/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style/main.scss":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style/main.scss ***!
  \**********************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ../../../../../../../src/assets/fonts/Expansiva/Expansiva.otf */ "./src/assets/fonts/Expansiva/Expansiva.otf"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! ../../../../../../../src/assets/fonts/expansiva/Expansiva-bold.otf */ "./src/assets/fonts/expansiva/Expansiva-bold.otf"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(/*! ../../../../../../../src/assets/fonts/Arkitech/Arkitech-Light.ttf */ "./src/assets/fonts/Arkitech/Arkitech-Light.ttf"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(/*! ../../../../../../../src/assets/fonts/Arkitech/Arkitech-Medium.ttf */ "./src/assets/fonts/Arkitech/Arkitech-Medium.ttf"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_4___ = new URL(/* asset import */ __webpack_require__(/*! ../../../../../../../src/assets/images/backgrounds/PiotrBania.svg */ "./src/assets/images/backgrounds/PiotrBania.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_5___ = new URL(/* asset import */ __webpack_require__(/*! ../../../../../../../src/assets/images/backgrounds/Portfolio.svg */ "./src/assets/images/backgrounds/Portfolio.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_6___ = new URL(/* asset import */ __webpack_require__(/*! ../../../../../../../src/assets/images/backgrounds/Lab.svg */ "./src/assets/images/backgrounds/Lab.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_7___ = new URL(/* asset import */ __webpack_require__(/*! ../../../../../../../src/assets/images/backgrounds/Skills.svg */ "./src/assets/images/backgrounds/Skills.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_8___ = new URL(/* asset import */ __webpack_require__(/*! ../../../../../../../src/assets/images/backgrounds/About.svg */ "./src/assets/images/backgrounds/About.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_9___ = new URL(/* asset import */ __webpack_require__(/*! ../../../../../../../src/assets/images/backgrounds/contact.svg */ "./src/assets/images/backgrounds/contact.svg"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);
var ___CSS_LOADER_URL_REPLACEMENT_4___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_4___);
var ___CSS_LOADER_URL_REPLACEMENT_5___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_5___);
var ___CSS_LOADER_URL_REPLACEMENT_6___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_6___);
var ___CSS_LOADER_URL_REPLACEMENT_7___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_7___);
var ___CSS_LOADER_URL_REPLACEMENT_8___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_8___);
var ___CSS_LOADER_URL_REPLACEMENT_9___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_9___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@font-face {\n  font-family: \"Expansiva\";\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n}\n@font-face {\n  font-family: \"Expansiva Bold\";\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");\n}\n@font-face {\n  font-family: \"Arkitech Light\";\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ");\n}\n@font-face {\n  font-family: \"Arkitech Medium\";\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ");\n}\n:root {\n  --purple: #7161F5;\n  --green: #61F570;\n  --red: #F57061;\n  --darker: #040117;\n  --dark: #07032E;\n  --light: #EBE8FE;\n  --lighter: #FFFFFF;\n  --background-text: rgba(113, 97, 245, 0.05);\n  --grey-text: #ABABAB;\n  --body-font: \"obvia\";\n  --header-font: \"Arkitech Light\";\n  --header-font-bold: \"Arkitech Medium\";\n  --header-alternative: \"Expansiva\";\n  --header-alternative-bold: \"Expansiva Bold\";\n  --links-font-size: 12px;\n  --text-font-size: 16px;\n  --main-shadow:\n      2.8px 2.8px 2.2px rgba(0, 0, 0, 0.07),\n      6.7px 6.7px 5.3px rgba(0, 0, 0, 0.05),\n      12.5px 12.5px 10px rgba(0, 0, 0, 0.042),\n      22.3px 22.3px 17.9px rgba(0, 0, 0, 0.035),\n      41.8px 41.8px 33.4px rgba(0, 0, 0, 0.028),\n      100px 100px 80px rgba(0, 0, 0, 0.02);\n  --hover-shadow:\n      2.8px 2.8px 2.2px rgba(0, 0, 0, 0.1),\n      6.7px 6.7px 5.3px rgba(0, 0, 0, 0.072),\n      12.5px 12.5px 10px rgba(0, 0, 0, 0.06),\n      22.3px 22.3px 17.9px rgba(0, 0, 0, 0.05),\n      41.8px 41.8px 33.4px rgba(0, 0, 0, 0.04),\n      100px 100px 80px rgba(0, 0, 0, 0.028);\n  --animate-duration: 1s;\n  --animate-delay: 1s;\n  --animate-repeat: 1;\n}\n\n*,\n*::before,\n*::after {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n  text-decoration: none;\n  list-style: none;\n}\n\nhtml {\n  box-sizing: inherit;\n  scroll-behavior: smooth;\n  margin: auto;\n}\n\nbody {\n  font-family: var(--body-font);\n  font-size: var(--text-font-size);\n  line-height: 1.6;\n  color: var(--light);\n  user-select: none;\n}\n\nh1 {\n  font-family: var(--header-alternative);\n  font-size: 2.074rem;\n  line-height: 1.2;\n  color: var(--light);\n  padding-bottom: 10px;\n}\n\nh2 {\n  font-family: var(--header-alternative);\n  font-size: 1.728rem;\n  line-height: 1.2;\n  color: var(--grey-text);\n  padding-bottom: 10px;\n}\n\nh3 {\n  font-family: var(--header-alternative);\n  font-size: 1.44rem;\n  line-height: 1.2;\n  color: var(--red);\n  padding-bottom: 10px;\n}\n\np {\n  font-family: var(--body-font);\n  font-size: var(--text-font-size);\n  line-height: 1.6;\n}\n\na {\n  text-shadow: var(--main-shadow);\n  font-family: var(--header-font);\n  font-size: var(--links-font-size);\n  color: var(--grey-text);\n  transition: all 0.3s ease-in-out;\n}\n\na:hover {\n  color: var(--green);\n}\n\nsection {\n  min-height: 100vh;\n  min-width: 100vw;\n  overflow: hidden;\n  display: flex;\n  padding: 75px 0;\n  align-items: center;\n  justify-content: center;\n  flex-wrap: wrap;\n  position: relative;\n}\n\n.container {\n  display: grid;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  width: 80%;\n  margin: 0 auto;\n  max-width: 1468px;\n  z-index: 80;\n}\n\n#section-a {\n  height: 100vh;\n}\n#section-a .container {\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + ");\n}\n#section-a h1 {\n  color: var(--light);\n}\n\n#section-b .container {\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_5___ + ");\n}\n\n#section-c .container {\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_6___ + ");\n}\n\n#section-d .container {\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_7___ + ");\n}\n\n#section-e .container {\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_8___ + ");\n}\n\n#section-f .container {\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_9___ + ");\n}\n\n#section-a {\n  background: linear-gradient(to right, var(--darker), var(--dark));\n}\n#section-a .container {\n  background-position: left;\n  background-repeat: no-repeat;\n  background-size: contain;\n}\n\n#section-b,\n#section-d,\n#section-f {\n  background: linear-gradient(to left, var(--darker), var(--dark));\n  padding-top: 100px;\n  padding-bottom: 100px;\n}\n#section-b .container,\n#section-d .container,\n#section-f .container {\n  background-position: left;\n  background-repeat: no-repeat;\n  background-size: contain;\n}\n\n#section-c,\n#section-e {\n  background-image: linear-gradient(to left, var(--lighter), var(--light));\n  padding-top: 100px;\n  padding-bottom: 100px;\n}\n#section-c .container,\n#section-e .container {\n  background-position: right;\n  background-repeat: no-repeat;\n  background-size: contain;\n}\n#section-c h1,\n#section-c p,\n#section-e h1,\n#section-e p {\n  color: var(--dark);\n}\n\n.logo {\n  position: fixed;\n  width: 70px;\n  height: 70px;\n  left: 5%;\n  top: 5%;\n  z-index: 100;\n}\n\n.menu {\n  position: fixed;\n  width: 100%;\n  right: 10vw;\n  top: 57px;\n  z-index: 90;\n  display: flex;\n  justify-content: end;\n  align-content: center;\n  visibility: visible;\n}\n.menu ul {\n  display: flex;\n  padding-top: 9px;\n}\n.menu ul li {\n  padding-right: 3vw;\n}\n\n.open-menu {\n  position: fixed;\n  right: 5%;\n  top: 5%;\n  width: 60px;\n  height: 60px;\n  padding: 7px;\n  cursor: pointer;\n  z-index: 98;\n  visibility: hidden;\n}\n\n.closed-menu {\n  position: fixed;\n  right: 5%;\n  top: 5%;\n  width: 60px;\n  height: 60px;\n  padding: 7px;\n  cursor: pointer;\n  z-index: 98;\n  visibility: hidden;\n}\n\n#nav-content {\n  position: fixed;\n  right: 0;\n  top: 0;\n  width: 75%;\n  height: 100%;\n  max-width: 600px;\n  z-index: 99;\n  background: linear-gradient(90deg, var(--dark) 0%, var(--darker) 100%);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  overflow: hidden;\n  transform: translateX(105%);\n  transition: 0.5s ease transform;\n  visibility: hidden;\n}\n#nav-content a {\n  display: inline-block;\n  width: 100%;\n  color: var(--light);\n  transition: all 0.3s ease-in-out;\n}\n#nav-content a:hover {\n  color: var(--green);\n}\n\n#nav-content.show {\n  transform: translateX(0);\n  box-shadow: 0px 0px 7.8px rgba(0, 0, 0, 0.053), 0px 0px 17.2px rgba(0, 0, 0, 0.078), 0px 0px 28.8px rgba(0, 0, 0, 0.096), 0px 0px 43.4px rgba(0, 0, 0, 0.111), 0px 0px 62.6px rgba(0, 0, 0, 0.125), 0px 0px 88.6px rgba(0, 0, 0, 0.139), 0px 0px 125.7px rgba(0, 0, 0, 0.154), 0px 0px 182.5px rgba(0, 0, 0, 0.172), 0px 0px 281.3px rgba(0, 0, 0, 0.197), 0px 0px 500px rgba(0, 0, 0, 0.25);\n}\n\n#nav-content .section-heading {\n  text-align: left;\n  font-size: 1.65rem;\n  font-family: var(--header-font);\n  color: var(--purple);\n  padding-bottom: 20px;\n}\n\n#nav-content .wrapper {\n  width: 70%;\n  position: relative;\n}\n\n#nav-content .closed-menu {\n  position: absolute;\n  left: 5%;\n  top: 5%;\n  transition: 0.3s ease-in-out;\n}\n\n.canvas-1 {\n  position: fixed;\n  top: 0;\n  max-width: 100%;\n  max-height: 100%;\n}\n\nstrong {\n  font-family: var(--header-alternative);\n  color: var(--green);\n}\n\nb {\n  font-family: var(--header-alternative-bold);\n  color: var(--green);\n}\n\nspan {\n  color: var(--purple);\n}\n\n.text {\n  color: var(--light);\n}\n\n.cursor {\n  color: var(--green);\n}\n\n#section-a .container {\n  grid-template-columns: repeat(12, 1fr);\n  grid-template-rows: repeat(2, 1fr);\n}\n#section-a .container .heroText {\n  grid-area: 2/2/3/9;\n}\n#section-a .container .upper-heading {\n  padding-bottom: 10px;\n}\n#section-a .container .lower-heading {\n  padding-bottom: 20px;\n}\n\n#section-b .container {\n  grid-template-columns: repeat(12, 1fr);\n  grid-template-rows: repeat(11);\n}\n#section-b .container .current,\n#section-b .container .other {\n  padding-top: 50px;\n  padding-bottom: 100px;\n}\n#section-b .container .project {\n  padding-bottom: 50px;\n  z-index: 50;\n}\n#section-b .container .project img {\n  width: 80%;\n  margin-left: 20%;\n  border: 1px solid var(--purple);\n  border-radius: 20px;\n  opacity: 0.66;\n  filter: grayscale(100%);\n  transition: all 0.3s ease-in-out;\n}\n#section-b .container .project img:hover {\n  opacity: 1;\n  filter: grayscale(0%);\n  border-color: var(--green);\n}\n#section-b .container .project ul {\n  display: flex;\n  justify-content: space-between;\n  margin-left: 10%;\n  word-spacing: 5px;\n}\n#section-b .container .project ul a {\n  padding-left: 50px;\n}\n#section-b .container .current {\n  grid-area: 1/3/2/12;\n}\n#section-b .container .project1 {\n  grid-area: 2/1/4/5;\n}\n#section-b .container .project2 {\n  grid-area: 3/9/5/15;\n}\n#section-b .container .project3 {\n  grid-area: 4/4/6/8;\n}\n#section-b .container .other {\n  grid-area: 6/3/7/12;\n}\n#section-b .container .project4 {\n  grid-area: 7/1/9/5;\n}\n#section-b .container .project5 {\n  grid-area: 8/9/10/15;\n}\n#section-b .container .project6 {\n  grid-area: 9/4/11/8;\n}\n\n#section-c .container {\n  grid-template-columns: repeat(12, 1fr);\n  grid-template-rows: repeat(2);\n}\n#section-c .container .lab {\n  grid-area: 1/3/2/12;\n  padding-top: 50px;\n  padding-bottom: 100px;\n}\n#section-c .container .labProject {\n  padding-bottom: 50px;\n  margin: auto;\n}\n#section-c .container .labProject img {\n  width: 80%;\n  margin-left: 10%;\n  border: 1px solid var(--purple);\n  border-radius: 20px;\n  opacity: 0.66;\n  filter: grayscale(100%);\n  transition: all 0.3s ease-in-out;\n}\n#section-c .container .labProject img:hover {\n  opacity: 1;\n  filter: grayscale(0%);\n  border-color: var(--green);\n}\n#section-c .container .labProject ul {\n  display: flex;\n  justify-content: space-between;\n  margin-right: 10%;\n  word-spacing: 5px;\n}\n#section-c .container .labProject ul a {\n  padding-left: 50px;\n}\n#section-c .container .lab1 {\n  grid-area: 2/1/3/5;\n}\n#section-c .container .lab2 {\n  grid-area: 2/5/3/9;\n}\n#section-c .container .lab3 {\n  grid-area: 2/9/3/14;\n}\n\n#section-e .vl {\n  border-left: 2px solid var(--purple);\n  height: 300px;\n  position: absolute;\n}\n#section-e p {\n  position: relative;\n  left: 20px;\n  max-width: 80%;\n  display: inline;\n}\n#section-e .purple {\n  color: var(--purple);\n}\n#section-e .purple-blue {\n  color: var(--purple-blue);\n}\n#section-e .blue-turquoise {\n  color: var(--blue-turquoise);\n}\n#section-e .red {\n  color: var(--red);\n}\n#section-e .green {\n  color: var(--green);\n}\n#section-e .grey {\n  color: var(--grey-text);\n}\n\nbutton {\n  font-family: var(--header-font);\n  font-size: var(--links-font-size);\n  color: var(--light);\n  border-radius: 30px 10px 20px 10px;\n  padding: 15px 30px;\n  justify-content: center;\n  text-align: center;\n  text-shadow: var(--main-shadow);\n  white-space: nowrap;\n  border: 1px solid var(--dark);\n  background: linear-gradient(-45deg, #7161F5 0%, #0E065C 100%);\n  background-size: 400% 400%;\n  animation: animate 5s ease-in-out infinite;\n  transition: all 0.3s ease-in-out;\n  box-shadow: var(--main-shadow);\n}\nbutton:hover {\n  cursor: pointer;\n  border: 1px solid #0AA119;\n  background: linear-gradient(-45deg, #61F570 0%, #0AA119 100%);\n  box-shadow: var(--hover-shadow);\n  text-shadow: var(--hover-shadow);\n}\n\n@keyframes animate {\n  0% {\n    background-position: 0 50%;\n  }\n  50% {\n    background-position: 100% 50%;\n  }\n  100% {\n    background-position: 0 50%;\n  }\n}\n.progressSection {\n  position: fixed;\n  right: 5%;\n  bottom: 5%;\n  width: 1px;\n  height: 150px;\n  display: flex;\n  justify-content: space-between;\n  will-change: transform;\n  transition: 0.3s ease-in-out;\n  z-index: 90;\n}\n\n.progressBarWrap {\n  position: relative;\n  width: 1px;\n  border: none;\n  border-radius: 10px;\n  overflow: hidden;\n  background-color: var(--purple);\n  box-shadow: var(--main-shadow);\n}\n\n.progressBar {\n  position: absolute;\n  transform: translateX(-1px);\n  bottom: 0;\n  width: 3px;\n  border: 1px solid var(--green);\n  border-radius: 10px;\n  height: 0%;\n  background-color: var(--green);\n  box-shadow: var(--main-shadow);\n}\n\n.progressNum {\n  font-family: var(--header-font);\n  font-size: var(--links-font-size);\n  color: var(--grey-text);\n  position: fixed;\n  right: 10px;\n  bottom: 0;\n}\n\n.strip {\n  position: fixed;\n  width: 1px;\n  height: 100vh;\n  background: linear-gradient(0deg, rgba(113, 97, 245, 0) 0%, rgba(113, 97, 245, 0.3019607843) 100%);\n  z-index: 50;\n}\n\n.one {\n  left: 26.66%;\n  top: 0;\n}\n\n.two {\n  left: 50%;\n  top: 0;\n}\n\n.three {\n  right: 26.66%;\n  top: 0;\n}\n\n@media screen and (min-width: 769px) and (max-width: 1279px) {\n  h1 {\n    font-size: 1.602rem;\n  }\n\n  h2 {\n    font-size: 1.424rem;\n  }\n\n  h3 {\n    font-size: 1.266rem;\n  }\n\n  p {\n    font-size: calc(var(--text-font-size) - 1px);\n  }\n\n  button {\n    font-size: calc(var(--links-font-size) - 1px);\n    border-radius: 28px 9px 18px 9px;\n    padding: 13px 26px;\n  }\n\n  #section-a .container {\n    grid-template-columns: repeat(12, 1fr);\n    grid-template-rows: repeat(2, 1fr);\n  }\n  #section-a .container .heroText {\n    grid-area: 2/1/3/12;\n  }\n\n  #section-b .container {\n    grid-template-columns: repeat(12, 1fr);\n    grid-template-rows: repeat(12);\n  }\n  #section-b .container .current,\n#section-b .container .other {\n    padding-bottom: 100px;\n  }\n  #section-b .container .project {\n    padding-bottom: 50px;\n  }\n  #section-b .container .current {\n    grid-area: 1/2/2/12;\n  }\n  #section-b .container .project1 {\n    grid-area: 2/1/3/8;\n  }\n  #section-b .container .project2 {\n    grid-area: 3/6/4/15;\n  }\n  #section-b .container .project3 {\n    grid-area: 4/4/5/11;\n  }\n  #section-b .container .other {\n    grid-area: 5/2/6/12;\n  }\n  #section-b .container .project4 {\n    grid-area: 6/1/7/8;\n  }\n  #section-b .container .project5 {\n    grid-area: 7/6/8/15;\n  }\n  #section-b .container .project6 {\n    grid-area: 8/4/9/11;\n  }\n\n  #section-c .container {\n    grid-template-columns: repeat(12, 1fr);\n    grid-template-rows: repeat(6);\n  }\n  #section-c .container .lab1 {\n    grid-area: 2/1/3/7;\n  }\n  #section-c .container .lab2 {\n    grid-area: 2/7/3/13;\n  }\n  #section-c .container .lab3 {\n    grid-area: 3/4/4/10;\n  }\n\n  #section-c .container {\n    grid-template-columns: repeat(12, 1fr);\n    grid-template-rows: repeat(6);\n  }\n  #section-c .container .lab1 {\n    grid-area: 2/1/3/7;\n  }\n  #section-c .container .lab2 {\n    grid-area: 2/7/3/13;\n  }\n  #section-c .container .lab3 {\n    grid-area: 3/4/4/10;\n  }\n}\n@media screen and (max-width: 768px) {\n  .logo {\n    width: 50px;\n    height: 50px;\n  }\n\n  .menu {\n    visibility: hidden;\n  }\n\n  .open-menu,\n.closed-menu {\n    width: 50px;\n    height: 50px;\n    visibility: visible;\n  }\n\n  #nav-content {\n    visibility: visible;\n  }\n\n  #nav-content a {\n    font-size: 1.5rem;\n  }\n\n  h1 {\n    font-size: 1.296rem;\n  }\n\n  h2 {\n    font-size: 1.215rem;\n  }\n\n  h3 {\n    font-size: 1.138rem;\n  }\n\n  p {\n    font-size: calc(var(--text-font-size) - 2px);\n  }\n\n  button {\n    font-size: calc(var(--links-font-size) - 2px);\n    border-radius: 26px 8px 16px 8px;\n    padding: 12px 24px;\n  }\n\n  .heading {\n    width: 80%;\n    left: 10%;\n  }\n\n  .heroText {\n    left: 11%;\n    bottom: 16%;\n  }\n\n  .upper-heading {\n    padding-bottom: 10px;\n  }\n\n  .lower-heading {\n    padding-bottom: 20px;\n  }\n\n  #section-a .container {\n    grid-template-columns: repeat(12, 1fr);\n    grid-template-rows: repeat(2, 1fr);\n  }\n  #section-a .container .heroText {\n    grid-area: 2/1/3/15;\n  }\n\n  #section-b .container {\n    grid-template-columns: repeat(12, 1fr);\n    grid-template-rows: repeat(12);\n  }\n  #section-b .container .current,\n#section-b .container .other {\n    padding-bottom: 100px;\n  }\n  #section-b .container .project {\n    padding-bottom: 50px;\n  }\n  #section-b .container .project img {\n    margin-left: 10%;\n    opacity: 1;\n  }\n  #section-b .container .project ul {\n    margin-left: 0%;\n    margin-right: 10%;\n  }\n  #section-b .container .current {\n    grid-area: 1/1/2/15;\n  }\n  #section-b .container .project1 {\n    grid-area: 2/1/3/15;\n  }\n  #section-b .container .project2 {\n    grid-area: 3/1/4/15;\n  }\n  #section-b .container .project3 {\n    grid-area: 4/1/5/15;\n  }\n  #section-b .container .other {\n    grid-area: 5/1/6/15;\n  }\n  #section-b .container .project4 {\n    grid-area: 6/1/7/15;\n  }\n  #section-b .container .project5 {\n    grid-area: 7/1/8/15;\n  }\n  #section-b .container .project6 {\n    grid-area: 8/1/9/15;\n  }\n\n  #section-c .container {\n    grid-template-columns: repeat(12, 1fr);\n    grid-template-rows: repeat(12);\n  }\n  #section-c .container .lab1 {\n    grid-area: 2/1/3/15;\n  }\n  #section-c .container .lab2 {\n    grid-area: 3/1/4/15;\n  }\n  #section-c .container .lab3 {\n    grid-area: 4/1/5/15;\n  }\n  #section-c .container .labProject {\n    padding-bottom: 50px;\n  }\n  #section-c .container .labProject img {\n    margin-left: 10%;\n    opacity: 1;\n  }\n  #section-c .container .labProject ul {\n    margin-left: 0%;\n    margin-right: 10%;\n  }\n}", "",{"version":3,"sources":["webpack://./src/style/main.scss"],"names":[],"mappings":"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","sourcesContent":["@font-face {\r\n    font-family: \"Expansiva\";\r\n    src: url(/src/assets/fonts/Expansiva/Expansiva.otf);\r\n}\r\n\r\n@font-face {\r\n    font-family: \"Expansiva Bold\";\r\n    src: url(/src/assets/fonts/expansiva/Expansiva-bold.otf);\r\n\r\n}\r\n\r\n@font-face {\r\n    font-family: \"Arkitech Light\";\r\n    src: url(/src/assets/fonts/Arkitech/Arkitech-Light.ttf);\r\n}\r\n\r\n@font-face {\r\n    font-family: \"Arkitech Medium\";\r\n    src: url(/src/assets/fonts/Arkitech/Arkitech-Medium.ttf);\r\n}\r\n\r\n// ------------------------------ Variables ------------------------------\r\n\r\n:root {\r\n    // Colors\r\n    --purple: #7161F5;\r\n    --green: #61F570;\r\n    --red: #F57061;\r\n    --darker: #040117;\r\n    --dark: #07032E;\r\n    --light: #EBE8FE;\r\n    --lighter: #FFFFFF;\r\n    --background-text: rgba(113, 97, 245, 0.05);\r\n    --grey-text: #ABABAB;\r\n\r\n    // Font tyoe\r\n    --body-font: 'obvia';\r\n    --header-font: 'Arkitech Light';\r\n    --header-font-bold: 'Arkitech Medium';\r\n    --header-alternative: 'Expansiva';\r\n    --header-alternative-bold: 'Expansiva Bold';\r\n\r\n    // Font size\r\n    --links-font-size: 12px;\r\n    --text-font-size: 16px;\r\n\r\n    // Shadows\r\n    --main-shadow:\r\n        2.8px 2.8px 2.2px rgba(0, 0, 0, 0.07),\r\n        6.7px 6.7px 5.3px rgba(0, 0, 0, 0.05),\r\n        12.5px 12.5px 10px rgba(0, 0, 0, 0.042),\r\n        22.3px 22.3px 17.9px rgba(0, 0, 0, 0.035),\r\n        41.8px 41.8px 33.4px rgba(0, 0, 0, 0.028),\r\n        100px 100px 80px rgba(0, 0, 0, 0.02);\r\n    --hover-shadow:\r\n        2.8px 2.8px 2.2px rgba(0, 0, 0, 0.1),\r\n        6.7px 6.7px 5.3px rgba(0, 0, 0, 0.072),\r\n        12.5px 12.5px 10px rgba(0, 0, 0, 0.06),\r\n        22.3px 22.3px 17.9px rgba(0, 0, 0, 0.05),\r\n        41.8px 41.8px 33.4px rgba(0, 0, 0, 0.04),\r\n        100px 100px 80px rgba(0, 0, 0, 0.028);\r\n\r\n    // Animation\r\n    --animate-duration: 1s;\r\n    --animate-delay: 1s;\r\n    --animate-repeat: 1;\r\n}\r\n\r\n*,\r\n*::before,\r\n*::after {\r\n    box-sizing: border-box;\r\n    margin: 0;\r\n    padding: 0;\r\n    text-decoration: none;\r\n    list-style: none;\r\n}\r\n\r\nhtml {\r\n    box-sizing: inherit;\r\n    scroll-behavior: smooth;\r\n    margin: auto;\r\n}\r\n\r\nbody {\r\n    font-family: var(--body-font);\r\n    font-size: var(--text-font-size);\r\n    line-height: 1.6;\r\n    color: var(--light);\r\n    user-select: none;\r\n}\r\n\r\n// ------------------------------ Fonts ------------------------------\r\n\r\nh1 {\r\n    font-family: var(--header-alternative);\r\n    font-size: 2.074rem;\r\n    line-height: 1.2;\r\n    color: var(--light);\r\n    padding-bottom: 10px;\r\n}\r\n\r\nh2 {\r\n    font-family: var(--header-alternative);\r\n    font-size: 1.728rem;\r\n    line-height: 1.2;\r\n    color: var(--grey-text);\r\n    padding-bottom: 10px;\r\n}\r\n\r\nh3 {\r\n    font-family: var(--header-alternative);\r\n    font-size: 1.44rem;\r\n    line-height: 1.2;\r\n    color: var(--red);\r\n    padding-bottom: 10px;\r\n}\r\n\r\np {\r\n    font-family: var(--body-font);\r\n    font-size: var(--text-font-size);\r\n    line-height: 1.6;\r\n}\r\n\r\na {\r\n    text-shadow: var(--main-shadow);\r\n    font-family: var(--header-font);\r\n    font-size: var(--links-font-size);\r\n    color: var(--grey-text);\r\n    transition: all 0.3s ease-in-out;\r\n}\r\n\r\na:hover {\r\n    color: var(--green);\r\n}\r\n\r\n// ------------------------------ Sections ------------------------------\r\n\r\nsection {\r\n    min-height: 100vh;\r\n    min-width: 100vw;\r\n    overflow: hidden;\r\n    display: flex;\r\n    padding: 75px 0;\r\n    align-items: center;\r\n    justify-content: center;\r\n    flex-wrap: wrap;\r\n    position: relative;\r\n}\r\n\r\n.container {\r\n    display: grid;\r\n    align-items: center;\r\n    justify-content: center;\r\n    height: 100%;\r\n    width: 80%;\r\n    margin: 0 auto;\r\n    max-width: 1468px;\r\n    z-index: 80;\r\n}\r\n\r\n#section-a {\r\n    height: 100vh;\r\n\r\n    .container {\r\n        background-image: url(/src/assets/images/backgrounds/PiotrBania.svg);\r\n    }\r\n\r\n    h1 {\r\n        color: var(--light);\r\n    }\r\n}\r\n\r\n#section-b {\r\n    .container {\r\n        background-image: url(/src//assets/images/backgrounds/Portfolio.svg);\r\n    }\r\n}\r\n\r\n#section-c {\r\n    .container {\r\n        background-image: url(/src//assets/images/backgrounds/Lab.svg);\r\n    }\r\n}\r\n\r\n#section-d {\r\n    .container {\r\n        background-image: url(/src//assets/images/backgrounds/Skills.svg);\r\n    }\r\n}\r\n\r\n#section-e {\r\n    .container {\r\n        background-image: url(/src//assets/images/backgrounds/About.svg);\r\n    }\r\n}\r\n\r\n#section-f {\r\n    .container {\r\n        background-image: url(/src//assets/images/backgrounds/contact.svg);\r\n    }\r\n}\r\n\r\n#section-a {\r\n    background: linear-gradient(to right, var(--darker), var(--dark));\r\n\r\n    .container {\r\n        background-position: left;\r\n        background-repeat: no-repeat;\r\n        background-size: contain;\r\n    }\r\n}\r\n\r\n#section-b,\r\n#section-d,\r\n#section-f {\r\n    background: linear-gradient(to left, var(--darker), var(--dark));\r\n    padding-top: 100px;\r\n    padding-bottom: 100px;\r\n\r\n    .container {\r\n        background-position: left;\r\n        background-repeat: no-repeat;\r\n        background-size: contain;\r\n    }\r\n}\r\n\r\n#section-c,\r\n#section-e {\r\n    background-image: linear-gradient(to left, var(--lighter), var(--light));\r\n    padding-top: 100px;\r\n    padding-bottom: 100px;\r\n\r\n    .container {\r\n        background-position: right;\r\n        background-repeat: no-repeat;\r\n        background-size: contain;\r\n    }\r\n\r\n    h1,\r\n    p {\r\n        color: var(--dark);\r\n    }\r\n}\r\n\r\n// ------------------------------ Header ------------------------------\r\n\r\n.logo {\r\n    position: fixed;\r\n    width: 70px;\r\n    height: 70px;\r\n    left: 5%;\r\n    top: 5%;\r\n    z-index: 100;\r\n}\r\n\r\n.menu {\r\n    position: fixed;\r\n    width: 100%;\r\n    right: 10vw;\r\n    top: 57px;\r\n    z-index: 90;\r\n    display: flex;\r\n    justify-content: end;\r\n    align-content: center;\r\n    visibility: visible;\r\n\r\n    ul {\r\n        display: flex;\r\n        padding-top: 9px;\r\n\r\n        li {\r\n            padding-right: 3vw;\r\n        }\r\n    }\r\n}\r\n\r\n.open-menu {\r\n    position: fixed;\r\n    right: 5%;\r\n    top: 5%;\r\n    width: 60px;\r\n    height: 60px;\r\n    padding: 7px;\r\n    cursor: pointer;\r\n    z-index: 98;\r\n    visibility: hidden;\r\n}\r\n\r\n.closed-menu {\r\n    position: fixed;\r\n    right: 5%;\r\n    top: 5%;\r\n    width: 60px;\r\n    height: 60px;\r\n    padding: 7px;\r\n    cursor: pointer;\r\n    z-index: 98;\r\n    visibility: hidden;\r\n}\r\n\r\n#nav-content {\r\n    position: fixed;\r\n    right: 0;\r\n    top: 0;\r\n    width: 75%;\r\n    height: 100%;\r\n    max-width: 600px;\r\n    z-index: 99;\r\n    background: linear-gradient(90deg, var(--dark) 0%, var(--darker) 100%);\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    overflow: hidden;\r\n    transform: translateX(105%);\r\n    transition: 0.5s ease transform;\r\n    visibility: hidden;\r\n\r\n    a {\r\n        display: inline-block;\r\n        width: 100%;\r\n        color: var(--light);\r\n        transition: all 0.3s ease-in-out;\r\n    }\r\n\r\n    a:hover {\r\n        color: var(--green);\r\n    }\r\n}\r\n\r\n#nav-content.show {\r\n    transform: translateX(0);\r\n    box-shadow:\r\n        0px 0px 7.8px rgba(0, 0, 0, 0.053),\r\n        0px 0px 17.2px rgba(0, 0, 0, 0.078),\r\n        0px 0px 28.8px rgba(0, 0, 0, 0.096),\r\n        0px 0px 43.4px rgba(0, 0, 0, 0.111),\r\n        0px 0px 62.6px rgba(0, 0, 0, 0.125),\r\n        0px 0px 88.6px rgba(0, 0, 0, 0.139),\r\n        0px 0px 125.7px rgba(0, 0, 0, 0.154),\r\n        0px 0px 182.5px rgba(0, 0, 0, 0.172),\r\n        0px 0px 281.3px rgba(0, 0, 0, 0.197),\r\n        0px 0px 500px rgba(0, 0, 0, 0.25);\r\n}\r\n\r\n#nav-content .section-heading {\r\n    text-align: left;\r\n    font-size: 1.65rem;\r\n    font-family: var(--header-font);\r\n    color: var(--purple);\r\n    padding-bottom: 20px;\r\n}\r\n\r\n#nav-content .wrapper {\r\n    width: 70%;\r\n    position: relative;\r\n}\r\n\r\n#nav-content .closed-menu {\r\n    position: absolute;\r\n    left: 5%;\r\n    top: 5%;\r\n    transition: 0.3s ease-in-out;\r\n}\r\n\r\n// ------------------------------ Canvas ------------------------------\r\n\r\n.canvas-1 {\r\n    position: fixed;\r\n    top: 0;\r\n    max-width: 100%;\r\n    max-height: 100%;\r\n}\r\n\r\n// ------------------------------ Hero section ------------------------------\r\n\r\nstrong {\r\n    font-family: var(--header-alternative);\r\n    color: var(--green);\r\n}\r\n\r\nb {\r\n    font-family: var(--header-alternative-bold);\r\n    color: var(--green);\r\n}\r\n\r\nspan {\r\n    color: var(--purple);\r\n}\r\n\r\n.text {\r\n    color: var(--light);\r\n}\r\n\r\n.cursor {\r\n    color: var(--green);\r\n}\r\n\r\n#section-a {\r\n    .container {\r\n        grid-template-columns: repeat(12, 1fr);\r\n        grid-template-rows: repeat(2, 1fr);\r\n\r\n        .heroText {\r\n            grid-area: 2 / 2 / 3 / 9;\r\n        }\r\n\r\n        .upper-heading {\r\n            padding-bottom: 10px;\r\n        }\r\n\r\n        .lower-heading {\r\n            padding-bottom: 20px;\r\n        }\r\n    }\r\n}\r\n\r\n// ------------------------------ Portfolio section ------------------------------\r\n\r\n#section-b {\r\n    .container {\r\n        grid-template-columns: repeat(12, 1fr);\r\n        grid-template-rows: repeat(11);\r\n\r\n        .current,\r\n        .other {\r\n            padding-top: 50px;\r\n            padding-bottom: 100px;\r\n        }\r\n\r\n        .project {\r\n            padding-bottom: 50px;\r\n            z-index: 50;\r\n\r\n            img {\r\n                width: 80%;\r\n                margin-left: 20%;\r\n                border: 1px solid var(--purple);\r\n                border-radius: 20px;\r\n                opacity: 0.66;\r\n                filter: grayscale(100%);\r\n                transition: all 0.3s ease-in-out;\r\n            }\r\n\r\n            img:hover {\r\n                opacity: 1;\r\n                filter: grayscale(0%);\r\n                border-color: var(--green);\r\n            }\r\n\r\n            ul {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                margin-left: 10%;\r\n                word-spacing: 5px;\r\n\r\n                a {\r\n                    padding-left: 50px;\r\n                }\r\n            }\r\n        }\r\n\r\n        .current {\r\n            grid-area: 1 / 3 / 2 / 12;\r\n        }\r\n\r\n        .project1 {\r\n            grid-area: 2 / 1 / 4 / 5;\r\n        }\r\n\r\n        .project2 {\r\n            grid-area: 3 / 9 / 5 / 15;\r\n        }\r\n\r\n        .project3 {\r\n            grid-area: 4 / 4 / 6 / 8;\r\n        }\r\n\r\n        .other {\r\n            grid-area: 6 / 3 / 7 / 12;\r\n        }\r\n\r\n        .project4 {\r\n            grid-area: 7 / 1 / 9 / 5;\r\n        }\r\n\r\n        .project5 {\r\n            grid-area: 8 / 9 / 10 / 15;\r\n        }\r\n\r\n        .project6 {\r\n            grid-area: 9 / 4 / 11 / 8;\r\n        }\r\n    }\r\n}\r\n\r\n// ------------------------------ Lab section ------------------------------\r\n\r\n#section-c {\r\n    .container {\r\n        grid-template-columns: repeat(12, 1fr);\r\n        grid-template-rows: repeat(2);\r\n\r\n        .lab {\r\n            grid-area: 1 / 3 / 2 / 12;\r\n            padding-top: 50px;\r\n            padding-bottom: 100px;\r\n        }\r\n\r\n        .labProject {\r\n            padding-bottom: 50px;\r\n            margin: auto;\r\n\r\n            img {\r\n                width: 80%;\r\n                margin-left: 10%;\r\n                border: 1px solid var(--purple);\r\n                border-radius: 20px;\r\n                opacity: 0.66;\r\n                filter: grayscale(100%);\r\n                transition: all 0.3s ease-in-out;\r\n            }\r\n\r\n            img:hover {\r\n                opacity: 1;\r\n                filter: grayscale(0%);\r\n                border-color: var(--green);\r\n            }\r\n\r\n            ul {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                margin-right: 10%;\r\n                word-spacing: 5px;\r\n\r\n                a {\r\n                    padding-left: 50px;\r\n                }\r\n            }\r\n        }\r\n\r\n        .lab1 {\r\n            grid-area: 2 / 1 / 3 / 5;\r\n        }\r\n\r\n        .lab2 {\r\n            grid-area: 2 / 5 / 3 / 9;\r\n        }\r\n\r\n        .lab3 {\r\n            grid-area: 2 / 9 / 3 / 14;\r\n        }\r\n    }\r\n}\r\n\r\n// ------------------------------ About section ------------------------------\r\n\r\n#section-e {\r\n    .vl {\r\n        border-left: 2px solid var(--purple);\r\n        height: 300px;\r\n        position: absolute;\r\n    }\r\n\r\n    p {\r\n        position: relative;\r\n        left: 20px;\r\n        max-width: 80%;\r\n        display: inline;\r\n\r\n    }\r\n\r\n    .purple {\r\n        color: var(--purple);\r\n    }\r\n\r\n    .purple-blue {\r\n        color: var(--purple-blue);\r\n    }\r\n\r\n    .blue-turquoise {\r\n        color: var(--blue-turquoise);\r\n    }\r\n\r\n    .red {\r\n        color: var(--red);\r\n    }\r\n\r\n    .green {\r\n        color: var(--green);\r\n    }\r\n\r\n    .grey {\r\n        color: var(--grey-text);\r\n    }\r\n}\r\n\r\n// ------------------------------ Buttons ------------------------------\r\n\r\nbutton {\r\n    font-family: var(--header-font);\r\n    font-size: var(--links-font-size);\r\n    color: var(--light);\r\n    border-radius: 30px 10px 20px 10px;\r\n    padding: 15px 30px;\r\n    justify-content: center;\r\n    text-align: center;\r\n    text-shadow: var(--main-shadow);\r\n    white-space: nowrap;\r\n    border: 1px solid var(--dark);\r\n    background: linear-gradient(-45deg, #7161F5 0%, #0E065C 100%);\r\n    background-size: 400% 400%;\r\n    animation: animate 5s ease-in-out infinite;\r\n    transition: all 0.3s ease-in-out;\r\n    box-shadow: var(--main-shadow);\r\n\r\n    &:hover {\r\n        cursor: pointer;\r\n        border: 1px solid #0AA119;\r\n        background: linear-gradient(-45deg, #61F570 0%, #0AA119 100%);\r\n        box-shadow: var(--hover-shadow);\r\n        text-shadow: var(--hover-shadow);\r\n    }\r\n}\r\n\r\n@keyframes animate {\r\n    0% {\r\n        background-position: 0 50%;\r\n    }\r\n\r\n    50% {\r\n        background-position: 100% 50%;\r\n    }\r\n\r\n    100% {\r\n        background-position: 0 50%;\r\n    }\r\n}\r\n\r\n// ------------------------------ Progress bar ------------------------------\r\n\r\n.progressSection {\r\n    position: fixed;\r\n    right: 5%;\r\n    bottom: 5%;\r\n    width: 1px;\r\n    height: 150px;\r\n    display: flex;\r\n    justify-content: space-between;\r\n    will-change: transform;\r\n    transition: 0.3s ease-in-out;\r\n    z-index: 90;\r\n}\r\n\r\n.progressBarWrap {\r\n    position: relative;\r\n    width: 1px;\r\n    border: none;\r\n    border-radius: 10px;\r\n    overflow: hidden;\r\n    background-color: var(--purple);\r\n    box-shadow: var(--main-shadow);\r\n}\r\n\r\n.progressBar {\r\n    position: absolute;\r\n    transform: translateX(-1px);\r\n    bottom: 0;\r\n    width: 3px;\r\n    border: 1px solid var(--green);\r\n    border-radius: 10px;\r\n    height: 0%;\r\n    background-color: var(--green);\r\n    box-shadow: var(--main-shadow);\r\n}\r\n\r\n.progressNum {\r\n    font-family: var(--header-font);\r\n    font-size: var(--links-font-size);\r\n    color: var(--grey-text);\r\n    position: fixed;\r\n    right: 10px;\r\n    bottom: 0;\r\n}\r\n\r\n// ------------------------------ Strips ------------------------------\r\n\r\n.strip {\r\n    position: fixed;\r\n    width: 1px;\r\n    height: 100vh;\r\n    background: linear-gradient(0deg, #7161F500 0%, #7161F54D 100%);\r\n    z-index: 50;\r\n}\r\n\r\n.one {\r\n    left: 26.66%;\r\n    top: 0;\r\n}\r\n\r\n.two {\r\n    left: 50%;\r\n    top: 0;\r\n}\r\n\r\n.three {\r\n    right: 26.66%;\r\n    top: 0;\r\n}\r\n\r\n// ------------------------------ Media queries ------------------------------\r\n\r\n@media screen and (min-width: 769px) and (max-width: 1279px) {\r\n    h1 {\r\n        font-size: 1.602rem;\r\n    }\r\n\r\n    h2 {\r\n        font-size: 1.424rem;\r\n    }\r\n\r\n    h3 {\r\n        font-size: 1.266rem;\r\n    }\r\n\r\n    p {\r\n        font-size: calc(var(--text-font-size) - 1px);\r\n    }\r\n\r\n    button {\r\n        font-size: calc(var(--links-font-size) - 1px);\r\n        border-radius: 28px 9px 18px 9px;\r\n        padding: 13px 26px;\r\n    }\r\n\r\n    #section-a {\r\n        .container {\r\n            grid-template-columns: repeat(12, 1fr);\r\n            grid-template-rows: repeat(2, 1fr);\r\n\r\n            .heroText {\r\n                grid-area: 2 / 1 / 3 / 12;\r\n            }\r\n        }\r\n    }\r\n\r\n    #section-b {\r\n        .container {\r\n            grid-template-columns: repeat(12, 1fr);\r\n            grid-template-rows: repeat(12);\r\n\r\n            .current,\r\n            .other {\r\n                padding-bottom: 100px;\r\n            }\r\n\r\n            .project {\r\n                padding-bottom: 50px;\r\n            }\r\n\r\n            .current {\r\n                grid-area: 1 / 2 / 2 / 12;\r\n            }\r\n\r\n            .project1 {\r\n                grid-area: 2 / 1 / 3 / 8;\r\n            }\r\n\r\n            .project2 {\r\n                grid-area: 3 / 6 / 4 / 15;\r\n            }\r\n\r\n            .project3 {\r\n                grid-area: 4 / 4 / 5 / 11;\r\n            }\r\n\r\n            .other {\r\n                grid-area: 5 / 2 / 6 / 12;\r\n            }\r\n\r\n            .project4 {\r\n                grid-area: 6 / 1 / 7 / 8;\r\n            }\r\n\r\n            .project5 {\r\n                grid-area: 7 / 6 / 8 / 15;\r\n            }\r\n\r\n            .project6 {\r\n                grid-area: 8 / 4 / 9 / 11;\r\n            }\r\n        }\r\n    }\r\n\r\n    #section-c {\r\n        .container {\r\n            grid-template-columns: repeat(12, 1fr);\r\n            grid-template-rows: repeat(6);\r\n\r\n            .lab1 {\r\n                grid-area: 2 / 1 / 3 / 7;\r\n            }\r\n\r\n            .lab2 {\r\n                grid-area: 2 / 7 / 3 / 13;\r\n            }\r\n\r\n            .lab3 {\r\n                grid-area: 3 / 4 / 4 / 10;\r\n            }\r\n        }\r\n    }\r\n\r\n    #section-c {\r\n        .container {\r\n            grid-template-columns: repeat(12, 1fr);\r\n            grid-template-rows: repeat(6);\r\n\r\n            .lab1 {\r\n                grid-area: 2 / 1 / 3 / 7;\r\n            }\r\n\r\n            .lab2 {\r\n                grid-area: 2 / 7 / 3 / 13;\r\n            }\r\n\r\n            .lab3 {\r\n                grid-area: 3 / 4 / 4 / 10;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@media screen and (max-width: 768px) {\r\n    .logo {\r\n        width: 50px;\r\n        height: 50px;\r\n    }\r\n\r\n    .menu {\r\n        visibility: hidden;\r\n    }\r\n\r\n    .open-menu,\r\n    .closed-menu {\r\n        width: 50px;\r\n        height: 50px;\r\n        visibility: visible;\r\n    }\r\n\r\n    #nav-content {\r\n        visibility: visible;\r\n    }\r\n\r\n    #nav-content a {\r\n        font-size: 1.5rem;\r\n    }\r\n\r\n    h1 {\r\n        font-size: 1.296rem;\r\n    }\r\n\r\n    h2 {\r\n        font-size: 1.215rem;\r\n    }\r\n\r\n    h3 {\r\n        font-size: 1.138rem;\r\n    }\r\n\r\n    p {\r\n        font-size: calc(var(--text-font-size) - 2px);\r\n    }\r\n\r\n    button {\r\n        font-size: calc(var(--links-font-size) - 2px);\r\n        border-radius: 26px 8px 16px 8px;\r\n        padding: 12px 24px;\r\n    }\r\n\r\n    .heading {\r\n        width: 80%;\r\n        left: 10%;\r\n    }\r\n\r\n    .heroText {\r\n        left: 11%;\r\n        bottom: 16%;\r\n    }\r\n\r\n    .upper-heading {\r\n        padding-bottom: 10px;\r\n    }\r\n\r\n    .lower-heading {\r\n        padding-bottom: 20px;\r\n    }\r\n\r\n    #section-a {\r\n        .container {\r\n            grid-template-columns: repeat(12, 1fr);\r\n            grid-template-rows: repeat(2, 1fr);\r\n\r\n            .heroText {\r\n                grid-area: 2 / 1 / 3 / 15;\r\n            }\r\n        }\r\n    }\r\n\r\n    #section-b {\r\n        .container {\r\n            grid-template-columns: repeat(12, 1fr);\r\n            grid-template-rows: repeat(12);\r\n\r\n            .current,\r\n            .other {\r\n                padding-bottom: 100px;\r\n            }\r\n\r\n            .project {\r\n                padding-bottom: 50px;\r\n\r\n                img {\r\n                    margin-left: 10%;\r\n                    opacity: 1;\r\n                }\r\n\r\n                ul {\r\n                    margin-left: 0%;\r\n                    margin-right: 10%;\r\n                }\r\n            }\r\n\r\n            .current {\r\n                grid-area: 1 / 1 / 2 / 15;\r\n            }\r\n\r\n            .project1 {\r\n                grid-area: 2 / 1 / 3 / 15;\r\n            }\r\n\r\n            .project2 {\r\n                grid-area: 3 / 1 / 4 / 15;\r\n            }\r\n\r\n            .project3 {\r\n                grid-area: 4 / 1 / 5 / 15;\r\n            }\r\n\r\n            .other {\r\n                grid-area: 5 / 1 / 6 / 15;\r\n            }\r\n\r\n            .project4 {\r\n                grid-area: 6 / 1 / 7 / 15;\r\n            }\r\n\r\n            .project5 {\r\n                grid-area: 7 / 1 / 8 / 15;\r\n            }\r\n\r\n            .project6 {\r\n                grid-area: 8 / 1 / 9 / 15;\r\n            }\r\n        }\r\n    }\r\n\r\n    #section-c {\r\n        .container {\r\n            grid-template-columns: repeat(12, 1fr);\r\n            grid-template-rows: repeat(12);\r\n\r\n            .lab1 {\r\n                grid-area: 2 / 1 / 3 / 15;\r\n            }\r\n\r\n            .lab2 {\r\n                grid-area: 3 / 1 / 4 / 15;\r\n            }\r\n\r\n            .lab3 {\r\n                grid-area: 4 / 1 / 5 / 15;\r\n            }\r\n\r\n            .labProject {\r\n                padding-bottom: 50px;\r\n\r\n                img {\r\n                    margin-left: 10%;\r\n                    opacity: 1;\r\n                }\r\n\r\n                ul {\r\n                    margin-left: 0%;\r\n                    margin-right: 10%;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {



module.exports = function (url, options) {
  if (!options) {
    options = {};
  }

  if (!url) {
    return url;
  }

  url = String(url.__esModule ? url.default : url); // If url is already wrapped in quotes, remove them

  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }

  if (options.hash) {
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }

  return url;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./src/particles/twirl_03.png":
/*!************************************!*\
  !*** ./src/particles/twirl_03.png ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "117e8d5c9ff1e99f38bae44bd3d8972c.png");

/***/ }),

/***/ "./node_modules/gsap/CSSPlugin.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/CSSPlugin.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSPlugin": () => (/* binding */ CSSPlugin),
/* harmony export */   "_createElement": () => (/* binding */ _createElement),
/* harmony export */   "_getBBox": () => (/* binding */ _getBBox),
/* harmony export */   "checkPrefix": () => (/* binding */ _checkPropPrefix),
/* harmony export */   "default": () => (/* binding */ CSSPlugin)
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/*!
 * CSSPlugin 3.10.2
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _win,
    _doc,
    _docElement,
    _pluginInitted,
    _tempDiv,
    _tempDivStyler,
    _recentSetterPlugin,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    _bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _horizontalExp = /(left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
},
    _renderCSSProp = function _renderCSSProp(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
},
    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
},
    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
},
    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
},
    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
  return target.style[property] = value;
},
    _setterCSSProp = function _setterCSSProp(target, property, value) {
  return target.style.setProperty(property, value);
},
    _setterTransform = function _setterTransform(target, property, value) {
  return target._gsap[property] = value;
},
    _setterScale = function _setterScale(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
},
    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
},
    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
},
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _supports3D,
    _createElement = function _createElement(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
},
    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
  var e = element || _tempDiv,
      s = e.style,
      i = 5;

  if (property in s && !preferPrefix) {
    return property;
  }

  property = property.charAt(0).toUpperCase() + property.substr(1);

  while (i-- && !(_prefixes[i] + property in s)) {}

  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
},
    _initCore = function _initCore() {
  if (_windowExists() && window.document) {
    _win = window;
    _doc = _win.document;
    _docElement = _doc.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _tempDivStyler = _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _transformProp + "Origin";
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

    _supports3D = !!_checkPropPrefix("perspective");
    _pluginInitted = 1;
  }
},
    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;

  _docElement.appendChild(svg);

  svg.appendChild(this);
  this.style.display = "block";

  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox; //store the original

      this.getBBox = _getBBoxHack;
    } catch (e) {}
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }

  if (oldParent) {
    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }
  }

  _docElement.removeChild(svg);

  this.style.cssText = oldCSS;
  return bbox;
},
    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
  var i = attributesArray.length;

  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
},
    _getBBox = function _getBBox(target) {
  var bounds;

  try {
    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  }

  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
},
    _isSVG = function _isSVG(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
},
    //reports if the element is an SVG on which getBBox() actually works
_removeProperty = function _removeProperty(target, property) {
  if (property) {
    var style = target.style;

    if (property in _transformProps && property !== _transformOriginProp) {
      property = _transformProp;
    }

    if (style.removeProperty) {
      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
        property = "-" + property;
      }

      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
      style.removeAttribute(property);
    }
  }
},
    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;

  plugin._props.push(property);

  return pt;
},
    _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
},
    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
_convertToUnit = function _convertToUnit(target, property, value, unit) {
  var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
  style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;

  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }

  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);

  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);
  }

  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }

  if (!parent || parent === _doc || !parent.appendChild) {
    parent = _doc.body;
  }

  cache = parent._gsap;

  if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time) {
    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount);
  } else {
    (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
    parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

    parent.appendChild(_tempDiv);
    px = _tempDiv[measureProperty];
    parent.removeChild(_tempDiv);
    style.position = "absolute";

    if (horizontal && toPercent) {
      cache = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);
      cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;
      cache.width = parent[measureProperty];
    }
  }

  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
},
    _get = function _get(target, property, unit, uncache) {
  var value;
  _pluginInitted || _initCore();

  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];

    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }

  if (_transformProps[property] && property !== "transform") {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];

    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
    }
  }

  return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
},
    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
  // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  if (!start || start === "none") {
    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
    var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty(target, p, 1);

    if (s && s !== start) {
      prop = p;
      start = s;
    } else if (prop === "borderColor") {
      start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
    }
  }

  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      endValues;
  pt.b = start;
  pt.e = end;
  start += ""; // ensure values are strings

  end += "";

  if (end === "auto") {
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    target.style[prop] = start;
  }

  a = [start, end];

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


  start = a[0];
  end = a[1];
  startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];
  endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];

  if (endValues.length) {
    while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }

      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        endValue.charAt(1) === "=" && (endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, endValue) + startUnit);
        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;

        if (!endUnit) {
          //if something like "perspective:300" is passed in and we must add a unit to the end
          endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;

          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }

        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
        } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum - startNum,
          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
        };
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }

  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
},
    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
  var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";

  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    //the user provided them in the wrong order, so flip them
    value = x;
    x = y;
    y = value;
  }

  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
},
    _renderClearProps = function _renderClearProps(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;

    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;

      while (--i > -1) {
        prop = props[i];

        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }

        _removeProperty(target, prop);
      }
    }

    if (clearTransforms) {
      _removeProperty(target, _transformProp);

      if (cache) {
        cache.svg && target.removeAttribute("transform");

        _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


        cache.uncache = 1;
      }
    }
  }
},
    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
_specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;

      plugin._props.push(property);

      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */

},

/*
 * --------------------------------------------------------------------------------------
 * TRANSFORMS
 * --------------------------------------------------------------------------------------
 */
_identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function _isNullTransform(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
},
    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
  var matrixString = _getComputedProperty(target, _transformProp);

  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round);
},
    _getMatrix = function _getMatrix(target, force2D) {
  var cache = target._gsap || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target),
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;

  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;

    if (!parent || !target.offsetParent) {
      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
      addedToDOM = 1; //flag

      nextSibling = target.nextSibling;

      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

    }

    matrix = _getComputedTransformMatrixAsArray(target);
    temp ? style.display = temp : _removeProperty(target, "display");

    if (addedToDOM) {
      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
    }
  }

  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
},
    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;

  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y;
  }

  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }

  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }

  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
},
    _parseTransform = function _parseTransform(target, uncache) {
  var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);

  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }

  var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));
  matrix = _getMatrix(target, cache.svg);

  if (cache.svg) {
    t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin"); // if origin is 0,0 and cache.uncache is true, let the recorded data-svg-origin stay. Otherwise, whenever we set cache.uncache to true, we'd need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.

    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
  }

  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;

  if (matrix !== _identity2DMatrix) {
    a = matrix[0]; //a11

    b = matrix[1]; //a21

    c = matrix[2]; //a31

    d = matrix[3]; //a41

    x = a12 = matrix[4];
    y = a22 = matrix[5]; //2D matrix

    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      } //3D matrix

    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2(a32, a33);
      rotationX = angle * _RAD2DEG; //rotationX

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      } //rotationY


      angle = _atan2(-c, a33);
      rotationY = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      } //rotationZ


      angle = _atan2(b, a);
      rotation = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }

      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }

      scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));
      scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2(a12, a22);
      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }

    if (cache.svg) {
      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
      t1 = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      t1 && target.setAttribute("transform", t1);
    }
  }

  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }

  uncache = uncache || cache.uncache;
  cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
  cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
  cache.z = z + px;
  cache.scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);
  cache.scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);
  cache.rotation = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;
  cache.rotationX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;
  cache.rotationY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;

  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin);
  }

  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
},
    _firstTwoOnly = function _firstTwoOnly(value) {
  return (value = value.split(" "))[0] + " " + value[1];
},
    //for handling transformOrigin values, stripping out the 3rd dimension
_addPxTranslate = function _addPxTranslate(target, start, value) {
  var unit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);
  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
},
    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;

  _renderCSSTransforms(ratio, cache);
},
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
  var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;

    angle = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }

  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }

  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }

  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }

  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }

  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }

  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }

  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }

  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }

  target.style[_transformProp] = transforms || "translate(0, 0)";
},
    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
  var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;

  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);

  if (skewY) {
    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }

  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;

    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;

      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }

    a11 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);
    a21 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);
    a12 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);
    a22 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }

  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }

  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }

  if (xPercent || yPercent) {
    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
    temp = target.getBBox();
    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);
    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height);
  }

  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);
  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
},
    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
  var cap = 360,
      isString = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";

  plugin._props.push(property);

  return pt;
},
    _assign = function _assign(target, source) {
  // Internet Explorer doesn't have Object.assign(), so we recreate it here.
  for (var p in source) {
    target[p] = source[p];
  }

  return target;
},
    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
  var startCache = _assign({}, target._gsap),
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      style = target.style,
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;

  if (startCache.svg) {
    startValue = target.getAttribute("transform");
    target.setAttribute("transform", "");
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);

    _removeProperty(target, _transformProp);

    target.setAttribute("transform", startValue);
  } else {
    startValue = getComputedStyle(target)[_transformProp];
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);
    style[_transformProp] = startValue;
  }

  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];

    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
      startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
      endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;

      plugin._props.push(p);
    }
  }

  _assign(endCache, startCache);
}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
      r = "Right",
      b = "Bottom",
      l = "Left",
      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
    return index < 2 ? name + side : "border" + side + name;
  });

  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;

    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }

    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});

var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
        style = target.style,
        startAt = tween.vars.startAt,
        startValue,
        endValue,
        endNum,
        startNum,
        type,
        specialProp,
        p,
        startUnit,
        endUnit,
        relative,
        isTransformRelated,
        transformPropTween,
        cache,
        smooth,
        hasPriority;
    _pluginInitted || _initCore();

    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }

      endValue = vars[p];

      if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) {
        // plugins
        continue;
      }

      type = typeof endValue;
      specialProp = _specialProps[p];

      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }

      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue);
      }

      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;

        if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) {
          // colors don't have units
          startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
        }

        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(startValue) && ~startValue.indexOf("random(") && (startValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(startValue));
          (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue + "") || (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(_get(target, p)) || ""); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
        } else {
          startValue = _get(target, p);
        }

        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);

        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }

            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }

          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }

        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0);
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }

            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);

            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endValue) : endValue);

            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);

            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }

        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN

          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
          this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;

          if (startUnit !== endUnit && endUnit !== "%") {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
          } else {
            (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);

            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
        }

        props.push(p);
      }
    }

    hasPriority && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this);
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: _getMatrix
  }
};
_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;

(function (positionAndScale, rotation, others, aliases) {
  var all = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, function (name) {
    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });

  _propertyAliases[all[13]] = positionAndScale + "," + rotation;

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "px";
});

_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin);


/***/ }),

/***/ "./node_modules/gsap/gsap-core.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/gsap-core.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Animation": () => (/* binding */ Animation),
/* harmony export */   "Back": () => (/* binding */ Back),
/* harmony export */   "Bounce": () => (/* binding */ Bounce),
/* harmony export */   "Circ": () => (/* binding */ Circ),
/* harmony export */   "Cubic": () => (/* binding */ Cubic),
/* harmony export */   "Elastic": () => (/* binding */ Elastic),
/* harmony export */   "Expo": () => (/* binding */ Expo),
/* harmony export */   "GSCache": () => (/* binding */ GSCache),
/* harmony export */   "Linear": () => (/* binding */ Linear),
/* harmony export */   "Power0": () => (/* binding */ Power0),
/* harmony export */   "Power1": () => (/* binding */ Power1),
/* harmony export */   "Power2": () => (/* binding */ Power2),
/* harmony export */   "Power3": () => (/* binding */ Power3),
/* harmony export */   "Power4": () => (/* binding */ Power4),
/* harmony export */   "PropTween": () => (/* binding */ PropTween),
/* harmony export */   "Quad": () => (/* binding */ Quad),
/* harmony export */   "Quart": () => (/* binding */ Quart),
/* harmony export */   "Quint": () => (/* binding */ Quint),
/* harmony export */   "Sine": () => (/* binding */ Sine),
/* harmony export */   "SteppedEase": () => (/* binding */ SteppedEase),
/* harmony export */   "Strong": () => (/* binding */ Strong),
/* harmony export */   "Timeline": () => (/* binding */ Timeline),
/* harmony export */   "TimelineLite": () => (/* binding */ Timeline),
/* harmony export */   "TimelineMax": () => (/* binding */ Timeline),
/* harmony export */   "Tween": () => (/* binding */ Tween),
/* harmony export */   "TweenLite": () => (/* binding */ Tween),
/* harmony export */   "TweenMax": () => (/* binding */ Tween),
/* harmony export */   "_checkPlugin": () => (/* binding */ _checkPlugin),
/* harmony export */   "_colorExp": () => (/* binding */ _colorExp),
/* harmony export */   "_colorStringFilter": () => (/* binding */ _colorStringFilter),
/* harmony export */   "_config": () => (/* binding */ _config),
/* harmony export */   "_forEachName": () => (/* binding */ _forEachName),
/* harmony export */   "_getCache": () => (/* binding */ _getCache),
/* harmony export */   "_getProperty": () => (/* binding */ _getProperty),
/* harmony export */   "_getSetter": () => (/* binding */ _getSetter),
/* harmony export */   "_isString": () => (/* binding */ _isString),
/* harmony export */   "_isUndefined": () => (/* binding */ _isUndefined),
/* harmony export */   "_missingPlugin": () => (/* binding */ _missingPlugin),
/* harmony export */   "_numExp": () => (/* binding */ _numExp),
/* harmony export */   "_numWithUnitExp": () => (/* binding */ _numWithUnitExp),
/* harmony export */   "_parseRelative": () => (/* binding */ _parseRelative),
/* harmony export */   "_plugins": () => (/* binding */ _plugins),
/* harmony export */   "_relExp": () => (/* binding */ _relExp),
/* harmony export */   "_removeLinkedListItem": () => (/* binding */ _removeLinkedListItem),
/* harmony export */   "_renderComplexString": () => (/* binding */ _renderComplexString),
/* harmony export */   "_replaceRandom": () => (/* binding */ _replaceRandom),
/* harmony export */   "_round": () => (/* binding */ _round),
/* harmony export */   "_roundModifier": () => (/* binding */ _roundModifier),
/* harmony export */   "_setDefaults": () => (/* binding */ _setDefaults),
/* harmony export */   "_sortPropTweensByPriority": () => (/* binding */ _sortPropTweensByPriority),
/* harmony export */   "_ticker": () => (/* binding */ _ticker),
/* harmony export */   "clamp": () => (/* binding */ clamp),
/* harmony export */   "default": () => (/* binding */ gsap),
/* harmony export */   "distribute": () => (/* binding */ distribute),
/* harmony export */   "getUnit": () => (/* binding */ getUnit),
/* harmony export */   "gsap": () => (/* binding */ gsap),
/* harmony export */   "interpolate": () => (/* binding */ interpolate),
/* harmony export */   "mapRange": () => (/* binding */ mapRange),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "pipe": () => (/* binding */ pipe),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "selector": () => (/* binding */ selector),
/* harmony export */   "shuffle": () => (/* binding */ shuffle),
/* harmony export */   "snap": () => (/* binding */ snap),
/* harmony export */   "splitColor": () => (/* binding */ splitColor),
/* harmony export */   "toArray": () => (/* binding */ toArray),
/* harmony export */   "unitize": () => (/* binding */ unitize),
/* harmony export */   "wrap": () => (/* binding */ wrap),
/* harmony export */   "wrapYoyo": () => (/* binding */ wrapYoyo)
/* harmony export */ });
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/*!
 * GSAP 3.10.2
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
},
    _defaults = {
  duration: .5,
  overwrite: false,
  delay: 0
},
    _suppressOverwrites,
    _bigNum = 1e8,
    _tinyNum = 1 / _bigNum,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _isNotFalse = function _isNotFalse(value) {
  return value !== false;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _isFuncOrString = function _isFuncOrString(value) {
  return _isFunction(value) || _isString(value);
},
    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
_isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    //only numbers (including negatives and decimals) but NOT relative values.
_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
_relExp = /[+-]=-?[.\d]+/,
    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
    // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
_unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    _globalTimeline,
    _win,
    _coreInitted,
    _doc,
    _globals = {},
    _installScope = {},
    _coreReady,
    _install = function _install(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
},
    _missingPlugin = function _missingPlugin(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
},
    _warn = function _warn(message, suppress) {
  return !suppress && console.warn(message);
},
    _addGlobal = function _addGlobal(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
},
    _emptyFunc = function _emptyFunc() {
  return 0;
},
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _lastRenderedFrame,
    _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "",
    _harness = function _harness(targets) {
  var target = targets[0],
      harnessPlugin,
      i;
  _isObject(target) || _isFunction(target) || (targets = [targets]);

  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
    i = _harnessPlugins.length;

    while (i-- && !_harnessPlugins[i].targetTest(target)) {}

    harnessPlugin = _harnessPlugins[i];
  }

  i = targets.length;

  while (i--) {
    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
  }

  return targets;
},
    _getCache = function _getCache(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
},
    _getProperty = function _getProperty(target, property, v) {
  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
},
    _forEachName = function _forEachName(names, func) {
  return (names = names.split(",")).forEach(func) || names;
},
    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
_round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _roundPrecise = function _roundPrecise(value) {
  return Math.round(value * 10000000) / 10000000 || 0;
},
    // increased precision mostly for timing values.
_parseRelative = function _parseRelative(start, value) {
  var operator = value.charAt(0),
      end = parseFloat(value.substr(2));
  start = parseFloat(start);
  return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
},
    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
  var l = toFind.length,
      i = 0;

  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

  return i < l;
},
    _lazyRender = function _lazyRender() {
  var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;

  _lazyLookup = {};
  _lazyTweens.length = 0;

  for (i = 0; i < l; i++) {
    tween = a[i];
    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
  }
},
    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
  _lazyTweens.length && _lazyRender();
  animation.render(time, suppressEvents, force);
  _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
},
    _numericIfPossible = function _numericIfPossible(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
  return function (obj, defaults) {
    for (var p in defaults) {
      p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
    }
  };
},
    _merge = function _merge(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }

  return base;
},
    _mergeDeep = function _mergeDeep(base, toMerge) {
  for (var p in toMerge) {
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
  }

  return base;
},
    _copyExcluding = function _copyExcluding(obj, excluding) {
  var copy = {},
      p;

  for (p in obj) {
    p in excluding || (copy[p] = obj[p]);
  }

  return copy;
},
    _inheritDefaults = function _inheritDefaults(vars) {
  var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;

  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent || parent._dp;
    }
  }

  return vars;
},
    _arraysMatch = function _arraysMatch(a1, a2) {
  var i = a1.length,
      match = i === a2.length;

  while (match && i-- && a1[i] === a2[i]) {}

  return i < 0;
},
    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = parent[lastProp],
      t;

  if (sortBy) {
    t = child[sortBy];

    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }

  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }

  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }

  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
},
    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = child._prev,
      next = child._next;

  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }

  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }

  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
},
    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
  child._act = 0;
},
    _uncache = function _uncache(animation, child) {
  if (animation && (!child || child._end > animation._dur || child._start < 0)) {
    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
    var a = animation;

    while (a) {
      a._dirty = 1;
      a = a.parent;
    }
  }

  return animation;
},
    _recacheAncestors = function _recacheAncestors(animation) {
  var parent = animation.parent;

  while (parent && parent.parent) {
    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }

  return animation;
},
    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
},
    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
},
    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
_animationCycle = function _animationCycle(tTime, cycleDuration) {
  var whole = Math.floor(tTime /= cycleDuration);
  return tTime && whole === tTime ? whole - 1 : whole;
},
    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
},
    _setEnd = function _setEnd(animation) {
  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
},
    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
  var parent = animation._dp;

  if (parent && parent.smoothChildTiming && animation._ts) {
    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

    _setEnd(animation);

    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
  }

  return animation;
},

/*
_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
	let cycleDuration = duration + repeatDelay,
		time = _round(clampedTotalTime % cycleDuration);
	if (time > duration) {
		time = duration;
	}
	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
},
*/
_postAddChecks = function _postAddChecks(timeline, child) {
  var t;

  if (child._time || child._initted && !child._dur) {
    //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
    t = _parentToChildTotalTime(timeline.rawTime(), child);

    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
      child.render(t, true);
    }
  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
    //in case any of the ancestors had completed but should now be enabled...
    if (timeline._dur < timeline.duration()) {
      t = timeline;

      while (t._dp) {
        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

        t = t._dp;
      }
    }

    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
  }
},
    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

  _isFromOrFromStart(child) || (timeline._recent = child);
  skipChecks || _postAddChecks(timeline, child);
  return timeline;
},
    _scrollTrigger = function _scrollTrigger(animation, trigger) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
},
    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
  _initTween(tween, totalTime);

  if (!tween._initted) {
    return 1;
  }

  if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);

    tween._lazy = [totalTime, suppressEvents];
    return 1;
  }
},
    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
  var parent = _ref.parent;
  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
},
    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
_isFromOrFromStart = function _isFromOrFromStart(_ref2) {
  var data = _ref2.data;
  return data === "isFromStart" || data === "isStart";
},
    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween.ratio,
      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
  repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;

  if (repeatDelay && tween._repeat) {
    // in case there's a zero-duration tween that has a repeat with a repeatDelay
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
      // if iteration changed
      prevRatio = 1 - ratio;
      tween.vars.repeatRefresh && tween._initted && tween.invalidate();
    }
  }

  if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
      return;
    }

    prevIteration = tween._zTime;
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

    tween.ratio = ratio;
    tween._from && (ratio = 1 - ratio);
    tween._time = 0;
    tween._tTime = tTime;
    pt = tween._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");

    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      ratio && _removeFromParent(tween, 1);

      if (!suppressEvents) {
        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);

        tween._prom && tween._prom();
      }
    }
  } else if (!tween._zTime) {
    tween._zTime = totalTime;
  }
},
    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
  var child;

  if (time > prevTime) {
    child = animation._first;

    while (child && child._start <= time) {
      if (child.data === "isPause" && child._start > prevTime) {
        return child;
      }

      child = child._next;
    }
  } else {
    child = animation._last;

    while (child && child._start >= time) {
      if (child.data === "isPause" && child._start < prevTime) {
        return child;
      }

      child = child._prev;
    }
  }
},
    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
  var repeat = animation._repeat,
      dur = _roundPrecise(duration) || 0,
      totalProgress = animation._tTime / animation._tDur;
  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
  totalProgress > 0 && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
  skipUncache || _uncache(animation.parent, animation);
  return animation;
},
    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
},
    _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc,
  totalDuration: _emptyFunc
},
    _parsePosition = function _parsePosition(animation, position, percentAnimation) {
  var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
  i,
      offset,
      isPercent;

  if (_isString(position) && (isNaN(position) || position in labels)) {
    //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
    offset = position.charAt(0);
    isPercent = position.substr(-1) === "%";
    i = position.indexOf("=");

    if (offset === "<" || offset === ">") {
      i >= 0 && (position = position.replace(/=/, ""));
      return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
    }

    if (i < 0) {
      position in labels || (labels[position] = clippedDuration);
      return labels[position];
    }

    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));

    if (isPercent && percentAnimation) {
      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
    }

    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
  }

  return position == null ? clippedDuration : +position;
},
    _createTweenType = function _createTweenType(type, params, timeline) {
  var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars,
      parent;

  isLegacy && (vars.duration = params[1]);
  vars.parent = timeline;

  if (type) {
    irVars = vars;
    parent = timeline;

    while (parent && !("immediateRender" in irVars)) {
      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }

    vars.immediateRender = _isNotFalse(irVars.immediateRender);
    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
  }

  return new Tween(params[0], vars, params[varsIndex + 1]);
},
    _conditionalReturn = function _conditionalReturn(value, func) {
  return value || value === 0 ? func(value) : func;
},
    _clamp = function _clamp(min, max, value) {
  return value < min ? min : value > max ? max : value;
},
    getUnit = function getUnit(value, v) {
  return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
},
    // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
clamp = function clamp(min, max, value) {
  return _conditionalReturn(value, function (v) {
    return _clamp(min, max, v);
  });
},
    _slice = [].slice,
    _isArrayLike = function _isArrayLike(value, nonEmpty) {
  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
},
    _flatten = function _flatten(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }

  return ar.forEach(function (value) {
    var _accumulator;

    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
},
    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
toArray = function toArray(value, scope, leaveStrings) {
  return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
},
    selector = function selector(value) {
  value = toArray(value)[0] || _warn("Invalid scope") || {};
  return function (v) {
    var el = value.current || value.nativeElement || value;
    return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
  };
},
    shuffle = function shuffle(a) {
  return a.sort(function () {
    return .5 - Math.random();
  });
},
    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
distribute = function distribute(v) {
  if (_isFunction(v)) {
    return v;
  }

  var vars = _isObject(v) ? v : {
    each: v
  },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
  ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;

  if (_isString(from)) {
    ratioX = ratioY = {
      center: .5,
      edges: .5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }

  return function (i, target, a) {
    var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;

    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];

      if (!wrapAt) {
        max = -_bigNum;

        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

        wrapAt--;
      }

      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
      originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum;

      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
        d > max && (max = d);
        d < min && (min = d);
      }

      from === "random" && shuffle(distances);
      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0; //unit

      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }

    l = (distances[i] - distances.min) / distances.max || 0;
    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
  };
},
    _roundModifier = function _roundModifier(v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())

  return function (raw) {
    var n = Math.round(parseFloat(raw) / v) * v * p;
    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
  };
},
    snap = function snap(snapTo, value) {
  var isArray = _isArray(snapTo),
      radius,
      is2D;

  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum;

    if (snapTo.values) {
      snapTo = toArray(snapTo.values);

      if (is2D = !_isNumber(snapTo[0])) {
        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }

  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function (raw) {
    var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;

    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }

      if (dx < min) {
        min = dx;
        closest = i;
      }
    }

    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
},
    random = function random(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
},
    pipe = function pipe() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return function (value) {
    return functions.reduce(function (v, f) {
      return f(v);
    }, value);
  };
},
    unitize = function unitize(func, unit) {
  return function (value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
},
    normalize = function normalize(min, max, value) {
  return mapRange(min, max, 0, 1, value);
},
    _wrapArray = function _wrapArray(a, wrapper, value) {
  return _conditionalReturn(value, function (index) {
    return a[~~wrapper(index)];
  });
},
    wrap = function wrap(min, max, value) {
  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
  var range = max - min;
  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
    return (range + (value - min) % range) % range + min;
  });
},
    wrapYoyo = function wrapYoyo(min, max, value) {
  var range = max - min,
      total = range * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
    value = (total + (value - min) % total) % total || 0;
    return min + (value > range ? total - value : value);
  });
},
    _replaceRandom = function _replaceRandom(value) {
  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
  var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;

  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }

  return s + value.substr(prev, value.length - prev);
},
    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin,
      outRange = outMax - outMin;
  return _conditionalReturn(value, function (value) {
    return outMin + ((value - inMin) / inRange * outRange || 0);
  });
},
    interpolate = function interpolate(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function (p) {
    return (1 - p) * start + p * end;
  };

  if (!func) {
    var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;

    progress === true && (mutate = 1) && (progress = null);

    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;

      for (i = 1; i < l; i++) {
        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
      }

      l--;

      func = function func(p) {
        p *= l;
        var i = Math.min(il, ~~p);
        return interpolators[i](p - i);
      };

      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }

    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }

      func = function func(p) {
        return _renderPropTweens(p, master) || (isString ? start.p : start);
      };
    }
  }

  return _conditionalReturn(progress, func);
},
    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
  //used for nextLabel() and previousLabel()
  var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;

  for (p in labels) {
    distance = labels[p] - fromTime;

    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }

  return label;
},
    _callback = function _callback(animation, type, executeLazyFirst) {
  var v = animation.vars,
      callback = v[type],
      params,
      scope;

  if (!callback) {
    return;
  }

  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

  return params ? callback.apply(scope, params) : callback.call(scope);
},
    _interrupt = function _interrupt(animation) {
  _removeFromParent(animation);

  animation.scrollTrigger && animation.scrollTrigger.kill(false);
  animation.progress() < 1 && _callback(animation, "onInterrupt");
  return animation;
},
    _quickTween,
    _createPlugin = function _createPlugin(config) {
  config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

  var name = config.name,
      isFunc = _isFunction(config),
      Plugin = name && !isFunc && config.init ? function () {
    this._props = [];
  } : config,
      //in case someone passes in an object that's not a plugin, like CustomEase
  instanceDefaults = {
    init: _emptyFunc,
    render: _renderPropTweens,
    add: _addPropTween,
    kill: _killPropTweensOf,
    modifier: _addPluginModifier,
    rawVars: 0
  },
      statics = {
    targetTest: 0,
    get: 0,
    getSetter: _getSetter,
    aliases: {},
    register: 0
  };

  _wake();

  if (config !== Plugin) {
    if (_plugins[name]) {
      return;
    }

    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


    _plugins[Plugin.prop = name] = Plugin;

    if (config.targetTest) {
      _harnessPlugins.push(Plugin);

      _reservedProps[name] = 1;
    }

    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
  }

  _addGlobal(name, Plugin);

  config.register && config.register(gsap, Plugin, PropTween);
},

/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */
_255 = 255,
    _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
},
    // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:
// let ctx = _doc.createElement("canvas").getContext("2d");
// _forEachName("aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});
_hue = function _hue(h, m1, m2) {
  h += h < 0 ? 1 : h > 1 ? -1 : 0;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
},
    splitColor = function splitColor(v, toHSL, forceAlpha) {
  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!a) {
    if (v.substr(-1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length < 6) {
        //for shorthand like #9F0 or #9F0F (could have alpha)
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
      }

      if (v.length === 9) {
        // hex with alpha, like #fd5e53ff
        a = parseInt(v.substr(1, 6), 16);
        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);

      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= .5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;
        a.length > 3 && (a[3] *= 1); //cast as number

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        a = v.match(_numExp);
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }

    a = a.map(Number);
  }

  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = ~~(h + .5);
    a[1] = ~~(s * 100 + .5);
    a[2] = ~~(l * 100 + .5);
  }

  forceAlpha && a.length < 4 && (a[3] = 1);
  return a;
},
    _colorOrderData = function _colorOrderData(v) {
  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
  var values = [],
      c = [],
      i = -1;
  v.split(_colorExp).forEach(function (v) {
    var a = v.match(_numWithUnitExp) || [];
    values.push.apply(values, a);
    c.push(i += a.length + 1);
  });
  values.c = c;
  return values;
},
    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
  var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;

  if (!colors) {
    return s;
  }

  colors = colors.map(function (color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });

  if (orderMatchData) {
    d = _colorOrderData(s);
    c = orderMatchData.c;

    if (c.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }

  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;

    for (; i < l; i++) {
      result += shell[i] + colors[i];
    }
  }

  return result + shell[l];
},
    _colorExp = function () {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
  p;

  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }

  return new RegExp(s + ")", "gi");
}(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function _colorStringFilter(a) {
  var combined = a.join(" "),
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[1] = _formatColors(a[1], toHSL);
    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

    return true;
  }
},

/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
_tickerActive,
    _ticker = function () {
  var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1000 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _delta,
      _i,
      _tick = function _tick(v) {
    var elapsed = _getTime() - _lastUpdate,
        manual = v === true,
        overlap,
        dispatch,
        time,
        frame;

    elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
    _lastUpdate += elapsed;
    time = _lastUpdate - _startTime;
    overlap = time - _nextTime;

    if (overlap > 0 || manual) {
      frame = ++_self.frame;
      _delta = time - _self.time * 1000;
      _self.time = time = time / 1000;
      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
      dispatch = 1;
    }

    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

    if (dispatch) {
      for (_i = 0; _i < _listeners.length; _i++) {
        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
        _listeners[_i](time, _delta, frame, v);
      }
    }
  };

  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    deltaRatio: function deltaRatio(fps) {
      return _delta / (1000 / (fps || 60));
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists()) {
          _win = _coreInitted = window;
          _doc = _win.document || {};
          _globals.gsap = gsap;
          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);

          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});

          _raf = _win.requestAnimationFrame;
        }

        _id && _self.sleep();

        _req = _raf || function (f) {
          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
        };

        _tickerActive = 1;

        _tick(2);
      }
    },
    sleep: function sleep() {
      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    },
    fps: function fps(_fps) {
      _gap = 1000 / (_fps || 240);
      _nextTime = _self.time * 1000 + _gap;
    },
    add: function add(callback, once, prioritize) {
      var func = once ? function (t, d, f, v) {
        callback(t, d, f, v);

        _self.remove(func);
      } : callback;

      _self.remove(callback);

      _listeners[prioritize ? "unshift" : "push"](func);

      _wake();

      return func;
    },
    remove: function remove(callback, i) {
      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
    },
    _listeners: _listeners
  };
  return _self;
}(),
    _wake = function _wake() {
  return !_tickerActive && _ticker.wake();
},
    //also ensures the core classes are initialized.

/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
_easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function _parseObjectInString(value) {
  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
  var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;

  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }

  return obj;
},
    _valueInParentheses = function _valueInParentheses(value) {
  var open = value.indexOf("(") + 1,
      close = value.indexOf(")"),
      nested = value.indexOf("(", open);
  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
},
    _configEaseFromString = function _configEaseFromString(name) {
  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
  var split = (name + "").split("("),
      ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
},
    _invertEase = function _invertEase(ease) {
  return function (p) {
    return 1 - ease(1 - p);
  };
},
    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
  var child = timeline._first,
      ease;

  while (child) {
    if (child instanceof Timeline) {
      _propagateYoyoEase(child, isYoyo);
    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
      if (child.timeline) {
        _propagateYoyoEase(child.timeline, isYoyo);
      } else {
        ease = child._ease;
        child._ease = child._yEase;
        child._yEase = ease;
        child._yoyo = isYoyo;
      }
    }

    child = child._next;
  }
},
    _parseEase = function _parseEase(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
},
    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut(p) {
      return 1 - easeIn(1 - p);
    };
  }

  if (easeInOut === void 0) {
    easeInOut = function easeInOut(p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }

  var ease = {
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut
  },
      lowercaseName;

  _forEachName(names, function (name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });

  return ease;
},
    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
  return function (p) {
    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
  };
},
    _configElastic = function _configElastic(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  p2 = _2PI / p2; //precalculate to optimize

  ease.config = function (amplitude, period) {
    return _configElastic(type, amplitude, period);
  };

  return ease;
},
    _configBack = function _configBack(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }

  var easeOut = function easeOut(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  ease.config = function (overshoot) {
    return _configBack(type, overshoot);
  };

  return ease;
}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };


_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;

  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});

_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

(function (n, c) {
  var n1 = 1 / c,
      n2 = 2 * n1,
      n3 = 2.5 * n1,
      easeOut = function easeOut(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
  };

  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);

_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});

_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});

_insertEase("Sine", function (p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});

_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }

    var p1 = 1 / steps,
        p2 = steps + (immediateStart ? 0 : 1),
        p3 = immediateStart ? 1 : 0,
        max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];

_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */


var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */

var Animation = /*#__PURE__*/function () {
  function Animation(vars) {
    this.vars = vars;
    this._delay = +vars.delay || 0;

    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }

    this._ts = 1;

    _setDuration(this, +vars.duration, 1, 1);

    this.data = vars.data;
    _tickerActive || _ticker.wake();
  }

  var _proto = Animation.prototype;

  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }

    return this._delay;
  };

  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };

  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }

    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };

  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();

    if (!arguments.length) {
      return this._tTime;
    }

    var parent = this._dp;

    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);

      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

      while (parent && parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }

        parent = parent.parent;
      }

      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }

    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
      //   this._lock = 1;

      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
      //}

    }

    return this;
  };

  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
  };

  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
  };

  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;

    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  } // potential future addition:
  // isPlayingBackwards() {
  // 	let animation = this,
  // 		orientation = 1; // 1 = forward, -1 = backward
  // 	while (animation) {
  // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
  // 		animation = animation.parent;
  // 	}
  // 	return orientation < 0;
  // }
  ;

  _proto.timeScale = function timeScale(value) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
    }

    if (this._rts === value) {
      return this;
    }

    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
    //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

    this.totalTime(_clamp(-this._delay, this._tDur, tTime), true);

    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.


    return _recacheAncestors(this);
  };

  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }

    if (this._ps !== value) {
      this._ps = value;

      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
      } else {
        _wake();

        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
      }
    }

    return this;
  };

  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }

    return this._start;
  };

  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  };

  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detached parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };

  _proto.globalTime = function globalTime(rawTime) {
    var animation = this,
        time = arguments.length ? rawTime : animation.rawTime();

    while (animation) {
      time = animation._start + time / (animation._ts || 1);
      animation = animation._dp;
    }

    return time;
  };

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }

    return this._repeat === -2 ? Infinity : this._repeat;
  };

  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      var time = this._time;
      this._rDelay = value;

      _onUpdateTotalDuration(this);

      return time ? this.time(time) : this;
    }

    return this._rDelay;
  };

  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }

    return this._yoyo;
  };

  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };

  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };

  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };

  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };

  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };

  _proto.resume = function resume() {
    return this.paused(false);
  };

  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

      return this;
    }

    return this._rts < 0;
  };

  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };

  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };

  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;

    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }

      return this;
    }

    return vars[type];
  };

  _proto.then = function then(onFulfilled) {
    var self = this;
    return new Promise(function (resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
          _resolve = function _resolve() {
        var _then = self.then;
        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
        resolve(f);
        self.then = _then;
      };

      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
        _resolve();
      } else {
        self._prom = _resolve;
      }
    });
  };

  _proto.kill = function kill() {
    _interrupt(this);
  };

  return Animation;
}();

_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */


var Timeline = /*#__PURE__*/function (_Animation) {
  _inheritsLoose(Timeline, _Animation);

  function Timeline(vars, position) {
    var _this;

    if (vars === void 0) {
      vars = {};
    }

    _this = _Animation.call(this, vars) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
    return _this;
  }

  var _proto2 = Timeline.prototype;

  _proto2.to = function to(targets, vars, position) {
    _createTweenType(0, arguments, this);

    return this;
  };

  _proto2.from = function from(targets, vars, position) {
    _createTweenType(1, arguments, this);

    return this;
  };

  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    _createTweenType(2, arguments, this);

    return this;
  };

  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };

  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
        // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
    crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;
    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);

    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }

      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;

      if (crossingStart) {
        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */


        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : dur;
          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
            return this;
          }

          dur = this._dur; // in case the duration changed in the onRepeat

          tDur = this._tDur;

          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -0.0001;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }

          this._lock = 0;

          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


          _propagateYoyoEase(this, isYoyo);
        }
      }

      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));

        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }

      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
      }

      if (!prevTime && time && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      if (time >= prevTime && totalTime >= 0) {
        child = this._first;

        while (child) {
          next = child._next;

          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;

          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      }

      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          _setEnd(this);

          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.
        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
          _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto2.add = function add(child, position) {
    var _this2 = this;

    _isNumber(position) || (position = _parsePosition(this, position, child));

    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this2.add(obj, position);
        });
        return this;
      }

      if (_isString(child)) {
        return this.addLabel(child, position);
      }

      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }

    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  };

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }

    if (tweens === void 0) {
      tweens = true;
    }

    if (timelines === void 0) {
      timelines = true;
    }

    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }

    var a = [],
        child = this._first;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a.push(child);
        } else {
          timelines && a.push(child);
          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
        }
      }

      child = child._next;
    }

    return a;
  };

  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
        i = animations.length;

    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };

  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }

    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }

    _removeLinkedListItem(this, child);

    if (child === this._recent) {
      this._recent = this._last;
    }

    return _uncache(this);
  };

  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }

    this._forcing = 1;

    if (!this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }

    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

    this._forcing = 0;
    return this;
  };

  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };

  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };

  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };

  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);

    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }

      child = child._next;
    }
  };

  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;

    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }

    return this;
  };

  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        isGlobalTime = _isNumber(onlyActive),
        // a number is interpreted as a global time. If the animation spans
    children;

    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }

      child = child._next;
    }

    return a;
  } // potential future feature - targets() on timelines
  // targets() {
  // 	let result = [];
  // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
  // 	return result.filter((v, i) => result.indexOf(v) === i);
  // }
  ;

  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};

    var tl = this,
        endTime = _parsePosition(tl, position),
        _vars = vars,
        startAt = _vars.startAt,
        _onStart = _vars.onStart,
        onStartParams = _vars.onStartParams,
        immediateRender = _vars.immediateRender,
        initted,
        tween = Tween.to(tl, _setDefaults({
      ease: vars.ease || "none",
      lazy: false,
      immediateRender: false,
      time: endTime,
      overwrite: "auto",
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();

        if (!initted) {
          var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
          initted = 1;
        }

        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
      }
    }, vars));

    return immediateRender ? tween.render(0) : tween;
  };

  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };

  _proto2.recent = function recent() {
    return this._recent;
  };

  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };

  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };

  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };

  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }

    var child = this._first,
        labels = this.labels,
        p;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }

      child = child._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return _uncache(this);
  };

  _proto2.invalidate = function invalidate() {
    var child = this._first;
    this._lock = 0;

    while (child) {
      child.invalidate();
      child = child._next;
    }

    return _Animation.prototype.invalidate.call(this);
  };

  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }

    var child = this._first,
        next;

    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }

    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };

  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum,
        prev,
        start,
        parent;

    if (arguments.length) {
      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
    }

    if (self._dirty) {
      parent = self.parent;

      while (child) {
        prev = child._prev; //record it here in case the tween changes position in the sequence...

        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

        start = child._start;

        if (start > prevStart && self._sort && child._ts && !self._lock) {
          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }

        if (start < 0 && child._ts) {
          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
          max -= start;

          if (!parent && !self._dp || parent && parent.smoothChildTiming) {
            self._start += start / self._ts;
            self._time -= start;
            self._tTime -= start;
          }

          self.shiftChildren(-start, false, -1e999);
          prevStart = 0;
        }

        child._end > max && child._ts && (max = child._end);
        child = prev;
      }

      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

      self._dirty = 0;
    }

    return self._tDur;
  };

  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

      _lastRenderedFrame = _ticker.frame;
    }

    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }

        child || _ticker.sleep();
      }
    }
  };

  return Timeline;
}(Animation);

_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});

var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }

  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

    start = a[0];
    end = a[1];
  }

  startNums = start.match(_complexStringNumExp) || [];

  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);

    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }

    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }

  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

  pt.fp = funcParam;

  if (_relExp.test(end) || hasRandom) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
  _isFunction(end) && (end = end(index || 0, target, targets));
  var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;

  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (end.charAt(1) === "=") {
      pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);

      if (pt || pt === 0) {
        // to avoid isNaN, like if someone passes in a value like "!= whatever"
        end = pt;
      }
    }
  }

  if (parsedStart !== end || _forceAllPropTweens) {
    if (!isNaN(parsedStart * end) && end !== "") {
      // fun fact: any number multiplied by "" is evaluated as the number 0!
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
      funcParam && (pt.fp = funcParam);
      modifier && pt.modifier(modifier, this, target);
      return this._pt = pt;
    }

    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
},
    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
_processVars = function _processVars(vars, index, target, targets, tween) {
  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }

  var copy = {},
      p;

  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }

  return copy;
},
    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;

  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

      i = plugin._props.length;

      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }

  return plugin;
},
    _overwritingTween,
    //store a reference temporarily so we can avoid overwriting itself.
_forceAllPropTweens,
    _initTween = function _initTween(tween, time) {
  var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      onUpdateParams = vars.onUpdateParams,
      callbackScope = vars.callbackScope,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars,
      overwritten;
  tl && (!keyframes || !ease) && (ease = "none");
  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

  if (yoyoEase && tween._yoyo && !tween._repeat) {
    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }

  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

  if (!tl || keyframes && !vars.stagger) {
    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

    cleanVars = _copyExcluding(vars, _reservedProps);

    if (prevStartAt) {
      _removeFromParent(prevStartAt.render(-1, true));

      prevStartAt._lazy = 0;
    }

    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent: parent,
        immediateRender: true,
        lazy: _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate,
        onUpdateParams: onUpdateParams,
        callbackScope: callbackScope,
        stagger: 0
      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


      time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

      if (immediateRender) {
        time > 0 && !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.

        if (dur && time <= 0) {
          time && (tween._zTime = time);
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        } // if (time > 0) {
        // 	autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
        // } else if (dur && !(time < 0 && prevStartAt)) {
        // 	time && (tween._zTime = time);
        // 	return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        // }

      } else if (autoRevert === false) {
        tween._startAt = 0;
      }
    } else if (runBackwards && dur) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (prevStartAt) {
        !autoRevert && (tween._startAt = 0);
      } else {
        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

        p = _setDefaults({
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && _isNotFalse(lazy),
          immediateRender: immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})

        }, cleanVars);
        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

        _removeFromParent(tween._startAt = Tween.set(targets, p));

        time < 0 && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted from() tween.

        tween._zTime = time;

        if (!immediateRender) {
          _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded

        } else if (!time) {
          return;
        }
      }
    }

    tween._pt = tween._ptCache = 0;
    lazy = dur && _isNotFalse(lazy) || lazy && !dur;

    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};
      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

      index = fullTargets === targets ? i : fullTargets.indexOf(target);

      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

        plugin._props.forEach(function (name) {
          ptLookup[name] = pt;
        });

        plugin.priority && (hasPriority = 1);
      }

      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            plugin.priority && (hasPriority = 1);
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }

      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;

        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!


        overwritten = !tween.parent;
        _overwritingTween = 0;
      }

      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
    }

    hasPriority && _sortPropTweensByPriority(tween);
    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
  }

  tween._onUpdate = onUpdate;
  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.

  keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the "before" state for any staggered/delayed animations thus when the following tween initializes, it'll use the "before" state instead of the "after" state as the initial values.
},
    _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {
  var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
      pt,
      lookup,
      i;

  if (!ptCache) {
    ptCache = tween._ptCache[property] = [];
    lookup = tween._ptLookup;
    i = tween._targets.length;

    while (i--) {
      pt = lookup[i][property];

      if (pt && pt.d && pt.d._pt) {
        // it's a plugin, so find the nested PropTween
        pt = pt.d._pt;

        while (pt && pt.p !== property) {
          pt = pt._next;
        }
      }

      if (!pt) {
        // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this
        // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo("x", 200) for example.
        _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.

        tween.vars[property] = "+=0";

        _initTween(tween, time);

        _forceAllPropTweens = 0;
        return 1;
      }

      ptCache.push(pt);
    }
  }

  i = ptCache.length;

  while (i--) {
    pt = ptCache[i];
    pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
    pt.c = value - pt.s;
    pt.e && (pt.e = _round(value) + getUnit(pt.e)); // mainly for CSSPlugin (end value)

    pt.b && (pt.b = pt.s + getUnit(pt.b)); // (beginning value)
  }
},
    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;

  if (!propertyAliases) {
    return vars;
  }

  copy = _merge({}, vars);

  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;

      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }

  return copy;
},
    // parses multiple formats, like {"0%": {x: 100}, {"50%": {x: -20}} and { x: {"0%": 100, "50%": -20} }, and an "ease" can be set on any object. We populate an "allProps" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a "t" (time), "v", (value), and "e" (ease) property. This allows us to piece together a timeline later.
_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
  var ease = obj.ease || easeEach || "power1.inOut",
      p,
      a;

  if (_isArray(obj)) {
    a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease

    obj.forEach(function (value, i) {
      return a.push({
        t: i / (obj.length - 1) * 100,
        v: value,
        e: ease
      });
    });
  } else {
    for (p in obj) {
      a = allProps[p] || (allProps[p] = []);
      p === "ease" || a.push({
        t: parseFloat(prop),
        v: obj[p],
        e: ease
      });
    }
  }
},
    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
},
    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    _staggerPropsToSkip = {};

_forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function (name) {
  return _staggerPropsToSkip[name] = 1;
});
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */


var Tween = /*#__PURE__*/function (_Animation2) {
  _inheritsLoose(Tween, _Animation2);

  function Tween(targets, vars, position, skipInherit) {
    var _this3;

    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }

    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
    var _this3$vars = _this3.vars,
        duration = _this3$vars.duration,
        delay = _this3$vars.delay,
        immediateRender = _this3$vars.immediateRender,
        stagger = _this3$vars.stagger,
        overwrite = _this3$vars.overwrite,
        keyframes = _this3$vars.keyframes,
        defaults = _this3$vars.defaults,
        scrollTrigger = _this3$vars.scrollTrigger,
        yoyoEase = _this3$vars.yoyoEase,
        parent = vars.parent || _globalTimeline,
        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
        tl,
        i,
        copy,
        l,
        p,
        curTarget,
        staggerFunc,
        staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this3._overwrite = overwrite;

    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {}
      });
      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized(_this3);
      tl._start = 0;

      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        l = parsedTargets.length;
        staggerFunc = stagger && distribute(stagger);

        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }

        for (i = 0; i < l; i++) {
          copy = _copyExcluding(vars, _staggerPropsToSkip);
          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }

          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
          tl._ease = _easeMap.none;
        }

        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
      } else if (keyframes) {
        _inheritDefaults(_setDefaults(tl.vars.defaults, {
          ease: "none"
        }));

        tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
        var time = 0,
            a,
            kf,
            v;

        if (_isArray(keyframes)) {
          keyframes.forEach(function (frame) {
            return tl.to(parsedTargets, frame, ">");
          });
        } else {
          copy = {};

          for (p in keyframes) {
            p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
          }

          for (p in copy) {
            a = copy[p].sort(function (a, b) {
              return a.t - b.t;
            });
            time = 0;

            for (i = 0; i < a.length; i++) {
              kf = a[i];
              v = {
                ease: kf.e,
                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
              };
              v[p] = kf.v;
              tl.to(parsedTargets, v, time);
              time += v.duration;
            }
          }

          tl.duration() < duration && tl.to({}, {
            duration: duration - tl.duration()
          }); // in case keyframes didn't go to 100%
        }
      }

      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized(_this3);

      _globalTimeline.killTweensOf(parsedTargets);

      _overwritingTween = 0;
    }

    _addToTimeline(parent, _assertThisInitialized(_this3), position);

    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);

    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this3.render(Math.max(0, -delay)); //in case delay is negative

    }

    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
    return _this3;
  }

  var _proto3 = Tween.prototype;

  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;

    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        isYoyo = this._yoyo && iteration & 1;

        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);

        if (time === prevTime && !force && this._initted) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          this._tTime = tTime;
          return this;
        }

        if (iteration !== prevIteration) {
          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }

      if (!this._initted) {
        if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

          return this;
        }

        if (prevTime !== this._time) {
          // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values.
          return this;
        }

        if (dur !== this._dur) {
          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._tTime = tTime;
      this._time = time;

      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }

      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }

      if (time && !prevTime && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      pt = this._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);

      if (this._onUpdate && !suppressEvents) {
        totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        _callback(this, "onUpdate");
      }

      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");

      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto3.targets = function targets() {
    return this._targets;
  };

  _proto3.invalidate = function invalidate() {
    this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate();
    return _Animation2.prototype.invalidate.call(this);
  };

  _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
    _tickerActive || _ticker.wake();
    this._ts || this.play();
    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        ratio,
        p;
    this._initted || _initTween(this, time);
    ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.
    // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.
    // if (_isObject(property)) { // performance optimization
    // 	for (p in property) {
    // 		if (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {
    // 			return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    // 		}
    // 	}
    // } else {

    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {
      return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    } //}


    _alignPlayhead(this, 0);

    this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
    return this.render(0);
  };

  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }

    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      return this.parent ? _interrupt(this) : this;
    }

    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

      return this;
    }

    var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;

    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt(this);
    }

    overwrittenProps = this._op = this._op || [];

    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};

        _forEachName(vars, function (name) {
          return p[name] = 1;
        });

        vars = p;
      }

      vars = _addAliasesToVars(parsedTargets, vars);
    }

    i = parsedTargets.length;

    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];

        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }

        for (p in props) {
          pt = curLookup && curLookup[p];

          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }

            delete curLookup[p];
          }

          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }

    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

    return this;
  };

  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };

  Tween.from = function from(targets, vars) {
    return _createTweenType(1, arguments);
  };

  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    });
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return _createTweenType(2, arguments);
  };

  Tween.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween(targets, vars);
  };

  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };

  return Tween;
}(Animation);

_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.


_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
        params = _slice.call(arguments, 0);

    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */


var _setterPlain = function _setterPlain(target, property, value) {
  return target[property] = value;
},
    _setterFunc = function _setterFunc(target, property, value) {
  return target[property](value);
},
    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
  return target[property](data.fp, value);
},
    _setterAttribute = function _setterAttribute(target, property, value) {
  return target.setAttribute(property, value);
},
    _getSetter = function _getSetter(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
},
    _renderPlain = function _renderPlain(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
},
    _renderBoolean = function _renderBoolean(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
},
    _renderComplexString = function _renderComplexString(ratio, data) {
  var pt = data._pt,
      s = "";

  if (!ratio && data.b) {
    //b = beginning string
    s = data.b;
  } else if (ratio === 1 && data.e) {
    //e = ending string
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

      pt = pt._next;
    }

    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
  }

  data.set(data.t, data.p, s, data);
},
    _renderPropTweens = function _renderPropTweens(ratio, data) {
  var pt = data._pt;

  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
},
    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
  var pt = this._pt,
      next;

  while (pt) {
    next = pt._next;
    pt.p === property && pt.modifier(modifier, tween, target);
    pt = next;
  }
},
    _killPropTweensOf = function _killPropTweensOf(property) {
  var pt = this._pt,
      hasNonDependentRemaining,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }

    pt = next;
  }

  return !hasNonDependentRemaining;
},
    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
},
    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
  var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

  while (pt) {
    next = pt._next;
    pt2 = first;

    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }

    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }

    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }

    pt = next;
  }

  parent._pt = first;
}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


var PropTween = /*#__PURE__*/function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;

    if (next) {
      next._prev = this;
    }
  }

  var _proto4 = PropTween.prototype;

  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };

  return PropTween;
}(); //Initialization tasks

_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
  return _reservedProps[name] = 1;
});

_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */

var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

    var getter = _getCache(target || {}).get,
        format = unit ? _passThrough : _numericIfPossible;

    unit === "native" && (unit = "");
    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);

    if (target.length > 1) {
      var setters = target.map(function (t) {
        return gsap.quickSetter(t, property, unit);
      }),
          l = setters.length;
      return function (value) {
        var i = l;

        while (i--) {
          setters[i](value);
        }
      };
    }

    target = target[0] || {};

    var Plugin = _plugins[property],
        cache = _getCache(target),
        p = cache.harness && (cache.harness.aliases || {})[property] || property,
        // in case it's an alias, like "rotate" for "rotation".
    setter = Plugin ? function (value) {
      var p = new Plugin();
      _quickTween._pt = 0;
      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p.render(1, p);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, p);

    return Plugin ? setter : function (value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  quickTo: function quickTo(target, property, vars) {
    var _merge2;

    var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, _merge2), vars || {})),
        func = function func(value, start, startIsRelative) {
      return tween.resetTo(property, value, start, startIsRelative);
    };

    func.tween = tween;
    return func;
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name,
        effect = _ref3.effect,
        plugins = _ref3.plugins,
        defaults = _ref3.defaults,
        extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });

    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };

    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }

    var tl = new Timeline(vars),
        child,
        next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

    _globalTimeline.remove(tl);

    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;

    while (child) {
      next = child._next;

      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }

      child = next;
    }

    _addToTimeline(_globalTimeline, tl, 0);

    return tl;
  },
  utils: {
    wrap: wrap,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    selector: selector,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem,
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});

_ticker.add(Timeline.updateRoot);

_quickTween = _gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
  var pt = plugin._pt;

  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }

  return pt;
},
    _addModifiers = function _addModifiers(tween, modifiers) {
  var targets = tween._targets,
      p,
      i,
      pt;

  for (p in modifiers) {
    i = targets.length;

    while (i--) {
      pt = tween._ptLookup[i][p];

      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          // is a plugin
          pt = _getPluginPropTween(pt, p);
        }

        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
      }
    }
  }
},
    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
  return {
    name: name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init(target, vars, tween) {
      tween._onInit = function (tween) {
        var temp, p;

        if (_isString(vars)) {
          temp = {};

          _forEachName(vars, function (name) {
            return temp[name] = 1;
          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


          vars = temp;
        }

        if (modifier) {
          temp = {};

          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }

          vars = temp;
        }

        _addModifiers(tween, vars);
      };
    }
  };
}; //register core plugins


var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt;

    for (p in vars) {
      pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
      pt && (pt.op = p);

      this._props.push(p);
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;

    while (i--) {
      this.add(target, i, target[i] || 0, value[i]);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

Tween.version = Timeline.version = gsap.version = "3.10.2";
_coreReady = 1;
_windowExists() && _wake();
var Power0 = _easeMap.Power0,
    Power1 = _easeMap.Power1,
    Power2 = _easeMap.Power2,
    Power3 = _easeMap.Power3,
    Power4 = _easeMap.Power4,
    Linear = _easeMap.Linear,
    Quad = _easeMap.Quad,
    Cubic = _easeMap.Cubic,
    Quart = _easeMap.Quart,
    Quint = _easeMap.Quint,
    Strong = _easeMap.Strong,
    Elastic = _easeMap.Elastic,
    Back = _easeMap.Back,
    SteppedEase = _easeMap.SteppedEase,
    Bounce = _easeMap.Bounce,
    Sine = _easeMap.Sine,
    Expo = _easeMap.Expo,
    Circ = _easeMap.Circ;

 //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.



/***/ }),

/***/ "./node_modules/gsap/index.js":
/*!************************************!*\
  !*** ./node_modules/gsap/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Back": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back),
/* harmony export */   "Bounce": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce),
/* harmony export */   "CSSPlugin": () => (/* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin),
/* harmony export */   "Circ": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ),
/* harmony export */   "Cubic": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic),
/* harmony export */   "Elastic": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic),
/* harmony export */   "Expo": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo),
/* harmony export */   "Linear": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear),
/* harmony export */   "Power0": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0),
/* harmony export */   "Power1": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1),
/* harmony export */   "Power2": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2),
/* harmony export */   "Power3": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3),
/* harmony export */   "Power4": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4),
/* harmony export */   "Quad": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad),
/* harmony export */   "Quart": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart),
/* harmony export */   "Quint": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint),
/* harmony export */   "Sine": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine),
/* harmony export */   "SteppedEase": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase),
/* harmony export */   "Strong": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong),
/* harmony export */   "TimelineLite": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite),
/* harmony export */   "TimelineMax": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax),
/* harmony export */   "TweenLite": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite),
/* harmony export */   "TweenMax": () => (/* binding */ TweenMaxWithCSS),
/* harmony export */   "default": () => (/* binding */ gsapWithCSS),
/* harmony export */   "gsap": () => (/* binding */ gsapWithCSS)
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ "./node_modules/gsap/CSSPlugin.js");


var gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap,
    // to protect from tree shaking
TweenMaxWithCSS = gsapWithCSS.core.Tween;


/***/ }),

/***/ "./src/style/main.scss":
/*!*****************************!*\
  !*** ./src/style/main.scss ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_main_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./main.scss */ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style/main.scss");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_main_scss__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_main_scss__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_main_scss__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_main_scss__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./src/hdri/gamrig_1k.hdr":
/*!********************************!*\
  !*** ./src/hdri/gamrig_1k.hdr ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("data:;base64,Iz9SQURJQU5DRQojP1JBRElBTkNFCkdBTU1BPTEKUFJJTUFSSUVTPTAgMCAwIDAgMCAwIDAgMApGT1JNQVQ9MzItYml0X3JsZV9yZ2JlCgotWSA1MTIgK1ggMTAyNAoCAgQAhzqGOdI6xzmnOqo5hjqMOQM6OjmFOoU5iTqXOYk6izuHOoU7gjqEOwE6izuYOpU5njqXO8s6hzsEOjo6O446ATuFOoM7qzqDO6A6hjmiOoc7/zqWOp07pzoDOTk6hzmROok5hDiXOYI6iDmQOoQ5ljqmYNVfg2CfX4JgiV+MYIJftmCCX5lgAWGWYARfX19gn1+YYLVfl2CeX4pgl1/4YIthnmCLX41ggl//YP9g42CWtwG2m7eTtpi3lbiDt4m4ubePtoK1hLYBtZO2i7WLtqK3h7iDuY64ibcEuLe4t4y4ircEtra3t4u2mrcLuLi4t7i4t7i4uLeMuIq5mriLuZC4kLeJuAO5ubiEuYy4l7eNuIK3m7iKuca4ibmxuAS5uLi4hLmNuAO3uLiLtwG4jbesuIO3irgBuY24AbmUuLS3hriDt4i4greGuIa3hbgFt7i3t7eeuI23AbiEt4K4m7f/f/9//3//f/9//3//f/9/iH8CAgQAgjiMOYQ6hzmMOJk5rjiLN4w4oDmCOIU5gziEOY04gjmcOIs5gziOOYI4iTmbOIc5ijiYOQE6hzmSOIw5Bjo5OTk6Ooc5Ajo5iTqDOYg6nDmNOoc7jjqPOQQ6OTk5hTqKOYk4BDk4OTmEOIw5hzoFOTk6OjqPOQQ6OTk5kDqNO4I8jDuHOos7hzoBO4Y6njuaOoY7hTqDO5I6gzmJOo47iTyJOwM6OzuFOgE7kTqNO4c6iDmIOgE7iDqCOYY6ATmFOgE5izqaO4U6ijmIOoU7kDqGOQM6OTmIOpc5hDqLO4s6iDmHOoc5hjiTXwdeXl5fX19ehF+EXgNfXl6KX4ZeiV+EXoZfjV6FXaleAV+JXpNflF6GXQZeXl5fXl6XX4pehF+DXo1fi14EX19fXppfA15eX6NeBF9fXl6EXwFen1+XYIhfh2CRX6FgAV+nYIZhimABYahgj2H4YARhYGBgkmEEYGBgYYRgh2GjYAVfX2BfX4tggmGeYIthhWCCYc1giF+HYIdfgmCNX4Nell+EYIZfkGCVXwFgj18Ct7aHt4y2Are2hLeJtgS1tra1mLaFtwG2hLeItgG3o7YCt7aEtwO2treFtoO1hbSNtbG2krWYtgK1toS1kLYDt7a3nLaFt4i2l7eLtoe3BLi3uLiNt4a2hLWHtoa3BLa3t7eOuKO3kriPuY64l7mEuIK5hLiLuQe6urq5urm5iLoEubm6uYy6h7mMuoi7h7qJuYe6hrmCupe5AbiNuYy6i7kDuLi5jLiLuYu6o7mSupa5iriVuQG6hbmCuJG5Cbi5uLm5uLi4uYa4hLmVuIK5hbiMtwG4ireMuIK5i7iDt4u2hbeItoO1h7YBt4S2nreFtv9//3//f/9//3//f/9//3+IfwICBACCOIc5hzqUOYs4Bzc3ODc3ODiIN4Q4BDc3ODePOII3hDiEN6E4hzeHOIk5BDg4OTmGOAc3Nzc4ODc3iDiCOZA4gjmMOII5lTiGOYs4iDmLOAQ5OTo6hTmHOAM3ODiEN4Q4gjmJOoM5jziCN4U4hzmCOog5ATqJOZU4nTmGOoY5ijiVOYU6hTkFOjo6OzuFOoY7Azo6O4c6ATuLOoU7hTqOO4g6ijuGOgE7hjqEOYM6hzsCOjuEOoc7gjqLO4Q6izuSOgM7OjuEOoU7BTw7Ozw8kTuFPJI7Cjo6Ojs6Ojo7OzuGOoQ7BTo6Ozo6kDsDPDs7hjyKOwE6jjsIOjo6Ozs6OjqNOYY6ijkEOjo5OYg6iDuPOgI5OoQ5Azo5OYk6hTurOok7hDoFOTk5OjqHOQE6ijkEODk5OYU4ijmCOJI5hDiCN4U4jTkBOoU5hTiON4Q4Bl5eXl9fX5Negl27XgFfmF4BX4ZeA11eXpBdh14BX4leil2CXoldiF6IXYtejl2FXoldh14BX4dehF0FXl1eXV2RXohdBF5eXl+IXoJdjV4BXZxeg1+EYINfhV6QX4JekF+DYIpfgmCVX4dgg1+HYAFfhmABYY5ghV+YYAZhYGBgYWGSYIZhAWKQYYlgg2GGYJBhAmBhi2CKYYNijGGFYIZhAWKPYQFgkmGEYJBhh2KJYYpiBWFhYmFihWEBYJBhjGCKYYxgn2GEYIZhAWCEYQRgYWFhkWCMYQVgYGBhYa5gCV9gYF9fYF9fX4dggl+SYJtfCGBgYF9fX15eil8BYIxfjl6QX4pelLWFtou1AbSHtYO0jrUDtLW1iLSHtYO0hrWftJG1kbSMtQG2hrWCtI21iLSCtYa0jLUBto61hbSDtYm0ArW0mLWFtoK1jLaMtYS2hLUFtra2t7eYtgW1tra2tYq2Are2ibcEtre2tpC3hbaGt4W4Cbm4uLi5ubi4uIa3hriFt4e4greSuJC5mriCuYe6irmFuoi5hLqOu4W6AbmIuga7u7q6uruLuoa7jrqKu4+6i7uEugG5hLqCuYe6ibuGuoO5iroDubm6hLmEuoO5hLiEuQG6hrmEugG5iLoFubm5uLiIuYW6g7uLuoK7h7qfuYe6hLmDuIm5Brq6u7q6uoW5rbgEubm4uYa4g7mEuIa3hriJt4a4hLeFtpi3g7aIt4K2hrWHtoS3hrYBtY22grWUtgG1/3//f/9//3//f/9//3//f4h/AgIEAII5hDiIOQI4OYY4jTeEOAE3hziCN4U4hjmLOIg3izgCNziTN4c2nDeFOIg5hDieN5U4izeLOAc3ODg4OTk5hTiPNwE2iTeFOII3kDiDOYQ4hjeCOIU3hjiEN444hTkEOjk5OYw4hTeFOIY5iTiLOY44hDmCOoY5hDgGOTk5Ojo5hDoGOzs7Ojo6iDkHOjo5OTo6Ooc7DTo6Ojs7Ojs7Ojo6OzuHOoc7iDqPO4U8iTuEPIU7BDw7OzyIOwU8PD08PIc7BDw8OzyKO488Bz09PTw9PT2GPIQ7kTwBO4Y8hDuEOoU7hjyHOwM8OzuEPAg7Ozs8Ozw8PIQ7kDyFPQM8PD2FPAI7PJE7iDqMO4M8jDuGPAM9PDyFO4Q6lzsEOjo7Oo47hzoDOTo5jzqEO4Y6hjmTOgU7Ozs8PIc7Bzo6OTo6OjmIOoU5gziHOYc4gzmHOgM5OTiHOQw4ODk5OTo6Ozo6OjmJOIM5hTqIOQE4hDmGOAQ5ODg4hzmGOAM3NziIOYxdAl5dhV4BX4peiF2DXJddAV6HXYJcjl2CXoVdC1xcXVxcXVxcXV1dhV6LXYdchV2KXIVdAVyTXYZcmF2GXKFdBF5dXV6EXQFejl0BXoRdClxdXV1eXl1eXl6HXQJeXYteg12JXpJdkV4BX4dekl+MXo5fhWCJXwJgX4xgBV9gYGBfkGCEYQJgYYRghl+HYIthg2CLYYJih2EBYodhgmKGYQFgiWEEYmJjY4hihmEBYo1hmGKFYYRiiGGXYgZhYmJiYWGHYgFjjmKCY4ViiGMDYmNjlWKCY4ZigmGNYoJhkWKCYYRil2GDYIhhhGKGYYZgg2GGYoVhAWCJYYRghGGJYJBhBGBhYWGHYIJhkGCFX4Rgh18FYGBfX1+RYINfiGCKX4JgjV+FXgVfX19eXo5fiV4EXV5eX4dehF8GXl5eXV1dhl6GX4deg12GtAW1tLOzs4i0AbWJtAS1tLS0hrUOtLSzs7O0tLSztLS0s7OLtIWzg7SFtYS0hbOCsoezA7S0tYe0BLOztLSUswK0s4S0jrOCsoWziLQDs7O0hbOItIazg7SHs4y0hLOEtAGzh7SKs4m0ArW0hbUFtLS1tLWGtIS1g7SEtQe0tLW1tLOzirSEtQW2trW1tYa0kLWCtoS1hLSKtYa2g7WItga1tra2tbWJtga1tra2t7eQtoK3jbiGt4S2hLeHuAO5uLiMt4S4jrkBuIm5hbqEuY66hLkEurq5uYu6A7u6uoS7BLy7u7uHuoS7grqIuwe6uru7vLy8iLuDvIW7h7yKu5i8hLuHvAO7u7yGu5S8Ab2EvAi7u7y8vLu7u4a6hruEvIm7hbqCu4S8BL29vLyPu4O6h7sEvLy7u4m6gruIuoS7BLq7u7yKu4i6Aru6h7uCuo65Bbq6uru7iLqEu4W6jbmOuAS5ubm4hLmIuIq5hbiHtwi4uLm4ubi4uIW3griHtwe2t7e3tre3hLiFtwe2trW1tra2iLcJtra2t7e4t7i4hLeCtY+2CLW1tra2tbW1hbaItYK2hLUDtLW1hLSHtQO0tLWHtP9//3//f/9//3//f/9//3+IfwICBACEN4M4hjeJOIo3hTiZNwU4Nzg4OIg3hDYENzc2NpA3gjiEN4o2jTcDNjc2hDcBNog3BTY2NzY2mDeDOIU3BDY3NzeKNgg3Nzg4Nzc2Noo3ATiYN4Y4hDeCOIU3gziJN4s4hjeFOIo3Bjg3ODg4N484hDeHOIQ3hjiEN4Y4gzmGOAg3ODg4Nzg4OIk5hjgENzc4OIg5ijgBOYs4BTk5OTg5hTiHOYo6Azs6Ook5hDqKOYM6hDsBOoU7Bjo7Ojo6O4g6lDsBPIY9gjyEO4Y8hTsGPDs7PDw7hTyTOwE8hj0DPDw9mzyCO4Q8hT2QPAU7PDw8O4U8hD0IPDw8Ozw7OzuJPAQ9PDw8hT2lPII9iTwEOzw8PIY7Bzo6Ojs8PDyEO4g8iDuEPJA7Bzw8PD09PDyKOwE6jjsEPDs7O4Y6iDuFOok7hjoBOYY6hzsEOjo6OYQ6gjmGOoQ7gzqFOYI4hTmDOoQ5jTqDOYQ4Bzk5OTg4OTqGOQU4ODg5OYY6Bzs6Ojo5OTmEOAg5OTg5OTk6OoU5BTg4ODc3hjiJN4Y4BDk5OTqEOY84ATcBXYVehV2CXIpdhlycXYdcAV2IXIVbk1yHXYVcAV2NXIRbkFyFXY5chFsCXFuHXIJblFyGXYRcgluNXARdXVxcjF2EXIJdhFyEXQVcXF1dXYhcjV0BXoRdAlxdhFwEXVxdXYVeCl1dXVxdXVxdXV2EXJJdlF6FX4JehF+CXoRdjl6IX4Nehl8BYIZfhmCLX4RgA19gYIlfhWCHYYhggmGKYAJhYIRhg2CMYYdihGEHYGBhYmJhYYpihWGCYoVhhGKDY4ViiWOIYoRjAWSKY4ViBGNjYmOLYohjAWKKY4Rkm2MEZGRkY4RiAmNihmMEYmNjY4RkhGMFYmJjYmOJYotjkGKCYYdihGMGYmNjYmJjhGIHY2NjYmJhYZBiiGGCYoRhg2KGYYJihGEDYmJhhWKFYYJghWGEYoZhAWKOYYRgB2FgYWBgYWGGYIphhmCCX4VghV+EYINfkmAEX19gX4dgh18IYF9fXl5eX16NX4Jeh1+FXgJfXodfhl4BX4teAV+FXgFfhF6EXYdehl0BXItdBrOzs7S0s5S0hLWHtIazB7Kzs7KysrOEsoSzh7SEs4a0BLOzs7SIs4OyiLOEshOxsrKxsbKys7KysrGysrKxsLGxhrKCsYWyhrEBsoqxAbKEsYWyi7GesgWzs7O0tIazAbKEs4K0hbMNsrKzs7KysrOzsrOztIaziLSCs4a0BrW1tLSzs4myCLOys7O0tLS1hrQBtY+0hLUFtLS1tbWHtJ21hLaEtYa2iLWFtgi3t7a2t7e3toS3g7aKtwG4hLeCtoS3Bbi4t7e3hLgDubi4h7cDuLi5hLiKtwq4ubm5urq5ubm6hbmHuoK5h7oDu7u6hLsBvIm7Bry7u7u8vIm7A7q7uoe7gryIvYS8A728vIS7h7yCvYW+hL0EvLy8vYa8hb2DvIq9BL6+vb2EvIm9BL69vr6HvQa8vL29vb6EvYO+ib0BvoS9AbyFvYO+iL0EvLy7u4i8BL29vr6MvQK8vYW8kb2CvIe9k7yCu4S8g7uFvIS7DLy8vL28vLu8vLy7u4S6AbuHugO7u7qGuwm6urq7urq7u7uFuoa5hroBuYa6Bbm5uLm5h7iJuYK6hbmGuIe5griJuYS4Bre3tre3t4S4hreDto63AbiGt4S4greMtgO1traJtYS2A7e2toq1AbaGtQe2tra1tba2jbUBtoW1grSEtYK0h7WCtIS1grT/f/9//3//f/9//3//f/9/iH8CAgQAhjgCNziFN4g4gzeOOJI3ATiFNwE2jDcFODg3ODiUNwI2N402iDe4No43izYDNTY1hzaDN4k2hTeHOIY3AzY3N4c4gjeENgg3Nzc2NjY3N4U4hTeDOJo3hTgONzc2Njc3Nzg4Nzc2NjaFNwM4ODeUOIk3hDiDOYU4EDk4OTg4OTk4ODk5ODg4NzeFOI45gziHOQE6hTmEOoU7hToDOTo6hjsEOjo6OYU6iDuEOgk7Ozs6Ojo7OzuFPAI7OoY7BDo6OjuEOog7hjyIOwE8hD2EPIU9Bjw8PDs8PIw9hT6EPQY+Pj0+Pj6EPQE8hT0HPj4+PT09PIY9AT6IPYI+hz0BPoY9hDyKPYM8hj0BPIU9ij6FPQE8lT2CPok9iT4IPT08PDs8PDyMPYI8jz2HPIg7hDwBPYQ8gj2IPIg7hTwDOzs8hTuJOoI7hTwCOzyJO4U6hDuJOoU7gjqGO446hTsDOjo5hzqEOQY6Ojo5OTmFOgE5ijoEOTk5OIs5CDo6Ojk5ODg5iTiCOYU6CDk5OTo6Ojk6hTmFOoI5hTgEOTg4OIU5hTgGOTk5ODg3kTiCOYg4hDkBOJFdAV6HXZNcAVuoXJxbAVyYWwNcW1uFWoRbAVqUW4pcB1tbXFtbW1yEW4RahlsFXFxcW1uKXIVbiFyEW4VchF2HXIRbhVwHW1xbXFxdXYRcAVuEXAFbjFwBXYZcA11dXIddA1xdXYVek10EXl5fXoldCV5eXV1eXV1dXoZdA15fX4deAV2EXglfX19eXl5fXl6EX4JekV+HYAZfX19gX1+PYItfhGACYWCJYYNgkGEFYGBhYWGEYgFhiWKEY4ZiA2NiY4ViAWOIYodjh2SEYwliYmJjZGRjY2OIZIhjhGQHY2RkZGNjY4VkgmWHZIRjjGSCZYdkgmWOZIdliWSEZYJkh2OLZIhjiWQDY2RkiWOIZI1jgmSPY4ZkA2NkZIljBmRkZGNjY4VihmOCYoZjjWKCY4likWEEYmFhYIVhgmKJYQFghGEBYIphimABYYtgg2GGYAZfYF9fX16KX4Ngil+CXpNfhV6HX4hehV2IXoRdil6GXQZeXl5dXV2EXgNdXVyLXQRcXF1dhLOGtIWzB7Kys7Kzs7OEtIWzgrKFs4KyibOCsoezkbIEsbGwsIWxg7KXsYKwhLGGsJCxhrKFsQywsLGxsbKxsLCvr7CFsYewg6+EsAWxsLGxsYewg7GFsgexsLCwsbKyirGCsISxBLKysbGGsgWxsbGwsIWxiLIGsbKysbGyhbMJsrKysbGwsbGxhbKCs4SyDrOztLSztLSzs7S0s7S0i7MQtLS0s7O0s7O0tLOzs7S0tIW1hbQBs4W0BLW1traRtQi2trW1tbS0tYe2hrUDtra1hraDt4i2Bbe3tra2hLcJuLe3t7i3t7i3hrgFubm4uLeHuIi5griRuYa6Cbu8vLu7urq5uYS6hbuCuoS7AbqNu4W8g7uEvAG7hrwDu7y8j70EvL29vYe+jb0PvL29vb6+v7++vr2+vr2+hL0GvL2+vr+/hb6Fvwe+vb6/v7/AhL8GwMC/v7/Ah78Dvr+/hMCCv4S+g7+Jvoi/kr4Lv7+/vr6+vb2+vb2Gvga9vb2+vr6OvYW+hL0Hvr6+vb29vIi9irwCvbyFvQG8h7uCuoS7B7y7vLu8u7yIu4K6hruEuoa7hLqFuwm6urq7u7y7u7uGuou7Brq6u7u7uoa5AbiFuYS4iLmcuAO5ubiJt4S2AbeEuA23t7e2t7i4uLe3tra2h7eFtoK1hLaCtYW0ArO0irWCtoS1grSFtYS0grWHtAO1tbSItQS0tbW0hbWKtP9//3//f/9//3//f/9//3+IfwICBAAGODg4Nzc2hjcHODg3Nzg4OIs3gjaFNwU2NjY3N4g2kjeCNoY3AzY3N6M2jTeINoY1izYDNTU2hDWENoM1jTYFNTU1NjaVNQE2hDeGNoY3jTYPNTU1NjY2NTY2Njc3NjY2hjeGNpQ3gjaIN4I2jDeCNoQ3hTaMN4c4izeHOAU3Nzc4OIU3gziFOQk6OTk5ODg5ODiEN4Q4gzeGOAY3Nzg5OTqFOYQ6kjkHOjo7Ojs7OoQ5izoBO4Y8BTs6Ojo5hDqEO4c6hzuEPAQ7PDw8hz0FPDs7OjqNOwk8Ozs6Ozs7PDyGPYQ+hT2EPAY9PD08PDyRPQc8PT08PT0+hz2EPgY9Pj49Pj6FPQc+Pj09Pj09hDyCPYQ+iD2GPgE9kT6KPwI+PYQ+CD8/Pj4+PT09hD4GPT4+Pj09hD6KPQY+Pj0+Pj6HPYQ8BT09Pz8/hD6GPQk8PT09Pj09PTyEPQs+Pj49PT4+PT08PIU9AT6GPQc+PT08PTw8hz2LPAQ9PT0+hD2IPIU9gzyGOwU8PT08PIo7izyUO4c6hjkFOjo7OzuEOoM7hzoEOzs6OoQ7iTqCO4k6Azk5OIo5GTg5OTg4OTo6Ojk5Ojo5ODg4OTk5Ojo5OTmIOAY3Nzg5OTmEOAo5OTk4ODc3Nzg4hDkDODc3iziFN4k4i10CXF2YXAFbhFwFW1xbW1uEXANbW1qNW4lcl1sBWoRbAVyLW4paAVuFWgJbWoRbB1paWltbWlqEW4daiFuOWoNbhloBW4RajVuIWoRbglyNWw1cW1tcXFtbXFxcW1tbh1yHWwNcXFuEXAZbWltcXFyHW4VcB11cXFxdXV2JXIVdBlxbW1xdXYRckF0IXl1eXl1eXl6NXYhehF2QXgJfXo5fBWBgX19eiV8BYIxflGABYY1gh2EBYothBGJiYWGHYoVhBGJiYWGGYopjgmSGYwFkiGMFZGRkZWWEZINjhmQDZWRlimQFZWRkZGWEZAVjZGRlZY1khGWIZBRlZWVkZGVkZGVmZmZlZWRkZGVlZoZlAWSFZQNmZ2eGZo1lA2ZmZ4hmh2UFZGRlZGSEZYRkAWWFZItlhWQBZYVkCGVlZWRlZGRjh2QHZWVkZGVlZYVkg2OIZARjZGRlhmSQYwFih2OIYpBjHGJiYmNjYmNjY2JiYWJiYmFiYmJhYWFiYmFgYWGFYohhg2KKYYJghWEEYGFgYIdhjGCDYYRgAV+RYAFfhGCDX4dghF+DXoRfB15eX19eXl6HXwxeX15eXl9fXl5eX1+GXgFfhF4OXV1eXl1eXl1dXl1dXV6MXYVchV0BXoddhbMNtLS0s7OzsrOysrGxsYeyhbOGsoWzBLKys7OGso6xBrCxsbCxsZKwAa+EsImvhrAEr7CwsI2virCFrwawsLCvsLCHr4SwhK+FsISvAa6ErwWwr6+wsIWvBbCwsLGxh7CGrwKwr4uwBa+vsLCxhbAEsbGwr4ywB7GwsLGwsLCGsRKysbGxsrKysbGysrGxsrGxsrOHshCzs7OysrOzsrGxsrKys7KyhLOCsoSzAbSJswGyiLMFtLS0s7OItJK1CrS1trW1tba3t7aEtZC2Cbe4uLi3t7e2tom3hLYBt5O4hLcJuLi4ubm6ubi4hbkEurq6u4S6ibmDuom7Bby8u7u8hLuCvIS7BLy8vLuIvAW7u7y8vYS8h72FvgG/hr6FvQi+v76+vr+/wIS/g76Ev4O+hL8Gvr6/v76+hL+GwBO/v8DAwcHAwL++vr+/wMC/wMDAhsEDwMHBhcAWwcHBwMHBwMC/v8DBwcHAwMHBwcDAv4TAgr+GwILBhMABv4W+BL/Av7+KwIO/hMAIwcHBwMDAwcCIvwfAwMC/vr6/hL4Iv8C/v76/v8CFv4W+hr+EvgG9hL4Mv76+vr29vLy8vb6+ib2FvoW9Br6+vr29vYW8g72GvAG9hLwFu7y8u7yIu4a8ELu7vLy8u7q6uru7vL28vLyEuwW8vLy7u4W6BLu7vLyEuwS6urq7hLoEu7u7uoW5hLoFubq5ubmGuAG5hbgEt7e3toS3B7i5ubi4uLeMtoS3Dra2trW1trW0tLS1tba3jLaJtYS0AbWEtIK1hbQItbW1tLSzs7OHtAe1tLS1tLOzhLSCtYa0g7OEtAOzsrKEs4SyAbP/f/9//3//f/9//3//f/9/iH8CAgQAhjcJODc3ODc3Njc3hDgENzc3OIQ3BTY2NjU1jDaFNwg2NjY3NjY2N4c2hjcDNjY1jzaENYU2AjU2hDWDNoY1BDY2NjWRNpg1BDY2NTWFNpI1BDY1NTWENgk1NDQ1NTU2NjaGNY82ATWENgE3iDYENzc2NoY1CzY2Nzc2NTY2Nzc3jDaEN4g2hDeDNoQ3BDY3NzeHNgc3ODg3Nzc2hTcBOIY3gjiEN4c4Ajc4hTcDODg5hzgDNzc2hDcBOIc3jTiKOQE6hDkFODg5OTqZOYQ6gjuHOoo5gjqJO4Y8CDs7PDw7Ozs6hjuCPIU9hzwBO4Q8gz2EPAs9PTw9PT08PD09PI49BD49PT2HPoY9CD4+Pj09PT4+hj2GPgg/Pz49PD09PYc+gj+EPoI9hz4CPT6EP4U+hD+GPoI9hD4JPz8/Pj4+QEA/hD4EP0BAQIY/AT6HPwc+Pz8+Pj9AhD+HPgY/QEA/Pz6GP4NAhj8EQD9AQIQ+ij+HPoc9AT6GPYM+hD8FPj0+Pj6NPYM+hD0FPj0+Pj+EPgE9ijyMPYQ8hTsBPIU9iDwBPYg8Bz09PTw8PT2NPAE7hDqFOwQ8PDs7hjoEOzs8PIQ7gjqGO4c6hDmEOgM7OjqMOYM6iDkHOjo6OTk5OIY5CTo6Ojk4ODk6OoY4Azk5OoU5hziCN4U4hDkBOIQ3iDiCN4c4gjeEOAY3Nzg3NzeFOIU3hV2LXIVbClxcXF1cXFtcXFyEWwRcXVxciFsLXFtbWlpbW1paW1uFXIpbBlpaWltbW4hagluLWgFZkVoFWVpZWVmHWgFZh1qEWYRahFkBWopZg1qEWQZaWlpZWVmEWoRZBVpaWVlZlloBW4ZaA1taW4dag1uGWoZbAVqMWwFahVsHWlpbW1tcXIVbDVxcW1xcW1tbXF1cXV2HXAJbXIRdglyFXYlchV2EXIpdglyIXQFeiF2CXoZdA15dXYVeBl9fXl9eXoRfh16NXwhgYGBfX19gYIVfnmAEYWFgYIphB2BhYWFgYWGUYgdjY2JjYmJijmOEZAZjY2RkY2OQZIJlhGQDZWVkhGWCZIdlCGRlZWZlZWVkhWUGZGVlZWZlhGaDZYRmCWdmZmZlZmZlZYVmDWdmZmZlZWVmZWZmZmWEZgFlh2YHZ2ZmZmdmZYZmimcEZmZnZ4tmhmeIZoRnhmYBZ4RmBGdmZmWHZgFlimYCZWaEZQ1mZmVlZWRkZWVmZmZlhGYEZWVlZIRlg2SFZYZkBmVlZWZmZYpkA2NkZIRjhGSLY4NkhmOCZIRjAWSFYwViYmJjY4ZihGMDYmNjhGIBY4liAWGEYophg2CFYQZgYGFgYGCFYYRghmGEYIVhiWCFX4ZgjV8BYIVfAWCGXwxeX19fXl9fX15dXV6EX4teg1+EXgtdXV5dXl1eXl9eXoRdAV6JXQFchF0FXFxeXl6EXQJcXYRcAV2EsgezsrKysbKyhrGGsouxBbKxsbCwhbGDsISxBLCxsbGFsAKvsImvhrAMr6+vsLGxsbCwr7Cwha8Erq+vr4awjq+Kroiti64BrYSuhK8Grq6ura2uhK0Crq2ErgKtromvELCwr66urq2tra6ur6+vrq6Ir4Ouhq+CroevBa6urq+whK8HsLCvr66vr4ewBq+vsLCxsIWvAbCIsYWwBLGxsLGEsASxsLCwhbGCsoSxhrICsbKGswG0h7OEtAuzs7S0tLOztLOzs4a0AbOItAS1tLS0hLUHtra1tbW2toi1AbaFtQG2hLeKtoK3hLiIt4a4g7eFuAa5ubm4uLiHuQG6hLsR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hTSDNYQ0DjY0NTY1NTU2NjU1NTY2hTUENjY1Noc3ATaGNwE4hDcOODg4Nzc4Nzg4OTg4OTqEOYY6ETs7Ojs6Ojs7Ojs8PDs7PD09hDyJPQY+PT09Pj2EPgs/Pj4+P0E/QEBAQYlABUFCQUBAhUEBQoRBD0JCQkNDQkJDQkJDQ0NCQ4ZECUNEREVDQ0VFRYZGJ0VGRkVFRUZHR0ZFRUZGR0dHSEhGR0lISEdHR0hHRkdHR0hHR0hIR4hIB0dISUlISEmHSgFJhUoTS0lKSUpLS0pKS0tKSkpLS0pLTIhLDEpKSktLS0xLTEpLTIdLEUxKS0tNS0xKTE1NTExLTExMhEsNTEtKS0xLTE1MS0xLSoVMBk1MTExLS4hMGU1OTEtNTExNTExNTEtMS0pLTE1MTkxNTU2ETBdLSk1NTEtLTExMS0pKTExMS0pLS0tKS4RKCEtLS0pLSklJhUoSS0tLSkpKS0pJSUpJSklJSkpLhEovSUhHR0lKSklKSklKS05SVFdXWFxgY2RmZmRgXFZTUU9MTExLSkhISElISEhHRUaHRSBGRUNERUVFQ0NERUNDQkREQ0NDQkJDQkJCQ0NCQkJBQoRBDUBBQEFAQEA/QEA/QD6GPws+Pj49Pj8/PT4/Pok9hDwFPT09PDuEPIU7hTwDOzs8hjsMPDw7Ozs6Ozw7PDs7hDojOzs8PDw7Ojo4Ojo5OTg5ODg4OTg4ODk4OTo6OTk4ODk4ODmEOAw5ODc3Nzg4ODc3ODiIN402BzU2NTQ1NDSENQE0CVhYWVhXV1hYWIlXB1ZWVlVVVVaFVQlUVFRVVFNUVFSLU41SA1FSUohRBFJRUVGEUA1RUVBQUVFRUFBRUFBPhlABT4RQDE9QUE9QT09PUE9PUItPAU6GTwROT05OhU8ITk5PT05OT06FTwFOhk8BTpNPhFAET1BPT4RQBU9PUFBPiVABT4hQAVGGUApRUFBQUVBRUFFSh1EGUlFSUVFRiVIFU1NSU1KFUwFShVMFUlNTVFOEVA9VVFRVVFVVVVRVVVZWVVWIVghXVlZXWFdXV4hYh1kJWlpZWVpaWVpZhVoCW1qGW4lchF0GXF1dXF5fhl6FX41gBmFgYGFhYYZiiWMCZGOFZIRlh2YNZ2dnZmdnZ2hoZ2hoaIVpBWppamlphWqEaxBqa2xra2xsa2tsbGxtbGxuh20Gbm5u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TU1NTE1OTU1NS0tNTk5NTU5OTU1NTkxNTU1MTU9OTE1MS0xOT4VNAk5NhE4NTUxMTU5OTkxLTE1MTIRNCE5MS0tMTU1MhEseSktMTExLS0tMTEtMTU1MS0tLTExLTEtLS0xLS0xMhEsKSktKS0pJSUtLTYRPHlBSVVZVV1dWWFlZWlpYV1RRT01MTEtJSUlISEhJSIVHDkZFRkZFRUZGR0dGRkREhEWGRAdDRURCQkJEhUMnQkJBQkJCQUFAQD8/QEBAQUA/QEA/Pz4+Pj8/Pj49Pz4+Pz49Pj09hT4FPz49PjyFPQk8PDs8PDs8PDyEOx08PTw7Ojo7Ozs6Ojs6Ojo7Ojs7PDw8Ozs7Pj8+PIU6hDkLODk5OTg6Ojk4OTmFOgQ5OTg5iDgFOTg5OTmINwQ2Nzc2hTcENjY2N4Q2DTU1NTQ1NTY2NTU1NDQJWFhYV1dXWFdYhFcRVlZXVlZVVVZVVVVUVFVUVVWKVI1Th1KKUQ5QUFFQUFFQUVFRUFBQT4RQBE9QT1CFT4JQi08QTk5PT05OT05OT09PTk5OT4ROAU+GTgFNhU6CT4ROAU+TTgdPT09OT09OiE8MUE9OT09PTk9PT1BQiU8RUFBQT09QT1BQT09QUFBPUE+HUIVRAU+EUIVRBVBRUVFQhVEEUlJSUYxShVMIVFRTVFRTVFOHVARVVVVUhFUbVlZWVVVWVVZXVldXV1hYWFdXWFhXWFhZWFhYiVkCWlmHWgRbW1tchFuGXANdXVyKXYVeA11eXoVfhmABYYVgCWFhYWJhYmJiYYRihGOJZIRlAmZlhGaGZ4RoDmdoaGlpaGhpamlqamlphWqEawpsbGtra2xtbWxsiG2CboZvAXCEb4NwjHECcnGGchVzc3Jyc3Jzc3Nyc3N0dHN0dHV0dHSFdQF0hHWEdhV1dnd2d3Z2d3d4d3h3d3Z2d3h4eXmFeAx5eXl4eHl5eHp5eXqEeQF6hHkFenp5eXmKegZ7e3p7enqFew16enp5ent7ent7e3p6hHsJent6e3t6e3p6hHsBfIZ7AXqEew58e3t6e3t7enp7e3p6e4R6AXyGe4V6BXl5enp6hXkGenp5eHl6hHmGeBV5eXh3eHd3d3h4d3d4eHh3d3d4eHiEd4R2M3d2d3d3dnZ3dnZ2d3Z2dnV0dHR1d3l5eHl6fH5+fn+AgYKCg4OCgH17eXl2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hiwEKysrKoQrBCorKyqEKwEqhysDKisrhCoKKysqKiorKiorK4cqASuLKgEphCoEKyoqKYYqgimLKggrKisrKioqK4UqAisqhiuEKoUrgyqPKwgsKyssKyorK5Asgi2MLAgtLSwsLS0tLIUtBS4uLi0tii4ELS8uLoUvBDAwLy+EMAMxMTCEMQEwhjEBM4UyBjMyMjMyM4k0BDU0NDWENIc1BDY2NjeGNgs3NzY3ODg3ODg4N4Y4hTkCODmEOgE5hDoDOzo6hjuGPA09PDw9PD09PTw8Pj4+hD8oPj4+Pz9APz5AQEBBQUBAQUFAQEFBP0FBQkJBQUJCQkNDQ0JCRENDRIVFAUSERQRGRkZFhEaERyVISEdGSEdHR0hIR0hJSEhJSElJSktJSUpKS0pKSUtKS0pKS0pLhEoHS0tLTEpKS4ZNBExMT0+FTVtOTU1OTk5NTk1PT05NT05OTk9PT05QUE5PT1BQT09QT09QUFBPUVBNT1FQUFFRUFBQUlJTU1NSUlJTUVJSU1JRUVJRUlJSU1FSUlFRUFJSUVFSUlNTUlNTU1RThVIRU1NSUVFTU1RSUlJTUlNSUVGGUg1UVVRUVVVWU1NTVFVUhFMGVFNTUlFRhFKEUxdSVFJTUlJSU1NTUlJRU1NTUlFRUlBRUoVRClJRUFBRUlFQUVGFUDpPT09OT09PUE5PT05PUFBPTk9PT05NTE1OTUxNTk1OTk5NT09OTU1NTk5OTUxMTEtLS01MTEtLTEtKh0uFSgNJSkqFSQpISEhHSEhIR0dIhUcBRoZHAUaGRQFGhEUQREVEQ0NDRERFRENCQ0REQ4RCAUOGQoZBA0BAQYRABz8/P0BBPz+EPgg/Pz4/Pj4+P4U9Bzw8PT08PDuEPAM7PDyEO4Q8hTuFOk47Ojo7Ozo6Ojs7PD09PD09PkBBRkpMTEtLTU9RUVFST01KSUhHR0lOT1RWWFhXVVNRTk1KR0VDQkFBPz09PDw/QkZHRkRFR0lKTEtKSEcSZ2VlZGNiX11cW1pZWFZXVlZViVSFUw9SUlJTUlJSUVFRUFFRUFGNUAtPT1BPTk9PTk5OT4dOA01NToRNCExMTUxMTE1Nk0wBS4xMAUuoTAdNTExMTU1MhE0LTE1NTExNTUxNTUyGTQRMTU1OiU0LTk1NTU5NTk5NTk2GTgFPjU4GT09PTk9OhU8GUFBPT1BPiFCGUQFQhlGFUg9TUlNTUlJTUlNTUlNTVFOGVIZVAlZVhVaEV4pYhlkGWlpaW1pahlsCXFuHXIldhV4GX19fXl9fhGABYYVgA2FhYoRhBGJjYmKHY4Rkg2WFZhNlZmZnZ2dmZ2doaGloaGhpaWppiGoHa2tqa2xsbYVsCW1sbW5ubm9uboRvA3Bwb4dwgnGGcglzc3N0c3N0dHOIdQZ2dnZ3dnaFdwF2hHeGeIR5Anp4hnoCe3qHe4p8IH19fH19fXx9fX18fX5/fn5+f39/fn9/gH+Af4CAf35/hoAWgoGCgICCg4GBgoKCgYKDgoKBgYGCgYSCgoGEgiCDgoKCg4KCgoGCg4KCgoOCgoODhIOCgoKDg4KCg4KCgoWDB4KEhISDgoKFgwmCg4KBg4KCgYKFgYSCG4GCgoGBgYCBgIGBgICBgIGAgH+Af4B/f39+f4V+BH1+fn6HfQN8fX2EfBd7e3t8e3x8e3x6enx7e3t6e3t6enl6eYx6BHh5eXqEeIV3CnZ2dnd3dnZ2dXWKdAFyhHMccnJyc3JxcnFxcHBxcHBvcHBwb3BwcG9wb25vb4duhW0CbG2EbIZrA2pra4ZqhGmIaAdnZ2doZ2dmhWcFZmZmZWaFZQRkZWVkhmOFYoRhhGKIYQRgYGBhiGBGYWFhYmJjY2FiZGVpbW1tbGxvcnJzc3JybGtpaGdpa25xdXl4eXl2dHBubWtoZmRlZWRjYmBfYGJlaGhoZ2dpa21vbWtrah28urm4trSzsK+ura2rqqmpqKeop6empqalpaalpYakCqOjoqKjoqKjoqKLoYWghJ8Cnp+Fng+dnp6dnZ2enp2dnp2cnJ2EnIWbAZyEmwGajpsKmpuampqbmpqbm4WaAZuEmgGZhpoBm4WaAZmEmoKbhpoFm5ubmpqEmwGahJsDnJuchZuCnISbCpybm5ucnJybnJuLnAWdnZycnI6dBp6dnZ6enYWeAZ+Gnhafnp6foJ+fn6CfnqCgn5+goJ+goaGgiKERoqKio6Oio6OjoqOjpKSlpKSGpYWmBKenpqaGpwaoqaipqamFqoOrhKyFrQWur62troSvhLCIsQeztLOztLSzhrQ5trW2t7e3tra3t7a4ubi5ubq6urm6ubq8vLu8vby8vb28vb6+vr+/vr+/wMDBwcHAwcHCwsPCw8TDhMQFxcbExcaGxw3Ix8jJycnKycrLysvMhMsBzIbNN87Oz8/P0dDR0dDR0NHR09PS0tPT1NXV1NTW1NXU1tfW1tfY2NfX2NjZ2NnY2dvb2tva2trb29uE3ATb293dhN4C4N6F3w7g4eDf4ODh4eLj4eLh4YTiKuHi4+Pk5eTj4+Pi4+Li4uTk5OXl5ebl5Obm5+bm5efn6OTm5unn5ubn5oTnCObn5+jo6OfnhugN6eno6Ojn6Ojn6Ofo6ITpC+fp6eno6Ojn6OjnhOkk6ujp6Ono5+jq6erq6enq6+rp6Oro5+nn6efo6Ofo5+bn6efnhOYL5+bl5eTm5uXl5eaF5Qjk5OPk5OPj5ITjIuLh4uHi4eDh4uLh4eDh3+Dg3+Df4ODg39/f4N/f397e392F3h/d3d3c3dzb3dza29rb3Nzb29ra29rZ2dnY2djY19bXhdaE1QTW1dTVhNMb0tLS09LS0tHR0tHQ0NHQzs3P0M7Ozs/Ozc7OhM2EzCXLzMvLy8rJy8rKycrJyMjHxsbIx8fGxsXGx8bExsTExMPCw8PChMMKwcHBwsHCwcDAwIS/EMDAv7+/vr69vb6+vby9vLyEu4O6hLkvurq4uLm5uLi4ubm4uLi3t7e2t7a2t7a2tbW2tbW1tre2t7e4uLi6vL7Cw8PBwsWExzDIx8TAv769vsHExsjMzs7MysjGw8LAvby7urm4uLa1tbW2ubu8vLu7vL7BwsHAvr3/f/9//3//f/9//3//f/9/iH8CAgQAET4/Pz48Ojg3NzU1NDMzMzIyhTGEMAQvLzAwhS8ELi4vL4Yuiy2ELIIrhCwCKyyJKwEqiCuCKoQrhioFKysqKSmJKgYpKiopKSqEKYUqBSkpKiophiqHKQsqKikqKiopKikpKoQpkyoJKSoqKisqKiorhCoKKyoqKyorKyoqKoUrgiqNKw8sLCsrLCsrKywsKywsLCuFLAErhiwBK4UsCC0sLSwtLS0uhS0ILi0tLi4uLS2FLh4vLy4vLy8uMC8wLy8wMDAvMDExMTAxMTAxMTEyMjGEMgkzMjIzMzM0NDOLNAU1NDQ1NIY1BDY1NjaNN4Q4Azc4N4Q4ETk5OTg5Ojk6OTk6OTs7Ojo8hDsCPDuGPIc9Aj4/hD4CPz6GPws+PkA/P0BBQEFBQoVBBEJBQUGFQh5DRERDQ0JDQ0NFRERDREVGRUVFRkZGRUZFRkhGRkeJSAFGhUgKSkpKS0pKS0tKS4RKDUxLS0pLTExMTUxLTE2FTAROTE1OhE0fTk1OTk5QTk9OTU5OT05NTU9QTlBQUE9QT09QUVJRUIRRClBPUFFQUE9QUVKEURhSUFBRUVJTUlJSVFVTU1JUUlJTU1NSU1OFUgdRU1JSU1NSiFMdVFRUU1NSUlNUUlNTU1RUVFNTVFNTVFNTUlJTUlKEUwRVVVZThFYEVFRWVoVVI1RVVFRUVVRVVFNRUVJTU1NSU1NTVFRTU1JSU1RTUlJTUlJUhlMgUVJSUlFSUlFRUlJQUlJRUFBRUVFSUVFQT1BPTk9PUFCFTwRQT1BPhE4HT09OTU5NTYZOAk1OhE0RTExNTk1OTEtMTU1MTEtLS0qESwRKSkpJh0oGSUlISUlJh0gMR0hIR0ZHR0dISEdHh0YLR0ZGRUZGRUVERUaERRREQ0NDRENDQ0JDQ0JCQUFBQkFAQIZBC0BBQUE/QEBBQEA/hEABP4U+AT+EPRs+PDw9PT08PTw8Pj4/Pz4+PT08PT08PDw9PDyEO4M8hD0lPD08PT09Pz4+QENGR0dJSUhIS01MTElISk1PTk1NTExLTEtNToVNH1BTVVlYVlNUVFBNS0hHRkVEQ0VISkpNTElKSUhGRD8XYmJgYF9eXFtaWlhXWFdWVlVVVFVUVFSGU4RSA1FSUoRRB1BRUFBRUFGIUIhPhU4BT4ZOhU2ITAFLh0wHS0xMTEtMS4ZMBUtMTExLiUwkS0xMS0xLTExLS0xLS0tMTEtLTEtMTExLS0tMS0tLTExMS0xLhUwBS4xMAU2NTAVNTUxMTIlNAUyTTQROTk1Nkk6JT4pQAlFQhlEGUlFRUlFRhlIDU1NSh1MDVFRThVSDVYpWh1eDWIlZh1oEW1taWoRbhFyFXQ1eXV5eXl1eXV5fXl9ehF+HYIZhh2KDY4VkhGUIZmZlZmZlZmaFZwNoZ2eGaAFphWoJa2pqamtrbGtrhWyEbYZuBW9wcHBvhHADcXJyhHGFcgpzdHNzc3R0dHV0hnWDdoZ3BHh3d3eGeAN5eXqEeSh6eXp7enp7fHt8e3t8fHt8e3t8fX18e3x9fX59fn5+fX5/f35+f35+hH8EgICAf4aACIGBf4CAgoGBhIIJg4GCgoKDg4OChYMIhISCgoOEhISEgwqEg4SEg4SFhISDhYQDg4OEhIMahISD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Mwg0MzM0MzQzNYQ0izUINjY1NjY3NjaENwQ5Nzc3hTgJNzc5OTo4ODg5ijqFO4c8hD0FPj4/Pj6JPwhAP0BAQUFBQIRBGUJCQkNCQkJDQ0JDQ0NERENDQ0RFRURFRUWFRgNHR0WER4VIAUeESBFJSEhISUpKSUlJSktKS0tLTIRLhkwfTU5NTUxOTUxOTk5NT09PTk9PT1BPUE9PT1BQUVBRUIRRHFBRUVJTUlJRUVJTVFRSU1JSVFNSU1NSU1JUVVWEVBVTUlNTVVVTVFNVVFNUU1RUVFNTUlOFVAtVU1ZXU1NVVVZXV4RWOlVWVldVVlZYV1dWV1VXVlZXVVZYV1VVV1ZWVlVVV1ZWVFZXVlVVWFZVVVhXVldXVlZXV1hXWFdXV1iGVxdYVVZXVlZWVVZVVlVXVlRUVFVUVVZVVIVVGFRTVFZUVVRUU1FSU1NTVFNUU1JUU1NUU4dSAVOEUgxRUlJRUVJSUFFSUlKEURdSUlFRUlFRUVBSUVFRUlJRUFFQUFFSUYRQE1FPUU9OT1BPTVBQTk5OT05OT1CFTgtPTU1OTU5NTExNTYRMGktLTExLS01NTEtMTEtMTEpKSkxLSkpKS0lJhUoMSUpKSUpKSklJSEdIhEcdSEZHR0dIS0tLTExMTU1NTlBQT09PTEdFRURDQ0OEQiNBQkJBQ0VFRUdFQ0NDQkNEREVERERFR0lMTUtJR0hHRkVERIlDTUJCQUBAQkVHSU1PUE9QTUtLS01SVVRXWVpaWlhST05QVVtdX2BhZWZmaGhra2pqZ2VlZmZlYF9aVVJQUVZeZGhramdhXldRS0ZDQUA+FV9fYGJhYF9dW1pYV1ZVVlZVVVRUVIdTg1KGUYVQiU+ITgJNToRNBU5NTU1Mhk2FTAhLS0tMS0tLSopLC0pKSktLSkpLS0pLhEoOS0pKSktKSktKSkpLSkmKSoJJjEoGS0pKSUpLiEoBS4VKiEsFSktLS0qPSwpMTExLTEtMTExLj0wETU1NTI1Nh04ET05OTohPjVACUVKFUQRSUVFRhVIJU1NTUlNTVFNTiFSFVQRWVVZVhVYJV1dYV1dYV1hYh1mGWgZZW1taW1uGXIRdB1xdXV1eXl6JX4lghGGDYoRjCmRjZGRkZWRkZWWHZoRnhGgGaWhpampphWqEa4VsDG1ubm1ubW5ubm9ub4VwhHEKcHFxcXJz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VlVXVlZXV1ZWVYRXZFhYVlZYVldXV1hWWFhYV1hXWFhXV1lXV1ZYWFhXWFdYV1dYV1hYWFZXVlhYV1hXV1dYWFdXWFhYVldXWFhYWVZXWFdXVlZYVldWV1dWVVZXVlVVV1ZWVFVWVlZVVlVVVVNUVFSEVQVWVFRTU4RUG1NTU1JUU1NSVFNTU1RUVFNSUlNTVFJSUlNTVIVSIlFRUFFSUlJRUlJRUVFSUlFSUVJSUlFSU1FRUlJQUFBPT0+EUAtPUFBPT09QT09QT4hOFk1OT05NTUxMTU1MTU5NTE1PTk1MTE2GTBFLTEtLTE1OTlBQUlVUUU9OTIVKKklJSEpKS0xMTE9TVVRTV1hZV1VSVFdYVlBMSUdFQ0NERENDQ0RFRkhHSYRMb05LS0xMTE1OT1FSUlFOSUpKSklJR0VGR0VGSEdHS09OTU1NTEtNTlBUVVVXWlpXVlRVVVZUVVhbX15dWltbV1VTU1FOTE5MTlpfY2RqbXBwdXdzc21kXllVUU1NTVBTWFxfYFxYUk1JRkNCQD49PYRiB2FgXVpZWFiEVwNWVlWEVIRThlKDUYdQhU8HTk9OT05NToRNAU6KTYtMC0tMS0tLSktKS0tLhEoBS5pKEUlJSkpKSUpKSUlKSUpJSkpJhEqCSZRKAUuVSgFLhEqRSwZMS0tMS0uLTAVNTE1MTI5NBk5NTU5OTYVOBk9OT09PUIRPBFBQUFGEUIxRiFKGU4hUh1WGVoVXAlhXhFiGWYhahFsHXFxcXV1cXIVdAl5dhl4PX2BfX19gX2BhYGFgYWFhhmIHY2JjY2NkY4RkhGWFZoVnB2hoaWppaWmFaoRrhWwDbWxthm6Cb4ZwhHEIcnFycnJxcnKEc4V0CnV0dXV1dnZ3eHiEdwJ4eYR4g3mFeoV7hHwEe319foR9gn6Ff4SAhYGEggGBhYKEgwyEg4SEg4SGhISFhYSEhQaGhoaFh4aFhwaIh4aHh4iHh4WIEYmIiYeIiYqJiYmKiomKiomIhIksioqKiYmKiomKiouKi4qKiomKiouKi4qLi4qLiomLi4qKiouKi4qKiouLiouEig+LioqLioqJiYqJiYiJiImIiISHEIaHiYiHh4eGhoaHh4aGhYaFhQKEhYWEDYODhIWFhISDg4SDgoOHggSDgoKCj4ECf4CEfwWAf4B/gIZ/An5/iH4JfX19fn19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ZGVkZmtwdXRuY11aWVhYVlBMSEhGGGdlYWBeXVxbW1taWVhXV1dWVlVUVFNTU4RShlGEUIlPBE5OTU6KTQNMTE2HTANLTEyHSwFMhEsDSktLjEoNSUpJSklJSkpKSUpKSoRJBUpKSklKi0kBSJBJgkqZSQFIhUmISgFJi0oHS0tKS0tLSoVLCkxMS0tMTExLS0uKTI1NjU4CT06FTwVQUE9PT4ZQiVGHUodTBFRTU1SJVQVWVlVWVodXB1hYWFlYWFiFWQ9aWlpbWlpbW1xbXFxbXFyEXQpeXV1fXl5eX19ehF8CYF+FYIVhHmJiY2JiYmNjZGRjZGRlZGRlZmZlZmZmZ2doZ2doaIRpBWppampqhGuGbAFthG6Cb4ZwB3FycXBxcXGFcgVzc3Rzc4V0gnWEdoV3Dnh5eHl4eXp6ent6e3p6hXwFfXx8fX6EfQV+f35/foiAg4GGgoSDhIQrhYSFhIWGhISFh4eFh4eHiIeIh4iIh4iIiIeIiImJiIiIiomJiouKiomKioyLDIyLi4yLjIyNjIuLi4aMD42NjI2Njo2NjIyNjYyNjYSODI2Pjo6NjY6Oj46Pj4SOH42Njo6OjY6Pj46Ojo+OjY6OjY6OjY2OjYyNjYyNjY2FjBuLjIyLjIyLi4qLi4uKi4qLioqJiYmKiYiIiImFiAiHh4iHiIiHhoWHDIWGh4aFh4aFhYWGhYSEA4ODgoSDhoICgYCFgSGCgoKBgoKBg4OEg4ODgoKCg4KCg4KBgYKCgYCAgYGAgIGHgAh/f35/fn19fYR8AX2GfCp7fHt7fHt7e318fXx8fX59fH1+f3+AgoSHjZCTkI+MjI2NjImHg357eHaEdYB2dnh3d3h5eXl4e36Cg4F+fIB/f357eHZ4e3+Afnx7e35/gIB+e3x9fX1/f319fX5+foCBhIaEgYKBfn59f4KHioyMkZedoKOio6SjoJiRjIyOjYiEfnx7fn58e3t6enZ0c3N1d3Z2dnl/gYKBfn57d3Vxc3d3d3yAgH9/f4CBgRyDhoqLhoKDhYSEh4uRk5GJgXp4d3h4dW9sa2toI7q3trKxsa+ura2sq6mqqqmop6enpqWlpKSko6OjoqGgoaChhaCGn4SeDJ2enp2cnJydnZ2cnYScBpubmpubm4aaAZuHmouZApiZhJgBmYWYApeYhJcCmJeFmIqXBJaXl5eFloeXAZaJlwKWmISXGJaXl5eYl5eXlpeXlpaXmZiYl5eWl5eXloSXBJiXmJeKmAWZmJiYmYSYEpmZmJmYmJiZmpmampmampqZmYiah5sBnISbBJycnJ2EnAadnJydnZ2FnhCfn56en5+en5+foKCgoaCghaECoqGEohGjo6Sko6Sko6SkpaSlpqalpoinhKkIqqurqqurrKuErIStha6ErwSxsLCxhLICs7KEsw60tbW1tra4t7e4uLi3uIS5g7qEuwS8vL2+hL0Hvr2+v8DAwITBXsLDw8TDxMTExcbGxsfGx8fHycjJycrKy8vLzM3MzMzNzs/Ozs/P0NHR0dDQ0dDR0tLS09PU09TV1dXW19bX19jX2NjZ2tna29rb29vd3t3d3t7f397g4eDh4eHi4uKG41jk5eXl5ubl5ebn6Ofm6Ofn6enp6uns6+zr6uzt7Ovt7e3u7+/u7vHv7+7v8PDw7/Dv8fLx8/Hx8PHy8fLy8fHx8vLy9PXz8/T08/P09PT19fbz9PX09fX0hPUY+Pj39vf4+Pf19vj39vb39/j49/f49/j3hvgF9/n5+PqK+SP4+Pn4+ff49/n4+Pf49/f5+Pb29/b19vb1+Pf39vf39vb19oT1ffT19vf19fX08vT08/Lz8/Py8vHy8/Ly8O/w7/Dw7+/w7+/v7u/u7u3u7+7v7u3u7e3t7Ozs6uvq6+vs6urp6erp6enn5+fo5+bl5ebl5eXm5ufo5ufm6Ofm6Ofn5uXm5eXm5eTk5eXl5OTl5OPj4+Lj4eLi4uHi4OHf4N/ghN803t7d3N3c3N3c3Nvb3N3c3t3d3d7d3dze3uDg4OHj6Ozv8fDt6ejo6unl4d/Z2NXT09LS0oTUKtPT1dTU09ba3N7b2dfY2NnY1dLR0tbb2dfW1dbZ2Nva1tPU1dbW19nW14TWatfZ29za2djX1tTV1tve4uPm6O/1+Pr6+vn49e3l4OPk4dzZ09PU1NTS0NDPz8vKycjJzc3Ozc/U1tfV1NPQzcvHyMrMzNDU1NPT1NXV1dfZ3uLe2NjZ2Nja3uPo5d/X0MzLzMzKxcG+vbz/f/9//3//f/9//3//f/9/iH8CAgQACEA+Pj05Nzc2hDQCMjOGMQEwhC+ELogtiiyJK4kqCCkqKiopKSkqiykBKIQpBCgoKCmRKAMnKCeOKIQnASiHJxMoKCcnJygnJygoKCcnKCgoJycnhCgJJygoJycoJycnhSgPJygoJycoJycoKCcoKCgphCgEJygoKYQoCikpKCkpKCkpKSiHKQsqKSkqKSoqKikqK4QqASuHKgUrKSoqKoUrASqGKwwsKywsKywsLC0sLC2FLI0tAy4uL4UuBS8uLy8vhjABMYQwiDEHMjEyMTIyMoUzhjQHNTQ1NDU1NYY2Bzc3Nzg4NjeEOIM5hDiEORQ6Ojo7Ojs7Ojo7PDw8Ozs8Ozw8PIc9Az4+PYU/hEAFPz9AQECEQR9CQkNCQkJDQkNCQ0RERkREREVFRUZFRkdHR0ZGR0hHhEgnSUlISEhKSUlJSklLSktKSkpMTEtMTEtKTE1MTE1NTE5OTU5OTk9PhFAbT09PUFBQUlBQUVFRUlJSUFFTUlFRUVNTUFFShlMiVFNUU1NVU1ZTVlVWV1VUVVZVWFdWV1dWVlZXVldXVldXVoVXhFgsWVhZWFhZWllaWllZWFhZWVlaWVlbWVpZW1paWVpaWVpaWlxbW11bWVxbW12EWyVaWltZW1tdW1xbWltbXFtcXF1cXFtbWlxdXVtcXFxdXF1cXFxbhFw2W1pbXFxaWlpZWFlbXFpaWVpbWVtaXFpaWltZWVtaWllZWVpZWllZWFhXWFhXWFdYVldVVldWhFcIWFZXV1ZWVVeEVoRVhVQIU1RUUlRTU1OEUgVTVFRTUYRTFFRUVVVVVlZXVVVXV1ZWVldXVVdXhlYbV1dXVlZVVVVUVVRUVFNTU1JSUlNUU1FTUlJThVIkVVVUVVRWWFlYV1ZVVlhaXWRsc3Z5P0B+e3h2dXNsZWJfXVVRhE6ATExNUFJUUlBPTk5OT09RUlBPUVJRT05QU1RVVFdZW11fXV9gYWBfYGJiY2ZmZWRlY2JjZWVjYmNlaG1ta2pmYmdrc3uBiIyOjUeOR4uGhH98eXd4dnZxbGNdW1xcXVxZU1JRUU5PUVRaX2BeXFxdYGJiYV5aWFVQTU1PUVRXV1YgVVZZXF5fYGJkY2NlZGNlaGtvcG9qZGBgYF5YVFBMR0MRYWBfXlxcW1pZWVhXVlZWVVWEVIJThFKEUYRQB09QT1BPT0+HTo5NiEwFS0tMS0qESwdKS0tKSkpLhkoKSUlKSUlKSUpJSodJgkqNSQlISUlJSEhJSUiFSQFIhUkMSElISUlJSEhJSEhIjkkFSElJSUiRSZFKB0tKSkpLS0qFSwFMhUuNTI5NiU4BUIhPilAGUVFQUVFRiVICU1KFU4RUh1WGVoVXEVhXV1hYWFlYWVhZWVpZWlpahlsGXFxcW1xch12CXoVfCGBgYF9fYGBghWEJYmJhYWJiY2NjhWQFZWRlZWWGZgVnaGhpaIRphWqCa4ZsCW1ubm1ub29wb4RwK3FxcnFxcHJycXFycnNyc3N0dHN0dXZ2dXZ2d3Z2d3d4d3d4eHl5enp6e3qGewR8fH18hH0Ofn59fn9+f3+AgH9/gICEgYaCDYGCg4OCgoODhISEhYWHhhaHh4eIh4aIiIiJiImJiYqKiYqKiomKiYsRjIyMi4uNi4yMjI2NjIyMjYyEjQmMjY2Njo6Pjo2GjgSPjo6Oio8Kjo+Oj4+Qj5CQkYWQBo+Qj5CQj4SQDI+QkJGQkZGQj5CPkYSQEo+Oj4+Pjo+Pjo6OjY6OjY2MjoWNGI6NjIyMjY2MjIyLi4yLiouKi4uKiYqKioSJGoiJiIeIiIeGh4eHiIiIh4iHh4eGh4aFhIWFhISFgxuCgoGAgYGBgICCgH+BgYKCgoODhISEhYSEhYWFhBKDhIODg4SEg4OCg4OCgoKBgYGFgAt/gH9/fn5/f35/f4d+CX9/f4CAgoSCgYSAgIKDh4+WmZtPUaOfn5ubmJONiomHgX17eHh4d3d3eXt8enp4d3Z4eHh5enl3eXp6enh5e319e35/gIKEg4SDhISCg4WEhIWGhoeGhISEhYaDg4SFio2Ni4uHhIWKkZedo6enqVWoVaejoJ6al5aVl5aTjIR/f35+fX16d3V0dHNzOnV2fICCf31/f4KDg4F/fXp2c3JwcnV4eXp4eXt7fn+BgoWHhYWFhoWGiY2QkI2Hgn5+fnp2cm5rZ2MitrOxsrGvrqysq6qpqKinp6empqalpaWko6Oio6KhoaKhoYSgA5+goIWfDJ6enp2enZ6dnJydnYSchpsGmpqbmpqZhpqImQGYhJkEmJmYmYWYBJeYl5eEmAmXl5eYmJeXl5iIlwaWl5aWlpeGlgOXlpeElhGXlpaVl5aXlpaWl5eXlpaXl4eWgpeFloSXAZaGlwiWl5aXl5aYmIaXCZiYl5eXmJmXl4aYCJmYmZiYmJmYiJkDmpqZiJoNm5qbmpuampubm5ybm4acBZ2bnJychZ0Lnp2dnp6dnp+gn5+HoA2hoaGioqOioqKjpKOjh6SCpYWmFqempqanqKipqaipqaqpqqqrq6yrrKyGrYKuhK8RsLGwsbGxsrKzs7K0s7O0tLSFtQ62t7e4t7e4uLm5urq7u4W8hL07vr+/v8C/v8DBwcHCwsHCxMTDxcXExsbGx8bHxsbIyMnJysrKzMvMzMzNzs3Pzs/Oz9DQ0tHS0tHR0tKF00jU1NXV1tbX2NfY2NnY2NjZ2dvb29zc3dzd3t7f3t/f3+Dh4uLh4uHi4+Pk5OXl5ebl5+fo5+Xm5+jn6Ofo6enq6+np6ezq6+uE7BLu7ezv7+/u7+/w8PHx8fLw8fOE8k3z8vLz8/Py8/Lz9fT09Pb19fT19vb19fX39vb2+Pf29/b39vb3+Pb3+Pj3+Pn5+fj59/n49/f4+fr6+fr4+vn6+vn5+/r7+vr7+vn8/IX7AfyE+wj8+vn5+vz8+4T6Hvz7+/v8+/r7+/z5+fj6+Pf5+fn49/f4+Pn2+Pj39oT4Evf19fX39/X29vP19fT19fT09YXyEvPy8/Hz8vHw8fDx8PDv8O/w74juCO3s7evs7OrqhOkc6Ojn5ubl5ebm5ufo5+fo6Ojq6enp6urp5+jp6YTohecE5ebl54blDuTj4+Lj4uHi4uHh4ODhhN+E4FHf4OHg4ODh4uTk4uHh4eLh4eTp8vj7+4CB//v7+/f08eno5+Tc2NbW1dXU1NXV19nY1tXU09TU09XW1dPU1tbV1NXX2NbX1tna3N3e397f3tyE3i/g4N/h393e3t3c29zb3uLn5eHf3d3d4eft9fr+/f6A/4D9+fXy8O7t7u3s5+Pa1oTVQtPOzcvKycrJy83T19fV09LU1tfW1tLRz83Jx8bGycvMzczOzs/S1NXV19rZ2NjX19nb3+Pk4dzX09PRzsnGwr67uP9//3//f/9//3//f9N/goDafwOAf4DUfwICBAASUE5KRUE9OTc0NTQ0MzIxMTEyhTAELy8uLoQtFS4tLS0sLC0sLC0sKissLCwrKyoqKoQrhCoBKYYqiikDKCgphCiCKYwoCycnKCcoJycoJycnhSgMJycoJycnKCgoJycohCcRKCcoKCcoJycnJicoJycoJyaEJxcoJycnJiYnKCgnKCcnKCcnKCgnJycoKIYnBCgoKCeHKAMnKCeMKAQpKSgohSkFKCkoKSqEKQEqhymGKgkrKispKisqKiqQK4UsASuJLAstLSwtLC0tLi4uLYsuhC8CMC+HMAMxMTCFMQUyMTEyMoczDjQzNDQzNDM0NTQ1NDU1iDYfNzY3Nzc4Nzg4ODk5ODg4OTg5ODk5Ozo5Ojs6Ojs8OoQ8KT09PTw9PTw8PT09Pj4/Pz4/QD9AQD9AQD9AQEBBQUJBQkNBQkJDQ0JDhUQDRkVFhEYHR0ZGR0hHSIRJJ0pKSUpJSklKSklKSktLSUpKTEtLTUxNTUxMTE1MTU5OTk1NTk5NToRPA05PT4RQJ1FRUVBSUlFSUlNSUlJTU1JUU1JRUlJUU1NTVFRUVVNUVFNTVlVWVoRXAViFV0dYV1hYWFlZWVhYWVhYV1daWVhZWFhZWVlaWFpZWllaWVlaWVlbWVlaW1pbWlpbW1xbWltcW1taW1tbXVxcXVtdW1taW11dW4ZcHl1dXFtbXVtdXl5dXV5eXlxcW11dXVxdXV5dXF1fXYVeDV9dXV9dXFxbXVxcXFuEXBtbWltdXVtcXFtaW1taWlpcW1pbWVlZWllaWVqFWWVXWFhXWFhXWFlXV1hYV1dXWFdXV1ZVV1ZUVFVVVVRUU1RTU1RTVFRTVFNUU1JRUlJSUVJSVFVWVlhXV1hZWVhaWVhZWFhYWVhXWVhYV1ZXV1dYVlZXVVdWVVZUVVRVVVNUVVVVVIZVhFSAVlRTVVZXVVdcXmRsdj9AQkFDRUNAfHJscG5ubWhfXFlUUE5OTk9OT09PUE9PT05OTktMTE1MTkxNT05PTk5OUVJUVlhbXF1dXl5hY2JkZGdpampscHV1c3FsamxwcHJ1e358eXdzcG90fIlJTU5RUlFRT09OTEpHRomDeXRwa2JHX1tbW1lYVFRVV1lXVVliZmdoZWFgXVpYV1VTUlFQTUxLSUZJSUpIRkZGSEtOT1FTVVhZWVpbXF9iaGppZmFdWVVWV1dWVVIbb21qZWFdW1lZWFhXVlZVVVVUVVRUU1NSUlFShVEGUE9QUE9Qhk+GTohNA0xMTYdMiEsCSkuLSglJSklKSUpKSUqQSQFIhUkDSEhJhUgPSUlISUlISUhISElISEhJiUiFR4NIiEkLSEhISUlJSElJSUiUSQdKSUlJSkpJh0oRS0pKS0tLSkpLS0tMS0xMTEuQTI1Nhk4GT05PTk5Ohk+GUAVPUVBQUIZRhVICU1KFU4ZUBFVUVVWFVgRXV1ZWhVeEWAdZWVlaWVpZhVqDW4ZchF2GXgZfXl9fXl+HYIRhhGICY2KEYxNkY2NkZWRlZWdnZmZmaGhnaGlohGkHamtqa2tqa4RshG0Ebm5vb4dwhXEMcnJxcXJzc3Nyc3R0hXWEdgV3d3h4eIR5Cnp6e3t7ent7fHuEfBh9fX1+fX1/fn+Af3+Af3+AgIGBgYKCgYGHggKDhIiDBISFhYWFhgaHh4iJiIiGiReKi4qKi4yLjIuLioyMi4yMi4uMjI2NjIWNBY6OjY6NhI4Vj46Ojo+Pjo6Oj4+PkJGQkJCPkI+PhJADkY+PhZEYkJGQkZCRkpGRkZKSkpORkZKRkpKSkZKRhJIBkYWSHJOSkpKRk5KSkpCSkJGSkJCQj5GPj4+Rj5CQkJGEjweOjo+Oj4+PhI0Zjo6Njo2MjYyMiouMi4uKi4uKiYiJiYqJioSJE4iIiImJh4iHhoeGhoWGhYSFhYSEgyKBgoSDgoKBgYCAgH9/gICBgoOFhYWGhoeGh4aHh4aGh4aHhYYXhYaFhYWEhYSDhIODgoKCgYGBgICBgYCEgQOCgIGIgC5/gYKAfoKGio+XUFJVVFVXV1Sjm5OTlZSVkoqIhYB8enl5eHh5enp6e3l4eXh4hnYBd4V4gHd4eXp8fX6AgoKDg4SHiIiHiIqNjY+QkZaXlJOPi4yQkZKUmZybmZaUkI6Tm6VXWVpcXV5dXVxbWldWVaiim5aSjYWBf35/fnt5eHh6end2eYOGh4eFgYB9e3p6eXd2dHNxcG9tbG1ubW5sa2ttcHJyc3V2eHl5enp8foKHiomFCoF9end2dnd3dnEcw8C9urWxrqyrqqmpqKinqKenpqWkpKOko6OiooehJ6CgoJ+gn5+enp+enp2enZ2enZ2cnJybnJ2cm5ubmpqbmpqam5ubmouZApiZj5gBl4SYD5eXl5aXl5iYl5eXlpaXloWXjpYFlZaWlpWFlgeVlJSUlZSVipYBlYWWBZeWlpaXhJYElZeXlYeWBJeXl5aHlwmYl5eYl5iXl5ePmISZAZqFmQqampuampqbmpqaipsDnJybiJwVnZ2dnp2enp2dnp6en5+en6CgoJ+ghqEIoqKio6Kjo6OEpIWlhaYKp6emqKipqKmoqYaqhKsRrKytra2urq+vrq+vr7GysbGFsoSzgrSEtQi2tba2t7i3uIW5Dbq7uru8vL28vL29vb6FvwXAwMHBwITCL8PDxMXGxcXFxsjIx8jJx8jJyszKzMzLzM3Nzc7Pzs/Pz9HS0dLT09LS09PU1dXUhNUG19fY2djYhtoB24bcJt7d3t7g3+Dh4eHi4eDh4uPl5OTj5OTm5ufn6Ofm5+jp6ejo6ejphOoQ6+rr6+zs7e3s7O3v7+7v74XwDvLy8/Lz8/T08/T19PPyhPUG9vX29/f3hvY2+Pf39/j3+Pj49/n3+fr5+vr6+/n5+fr7+vv6+vn7+vr7+vv8/Pr6+vn9/fv8/fz7/Pz7/f78hf0a/v39/v39/fz9/f79/v7+/fz9/v79/P39/v2E/jz9/v78/vv7+/z7/Pr6+fv7/Pv7+/r8+vr7+/z5+/f4+Pj5+fn39vj39/b29/f39vb09fX08/T08/Tz8/SF8i/z8vPw8fHw8PDt7+/v7e3u7Ozs7ezr6uvp6+rp6efo6Ofm5ufo6Ofp6enr7Ozu64XsB+3s7Ovq6+uE6oXphOiA5+fn5ubl5uXl5OTj5OTj4+Tj5eTk4+Lh4uLj4eLj5OPj5Ofr8vmAgoSDhYWFgvv18fTz8/Dt5+Pg3NnY2NfW1tbX19bV1tbU1dTV1NPU09TT0tHT09TU09PV1tja3Nvc3N3d3+Di4OLk5eXl5+nt7+zp5uTm6Orp7PH08e3t6udg5erx/YOFh4eIiIiHh4aFgoGA/fjx6+jh29jU1tbU0tDOztHQzc7R2tzd3tvY1tPRz87LzMrJyMbFxMHCwcLBwL++vsDDxcfIycvNzc7Oz9DS19zd29jV0M3LycrKysjE/3//f/9//3//f/9/zH+IgNZ/joDOfwICBAASR0M/PTw8OTc2NTMzMjExMjExhDARLy4uLi0tLSwtLSwtLS0sLC2ELAMrLCyGK4QqASmEKgQpKSkqhSkBKIQpiCgBKYcoASeFKIcnDignJycoJygoKCcmJycmlCcBKIQnhCYCJyaTJ4IoiicPKCcnKCgoJygnJycoJygnhigBJ4coDCkoKCkpKSgpKCkpKIcphCoEKSoqKYYqCykqKisqKiorKyoqiisILCwrLCsrLCuLLAMtLSyELQ4uLi0uLy4uLS4uLy8vLoQvCzAvLzAwMDEwMDEwhDGEMoQzEDIzNDQzNDMzNDM0NDQ1NTWGNgM1NjaEN4U4Cjc4ODk5OTg5OTmFOgY5Ozo7OjqFPBE9PDw8PT4+PT0+Pz4/Pj8/PoRABkFBQUBBQYRCBUNDQ0RDhkQLRUVGRkZFRkdIR0eGSA9JSUhJSklKSkpLSklKSkqFSwVMTE1NTYROIk1OTU9PUFBPT05OT1BQT1FPUFFRUFBRUFJTUlJRUVJTUlSGUw5UVFNTU1RTU1NSVFVUVoRVGVZUVVZWVlhXVlhZWlhZWVhYWllaWltZWVuFWlFZWVlYWVtZWVpaWllZWlpbXFtbW1laW1tbWlxcWllbXFtcW1xbXFtcXFtbXl1dXFxbXV1bXV5eXF5fXVsuLl1eLl1cXS8uLy4uLl5fXi4vL1+ILxldLjAvMC8vXy9fL19gX15cXV5cXV5fX19ehF0PXl1dXF1cW1xdXFxcW1tchFsKXFpaXFxbWltbWoZZA1hYV4RYBVdZWFlZhVcHVlZXVVRTVIRVD1ZVVVJTU1NUU1NTVFNRUYVQDFJWV1dYWltaW1tcW4RaI1tbWllbWlpaW1pZWVpaWllXWFlXWFdWV1VVVldXVlZXWFlZhFiAVlhWVldZXGNqcDxBREVDQkE/PXd0dXNxcG5qaWhiXlpYVlVWVVRSUVFQT05NTk9OTk5NTU9QUU9PT01OTU5NTU5QVVdaXF9gYWJjaGttbG1ra21sa2trbnJ4gIF8dXV8gIOMSUpLSkeKiYmOS1BTVllYV1dUUE1LSEaKh31xbGdKZGFdWVpaWVZUT01RWWBjZGVoaGhqa2dgXFxZVlNUVVVVU09OTUxKSElKSUdIS0xNT1dfZWtvbW5ubm1sbW1oY2FeW1pYVVRSUEsXaWZjYWBfXVtZWFdWVVZVVVRVVFRTU1OEUglRUVFQUFFQUFCHT4ZOiE2ITIdLA0pKS4pKB0lJSklKSUqOSQRISUhIhUkKSEhISUlISUhJSZRIAUmFSAFJkUiCSYxIDklJSUhISUhJSEhJSUhIh0kESkpJSYtKgkuFSohLBExMTEuKTAJNTIZNAU6ETYROAU+HTodPD1BQT1BRUFBRUFBRUlJRUYZShVMCVFOGVINVhFYCV1aFV4ZYhlkFWlpZWVqFW4ZchF0KXl5eX15eXmBfX4ZghGGEYoZjCGRkZGVkZWVlhGaDZ4RohGkFamtqa2uGbAFthW4Fb29wcHCFcQlycnNyc3NzdHOFdIR1CnZ3d3d4eHh5d3iFeYJ6hHsIfHt8fHx9fH2IfgF/hIAP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oaCipKesrayqrqyop6Sin52dnJycm5qahJmFmIWXDpaVlZSUlZWVlJSVlJSUhZMHkpOTkpOSk4eSCpGSkZKRkZKRkZCIkQeQkZCRkJCRiJABj4uQAY+IkAqPj5CQj5CQj4+QhI+CkIiPBpCQkI+PkIWPgpCEj5mQhJGFkBKRkZKRkpGSkZKSkpOTkpOSk5KEkwWUlJOTk4SUBpWVlJWVlYmWAZeGmAmZmZmamZqZmpqEm4WcBZ2dnp6ehJ9AoaCgoKGhoqGio6OkpKSlpaWmpaanp6epqKmpqaqrq6usrK2tra6ur66vsLGxsbKys7S1tLW1tba2t7e3uLi5uYS6Sby9vb6+v7/AwMDBwcLCwsTExMXGxsfHyMfJycrLyszNzs7P0NDR0tPT09XV1tbX2dna2tvc3N7d3+Dh4uLk5OXl5ufn6Onq6+uE7T/v7u/w8PDy8fHy9PT09ff2+fn4+/39/v+AgYGCgoODg4SDhISEhYWGhoiHh4iIiImIiYiIiYmKiomJiYqLioqEiwqMjI2Njo+Pjo6PhZCEkYWSCJOTkpOUk5SUiZYEl5aXl4eYAZmFmhObm5ycnZycnJ2bnJ2dnZydnJ2diJ6EnwOen5+Engidnp6en5+enYaeDJ2fnp6dnp+eoKCgnoSfAaCHnwien5+fnp+en4eegJ2fnp6enZ6dnZ6en56fn5+dnp6go6yvsLCysbS1usHW6OTW2uDZ29Ld5ePVys3W3d3Y1tfX08e9ua+qpqaqrLCytLSxrLO0uLWzsa2prK6sq6ywucTQ2ubs7/Hz8uzj29TRzMO3sKejoqi1ury5rKqrp6Cis8TQ3u/6////+/PtDuTf2tTOycfJy83MzcvKhMgvy8zLzMnKycrNzc7P0NDQz8/My8rIycXExMXEw8TEwsC7uLOvraurq6yus7i+wMWExw3CwcK/vb68vsDDxMTFhMKAwMC/v8C/wLy9vL/CxcbIysvO0NLV2dnb29vY1dLOysfBu7e0srGvr6+urq2vr66vsLKzs7KysbGwsLCxs7KysbGwsK2rqaaloZ6amZaUkpKSk5GRkY+Ojo6LiIaEgoGA/fr28+/s6uPd087Qz8rKy83LyMXFy87NzMjHx8XBvbwOvLu3sq+vr7CwsK6tra7/f/9//3/ff/+A/4D/gPmArn8CAgQAMDY2NTQzMTExMzY1MjEvLy8uLS4vMDExLy4vLi8vNTo7Ojg4NTMyMTIwMDIwMC0rK4UqCygpKCgnJiYlJiYmhCUEJCUlJYkkAyMjJIsjBSIjIiIjhCIMISIiIyIiIiMiIiIjjCIBIZMiASGMIgQhIiIhiiIBIYgiECMiIyMiIiMjIiIjIyIjIyKNI4MkhCOFJAEjhyQFJSUkJCSEJQEkhyUCJiWHJgYnJycoJyeKKAMpKSiFKYgqAisqiCuDLIgthi6ELwIwL4QwhDELMjIyMzMyMzQ0MzSENQQ2NjU2hzcFODc4ODiFOYQ6Azs8O4Q8Jj09Pj4/PT4/QD8/QEBBQkJBQUJBQkNDQ0RDREVGRUVHRkZHSElJhEoMTExMTU5NTk9OT1BQhFEtUlJUVFVWVldVVldWWVpZWlpaWVpZWllYWFlaXFtbW1xdX19eX2AwMDEyMjMzhTQNMzM0NTQ1NDQ0NTU1NoQ3CzY2Nzc3NjU2NzY2hTUMNjY3Nzg3ODg4Nzc3hjgIOTk6Ojs7OjuFOio7Ozs8Ozo7PDs6Ozs6Ojs8Ozw8PT08PT0+Pz4+Pj8/Pj4+Pz4/Pj4+Pz6GP4RAAT+HQAk/QEA+Pz4/Pz+JPgE9hT4UPz9AQEFBQEBAQUFBQEFAQEFAQEGGQIBBQUFAQUFCQUFCQUBBQUFAQUJDQkJBQ0VGRklQV1BNTU5KSk9dbHmRj4ySmZiKh5GWjYSBiYuMjY2Mi4qGjIZ5bWxkXVRQTU9SUE9RV1xiZWhpZWJkbG1lZGVobnaIkJado6Kflo6Qk5CGe3BmW1hVUFZcWFJOTEtMWnuVp7plaoBsaGXEv7aupp6VkIqFgICAgYSFhoaFhIeJjIyOjIqNkJKUlpeZnJubmZiWlZKQjIuHhoSDgYF9fnp3dXNuamhna29zeoGHjJGRkpOVkY+MiYmGhYSFhYeGh4WDhIeIh4aIioqLi4+Rk5eYmZqcnZ6goqSmpqejoJ6bmJOQi4WCgEh9fHp4d3Z0dXZ2d3h4eHl6enl5en2AgYGCgoKBf356eHd1c29saWZjYV5cWVdWV1ZTUFFRUVJSUE9LSUeKhYB6dnNxb21pYl+EWx9dW1dWUU1PU1RSTUxKSUhJSENDQT48Ojs7Ojo4NzY2NVtaWllYVlZWV1pZVlZUU1NSUlJTVFRTU1JSUlFSWVxcW1pZVlVVVFRSU1NSUU5NTE1NTUxMhEoBSYVIh0eLRgJFRoZFikSCQ4dECUNDQ0RERENDRIZDgkSkQwFChEMBQoRDA0JDQolDAUSFQwZEQ0RDREOERAFDikSTRQJGRYlGi0eESAJJSIdJA0pJSYRKhkuGTIdNhU6FT4VQhVGEUoZTEVRUVFVUVFVVVVZWV1dXWFhYhVmEWgRbXFxchF2CXoVfhGAGYWFhYmJihGMGZGVlZWZmhGdKaGhoaWppampqa2xsbG1sbW5ub29wcHBxcnFyc3N1dHV1d3d3eHl5e3t8fHx9fX6AgICBgYKDg4OFhYaGhoeHiIiJiouLi4yLjIuEihiMjo6Pj5CRkpKTlJNKSktLTE1NTk5NTk6GT4RQClFQUVFSUlJRUlKEU4dSg1OEVIhVDlZWV1ZXV1hYWFlZWVhYhFmDWodbBlpaW1tcXIVdg16EXwpgX19fYF9gX2BfhGAYYWFgYGBhYWFiYmJhYmFiYWFiYmJhYGFhhGALYWFhYGFgYWBhYWKGYYdig2OHYoRhBmJhYmFhYohhAWCEYYBiY2NhYWJkZGVobnRtbGtsZ2hte4aVrKilqbKsoaGsrKSal5+ho6KhoaCenaKZjYOCe3NsZ2Voa2lpa3B0enx+gHt5fIWCent6foSQnKOorrGxraWfoqOemZCEenBvbGVvdXJrZmNiYmyIoK+9Z2tubWrQy8S9t66oopuXkpGRkgiUlpaVlJSWl4SaNJianZ6goaOkpqenpqSjoJ+dmpiWlJSRkY+PjouHhIN/e3h4eX2Ch42Tl5mcnZ2cnJqYlZKEkYCSk5KSkZGQkpKTk5OVlZWWl5mdoKKio6Smp6mrra6urayqqKajnpuWk4+MiYeGhYSDgoGCg4ODhISFhoaGhYaIiouLjIyNi4qHhoWDgX98eXd0cW5samhmZmVkYV9fX2BhYF5cWVhWqqWgm5eUkpGQioOBf359fX57eHdzcHR2dxZ1cXFwbm1ubWlnZWJgX2BgX15cW1xbF66uq6uqp6enqausqaempqWko6SkpaakhKMmoqOpra6rqqqnpqWkpKOio6Khn56dnZycm5uZmpmYmJiXmJeWl5aElQKUlYWUA5OUlIeTh5IJk5KSkZGSkZGShZEQkJGRkZCRkZCQkJGRkZCQkYeQE4+Pj5CQj5CQkZCQkI+Qj4+PkJCEj4KQjo+CkIiPBI6Pj5CHj4SQBI+QkI+EkIWPhJAMj5CQkJGQkJGQkZGQhZEDkpGShJGEkgGThJIEk5KTkoaThZQJlZSUlZWVlpaWhJcOlpeXmJmYmJiZmZiZmZmFmgqbm5ucm5udnJ2dhp4SoJ+foKChoqKio6OjpKSlpKWlhKYBp4SoDamqqqysq6ysra6ur6+EsISyE7OztLS1tbW2tre3uLm4ubu6u7uEvYS+aL/AwcHCw8PExcXFxsXGx8jJycnKy8vMzc3OztDR0dLT09TU1dbY2Nja29zc3d3e397g4eLi5OTl5ufo6erp6+zs7e3u7/Dx8/Lz8/L08O/w8PP4+Pj5+fv6+/7+/4CBgoKDg4WEhYWFhIaEhwSIiIiJhYoRi4yLi4uNjIyNjIyLjIyNjY2EjhGPj5CQkZCRkpGRkZOTkpOTlISVFJaWlZWWlpaXlpeYmJiXmJiYmZmZhJoLm5uanJycnZ2enp2Eng2fnp6fn52enp6fn56fhKAIoZ+hoJ+gn6CEoQKgoYWgBaGgoKChhqABn4SgA6GioI6hhaAIn6CgoKGhoZ+EoYCgoJ+fn6Cgn5+goJ6goaKio6Wpr6qnp6mkpqm0wMzi4N3j6uTZ1+Lj3NPR19jZ2tnY2NXW2dLIv7y2r6ejoaSmpqSmqq2ztLa4tLK0ubqzs7O2u8TP2N3i5ebh29bX19XPxbuyqaWjnaWrp6CbmJeaqMXY5vWAhIWEgv/69O7n4Ena1M/KyMbGx8fIycnGyMjLzM3My8rLzdDR09XX2NjW1dTT0s/MysfGxMPCwL6+u7q4tbOvq6uoqa6zuL3BxcjJysrJycfEwsG/hL0zv8G+vr69vr+9v7/AwMHCw8bJy83Nzs3Q0NPU1tXW1dTR0M3Jx8O/u7e2s7Owr66sq6urhKwJq66urq2trrCxhbRQtbOxsa+sqKelpKGenJmXlZKRkJCNi4iJiYuLiomGg4GA/fjz7uvp5uXj4drX09PR0tLQzszHxcjLy8nGxMTDwcHAvLu4trOzs7KysbCurq7/f/9//3/ef/+A/4C6gIWB/4C6gK9/AgIEACk2NzY1MjEyMjM1NjUzMTIyLy4vLy8zNDMxMTAwMzk+Pjs3NjQyMi8tL4QxAzAuLIQrASqEKAInJooliSQYIyMkIyMjJCMjIyIjIiIjIyIiIiMiIyIjiSIKISEiIiEiIiEiI5IiASGHIgMhIiGJIoQhDSIiISEhIiEiIiEiISGEIgQhIiIhhCIBI4QiCSMjIyIjIiMjI4QiiSMIJCMkIyMjJCOSJAQlJSUmhiUDJiUlhyYHJycnJicoJ4QoDyknKCkpKCkoKSkqKSkqKYgqhisHLCssLC0sLIYtBS4tLi8uhS8KMDAwMTAwMTIyMoUzCTQ0NTM1NTY1NYQ2hTcEODg3OIU5HDo6Ojs6Ozs8Ozw8PD09PT4+Pz8/QEA/QUBBQUGGQg9DRERERURFR0ZGRkdISEmEShhLS0xMTU1NT09PUFFRUVJUVVVWVldXWFeEWAxaW1tdYGBfX15cXFuGXA1dXl9fX2BgYTAxMDAxhTIBM4Q0BzU0NDU1NjWFNgE3hjgKNzc4Nzc3NjY3NoY3Dzg4OTg5Ojg4ODk4OTk5OoQ7ATyEOwM8PDuFPIY9hTwCPTyEPYQ+hT8IQEBAP0BAP0CFPwZAQEBBQECEQQZAQEFAQECFQQdAP0A/QEA+hD8TQD8/P0BAPz8/QEFAQEFBQUJCQYdCRkFBQUBAQUFAQkJCQ0JBQUJCQ0NDQkJBQkFCQkFDQ0RERUVGSEhFQ0NCRUNDRFRnbm5sfIeHeGplZXFtcHd3e42QjYmEhYaEiICBc2pmaWdjWlVWU1ljaGxraWdqa3J3d3V4gIGFk5mdlZCOjo6MiYeCgHZsXlRRUVddVk9NS0dESm+Wp7llaWppZWPBu7StpZuRi4SAf3+BgYSGh4eHg4OKjJGVkpGRkpOTlpyhoqKenJmYmJaRi4SAfHt4eHRydnd0cnBvcXNxcIBzdXmAhYmNkpeam5mTkI6LiIWDgH+Af35+f4CDhYSFiYyQk5ianJ2dnZ6cnJ2dn52fnpyYlpOSjYqIg4B+e3p6enl5eHd3dnd3d3V2dnd4dnd4e32DhYaFhoODgH56dnVybmxpZWJeXFpXVVRUU1JSUlFSUlJRTkxLSUeJg3t1cipwbWxqZ2RiYWFeWlxgYVxVT0xMT0tJSEVEREdHRUI/Pj48Pj89PT06ODY6XF1bWVdWV1dYW1pYV1VYV1NTU1RVV1dVVFRUU1ZcYF9bWVhVVFVRUVJUVFRTUVBPTU1OTUtKSkpJSYRIhUeLRodFB0RFREVFREWQRAhDRERDQ0NERJ9DBEJDQ0KEQxFCQ0JCQ0JCQkNDQkNCQkNCQoRDAUKTQ4VEAUONRIlFBEZFRUWPRgRHR0dGhEeJSIZJhEoKS0tKS0tLTEtLS4RMhU0DTk5NhE6ET4VQiFEBUoZThFSEVYNWhFeDWIRZB1paW1tbXFyEXYRegl+FYINhhWIGZGNkZWVlhGY5Z2doaGhpamlqampra2tsbGxtbW5ub29wcHFxcnN0c3R1dnZ2d3h5eXp6e3x7fH1+f4CAgoKDhIWFhIY7iIiJiYqLjY6QkJCOjo6Njo6OjY6Pjo+PkJGSkpOUSkpKS0tMTExNTk5OT09QUE9QT09QUFBRUlJTU1OIVBBTU1RUVFNUVFRVVVZVVlZWhFcMVldXWFdYWFlZWllZh1qEWw1cXF1dXVxdXF1cXF1dhF4MX19fYF9hYGFhYGFihWEFYmFiYWGGYgVjY2NkZIxjAWSEY4NihmMFYmJiY2KFYwNkY2OLZIpjDmJjY2JiYmRjY2NiYmNjhGInY2RkZGVmZ2dlY2JiZWFhZHWCioiImaKekoKAgY2Hi5CPlKKin52ahJyAnZuTh4B9f355cW5tbHF8f4SCgH2BgoqPi4qOk5WZp6uqpqCgoJ6cnJqWkYqBc2pnam93cGhlY2BcYHufsL9mbG1sa2jLx8K8tq2lnZeTkZGRk5OWl5eWlJWXm56hoZ6foaGhpKepq6yrqKalpaKfmpSQjIyKh4WEhIeGg4B/gH8Vfn2AgoeMkJSXnaKjpKKempeVkpCOhI0zjIuLjI6QkJGTlpmdoKOkpaanqKamp6inqKempaSgn5uZlpOQjIqIiYeGhoWEhIOCgoSDhYJbg4KEhYmMjo+Pj46Oi4mGhIF+fHl2dHBua2lnZWRjY2JhYWBgYmFgXVtZWFWoopyWkpCPjouIhYODg4F9foOCf3hzcHFyb21ta2pqbGtoZ2VlY2FjY2JjYWBcWjWurq2rqqipqKqsrKuqp6mopqOkpKWoqaempKSlp6ywsaypqKWlpKGhoqSkpKKhoJ+enZ2cm4SZA5iXl4aWB5WUlZWUlZWElAKTlIWTBpKTkpKRkYeSBJGSkpKHkRGQkJGRkZCQkJGRkJCRkJGRkYSQAY+FkAiPkJGQkJCPj4WQgo+EkAKPkIaPBo6Pj4+OjpiPhJAMj4+QkI+QkI+Qj4+PjJCEkQOQkZCGkQWSkZKRkYmSiJOFlAKVlIeVhJYEl5iXl4WYCZmZmJmZmZqamoWbgpyFnYSeBJ+foKCGoQajo6SjpKSEpRCmp6inqKmpqaqqq6urraythK4Ir6+wsbKxsrOEtE+1tba1tre4uLi5ubu7uru8vb29vr+/v8DBwMLCw8PDxMTFx8fHyMnKycrKy8zMzs/P0NHT0dLT1NXV1dfZ2drc29vb3t/f3+Hi4+Pl5ufohOo77O3u7+/w8vP09fb39/b19fb29PX29/n5+vv8/f7//4CAgYGBgoOEhIWFhoaHh4eIh4iIiImJiYqLi4yGjRKOjo2Ojo6Njo6Njo+PkI+QkJCEkg+Tk5KSlJSTlJWVlZaWl5iFlwqYmJiZmZqZmpqbhZqCm4SchJ0Lnp+fn6GgoJ+gn6GFoBmhoaChoaGioqGioqGio6OjoqKhoqKkoqKjhKIFoaKjoqOGohehoqKjoqOio6Sjo6SjoqOioqSipKOjo4iiBKOioqOEogOhoqKFoQWgoKChoYSjgKSlpKKgoKChoJ+hrr3CwsHP2NbJvbm5w8HCysnM29vZ19TT1NTU0tPNwru4ubm0rampqKu0uby8ube6ur/ExMHEycnO2+Df29fV1dXT09DLx8G5raOfn6WqpJ2amZWTmbvZ5vWBhYaFgoD8+PLu5t7Wz8rIxcTFxcfJysnJyMfJU87R0tLO0NHQ0tXZ293c2tfV1dPRzcfCvry5ura1s7a3tbGvr7Gwr6+ws7i7v8LFzM7Pz83IxsTCv728ubm4uLe4t7i7vLy9v8LGyszO0NHR0dDShdF60M/NzMrGxMPAvLm1tLOysbKwr66ura2trq2rq6usrKurra6ytLW2t7e2tbOxrqyppqWkoJ6al5WUkI6NjY2Mi4uKi4yMiYeFhIKA/PXv6Ofk4eLg3dvZ2tnV0NLX2NPOyMTExcPBwb+8vb++vbq5uLe1tra1trWzr63/f/9//3/cf/+A/4C7gIaB/4C6gK9/AgIEADw5OTc2NTQ1NTU3Nzc2NjY0MTAvLS0tLi8vMzY3ODk6Ojg1MzIwLy8uLS0wMi8vLy0sKyopKCgnJycmJSaEJQQkJSUliCQCIySKIwgiIiMiIyMjIoQjiiKCIYciBCEhIyGLIgEhiCIIISIhIiEiIiGGIgQhISIihCEIIiIhISIhISKFIYkiESMiIiIhIiMjIiIjIiIiIyMiiCMBIoojAyQkI4QkASOGJAEjhSQDJSUkhiWEJgElhSYLJyYmJicnJygoJyeEKAIpKIkphCqEKwEqhysELCssLIUtBi4tLi0uLoQvhTAvMTExMjExMTMzMjIzMzQ0NDU1NjU2NjY3Njc3ODc4ODg5ODg5Ojg5OTs6Ozs8OzuEPBo9Pj0+Pj4/Pz4/QEBAQUFCQUFCQ0NDRERERYRGCUdHR0hISUlJSoZMTk1OT09PUFBRUVJTVFNUVVdWWFlaW1tbXV5fYWNlZGRiXl1dXVxcXF5fXl9fYTAwMTAwMTAxMjIxMjM0NDU1NTY1NTY2NTY2NzY2Nzc3NoY3Azg4N4Q4Ezk4ODg3ODg5ODk6Ojo7Ojo6OTmEOoQ7CDo7PDs7PTw8hT0CPj+EPhA9Pj09Pj49PT4+Pj8/QEBBiUACQUKEQQdCP0BBQEBBhEISQUFCQ0NCQkJBQUFCQkJBQUJAiEEMQEJAQEE/QUBBQUFChUMORERDRERDQkNCQkFBQkKERAhDQkNCQ0NERIRDgEJCQkFCQ0VERENDRENCQUFCQkFBQURKUU9RVVVdY2JZWF5jZ2hne5agoaOknZKcmpSZoJqFd357aWBhZGhqe4yLh4eFio+HgoKHi5GYnZ6fn52Zlo+GhIF5b25xbGFYV11mYVRQVl5jb4OVqrtmaWVkxcG+ubevp5ySjISBfnt+gIKCg4iMjIuLhYePlJSTlpWVmJygoqSknpmYlpaYlZGKhoOAfXx4c3BubGhjYWZudHNzdnh8gYaKjZWco6Wkop6WjouGgYF+e3h5d3p8f4KHi5KXmp6dn6GioaGgn52dm5qXlZORj4qIhIB9enp4eHZ3dnZ4eXh5eHh3eHd3eHh3VXZ2dXV5fIGEhYaEgX97enZzcW1sZ2RhXlxbWFZVU1JRUVBPTk9PT05KR4uHhIeFfn16d3Jvbm5ubWpkXFheYV9bVk1JSEZFREI+PUBCRURBQD49PD6FQQI/OhNdXVtbWllaWVtcXFtZWllZVVNUhVInU1ZZWlpbXFpaV1ZTUlFRUE9QU1NSUVBOTk1MS0tLSklJSUhIR0hIhEeHRgJFRodFjkQHQ0RDRERDQ4REqEOLQgFDiEIBQ4RCCkNCQ0JCQkNDQkKIQwtERENDRENEQ0REQ49EA0VERI1FjkaFRwlIR0dHSEhISUiJSQRKSktKhEuGTAJNTIZNg06HTwlQUFBRUVFQUVGGUoVTglSFVQtWVldXWFdYWFhZWYRaCFtbW1xcXF1dhV4YX19fYGBhYGFhYmFiY2JjY2RlZGVlZmZmhGcJaGlpampqa2trhGxZbW1ubm5vcHFxcXJydHR0dXZ2d3d3eHl6e3t7fHx9fn5/gYGCgoKDg4WFhoeIiYuMjI2OjpCUlZSUkpCQj4+PkI+QkZGTk5NKSktLSktLTExMTU1OTk5PT0+EUBFRUVFSUlNSUlJTU1RUVVRUVIxVhFaCV4hYhFkIWlpZWVpbWluFXINdhl4KX19eXl9fXl9gX4RgAWGIYodjA2RjYoVjg2SRZQRkZGRjhWQBZYxkhGWFZoZlEmRkZGVlZGVmZWRkY2RjZGVkZYRkDmNiYmNjZGRkY2NkZGJihmGAZGlxbnFyc3l9fHN0eXyCgYCVrrK0tbatpq+sqK6yrJmNl5GAeHl8f4KUoZ2amZeeoZqVlZyepamsra6vq6mmn5mXlIqDhIiAdm1sdX55bGhsdXeAkJ+vvmhramjPzMnGw7+4r6ael5SRj4+Sk5SXm5uYmJeTm6ChoaKjoqOlq66Ar66sp6Wko6Oin5qWk4+MjImFgX59e3ZydX2Cg4OEhYqMkJSXnKSqrK2qpqCblpKPjYuIhYWFh4mLjZGVmp+kpqeoqqurqqqpp6SlpKKhn5yal5WSjYqJh4WEg4KDhIWGhYSFhYSEhYSEg4OCgYCChIiNj4+Qjo2LiIaDgX57eXVHcW9sa2lnZWRiYWBgX15cXV5eXVpXq6akpaKem5mWkpCQj5COi4V/fIGDgn13cW5samppZ2RjZWhpaWdkYmJiZGdnZ2ZlYl48sbCura2rrKytrq6urKyrqqilpaSioqSkpairq6yrraypqKakoqKhoKCgo6OhoqGfnpybm5qamZiYl5eXhZaFlQeUlJSTlJSUhpMCkpOHkgaRkZKSkZKGkQSQkZGQipGQkAGPjJADj4+QkY+CjoaPAY6KjwGOh48KkI+Qj4+Qj5CPj4SQA4+Qj4iQCZGQkZGQkJGQkIuRBZKRkZKRh5KGkwqUlJOUk5SVlZWWhJUElpaXloaXCpiYmZiYmZmZmpqEmwiam5ybnJydnYSeAZ+FoCChoaGio6KjpKSkpaWlpqenp6inqKmqqqqrq6usrK2uroSvDrCwsbKys7O0tLS1tra2hLcJurm6urq8vLy9hb5Mv8DBwsPCwsPDxMXGxsfJyMnKysvLzM3Nzc/R0NHR09PU1NbX2Nra2tvc3N3d3t/g4OHi5OPl5ufn6Orr7O7w8PDx8/X29/j6/Pv5+IT3CPj6+fn8/f3/hIAVgYGCgoODhISEhYaGhoeHiYiKiYqJhYsIjI2NjY6NjY6GjwWQj5CQkIWRBpOSk5STk4SUhJUHlpaXl5eYmYSYIJmam5qam5ucm5ycnZ2cnJ6cnZ2enZ6en5+foKCgoaGjhKIHo6OjoqOjooajhaQLo6SkpKOkpaSkpaaEpYWkEKOkpaWlpKWlpaSkpaWkpKSFpQqmpaalpqampaWlhaQVo6SlpKWkpKWjoqOjpKSjo6SjoqKihKOAoqKioaGioaCen5+enp+hpqypra2stLe4rrC0t7y9uszk6+vt7uff5uPg5evj1MjPzLy0tLe5vcrY1dLT0NXX0MzM0tba3+Ll5eXj39zX0c3Lxbu6vbmvp6Wss6+jn6Wsr7rI2ef3goWCgf/8+/n18Ojg2NDMyMTDxMXGxsnNzMxry8XHzdLT0tPS0tTX3N7e3tvW1NTT09HNycPBv727uLSxr62qpaOnrrO0s7S2uLy/wsXM09bY2NTPysfBvbu5uLWysbKzt7e7vsLGzM7R0tXU09PT0tLQ0M7Ny8rIxsO/vbm4tbOxsK6trq6ErwSxr66vhK5erayrqqurrbGztri4t7Wzsa6rp6akoJ6bmZaUk5GQjoyLi4uJiIeHiIiHg4H++ff49fLv7erm5OPj5eTe2dPR1tjX0szFwr+9vby6t7a5u7y8ube3tra3u7u6u7q4sv9//3//f9h//4D/gL6AhIH/gLqAsn8CAgQAMzw8Ozk6Ojg3Nzc4OT09OzczMzMyLy8wMTE0ODk1NTc2MzIzNzw4MzAvMDAuLS4tLCspKYQogyaEJQQkJSUlhiQEIyQkJIcjCCIjIyIiIyMjjiIGISIhIiIjkiKCIYciBCEiIiKYIQEiiSEDIiEhhSIEISIiI4ciByMiIiMiIyKEIwciIiIjIyIiiiMDJCMjhCSCI40kiCUMJiYlJSYmJyYmJicmiCcDKCgnhCiEKQEqhCmHKgMrKyqEK4UshS0LLi0uLy4uLy4vLy+EMAUxMDExMYQyhTMFNTQ1NTWENgI3NoQ3hjgPOTo5OTk6Ojo7Ozo7Ozw8hD0BPoQ/BkA/QEBBQYVCCUNCQ0VEREVGRoRIT0lISElKSkpLTExNTU1OT09OUFBPUVFRU1JUVFVWV1hZW1paXF5hY2c1aWZjYmFfX19eXl5fX2BgYDAxMTEwMTExMjMyMzQzNDQ0NTY1NTWENh03Njc3ODg4Nzc4ODg3ODg5ODk5Ojk5OTg4ODk5OIQ6GDs7Ozo7Ozs6Ojk6Ozo7Ozs8PDw+PT0+PYU+Az8/PoU/AT6FPwdAQEBBQEFChEEWQkJBQkNDQkJDQkJCQUFCQ0JCQkNDQ4RCG0NDQ0JCQ0NCQ0JDRENCQkNCQkJBQkJBQkJBQoRBB0JCQ0NDRESERQxGRUREQ0NDRERDREOERBtDQ0JDRENCQ0NERUVDQ0JCQ0JDQ0RDQkNCREOERIBCQkNER0hIT1deYGNnZWNjaXB2iIuZqbCroqqtpZ+Thnx3fH12bWdrdHt9eHqAiIuOjYSCjZaTlaWvrq6wrKmknpWQjIZ6c3R1c3JtaWlmX1xWV2eAm6u4wmHBvry5tba1sqyil5CKg398fH1+foCCg4SHiomLioqIhYyUnJ+jpoCjop6Yk5WYmpyblpGKhH56dXNxbWdgXFZWW2BiY2NkaHODj5miqK2tq6aim5SMg318eXZycnV2eXx/hYuRlJqfoaGioKCenp6dm5qXlZGPioeBfnl3cXFycHBvcHFyc3R4d3l5enl6eXl6enl5eHh4eXp9f4CAgH59eXdzcm5raEhmZGJgXV1bWVZUUlFQUFBOTU1KSEeFgHx8f399fnx3c3Bub3J1cGhhX15fXVlVTUdDRUZGQkE/PkNDQkNCQT8+P0FAQEJCQ0A8YGFgXV5eXVxcXF1fYGFeWlZWV1VUU1RUVVhbWlhYWVdVVVRZXFdTUlFSUlFQUE9OTUxLS0tKSUhIR0dIhUeIRolFCEREREVERERDh0QDQ0NEmEMGQkNDQ0JCjkOKQgFDhkIBQ4xCAUOHQo5DDERDQ0NERERDQ0REQ4pEBUVFRUREi0WMRgJHRoZHA0hIR4VIiEmESgJLSoVLBUxLS0xMhU2IToRPAlBPhFALUVFRUlJTUlJSU1OEVIVVClZXVlZXWFhYWVmGWgFbhFwBXYVeGl9fX2BgYGFhYGFhYmJjY2NkZGVlZWdmZmdnhWhcaWpqamtra2xsbG1tbW9vb3BwcXFzc3N0dXV2dnd3eHl5enp7e3x8fX5+fn+AgIGCg4ODhISGiImKi4yNjpKTlUyXlpKSkpGRkJGSkpOTkpOUSktMS0tLTExNTU2ETgRPT1BQhFGCUolTHFRVVFRVVVVWVlVWVldWVldVVlZXWFdYWFlZWVqEWYVahFuEXAFdhl6EXwlgX2BfX19gYF+EYYViAWOFZA1jZGRkZWVlZGVlZWRkhGUGZmZlZmZlhGYHZWZmZ2ZmZ4VmBGVlZmWFZgVlZmVmZoRlBGZlZmeHaIRnhGYBZYRmCWVlZGVkZWVlZIRlFGRkZGNjY2RjZGNjYmJjY2NkY2RjhGKAZ2ZnbXN6fH+BgH1+hI2SpKa2v8O6s728tLConJGOlJOMhH6FjZOUkZKXnaGioJiapKelqbe+uru+urayraWfnpmNh4qKiIiDf4F9dnNvbnqOpLXAymfNycfEwsHBwbu0qqGZlZCOjo6Pj5CSk5WWmZiZmZiXlJiepauur66uqaRBoKGlp6ino5+alI6Kh4WDf3lzb2tpbXF0dXZ1d4GMl5+nrbKztLCrpZ6Xj4yJh4SBgIGDhomMkJWbn6OnqquqqqmEqBemo6OgnpqXkpCMh4SBf39/fXx9fX+AgoSEZIWFhYaGhoSFg4KCg4SFh4qLjIuJh4WDgHx7eXZ0cnBua2ppZ2VjYWFgYF9fXFtZWFakoJ6eoJ+gnp2YlZKQkJOXkYmDgYGAf3t3b2ppamxqaGVjY2hoZ2dnZmRjZWdmZmdoZ2QntLWzsLGxsK+vr7Cxs7SxrKmoqaelpKanpqmtrKmpqailpqaprKijhKIBoYSfAZyFmgaYmJeXl5WFloWVhJQDk5OUhJMCkpGJkgKRkoWRAZCHkQmQkJGQkZGQkJGFkAGPhJAFj5CQkJGLkAOPkJCIjw2Oj4+PkI+Pj46Oj4+OhI8BjoWPBI6Pj46Qj4KQhY+CkIaPhZABj4SQhJEEkJGRkIaRCZCRkJGRkpKRkYaShJMIkpOTlJOTlJOElAaVlZaVlJWFloWXg5iFmQ2ampqbm5qbm5ycnZ2dhZ4Pn5+goKChoaGioqKjo6SkhKUJpqanqKioqaqphasWrK2urq6vsLCwsbGysrOztLS1trW2toa4Obm6urq7vL29vr+/v8DAwMHBw8TExMXGxsfIyMnKy8zLy8zOzs7P0dDR0tPU1dbW2NjY2trb293d34TgGOPh4+Tk5ejp6err7e/v8fHz9fb5/ID//YX7D/z7+/z9/v3+/4CAgIGBgYSDF4WEhYaGh4eIiIiJiYqLi4uKjI2NjYyNhY6EjwiQkJGSkpKRkYSShJSElQSWlZaWhZcQmJiZmpmampmampucnZydnYeeA5+enoSfE6ChoaKho6Oio6Oko6SkpaSlpaSJpROmpaamp6WmpqalpaWmpqalp6emhaeFpgqnpqeopqWmpqemhacHpqinp6inqYanBKampaeGpgalpaSko6OEpAelpKSko6KjhKQCo6GEooChoqGioaGgoaCkpKSqsbS3u726uLq+xMjZ3er1+vLr9fTt6OLWzMnOzMW/ub3EyszGyc7T1tnXz8/a3trd6/Px8fTy7ejl3tfUz8bAwcLAv7q3t7SuqqamtMne6/b+gP79+Pb09Pby7OHa0s3HxMHBwsLCw8XFxsjJycrKycfGzHHR2Nzg3t7c2dPP0tXY2tfRzMfEvrm3trSwq6Sfm5ueoaSlo6SnsrzGz9ba3t7d29bQyMK8t7Sysa+trbGztrm9wcbLz9DT09XS0tPS0dDRzsvKxsTBvbi1sK2rqaqpp6enqKurra2wr7Cvrq+xsa+urYWsV66xsrKysbGwramnpaOhoJ2bmpeWlZORjo6MioqJiYiHhYSDgPfy8PHz8/Hy8e3o5eTk6O3m3djV1tTU0MzEvb28vr66ube2u7y6u7q7ube4urq6u728uP9//3//f8Z/AYCQf/+A/4C/gAGB/4C8gLN/AgIEADRCQ0E8OTk7PT4/QD4+P0NBPDc3NzY0Nz05Ojo8Pz45ODU2PEBDQj46Mi8yMjEwMTY1LiknhCaFJYokjSMGIiIjIiIhkCIVISIhIiEhIiIiISEhIiEhIiEiISIihiEHIiIhIiEhIpQhBiIhISIhIIkhDCIgISIhISEiIiEiIZAigiOFIgQjIyIijCMIJCQjIyMkJCOHJAYjJCQkJSSMJQImJYUmECcmJicnJygoJygnKCgoKSiHKQMqKimGKocrhSyELQUuLS4uLoUvAjAvhDAFMTAxMjGEM4Q0JzU0NTQ1NjY2NzY3ODg3ODg4OTk4OTk6Ojk6Ozo7Ojw7PD09Pj0+PYQ+B0BAQEFAQUGGQglDRERFREZHR0eFSIRJC0pKTExNTk5OUVJShVE/UlRVVVdXWVtbXF1bXF5fYWFlZmZlYmJkZWJgX2AvMDEwMDExMDEyMzIzMjMyMjM0NDMzNDU0NTU1Njc3ODc3hDgTNzg5OTg3ODg5OTk6Ojk5OTo6OYQ6ATmHO4I8hDsTOjs8PTw8PT4/PT4+Pz4/P0A/QYlAIUFBQEBBQkJBQUJDQ0RDQ0RCQ0NDRUREQ0RDRENEQ0NDQoRDAUGFQhZDQkNEQ0REQ0REQ0NEQ0JDQ0JCQkNDhEILQ0NDQkNEQ0RFRESFRgNHRkWERAxFQ0VERERFQ0REQkKEQ4REiEKAQ0JCQUNBQkNDRENDQkJBRUxRWF1iamdkXVVUVFVTU1ZYWXCNmqOlqKKXkoiBfXVqZmdrbWtrZWhrcXh/gXhyeYucp66uqrRfYGFgt6qhm5ePiYWAfXhvY2VlYFxcb4ObpqmprK6ws7S1tbW0sKulnZSLhISEgXx6eHhyd4KHiYd6goB/goqRmaGkpaGdmpmYmZudmpWTko2IhYF7dnNtaWJZT01NTExNU1tldIOTnKSoqaain5uXlJCLhX56d3Z1dXd4eHx9goiNk5SXm52bm5mXmJiamJeUjoeBeXNrZWZlZWZpa2ppa21vc3Z5eXt7fHx9fX5+fXt8e3uFeVR4eHh1dHRyb21ramhmZGJgX11cWVZTUVBPTk1LSEeKhoSBeXR2eHZ0dnRvaWZnbHBya2FeYGBgXlxZUk1JR0RCQUFAQUJGRUZGREJDQkA9P0BBQ0I1aGdkYF1dYGJiYmNhYWJmYl1aWllYVlteWlxbXV9eWVlWWF5iY2FeWlNRVFRSUVRYVk5KSUmESAJHSIRHi0aGRQJERYlEB0NERENEQ0SUQwVCQ0JCQodDB0JDQkJDQkKEQ41CAUGcQgNDQkKPQwpEQ0RDRENERERDiUSRRYpGiUcISEhHSEhISUiFSYdKhkuFTIdNhk6FTwdQUFFQUVFRhFKFU4RUg1WEVhRXV1hYWFlZWVpaW1pbW1xcXF1dXYReDF9fX2BgYGFiYWFiYoRjFmRkZWVmZWVmZmdnaGhpaWlqampra2uEbUBubm5vcHBxcXFydHR0dXZ2dnd4eHl5enp8fH5+f3+AgYCBgoKDhoWGh4qLi4yMjI2NkJGSlpiWlZOUlJaVlJOTh0oDS0xMiE0BToRPBVBQUVFRhFIBU4hUBFVVVVaFVwRYV1dXh1iFWYJaiVsCXVyFXYNehF+DYIdhBWJiYmFihWMEZGVlZoRlh2aHZwVmZ2dnZoRnhGYEZ2hnZ4dohGcNZmdnZ2hoZ2hoZ2hnZoRnEWhoaGlpamlpamlpaWhnaGhmhGcSZmZmZ2ZlZWZlZmZlZmdmZmVkhGOCZIdjBGVjZWSEYoBlanB2eX+HgX94cW9wcG5ucHN1j6iwuLi7tKmmnZmVjYF+gISFg4N9f4OJj5aWjYmSpa+1vLu6xGVnZ2bCuK6qpqGcl5SRjIN5fHt2c3KAkqeztre5u7q8vsHBwL67uLKsppyVlZWUkI2Mi4aGj5WYlpGQj5CXnaOqsLGtqqampBOlp6mopqOhnJeVkoyHhIB8dW9lhWGAZWx0gY6cpayxsK+rqKWjn5uWkYyHhIOEgoOFhoiKjpKYm5+io6SmpaOioqOjoqCemZKOiYJ6dXV1dHZ3eXh3d3p8f4GEhoaIh4mIiIiJiIiHh4aFhYSEhYSEg4KBgH98e3l2dXRycW9tbGpoZGJgXl5eXFtYVqqmpKGalpeZmJUsmJWQi4eIjZKUjIOBgoODgH58dXBta2hnZmZlZmhsamtsaWhoZ2RjZGVnaGg3vLu4tLCws7W1tba0tLa5t7GrrK2qqKyxra6srq+uq6mnqa6ztLKwq6Oho6SjoaOopp6amZiYl4aWA5WVloSVhZSEkwSSk5OThZIEkZKRkoSRAZKHkQGQhJEFkJKQkJGIkAGRh5ABj4WQBI+Pj5CRjwGOj48Jjo+Pjo6Pjo6OmI8KkI+Pj5CPj4+Qj4aQAY+FkASRkZCQhZEBkIiRCZKRkZKSkpOSkoWTBJSUlJOElA2VlZWWlpWVlpaWl5eXhZgCmZiEmRWampqbmpqbnJucnJydnZ6dnp+foJ+EoAOhoqKEowOkpKWEpgenqKioqaqqhKsErKytroSvL7CwsbKys7SztLW1tba2tre4ubm5urq6vLy8vb6+vr/AwMHBwsLCw8PExcbGx8jIhMkey8zNzc3P0NHR0dLU1NXV1tbX2Nja2tvd3t/g4eHjheQY5+nq6uzt7/Dx8fPz9fb3+fv///38/P7+hP+GgAeBgYGCg4SDhIQNhYaGhoeHiImJioqKi4SMA42OjYSOBo+PkJCRkYSSiZMUlJWWlZWWl5eXmJiZmJmZmZqZmpqEmwicnZ6dnp6fnoSgFaGgoKGioaGhoqKjoqKjpKSkpaWmpYSmhKcHqKenp6imp4SoGKaop6eop6eop6inp6moqampqKioqampp4WoC6moqamoqKipqaiohKkGqqmqqKqrhakMqqmoqKinp6inpqanh6YCpaaFpQWko6Sjo4aihaOEoQygpKitsbW5v727s62Eq4Cqra6uw9zm8PDz7eXf1tLMxby5u72+vby5uLvAxszMxMLF2OXr8/Hv+oGBg4L77ubh3tjUzs3Kxb2ys7Otqqy90OHq6uvs7u/y8/Lz8PDt6eLe1s7LyMjFwb+/vbi7xMfLx8PAwMTJ0Nfb39/c2NbU0tbZ2dnW0s/KyMTBvbi2s4Cspp+UkZOSkpKXn6axv8zU2tzb2tjU0M3KxsG8uLSysrGwsbO0tbe7vsPGy8vOz9DNzM3NzMvMysfCvbm0raagn5+foaGjo6KjpaeqrK6wsLCxsLCysrKwrq+wr66tra2srqyqqqmopqSjoaCfnZuamJeVlJCOjIqJh4eGhYKA/TX49vLs6Ors7Ojq6eXd29vh5+fg19XV19nW09DKw8C+u7m6ubm4u769wMC9vLy6t7e4uru8vP9//3//f9F//4D/gKiAhIH/gNOAtn8CAgQANUVEQj86Ozw/RktNS0ZGR0pGQ0ZEPz5BQzxCS1BQTkQ5ODxAQj86OTc2NTAsKissLi0pKCcmhSUFJCUkJCWFJIojBiIjIiMjI4YigyGGIgQhIiEhhSIDISEihSEBIoYhByIhIiIhIiKFIQEikSEIICEhICAhISKXIQwiIiEhISIhIiEiIiGEIgEhhiIBI4siAyMjIokjjyQHJSUlJCUlJIcliSYDJyYmhScIKCgoJygpKSiIKQIqKYUqBisqKyssK4YsBy0tLS4tLi6ELw4wLzAvMDAwMTEyMjMyMoQzgjSGNQM2NzaEN4U4CDk5Ojk5Ojo6hDsSPD08PT09PD49Pj8/P0BAQEFBhEJFQ0JDQkRERUVFRkdHSEhISUlKSklKSktMTE1OTU5QT1FSUVFSU1RTVFVXVldXWltdXFtbXlxdXl9gYGJjYzIyMGIwMDEyhDEMMjExMjExMjIzMjIzhDQDNTY1hDYZNzc3ODc4ODk4ODg5OTg5OTk6OTo6Ojs7O4U6BDs7PDyEOxM8PTw8PTw8PTw9PT0+Pj4/PT4+hT8dQEFBQkJBQUJCQkFBQUNCQUNBQkFEQ0RERUVERUSERStERUVEREVGRUVEQ0REQ0REQ0REQ0NERURERUVFRERGRENEQ0VEQ0RDREREhEMVRENEREVERERFRkVGRUZGR0dGR0ZGhEUBR4VFBERDQ0OFRIBFRUNEQ0REQ0JDQkFBQUJCQkFCQkFBQEBAPz9AQUVGR09WU1NYWFJNSklOTVFORlJrgH13dn6HhHdwa2xxdXh0a2NjaWhmZ2ZmamlvgY+RkZCSpl9kYl+1raKVjomBdXBwbmVhZWphW2yGjIyOkpeanqOnp6ess7jAwb+6rp6WlICLf3pza2lsdoGFi42GhY6aoKGioqCclI6MjZGSl5eWk46LhoOAf3t1b2hlYlRJRUZGRUdSWWNygImSmp6fn5uampiUjoiBe3dxb25tbG1vc3l9gouLjpKSlZaSkY+OjpCNi4h+eHJnXVZTVFVaXmRnbG1vcHN1eXt9f3+AgYB/f1+Afn19ent6eXZ1c3JwcGxsa2pqZ2dlZGRhX19dW1lWVFBPTk1NTEpIioWGh4eEgH57eXZ2dnNvb3BxcW9qYVpXVlVTVVRTUlFMTEtIRUNBQUNFRkRDREVFQkJEQ0NDRTRqamZjX2BhZGpubmtnaGtsZ2VnZGFfYWNdZGpubmxgWlldYGJfW1tYWFZRTU1OT1FPTEtKhUiER4hGjUWLRAlDQ0NERENDQ0SHQwFChEMDQkNChEMOQkJCQ0JDQ0NCQ0NCQ0OvQgxDQ0JDQkJDQ0JDQkKLQwJEQ5BEjEUDRkVFikaIRwlISEhHSElISEiFSYdKhUuFTAJNTIVNAk5NhE6ETwVQT1BQUIRRg1KFU4NUhVWEVgVXV1hYWIRZEFpaW1tbXFxdXV1eX15fX1+EYIRhhGKEZAdlZmZlZ2dnhGhNaWlpampra2xsbG1tbm5vb29wcHJxcnJzc3R1dXd3eHh5eXp7fH19f35+f4CAgYKDhISFhoeHh4qNjIuNjoyOjpCQkZKTlJVMTEuVSkqGSwdMS0xMTU1Nhk4GT09QUFFRhFIJU1NTVFRVVVVWhFUGVlZWV1dXhFgHWVlYWVhZWYRaCltaW1xbXFxcXVyEXQVeXV5fXodfBmBhYWFiYYViDmNjY2VjZWVlZGRkZmdmhGcNZmhoZ2hoaWhpaWhpaYhoAWeJaAJpaIhpBWhoaGlohGmEaIJphGiDaYVqA2traolpgmiFZxFmZmdnZ2ZmZmdnZmZlZWVkZYRkhWOAYmJhYmBhYGBiZWZncXVwcnV0b2tpaW1pb2pjcYqcl5CRmZ+YjoeDhomOjYmCe3yCf39/fX6CgYmYpKWloae9ZmloZcK6r6afmpSJhoeDe3d7gHlwf5aen6GjpqqssbS1tre9wsbIx8W7raejnZOMh4B+fYWQlJialpSao6qsra2ArKmknZucn6GjpaSgnpqWkpGPjYiDfHl1a15aWltaXGRtdH+MlJ2gpqinpqSjop+clZCKhoJ+fnx7fH2BhYmOk5eYmZyenp2cmZmamJiXlY2GgHhvZ2VlZmpucnZ5eXt8fYCFhoeJiouMjIyLi4qJiIeHhYSDgYF/fXx7enl4d3ZLdnRycW9ubWxqZ2ViYF1dXF1bWFeppKWkpaKfnZyal5eWk4+OkJKTkYuCfXp6eXh5eHh3dXFwbmtpaGZmaGtraWhpampnaGlqZ2hpPb+9uraztLS4vsDBwLu7vsC8ubq2s7G0trC0vL/AvrKrqq+ysrCrrKmopqGenJ6eoJ+bmpmYmJaWlZaVlpaGlYSUApOUhpMEkpOTkYWSBpGRkZKSkoSRAZCHkQeQkZGRkJGRj5AMj5CQj5CQkI+QkI+Qio8ajo+Ojo+Pj46Pjo6Pj4+Ojo6Pj46Ojo+Ojo6Hj4KOiI8BjoyPB5CPkI+QkI+GkIKPhZALkZCQkJGQkZGRkJCJkQKSkYaShpMClJOElIaVDJaVlZaWl5aWl5iXl4SYCpmZmZqZm5qampuFnAednZ6enp+fhaAFoaKjo6OEpCOlpaampqeop6eoqaqqq6urrK2ura6ur6+wsbGysrKztLW1toS3BLi4ubmEul+8vLy9vr6/wL+/wMDCwsPExcXFxsjIyMnJysvMy8zNzc/O0dLS0tTU1NXV19jZ2Nvb3N3e39/h4eLj5OTl5ufq6Onq6u3v8PLz9PP19vf3+fr7/P3+gYGB/4CBgIGBgYSCBYOCg4SEhYUfhoeIiImJiouLi4yNjI2Njo6Pj4+QkI+QkZKSkpOTk4WUhJUXlpWWmJeXl5iYmJmZmpqbnJucmpycnpyEngmfn5+gn6CgoaCFogqjoqOko6WlpKSlhKYMqKeop6enqKipp6iohaoSqaqqqaqoqqmpqaqqqqmrqamqhasOqquqq6urqqqrq6upqquGqoWrAqyrh6wGq6ysq6urhaoKqampqKiop6iopoSnFqanpqempaakpaSko6Sjo6Sjo6KioaGEoICfn6KkpaqwrK6ysKqnpqWop6qmoam/0M7IyM/W0cjDvb/Dx8bDvrW2u7q5t7W2uLi/zNja3Nfc8YCDg4H68Obc1tHMwr69urWws7exrLvQ1NTW2N3f4uPn6Onq7/P3+Pjz6t/Z1c7FvrezsLK8xMbKy8fFzNfb3uDe29rUzcvN0BPR1NTT0czKxcPCwL24s66rppuPhIuAjZadpbG8xMrQ0tXT0NDPzcvHwru3tK+sq6qpqayvsra8v8LExsfJycbEw8TDwsHAvbewqqGZk5CRkZaanKKkpqeoqaytsLGytLO0s7S1tLOxsLGvra2rqqiop6ako6Khnp6enZyZl5eVlJORj4yJh4eFhoaDgPv49/j59vLw7+wt7Ovp5uTi5Obn5uDW0c/OzczOzcvKyMXEw8C9u7m5u72/vr27vr68u729vby9/3//f/9/y38EgICAf/+A/4CqgISB/4DSgLd/AgIEADpJREJCQUNISktMT1RWVE5ISEhNTUdDRUhJUFlZVEs/ODg+QD03MjIxLCopJygnJygnJicnJiUkJSUliCQFIyQjJCSGIwMiIyKEI4ciASGEIgchISEiIiEhhCICISKMIQciISEhIiEiiSEBIoUhASCHIQEgiCEDICEgiCGCIIkhBSAhISEihCEMIiIhIiIhISEiIiIhhSIBIYUiASOEIoYjASKKIwckIyMjJCQjhSQGJSQlJSUkiSWIJogniCiEKQUoKikpKYYqHSsrKywsKywtLC0sLS0uLi4vLy8wLy8vMDAwMTAwhDEIMjIzMzM0MzSENQk2NjU1Nzc2NzeEOIQ5Gzo6Ozo6Ojs7PDw8PT09Pj4+Pz4/Pz9AQEBBQYRCXkNEQ0NEREVGRkZHR0hISElJSkpJSkpMTU5PTk9QUVBQUVFSUlRTVlZYWVdVV1ZYWVxdXV1fXl1eXl5fYWExMTIyMzIyNDQ0MzM1NjY2NTQzMjIyMzM0MzU1NjU2NjaENwo4ODk5OTo6OTk5iDoROzs7Ojs8Ozs7PDo8Ozs7OjuEPB49Pj4+Pz4/Pj4/Pz8+Pz4/Pz9AQD9BQEBBQkFBQkGHQgxDQkJDQ0RERkVGRkSERQVGRUdGR4ZGA0VGRIRFF0RERUNFRUZGREVGRkVGRUREREVFRERFhEQBRYREC0VEREVEREVFRUZGhEcTSEhIRkZGR0dIR0ZGRkVERURERIdFgERERENCQUFCQkJBQUJBQkJDQkJAQUFBP0BAP0BBQUVLSEhDQkFFRkZDQUJBQ0RERUNCREpccH5ycnt8e3x0aGFiaGZmZF9jZGp7eHd9gYWIkaCora+upZqQh4J/fHxzbXB0e3Vub3N2dXV4fIKCfnp1eo+hr7i5uLewqJ6UjIN7gG9kYmhyf4uZoqempqSkpaSjn5iOg31+gYKCh4eHhX97eXh2cWllZWVfWFRPT0tLTVBQWml2fIWNl5yenpyalZCIgHlxaWRiYF9eYWRqcXh9gYOFiY2Pko+MiIeHhISFgnpyaGFcWFNUWFthZWhvc3Z3enx+fn6Dg4OCgYCBfX18XHt5eXZ1cnJxbm5tamhnZWVjZGRjYmFgXl1cXFlYVFJSUVFQT0xJjYqJiYWEgYGCgX+Bgn99e3dzbWdgWVRST0tJSUtNUFBPTU1MSUZFRkpLSkpKSEdGQkJDQkZILG1oZWVkZ2tsbG5zd3Zzbmhqa3BuZ2VmaGhweHhyaF5YWmBhXllVVVNQTUxLhEoHSUlKSUlISIZHiEYCRUaKRQRERERDh0QFQ0RDRESRQ4VCDkNDQ0JDQ0JCQkNDQkJDk0IEQUJCQYVCBEFCQkGPQoJDhkIHQ0JDQ0JDQoxDBEREREOLRAJFRIxFikYFR0dGRkaFRwNISEeFSIhJhkqHS4RMh02FToRPg1CEUYRShlMBVIZVBVZWVldXhFiEWQ9aWltbXFxcXV1dXl5fX1+EYIRhB2JiY2NjZGSEZQNmZ2eFaIJphGoHa2tsbW1uboRvDXBwcXFzcnN0dXZ2dneEeRx6fHx8fX5/gH+AgYGCg4WGh4eHhoeGiImKjI2PhY4Sj5CSk5NKS0pLTUtMTU1NTk1OhE8PTk5NTU1OT09QUFFSUlFShFMTVFRUVVZVVlZXV1ZXVldXWFdYWIZZCFpaWllaW1tbhlyDXYRehF8EYF9fX4RggmGEYgxjYmNjY2RjZGRlZWWGZgRnaGhoh2mFagNramuKagNpammGagVrampra4ZqAWmFagFphGoEaWlqaYRqDGtramtrbGxsa2xsbIRrCGpqaWloaGhpi2gUZ2dmZWVkZGVkZGRjY2RkY2NiYmOFYYBgYWFiZmlnZ2NgYWRlZGFgYGBhY2RjYWBiaHqMl4qOlZOTk4p+enuAfn17dnt7g5ONjZSXm52otLi9v7u0q6GYlJGPkIiEhoySiYKEiYuLiYyQkpWTkIuMnq27w8XGw722r6Wdl4+Fend6g46Woqyvra6wrrCwrqymnZSPjpGTkoCUl5eWj4uKioiEfnl3d3NsZmNhX15gYmFod4KIkZmhpqampaSinJWPiIF6dHJxcG5wdHh9g4eNjpCTlpmal5SRkZCQkZCNiH53cGxoY2Nna3Bydnp/gYKEhoeIiY2Pjo2NjIyLiImIh4WEgoB/fXt6eXh2dXRzc3NycXFvbmxqakJpZ2ZiYF9fX15eW1mrqamopaOhoaOhnp+hnp2bl5SPiIB7d3ZzcW5vcHN0dHNycnFuamprbnBubm5sbGpnZ2hpamwtwLy5ubm6vsC/wMTJycbCvL2+w8C7t7i7usHJyMS7r6qrsbGuqaSlpaCcm5qahJkLmJmZmJeXl5aVlpaFlYWUCJOTkpOTk5KThpIUk5KSkZGRkpGRkZKSkZGQkZGRkJGKkIKRiJABj4WQBI+Qj5CMjwGOho8Ljo6Pj46Oj4+Pjo6GjwOOj4+EjgSPj4+Oio+EjoaPAY6Hj4KQhI8FkI+Qj4+GkAGRhZAHkZCQkZCQkIeRhZIEk5OSkoeTBpSUlJOUlIWVApaVh5aCl4WYhJmEmoKbhJwKnZ2dnp+en5+foIShEqKio6OkpKSlpqampaenqKipqYSqGKusra2trq+vsLCxsbKys7O0tbW1tra2t4S4XLq7u7u8vL29vr6+wMDBwMLCwsPExcXHxsfIyMnJysvMzc3MztDQ0dLT1NTV1tfX19jZ2tzd3d/e4OHh4uPj5ebn6Orr7Ozs6+zs7/L19Pf3+Pj39/j4+v3/gICAhYIEg4OEg4eFDoSFhYWGiIiIiYuLjIyMhY0Ejo6PkISRApKRhJMFlJOUlJWEloSXDpiYmZmZmpqZmZqam5uchJ2FnhGfn6CgoKGgoqGhoqKio6OkpISlhKYUp6anqKipqKiqqaqqqqyrq6usq6uGrAitraurrKyrq4asEK2traytrKytra2sraytra2IrAirrK2trq2trIWtCq6tra2ura2trK2FrAarqqqqqaiFqRGoqKmpp6inpqelpaakpaSkpYSkBqKio6OhoYWgbZ+fpKelpaKfoKKjop+enp2en6CgoJ2eo7HDzMTGzMzJy8S5tLW5t7a1sbS0usnFxcrOz9Tb5uzy9fPs49nSzcrHx8C8vcHIwry9wsPCwMTIysvGw7/D1eLu9PX18u7l3dbQyMC3raywt8PN1t+E4IDf4ODf29TMxMDBw8PDx8fHxL+7urq3s66pqqiinZiUkpCPkpOTmqiyuL7GztHS0dHSzcfBu7Wup6KgoJ2cnqOmq7C1uLm7v8HExMLAvLu8uru7uLGro5yYlo+Qk5ednqKmqKuurq+ysbK1t7i4trW0s7Gxr66uraupqKako6Khn0+enJubmpuamZiXlZSSkpCPjIqJiIiIhoWC/vr7+fj28/T19PLy8/Lw7+zp5N3Vz8zKycTCwsPGyMjHxcfEwb2+vsLEw8LCv7+9uru8vb6//3//f/9/y3//gP+A/4D/gIaAtn8CAgQAKkRHSElLT1NYXl5cW1tdXVdRS0VCQ0VGS0xNUVNKQj02MjM2NDEwLConJ4YmAiUmhSWKJBYjIyMkJCMiIyMjIiMjIiIiIyIiISIjhSKCIYUiAiEihSEBIoQhASKJIQEgkSEKICEhICEhICEhIYUgCiEgISAhICAhISCHIQggISEgISEhIIkhAyIhIIQhASKFIQQiISIhjCIHISMiIiIjI4QiBCMiIySIIwIkI4kkhyUFJCUlJiWEJgElhyYCJyaEJwQoJygnhSgFKSgpKimIKoQrhCyHLQMuLy6EL4YwgjGFMgYzMzIzNDSFNYI2hDcCODeFOIM5hToEOzw8PIU9gj6EP11AQEBBQUFCQUJDQkNEREVGRkVHR0dISElJSUpKSktKS0tMTU5PTk9QT1BQUVJTU1RVVlZWV1ZWV1hZWlpbXV5dXV5fXl9gX19gMDEyMjExMjIyNTY1NDQzMzQzMzOENAE1hTaCN4Q4hDkGOjo6OTo6ijsCPDuGPDY7Ozw8PT08PT0+Pj9AQEFAPz9AQEBBQEA/QEBAQUJBQUJBQEFCQkNCQ0JCQkNDRENEQ0FDRESFRQNGRUaERxBGRUZHRkZHRkZFRkZFRUZEhEWGRgFHhEYLRUZHRURFRUVERUaGRQVEREZFRYRGBUdHSEhHhEkhSEhISUdHSEhHRUZFRURERkZGR0ZGRUVERENDREREQ0NChkOAQkJBQkFBQEFAQEA/QEFCRUZFSVFJQ0JAQD4/QUFAQ0VEREJBREdDQkpXYGtsZF1bYWdoX1xkam5ya2+Dl5WKgIuVm5+gnZaNjo6Vlox/cWViaW1maXB2d3VzcnJycHBsbHaDiY+RkpGPjouHgHxzamJkanB3hpelrbO1tbKuqqSAmo+IgHZwc3Rzdnd1c29tbm5wbmtkYF5YV1dVUVBVWltdY2psa3B9g4WGiImJh4N7cGVcXl9dW1ZaYGVpa21ycnh/h42Oj42IhH99fH18eHZ0cW1raWZnZ2Zpb3J0eHt9gH6AgoSGhoSDgYB+fHp6e3h2c3FubWxsa2dnZWNgX106XV1eYGFiY2JhYWFeXVtZWVhWVFJQTkiHgoOFhYKCgIGAg4SBfXhybGdiXFdUUElEREdMTU5PUE9LSoRIDUZHS0tIRUZGRERHSEUraWxsbW1xdXp/fHl6en58dnFrZmVlZmhqa21xcmpiX1dUV1lXVFJPTEpKSoRJhkiFR4hGA0VGRopFD0RERUVERERDREREQ0RDRI1DA0JDQ4pCAUOaQoJBj0IBQZtCBENDQkKMQ5BEAkVEkEWFRgNHRkaIR4pIg0mISoVLhUwCTUyETYZOD09PUE9PUFBQUVFRUlJRUoRThVQKVVVUVlVWVlZXV4RYCFlaWlpbW1xchF0JXl5eX19fYGBghGERYmJjYmNjY2RkZGVlZmZnaGiFaUtqampra2xtbG5ubW5vcHBxcXJyc3N1dXZ2d3d3eHl6ent8fHx9fn5/foCBgYKDg4SFhoaGh4iIioqLjIyOjo+PkJCQkpOTk5RKS0uETCJNTU5QUE9PT05OTU5OTk9PT1BRUVJSUlNTU1RUVFVVVVZWhFcCWFeFWAdZWVlaWltahlsFXFxcXV2FXgZfXl9fYGCFYQdiYWFhYmNihGMFZGNkZGSFZQRnZmZmhmcIaGhpaGppamqFawdsbGpqa2tsh2sVamtqamtramtsbGxra2xrbGxsa2tshWsBbI5rC2xsbG1sbG1tbW5th2wRa2tqamppamlpampqaWhoaGmEZ4ZmhWWAZGRkY2NiYmJhYWBgYGJkZmVlaG5mYmFfXl5fX19gYmNiYWBgYmNgYWhyfIaFe3Z1fICAd3R+g4iJgoabqaaalqGorbCwrKOeoJ+npZ6ShXp5goZ+f4aKi4qIiIeGhoWCgIqXm6CjpKOhn56alZGJgHh2fIKIlKGvtrq/v7y5trCAqZ+ZkoiChYeHiIiHhIJ/fn+Af3x3c3BsamloZGNmbG1scXh6eoCLkZKUlZaWlJGLgXdvb3BwbWdpb3N2eHt9f4OKj5WXmJeUjoyKiomJhoSCfnt5dnNzcnN3e32Ag4WIiYmLjo+PkJCPjouKioeFhoWEgX9+fHt5eHV1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bGtubivCwL+9wMfP1tne4ODe19HNycXCvbi2u8bCwcG/ubOvq6aioJ+enJuampmZhZiFlwiWlpaVlZaVlYaUA5OUlIeTipIEkZGSkoSRAZCHkQmSkZCQkZGQkJGEkAqPj5CPj4+Qj5CQjI8BjoiPAY6Hj4eOAY+JjgGPho4Cj46EjwWOjo6PjoiPBI6Pj46MjwOQj4+EkAGPipAEkZCQkYSQBpGRkpGRkIiSBJOSkpKEk4WUhZURlJWWlpaVlZeWlpeXmJeXmJiEmQaampuam5uEnASdnp6ehJ8woKCgoaGioqOjpKOkpaWlpqamp6enqKmoqquqq6usra2ur6+wsLCxsrKytLS0tbW2hbdYubm5urq7u7y9vb6+v8DAwcLDwsPExMbGx8fHyMjKysrMzMzOz8/Q0NLT09LU1dbW19na29vb3d7e3+Hh4uTk5eXm5unq6+rr7O3u7+/x8vL09ff29/j7+4T9EPz+/4CAgYGBgoOEhYaEhYWGhkuHh4mJiYuLi4yNjY6Pjo+QkJGQkZKSkpOUlJSVlpWWlpaXmJmYmZmZmpmamZqbnJucnJ2dnp6fn5+goKGioqKjo6Sjo6SkpKWmpqWEpoSnBainqKipiKoTq6usrK2sra6urq+vrq+wr66wsYSwF6+xr7Cvr7CvsbCwsbCvr7CwsbCxsbGwhLEGsLCvsbGxh7Amr6+wsbCwsbGxsLGxsbKysbGysLGwsbGwsK+vra2urq2trKyrrKyEqwWqqquqqYWoAaeHpgilpaSkoqOiooWhgKqtqKWjoqGioqOioKKlpaampqKioqChnpqbo7CwsbO2uLWysLOzvcfO2Ovt6Ojm4NbR09zj5eLl8vb17ODPvraysrC2w8rP0M/KxcPFxsTBvry+vby4s7Cwr7OzsK2tq6+utb/Hz9zn8fPz7ujh2tbMxsG9uLi4tri4t7W0sbGvgKqopKKfnZmUlJSSkJKWmZudoKOiop6doqWlpaqsraqmnZaYm5mXmp2ipqahoKOqsri+vru5trKsp6enpqSorayrqaqqq6ysq6yurq+xsrS1uLe6urq4trW1s7Oxsa6sqaakoqKioZ6dnJuZl5aUk5CQkpSXmZqbnJubmJiVkZCPOo+Ni4mGgvz6+v3+/vz9/Pf7+vn17eXg3NjV1dHKw7y6vb/BwcPHx8XFxMXGxcC7u7u9vsDE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hEkESkpKSYdKhEuETIVNDk5OTk9OTk9PT1BQUFFRhFIFU1JTU1OEVIRVhVYDWFdYhVkJWlpbW1xcXF1dhF6FXxpgYGBhYWJiYmNiZGRkZWVmZmdnZ2hoaWlqaoRrDWxsbW5ub3BwcHFxcnOEdDZ2d3d3eHh5eXp6enx8fH1/gH+AgYKCg4ODhISFhoeHh4iJioqLjI2Ojo+QkZGSkpSTlJSTSUmESgNLTEyFTRBOTk5PT1BQUFFRUVJSU1NUhVWCVoRXFVhXWVhZWlpaW1xcW1xdXV1eXl5fXoRfg2CEYRRiYmJjY2RkZGVlZWZlZmdmZmdnZ4RoAWmEaIRpCGpqa2prampphGoFa2trbGyEbRpubm5vbm5vcG9wb25ub29wb29vbnBvb3BvboRvgnCGcQFyhHEGcHFxcXBwhG8OcHBvcG9vbm5vb29wcXCFcQRwb29vhG4PbW1ubWxsbG1tbm1tbWxshmsFaWlpaGmEaIBpaWlnZmZlZGNjY2JjYmdlYWFhYGBhYWFiYWNlaGppZ2pnZmNpZ2JhYF9dXWBseX94dG9xeoqepq6so5KHi5CMiZajsrOvsrS3s6qilJacnZmIh5GXmJedn56dnJ2dm5qbnZqTh35xamhlXFhYXV9jZmtxcHF3g5OdprCysq6rpyikn5mQipGXmZuclpKOi4mFf3dtZ2NfYWRkYmNnaGRgZmZdVldcY2RghF6AW1lZXWJnZ2ZnamxtcXR0cW1ygH93cG5xeX6ChIB9e3l5dnd5fYKGh4iIiYmJh4WGh4eIjI2QkZGPjo2JhoN/enZ1dHNycHBwbm1vbmxqaWhoaWpsb3BzdHZ2eHd1dXNycG9ubWlmZGBdW1taWVhZXV1bWVepo5+clpGPioiBfXsddnJvbWxqaGptb3J2d3h6eXh5eHZ2dHJwb3FvbW8uwsG6wMbJycjN0tPR0M/NysjKyMbBvsDAvry4ury6tLCrpKCfnJqamZmYmJeXloaXEZaWlZWUlZWUlJWUk5SUlJOUiZOHkgaRkpKRkZKEkYKQhJEDkJCRh5CCj4SQh48BkIaPBZCPjo+OiY8Ejo6Oj46OAY+EjgeNjo+Ojo6Pho4Lj46Oj4+Pjo+Pj46FjwOOj46GjwGOjI8GkI+QkJCPjJACkZCIkQKSkYiSApOShZMDlJOThZQGlZSVlZaVhJYfl5eXmJeYmJiZmZqamZqampubm5ycnJ2enp6fn6CfoIShgKKio6OkpaSlpaamp6enqKioqaqrq6ysrK2trq+vr7GwsrKys7O0tLW1tra3uLe4uLq6u7u7vL2+v76+wMDCwsPDw8TFxcbHx8jJysrKy8vMzc7Pz9DS0tPT1NXW19jZ2drb3N3d3t/h4OHj5OXm5ubn6erq7O3s7u7v7/Hy9Pb2Gvj3+fr6/P39/f7+//+AgYCBgYGCg4SEhYWFhIYDh4iIhIkhiouMjY6Ojo+QkJGRkpKSk5OTlZSUlZaXmJeZmJqZm5qbhJwQnZ2en5+foKGfn6GhoqOjo4WlCaanp6inp6iop4SqBauqq6uqhKuDrIStDq6ura2tr66vsLCvsLGxhLIds7OztLSztbO0tLSztLO1tLS0s7Szs7S1tLS1s7SEtQm2tbe2tba1traItQe2tLO1tLSzhLUDtLW1hLYQt7a0s7Szs7OysbGysbCwsISvBLCwr6+ErgqtrayrrKuqqqqrhKoPqainp6ampaSkpKOkp6iihKGAoKGhoqGioqWnp6Wop6SgpaWgnZ2cmpqbprK3sq6rrLPB0trk5dzJwMLGw8LN2efq5ujs7enh2svM0tTRwsLLz8/P1NTT0tPT09HR09LPxbmxpJ+dmZGNjpKVmJugpKWnrbnI0tnf4uDd2NfU0MjAv8XJy8zLx8O+u7q2r6iel5SAkpOWlpOVmZqVkZaWjIaGjJOTj42Ojo2JiIiNkJaVlJaZnJygo6GemqCqp6KamZ2jqa+wqqmnpaShoaOorbCxs7OztLGxra2vsLG0tri5urm3tLKwrKeinp2dm5qXmZmXlpeWlZOSkZCSlJWXmJqcnp+fn56dm5qYmJaVk5CNioY0hYOEgoKDhoeEg4H59fLw6eTi39vV0c/JxMPBv728vsHDxsjLzM7NzMzMycrIxcTBxcO/wf9//3//f81//4D/gP+A/4CRgKl/AgIEADFAQ0ZIR1BYWVdaXVxbWllWWFlYUklJU1dTS0hGSkpJRz80LyspKCcmJSUkJSQlJSQlhCSPI4QiASOEIgUhIiEiIoQhASKLIQIgIY4gCiEhICAhICAgISGcIAEfnCABIYcgCSEgISAhISEgIIUhASCLIQciISEiIiIhhyIGIyIjIiIihSMBIoYjBCQkJCOFJIUlASSHJYcmBScmJycmhCcCKCeFKAIpKIUphSqGKxUsLCwtLC0uLS4vLi8uLy8vMDAwMTCEMQcyMTEyMzMzhDSDNYQ2BTc2Nzc3hjgMOTo6Ojs6Ojs7PDw9hD4SP0BAQEFBQUJCQkNCRERERUVGhEcGSUlISUlKhEsLTExMTU1NTk9PUFCFUQdSVFNUVFRVhFYIV1hZWVpbWlyEXQdcX2BfYDAwhzGLM4Q0BTU1NjY2hjcQODg5ODk6OTk6Ozs8PDw9PIU9Bj4+Pz9AP4pAHkFCQUFBQkFCQ0RDRERERUVERkVGR0ZGRkhISElHSIVHAUWERgRFRkZGhEUoRkZHRklHR0dIR0dJSElJSElJSUhJSUlISUhHR0hIR0hJSEhKSEhKSYZKEktLTExKS0pKSklKSElISUhJSYVICUZHSElJS0xLTIRLG0pJSUlIRkdGR0ZGRkhISElISEhHSEhHR0hHSIRHFkZHSEdIR0dHRkZFRUVDQ0NCQUJBQUKEQRJAQD5APz4+QEBAP0A/RkRDQ0WFP4A+P0BFTFpgYGZudoSNlpiLfnpzd3uCkZupsLCxsqyjmo6BfoiLiXtwbnV/gIGGjo6Ni4mJjZOTkYt+bmBZV1hSRTw5OTk7PkJFR1FfbHqLm6WoqKWdlIyEfH+EjJGWl5STjoiBfXhsYFhWU1NVWltcWllWTktOSEJDRU9XVlJKQxQ/Pj9CQTxBQ0dNUVNUVFZZV2FpbIRtgHBzeHuAf35/fHZyc3N3en1+gIKCgYB/e3l4eXt9f4GBgoKBfnt4dG1pZmNiZGVjYmNlZGVmZWJgXltaXF1hYmZpamxsa2tpaGZkYmFfXFlUUU1KSklKS0xOTUxKSYyHgX16cmxnYV1bV1RVVldXVVJRUlFSVVVWWVlaWllcXVlWBlNSTEQ8PSxmaGtra3R6eXh8fn18e3l3eXp5cWlqcnZybWloa2pqZ15WUU5MS0pISEhHSIZHA0ZGR4ZGjEWKRIpDBEJDQ0OeQgZBQkJCQUGGQoJBhEICQUKFQQtCQUJBQUFCQUFBQopBmUIHQ0JCQ0NDQoxDBkREQ0NEQ41EiEWLRgdHR0dGR0dHh0iGSQVKSUpKSYRKBUtKS0tLhkyFTYROBk9OT1BQUIZRg1KFUw1UVFVUVVZWVldXV1hYhVkGWlpaW1tbhV0JXl5eX19fYF9fhGEFYmJjYmOEZAxlZmdnaGlpampqa2uEbBBtbm5ub29xcHFycnNzdHV1hHYyd3l5eXp6e3x8fX19fn+AgICBgYKCg4SEhoaGh4eIiYqLi4uNjY2OkJCRkpKSk5VKSkqFSwFMhE2FThJPT09QUFBRUVJTU1NUVVVVVlWFVglXV1lZWVpaW1uFXAFdhF6CX4ZggmGEYhljY2RjZWVmZWZmZmdoaGlnaGlpaWppampqhGsEbGtqaoVrE2xsbGtsa2trbGtsbm1ubW9ub2+FcAxxcHFxcHFxcXBwcG+EcANxcXCHcQFyhHMEdHNzc4ZyBnFxcXBxcoRxEXBwcXBxcXFycnNzcnJzcnFwhG+DboRtC25vb25ubm1tbGxthGwfa2xqampra2tqamppaGhmZ2ZlZWVkY2NjYmNjYmJiYYlgA19gZoRjgl+GXoBkanZ6eoCIkJykq6udk4+Jj5CXpq64vb2+v7mxqqCUlJ2gm5CHhYmSlJaYn6GfnZucoKWmo5+Wh3lwb3JsX1ZUUlNTVlpdXWVyfYiYpK2zsq+popuTjY6TmZyhoqCempWPjId+cWpoZmdmbG5ubWxqYl5gXFRVWF9oZ2VeWFRSU1dWVlFVV1pfY2VlZWZpZ252d3l5eHl7foOHiYqJiYiBfn5/goSIiouLjY2MiIWEhIWFh4qLjY6OjYuIhYB8d3RxcXJycG9xcnFxcnFubGpoaGlsbW9ydHaEd0B2dHJwb29saWZjX1xZWFhYWltdXFtZWKymoZ+bk42Jg399eXZ3eXp5d3V1dHR3eHl6fH19fHx9fnx3dXRvaGJiKLi7vr69xs3OzM7S0dDOzszLzcvFu7vEycW+u7q9vLy6sKejnpybmpmFlweWlpaVlpaWhZWIlAiTk5SUlJOTlIeThZIFkZGRkpKHkQSQkJCRhJABj4SQAY+EkISPgpCEjwGQiI8Ejo+OjoSPhI4Gj4+Ojo6PmY4Pj46Oj46Ojo+Oj4+Oj4+OiY8Bjo2PAZCEjwSQkJCPiZAHkZCQkZGQkImRh5IDk5OSiZOElIWVBpaVl5aXl4aYhJkEmpmamoSbD5ycnJ2dnp6fn5+goKGgoYSihKSEpQSmp6eohKl7q6usrKytrq6vr6+wsbKysrO0tLW1tba2tre4uLm6uru7vL29vr+/wMHBwsPDxMXFxsfHyMnJycrLy8zLzc/P0NLT0tLU1dbX19jZ2djZ29zd3t7f4OHi4uTl5ufo6Ojq6uvt7O7v8PHx8/T19vb49/n7/P79/v7/gICBhIIJg4OEhIWGhoeGhIc7iImJioqLi4yNjo6Oj5GQkZGRkpOTk5SUlpaXmJeXmJmamZqam52cnJ2enZ6fnqCgoaGioqKjpKSkpaWEpgSoqKiphaoKq6urraytrK6urYSuBK+vrq6Fr4SwDbKxsrGysrO0s7S1s7SFtQO2tbaHtYS2Gbe2tre2t7a2tri4t7i4uLq5ubq5t7e5triGtwS2t7e3hbYTtba4uLm4uLi5t7a2tbS2s7Oys4SyB7GysrGysbGFsBmvr66vr62trqysrqysrKurqqmpqKempqSlhqQBo4SigKGhoKCfnqCgn5+joqCgoJ2dnJuam5qbn6SutbW5wcbT2eLi1cvIwsXHzNni7fP09vbx59/XzMzV1tPJvr7DzMvM0dbW1dHQ09fa3drUybqtpqanoJOLioiJiYyPkpScqLS/zNbd4uDd19LJw76/xcnN0tTQzsvGwLy4rqKdm5mZgJqfn5+dnZqRjpCLhYWIkJeXk42Hg4GBhYSBhIaKj5KTlJSVl5WboqOlpqWlp6ussLS1s7Syraipqq6vsbS1tra2tLKvrK2urrCytbW3t7SzsK2ppKCcmZqZmpiXmZqZmpuYlpSTkJCSk5WYmpyfn5+enp2cm5iXlpSTkIyIhYKBG4GCg4aHh4SDgf/59fLu5t/d2NLQzMnLzMzNyoTIE8rLzc7R0NLRz9DS0MzIxsK7tLT/f/9//3/Lf/+A/4D/gP+Ak4CpfwICBAAJP0NIS05OS09VhFscWFVTUE9NTU9UWFNHOz5FSUpJQzoxLCkoJyYlJYQkASOFJAMjIySNIwMiIiOIIgMhISKLIQYgICEgICGFIAEhqCAIHyAfIB8gIB+HIAEfiSABH44gASGIIA4hISEgICAhICEhICEgIIohASKFIQ8iIiIhISIhIiIjIyIjIiKFIwUkIyMkI4okBSUkJSQkhyUIJiUmJiYlJiaEJwYmJycnKCeFKAYpKSgpKSmGKoUrBSwsLC0shC2CLoQvFTAvMDAwMTAxMTIyMTIyMjQzMzQ0NIQ1ATaGN4c4CDk6Ojo7Ojs8hD0KPj4/P0BBQkJCQ4RCHUNEREVFRkZHR0dISElJSUpKSUpKS0xLTExNTE5NhE8GUFBQUVFShFMfVFVVVldXV1lZWFpZWltbXF5fX2BfYDAwMDIyMzQ1NYQ0hDUDNDU1iDaEN4Y4ATeEOAw5Ojo7PDw8PT4+PT2EPhQ/Pz8+QD9AQEBBQUJBQUFCQUJCQoRDHUVGRkdHR0ZHR0hISElJSElISkpJSklJSEhIR0hIhEcDRkdHhUYGSEhJSUhKhUgPSUhJSUpJSUpJSElJSEdIhUkhSElKSkpLSktKSkpMTUxMTEtLSktLS0pJSElLSUlJS0hKhUkiS0tLTExMS0tMS0xKSUpJSEhGR0dGRklJSEhIR0dHRkZHSIRHL0hJR0hJSUpJSUlISUlIRUZERENCQkNDQkREQ0NCQUA/Pj4/P0BAPz8/QEBAP0JAhD+APj4/Pj5ASFFdcHqFjo6IfX6JiH2FjI2IiZOmr7a2rJyUiIB4foiDe319fHp4e4OEgXtzc3d6foOGhoJ7b2RfWlA/NTIzMzMyMjQ3QExdbX2NmaKlpJyNf3dzcXeAiY+Wmp2Zlo+LhoB6cmphWFVbYWJgXVpTT0tHRkZDR01MR0U2QXNoXlxXV1tpP0RITFJYW2JkaGtsbnJ4eHp8fX2AgYOFg396ent8fX+BgoKAgoGAf318fX9+hH9lfn19e3l0cGxnZWdoZmVkY2RlZ2dpamhlYV5eYGFjZ2lpa2xra2pnZGJgXltZVVFNSUhJSEpMTU5NSklIRoiEfntzamNeXV1fYWFjYmRjYF1bWFVVV1lcXl1eX15aV1VVUkpCPTwpZGhubnFwbXJ4fH18fHl3dnJyb29wdHhzZl1haGtramVbU05MS0pJSEiIR4ZGikUFREVEREWHRAVDRERDRIlDA0JDQ41CBUFCQkJBjUIPQUJBQUJBQkFBQUJCQkFCnUEGQkFCQUFBhUIBQZFCCkNCQ0JCQ0JDQ0KOQ41EiUWKRoVHAkhHiEiGSYhKBEtMS0uGTA9NTU1OTU5OT05PT09QUFCEUYZShFMOVFRUVVVVVlZXV1dYWFiEWQdaWlpbW1tchF2EXjJfXl9fYGBhYWFiYmNjY2RkZWVmZmhoaGpqamtra2xubW1ubm5vcG9wcXJyc3NzdHR1dYR3O3h5eXl6ent7fH18fX5/f4CBgYKCg4SEhYWGh4iHiIqJiouMjI6Nj4+RkZKSlJRKS0tMTE1NTk9PTk9PhlCEUYZSBlNUVFVVVYVWFVdXWFhYWVpbXFxcW1xdXl1eX19fXoRghGETYmJiY2NjZGRlZWVmZmdnZ2lqaoVrhGwEa2xtbYhug2yGbQJubYRuGG9vb3BwcG9wcHBxcHFxcnJxcnFycnJxcYVyC3FycnNzc3Jzc3RzhHQHdXV0dHR1dIRzCHJzcnNzcnJzhHIEc3Jzc4V0CnN0c3JycXBwb2+EboVvCW5ubW1ubW1ubYdshW0bbGtsbGppaGhmZWVlZmVkZGRlZGNiYmBfYF9hhmCAX19gYWBeX19eXl5dXVxfZm55i5Oeo6Odk5Wfm5KboZ6cn6m4vMHAuaummZONlJyXjZCQjY2MjZaXlpKLh42Pk5icnZmSiH13dGtaT01NTk1MTExPVmJxfoyapKyurqmdkImGg4aPlJqgpamloJyYlZCJg3x0a2htcnVyb2xoY2BQW1lZV1thX1xaVpyTi4iChIeTUldaXmJmaG5yc3h4e32BhISFhoaMjI2QjomGhoiJiYuMjIuNjYyMi4mIiomJiouLjIyLi4eFgn16dXF0dHOEcVRzcnR1dXRxbWtsbW5vcnR1dXZ2dnVzcW9sa2pnY19cWVdXWFhaXF1bWlhXVaijoJuUi4SAfn+AgoOEhIaFg399enl6e3yAgYGBgn98enh4dG1mYWE8t7vAwcXDwMTKztDP0MzKycfFw8LDxsrFua+zuLy9vLetpaCdmpqZmZiXl5eWlpaXlpaVlpWVlJSVlZSVhJSMk4WSBJGSkZKHkQaSkZCRkZGGkAGPhZAGj5CPj4+Qk4+DjoWPBY6Pj46NlI6Cj4mOBo+Pj46PjoSPAY6FjwGOhI8Djo+Oh48BkIWPBpCPj5CQj4WQAY+EkAGPhJCEkQeQkpGRkpKRjJKHk4WUh5UGlpaXl5aXhJiCmYaahJsKnJ2cnZ2enp6fn4SggKGioqKjo6SkpaSlpqamp6eoqKipqqqsrK2trq6ur7CwsbGysrKztLS1tbW2t7e3uLi5ubq7vLy9vr6+wMHBw8LExcXHx8jJy8rJysvLzM7Oz8/Q0dLT09TU1dbW19fY2Nna29vc3t3f4OLh4uPk5Obn5+jp6+vs7e3u8PHx8/P0JfT3+Pj5+vv8/f7+/4GBgYKDhIWGhoeGh4eIiImJiYiJiYuKi4uEjD6NjY6Pj5CRkZKSk5OTlZSVlZeXmJmZmpqam5ycnJ2dn56en6CgoaGioqKjpKOkpKWlpqanqKipqaqrrK2srYSuIa+vsLCvsLGxsbKxs7GxsbCxsbKysbKxsrOzs7Kys7S0tIa1CLa2t7a3tre2hLgLube3uLe5uLi4ubiEuRu6u7q6uru9u7y7u7q6ubm6urm6uLm5uLm5ubqEuRG6urq5uru5ubm4ubi3t7a2tYS0K7O0srO0s7KysrGwsbGxsLGwr6+usLCvr7Gvrq6vra6sqqmpqaempqanpqaEpQGkhaIRoKChoKCgn5+enaCfnZ2dm5uEmoCcoaeywMnU2trVy8zT0cnQ1tbR093s8vj48OHbz8rEydDOxsjIxsfFxczOzMW+vsTHy87S0s7Hu7KsqZ+OhIODhIOCgoKHjJios8HM1t3e3NXMwLm2s7fAxsvR1NjUz8rIxsG7ta2knJugpKWjoZ2Zk5CLiomHi5COi4mE+vHq6CTi4+fzgoWJjJCUl5yen6Skpqitr6+xsLG1tbe5uLSxsbKzs7SFtga3tbOysrKEs2e0s7KysK+sqqeinZycnJuamJiZm5uanZ2cmpaTlJWWmJmbnZ6fn5+dm5mXlZOTkIyIhYKAgYGChYaHhIOBgID79vPu597Y1NHS09XW1tjZ2NbS0c3Mzc/Q0tTV1dXU0M3Ly8fAuLWz/3//f/9/yn//gP+A/4CegIh/7oCofwICBAAzSEVGS09VWVdYWFVVVVJNTEpLSkxIR0U/PTw4OTs8OzUyLSknJiYlJSQjIyQjJCQjIyMkhyOJIgEjhSIHISIiISEhIoUhAiAhhCCCIZggAR+JIAEfhCANHyAgIB8gIB8fIB8fH4QgBR8gIB8ghB8QIB8fIB8gIB8fIB8gIB8fH5MgASGFIIQhASCTIQYiIiIhIiGJIgQjIyMihSMDJCMjiiSKJR4mJiYlJiYmJyYmJycmJicnKCcoJycpKCgpKSopKSmHKoIrhSyELYQuAi8uhC+DMIQxhTIOMzM0MzQ1NTU2NjY3NjaGNws5ODg5Ojo7Ojs6O4Q9CD4/P0A/QEBBhEIHQ0NDRERERYRGREdISEhHSElKSUpKS0pLTEtMS01NTU5QT1BQT1FRUlJTU1RUVFZWV1dYWFlZWFpbW1tdXV5eXl8vMDAwMTIzMzQ1NDU1hzYCNziKNzk4Nzc3ODg4OTg5ODk5Ojo7Oz08Pj4+PT4+PT0+Pj8/QD9AQD9BQUJCQUJCQkNDQkJEQ0REQ0RHR0eGSAFKhUkISkpLSktLS0yESgdJSElISEdIhUcESEdHSoRJB0pISElISEiFSQhKSUlJSklIS4RJG0pJSUpJSkpKS0xMSkxNTUxLS0tMS0tLSktKS4ZKI0tLSUtKTEtLTEtOTExMTUtMSklISUdHRkZHSEhHR0ZGR0ZGhUcXRkVGRkdJSUlISUpNTkxMSkdGRERDQ0OFRAhDQUNBQEBAQYRAED9AQD8+QD4+Pz49Pz8/Pj6EPYA+Q1N6k5KGfHd2d3x7gIWEgoOEgpOrsrWsl4yMkZWQhHd2ipKRkZablIyIgHx3dnBubG51dnZwaWNdU01BOTMxNDs3MTEzOUJJVW+EkJeZlINtZWVgaXN/h46QlJSTlI2EgHt1bWVgXFpeX19cV1FMSEtQU1RSS0U+d3NrXFZTT3xOUFZldkJPWWBkbHFvbm5vb2txfH19fHp6enl5d3Z3eXx8fX59fHx+f39/gH5/gIB/e3t5eHh3dXRycG5samlraWhnZ2ZkZGNmamdjYWJhYWFjZGZqbW5ta2pnZF9cWlhWUU1LR4yMSU1QUU9NSY2LioaCe3Vwa2hmZmhrhGwZampnZF9cWFVUU1RZWllbXF1cWlVPSEhJTSlpZmlvc3h6d3l4d3V2dHBubW5tb2pqaGNgX1tdX19dWFRPTUpKSUhISIVHA0ZGR4VGA0VFRopFikSJQwpCQ0NCQkJDQkFBh0IBQZFCFkFCQUJBQUJCQUFCQkFCQUJBQUJBQUKcQQRCQkFBhUKCQZRCBkNCQkNDQpJDAkRDiESERQJGRYpGA0dHRodHiEiISYRKh0uETAVNTE1NTYROhE+EUIRRg1KFU4RUF1VVVVZWVldXWFhYWVlZWlpaW1tbXF1dhV6DX4RgIGFhYmJiY2RkZGZlZ2dnaWlpamprbGxtbG1ubm5vb29whHFFcnJydHR1dXV2d3d4eHh5eXp6ent8fHx+fn9/gYGCgoOEhIWGhYaHiIiJioqLjIyNjo+QkZGSk5NKSktMTE1NTU5PUFBQhFGEUoRTA1RUU4ZUBVVVVVZWhFcBWIRZB1tcXV1eXV2FXhVfXmBfYGBhYWJiY2NkZGVkZWVlZmaEZwRoaWprhGyGbRNubW9ub3BwcXBwcXBvb25ub25uhG8Jbm9vbm9vcHBwhHEDcHBxiXIFc3JxcXKEcwx0cnRzdHN0dXZ2dnWJdoR1hXQGc3R0dHNzhXSE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DktLS0xNTE1MS0tMTU1MhE09Tk5OT05OS01LS0lISEdHSEhJSUhJSUhISUhJSEdIR0ZIR0dHSEhHSkpKTU5LSUlIR0VERURERUZEQ0NDQodBhEAQPz9AQD4/PT89Pz49PTw9PIU9gEVph5GNeXV5e3x9fHl2en98eYafqaqimZmfop+VhXmBjpicpayqoZaPhn98eXd2d3p6dnV0dG9jXFJEPDg0NDw+OjMwMTQ5QVJcYm15fntyaWJaX2l3f4SIkJSSjoZ9d25mX1lXVVVWVFBSUk5LSlBWXFtXUk1EPXRpYlhRTU5RgFVha3ZDTlRcYmRjZGVkXV1nc3RvZ2RjYGFlaXB0d3d5enp4dXJxcXR4eXp7fnt7enh3dHJwb2trbWtraWhpaGhpaGNfXV1gYmJfXV5fYGFiZWhsbm9ta2poY19cWFdVT0tJSEiQSk5RUU9MSIyGhoWBf3l0bmtrbXBzdnV0cnJvF2xpZmJcW1tYWVlXVVZWVlVUUVBNS05YL396dnh6en2ChYWBfXd0cG5uaWViYmBcXVxYVVNVVVRQT01NS0pISEdIR0dHRkZHhkaLRQJERYhEikMCQkONQgJBQoVBBUJBQkJChUEBQoVBB0JBQUJBQkKJQQZCQUJBQkKgQQRCQkJBhEIBQY1Cg0OEQpVDiESJRYlGAkdGi0eFSAJJSIVJhUoGS0pLS0xLhUwJTU1NTk1NTk5OhE8HUFBQUVBRUYVShFOEVAZVVVRVVlaEVwFYhFkEWlpbW4Rcgl2EXiVfX2BgYGFhYmNjY2RkZGVmZ2doaGlpamprbGxsbW1ubm9wb29whHEBcoRzQHR0dXV1dnZ3eHl5eXp6e3t7fH19fn+AgYGBg4OEhIWFhoaIiYmKiouMjY6Ojo+QkZKSlEpKS0xMTE1OTk9PT1CEUQlSUlNTU1RVVVWGVgZXVldXWFeEWINZhFoGW1xdXl5ehF8WXl9fX2FhYWJiYmNjZGRlZmZmZ2ZmZ4RoCGlpamtrbG1uhG0Lbm5ub3BvcXBwcXGFcoJxinAHb3BwcHFxcYRyGnNycXJycnNzdHRzcnJzc3N0c3R0dXR0dXV1hHYMd3Z3dnd3d3h3d3h2hHcIdnd2d3d3dnaOdwx2d3Z1dXNycnJxcXCEcYdwBG9vb26FbQ9ubW5vb29wcXBvbWtqaWmEaAlnaGdnZWVkY2SFY4Ri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Pj49Pj4+PT08PD08PTs9PT9CVW1va2dwdnl4cm11hZWbk5iqsru4r6mpraWWh3R8hoWBkJqcmY6Ad29pamx2foWGg3x2cGpmYlhMTFFHQ0VAQDs6M2AxNTlASFJVUkhISkxOV19kanJ/gIqNi4F7eHRwZ1pRS0RCQkZJTExLR0VITVBTWVlWSUVEPWxdUFNYXFxdZnB4QUlTWFpYUlBTWlthbGhaU0pHS1FYYGdscXV2dnJuamNgXWJnaW1yd3p7endzcGxraGNhYmZqa2loZ2doZmJcWFdXWVxfXVxeX2FjaG1vcHBvbWloPmRfXFlWU05MSklISEhMTk9NS0eKiIWEgYB8dXBucXNzd3d4eXZzb2xpZWRfXltST1NTUk9MSUdGRkdGR0pOKHh7fH+AgYCBhoqJhH16dHJwa2VdV1dYU09QUE5NTUxMS0pKSklISEiFR4dGhkUDREVFhkQBRYZEiUOOQgVBQUFCQoVBAUKFQQVCQUFBQptBBUBBQUFAh0EEQEBBQIxBCUJCQUFCQkFCQZdChEMBQoxDAkRDi0SGRQNGRUWMRolHh0iFSYVKBktKSktLS4ZMhk0JTk5OT1BPUFBQhVGFUoRTBlRUVFVVVYRWEldXV1hYWVlZWlpaW1xcXF1dXYReIV9fX2BhYWFiY2NkZGRlZmZnaGlpaWpqamxrbGxtbm9vb4RwCHJxcXFycnJzhHQJdXV2d3d4eHl6hHtDfH19fn5/gICBgoKDg4SFhYeHiImKiouMjI2OjpCQkZKSk0pKS0tMTE1OTk5PT09RUVJSUVFRUlJTVFRUVVZWV1hYV4ZYglmFWoRbCFxdXl5eX19fhmAaYWFjYmNjZWRlZWVmZmZnZmhoaWppampra2uEbYNuhG8KcHBycXFycXJycoVzB3JzcnFyc3GEcoJxhHIIc3R0dHV0dHOHdBJ1dHR1dHR1dnd1dnd3dXd3d3mGeAN5eXiGeRF6eXl5enp7enp6eXl4eXp5eYV6CHt6enl4dnZ0h3MCdHOGcoRxGHBycXBwbm9xdHV0cnFvb21sa2tqa2praoRpBGhoZ2eFZYRkEWJiYmFhYWBfX19eXl5dXVxdhFyAW11dYHOJiIWBio+Sj4qFjZ2sraatu8LJw765t762p5yKjpublqCpra2jl46GgICCiZGWmJWRi4WBfHdxZGJnXltdVllSUkyT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OD5ISUdCRU1UWmFscG9wbmpgUkxFPWpkYWVnamxxPHI7QUtRVVtRS0xKRD94QD56gHp1dXp7dnhFTktDf39HTU5UYWVdWlJKR0pOVFheY2dpa2plXlVST1BSWmJpcXZ5eHVybWtramlmZGRnZmVpaWppaWdjX1xYWVtaV1ZZXmJkaWttcG5tbWhmYmBcWFVSTUpJSZCOSEtNTkpIRomEfXp5endzcG9ydHR2d3Z2dHJvF2tqaWlnZWFaU1JRTElGRENCRUZFREZII3B1eHh7goKAfIGFhoOBfXdwZV1YU1FRTUtMTEtLSktKSklJhEiDR4dGAkVGhUWGRAFFiESLQ4tCBUFBQkJCiEEDQkFCpEGKQAFBhUAEQUFBQJBBAUKEQZFCB0NCQkJDQ0KMQwdERERDRERDhUQCRUSGRQJGRY1GAkdGhkcCSEeESIZJBkpJSUpKSoZLhUyGTQlOTk5PT09QUFCHUQRSUVJShFMFVFRVVVWEVjBXV1dYWFlZWVpaWltcXF1cXV5eXV9fX2BgYWFhYmJjY2RkZGZmZ2doaGlqampra2yEbQhubm9vb3BxcYVyQnNzdHR0dXZ2d3d3eXl6e3t8fH19fn9/gICBgYKCg4SEhoaHh4iJiYqLi42NjY+PkJCRkZJJSUpKS0tMTU5OT09QUIdRCFJSU1NUVVZWhFcKWFhZWVhZWVpaWoRbClxcXV1eXl5fYGCHYRViYmNjZGRkZWZmZmdmZ2hoaGlpaWqEaw9sbW1ubm5vcG9vcHBxcHCEcYNyhXOIdA1zdHRzcnN0c3N0dXZ2hXeFdgd1dXV2dXZ1hHYFd3d5eXiEeYV6iHuFfIJ9hnwHe3t7fHx8fYR8MHt7e3p5eHd2dXZ2dXZ2d3Z2dnl7fn15dnR0dHN0dnp9fX16fX+Cfnlybmxsa2xsbIRtDWxqamloaGhnZmZmZWWEZARjY2JhhGCDX4ddhFyAW1tgZWltc3N0eHyBipSZmZqepKvAzGdnwLWxpaGjpaGVhn2SpKWmno+Gf319gY6Tm5+fmI6JiIOCfnt7eW5mXmBoamdeV1ReYGBZU09NlZZOU11eXVlaY2ludH6Bf39+e3VnYVpTl5COkpSWmJtSnU9VXmNlbWNeX11YUp5TUaCAoJ2coaGcnVdfX1alpVlfX2RvcmxqY1tYW19kaG5yd3l6eHRuaGRhYWNqcXl/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xsjKztLS0tTUz8zP0MfEva2loqGfn52cnJubmpqamZmYmJmZmJiXlpeWlZaElQKUlYSUA5OUlISTAZSKk4SSA5GRkIWRjZABj4SQAY+IkAOPj5CEjwGQiI8Gjo6Oj4+PiI6GjQGOio0Njo2NjY6NjY6NjY6OjYmOBY+Ojo6PhI4Kj4+Pjo6Pj4+OjoyPBJCPj5CEjwGQhY8CkI+MkASRkZCQh5GIkgGRiJMDlJSThJQDlpWVhJaFl4SYg5mFmgWbnJycnYSeBJ+fn6CEoYCioqKjpKSlpaWmpqanp6ioqKqpqqurrKytrq6vr7CwsbKys7S0tba2tre3uLm5u7u8vL2+v8DAwcLDxMXFxcfIyMnKycnLzM3Nzs/Pzc/Q0tLS09TV1tbX2Nra2tvc3N3e4OHi4uTl5ubn6Onq6uzt7e7v8PHy8/P19vb2+fn7/A39/P7+/4CBgYKDg4SFhIYSiImJioqKi4uMjI2Ojo+QkJCRhJMYlJWVlpWWl5iYmJmam5ucnZ2dnp+foKGhhKMEpKWlpYSmBKeoqKmFqgysrK2ur6+wsbGxsrOEtAW1tra2t4a4Irq6ubq7u7y7vLu8vLy9vby8vb6+vb/Bv7++wMDAwcHCwsOEwhXBwcHCwMDBwMHBwMHCw8LDw8PCxMSExTXGxsXGx8bHyMjIx8nIyMjHx8fIx8jIycjHyMfHycfJxsfGxsfGxMTDwsHBwcDAwcDAv7/AwYTEgMPAvr28u7u8v83KxcLBvr7BxMC7tLKys7Oys7Kysa+urq+trKyqqamoqainp6ampaSloqKhoaCfnp+enp2dnJybmpubmpiXl5iYmJmbnZ+jpaanqquvu8zb6e/w7uzo49nX3NvPvrKwwtDRzcq/ubWxsra7wsnR1c7CvsHExsK8gLaspKWtsri3tK+knZ+fnJWOh4OHhYmOkpGLgvj2gIeMk56dmJqZl5CNhf7y7u/u9vz5goiA/oOJjpGVmZuZl5eZl4uA/Pv//YKEgP3+/ff4hImJjYuPmZmWko2KhYSCi5GUl5aSkpKPg/369vn6iJCVnaSnp6aoqaqpp6ainpqXXJGQkZSYmZmam5qWk5GSkpGMh4mNk5ebnJyenp6cmZiVkpCOi4mD/vv8/oOHh4aC//379/Pu7ero5ebo7Ozr7O3t6+rn4+He3d7d2drX1M/Iw8O7t7i4uLu8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hkiGSYZKhEsCTEuETIVNhE6ET4RQg1GEUhtTUlNTU1RUVFVVVVZWVldXV1hYWFlZWlpaW1uEXCldXl5eX19gYGFhYWJiY2RkZWVmZmdnaGhpaWpqa2xsbG1tbm5vb3BwcIRxRHJzdHR2dnd2d3h5eXp7e318fX5+f3+BgoGCgoKDhIWFhYeHiIiKioyLjI2Njo6Qj5GRkZJJSkpKS0xMTU1NTk5PUFBQhFEvUlNTU1RTVFVVVVZXV1hYWFlaWVpaW1tbXF1eXV5eXl9fYGFiYmJjZGVlZmZmZ2eFaCJpaWppaWlqaWtrbGxtbW5tb25wcHBxcXJycnNycnNzdHR0hHWEdoJ3hHYUd3d4eXh3eHh5eXp6enl6e3l7fHyEfYJ+hH0DfH18hHuCfIR9DX59fn5/f35+gH9/gICEgQWAgYGAgYSABH+AgYGEgEOBgYKCgYGBgoCAf359fHt7e3x8fH19fHx8e3p5en6CjaS0sZ+KgX19fX59f4mMlpCRhoF/eXRydXuCf3p4dHFvbm5uhWsHaWhnZ2VkZIRjFWJiYWBhYWBgYF9fX15dXVxcW1tZWohZaFtfY2ZoZ210eYGMmqq+wr+3s7i+tqORfnyEjIx/d3t3cG94gHx5eHd7dXqEgoiQmZugp7S5saegoaCcm5iSioR8altZWFhXUkuQjIiFhY1NUVNTWlmWjo6LkU5PU1xgZWdeVZeWm05UhFaAU1RXWFhWoZmYlZxVXGJhX1pdYGNgW1Olm5SJiY2PjIyQmJhTW1ickISBfnt5e36BipicnZ2kWWNud4CIjIyMhXt3c3JybGVjXq+rXWZtb25ramhmZWNgX19iZmttcHFycnFwbGlmZWRhXVlXrFhZWlirpZ+cnZ+dmpaVl5iYl5UglZORj4yJhIOAgH5+goSCgH5+enNtZl9bXWdraWhoZ2ocwMHBwcPExMHBwcTDwr69vby0q6Shn52cm5ucm4eZCZiXmJeXlpaVloSVDJSUlJOUlJOTk5STlIaTAZKEkwWSkpKRkomRjZAQkZCQj4+Qj5CQkI+Qj4+PkIaPhI4Ij4+Pjo+Pjo2HjoSNA46NjISNAYyIjQWMjY2Njo2NAo6Nho4Bj5KOA4+OjoSPAY6JjwiQkJCPkJCQj4uQBJGRkZCJkQSSkpKRh5KFkwaUk5OUlJSFlQOWl5aFl4WYhJkNmpqam5ycnJ2dnp6en4SggqGEogGjhKQ+paWmp6enqKioqaqqq6usrK6urq+wsLCxsrKytLS1tba3t7i5urq7vLy9v7/AwMLCw8PEw8bGx8fIycrKy8yEzYDOz9DR0dPT1NXW19fX2drb29zd3d/f4eLj5OXm5+fn6Onq6+vt7vDw8fLz9PT19vf3+Pn7+/3+/4CAgYGCg4SEhIaGhoeHiImJiYqLjIyNjY2Oj46QkZKSk5OTlZaWl5eYmJiZmpubnJydnp6foKGgoaKio6SkpaeoqKeoqampqxGrrKytra6tr66vsLCxs7O0tIS1B7a3uLm5uLeFu4S8A728vYS+gr+FwDTBwcPDwsLDw8TFxcTExsXGyMfHyMjHx8jJyMfIx8fHxsbHyMnIycjJycrKy8rLy8zLy8vMhs0BzobMBc3NzczMhc2AzMzNzs3NzMrKycrJx8fFxcbFxsfHx8bDw8TEw8fK0ebz8eLQx8TEw8TCxszP19TUycXDv7y6u7/FxL67uLa0srKwsK6urq2tq6qpqKempaSlpKOio6OioqGgoJ+enp2dm5uamZmYl5iYl5aXlpeXl5qgoaSjp66yusbV5fT18euA6O7y6tjGtbW9xcK2sLOtp6ewtbGtra6wrLK3t7zEys3S2uPm4NXQ0tHOzsrEvLaum4+OjIyKhoD49PLu7/eBg4SGjYr59PPw+YGBhI2Sl5eOg/j5/ICFhoWFhYKDh4mHhP729fT7hIuQjoyHio+QjYeA//Tt5OPm6eXk6fH0gYd7hPTn3drY1dTU19zj7/Hz8vuEj5mgqrC0tbKrop6cnJuUj42H//2GjpSXlZOSkI6Ni4mHh4mNkZSWmJiZmZiUkZCOjIqHgoD/gYOEgP358/Dx8vDs6uvr7e3s6+no5OPf3NjW09LQ0dTY19TU1M/Hwru0r7C6v768vLq+/3//f/9/wn//gP+A/4ABgIZ/hoCFf4mAg3+MgIV/jICMf4OAkH+TgIJ/oYABf4SAr38CAgQAGEVEREVHR0dFQDw+P0BDQT49ODItKiknJoUlhiSEI4giCyEiISEgISEgISEhhiAFISEgICGJIAMfICCIHwEghh8BIJQfER4eHx4fHx4eHh8eHx4eHh8fmx6CH4YeAx8eHpQfASCGH4UgAR+RII0hiSIDIyIijiOJJAMlJCSEJQcmJSUmJiYlhCaFJ4UoAykoKIQphSoGKyssKywrhCyGLQ8uLi4vMC8wMDAxMTEyMjKEMwY0NDQ1NTWENhE3Nzg4ODk5OTo6Ojs8PT0+PoQ/BUBAQEFBhEILQ0NDRUREREVGR0eGSCRJSkpLS0xLS0tMTU5OTk9PUFFRUlJTU1NVVVVXWFdXWVlaWlqGWwhdXVxdLi8wMIQxBTIzMjM0hzWCNoQ3DDg4OTg4OTo5Ojs7PIQ7Gjw8PT0+Pj4/P0BBQkJCQ0JDREVGRUZGR0dGhEc4SEdHR0ZISEdHR0hISUtKSUpLSkpKS0tLTExMTU1NTE1NTE1OT01OTk9PT01OTU5OT05PTk5OT06ETwlOT09QT1BRUVKFURlPUFFQUk9PT1BPUFBPUVFQT1FRUlJTUlJThVQLVVZUU1RSU1NSU1GEUjlTUlJUU1VVVFVUVVVUU1RSUVJTUVJRU1ZWVVVSU1BPUFBRVFpeXF5gXltYWFdUU1VXWWmCd3FlWVGEUAlTUFFWVE9OS0mFSB9GRkRDRERDQUBAQD8/QD8/QEBBPz9APz8+Pjw8Ozo6hDmAOjs7PDs6Ozs9Pj5AQ0lKUFVmdoKOm5uVjZCWhm9cU1ZZZG5zc3d5c2dfW1dZWldaXlxgc5Gfo6GbkpKamJugqrS1sKaXiYJ5ZlJJREE8OTZfXF9jOTw3OjxJX1tFOjk8O2pkajo/Q0VBPXNwbmdraGVyPT5APz9AQ0NCQXxBRUmATU9OUVRWUkdCfmhWU1FQUVVXWFxdXnCBeVVKSklNTlFZYmtxd3l1dX5FUFVWYm95fX18dXNxbWtoYVhOinp2g01XW15eWlVOTk5MTE9SV1teYWJjYmFeXFpYVVFMSIuHhoeGf3dyb29wcHFxcXJydHJwa2hnY2JfWU9OUFFQUFYTWFlYWFRMSUdFQkA/QkdHRkVERhhramlqa2traWRgY2RlZmRiYVtWUk5NS0qESYZIhEeERgJFRoZFhkQIQ0RERENDRESHQ4pCBUFCQUJCmEEFQEFBQUCEQZhAAT+dQAJBQIRBAUCPQQRCQUJBkEKLQwJEQ4hEj0WHRodHiUiFSQJKSYVKhEuFTIVNhE4DT05PhFCFUQZSUlJTU1OEVINVhFYRV1dXWFhYWVlaWlpbW1xcXF2EXiNfYF9gYWFiYmJjZGVlZWZmZ2hoaGlqamtsbGxtbW5ub3BxcIRxRnJyc3R2d3Z2d3d4eHl5eXp6ent7fH1+f4CAgoKCg4SEhYaHh4iJioqKjI2NjY6Pj4+QkZKTkZNJSktLTExNTU5OT09QUFCEURNSU1NTVFRVVVZWVldXWFhZWlpahVswXF1dXl5fX2BhYWFiY2NkZWZnZ2hnaGhqaWlqa2trbGprbGtrbG1tbW5vb29ucHFwhHIFc3N0dHSEdYJ2hneEeAR5eXh5hnoBeYR7Cnx7e3x7fHx+fX6Ff4Z+BX19fn5+hn8BgIWBGoKCg4KDgoOEg4OCgoOBgYKBgYGAgYGCgYGDhIIwg4KDg4KBgYGAf35/f3+AgYKCgH59fXt7fHx/hIeDhoiFgoF/f3x8fX5+jqWYlYl+hHcednh2dXt4c3Nwb25tbWxtbGpqaGhnZmVlY2NiYmJjhGIPYWBgYF9fX11cXFtbWllZhFqAW1pZWVpbXFxeX2Rma29+jZehra2poaKpoIt5bXByeoKJh4uOiH52c21wb25wc3F0gZunrqyqoaCopaestLy+urOmmpKNfGpfW1dUUU6TjpCQTlFPUFFbcW5aT05RUJeRllBVWFtXUp+bmpWXlJCaUlJUVFNUV1dWVKJTWFteYF+AYWVmZFpVpZGBfn17fH+Bg4WIiZmnn4B1dXV3eHqBiI+WnJuYlqBVX2Nlb3qDh4mFf359eHd2b2ZdrJ2apl5naWpqaGNeXl5cXF5hZWltbm9wcG9samdmY2BcWayoqKmnopqVlJOTk5SUlJWWl5aUkIyLiYaDfXV0dnZ0dXp9fX0QfHhxbm1rZ2VjZ2xta2ppax+/vr2/wMC/vbi0t7i6u7m2tK+ppKCenJubmpmZmZiZhZgBl4SWApWWhJUFlJWUlJSEkwyUlJOTk5KSk5OTkpOHkoaRAZCFkYqQBY+QkI+QiI8DkI+QiI8Cjo+Ojo2NAY6RjYKOiY0Kjo2NjY6OjY6OjYuOAY2EjgWPj46OjoePB5CPj5CPj4+MkAmRkJCRkJCQkZCHkQaSkZKSkpOEkgKTkoeThZQHlZWVlpWVloWXgJiYmJmZmJmampuam5ucnJydnZ2enp6fn5+goKGhoaKio6OkpKWlpqanp6epqKipqqqrq62trq6vsLCxsbGys7O0tLW1tre4ubm6uru8vb2/v8DBwsLCw8TFxsfHyMjJysvNzc3Ozs7P0NHT1NXV19fX1tjZ2trb29vd3d7f4eHiLuHk5efo6Orq6+3t7e/w8fLz9PX19/j5+vv8/P39/v7+gIGDgoOEhYWGh4iIiYmEijuMi4yNjo+PkJCQkZKTk5SVlpaXmJiYmZmbnJucnJ2en6CgoaKjo6OkpqanqKmqqqqrrKyrrK2urq+vroSxhbMLtLe2t7e3uLm5uruEvB69vb6+v7++vsDBwMDBwcLCw8LCwsTExMPExcTFxceExg/Ix8jJysrKy8vKyszLy8uEyhDLy8rLzMzNzMzNzc3Oz8/OhM+C0YTQhc8Qzs/Nzs/Ozs/Ozs7Nz8/Qz4TOUs3MzMrKysnJysrMysnKyMbGx8XFx8vOy83PzMnHyMbEw8TExdLo3NjMw769vry7vbu6v7y4t7WzsrGxsrCvr6yrqqqpp6ampqWko6Sko6KioaGEnwienJubm5mZmYWYgJeYl5eXmJiZmp2foaWqucfQ2uTj3tjb4NS/raSnq7S7vr/BxL60ramkp6akp6ioqrrR29/d2NDT2tbW3ebs7Ojh18rEvK6ck4+MiYWD+vf5+oSGgoOEj6OeioCAg4H79/mBhoiLhoL//Prz+fXz/IGCg4ODhIaGhYL/goWJjI6NT4+Tk5GGgvzp3NnZ2Nnb3d7h4ePx//bY0NDP0tPV2uLo7vTy7u73gImNj5ijq66urKempKCfnZeQh//v7PeGj5GUkpCLhoeGhYSGiY2Rk5SElj2UkJCOjImFgv77+/z49Ozn5ubn5+jo6Orq7Ovq5OHe3NvX0MjGyMnIx87R0dHQzMbCwb+7ube6wMG/v73A/3//f/9/w3//gP+A/4CEf42Ag3+GgIh/ioABf4yAoH+TgIR/noC1fwICBAAYPT9BQkVGRkM9OTc3Njo8OjYxKykpKCcmhSUDJCMkhiMCIiOGIgohISAgISEgICAhhyAEISAgIYggBB8fHyCXHwEehR8FHh8fHx6FHwQeHh4fhx4BH4UeAR+MHgEdhR4BHY4eAR+FHgQfHx4elh+EIAgfIB8fHyAgH4QgCSEhICAhISAhIIchBCIiISGEIgEhhiIDIyMihyMXJCMjJCQjIyQkJCUkJCQlJSQlJSYlJSWGJoYnhygDKSkqhCmDKoUrhiyDLYQuhS8RMDAwMTExMjIyMzMzNDU0NTWENgg3Nzc4ODg5OYQ6BTs8Ozw9hD4OP0BAQUFCQ0NDRERERUSERQtGSElOSkdHR0hJSYRKhEshTE1OTk9QT1FRUlJTU1RVVVZXV1dYWVlYW1pbWlxcXF4uhC8PMDAwMTExMjIzMzQ0NDU0hTUHNjc3Nzg5OIU5DDo6Ozs8PD08Ozw9PIQ+Bz9AQUFCQUOERAtFRkdFR0dHRkdISIVHA0lISIVJCUtKSUtMS0pLTIVNIExNTk9NTk1PT09RT1BPT1BRUFBPUFBRUFFQT09PUFFRhFAJT1FQUFJRUVJShVEGUlFQUFFShVGEUoVTJVJTVFVVVVdXV1ZVV1ZTVFRSVFJRU1NSU1NSUlJTU1VVVlZWVVWGVERWVlVWVlZUU1RRU1ZUU1RVWVhZWVhYWFdWWF9bXnmBcGZaV1RQT09QUVBOTE1LSklJSUpISEhKSEZFREVERENCQkA/QIQ/gEA/QD8/P0A+PT08Ozs6Ojk6Ojo7Ozw7Oz07Ojo7O0BNVFVOUFdbaHV7dHJvbGRZTkhBRFJiZGNiYFFISUtLVmNpcnuFh4uTjYKEjpaUlJCOl6Grr66ppJmSi4B1al9TSj86NWU1Oj9HSEZFTVFRSEE8OjlrY1xgamlnY2NjWlZSgFVZWml0PD52dnE8SEpGQEBBRElLTUxMTUtEfnloWEtHRkdISUpIR0ZHVVdJREZFSU9Yand+R1BMRURFSkxPWWNtdHh8fn59enh1b2dbUUl8c3SKUFhgYF9YTUmMhkZKTFBSVVdaXl9fXVtZV1RSTUhFhYaEf3hya2ZnaGpqa21uJW9vbGhhW1laWVVTTUdITExOUVFTVVRRTEZEREJAPkBEQ0E/PTsbY2ZmaGlqamdfXVtbW19gXVpWUE1NTUtKSklJhEiFR4VGhEUDREVFi0QCQ0SKQ4pClkEBQIZBBEBBQEGIQAFBsUABQYRAAUGEQItBA0JBQoRBAkJBjkKNQwJEQ4REkUWGRgNHR0aGRwdIR0hISElIhkmGSglLSktLTEtMTUyFTYVOgk+EUIRRhFKDU4RUhFUcVldXVldYWFlZWVpaWltbXFtcXV1eXl9eX19gYIRhGWJjY2RlZWZmZ2hoaWlpamtrbG1tbW9vb3CFcThyc3R1enZ1dXZ2d3d4eHd5enp6e3t8fX9/f4CBgoODhIWFh4iIiYmJiouMjY2Ojo+RkZGSSUlKSYRLCkxMTU1OTk9PUFCEURRSUlNTVFRUVVZWV1dYWFhZWlpbW4RcK11dXl5eX2Bg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TUtMTU5NTk1OTU5PTk9OTk9PT4ZQGVFSUlRTVFJTUlJRUVJSUVFRUlFRUFJRUlCFUhlRUlJSUVJRUVFSUlNSU1NSUlJTVFRTVFVUhFUMV1ZXVlhWVlVVVFVVhFOEVGNTUlNTVFVVVlVWVlVWV1dYWFZXVlVWVVZWVFRVVVZVUlNTU1VWWFdXVVdWVVlfXVpcWFdVU1NRUVBSUU5MSUlJSEpJSUhHR0dGREZGRUVDRERDQkBAPz8/QEE/QkFBQEA+Pj2EPIA7Ozo7Ozw8PD09PDw7ODc2OkA8OjpBRktMTVNLUFlfYl9SSUNEQ0JDRUtLQTs6PURMZYOVrq+gl5ONgHV3ipGQh4KAgIORpLK1saiZinxwZFlQQ0JCQURFR0xPVFRVUEhCP0Q+PG1lYFtmamZbV11bT0tMT1hfaGtkWVhcZWVubRNucXN0dXt6d3t2dm5iYWBZTkZEhEWAREJBQUBDREFCQ0ZOaEtbZ3Z0aF5aWlZUVl1fYGRtdXt8endzcGtnXlZQSod3bHlJVVpcWFFJin9/ikpLS01SV1pbW1hWU1BOTUhGhYKCfnt1b2pmZGZoZ2VkYWVmYmBdWldTUlJQT0tKSUpLTE1OTElGRkRCPTw6PD9APjs3NjYdXmJoamxraWZiXVpXWVlaWFZWUk1MS0pKSklISEiGR4VGh0UKREREQ0NERERDRIRDBERDQ0OOQoRBAUKPQQFAiUEFQEBBQUGPQAE/ikAGP0BAPz8/iUADP0A/lkAFQUFAQUCPQQhCQUJBQkJCQY1CikOGRARFRUREikUCRkWHRoVHBEhHR0eESIdJhkqFS4NMiE2ETgFPhlCCUYVShFOCVIRVBVZWVldXhFg6WVlaWltbW1xcXV1eXl5fX19gYGBhYWFiY2RkZGVmZ2hoaGlqamprbG1tbW5vb29wcXFycnNzdXZ3d4R1fnZ3d3d4eHl5ent7e3x9fX+AgIGCgoOEhYaGh4iJiYqKjIyNjY6Oj5CQkpKRSUlKSktLS0xMTU5OT09QUFBRUVFSU1NTVFRVVVZWV1dXWFhZWVpaW1tcXV1dXl1fXl9gYWFiY2RkZWVmZmdnaGhoaWlqaWtqa2tsbG1sbW5vb4RwBXJyc3NzhHQBdYV2g3eEeBN5enl6e3t7fHt7fHx9fn5/fn99hX6Hfw9+f3+AgIGBgoKBgIGBgIGFgouDB4WE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U1RVV1ZWWIVWWldXVlZWVVVWVlVTVFNVVFNSUlJTVFRWVlVVVlZUVFVUVVVWV1VSUlFQUFBSUU5LSklJSElHR0VGRUZHRkhHRkdJR0VEQ0JBQUJBQUFCQkFAQD9APz4+PTw7O4Q6gDs/REM/PDk3NjY1NTQ1NTY3ODg6PklNT1VVV1paW1BOXGBJQkZCOjc6RVB3o7K+vK+vr6GJeXB5f4KEhYR/go2grK6omoh5amBYU0xGSk1TVllkbm1tbHBuZ19TRz5jZGNeWFtaWVZNS05MSUhKTE9QVVhPSk9UTlJbYmRobW96c35/d25tY1tSTkhGRUNCQ0FAQD8/PkA/P0BAQUZjVGJ7ho2JfmlRSkOESFFTUVFWYGhxcnBsZmJbWVhXVVJNSEdJUFdXWFJKiX57ik1RUU9PUVRUVVJPS0aIhYB8dnFwcGtnZ2JdXFxeYmJhXVxcXVpVUE6ETBpNTUtNTElIRUJAQUBBQDw6PDw6Ozo6ODY4OB1eYGNmaWlnZmJfXFpWVVVUUVBPTkxMSkpJSUhISIVHhkaERYVECENERENEQ0NEiEMGQkNCQkJDh0IGQUJBQkJClUEEQEFAQZdAAT+IQAY/QEBAPz+EQAc/QD9AQEA/mECTQQdCQUFCQUFBikIEQ0JDQohDh0QGRUVEREVEh0UDRkZFh0aFR4dIA0lISIdJhEqDS4ZMhk2ETgVPT09QUIRRhlKEU4JUhFUHVlZXV1dYWIRZWlpaW1tcXF1dXl1eXl5fX2BgYWFhYmJjZGRlZmZmZ2dpaWpqa2trbGxtbm5vcHBxcXJyc3R1dXR0dXV1dnZ3d3d4eXp6e3t8fH1+f3+AgYKCg4OEhYaIh4iJiYSLR4yNjo6PkZGRSJJJSkpLSktMTExNTk5PT09QUVFSUlNTU1RUVVVWVlZXWFhYWllaWltbXFxdXV5fX19gYGFhYmNkZWVlZmZnhGghaWlqamtrbGxsa21ubm9vb3BxcXJycnNzdHV1dXZ2d3d3hHgMeXh6enp7ent7fHx9hH6Cf4WBAYKEgQOCgYKHgQaCgYKCg4SFgwGChIOEhAyFhoWGhoeGhoeGhoWEhgmHiIiIiYiJiYiEh4KGhIUMhoaFhYSFhYaGiIeHhYYFhYWFhoWEhICDgoKCgYGBgH9/gH+BgoCBgICAf35/fX99gH99e3p5eHd4eHl1c3FwcG9vbm5tbWxra2xsbWtqbGppZ2ZmZWRjZGNkZGRjYmFhYWBfXl1dXFtbW1paW15jYF5aWVZVVFRUU1NTVFRVVlZZYmdob29xdHR0a2ZyeWRbYFxVUVRdZYCFrLzFxrm5urCdjYSMkZOVlpWQkZustrq2rZ2MgXZwaWNdYGJma212fn1+foGAeXJoXFSSkpGOhoqLiYR9fH18enl6e36AgoV+eXx/e36GjI2QlZWho6Sdl5WNhn97dXNxb29wbm1sbGtra2xsa2xscIhhboKOlJCGdGFbVqlYYV1jYmFlbnV8fXt3c3BraWhmZGJdWFdZXmVmZWBZqaGfrV1fXl5eYGNkY2JfXFiqqaSgmpSUlI+Mi4aCgYGDhoiEgoGBgX98dnVzcXFyc3NxcnFubWpoZWZmZ2ZiYWKFYARdW11eJ7O0t7q+vbu6t7Swraqnp6ejoqGgnp2cmpqamZiYmJeXl5aXl5aWloSVCpSUlZSTk5OUk5SJkweSk5KTk5KThZKHkQiQkZCRkJGRkY6Qho8BkImPBY6Oj46Pj46bjQGMm40BjoSNA46OjYqOA4+OjoyPBZCPkI+PipACkZCGkQSQkJGRh5KHk4aUhpUKlpaWl5aXl5iYmIWZCJqampubm5ychJ2Anp6fn5+goKChoqKjo6SkpKWlpqanp6eoqKiqqaqrrKysra2vsK+vsLGysrO0tbW2tra4uLi5urq8vb2+vr/AwcLCw8TFx8fIycnJysvMzc3Pz9HR09TV1NTV1dbW19fY2drb29vc3d/e4OHi4+Tk5ebp6err7Ozu7/Dy8vL09vaA9/f5+vv7/f2A/4CBgoKDgoOEhYWGh4iIiYmJi4yMjI2Oj5CQkZGSk5OUlJWVl5eYmZmampucnJ2en6ChoaKjo6SlpqanqKioqqqrrK2tra6ur7CxsbKysrO0tra2t7e5ubm6uru8vr6/wL6/v8HBw8HCwsPDw8XFx8fHyMjIyssLy8zMzc7Ozc3Ozs2FzjPPz87PztDP0NHR0dDR0tHS09LS0tPS09PT1dTU1NXV1tXW19XV1tXW1tfX19nZ2djY2NeE1hrX1tXV1NTV1dXU1NPV1NXU1dTV1NTV1NLT1IXSAdGFzizNzczLysnJy8vLysrJx8fIx8fGxsjIxcLDwsHAvr+9urm4uLa2tbS0s7Gvr4SwgK6vr62rqqiop6enpaWkpqSkoqGhoaCfnp2dmpqYmZqZmJugnZuXlZSTkJGQj4+PkJCRkpKWnqGip6eqq6yroqCtsJqVmZSOi46Vn8Lj7ff27Ovr3s2/uMDFx8nJxsPG0eDo6eTZy72yqqOdl5GUl5ufoKuwr66wtLGqpJqOhvX3LPXw6+/t7Ojg3uDf3dzc3d/f4uXf2tzf3N7m6ezs8/H8//748vDo4dvX0tDOhMwDycnIhsdvyMjM442arLW6tqycioWA/IKLjIuLjpedoqOin5uXk5KQkI6KhoKBgYiMjo2Jgvvx8P6FiIeGhoiLjIuKiIWA+/n18uvo5+bh3d7a1tTT1drb19TU1tXU0MvIxsXFxsbHxMXFwsK/vLi5urq6trS1hLQFs7GtsLD/f/9//3++fwKAf/+A/4D/gJOAv3+LgAF/noCEf42AuX8CAgQAHjo5ODg5Ojc3NjY5NzMuKykpKikoJyYmJiUlJCMjI4QiASOEIgghISEgICEhIZMghR8BIJQfAR6FHwceHx8eHh4fnh4EHR0eHYQeiB0BHoYdhh4BHZoelB8FICAfHx+KIAohICAgISEgISAghCEGIiEhISIhhyKJIwIkI4ckhyUFJiUmJSWEJgQnJiYmhSeFKIUphiqEK4QshS0HLi4vLi8vL4UwAzEwMYQyBjMzNDQ1NYQ2hDcKODg5OTk6Ozs7PIQ9BT4+Pz8/hkEEQkNDRIVFIEdHR0hHR0dISUhISUlJSktKTE1NTk1OT1BPT1FRUVJThFQZVVVXV1ZXWVlaWVpaW1tbXS4uLi8wLy8vMIQxCjIyMjM0NDU1NjaENw04ODg5OTo5OTo6PDs8hj0BPoQ/Q0BBQEJCQ0JDRERFRUVGRkdGR0dISEhJSEhISklMS0tLTExNTExMTU1NTE9QT09OT1FPT1BOT1FRUlJRUVJTVFRVVVaFVxJWVldYWFhZWVdXV1ZXVlVVVFWEVIZVAVSHVT5WVVVUVVZVVldXVlVXVlVWVlVWV1dYWFdYWFhZWFdYWFhXVlZVVVdVVFVVVVZWVldXVlVWVVdWVVZVVVZUVYVUDlJTU1NQUlNVVldYVldWhFQ8VVVXVldYVVNSUVFPTk9PTEpJSEhHR0ZFRUZISElKSkpJSkpNUk5PTEdCQUFCQkJBQD8/Pj8+PT08Ozs6hDkOOz5CPjw6OTg3NjY1NTWENlU4OT5HTkpAPkdMS0NHVFBDODc5OTY1OEx5qbe6wcpkwrCPi4d9eH2AgIKIjpOgp6SdlIZ7bFtSUVBUW15iaXF6gHx4dHFuaWVhWFFIOVVMSEhMTlFJhEUfRkRGRUZIS1VXUVlgYV5fZ25vc3Zzbl5VUlJMRUNBQIRBL0A/Pj09PT4+Pz9CREl3V2qCkI+HfGhMfm90h0SGg0RKUlRUVWJoZmFYU1FUV1hYhFYLV1dZW1dOjYB7hEiESzRMTlBLi4N4cW9ub21paGtpYVxXVlRVW15dXFpYVlRTUElFQkFBQ0lNS0tJRkI+PD4+PUBAhD8IPjs8PD09PTwUX19dXl9fXVxaW11bV1JPT05OTUyFSgRJSEdHiEaGRYhEhEMBRIlDjEICQUKTQYJAhUGGQAFBm0AQPz9AQD8/P0A/QD8/P0BAP5NAAUGHQA1BQEBBQEBBQUFAQUFAhUEBQoZBBEJCQkGMQgJDQohDiESMRYlGhEeFSARJSUlIhUmHSgRLTEtLhUyFTYROhE+CUIRRhFKDU4RUDFVVVlVWVldXWFdYWIRZB1pbW1xcXF2EXhlfX19gYGFhYWJjY2RkZWZmZmdoaGhpaWprhGwObm5vcHBxcXJyc3N0dXSEdSd2d3d3eXl6ent7fHx8fn9/f4CBgYKDhISFhoeHiYiJi4yLjIyNjo+EkBOSSUlKSkpLS0xMTU1OTk5PUFBRhFIIVFRUVVVWVleEWAZZWVpbW1uEXR5eX15gYGFiYmJkZGRlZmZnaGhoaWlqamtra2xsbW2EbiZvcHFxcXJzc3N0c3R1dHd2eHh5eXl4eXp7enp6e3x7fX19fn+AgYSCCYODhIODhISFhoSFhISIgxmEhIWFhoWFhYSFhoaGh4eGh4aHh4eIiIiJhoiEiYOKhIsIiouKiYmJiIiEhwWGhoeGh4SICIeGhoWGhoeGhIUEhIODg4SCh4EFgoKBgYGEfxqAf4B/gX9+fHp6enh3d3Z0c3FwcG9ubWxsbYVuhG0nb3NwcGxpZWRkZGVjY2JiYF9fXl5dXFxbWllYWVlaXWFdWllYV1ZVhFReU1RUVFVXWGBpZlxaYWdmXmBubF5UUlVUUlBSYYmxv8LIz2fKvKGbmI+Mj5KTk5ifo6y0saylmo+BcWhnZWhucXR7goqQjoqGhoJ9eXZwZ15Rhn16enx+gXt2dXZ2doR1GXh7goN+hIqLiImQlZebnZuYioF+fnlzb26Ebz9tbWtqamlpampra21vcZlldYqWlpCFdl2hlJiqVqqoVlthZGVmcHRzbmZiYmRnZ2dmZWVlZmVoaWVdq6KfqFmEW0BdXmBcr6aclZGRkpGMi42NhIB7enh6gIODgn98e3t4dG5raWhnaW5xcXFvbGhlYmRjZGZmZWRkZGNgYmFhYmJhDrSzsrOysrCvrq+vraqmhKAMnp6cm5uampmZmJeYhJeEloWVBZSUk5OUj5MEkpOTk4eSApGSjpGNkIWPBpCQkI+PkIaPA46Oj4SOAY+MjgeNjY6NjY6OjY0DjI2Op42IjgePjo6Pj4+Oho+CkISPBZCPkI+PipACkZCIkYeSh5MFlJSVlJSIlYKWhZcDmJmYhJmCmoSbEJycnZ6dnZ6fn6CgoKGgoaKEowqkpaWlpqamp6iohKk+qqqsraytrq2usLCxsbKys7S0tLW2t7e4ubq6u7y8vb6/wMHBwsLCxMXGxsfJysrKzM3Mzs7P0NHR09PU1NWE1hzX2Nra29zd3t7f4eHj5OPl5ebo6Onq6+3t7u/xhPNq9vb39/n6+/39//+AgYGCgoKDg4WFhoaHh4iIiouLjI2NjY6QkZGSk5STlJSVlpeXmJmampqbnZ2dn56foKGio6Slpaanp6ipqaurq6yurq+vsLCwsbKzs7S1tba3uLm5urq7vLu8vb7AwITBBMLCw8OExQrGyMjJycnMzM3Nhs8K0NHQ0NHR0tLT0YXTgNLR0NLT09TU1NPV1NTU1dbV19bY19bW1dfX1tna2dnY2djY2NnY2drb29ra3Nvc3Nrb2tna2dnZ19jY19bV1tTW2NfX2NfX1tXW1NTT09TU09LS0tDQ0c/Ozs7Ny83NzczOzczLy8rKycnJyMjHycfFxcPDwcC/v769ubq3tra0NrSzsrKytLSysbKxsLGytrSyr6qopqWmpqWko6Oin5+fnp2cm5mYmJeXmJmbnJmYl5WUk5KRkYaQd5GTlp2inpWVm6Cel5umoZWOjI+Oi4mMnMPn8fT6/oD77NLPysPAxMTFxs3R1N/k4dvTy7+zo5uamJyipamutb7Bvrq4trOvq6egmo+C6uLe3uDh493Z2dnY2NfW1tfX2+Li3eTp6Obo7vLz9/j18uTe29vUz8zMhcsvycbHxsXFxsXGxsjJzfSQoLK+vLWtnYb16e/+gP36gIWKjYyOl5ualY6Mio2QkJCFjk6NkJGNhv7z7viBg4SDg4SGh4T/9u3n5OTk4t/d4eDY1M/OzM3T19bV09DPzczJwb69urq9wsXFxcLBvLi1t7e4u7q4uLi5uLS2tbW2trX/f/9//3+/f/+A/4DmgAGBroC9f4mAhH8DgH9/m4CEf4mAvH8CAgQAFDo4NzY1NDEvLS4uMTAvKycoJykphCcDJCMjhSICIyKIIQMgICGOIAQfHyAghB8BIIofAR6FHw8eHx8fHh8eHh4fHx8eHh+gHoIdhx4WHR0eHR4dHh0eHh0eHh4dHR0eHR4eHYkeAR2HHgQdHh4fhh4DHx4fhR6OHwYgICAfIB+QIAIhIIohiiKGIwQkIyMjiCSHJQImJYQmCicnJyYnJyYnJyeFKIYpBCopKiqEK4YshC2DLoUvGDAwMDEwMTEyMjIzNDM0NDQ1NTU2NjY3N4Q4Ejk6Ojo7Ozs8PD09Pj0/QEA/QIRBNUJDQ0NERUVFRkdHR0hISEdISElISElJSktLS0xNTk5PUFBPUFBRUlNTVFNTVVZWVldXV1hYhFoEW1pbXYQuAS+EMBYxMTEyMjIzMzM0NDQ1Njc2Nzg3ODk5hToDPDs8hT2EPg5AP0BAQUFBQkNEREVFRYRGEUdHSEhISUhISUlKSktLTE1MhE1ITk5MTU1OT1FRUFBSU1JSU1JSUVJSUlNUVVRXWFdZWFlaWllYWFlYWVlaWllaWFlZWVhZWVdXWFhXWVhYWFdYWFlYV1hYV1dXhFgBVoRXBVhYWFZXilgDWllbhFoNWVpaWVlXVldWVVRXV4RWTldWVFdWVVVVVlVUVVNUVFNUVVZVU1RTU1VUVVRVV1ZWVVVZWVdWVlhXWVdYVVJSUE9PT05MS0pISEZGR0VHSEpKS0pKSUlISEpNT0lGRYREBkNEREJBP4Q+FTw7PDs5OTg5ODk7PD0+PTs6Ozg4OIc2gDg5Ozo5Nzg9QkE+PkBDPDU2Ojw5Nzc7XJOssr7IyMO2pqWmnpCBdm5yd3qAjpucmpaSiX1oWFNXYGdscXh+f393b2VeW1hZWVVNRj1fTkZFRUZKR0ZERURDQkRERUdKTlRRUllWU1NfXmFjXFBKRUNDQkJAQD4+PTw8PT09PDs7KDw9PUBHT1VfRV5sfIuKf3BfR3hsY2pvcnR8goGChElPVlpYUkxKTlWEVlFXWFVQUFJTUU2MeG11fohGiYyPioV3a2lpbHBycW9saWNgX1xXU1NUVlhaW1lYVlVUTURBRERNUlNQS0Q+Ojo4OTk4Oj5BQkFAPj5BQkJBPz0fYV5cW1lZV1VTU1RWVVNPTEtMTk1LS0xKSUhHR0dGR4VGhkWIRIxDAkJDh0IBQYdCjkGCQIRBAUCFQQJAQZBAAT+EQAE/iUAJPz9AP0A/QEA/hEAFP0BAQD+XQIJBhUACQUCOQYRCgkGQQgJDQoZDAkRDh0SJRYpGhEcDSEdHhEgISUhJSUhJSUmESgZLS0tKS0uHTIRNhU6DT4VQDVFRUlFSUlJTU1NUVFSEVUNWVldXWFhXWFlZWVpZW1tcXFxdXV5eXl9gYGBhYWFiYmNjZGRlZmZnZ2hoaWlqamtra2xtbW1vcHBwcXJycnRzdXV1hHY3d3d4eHl6e3t8fH1+fn9/gIGBgoKDhIWFhoeHiImKi4uLjI2Nj4+PkZCRkklJSkpLSkxNTU1OToRPNVBRUVJSU1NUVVZVVldXWFhZWVlaW1tcXV1dXl5fX19gYWFiYmNjZGVmZmdoaGlqamtra2xshG2Fby9wcXJzc3RzdHR1dXZ2d3h5eXp5ent7fHx8fX18fH1+fn+AgIKCg4SFhYWGhYWFhoSHAomKhIcNhoeGh4aHh4eIiIeIiYaIDIqJiYqLioqJiouLiYSKDYuLiouKiouLjIyNi4yFjRaMjY2NjIuLiYmIh4eIiImJiIiJiYiIhYcNhoWFhISFhYSEhYSDg4SCSIGCgoKDgoKBgYKDgYCAgIGBgIF9e3t6eXl4dnVzcXBwbm5ubW1ucHFwbm5tbWxtbXBxa2loZ2ZmZWZmZWNhYWBgX19dXVxbWoVZDFpaW1tbWllZWFdWVYZUgFVWWFdVVVVYXl5aWlteWFJRVFZUUlNVbp21u8TO0MvBs7GzraCTjIOFio2Qnamqp6WhmpB/bmhsc3p/hImPkY+Lg3t0cW9vb2tkXlSPfnh2dnd8eXV0dXR0c3R1dHZ4fIF+foWCgH6IiouOh314c3Fwb25ubWxrampramlqaWhod2hpaWtxeH2DVWt3hJKRiX1tWJySipGUl5igpqWlp1lgZmloYl1bX2VmZWVmZ2dkYF9jY2BcrJuQmaKqVqutsa6om46LjI+Tk5OQjoyHg4OAe3d4eXx8f399fXp6eHFqZ2lqc3d4dHBqZWFfXl9fX2FlaGhmZmNjhGcCZGMgtbOvr6ysqqimpqapqKahnp2eoJ6dnJybmZiYmJeWlpWHloOVhZSNkwqSk5KSk5OSkpKRiJKGkQGSiZEEkJCQkYmQB4+PkJCPj5CGjwyOj4+Pjo+Ojo+Ojo+FjgGNhI4DjY6NhI6GjQGOiI0BjpaNAY6GjQ2OjY6NjY2Ojo2Njo2NiY4Ej4+PjouPA5CQj4iQApGQhZEBkoSRApKRhJKFk4iUhJWElgKXloSXgpiGmQiampqbm5ucnISdGZ6fn5+goKChoaKio6SkpKWmpqanp6eoqKmEqj2rrKysra6vr7CxsbGzsrO0tbW2tre4ubq6u7u8vL6+v8DAwsLDw8TFxsbGycnJy8vMzc7O0M/R0tLT1NXWhNcE2Nna24TdgN/h4eLj4+Tm5+jo6enr6+3u7/Dx8vL09vb3+Pn6+v39/v//gIGBgoKDhISFhoeHh4iJioqKjIyNjo+QkJGTk5OUlJWWlpaXmJqampucnJ6dn6CgoKGio6WmpqanqKmpq6qsra6vr6+xsbCys7O0tLW2t7e4ubm7u7u8vL2+v8C/G8HCwsLDxMXGxsfHyMnIycnKy8vNzdDQ0dLR0obTB9TV1NXW1taE1QfW1dXU1NbWhthX2dnZ2tjZ2dva29rb29ra29rb3Nzb3Nvb3Nvc3Nzd3N7d39/e3N7e3d7d3dza2tna2tnZ2NjX2trY2Nra2NjX19XU1tTU09PS09LS0dDPz9DOzs7NzM7OhMwZzc7Ly8rLy8vKycbFxMLCwcHAvry6uba3tYWzgLW1s7S0srGwsrSzrqyqqqmpqaenp6SjoqGgn5+dnJyamZmYl5aYmJmZmpiWlpaUk5ORkZGQj5CQkZKTkpCPkZSYl5OTlZaQjIyPkI6MjY+r1unv9v7/+e/k5OXe08a+uLu/wMTS2drY1tHKwK+hm6CorrO2vMDCwLu0rKajoaGigJ6Wj4Xx4tza2tve2tjY2NbW1dXV1Nfa3N/d3eLf3d3k5+fo4drU0M7OzMzLycjIyMbGxcbFxMPDw8TExszS192BlaGtubavpJaC8+jg5+nt7/X8+Pj6g4iNkZCKh4WJjo+NjY+QkI6IiIuKh4P96uHp8vyA/P3//fns4N3d4uXmNeXj4N/a2NfVz8nMztDR09PQz83OzMa+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XF1dhF4cX2BgYGFhYmJjY2RkZWZmZmdnaGhpampra2xtbYRuW29vcHBxcXNzdHV1dXd2d3d4eHl5eXp7e3t9fn9/gIGBgoODhIWGh4eHiIiJioqLjIyOjo6Pj5CRSElJSkpLTExMTU1NTk9PT1BQUVJSUlNTVFRVVVdXWFlZWVqEWyFdXV5eXl9fYGBhYmJjZGNkZGVmZ2hoaWpra2xtbW1ub26Eby5wcHFycXJzdXV2dnd3eXh4enl5enp8fHx9f4GAgIKCg4KDgoGCgoSFhoeHh4iIhIkGi4uMi4uMhYsFjIuMjI2FjCeNjo2Oj46Oj46Oj4+PkI6Oj5CRkZGQkJCPkJCRkJCRkZGQkZKPkI+EkIKPhI4JjY6NjYyMjIqLh4oYiYmIiYmJh4eGhYaGhoeGhYWEhISDg4KChIMEhIWGh4SFFIaGhYSDg4B/fX17eXl3d3NycXBwhG8kcXZ/dHBvbm5vbm1ramppaGlnZmdpZWRkY2FgYF9eXVxcW1tbh1ptXWRoamFeXltdX2ReWldUVFVTU1RTUlFRUVJSU1RaYF9cYWVucneLn6W5xMDAvbm2r6iZkpKTjoSAgIKGho2UoKiro5eHe3R0cnd/gYB6c21mY2BaVVFPT5uYl5OXioWKkY6Bf3p5ent6dnRycoVwGXFyc3Z6dXR1dXJubWxrampqaWppaWhoaGmEaH1pamtqanB7kFtvf4aGfnNbnZqbm5iUkpWPh4SDg4aKiYmQjouZmaisoqClrVlZWVpZqqitV1amm5CGho6co6Kfm5GIhYaQk5GOioiHg396d3d4e4GEgn59fYCDgX56d3l6enVvbWliXVpdXl5cXWJkaWtrbGppZWRkZGJhXBWrp6elpKShn56hn5+enZuamZmZmJiGlwWWlZWVloWVC5aVlZSUlJOUk5OUipMZkpOUk5OTkpKTk5OSkpKTkpOSkZGRkpGSkoWRFJCRkJCRkZCRkJGRkZCRkZGQkJCRhZAEj5CPkI+PA46Oj4mOCo2OjY6OjY6Njo6OjQGOhY0Fjo2NjY6NjQSMjY2Mio2OjoiPgpCEj4SQCJGRkJCQkZGShJGFkgeTk5KTk5OShpMElJWUlISVCJaWlpeWl5eXhZiFmSeampqbm5ycnJ2dnZ6fnp+foKChoaKio6OkpKSlpaampqeoqKipqaqEq4CsrK6trq+wsLGx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TQufoJ6cm5qZmJiXmIeXiZaGlQGUhJWJlAqTlJSTlJOTlJOUiJMFlJOTk5SHkwSSkpKThJIEk5KSk42SiZEBkIWRBZCQkZCRh5ABkYSQj48Gjo+Ojo+PlI4BjYSOBY2OjY2NiI6DjYWOCY2Njo2NjY6OjYaOgo+HjomPApCPhJADkZCQhJGFkiSTkpOTkpOTlJOTlJSUlZSUlZWVlpWWlpeXl5aXl5eYmJmZmJmFmgebm5ycnZ2dhJ5In5+foKChoaKioqOjpKSkpaWmp6enqKipqamqqqurrKysra6vsLCxsLKys7O0tbW2t7i4uLm5u7y8vL2+vr/BwcLDxMXHycrKhMuAzc7Ozs/R0NHT09PU1dbX2NjZ29ze3t/f4OHh4eLk5uXn5unp6+zt7e/v8PL08/X19/j5+/z+/f+AgICBgYKDhISEhoaGiImJiouLi4yNjo+QkJGRkpOUlZaWmJiZmpubnZ2en5+go6KjpKWkp6enqKqrq6ytra6vsbGxsrO0tbZFt7i3uLq6u7y9vb7AwMPExMXFx8nJysrMzM3O0dHS09XV1dfZ2tvb29zd3t/g4ePk4+Xm5+jn6ejp6Orp6Orr6+zs6+zrhOwn6+vs7Ozt6+rs7Ozu8O/x8PDw7/Lx8vPz8vLw8PDx8vLx8/Hy8fHxhfOG8n3w8fDv7+3u7+/v8O/u7e3r6+vq6ujn6Ojm5uXl5eTl4+Pi4d/h4ODf3t7d3d3f4OHj4uHh5OTi397d3Nra1tXT0tHRzs7OzMvLysjGxcPCv8DAwsrIu7m5t7a0srCwrq2tq6qqqKempqSkpKOkpKOhoqGgoJ+gn5+enp+foISfgJ2dnJycnZyeo6aqn6GqsLK4vLu+x8m7rqKjq6ytpKuhlpKLioqJjqautr7Nz9DX19fc2NHJv73BubCsrrK6wMXO2dvX08/Iwrqyp5qTmZiTj4qE8+zp5OPg4OHm8vXs4drW09PU1dbU09PU1NTV09DPzs7My8vKycnIyMjGxsXEAcWFxIDFxsXGydDS0dLT2uHk5Ofp6+7x8fT5+efi3dDLyM/Q0NTa4NrV0M/Nz9DQ0dLSy8jFxcbIxsLDxcjEvLi3ubi3uL/J1tzczsbCv7/DxMXKz9XY2djW2drW1NTV1dLS09LOysjGxsfGxMC+vLi3ub2/wL+7vLu1raqopqShnZybnAKdnv9//3//f7d//4D/gP+AmoD/f7Z/AgIEAAQmJiUihSEEICAhIYcgASGPIAIfIJofhx4GHx8eHx8fiR4DHx4fix6CHYYeAR2EHgsdHh0eHh4dHR4dHYQeAh0ehR0BHqAdgh6EHQceHh0eHh4dmB6NHwEghh8EIB8fH4wgiCGFIg4jIyIiIiMiIyMjJCMkI4UkiiWCJoknhSiEKYUqAisqhCuFLIIthy4LLzAvMC8wMDEwMTGEMgEzhDQNNTU1NjY2Nzc3ODg4OYQ6Cjs7PD09Pj4/QECFQQhCQ0JDRERERYVGKkdHSElKSUpLSkxMS0xMS01MTU9PUFBQUVJSU1RUVFZVVldXWFhYWlhYWYUtCi4uLzAvLzAwMTGEMoQzJzU1NTY2Njc4Nzg5OTo5Ozs8PD09Pj4/P0A/P0FBQkJDQ0REQ0RERYVGBUhISUlJhEqFTChLTUxNT1BQUlJTVVRWVVZXV1lZWllbXFxdXl5gXl9eX2BhYmJlZGRmhWcKZmZlZmdmaGZnZoRkG2ZlZWVjZmZkZWNkY2JhYmJhYWJlZGRjY2JkZYRkD2NlY2FiYmNiY2NlZGRhYIViAWCEYU1gYF9gX2BhYWBgYF9fXl1dXVxbW1tcW1xbXFtbW1xbWllaWFhYWVlYVlVWV1hbXF1hY2dwdWpnY2RjYF5cWllYVldXVlVWU1NSU1JRUYRPC05QUlJPTUtKSEZEhEICQT+FPQE+hT2APj4+PT09PD0+Pj49PT4/P0BCQUA+PT0+Pj49P0pbYFJGR0RJTFZufHNoc3GZY2S7ooN+a1hFNzAvMDM8RE1bZmpqdHBiaWtiX1tofoJ5alRUX2d5jJqfn56bkoZ9cmVdV1FOT05GO2w6bm5hVE5LSkxOS0pJR0ZEQ0RDQ0JDQ0IQQ0REQj9AQEA/Pz4/Pj09PoQ9gDw9Pj49Pz9AQEBERURGSUlJTVNUWWZmYWFkcH9/bFtZU01PTktMTVVjY2lfYWdsbnFyb2dgUUhDRUZIRkNDRkE+PTk2MzM1PkpbY2JbWFNJREpQTlFVXGJlZmRjX1pZV1lXVldUVFBMTU1KSkpISEZDPjpBQ0VDPTY1NjYzLiwoCCYkJCUlIyUnBExLSkiER4RGkkWFRAVDRERDRIdDBkJCQkNDQ5dCA0FCQpVBA0BBQZ1AAUG1QANBQUCVQY1CiUMHRENERURERIlFiEYER0dHRoRHAkhHhUiGSQVKSkpLSoRLhEyGTYROg0+EUIJRhVIFU1NUU1OEVAVVVVVWVoRXhFgmWVlaWltbXFxcXV1dXl5eX2BgYGFhYWJjY2RkZWVmZmdnaGlqamuEbQhsbW9wcHBxcYRyd3N0dHV2d3d5eXp6e3t8fH19fn5/gICBgYGCg4SFhoaHh4mKioqMjI2Njo+Pj0hISUlJSktLTExNTU5OTk9PUFFRUVJSU1NUVFZWV1dXWFhZWlpbXF1eXl5fYGFhYmJiY2NlZWZnZ2hoaGpqa2tsbW5ub29wcXFxhXNQdHR1dnd4eXp7fH1+fn9/gYGCgoSFhYeHiYmKi42NjoyNjo+QkZOUlZWWl5eXmJmYmJiZmJiampmZmZiZmZmampuZmZmamZmampiXmJiYmZqHnBSdnZ2cnp2dnJybm5ydnZ6en56bmoecBpubm5qZmoSZgpqEmVeYlpaVlZWTkpOUk5OTkpOSkZGQj46NjYyNjY2Ki4qKjI2PkZOVmJ+jmJSTlJKQjYuKh4aFhYWEgoGBf39+fnx7e3l4d3d5enh2dHFwbmxsamlpZ2ZmZGOIYglhYmFgYV9fXmCHX4BgYGFiYF9dXV1eXl1dZHR7bWNjYWRnb4SPin+Kh6Znaci3mpaIcmJVTUxMTldeZXF+gH+IiHuAg3p3c3uQlY+Abmt2eoqZpqusq6iilo+GeXFsZ2RkZF1TmFCZmpCGf3x7fX97e3l3dnV0c3NzcnNzcXJycnBvbm5ubW1tbGxrawJqa4VqgGlqaWtqbGxrb3FxcnRzdHh8fIGMi4iIipWio5KDgXt2d3d0dXd8h4iNhIaJj5CTlZGKhHlwbW5vcW5rbW5rZ2hkYF5eX2hxgYmHgH14bmtxdXN3eoCGh4mIhoR/fX1/fXx8e3l1c3Jyb29wbm1samRhZ2pramReXV1dWlVTT01LBktMSkpLTAednZyamJiYhJcDlpaXjJaGlQWUlJWVlYmUAZOFlAqTlJOUk5OTlJOUj5MBkoWTCZKSk5OSk5KTk5GSkJEEkJCRkYaQA4+Qj4SQA4+QkIiPCI6Ojo+Pjo6Pho4Bj4iOg42GjhGNjo6NjY2OjY2Njo2OjY6OjZCOjY8KkI+Qj4+QkJGQkISRiJKJk4OUh5WDloeXAZiEmYSaFpubm5ycnZydnZ6en56foKCgoaGhoqOEpAqlpaWm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SEhJSElKS0xMTk1MTE1OTU1MTUxNT1BRUlJSVVVWV1dXWFlYWltdXl9eX19gYGBiY2NlZWdoZ2dpamtramtrbW1ubGxsbW5raWlsa2poaWhohmZeZWRjZWZmZmdoZ2hoZ2hnZ2ZlZ2ZmZmVmZGZlZGRmZGVlZGNjY2RjY2RiY2JjZGRjYmNhYmFiYmNhYGFhYGBgXl5fX11dXV5eXVxdXVxbW1xcXFtdXVxbWVtcXV9gY4ZmCGlpaWVjYF9fhF6AX11bWFdWVFRTUlJRUE9QT05NTk5PTk1KS0lIR0VEQT8+PD09PT49PT8+Pj8+Pj09Pj9APz49PDw9PkBERkZEREVFREpUUE1SYn6Oe19ogYt+iqWomLBteHZyamCtlnRWTkU4Ly0xMS4vMzU0MS8uLy8vMjEtWVowMTExNj1KWGgqhJuZiYiQlpOPiHprXlpYT0dMT1NgXlNFPmdfVVRVT0dGREREQ0JDQUFAhj+APj4+PT08PT09PD09Pj49Pj9FTk1KSUhGRkpLTUlFQkJBQkhUUllncYVEiX+Bgndvd3uAhXl1anJ1e4R6eH94bWpqamtsamVlVEdEREA8NzY4Ojw8NzM2QkJCQ0VJR0pQU1haVVRZXWBgW1JMRUREQENFRUVDRUdLTVBTUVFUUEwXS0hDPTo2MjAuLzArJiUjIyMkJSYlJSMGSEdHR0ZGh0UCREWMRAFFiESOQ4tCAUOPQglBQkJCQUFCQkKTQQFAhkGFQApBQUBAQUFAQEBBj0ABQZRABUFAQUBBiEALQUBBQEFAQEFAQUCNQQFChEEHQkJBQUJCQYhCi0MDRERDhESKRQZGRkVGRkaJR4dIhEkJSklKSktKS0tLhEyETYZOgk+GUAdRUVFSUlNShFOHVA5VVVVWVldXWFdYWFhZWYRaLFtbXF1dXV5eX19fYGBgYWFiYmNkZGRlZWZmZ2hpaWpqa2xsbW1ub29wcHFyhXNzdHR1dXZ2eXl6e3t8fH18fX5/gH+BgYKCg4OEhYaHiIiKiouMjI2NjY+PkJCRSUlJS0tLTExMTU1OTk9PUFBRUVJSU1RUVVZWV1dXWFlZWltcXV1eXl9fYGBiYmNjZGVlZmZnaGlpamtsbW1tbm5vcHFyc4V0SXV2dnd3dnd4eXp7e31+f4CBgoOEhISGhoiJioqMjY2Oj5CQkZKTlZaXmJmZmZqb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lZSUlY+UAZWMlJiTApKTipIBkYWShJGKkAaPkI+Pj5CLjwGOh4+EjgqPjo6Pjo6Oj46PhI4Bj4aOBo+Oj4+OjoePAY6KjweQkJCPkJCQiZELkpKSkZKSkpOTkpKEk4WUhJWCloaXE5iZmZiZmZqampuam5ybnJydnZ2Eng6fn6CgoaGhoqKjo6OkpISlgqaEp22oqKmpqqqqq62srKytrq6vr7CxsrKzs7O0tbW2t7e4uLm6uru8vb2+v7/BwsPDxMXGx8nKy8vNzc/P0NHS09PT1NTV1dfZ2drb3N3e3+Dh4+Tk5ebn6Ojp6urs7e7w8fLy9PX29/n6+vz9/oCAhIFygoSFhYWGh4iIioqKjIyNjY6Pj5CRkpSUlZaWl5mZmpucnZ6eoKCho6SkpaWnp6ipqqusra2vsLGysrO0tre3uLi5uru8vb6/v8DBw8TFxsbHyMjKyszMztDR0tPU1dfZ29rc3d7g4uTk5ebo6Ons7u/whPMg9Pb29/j3+Pj6+/r6+fr7+fr7+vv7/P39/P39/v//gP+HgIKBhoILgYKCg4KCg4OCgYKGgQWCgYKCgoaBBoCAgP+AgYmAIv///v79/f38/fz8/Pr5+Pf29vf29vf2+Pf49/f29ff5+PiE9w318+/u7erp6Obk4t/fhNyA4N/c2NLQzszKyMfFxMPAvr28u7y+vsHDwL29vLi2s7Kxr6+traqqqqmoqKenpqenpaWlpKm1vLS2ycq8xNPk3d7TzNDO0Oz69OTXybupo6Ontb3ByszR1tje29rMxcvFpZONh4aFhoiMj5ervdO6jYyJjP75+Pf19vX3iZWRi4sziYeEh5Wir6ykm5yanKajk4mDgfn3gf/37+7o6ez59vbt9+LS0dDOzczLy8rKycfIx8bGhMWAxMTFxcXGy9vm9ICA9ePX0s3N0Nbd2tbZ1tbg5evy9uzm5e3w4+Ln6Orz/oeNjoyFgoOGi42QkYyF/PPk4eDTw76+v7q3tbGxsLCvsLGytLW5urm8wsXFxMG/u7a1tba0sa6wsbS1trm5vMHDwsPHzM7NzMfDvry7trCuraqrqaUOnpybmpqamZmZmJiYl5f/f/9//3+xf/+Am4ACgYCugQGAi4H/gKuAiH+YgAN/f4Crf4KAn3+OgNV/AgIEAIofFR4eHx4fHx8eHx4eHh8fHh8fHh8eHo0fAR6E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kI+Pj4SQEY+PkI+PkI+QkI+PkI+QkJCPhpCFkQSQkZGShJGGkgqTk5OSkpOUk5OThZQClZSGlQqWlpeXlpeXmJeXhZiCmYSagJubm5ycnJ2dnp6en5+foKChoaGioqOjo6SkpaWmpqenp6ioqKmqqaqqq6ysrK2trq6vr6+xsbGysrKztLS1tra3t7m6urq7u7y9vr/AwcHCwsPDxsbHyMrLy83Nzs/Q0dLS1NXV1tjY2dvc3Nze3+Dh4ePj5Obm6Onq6+3u7u/wgPLx8vT19fj4+vz8//6AgYGBg4OEhYaGhoeIiYmLi4yNjo+QkZKSk5SVlpaXmJmbm5udnZ6foaGio6Smp6mpqqqsrKyur7Cxs7OztbW2ubi6u7y8vsC/wcDCw8XFx8fJysvNzc7Q0dHT1NTW19ja29ze3uDi4+Pl5ujp6uvt7e7vLPDy8vT29vj5+vv7/v7+/4CBgYGCgoKDhISFhYWGhYWFhoaHh4eIiYmKjIuMi4uDjIeNhoyHixGMi4uKi4uKiomKiomIiImJiYSIGImKiomKiYqMjY6OjoyLioqJiIeGhoaFhYeGgIWFhIOBgID+/fz59/Ty7+3q6Ofn6Ojj4eLf5f+Kkon64tLKx8bHx8fIyMfHx8bFxMTDwsLBvry6ubi1tLOxsK6trKurq6qqrra1ramoqKeoqKqoqayutcPmgYeD9fnl09XU0dbb9oSFhPTk4OLs8ube29W/uL6ztb2/rZuSj4uIgIeIlJaWlp+wr6ioqJaQj4D7+Pf29PPy8fHw8PDygZansrG1raKdmY+PlpGEgYCDkqKqoJqRg/747OPi49vZ2NTS0dDRz8/Nzs3My8nIycnJx8bGxcbIysvR3evn39bW29zU1Nna187IyMrO0NDOycrO1d3i3tnd8oKHjI2PlJmaV5qbnJeVlZWUkY+I/uvZzcW/ubSzsrGwsK+urq2rq6usrKusrq+ur66traysra2trqypqquvsLO4u7/BwsTGxsXAvbeyrKmopqajoaCfnp2cm5qampmZmYSYBZeXlpaW/3//f/9/rn//gIOA+oGVgIOBuoCDgYqAg4GngI1/mYDCf5OA1X8CAgQAgh+lHgwfHx4eHh8eHx4fHx+KHgEfhh4BH4UeAR+EHgEflR4GHR4dHh4dix4FHx4fHh+GHgQdHR0enR0GHh0dHR4eix2CHocdBx4dHR4dHR2THgUfHh8fHoofiiAFISEhICCMIQUiIyIiIocjAyQkI4QkhiWFJgknJiYmJycnKCeEKIQphSoPKysrLCwrLC0sLS0tLi4uhS+GMIQxhTKEMwg0NDQ1NTY2NoQ3hTkPOjo6Ozw9PT0+P0BBQUJChEMNREVFRUZHR0hISUpKSYRKI0tLTE1NTk9PUFBRUlNSU1JTVFVWVldYWFpaWi0tLS4uLy8vhDAYMTExMjIzMzQ1NTU2Njc4ODk4OTk6Ojo7hDxoPj4+P0BAQUJCRENERUZGR0dHSEhISklJS0tKTExNTU1PT09NT1BRUVNSU1VVVVZXVVdXWFlaW1pcXV5eX19gYWFjZGNkZWVnaGhoaWpra21qa2tqbGw2Njc3ODc3ODg5ODk3ODg3ODiFNw44OTk7PDw8PTw8Ozs6O4Q6BDk4OTmIOgE5hToEOTk6OYQ4Czk5OTo5ODk4ODc3hTaENwM4NziFOYA7PD09Ozs6Ojk4NzY2Nzc2Njc4Ojs8PTw7Ozo3NzY2NWtraGViY2JhYGBkZWlxaGJcZHJGUk1KhmtcTUtKS0xNTlNYWVBMSkpJSElJSktIRkNBQkA+Pj09PT4/Pj4+QldtX09JSEM9Pz5KVVtlWFBQVmeKm5acjYKHjH50b4aXnlqhnZd9Zml5jaGyon1nbGRcWmlcQzYzMS8yOT47P0dfZ1tMRUVDOTguVlRTU1JRUFBQUVFTXz1FVGRoaWNiW1RRTUdEQ0BDS05VXmNaUUw7ZVRKSUdGRERDQkKFQVxCQUJDRENDQUFBP0FEQkBCQUBBRk5XW1ZaX1lRUU5TWFBMSE5UU1RNWmJvfUmLiklTWmFlZmNkZ2pnZGViYGJjYVxXT0V3XktCOzYyMjEwMDExMDEwLi4tLS0sLYQuMC8vMC8vMDAyNDMwMTQ4Ojs/Pz08PkFAPDo3NTIvLCsqKSgoJyUlJCMjIiIhISAgIYQgBR8fHx4fAUWIRIRDAUSGQ4JCnUMBQodDDEJDQkNDQ0JDQkNDQoVDBEJCQkOEQoJDh0IBQ4lCAUGNQgRDQkNDh0KcQQFClEEBQo1BBUJBQkFBjkKCQ4RCA0NDQoVDAkRDhUQCRUSGRQJGRYlGiUeHSIRJBUpJSkpKhUuFTIZNAk5NhE6CT4RQglGGUhFTU1NUVFVVVVZWVldXV1hYWIRZBlpaWltbW4RcgF1dXV5eXl9fYGBgYWFiYmNjZGVlZWZmZ2hpaWpqa2tsbW5ub29xcXJycnN0dXZ2d3d4eXp6e3t8fH1+fX6AgIGCgoOEhIaHh4eIiIqLjIyNjo+PkJFJSUpKSktMTExNTU5OT09QUFJSUlRUVFVWVldXWFlZWlpbXFxeXl5fYGFhVmNjZGVmZmZoaWprbGxtbm9vcG9xcXJzdHV2d3d4eHh6enp7fH1+f4CBg4OEhISFhoeIiYqLjI6PkJGQkpOUlpeXmJmbnJ2dnp+foKGioqOjo6SmU1NUhFUGVldXVlZWilcRWFlaW1xdXV5dXV1cXF1cXFyFWwlcXFxdXFxdXVyEXRRcW1xbW1paW1tbXFxcW1tbWlpZWYVYBllYWVlaWYVaDVtcXV5dXFtcW1pYV1eGVgJXWYRagFlYV1VUU1NSpKOhnZyamZeWlJSVmZ2WkIuSnVplYFyqk4R6eXl7e3x9gYSDe3l4d3d2dXR0dHJxbmxqamhmZmVlZmZlZWVoe4x+cGxrZWJiY211fIV3cHB0g6GwrLCmmZuimo6KnKqws7CsmoODj6CywLeXgYV9eHOBd2BUUU9NGE5UWFZYXnR9dWZfXl1TUkqNjYuKiYmIiISHJo9UXGl3eXp2dnFqZmJdWVhWWF9iaHB1bmZhUpSGfXl6d3V1c3NyhnFacHBwcnBwb25ubW1wbm1ubW5uc3qChIGDiIR8fHl+gnl2dHh9fH14gYaSn1isqVdhZ21xcW9vcnZzcHJvbW9wb2tnYFechXRtZmFeXVxbW1pbW1xaWFhYV1dXh1iFWSNaXFtZWVxgYmJmZ2VkZ2ppZWJfXVpXVVRSUFBPTk1MS0pKSYRIC0dHR0ZHRkZGRUVFhZUGlJWUlJSViZQBlYSUA5WVlIWVCZaVlZWWlZaVlYeWgpWFlgOVlpeGlgSXl5aWj5cBloWXCJaXl5aWl5aXkJYFl5aWlpeEloSVhZQCk5SHkwGShZOEkgGTipKLkQWQkZCQj42QBI+Qj4+PkAGPh5ABkYWQCJGRkZKRkZKRhZIFk5KTkpKHkwOUk5OGlIWVhZaDl4WYB5mZmpmZmpqFm4ScDp2dnp6fn5+goKChoqKihKMSpKWlpqemp6ioqampqqqqq6usha2Arq+vsLCxsrKys7O0tLS1tbe3uLi5urq8vL29vr/AwcHDw8TFxcfHycrLzMzO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mpmahZkHmJiYl5iYmIWXB5aWlpeWlpeFlgOVlpWElgKVlomVhZQCk5SEkwGUipMFkpOSkpKKkwySkpKTkpOSk5OTkpKPkwSUlJOThpQBlYaUA5WUlImVApaVhJaHlweYmJiZmJmZhpoGm5ubnJychJ2CnoWfBKCgoKGEooKjhKQBpYSmgKenp6ipqaqqq6usrKytrq+vsLCxsbGysrSztLS1tra2t7e4ubq6u7u8vb2+v8DAwcLDw8XGx8fIyMnLzMvMzc7P0NHS09TV1tfX2drc3N3e3+Di4uPk5ebn6Orr6+3v8fDy8vT29fj5+vv9//+AgYGCg4OEhYWHh4iJioqLi4yNgI6PkJGSk5SVlpeYmZqanJ2en6ChoaOkpaWnqKmqrKyusLCxsrOztba4uLq6u7y9v8DBxMTExcbIycnLzM3P0NHT1dfY2dvc3d/g4eLk5OXl5+jo6ers7e7v7/Hz9Pb3+Pn6/Pz9/oCCg4SFhYaIh4iIioqLjI2Njo+Qj5CQkZKRB5KTlJOTlZWFlgiXl5iampmZmoeZCZqbnZycnJucm4aaBZubm5yahZsInJycm5ybm5yEm4Ccm5ucnJubmpqamZmZmpmYmJeVlZSVl5WUlJSVlpaVlZOSk5eZk5CNi4yTjoaEgoKA/v6BgYairKSiqaSempiXmqCkpKSgmqCakomJnaGhn5yZlpibm52goJ2YkYmFgoGBhIuO9+aEjYaBhZWVkpqko5iMhYWIgvXq4d7m+f335YC/vMDB18i8s66rqbXB14D/0rurqKOdm5ycnKKen6GfnZ+ipJ2VkZKTjY6OjJGYkYuKiomLjIiFhYiEgf///v79/fz7+vv7+/39gIWKl6OkmYmD/IGPkYqKhoKDhIP98u/n4t7b2NfW1dTT09TZ4NzT08/S09Xi6vL09PDw9O/j4Unby8bGx8rKzNDT29/e2t7f29ftgP/9/v759f6Bgffr6veAg4OEhoiE++/1goeE8N3by765tbSysbCvr66trKyrqqqpqqmpqKioh6caqKqsrbG0ta+usLGxsrO1tLOwsKejoaGgn5+EngOdnJyEmwWampmZmYSYCJeYl5aXl5aW/3//f/9/qn/5gP+BjIGCgLGBgoCRgZeAAYGsgI5/iYABf4qAtn8BgId/goCEf4eABn9/f4CAgNh/AgIEAAMeHh+JHgUdHh0dHocdhh4BHZIeAR+SHhIfHh4fHx4eHx4fHh4fHx4fHx6GH4seAh8eix8DHh4fhR4BH6keAR2FHgUdHh4eHZgeCB8eHx8fHh4ekB8EIB8gH4ggBCEgICCGIQUiIiEhIYQiAiMihyOFJAclJSUkJSUlhyaHJ4YogymGKocrAywrLIQtCS4uLi8vLzAwMIUxBzIyMzMyMzOFNAE1hDaENxM4OTg4OTo6Ozs7PDw9PT4+Pz8/hEA4QUFCQkNEREVFRkdHSEhJSUlKSktLTExNTk5PT1BQUFFRUVJTVVRWVldYWFksLS4tLS4vLi8vMDCFMSUzMzM0NDQ1NjY3Nzg5OTo6Ozw8PD09PT8/QEFBQUJDQ0VFRkdHhEhESUlKSktLTExMTk9PUFBRUVFTUlNUVVZWWFhaW11dXV5eXl9gYWBgYWBhYWJiYWFjYWRkY2ZnZmlpaWtsNjY3Nzg3OTmFOgc7Ozw8PT09iT4FP0BAQUCEPw1AQD8/P0BAQEFCQ0FBhUAUQUFCQ0NCQkFBQEBBQUBBQUFCQ0KEQYVAB0FAQUJDRESEQwtCQUBAQUA/P0BAQYRAgD8+PT0/QUFAQD8/QEJDQkFAR1RPSkVCRF5tYkQ9NzY2ODo6PU5+eG55eGplYF1eZXN1cXBvcHJ0cWlfZnR4dXJvbWtvdHV1dHNtZ2NhYWBhZG10W1FaXmJTkVNUUp5fZ2dZoZudmn6CmpaRf4KLjHJvgI6MbWRwZFFKT1B0r2VfgIpUQj07OTg5PD08Pz06OTc5OTc2NjQzMzIzMzc6NzQ3OjMyMTAvLzEzNzBcLl0xWltaWlpdYzRmNkNWZmldSTtlXWM7R01JQjplaV9ZWFJOTElISEZGRkVFQ0VPTkRGTEpGREZLVF1gXFpgYFtfZGFURkI/QERDRU1ccXRucm1mNmF7U1VLjlBbYGRkX1ZQS1JVVlZVVVVKfG54RUhGeltKQTs5NDEwMC8vLy4uLS0sLCsrKyorK4kqHCsrKywuMjY1MjM1Njg5Ojo5ODYwKignJSUlJCSEI4MihCGEIAMhICCGHwIeH4hFh0QGQ0NDRENDhESDQ5NEEENDQ0REQ0NEQ0NDRENEQ0OKRAFDk0SNQ4pEAkNEm0MBRI5DBkJDQ0NCQohDAUKUQwFEiEOERAFDh0QDRUVEjEWIRgJHRohHAkhHhkiHSYZKg0uFTIhNhk6CT4RQg1GGUgZTU1NUVFSEVQlWVldXV1hYWVmEWghbW1xcXF1dXYReMl9fX2BgYGFhYmJiY2RjZGRlZWZnaGhpampqa2tsbG1tbm5vb3BxcnNzc3R0dXZ3eHl5hHuAfH19fX6AgYKCg4OEhYWGh4iKiouLjI2Pj5BISElJSkpLS0xMTU1OTk9QUFBRUlNTU1RVVldYWVlaWltcXF1eX2BhYWJjY2VlZmhpaWprbGxtbm9wcHFxcnN0dXZ3eHh6enx9fX1+gIGBgoOFhYeIiouMjI6OjpGRkpKTlJOUlJYnl5eYmJqampycn5+hoqOkplNTVFRVVlZYWFhZWVlaW1xdXV5eX19fhGADYWFihGOCYoRjAWKEZBllZmdnZ2ZmZWZmZWVnaGlqaWlnZ2ZnZ2hnimiCZoRnEWZoaWlpamlpamloaGdnZmVmhWWAZGVkY2FhYWNlZGRjYmJjZGZkY2FocmtoY2BieIZ5XlhUU1JUVVRXZ5KLf4qHfXhzcnJ5hIWDgoGChIWCe3J6hYeEgoB+fICDhYSDgn14dHNzcnN1e4BpYmlub2GyZWFgv250cmW8ubm3nKO4sq2coaasko2bp6mOgo6EcmttbowawWxpqnZjXlxaWllcXVxdXFpYV1hYVlVUU1KEUYBTVlRRU1ZQT05NS0tMT1FLk0qTTJKSkJCRkpRNlk1YaHd6cl9Sl4+VUl1iX1lSlZiRi4mFgX58e3l4d3Z2dnR1fX10dXt5dXN0eIGIi4iGi4mGiI6Mf3RxbW9xcHJ5hJaakpiTjYeeYWNbsF5nam5uamReWmBjZGRjY2Ran5SdWBdcWqGEdWxnZGBeXFxbW1pZWVhYV1ZWVoRVhVQBU4VUG1VWWFteXVtcXV5gYGBhYF9dWFJRUE5NTU1MS4VKhUmESINHhkYCRUYKlpaWlZWWlZaWloqVAZSGlYWWA5eWloWXA5iYl4iYAZeHmAOZmZiGmQOampmEmgGZj5oQmZmampqZmZmampmampmZmYaaBZmamZmZh5iGlxKYmJeYl5iXl5aXlpaXl5aXlpWFlgKVloaVBZSUlJWVhJQBk4iUBJOTk5SckwqUk5SUk5SUlJOThpQGlZWUlZWUhpUIlpWWlZaWlZWHloSXh5gGmZmZmpqZhJoFm5ubnJyFnQOenZ6En4KghKEHoqKio6OkpISlhKYBp4SoAqmqhKsH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AZ6FnQWcnZydnIedD5ydnZydnJycm5ycnJubnIqbjpoImZqZmZqZmZiEmY6YgpeEmIiXA5aWl5eWApeWh5cNlpeXlpaYl5eYl5iYl4iYCZmZmJmZmpmZmYaahJsEnJucnYScBZ2dnZ6dhJ6En4egBKGhoqKFo4CkpKWkpaWmpqanp6ioqKmpqqqqq6urraytra2urq+vsLCxsbKys7S0tbW2t7e4ubm7u7u9vr2+wMDBwMLCw8TExcXHyMjIycrLzMzNzs7Q0NLT1NTV1tfY2drb293e3uDi4+Tl5ufp6uvs7u/w8fPz9Pb2+Pr6/Pz9gICBgoKDhH2EhoeHiImJi4yMjY6Pj5CRkpOTlJWWl5eZmpydnp+goqOkpaanqKmrq62urrCxsrS1tri4uru9v7/BwcLExcbHyMnLzMzPz9HT1NXV1tna3N7e4OLj5OXl5unp6+3v8PLz9ff3+Pr7/oCBgoOEhoaIiYuMi4uMjY2Njo2Pj4SRFZKSlJaWl5iZmJmZmpmam52cnp+foIShgKKio6Smp6iqqqioqKmpqqutsLK2sq6sraysrKurrK2trK6urq2ur66vr6+wrq+wsbGys7SysbCxsLCysrGzsrCur7Gvr7GysrWwqaWlo6Oko6OhnJiVlqK0tqunparA1tTHsa+tkpaz2OLa3Ozv8u3t5uHY2cy7ssPZ29nQx7afSKCttq6ntcHNz9fV0ce4raWkmJCA8fDw9fTz+f6FiIuNkpCJiIH9k7W4qaChnpqO/eTPysvLy8a6t7Oxr66usLCvq6empqalpIWjJaKkpaOdmpqZl5aUlJSSkZGQjo2Mi4qKiIiIh4aFhYWEhIOCgoKEgXyDiY2Nh4eChYWHg4H9+/z38vHu7e3t7/D1+vWA/O3n5ePg393d29vY19zd2dfY2dvZ2NjW1NLRz87NzMzLysrKy8vMysvO0MvNzczKyczV5fD69e7k8IyXm5mfpKainZiUkpORjIb35Nfa2tjTzcW/vbm4tbS0s7Oxr62thKwBq4SqCamoqKinqKenp4SoBaeop6eohKcfqKenp6alpqampKGgn5+fnp6dnZ2cnJybm5uampqZmISZiJgBl/9//3//f6V/74D/gceBiICJgQGAiYHTgI9/AYC6f5CA4X8CAgQAih4BHYUehh0BHoYdCB4eHh0dHh4dih4GHx8eHh4f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EFRTVVZXV1hYLC0sLS0uLi6ELwUwMDExMYQyMTM0NTQ0NTU2Nzc4ODk6Ojo7Ozw9PT8/P0FBQ0NERkZHSElLSktMTU9OUFFSVFRUVVSEVihXV1lYWVpbXFxdXmBgYmJjZGZnaGhpa2tsbW1ubW03ODk6Ojk6Ojs7hDwEOzw+PoQ/EUFCQkNERUVFRkZHR0hHSEdIhUdLRkVFRkdISElJS01PT1FUWV1cVldYWFdWWF1fYF1dZm9pX2N0fXFrd3tnU1JRU1RWV1hXWl1fY15aVlVVVFRUVVRVVVRTUlFPTk1NhEyATk5NTU9QTk1NTUxPUVRjp2dfc2ZiYmKvmYeHgnZuX1dmqaRpXFRvtm9vbWnEvK2Pc2ddVVh9j5+pjquig2VRS0hDRUxFPz9BQEBBQ1eFgpCBZVxrXFVma2ZGcWlnZGFgXF5nf3VrYl9dXFxcWFZWVVp0joqHmp1VYZ2Hg2dXUFMtTk1MSUhHRkVFRERITnF6VkRDQkFBQEBAPj49PTw8Ozo6OTg3NjY1NTUzMzMyhDGCMIUvNC4vMDk6QFJpallFQDk3SVldWlA+OjU3Y1xVU1BOTk1NTE1QUVppOnRwZFxSVFRNS0lIR0aERUhGRkREQ0NCQURGRERIRkhIRktRXWluZ2Z6SVldXlpfaW90b2ljYFhNQ3hmWUxHSlBMREA7OTU0MzIxMDAvLi4vLi4tLCwtLCyGK4QqAykqKoUpBCgoKCmEKIMnhCaDJYQkhSOEIoUhAiAhhSAEHx8gIIQfBCAfHx+ERwRGRkZHqEYBR4VGg0eWRgpHR0ZGRkdGRkdHikYBR5FGAUeERgJHRptHBkhHR0hHR5NIDkdHSEhIR0hIR0hISEdIhEcFSEdHSEiLR4pIjEmJSodLiUyFTQVOTU5OToZPB1BQUFFRUlKJU4VUEFVVVVZXV1hYV1dXWFdYWFiGWQ1aWltbXFxdXV1eX19ghWGFYoNjhGSAZWVmZmdoZ2hpampqa2tsbG1ub29wcHFxcnJzdHR0dXZ2d3d4eXp7e3x8fH5+f4CBgoOEhIWFhoeIiYmLjIyNjpCQSEhJSUlKS0tLTExNTU5PT1BQUFFSUlNTVFRUVVZXWFlZWltbXF5eX2BhYWNkZWZnaGpra21ub3BxcnN1dndGeXl7fX5/f4CBgoODhIWGhoiJiouMj5CRkpOVlZaZmpydoJ+h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VlVVVFWEVAdTU1NUU1NThFIOUVFRUFBPT09OTk5NTU2FTIZLg0qESY1Ii50BnoWdkZ4Ln56fn6Cfn5+goJ+FoIShhKIKo6OkpKOjpKSko4akiKUEpqWlpo+lAaSFpQOkpKWdpAGjiKQGpaWnp6WlhKSKo4iiC6GioqOioaGhoKChh6CEn4KgnJ8PoJ+gn6Cfn6Cfn5+gn5+fh6AGoaChoaKhhKIDoaKihaOFpAalpaWmpaaEpwyoqamrrq2tra6srq+GrgKvroSvBbCwsbGxhLKAs7OztbW1tre3t7i5vMC/vLu9vr+/v8DAwMHCwsPDxMPExMXGxsfIyMrJy8zMzc/Q0NHS0tPU1dXW19jZ2tvc3d3e4eHi4+Xm5+jp6+vu7vHx8vP19fb4+fr8/f6AgIGBgoOEhIWGhoiIiYqKi4yMjo+QkJGSk5SVlpeZmpqbnJ5Sn6CgoqOkpKanqaqsra6wsbK0tre4ubu9v8HCw8bHyMrMzc/P0tLU1dXX2dvc3t/i5OXn6erq7e7w8vL09fb7/P3+//+BgYKDhIaHiImKjI6QkISRhJNFlJWWmJmbnp+goaKjpaeprK+wsbKysbCwsrOzsrK0t7q8vMPHycbJzc/Szs3Mzc7Q0tLT1Nrd49zSz87Oz87My8zLy8rMhM2AzMvMztHV1tfZ1tPRz87My8vMysjJycfHxsXFxsjHx8jIx8fJx8XGyM3Px8fFxcnM0ef9oK6nnJOHgIOG+ejh/IToyb3C34P+7/zhzeD3iYiI+P+Nhvfk18rV1MjJt6ikoJ2bmZiVk5GRm8jEubWwusa+xsWxp66/zc/KwbWdiopbk52kr7e+yMW3qqCZmZ+ilo+KhYH++PPp283NzcK9vcLAvLu6uLe1tLKysbCurKurqqiop6u71ef05t/AqqGdnJqamZiWlZWTk5KRj4+OjYyLioiIh4aFhYSFhIWDN4WIjo2HhIWFgf/7+vn49vX09PPw8O7s6+7x/YKRmZeK8+3p5+bo5eTg3t3b2trY19fW1tXV1NOF0jDU293Y1tba3+Xr6eTl7/Pz9vr8gIGB8+Ld1NXPzMjGxMLAv7++vb28urm3tra1tLOFshGxsbGwr7Cvrq6uraysrKurq4SqhakFqKmoqKiEpwWmpqalpYWkgqKGoRCgoJ+fn6Cfn5+enp6dnZ6ei53/f/9//3+bf+iA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V4VWBVVVVVRUhFODUoRRg1CFTwVOT05OToZNhkwES0tLTIVLBkpLSkpLSoWjCqSkpKOjpKOko6WMpAilpKSlpKWlpYSmBaempqenhqgLqamqqqmqq6usrKuFrAWtrKysrpGtAa6HrYKuhq0Bro6tj6wDra6thq4CrayGrYSsAqusiKuCqoSpCKqqqaqqqaqqh6mDqImnCKiop6enqKemh6cJqKempqanpqamkqUGpqalpqWmhKeEqAypqqqpqqurq6ysra6ErRysrK2traytra6uraytra6trq6tra6urq+ur6+whbEGsrOztLW2hLeAuLe4uLm5urq7vLy8vby9vb6/v7/AwMHCwsLExcXGxsfIyMnKy8vMzc3P0NDS0tLU1NXV2Nja2dvd3Nzd3+Hh4+Pl5ufn6erq7e7u8PLz8/X2+fj7/f3+gICBgYKDhIWGh4iIiYmKi4yNjY6PkZKSk5SVlpiZmZucnZ+foKGio6SApaenqaqrrK2vsLGztLa4uru8vr/CwsTHyMrMzM/R0tTV1tja2t3e3+Hi5Ofp7Ozv7/Hz9Pb4+Pv9/4CBgYGCg4OFhoeIiYmKjI2Pj5GSlJWWl5iam52en6ChoqWmp6qtra6wsrS3ubu+wMPExMTDxMbHycrKy8zNzs7R1Nba3uEl4uTm7fX39vT1+Pbz9fTz8vLt7Orr7e7s7+/4/fv6+PXv6+nn5oXkgODe29rc3dva3N/f4eHi39/f3t3c29rY2drj3+Tx8uzq6uft7/Hs497g4fyRkZWloITc3NfY1NDQ0dHT19zf39jV0s/PzMvMycbM3e37h4Lp5dHa0by4uLrI1MbByMjPysC0sLXF1cW2tc7c2sepoJ+enZydnJ6qop+oqJCMjZCTgI6PobSytrq/u7GqnpGOhIuhra2rqaWZjvXt7evn4+Dd2tbT0MzKxsbHxL67ura0srGurK662YaTlZGI/+7Ssqi7xdvX6cijn5+enZuamZeWlJORkY+VnJmblZGQkY2Ih4eJiIWFg4SDg4OCgoGBgoSDhIP+9PT18/Ly9+/v7e3uIfb8gomWn6apppeWko+Un6Kgm4rt6uPi5ej5/+nt7+3i2oTWHNnf29bU19rZ2dfW2djOysnGxsTDwsHBwL+/vr2EvBO7u7q6ubm4uLa1tbW0tLOysrGwhK8BroatF6usrKuqq6qqqamp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ODk5OTo6hDsoPT0+Pj9APz9AQUFCQ0REQ0RFRkVGR0dISElKSktLS01OTk9QUFFRUoRTDVRWKisrKywsLS0tLi+EMBYxMTEyMjIzNDU0NTU2Nzg4OTs7Ozw8hD1FPj9AQUFBQ0NERERFRUdISEpLS01NTlFRUlFTVFZXV1paW1xdX19gYmFiZGVnaGhoaWtqbG5xcHA5OTo6Ojk6Ozw8Ozs7hDwFPT0+QECEQQNCQ0SERYBGR0hHSUpLTE5PUFNWWVxfX19gYWFjZGZnaWhmZWVnamtsbGxucHR7f4B2cnF1dnt8fn19e3l4fHt7enl6fHl3dHJtbG1tbWxsbGpoZ2ZlZGZqamdna29yc29qaGhmZWNhYWJhYmNlZ2txeU1NRklEfoh5b2llYF5cXV5eX15gXzlgYWFmaWlra2ttcG9sampramlnZGRmZWdvcXBwbWxoaGprcHZ0b2ljYWBiYmJfXl1fYmBfYF5dW1qEW3VYVVRTUlFQUVBQUFJQTE9ZWFFMSURCSlltal1gVkdDRElUU2iBgn9tX2ZmcXBygGplZVRQT01OkI+LioZ+bl9YU09NTUxlkXSGXHp7dWWglI+VrbRdY2lubWxnYLWqm4lzZmRHQkI+PDs4NjU0MzExMDAxMTGEMIYvYS4uLi0tNkJNQTtCTFlvdXSBl5BoVD9bT09PUDhJQkBNaHpvZV1SSE1SVVldYFhGQ1VBZHV1Xl1ORURFRUNBQD9BQUJAPz49Pj49PDw8Ozs6Ojo4ODg3NzY1NTQ0NDM0NDSEM4UyCjEwLy4tLSwsKyuHKoQphSgFJycoJyeGJoMliiSEIwUiIyMiI4giiCEGTEtMS0xMjEsBTIVLgkqNSwVMS0tMS4hMB01NTE1NTUyITQNOTU6HTQFOj00BTo1NBk5OTU5NTYhOBk1NTU5NTYVOgk+GTgdPT09OTk9OhE8MTk5PT09OT05OT09OkE8DTk9PnU6JT4pQAlFQhlGGUoRTCVRUVVVVVlZXV4ZYCFlYWVlYWFlYi1kHWllZWVpaWYdaA1tbWodbCVxcXV1dXl5eX4RgBWFiYmFhhGKAY2JjY2RkZWVlZmdnZ2hoaWpqamtsbG1tbm9vcHBwcXJyc3R0dXZ3d3h5enp6e3x9fn5/f4CBgoOEhYWHiIiKiouLjY6PR0hISElJSkpLTExNTU5OT1BRUVFSU1NU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KoQrYywsLS0uLi4vMDAxMTIyMjMzNDM1NTY3Nzg5Ojo7Ozs8PD09Pz8/QUBBQUJEQ0NERUVGR0hJSUxNTU9QUVJTVFRWVllZWlpcXV5fYGBiY2VmZmdmaWhpbG1ub29vOTk6Ojs7O4Q8Az08PIQ9Lj8+P0A/QEFCQkNEREVFRkVGR0hISUpKTE1OT1FTV1tdXmFjY2NlZ2hoZ2hnZmmEajJsb3R5e3h6fHRwb3ByeHd3dnd4eXx8eHl7ez55eT14eXRxcnJxbmxsaWhnZ2ZobHBwb4RugG1qZmZlY2RiYmFgYGFhY2Rma29ua2twb2lvcnNuZ2JhX15eX15gYF9fYWJkaWprbW9vb21qaWpramdmZGRmZ2hucnBxbmpnZ2lueHltaWVhYV9eXV5cW1tdXl9hYF1aWFlaWVpbWldUU1RTUVFQUVNRT0xLS0xLSUdFQkFBQkxTV1ZHPDxCUVxncHVzbGJfWk1gfHdtWl9ckkuUS1ZMi32DlFeVcF1VVml1c4afmpqmW15lXpyEhLBfoJGlYnBxcXFsZLilhW1mVUNCREFAPDo4NzUzMjEwMIQvATCHL0YwMC8uLS04UFI+Q01bc4WDf3uEg2hdWkNiTk1RUzU5O0dgd3x1cGNiXGFiaGdeXElMSHg9RU1CY09FRERFQ0FAPz8/QD8+hD0UPj08PDs6OTo5Ojk4Nzc2NTU0NTSEMxMyMzMzMjIxMTIyMTAvLS4tLCsrhiqGKYUoBycnJicnJyaGJQQkJCUlhySGIwMiIiOHIgQhIiEihCGFTA9LS0xMS0xMS0xLTEtMTEyGS4dMBEtMTEuJTI9NAk5Nik4BTY5OA01NToRNAU6GTQVOTU5OTYdOgk+QTghPT09OTk9PUIRPBU5PT09QkU8BUJlPCk5OT05OTk9PTk6ETwFOh0+JUIlRiFKHU4JUhFUEVldXV4RYAVmEWIhZA1pZWYRagluHWgFbhFoCW1qGW4RcDF1dXl5eX19gYWNiYYdihWOAZGVkZWVmZ2doaGhpaWlqamtrbG1tbm9wcHFxcXJzdHR1dnZ3eHh6e3t7fH1+fn+AgYGCgoSDhoaIiImKi4uNjo5HR0dISUlJSkpLTE1NTU5PT1BSUlJTVFRUVldXWFhZWltbXV1eX19gYWFiY2VmZmZoaGlqa2xtbnBxcnN0dniAeXp6fH5/gIKDhIaIiIqL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RUZHSEhJSktLS09OUFJSU1RVV1hZWltbXF1dXl9hYmRlZmdnZ2lqa2xtb29wODk6Ojo7O4Q8AT2JPgo/QEBAQUJDREREhEZTR0hISElJS0xNT1BRU1dcX2FiYmVmZGVmZ2hoaGlpaWppam91fXh2dHV4cm9tb3F0cnJ0dHV1eHh4ej4+PHZ2PT0/PHVzcXFwbWxpaGlpaGtvcG+EbDZramhoZ2VkZGNjYmJiYWBhZGRlZWVoamdmaGlrbGljY2JiYWFhYGBfYGFiY2dpaWtwcG1qaWmEajJpZmVmaGlsb3d5dm5samlrbnRrZ2VjYV9fXlxcXVtdX15fX11dW1taW1tYWVlXVlVVVIRSaVZWVFFOTlFPTEhFREJFRUE/Pj49OUFSUlZjXltZUE1GSFZdYmhMhY5IT15sbmteUU6ZT06Oe2hodXxvW2ZqcHJvfVarjm50o12efZS3Z2BjbnFqYJt6Y1hKQ0NCQUA/PDs4NjUzMjEyMYUvVi4vLi4vMTMxMS8tLTJJb2heZGdWZmxnX2loXFtnTzZSTU5MTlk8SmF7h4N2eXlvZm9yYldZSkJGQUhKSnVYTUZDQ0JCQUA/P0A+Pj08PDw+QEE/PTw6hDkPODc3NzY2NTU1NDM0MjMzhTKFMQswLy8uLS0sKysqK4QqFCkqKikpKCkoKCcoKCcnJyYmJSUmiCWHJIcjhCIBI4ciBCEiIiGmTAVNTU1MTIVNDU5OTU5OTk1NTk5NTk2WTgFNhE4BTY5OCk9OTk5PTk9PT06FTwdOT05OTk9Oh08BUItPAlBPhFABT4VQBk9QT09QT41QAk9Qik8BUJdPilCIUQlSUlJTUlNTU1KHU4RUDFVVVVZWV1dYWFlYWI1Zh1qCW4RaiVsEWltbW4VchV0QXl5fYGBhYWJiYmFiYWJiYoRjgGRkZGVmZ2dnaGhpaWlqa2pra2xtbW5ub3BwcXFyc3R0dXV2d3d4enp7fH18fn9/gICBgoODhIWGh4mJiouLjI1HR0hISUlJSkpLTExMTU1OT09QUVJTU1NUVVVWV1dZWlpbW11dX15fYGBhY2RkZWZnaGlpamtsbW5wcHJyc3Z2gHh5e3x+f4GCg4WGiIiJioyNjpCSlJaXl5iam5yeoKKjo6ZTVFVWVldYWFlaWltbXFxdXV5fX2BgYWFiY2VmZ2doamtrbG1ub29wcXJ0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qqushKuFrIetCa6vrq+urq+vr4awBrGxsbKysoWzhLQEs7S1tIW1hLaGtwS4t7e3hbgFubq6ubuIugW7uru8vIS7C7q6ubq5ubm4ubm5hLgGt7i3t7e4ircFtre2treHtgG3hbYBt4a2hLUFtLW1tLOEtAKztISzB7Kzs7Oys7OKsguxsrOysrGxsLGxsYWwhq8JsK+vrq+vrq+uha8Erq6vroSvArCvhbCEsYeyBrOztLO0s4S0CbW1tbS1tra3uIy3Bbi3uLi3hLgCubiFuYC6u7u8vL2+v7+/wMHBwsLDw8TDw8TDxMXGxsbHyMjJycrKy8vLzM3Nzs/Q0dLS09XW19jZ2dvb3N7e3+Dh4uTk5ujo6uvs7u7v8fL09fX1+fr6/P3+gICAgYKDhISFhoeIiIqLjI2Njo+QkZKTlJSVl5iZmpucnZ+goKKjpKWmqICoqqqrrK6wsLKztba3ubm8vL6/v8DBwsPGyMnNztDR09bX19jb3N7f4uPl5+rs7vHy9PT29/n7/YCAgoKDhYaIiYqMjY6Pj5GRk5SVlpeYmJmam5ucnqCgoaKjo6SmqKqrrK6vsbO2uby/wsTFxsjMztHT1djb3uDk5ufo6uvr7YDs7vDw8PLz9fj4+fr6+/r6/P3+gIKDhIeJi4aEhIaHh4aGh4eHhoaEgf/9/f3+///+/Pr5+Pj4+fv6+fn6+vj19fX09PPy9PP19PP08/P0+Pr8/Pj39/b09fP19vb2+Pn8/4CBgYKAgP/9+vX6j46JgPT09PLz8vH17uvp49/d3YDc2tjU0dHR0NDQz87MysnGxcPBwL+/vbq4t7WzsbCtq6uppqSjoJ6cmpqZmJiXlJKQkJCPj5CVlJeUj5KRi42NjIqHhIKHjYycnYqMioqEhZGgnZqhnZiTj4yIjYSHh4P19OvQ0M3P18zGwL67s7vCxNXwgoWHjIX04NPd4+HSznbKyMPBvMDDsqKjyd/Vt5uWnJmRjo2LjJKZoaSmoKSwsbO2uby7u7q2r6yomo6UnJuaoaOrsrCttrixwszV3+Lc08vBuK+qqqSemJKJ//Pm5ebe3NvZ19bU1NLQz87NzczLy8rKysnIx8bGxcTEw8PCwsLBwcDAhr8Pvr2+vLy7urq6ubm4ubi4hbYJtbW0s7KysbCwha8Crq+HroWtBKytrayFrQisrK2srK2trYas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U1KEUwNSU1KMUwJUU4dUAlVUhVWDVoZXhFiIWQZaWlpbW1yEWwZcW1tcXFyEXQ1eXl5fX19gX19fXl5fhmCCYYxgBmFhYWJiY4RkhGWGZgFnhGiAaWlpampqa2tsbGxtbm5vb3BwcXFyc3R1dXZ3d3h5enp7e3x9fn6AgYGCg4OFhYaGiImKiouMjo6PR0hISUpKS0tMTE1OTk9PUFBRUlJTVFRVVVZWV1dZWVtcXF5eX19gYWJjZGRkZWVmaGlqa2tsbW9vcHFxcnJ0dXZ3eXp7fX6AgYOFh4mJi4yNjo6RkZOUlZianZ2eoKGjo6WmU1NUVldYWFlaXFxeX2BiY2RlZWVmZmZnaGlpamprbG1tbm5vcHBwcXJzc3V3eXp8f4KDhIaIiYyOkJOVmJeYm5+gpKWmp6ipqaysrq6vsLKzsrJaW1taWlpbXV9eXmBgYF9fX14jXF5fX15eX15fX15dW1pZWFhYV1ZWVldXVqyrrKyrrFZVrKuEqoCopqamqaqoqKmnqaurVVaqqlVXWFhXVqunqausV1laWlxfYWFgX11fY2RftrKtrKyxtre3trKtp6ShoaGgnp6dmZiam5yenZubmZmZmJaTkZCQj4yLioiEgoB/fXt5eHVyb2tpaGdnZ2ZmZmVkY2FhYmRkY2JnY19fYGd9c2lxcIBeVltpZW14gXNfW15cpqipWnWAioyGe3FmuLC6r4iXtbBhZ4KAc2piq4lzgpyntLGwloqJlarIwJudsbjAwsbIy8KqnIp/j5mlnoBya2JaWVZUVFRTVVZfXldhcIGPnqech42WmZeNgHZuZWRgXVpqeYWXoKOprLCzt7m0rquflA+LgnpzbWlkX1mil5GOhnyGeRF3dXR0cnFwb29ubW1sbWxsa4RqBmlpaGdnaIVnDGZlZGRlZWRkY2NiYoRghV8RXl5dXVxcW1taWllZWFhXV1eFVgdVVVVUVVRUhlOLUohRhFCJTwGtiayErYSuha+GsIOxhLIGs7KzsrS0ibWHtoS3D7i4t7i4uLm5ubq5ubq6uoS7hrwTu728vLy+vr++vb2+v7++vb28vIa7jboCubqJuQS4ubm6hLkDurq5irgFt7e3uLeHtgO1tbaEtQe0tLS1tbS1jLQIs7O0s7OzsrOEsoWxArCxlrADsbGwhLEHsrKys7OztISzhLSEtQO2trWFtgS3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YmNjhWSCZYRmhWeAaGhoaWlpampqa2tsbG1tbW5vb3BxcXJyc3R1dnZ3d3h5eXp6e3x8fX6AgIKCgoODhYWHh4mKiouMjY6OR0hISUlKS0tMTE1OTk9PUFFRUlNTU1RUVVZXV1dYWVpbXF1fX2BhYWNjZGRlZmZmaGlqampsbW5vcHBxcnN0dXZ3eHoxe3x+gYKEh4qMi4yNj5CRkpSUlpiZm52dnqGio6SmU1RUVVZXWVlbXF5fX2BgYmRlZoRnCWhpampra2tsbYRuVW9wcXFxcnNzdXh6fH2Cg4OEh4mLjY+RlZeanZygoqKnqqqrrK2tr7CwsrRaW1tbXV1eXl1cXF1dXV5fX15eXl9gXl9fYGBgX19eXl5dXV1cW1tZWVmJWBNXV1dYWFlYV6yrq6qpp6pVVaurh1ZhV1ZXWFtcW1pZWFdYWFlaW1xeXl1eXl1dXmFeW7WxraysrbGwr6+uq6ako6WjoKGgoJ+enZ+goJ6dnZycm5mXlpWVk5OTko+RjIWDgYB+fHl1cnBubWtqaWlnZ2dlZGZmYoRjgGFgYF5dXV9nZl9aXF1dWV5xd2pncmtarpeYp2d4jIuEgoB9d3BmtJeUlmt9hoJ6dnNyacCvkHd+kq7AxsCkkI6LjZ6ssaTAzszOysfHyrytnYyRipWJhHp3bmFeWlZeX11jc3FtZnSTm6Wxt6mYj5CcnpKGf3lyYmRpbnmBhpOeHaq3ubaysbKup6WbkIiAeHFrZmBcV6KcjYV9eXh4hHkYeHh2dHRycXBvbm1tbG1sa2tqamtqaWloiGcNZmVlZWdmZmVkZWNiYYRghl8UXl5eXV1cW1taWVlZWFdXVldWVlaGVYNUhVMGUlNSU1JThlKHUYVQAU+EUIJPBaytra2shq2DroSvhbAJsbGxsrKxsrKyhbOEtIa1g7aFtwK4t4S4BLm4urmHuoW7h7wZvb29vr2+vr/DwsLBwL6+v8DAv72+vb28u4S8Bbu7u7y8i7sRurq7urq7urq7uru6uru7urqFuQO6ubmIuIW3Ara3hraMtQu0tLW1tLW0tbSztIWzArKzhrKIsQewsbGxsLGwhLEBsIexhLINs7Oys7OztLW1tLW1tYS2Are2hLcFuLe3uLeFuBa5uLi6urq5urm5urq6u7u7vLu8vLy9hLyAvby8vb2+vr+/wMHBwsLExMPFxcXG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RkdHSElJSUpLS0xMTU1OT1BQUVFSU1RUVVZXV1haW1tcXV1eX2BgYGFiYmNkZWZmZ2hpamlra2xsbW5vcHBxc3R1dnh5enx8fX+Bg4SHh4mKjY+PkZOUlZaYmJmbm52foaSkplNUVVZXWFlbXV1eYGFkZWVKZWZnZ2hoampra21tb29wb29vcGypkLCyqJ1ddHp7fH+BgoOFh4mLjpCQkZSRjmqTpaitmbCys7S1t1xeX2JiYmNlZmhoZ2ZmZmeEaCtnZWVnZmVlZWRlZGRlZWRjY2RkY2FhYmRlZWRjYmFhYmNjY2VoaGpsbWxrhG2AbGtrbG5tbW9vbmxqaGdmZ2dqamhrbW5ubWxrbG1tbWtnZmRiYWFhYF1cXFtaWVlYV6+wr62trayrq6qpqKinpqWmpaWkpKOjo6Slpqamp6alpqakoqKhnpuboaKnqpOvxqCJh4qRl4l/fH59enh1c3FvbWtqaWdlY2JobWRbWVlDWFhXV1ZVVFVUU1RbaGFiYFZdbK6lpWJna2arp2OxnJ2jrV+akI6MiYeEgoqgnba9l5KbqbimpLHEw8XKw7Kik5CEf4R7bXd0cXBubGpqaGZkY2FgX11bW1thXl9cW15yhoJ7c4J+enxzZWJlbXmCiJmWk52boqq1ubClm5ONiIJ8eHVzc3Fva2djXlmilZSAfHt6eXl5eHh3dnR0cnBxcnFxcXBvb29ubm5vbWxsa2pramqGaQZoZ2ZlZWWHZBJjY2JhYmFhYGBgX19eXl5dXV2EXIRbBFpZWVmEWIRXB1ZWVlVWVlaKVYxUB1NUU1NTVFMdsbCPjqOKg4mPnoussLKys7OztLS1tbW2tra3uLeEuBK5ubm6ubq6uru7u7y8vby9vb2EvgS/v8C+hb+DwITBh8IKw8PCwsPDw8TGxoTHC8bGx8XFxcTExMXGhcQJw8LDwsLDwsLDhcIEw8LCwoTBF8LBwMHBwMHAwMHBwcDAv7/AwL+/v76/hr4Pvb29vr29vL28vL29vLy9hbwCu7yHuwe8urq5urm6hbmEuAW3t7e2t4i2CrW1tba1tbS1tbaJtQW2tra3toS3B7i4ubm6urqEuyy8vb3Bv76+vr2+vr+/v8DAwMHBxMTDxMTDwsLCw8LCwcLBwcDAwcHCwcHBwoTDgMLDxMTExcXFxsbHx8fIyMnJyMevkoLgbWRzck70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2b/2l5K1i3Cok42IcebGsbu3o3/6h7R2enp7e3x9fX5/gIGCgoODhIWGhoiJiYqLjIyNjkdHSEhISUlKSktLTE1NTU5PUFBRUlJUVFVWV1hYWVlaW1xcXl5fX2BhYmNjZWZmZmdoaGlqamtrbGxub29wcnJ0dXZ3eHp5e3x+foGChIWIiIqMjo+Rk5SVl5mbmpqcnZ6ho6WmVFRVV1dYWVpbXF5gYWNjZGVmZ2doaWlqamxsbW9wcXJxcHBvbpmLo6ijhV95e3x9gIKDhIaJjI6SlJWUlIdzrHyhp6N1oaS0tbS2XWFiYmJhYmNjZWRkZWVmZoRoAWeEZkNlZGVlZWZlZGNjYmJhYmFhYWNkZWVjYmFhYmJiY2VnaWpqa2tsbGxtbGxrbm5ubW9wcHBvbWtqamtrbW5ubm1tbWxqhGslbG1pZmRjYmFhYGBeXV1cW1pZWFdYWLCvra2tq6ysqaimp6WmpoSkgKOlpaanpqamp6emqKako6KenJqamZ2vsqmqqqqbkJKFhY6JhIF+fHl3dXJxb2xramlnZGNkaGRdW1paWFlYWFdXV1ZUVFdhZ2pfV1tgX1mlqqyorqCapZuSlpWTm5qOjIqJh4OChJWUk5qGfnyEkZCWl6Ktr6ylnYh2enp1bXyDXn96dnNxb25ta2ppZmVjY2NiYV9gbnNkYV5haXNzdm9nbGxmYF1cWWmYq56YjZWfoq2ysrS1q6GXkImDfXZubG9ubWpmYFtWU5+Rg358e3t7enl5eHd2dHNxcXJxcHCFbwpub25vbm1sa2tphGoJaWppaWdnZmZmh2UOZGRjYmJhYWBhYGBfX1+EXoJdhVwKW1taWllZWFlYWIRXBFZXV1eHVohVglSEVYpUGbGj2Xf4fHLCm5tu66+xsquos7S0tbW1treGuAO5urmEuga7u7u8vLyEvYK+hb8CwL+EwBvBwcDCwsHCw8LDw8TDw8TDw8TExMPFxMXFxsiFxwrGx8bFxcbFxcbGhMWHxAfDw8PExMPEh8OFwgTBwcLChsETwMHAwMHAv8DAv8C/wL6/v7++v4a+hL0LvL29vb69vby8vL2IvIS7grqGuYS4h7eQtoO1hLaEtwa4t7i4ubmEugm7u7u8vLy+wMGFvhW/v7/AwMDCw8TFxsTEw8XExMPDxMSEwwTCwsLBhcIMw8PEw8TFxcTFxMbGhceA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a2trXoGjo5uk29S2+Ofsq1tlg3SmyOe0j6uj7Zjm7bB6e3x8fX1+fn+AgYKCgoODhYaHiImKi4uMjY1GR0eESHFJSUpKS0tMTU1OTk9QUVJTU1RVVVZXV1hZWlpbXF1eXmBgYWFiY2NlZmZnaGlpampra2xtbm9vcHJydHR1dnh6e3x9f4GBg4SGiIqMjY+QkpSWmZudm5ycnZ6goqKlplRVV1dYWVlbW15fYWJjZGVmZ4RoQGlpamtsbG5vb2trbnBwcF17ro58c4N4e3x9gIKDhYeKjpGUlpeRrI1my7CFpq2ds7K0t1xdYGFhYWNjZGVlZmaEZwtmZ2hoaGdmZ2ZlZYRkL2VlZGNiYWJhYmNiYmNkZWVkZGJiY2NjZGVmZ2dpamtramtrbW1tcHJycnBwcG5uhGxybXB0cnFwcG5tbGppaWhoa2xraGVkZWJhYGBfXl5dXVtbWVhZWViwrq2tq6qpqaelpaWmpqWlpaanqKiop6imp6mpqKempKKgnJqamJeXl5mbnJilo6Cfi4qLiYSBfnx7eHd0c3BubGppZ2VkZGJgXl1bhFkBV4RWgFVUVVVWVllZWKmppp+fnZ2cm5iYlpSUlJKQj42Ni4iIhIKBhYiEg3x5eHd1eXl9hIaKeXBzcWttaWdoco15gX54c3Bvbm1ramhnZWRkaGpkYWdpaGZiY2RlZ2RjYGFgX19fWlt5pr63oo+NlqWts7Guqqimn5SLg3x1bGVna2pmLGFdVlOkmIaGlp6JiYiAgZKRfHd2dXNydHJwcG9ub29ydnJxcG9ubWxsa2trhmoHaWhoZ2dmZoVlDmRlY2NiYmFhYWBgYF9fhF4MXV1dXF1cXFxbW1pahFkHWFhYV1dXWIVXh1YEVVVVVo9VAlZVF5WgZF5gbFpPh2yd+JSunoWTpqq0tba2hLcGuLi4ubq6hbsDvLu8hL0Kvr6/v7/AwMHAwIXBC8LBwsHCw8PDwsPDhMQMxcXExcbFxsXGx8fHhcgEx8fHyITHgsaFxwrGxsbHxsXGxMTFhMSCxYbEiMMEwsLDw4TCicEHwMDAwcDAwIW/BL6+vr+HvgO9vr6KvQK7vIS7A7q7u4W6Frm4uLm4uLi5t7e3uLe3t7i4t7a3t7eFtgK3toS3MLi3t7i3ubi5urq7urq7ubq7vL29v7+/vr6/vr+/wMDBwcHCw8PFxcTF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WltbW1xcXF1dXV5fXl9eX2BgYWGHYhRjY2RkZWVmZmdpa2loaWlpa3FraoRpA2ppaohpAmhphmiCaYRqAmtqhWtAbGxfXIqt4IXshbOwr6bTrm6P84y0ws240eSN0t3Eh2l7e319fn9+f4GBgoKChIWFhoeIioqLioyMjY5HR0dISIRJgEpLTExNTU5OT1BQUVJTU1RVVldXV1hYWVpcXF5eX2BhYWJiY2RlZmdoaGlqamtsbG1ubm5vcHJzc3V1d3h5e31/gIKEhYeJiouMjo+Rk5WYm56dnJ2en6CioqOlpqdUVVZYWVtcXmBiZGNlZWdoaWpqaWhoaWlqbGxtZahaiqWVLGZwlcK5z5BveWV8fn+Bg4OFh4qNkpWYnH6ia2bIuKVzeJevXrhdXmBjY2RkhGUEZmZoaYVoFWdmZ2doZ2dmZWRkZWRkZWRkY2JiY4ZkVWVmZ2ZmZWZmZWRlZmdnZ2hqa21tbnFxcXJycXFxcHBwcnFvcG9xc3NzcnJycXBtamhnZ2dramhnZmVkY2JhYWBfXl5dXVxbWlpZWK+ura2trKqoqaiEpoCnp6iqqqmpq6urrKqpqKilpKKhoKCcmZiYl5SSkpGPjo6Qj42Mi4eEgX99e3p6d3Nwb21ramtpZ2RiYF5dXVtaWVlYV1ZVVVVUVFSpp6imp6ejoZ+enZybmpqYlpaVlZSSkY+OjIqJh4WDgYB+fXt6eHZ1dHNzc3BwcG5ta2ppZ2FmZWpvhZqXhXp0cm9ta2poZ2dmZmVnZGNiY2NjYmJiYWNhYF9gX2NmamiDm6u7uqyZkJCao6errqqjnpmVjIF3bGZhYGFkYV5aWFheZKBcaHNxcHJpWGdifHd1dXV0d3NxhXAccnhyd3RxcG9ubWxsbGtrbWxqampra2hnZ2ZmZoRlCGRjY2NiYWFhhGACX2CEXwFehl0GXFxcW1tahVmKWIVXi1YLVVVWVVZVVVZWUqgiY+ifZY6KmrBhYXyDqoGl8ZD7uKO0tra3tra3t7i5ubq6u4W8Cr29vb6/vr+/v8CFwYTCCMPDw8LDw8TDhcQBxYjGgseFyAnKycrJyMjIycmGyBbJyMfIyMfGxsfGx8XGxcXGxcXFxsbGhMUJxMTDw8TDw8PEh8OIwgbBwcLCwcKEwYTACL+/v8DAwL/AhL8BvoS/hb4Mvb69vby8u7y8u7y7hLoF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W1xcW1tcXIdbjlqEWQFalFkBWIlZg1iIWQNYWVeHWANZWFmHWAdZWFlYWFlZm1gDWVlYilmHWoVbC1xcXVxdXV1eXl5fhGAbYWBhYWFiYmJjY2RkZWVmZmZoa2xqam1ta2tshGsBaoZrBWpsbGtrhWoBaYRqgGlkZmZqamxrbGxtbGxsbVmDYOnYraGhi+yTocmbhGak6eDHhpiCobfCw9CaeXx8fX5/f4CAgoKCg4SFhoaHiIqKi4uMjY1HR0dISEhJSUlKSktLTExNTU5PT1BRUlNTVFVVVldXV1hZWVtbXF1eX19gYWJjY2VlZmhpampqa2trgGxubm9wcHFydHR2dXh5enx+f4GEhomKi4uNj5aalZSWmZubnJyeoKCgoqOkpKdUVFVXWFpbX2BjZ2lpZ2psa2tvcW5qaWprbG1ubJ2otI1mkr9gwrNyeGZhc12vXX6DhYaHiYuPk5Wan6GWjYp4tMPTwo2orV63YbFis2BlZmZoA2loaIVpEGhoZ2hpamppZmVlZGRlZGWEZApjY2RkZGVlZWZmhmeFZghoaGlqa21vb4VwEHFydHR0cnR0cnJxcHJzcnGEcIBvbWtqamtra2lmZWVkZGRjY2JiY2FfXl1dXFxaWVlYWLCvsLGwrKurqamqq6urrK6srKyurq+uraqnpqOioZ+fnJuZmJeWlJKRj42NjY6OjIqKh4SCgX58fXt3dHJwb25sbGpoZWNiYF9eXFxaWVhXVlZWVVVUVFSop6WlpKKioEOenJuZmZmYl5aVlZWSkZCQjoyLiYiHhYOCf318enh1dXRzcnFwb25tbGppaGhoZmVqg4yKhXl3cm5saWhnZmVlZWRkhWNTZGNiY2NkYmFgZGpvZWd9kKizsKeXkJGYnKCjpqSfmJGMi4N3bmZkYV5bXGJoZ2ltbG5ygY6FfYB8bWdlkHd2dXV1dnRycnFxcXBxcXF1d3Vzcm+FbhBtbGtpampqa2xpaGdnZmZlhGQEY2NiYoRhhmAFX19eXl+EXgNdXFyEW45ZhFgCV1iJV4pWAlLgKjJ29pfSgdbrgmvZgteO8aGH3rn2l6u1trS1t7e4uLOzuby8vb2+vr6/v4XAgsGEwoXDA8TDw4XECcXFxcbGxsfHxoTHgsiGyYXKBsnKysrJyonJDMjIx8jHx8fGxsfHxYbGhsUFxMXExcWLxIXDicIO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hp9XWFdYWVhYWL63WodWhFeFWIpZAVqGWYtaiFuEXAFbh1yFWwRcW1tbj1oBWYtaBVlaWVpamFkBWJ5ZDFhZWVhYWVlYWVlZWIRZAViKWYdaiVuEXIRdIl5eXl9fX2BgYWFhYmJiY2JjY2RkZWZmZmdnaG5va2tucXCEbAlubm9ubm1sbG2EblltbW5tbGxsbW5tbGxmr5ufs1lsa2VlbWpgUlpUg2DQva+vtb+Gyaq7vfnju5zqpuedzYeMgoa/Y3t9f39/gIGCg4KCg4SFhoaHiImKi4yMjkdGR0dISEhJSYRKgEtLTE1NTk5PUFBRUlNTVFVVV1ZXWFhZWltbXV1eX2BhYWJjZGVlZmhpamtrbGxsbW5ub3BxcnN0dXZ4eXt8fX+AgoSIiYqLjZCWnp+dmZiZnJydnp6goKKjpaalqFVWVlhZW19hZGJobW1rdb1ubXJ1b21sbG1ubm9vnr3Bo5yMQWuBkcCfd4BiWWiVonl+e4WJjY+RlJehp6KgqHFzl3mjsqiXgoOxpoCE7sWmZmdoZ2ZnaGhoaWlpaGhqbGxqaGdmhWWFZgZlZWRkZGWEZoJnhWgfZ2lpaGlpa21vcXNycnNycnJzcnR1dHR0c3R0cnFxcIRvgHBvbm5sbGxtbGppZmVlZWdnZWRkY2JhX11dX15dXFtbWlpZWVlaWbGwr62urrCxsrSysa6ur7CxsK+urKmko6GgoJuamJeVk5KTkpCPjo+OjYyLiYeFgoB/fHt5dnRydHhvbWxsamZlYmFfX15dXFpZWVhXVlZVVVSpqaimpKSjPqKgnp2bmpuamZiXlpWVlJOSkY+PjouKiYiGhIGAf316eHh3dnRzcnFwbm1samppaGdmZWR3fXp5fHRwa2hnhGWGZIRlhGRLY2Nkc3FqZWZwiZqkoZeLh46ZmpiXmZ6bk42HhIF8dW9oZmFeYGZzeXJrZmpvfIqEfXtvYlypjHd2dXZ5d3R0c3N0c3V6gYGBfHNyhHAYb29ubWtramlpaWpqaWhoZ2dmZmVkZGNjhGKFYQJgYYRgEF9fX15fX19eXVxcXVxcW1uGWgRZWlpahFmGWAFXhFiFVwNWV1aEVwJPyzRBSFiDgPiCxaCA3NrF2Pmf9fzu7n3mr7KzsKSxtrLax6O7vL2+vr+/v8DAwcHBwsHCwsPDhcQMxcXExcXFxsXExsbGhMcEyMjJyITJCsrKysvKysvLy8qHywLMy4jKg8mEyAPHx8iExwfIxsjHxsbHhsYJxcXGxcXFxMXFhcQEw8PDxIrDA8LCw4fCCcHBwcLBwMDBwYXAgr+IvoS9hLwCu7yFuxG6urq5urq5ubq5ubi4ubm5uoS5h7qGuwW8vL29vYS+gL+/wMDAv8DAwMPCw8PExMXKy8nIy87MyMrJysvLysrJycjIysrLy8rKy8vKycrKyszMysmy9Jm52IfExLOxycCmgpWFvoPlo1RLgHVaZztpj6/Wkml+WYNdaUdAQkaOldfh4+Xo6uzu7vDw8fHz8/X2+Pn6+vv9/4CAgYGBgoODgIOEhISGhoeHiImKi4uNjY+PkJKSk5aWl5iYmZqbnJ2foKGio6Wlp6ipq6usr6+xsrOztLa3uLm6vLy9v8DCw8XGyMrMzc/R09XY2tzd4eXq7ezq6evv8PHy8/X3+Pr8/v//gYKDhIaJi46RjpSYmZOd/JycoaOfnp2dnp+foKDZOvLbxaZ6hbSn7eemt5GAl8/hsbixw8fLz9HV2N7i2dbgkZPEkb7s3sWsruDhmJz1++GLjY6Ojo+RkZCEkgeTlJaWlJSShJECkJGEkoSRC5CRkZKSk5OTlJWVhJRFlZaUlZaYmpyfoKCfoJ+foKCfoKGioaKio6ShoKCfnp6dnZ6enZ2bmpqbmpiXlJOTlJWUkpGQj46MioiIiIeHhYSEgoKBhIAN/fz6+Pf4+fn4+ff18oTxgO7r6+nm4uDd3NvW1NLPzszKycjFxMPCwb++vLu5tbOxsK6rqaempKSln52bm5iWlJKQjo2Mi4qJiIaFhIOCgYCA///+/Pv39/Tz8fDw7ezr6efm5ePh4uDf3Nva2NbU0tDPzMrHxsTDwL++vbu5uLa2tbGwr62sq6qqp6ezuLW2C7ivq6ilpKOioaGhhJ8BnoSfbp6enZ2cm5yopqCcnKW4xczJwrezucC/vr3Aw7+5tK+sqaSfmZORjYqMkZqgmZSPkpagqaWfnZSKhf7o1tXU1NfV09LS0tDP0tba2tnX0M7NzczMzM3MysnJx8bFxcbGxcTDxMLCwcHAv8C/v7++hb2EvIa7hLoMubq6ubq5ubi4uLe3hLgFubq5ubiFuYW4BLm4ubmEuAm5uLi3t7WwhZ0OfX19fn9+f358fX18fX6EfYR+iH+Cfv9//3+Wf4R+i3+CfoZ8hX0JfHx9fXx8fH18hX2Zf+qAj4EBgI2BEoB/fn9+fX+Af3+AgICBgYGAgJKBgoCFgQeAgYCAfoCB+oLSgf+AjYD3fwF9AgIEACKUrnibdmZSd8jaiGifaJeQXG65gb9nKyosgW5oMYaFbWIoiCeEKAMpKCiKKQYqKiopKSmFKgEphSoFKSorKiqEKwEshisOKisqKysqKiorKyoqKSqYKQEohSmCKIUphigEKSgoKYsoDCcoKSgpKSgpKSgpKI0pASiGKQcoKSkoKSkolCmFKgYrKyorKyuFLAQtLS4thC6EL3gwMDExMTIyMzMzNDQ1NTY3Njc3OT8+Ozw9QEA/Pj9FRkJBQUBCQD4/Pz9ARkdEQUFBTFFOTkdBPztbhKtkOj5lZ2I/Pl9FR2tomF+XmK+SnLGLjX9snn3Db41rlbirkXuwf7V4SUdMS0pKTU1NTk5OT1BPUVBSU1OEVQxXKisrLCsrLC0sLS2ELhIvLy8wMTEyMjM0NDU2Njc3ODiEOQU7PDw9PYQ/CkBBQkNDRERGR0eFRhxHSElKSkxMT09QUVJTVVZYWlxfX2BiZGdpaWpqhGuEbW1wb3BycnI5Ozs7PDw9P0BDRElOVlxjYoeRU1tiWlBOTU1OTk9IcWJZjW+lmKZokV9eU059dFdXSEtQXGFjZGZqcnqBi42XcNmtqaGlmn6BYXBbcomLXVxvRkdISElISEhKSUlISUhHRkVDQ0REhEOFRB1FRURDQ0RGR0ZGR0hJSkpLTU1MTEtNTExOUVNTUoVTOVJRUlJPUFFQUE9OTk1OTUxLTEtKSkpJSUlKSUlISEdHR0ZHR0VEQ0JBQUBAQEFBQUA/Pj4+PT0+PoR7IH18fIGEhIOBgIGBgoWGg4GBgX56eHZ2dHNxcW9ubm9thGs8amtqaGhnZmNgYF5cW1lYVlZYVFFQT01LSUhHRkVFRENDQT4+PT49PTs7PHh5eHZ2dXNycW9vbm1tbG1shGsuamppaGdmZWJiYF9dW1xaWFdXVlVTUlNUV1hPT0pHR0VFQ0JBPz5EQkJJQ0hIRIVDBkRFRUVGRYRHbkZHR0dGR01STEdEQ0pYa2tfZWdtdn1+f399f398enRwb2xnYltWT0tMT1hfW1BFSldkampjW0lsUkxBQEBAQ0FBQEJDRkZJU1hUSkQ/PTw9PD08PDw7Ozs6OTg4Nzc3ODc3Njc2NTQ0MzMyMjEyiDEIMDEwMDAvLy+FLoYtgiyHKwQsKysrhCoGKSopKikqhimCKIQpBSgpK22wIcjMiLCji32W4+mpnL+hzLd6l+mYzKFZWVq/l6NcvKaNp4dXBlhXV1hYWIhZAlpZi1oMW1taWlpbW1tcW1tbhVwEXVxdXIRdhVwIXV1dXFxbXFyLWwVaW1paW4VaCFtaWlpbW1pbilqGWQNaWVmIWpBZCVpaWllZWVpaWopZAVqQWQZaWVlZWlmGWgpbW1tcXFxbXFxchl0HXl5eX15fX4RgGGFhYmJiY2RkY2RkZWZnZ2doaWpvbmxsboVwZnR1cnJycXFwb3BxcHF2dXRxcnF5fXt7dXFvZZS19oVba52ilWZjkmVpmpLYjra63afA5ZSqpJHXpuGAqoOk0si4lLuQyqJycHh/gIGDg4SEhYWFhoeIiYqKi4yNjo6PSEdISElJSYRKgEtLTE1NTk5PT1BRUVJSVFVVVldYWFlZWVpbXFxdX19gYWFiY2RlZ2doaWpra2tsbW5ub3BxcnJ0dXd4eXt9fX6BgoSHioqLjpCTlZWXl5mZmpycnZ6goaKkpaemU1ZWVlhYWVtcXltdZm1zdnOis2x0enZvbm1tbm5uYpN/cbaTQsKjv4K5cXVmZqeVcXFeYmyDi42PkpWdpKeusLB+9cW8tLmzmKF8jnaTtLV5epVkZmhoaWloamxramprampoZ2ZlZoVlFGZmZWVlZmZkZWVlZmdnZ2hqa2tshW04bG1tbm9zdnV0dHZ2d3Z1dXZ2dXV1dHNzcXJycXBvbm9ubWxtbWtrbGtramppaGhoaWhmZGJhYWCFXwVgXlxbW4VagLKzsbGxsLK1t7e2tLGysbG1tLCurKyppKKhn56cmpiWlZSUkpCPj42Mi4uJiIeFgoB/fXt6eHZ0dHRxb21samhmZGNiYF9eXl1bWVlYWFdWVVRUqKiopqWjo6Cfnpybm5qZmJeXlpaVk5OSkY+OjYyKiIaFg4GAfn18fHp5eHh4Fnp5dHJvbWtraWhnZWNjaGRnbGdqamWKZIhlWWRkZWluaWNiYGVxgIF2e3yBiI+Pj46NkJCNioaDgH97dnBsZWFhY2twbWRbXml0eXh1bV6dhoJ3dnZ1d3d1dXZ2eHh6goaEe3ZzcG9wcG9ub25ubWxra2pqhmkLaGhnZmZlZGRjY2OFYgJhYoRhC2BhYGBgX19fXl5ehF0QXFxbW1paWltbWltbW1paWoVZBFhZWVmHWApXWFhXV1hYWKniMcxqVKH75NiDqW590LzP78CDuYJKmtGsqqbPer6arUVJ97m7vr6/v8DAwcHCwsPCw8OFxAHFiMYMx8jHyMjIycnJyMnJhMqEyxLMy8zMzMvMy8zLzMzLzMvMzMyEyw7Ky8rKysnKysnJyMnIyYnICcfIyMfHxsbHx4TGC8XFxsbFxsbFxMTFh8QEw8TDxIXDBsLCwsPDw4TCBsHCwsHCwYXAhb8Ivr++vb6+vb6EvQ68vLu7vLy8u7u6u7q6u4u6Cru7uru6u7u8vLuHvIC9vb2+vr6/wMDBwcLBwsLCw8TExMXFxszLycnKzcvMzMzP0M7Ozc3OzcvMzM3O0dHQzs7P1dfW1tLNzLXrsf2VjMHq/tGpoNiEgJWE3J6mgJVneYRNTExCao2US1ZLanhpWk9tUomyu7bM4ujs7e/v8fLz9PT29vj5+/v8/v///4CAgYKCgoODg4SFhYaHh4iIiouMjI2Pj5CQkpOUlZaYmJmam5udnp+goaOkpaaoqamrrK2usbGzs7S1tre5urq8vb/AwcPFx8jJy8zO0dLW2Nvb3t/j5Obn6ers7e/w8fP09vf6/P3+gIKCg4SFh4mLi4KDjpqcm5rV9Jiip6SfnlGen5+foInJrJffmbR9uZn0iYGDlu/NkY6Bhpi9x8rN0NXc4OHn6d+X3t/a0evoxbuCrZu33d+gn8uLjZCQkZKSlJWVlJWVlJSTkpGQkpKRkJGEkkORkZKRkJCRkZKTk5OUlpeYmJiZmZqZmJiZmpygo6KhoaKjpKSjo6OioqKhoqKhoKGgn56dnZ2cm5ucm5qZm5qZmZiYhJYZlZOQj42MjIuJiomJiYaFhIOCgYGBgP/+/YT7gP39/Pv49vX09PXy7+zp6Obh39za2NXT0c/NzMvIxsTEwcC/vbu6uLa0srCvrKqppqSkpKCenJuZl5WTkpGPjY2Li4mHhoWEg4KBgID//v38+Pf29PPx7u7r7Orn5+Xj4+Lg3t3c2tjW1NPQz83MysjGxcTDwsC+vb6/v7e2s7GwGa+uq6mnpqWopqaqpamopKOioaCgoaCgn5+EoFyfn5+enZ2eoaSgm5qYm6axsqmsrK+1uLi3t7a4t7SyrqyopqOemJSPjY2PlJmWjoeJkZmdnJiThvTj39fW1tXW1dXU1NXW1dbd393W0s/MzM3NzcvLysvKysnIx4XGCcXFxcPDwsHBwIW/Bb6+vr2+hL0FvL28vLyFuwm6uru6uru6urqGuYW6HLm6urq5urm5uri5urm5urq4ubi6uLm3t7eu9P+EfRl+fn59fHx9fXt9fX1+fn19fH5/f39+fn5/hH7/f/9/lX8Ofn19fn9/fn5+f39+fn6EfYZ8hH0EfHx8fYh8A319fpl/54CRgYKAjIEIgICAfn59fX6EfwKAgYSAkIERfoCAgIGBgX9/gIGAgICBgYH5gtOB/4CKgPh/An59AgIEACx0zcqbwuq94tWBPEY7aE9OX4t4eWFfcHJuccdrc4DOr3kxLCgnJygnJygnJ4cpBCoqKSmSKgQrKyoqhCsCLCuFLAIrKoQrgiqEKwEshSoPKSkpKioqKSkqKSkpKikqkCkBKospBygpKCkpKCiGKYIohikEKCkpKIspASqGKQEomCkHKikqKSoqKoQrASyEKwEshy2DLoUvhDAMMTExMjIzMzM0NDU1hDcCODqEO2I9PUBJSEZHUFJYTUlIREFBQkFESEtOUmJkcXZmW1pWT0lEWli1QnVRfZ1vbl5gVW2DqYyDkJyMfHqotNTnk39uxcZjf31wfcPbdY54Q3BGR0xNTU9OTk9PUFBQUVJSU1RWVYUrBywsLC0tLC2GLgwvLzAxMjIzMjI0NTWEN4A4ODg5Ojo6Ozw9Pj4/P0BBQUJDREVFRkZGRUZHRkdHSElKTE1OUFFSU1RVVlhaXF9fX2BhZGVmZ2doaWpra2xtbm9vcHJzcjg5Ozw8PT4+P0FCRUqFTFZSm3CFVF9nXFNRT05OTkxHl5FpWJuSo3p0ncVsZn5hZJyNZ2hVXHFvbB1yhIaQlpGvjYmKinuslJaDXVFrWZlSY15kgUdHSIRJF0xLSUlISEhJSEdFRURFREVERUVFRERFhEYMRUZGSUhISEpMTE1PhVAfUVBQUVNUVFVVVldVVFRWVlNRUlFPUE9PT1BQTkxLS4RKEElJSUhISUhHR0dIR0dIR0aFQwtEQ0NCQ0NBPz49PYU+gD8/f3+AQUREh4WGhoiGh4uJhoSCgH57eHV1dHR0cnBvbm5sa2ppaGdmZ2dnZmRkYF9cWllYV1dVVFRRT05NS0lJSEZGRUNEQ0FAPz49PT08PTx7enl3dnVzcnBvbm5tbm1sbGxtbGxqamhoZ2RjY2FgXl1eW1pZV1hWV1RUVVRUI1FQTkxJS09LRURBPz89PT08PT8/QEFBQkJDREVFRkZGR0dIhkczSEVGTUxJREJOVERKT1VZWmNwd3tmXmFpbnFzcGllXlhTT01MT09KQm08TFxhXldKZU9ChkEUQEFAQUJJTVlfVUhBPj08PDw7OzuGOgQ5OTk4hjcLNjY1NTU0NDQzMjOEMocxhjAZLy8uLy0uLS4uLS4sLCwrLCssLCsrKisrK4kqAikqiykDKiotJart69LZ8/Dq8pRbb12Rdmt7lpeUhZ+zqKeY2pevk+TbrFxaWFeGWAFXhFmHWoRbAVqFWwZcW1tcW1uHXIVdBV5dXV1eiV0BXoVdhVwJW1xbXFxcW1xchlsBWoZbglyEWwVaWltbW4daAVuRWgNZWlmMWgFbhloBWY1aBVlaWllZkFqEWwpcXF1cXF1cXV1dhV6EX4VgB2FhYmJiY2SGZW9naGhoaWpsbW1sbW1ucHh3dnZ9f4N7eHd0cnJzc3R4eXx/i42Ym42EhIF6dGiGdNZhq3i026GZiYZ9nK/1xrSYuK+YpsTd+fy6sIPu94GXmJCJ3fqLsqxonWJzgYODhIWGhoeHh4iJioqLjI2OR0eFSAZJSUpKS0uETIBNTU5PT1BQUVJSU1RVVldYWFhZWlpaW1xdXl9fYGFiY2NkZWZoaWprbGtrbG1ubm9wcXNzdXd4enx9fn+AgoSHiouMjY6QkZKUlpaXmZucnp6goqOjpaenU1RWVldYWVpbXl5fYKZja2G5h59rd35zbGpvbW1taF3AtoJxrKOmkjyNyNx+gJt3ecexhYdtdZWVlJmoqrO3ssielJCRjr6jrZ10ZYNtwGiAeISyZWZoampqa25ta2tramtsa2mEZ4dmAmVmhGcMZmZmaGlpamttb29wiHEGc3V2dnd3hXkfenx5eHd2dHN0c3N0cnBvbm5tbW1sbGtra2psa2ppaIVpD2dkY2JjY2NiYWFiYV9cW4lagLS0tVxeXbm4t7i3tra3trGwrKyppaKfnp2cmpiXlpOTkZCOjYuJiYiJh4aEgoB+e3p4d3Z0c3FxbmxraWhmZGNhYV9eXl1bWllYV1ZWVVVUqqmnpqakoZ+enpybmpmYmJeXlpWUkpKRkI6MjIqIh4aFg4KAfn19fXt7enp5eHV0EnJwbW5xbWlnZWNiYmFhYGFhYYRiBWNjZGRkhGWCZoRlTmRlZmNjaGdlYV9ob2BmaW9xcnmDiYt7dHZ9gYSEgX14c21oZWJhYmRfWZ1TX25ycGpgloN4eHd3d3Z2dXV1dnd7f4iMhHp0cnFvb29uboVtBmxsa2tqaoVpCWhoZ2dnZmVlZIZjBmJiY2JiYoRhhWCCX4ReBF1eXV2EXIZbA1paW4RajFkDWFlZhlgBVTjQqGPN5NzOi659g7KOwKmTnWVfRIro44uwiFiUx0dTiJ6esL6/v8DAwcHBwMLDxMTFxcXGxcbGxoXHg8iGyYTKgsuEzITNAs7NhMwGzczNzMzMhM0DzM3NhMyFywLKy4TKB8nKysnJycqEyYjIiMeExgHFhMaHxQrExcTEw8TDw8TEh8MIwsPDw8LCw8KHwYTAhL+EvoS9A7y9vYS8irsHvLu7u7y8u4m8hL0qvr69vr6+v7/AwMHBwsLDwsLDxMXFxsbHycrJysrKy83S0tDR1tfb1NLShc+A0NLV1tji4+zu5N3c2tXMsMyW9aL7lqi0yKCnno10gOm5oGWFalZkbGJ8dFVtToWKS2dcU097gkRt5ai5jcPo7O/w8fL09PX29/j5+vr8/f+AgICBgYKDg4SEhYaGhoeHiIiJiouLjI6OkJGSkpOVl5eYmJqam5ucnp+goaOkpaeAqKmqq6ytrrCxsbO0tra3ubq8vb7AwcLExsjKy83O0dPV19na3d3g4eTk5ujp6+3w8fL09vf6/f7/gIGCg4SFhoeJi42OiuaImID1rtWWpKqclpafnp2eloHz5KGGpZt0hKDd04Wp1Jyb7+24vZSgy87P1eDj6e3p+sGsn6Ga5M0V3suKgZ6I64SUm6z1jI6QkpKTlJeWhZUil5aUkpOTk5GRkpKSk5KSkpOTk5KSkpOUlJSWmJmbm5ydnYaeKqCio6OjpKSmpqWmp6enpqSioqGhoaKioZ6enJycm5ubmpmZmZiamZiXl4SWFZWTkY+Ojo6NjYuJi4mHhYSDg4KCgYSAgP/+/YCAgP79+/v69/b29O/t6ujl4d7b2NbU0tDOzcvKxsXEwsC+vbu6ubi1tLGvrKqpqKalpKKgnpuamJaUk5KQj46Ni4qJh4aFg4KBgYCA/v38+vn49vTy8O7r6+ro5+Xk4+Lh393d29nX1dTSz87My8nIxsXDwsHAvr++vLm4GrezsrGzsKupp6Wjo6KioaGgoqGgoKCfn6ChhqA8n5+fnp2dn56cm5+dnJiXnqOXmp2hpKOor7K0qKKkqausramkn5mVkY+NjI2Oi4X7gYuVl5WQiO/h2tjXhNaE1BnV2Nvi5d7W0tHOzczMzMvJysvLysrJycjHhMYbxcXFxMPDwsLCwcHAwL+/v76+v76+v729vby9hryJu4S6I7u6urq7uru6u7u6urq7urq6u7q5urq6ubq6urm4uLe3trSmAX6GfQp8fHx+fn59fn5+hH2Ffgd9fn5+fX1+/3//f5Z/DX5+fX9+fn19fn5+fX2RfIJ7h3wFfX1+f36Uf+mAjYEHgIGBgYCAgIyBhH8IfX19fn9+fX+EgAJ/gJKBD4CAgYGBgIGAgYCBgIGBgf2CBoGBgYKCgsqB/4ABf4eA+38CAgQAI3bZzaTIoqHriI/Dy6ZmxLWys7PLcnGEdLaon6xttb6/aHEqhygRKSgpKSopKSoqKSsqKiorKiqEK4QqiyuHLAEthCwNKysrKisrKywsKywrK4wqgimFKoQpByopKSopKSqFKQEqhCkFKCkpKSiFKQEohSkFKCkpKSqNKQEqhykJKikqKSopKSkqiikBKoQpBCopKimHKgspKiorKisrKyorK4Qshi2CLoQvhTB8MTExMjIzMzM0NDQ1NjY3ODk6Ojs7Ozw8Qk5OUlFdcXBoYlVNSUVDSVJbaHaEhIWLk4R4a2+Ch4ZrTVeLz6aAZWtUl3NVhq2abmqac3m2nJ5ob5aQl6O0cJ65c7vRnKWLj79vbKNnQExNTk9PT1BQUVFRUlJTVFRVVysrK4QsBS0tLi0vhC4sLy8wMDAxMTMzMzQ0NTY2Nzc3ODg5OTk6Ozs8PT0+P0BAQEFCQkVFRUZFRkaER4BJSUpLTU5OUFJTVVdYWFlcXWBhYmJkZWZoZ2doaWpra2xtbm5wcXFxOTk6Ozs8PD0+QEFESEx/ZFKlinWNVlFNTVhhV0+FTUh8ZGGgtol3gJNrWGOohItof3WHbWpeiYyIfIqyZmK3uW6jm66xuGtprJx5ZGyGUoOLTkpJSUpLSgtLSktMTEpJSEhJSYRGBUVFRUREh0U7RkdHR0ZHSUtKSkxNTk9QUlNSU1RWVFRVVldYWVtaWldXV1lYV1RUU1JSU1NSUlBOTU1LS0xNTExKSUiERxVISEpJSUlLSkdGRkZFRENDQUFBQD+HPk5APz9+fn+BQkVFRYuKjIyJjIyLiYOAf31+enl2eHl3dXJwcG9ua2loZmVlZmVnZGRiX11bWllYWFVUU1JQT09OT0xKSUdFQ0NCQkFAPz6FPYB5eXh3dnd2d3Vxb3Bvb29ubm5tbGxraWpoZmVjYmFgX19dXFtaWVdXVlVUVFNTUU9RWGJtZF5NR0RAPj09PTw8PD0+Pz9AQUJCQ0RFRUZGR0hIR0ZGR0hGSE5QSURCQUBAQD9BRENIWWBmYVtbV1xlcnZ1bWdgWlVST0xKR0U6XyFeOkxZWFFEYU5JSExDQUFCQUNCQ0ZRT0tQVEg/Pj08PDyEO4U6Ejk5ODg4Nzc3Njc3NjY1NTQ1NIQzAzIzM4QyhDGGMIMvhy4JLS0sLSwrKywshCsELCsrK4UqBCkpKSqIKQUqKisrLSal8d663sDB5pq29fnWiejb2OLx7piTpIXWsqvRg9C34IWlWVlZWIVZAlhZh1qFW4hcAl1chF0HXl1dXl1eXYZeBF9fXl+FXgNfXl+FXoZdhFyCXYhcCVtcW1tbXFxcW4RcAltcj1sBWotbC1pbW1pbWlpbW1taiVsMWltbW1paW1tbWlpahluGWgdbW1taW1taiVuEXAJdXIVdhV4EX19gX4VggmGFYgNkY2SEZW9mZmdoaWlqa2xtbGxtbnJ7fH9+iJeVkIuBfHp2dnqAhpCcpqenrbKmnZKVo6emj2xwfMPPloWUd82kd7zn0pyS1JmV3srRi4m9lrPM6YvG54Xg6rO/sbX6mJzakWF/g4SFh4aHh4iIiYuLjIyNjo+ESIBJSUlKSkpLS0xMTE1NTU5OT09QUVJSU1RUVVZXWFhYWVpaW1xdXV5fYGBiY2NkZWVnZ2lqamtrbGxtb29xcnJzdXd4eXt9foCBgYSGiYuNjo6RkpOUlZWWmJmbnJ2fn6CipKWmU1RUVlZXWFlaW11fYmWaeGHBoYylbGlgYGx4c0hspGldjXx0t96cj5W1f2p4w5uleIWFoYV/bKKnpp+qy29tz890qae1uNB6e9K5kHqCo2SksmhnaGlqbGtra2xubWxramtra2mEaAFnhWYBZ4RmHGdoZ2dmZmhqa2ttbm9xcXJzc3V3d3Z3d3h5e3yFezZ8f358fHl3dnd3dnZ1c3Bvb25ubnBvbmxsa2ppaWlqamtqa2psa2hnZmZkY2JhYGBgXl1cW1uEWgtbWlmzs7S2XF9fXoS7gLi5uLa0rqupqKekoZ+fnpyal5aVk5KPjYqJiIeHh4aEg4F+fHp5eHZ1c3Jxb21sa2ppZ2VjYmBfXl1dXFtZWFdWVlVVqqmoqKampaOgn52cnJybmZiYl5aVlJORkI+NjIuJiIeFhYOCgH9+fXx6enl4d3V0dXiAh4N9b2pnZGJhFmBgYF9fX2BhYWBhYmNkY2RkZWVmZ2eEZVJmZGVpbGZiYF9eXV5dXmBfYnB3e3dycW5yeYOGh396dG9rZ2RiYF5cU5SSUmBsa2ZbkoN/fYB5eHd3dnd3dnmCgH6BhHpzcXFvcG9vbm1ubW1thGwEa2pqaoRpDmhoZ2hnZ2ZlZWRlZGRkhmODYoRhhGCEX4ReB11eXV1cXFyLW4Vai1kFWFlZWVg3rXZfRk4wOHQ8jn5pY4CxlLTF5m98UEovSUU2RDdUWnxBtbS9v7/AwcLCwsHExMTFxsbGx8bGyITJA8jJyYTKBMvKy8uEzAHLhs2EzgLNzoTNhM6CzYXOg82FzA/LzMzMy8vMy8rLy8vKy8uHyhbJysrJycnIycnIyMjHyMfIx8fHxsbHicYCxcSFxYnEicMKwsLCwcLBwcHAwYTAhb8Evr++voa9hLwBu4+8Bb29vL29hL4Lv7+/vr/AwMDBwsKGwwbExcbGx8iFyoDLy8/V1tjY3+vp5eHZ1tTS0tPZ3uTu9vb3+//27+bo8/X0362WYJy8aVmAjdnystCngIh3vo5zoXmFW0puS0xcdE9jeUt9imNsXFrQutz5pZHg7e/w8vT09fb3+Pn5+/v9//+BgYGCgoKDhISFhYaHh4eIiImLi4yNjY6PkZKTk4CUlpeYmJmZmpucnZ6goaKjpqanqKqrq6yur7CxsrO0tbe4uru8vsDCw8TGx8nKzM3R0tTX2dzb39/h4uPl5+jq7O7w8vL19ff7/f+AgIGDg4SFhoiKjI6Rkc2egP7RtNuYlIaEkqGhmt6UgrOZiLrojLG24puRm/St25l7hNCplyiK0tjZ1t/6hIP//oi7xtDW/4SH596qm6fWgdTpi4yPj5KTk5OVlZeXhJUMlpaUk5OUk5OTkZGShJNbkpKTlJOTkpOUlZaXmZqcnZ6en6Cgo6Sio6SlpqemqKiop6mrq6qpqKWkpKSlpaSkoZ+dnJydnJ6enJuamZeXl5aYmJmYl5eYmJWSkpGQjoyLioqJiIaFhIOCgoSBgID+/v//gIGBgP7+/fv49/X08evo5uTh39vY19bU0c/My8nHxcLAvb27urm4trSysK2rqainpqSioJ6dm5qZl5WTkpCOjYuKiYiHhYSDgoKBgP/+/fz6+ff38/Dv7uzr6ujn5eXj4eHe3dva19XU0tDPzczKycfFxMTCwb++vru6E7m5u8DHwLyxrKmlpKOjoqCfn6CEnwaenp+goJ+EoFShoJ+enp6fnZ+hop2ZmJeWlpSTlJaWl6OmqaWioJ2hpq2urKeim5eUkI2Li4mHgPXygIuTko2E7OLd293Y19XV1dbW1dfe3Nnc3tbQ0M7OzMzMy8uFygXJyMjIx4TGB8XFxcTDw8OEwgbBwcHAwcCFv4O+hr2HvAO7vLyNu4O8iLsBuoS7Crq6ubm4uLe2tawBfoZ9AXyFfQF+hn2EfoR9Bn59fX1+fv9//3+WfwF+hn0Pfn1+fnx7fH19fHx8e3t7i3wDe3t8hH0Efn59fpN/6ICOgQOAgIGEgIiBCYCBgYB/f35+foR/C4B/f3+AgH9/gICAh4EFgoKBgYKEgQyAgIB/gICBgYGCgYH/ggGChIGEgsiB/4CCf4aA+38CAgQAI3bpxo+MnMa+08V9dtG+4MZytJu4eNfSkn24j56fpKSnr1MrhikMKCkpKioqKSoqKikrhCoDKysqiCsHLCsrKywrK4gshC2GLAgrLCssLCssLIYrhCoGKysqKyophCoJKyoqKikqKSorhSoVKSkpKiopKioqKSopKSkqKSkqKikqhCmDKokpDioqKikqKSkqKiopKiophSqCKYoqASmPKgMrKiqGK4Ysgi2GLoIvhjAGMTEyMTIyhDNyNDU2NjU2Nzg4OTo7Oz9DS1pkandveHyAgnVYUldOXGxvg0xSVVJOT0uPTZeXmJBzYmBSl+PweHWLUIFTlamajJmrVnmHsqqtbHGRzLKvkrNzls2UuW2nhIWZeZlhO0xPTk9QUVFQUVFSUlJTVFVWVisrhCwELS0uLYQuTy8uLzAwMDExMjIyMzM0NTU2Njc4ODg5ODg4Ojs8PD0+Pz9AQEBCQkNERUVFRkVGR0dISEpLTE1OT1BRVFRWVllZW11fYWJiZGVlZ2hoaGmFa2psbm9xcnI5OTo7Ozw9Pj9AQ0NGSnqMcHSHpXdtpFpbWFhUTkpssnd32HBdcJiUZmJmeJOYqXiMt6zGdp2mlZWmmpGgYF6is2ZoY7K0n2h7xo6acY9RUlZQTUtJSkxMSkpJSktMSklISEdHhEYFRERDREWERixHRkZGR0hIR0dJTE1NTU9RU1RUVlZXWFpZWVlaXFpcXl5cXFtbXFtYWFZWVoRUfFNRUU9OTk9PT01LS0lIR0dHSEhKSUhISElJSElKTEpIRUJBQUJBPz49PkA+PkBBQT98f4CCQkRGR0aLjY2Njo6MhoKAfn59fXt4eHh2dHJxcnFubWtpZ2ZlZWVkYmJhYFxcXFtbWVZUUlFPUFBQT05MSkhHRUREQ0JCQD+EPUI8PXl4d3d3eHl3dHRycXFwcHBvbm5tbWxra2lmZGRiYWBfXl1bW1lYWFdWVFRSUFFRX3J/c15QU1tNQz8+Pj08PDyFPVY/QEBBQkJDREVGSElHR0ZFREVEQ0JAQD4/Pj9CQD9AQERPTUZHTE1PUlltdHlxZ2BbV1RRTEQ/O2RYWmR0TlRRRj93ZFhQS0RCQkFDSExVXGZdTEZCP4Q9BDw8OzuFOgQ5OTo5hDiGNwY2NjU1NDWFNAczMzMyMTIyhDEDMjExhDCCL4kuBy0sLCwrLCuGLIQriSoBKYUqAyssNCaf6s2kmIunvvbklY/w7OPsjeS83o7p36KTtJuzpZKkt75xWVpZWYhah1uFXAldXF1dXVxdXV2IXgRfXl5ehl+CYIRfhF6EXwJeX4Veil0BXIRdh1wBXYdcAV2KXAlbXFxbW1xcXFuGXAFbhlwIW1xcXFtcW1uFXIRbBFxbW1yGW4NcjFsJXFtbXFxbXFxbhVyGXYVeC19fYF9fX2BgYWFhhGJ8Y2NjZGRkZWVlZmZnaGhoaWlqa2xsbXB0eYWNkZyVnaGjpJuFgIR9iJWXp1tgYWFdXVqvW7Ozs6yPfXhqr9n4hJG/dLNz0ujMwMTOd6/F/8rJiI27/cHRr9+RvOWe04jSsrDLpL+KWX2DhIWGh4eIiImKiouMjY2OjkdISIRJAUqES4JMhE2ATk9PUFBRUlJSVFRVVldXWFlYWVpaWlxdXl9fYGFiY2RkZWZnaGlpamtsbW1ucHFxc3R1d3h5e3x9f4GChIaHiYyOjpCRkpOUlZeYmpubnJ6en6GkpqZTVFVWVldYWVtdXV5gYpWog4ibtYqGvWpubG1nYF99vIZ+1INsjayxfHg5e4+rtsiJlr7D6IWzvKSrurWwvWprvspucGu7vrF1hOqltYeqZmdua2hpZ2ptbWtra2xtbmxra2pphGgPaWZmZWZnZ2hnaGhnZmZnhGg9amxtbW5wcnN0dXd4eXp8e3x9fX1/f4CAgH+AgYJ/fn17eXl6eXh4d3RzcXFwcnJxcG9ta2ppaWpqamtqaYdqgGxqZ2NhYGBgX11bWltcWlpcXVxas7S1tlxeYGBeu7y8urq5trGuq6mop6WjoJ+fnJqYlpeVkpCOjYuJh4eHhYOCgX98e3p6eHZ1cnBubm1sa2ppZ2VjYmFfXl5cW1pZWFdXVlVVqampp6empqOioZ+dnJubmpqYl5aVlZSSkI6NI4yJiIeFhIOCgH9/fnx7enh4dnV2gI+Yj39yc3htZmRiYWBghl8EYGBhYYRiCGNkZWZmZWVkhGNEYmBfXl1dXF1fXl1dXV9oZ2FhZmZoaW9/hYmCe3VwbWpmYltXU5iOkZajY2hlXFakk4yEf3p5d3d5fH+Ei5OMfXl1cnGEcANvb26GbQhsbGxra2praoVpAmhnhWaFZYRkgmOHYgRhYWBghl+EXoNdiFwJXVxcXFtbW1pbhVoBW4RaBllaWVlZVzaogEcwKTpGSElaKytRd3ZQOJWNXT5WSDAsSTY2Qk5oX1iEr7u8vr/BwsLDxcXFxsfHx8jIycmEyg7Jy8vKy8vLzMvLzMzNzITNhM4Lz8/Qz9DPz8/Qzs6EzwfOzs7P0M/Phc4Ezc3NzoTNA8zMy4XMDcvMzczMy8rMzMvLysuHyoLJhsgIycjHxsfHx8iEx4bGBcXFxsXGhsUGxMTFxMTEhsMFwsLBwsKEwQi/wMHAwMC/v4S+Bb2+vb6+hb0OvL29vL29vLy9vby9vb2FvoW/gMDAwMHBwcLCwsPDw8TExcXFxsbHx8jJysvLzdDU3eHl7env8fPz7tzZ3Njg6Or4gIOFhIKDgP2A////8sKel5u5qrBGjvKgzpH338GOdnaC+tnPi5VbV3N/aWhbe0hfgVhqSHZXXHhqv7GF1urt7vDz9PX19/n5+vv8/f7/gYCBgIKCgoSEhIWGhoeHiImJiYuLjI2NjY+QkZGTlJWVlpeYmpqam5udn6CioqOlpqeoqaqsra6vsbKztLW3uLm6vL2/wMHDxcfJy8zO0NLU1dja3d7g4eHj5ebo6+3u7/Dx9PX4+fz+gICBg4OEhYeJi4yOkI/Q7qmXwOGsqv6Ql5OTWYqBgZvUq5fqp5DEu8awpKzE6O71pYqI09NlyeXQ2+jl5O6AgfL7g4aB4OjaiovqstGl2YWIkI2Mj4+RlJSTk5OWl5iWlZSUlJOSk5SUkpGRkZKUk5SUlJOShZM4lJWXmJmbnJ6goaKipKWnqKenqaqrqaurrK2rrK2trKuqqqinpqalpqWjoaCfoKCgn5+dm5mYl5eFmIWXhJaAlZOOi4qKioiGhIODg4KCg4ODgP7+//+AgYKBgP7+/Pr59vTw6+jm5OLg3drZ1tTS0M7Ny8jGw8G/vbu6ube1s7KwrqyqqqinpKKgnp2ampmYlpWTkY+OjYyKioiGhIODgoKAgP79/Pv7+fj18/Lv7e3q6ejm5uTj4uDe3NvY1tQm09HPzszLysjHxcPDwMC/vby7ur/N1My+tLS3rqmlo6OhoaCfnp+Lnlefn6Cgn56enZybm5qZmJaWlZSUlpSTk5KUm5mUlJeXmJqeqa2wqqOdmJWTkIyHhID38fH1/4yQjYWA++7n4d7a2NfW19vd4ePp5NrW09DPz87Ozs3MzMuFyoTJEcfIx8bHxsbGxcTEw8LDwsLChcEGwMC/wL6/hL4Dv76+hb0GvLy9vLy6jLwFvb28vL2GvAO7vLyEuwi5ubm3t7a0kwF+iX2CfoR9BX59fX1+hH0BfId9AX7/f/9/hn+HgAJ/gIh/In18fH19fX59fn18fHx9fX59fHt7e3x8fHt8fH18fX18fHyHfQF+k3/ogI6BBICAgH+FgIeBCoB/gIB/gICAfn6EgIR/B35+f35+f4CGgRGCgoGBgoKCgYGAgYB/gICBgf+ChYKEgYWCyIH9gIV/hYD6fwICBAArvqHBwcXiyK7V13O0oODbpJjK3aaSxMaFybXYl5TUj85ZLCorMTV8NispKYYqCysqKisrLCwrKywshCuGLAErhSwOLSwtLSwtLS0uLS4tLS2GLIMthyyHKwEshCsMKisrKisrKisqKisrhioBK4QqAysqKYcqASmJKgEpiyoBK48qASuFKgYrKyoqKiuKKggrKisqKisrKocrhywULS0uLi4vLi4vLzAwMDExMTIyMTKEM2c0NDQ1NTc4ODc3ODg8OzxASU5baWN9k5GNfnlvbmdtamh0hIaNTFBOToqJjlRZW1xYjqhxiIZof8iKrZ1zY4mSv6trdpdteU2QspylcXmGg22wl4+0hcV9oouvjcF7ZmtuQE5QS0pOhFIMU1NUVVZXVysrKywshS2CLoUvgjCEMYAyMzM0NDQ1Njc3Nzg4ODk4OTg6Ojs7PT4/QEBAQUJDQ0RFRUZFRUZHSElKS0xNTU5QUVJTVFZWWVpcXl9hY2RkZmdoaWlqa2trbGxtbG5vb3BxOjs7PDw9Pj9CQ0hTVE2YjJV0uqaoZoiGdmtfXZqJcXuCimSqZGxZSWCXaVxVhDXkp7a9fMWQlMSnyL3FurKim5aqt2Zqs5+7vZl8zaKrZltaVVRRTkxLTExKSEhJSUhIR0ZGR4RGCkVEQ0RFRkZGR0eFSD1JSktLS09SUlJTU1ZXWFlaWlteXl1dXGBhYWJjYF5fYF5dXFtaWlpYV1dWVVNTUlFSUlNRTkxLTEtLSkpJhEeHSXBIR0ZFQ0JDREI/Pj4/QD8/QEFBQD9AQUFCQkVHRo2Njo6OjIqFgoB+ent7e3l6eXd2dHR0c3Bta2ppZmVjZGRiYmFgXl1dXFtZWVVTUE9QUE9SUU9OTEpIRkVDQkJBQD8+Pj49PXl5eXp7eXh4d3RzhXEwcHBvbm1tbWxpaGdlY2FgX15cW1tbWFdXVlZVU1JQUlxvcVpTX211ZlREQT8/Pj4+hT2CPoRABEFBQkOEREhDQ0JCQ0NEQkA/Pj8/Pzw7Oz09Q0NAQUhWVE9cZWt3dmpgWlRVU1BHO2JcXGVhZUZOTkF5fXZiT0lGSkxJREhRWGNnWEhCQD6FPRM+Pjw7Ojo5Ojo6OTk6OTk5ODg4hDcFNjY1NDWENIQzBDIyMjGFMgMxMjGEMIcvhC6DLYQsES0sLS0sLCsrLCsrKywrLC0whisELjAvYijSwdbw+N6lrejti9C38+XErPH6vaHU0ZjSzvCrn+2k8XdZW1teX8FfhFuFXAZbW1xcXVyFXQ5eXl1dXl5eX15fX19eXoZfiWACX2CEXwVgYF9gYIVfhl4GX15eX15dhF6EXQReXV1ehV0BXoRdAVyEXQRcXV1dhFyLXYhcA11cXYZcAV2IXANdXF2EXIJdjVwBXYZcA11dXIVdhl4FX15fX1+EYIJhhWKCY4RkhGVxZmZnaGhqamlpampsbG5xeHuHkIygsrCuoZ6XlpGVk5GcqamxXF9eXqurrmFlZWZjp9WOp6J/mdur0M6YgLnR79uKk7SUqG3O8de2jJaqp4vcrLXfkuCTzrjhr/SripmpYoCDe3B7h4mJiouLjI2NjpCESApJSUpKSktLS0xMhU0STlBQUFFRUlNTU1VVV1dXWFlZhFqAXFxeX19gYWJjZGVmZ2hoaWpqa2xsbm9wcXN0dXZ3eXp7fX6AgoOFh4qLjI6QkZOUlZWXmJmam5ydnp+goqWmp1RVVldYWVpbXV5iaWlftqSof9q4wG2QkomCdHW9poaLnKhzs3iDa1x3uYFuZJL9nsO9i9uSqt2tzsnSzMi+ubUgxM1tcL2jx8aeh9auu3FrbWtvbmxra2xta2pqa2prammEaAxnaGhnZmVlZmhpaGiGaR1qa2xsbW9yc3N1dnd5eXp6e32Af3+BgIGDhYOEg4WCG4F/gH9/fnx7eXh2dnV1dXZ2dHJvbm5vbWxsa4RphmoLaWloZWRjYWJiYF2HXIBdXVtaWltbW11eYF69vLy6uri1sayrqKalpaWioZ+enJqZmJeUkY+OjIqHh4aFg4KBf318e3p5eHZ0cW5tbGxsa2tpZ2ZlY2FfXl1bW1pZWFdXVlWqqqmpqaempaSioJ+dnZ2cm5qYl5aWlJSSkI6Ni4mHhoSDg4F/fn18e3t5eBZ2dnZ/jo98dn6KkIFzZmRjYmFhYGBghF+CYIVhCGJjY2NkY2JihGEEYmBfXoRdQ1taWVpaXl5cXGJta2VweH2Hh350cGtqaGVeVJaTkpmVl1xjY1imqaOUhH99fn98en2Dh5GUiXx2dHFxcHFxcXBxcG+FbQtsbWxsbGtramtqaoRpBWhnZ2ZnhGaDZYVkCmNkY2NjYmJiYWGEYANfX2CEXwFehV0GXFxcXV1dhlwGW1tcW1tYhFsHWlpaV1pYkjV5cUtXT11APUNGIDU0YmY3M1qwVztBRTNLRDs4PFA3Xpetubmdm/KXvcPExcXGxcfIycnKyoXLA8zLy4XMCs3Mzc7Ozs/Oz86EzwHQhdGE0A3P0NDPz8/Q0NDR0NDQhc8Lzs7Pzs/Ozs3Mzc6HzQLMzYTMB8vMy8zLy8qEy4bKA8nJyoXJBsjJycjJyIjHFMbHxsbHxsbGxcXGxcTFxcTFxcTEhcMpwsLCw8LBwcHCwcHBwMDAv8C/v7++vr69vr29vr2+vb2+vb2+vb69vr6JwIPBhMKCw4TEBMXFxsaEx4DIycvLy8/U1t/m4vD9/Pry7+vq5unn5u72+P2ChIOD+vv9hoiIiYfl+5GjuI2og19t4M6Ropu24WlJY57wht21hHlbV1FTRXJXV3BYZU1wUHlenIan0PmX4enVs9bz9ff5+vz8/P7//4CBgYKCg4OEhYaGhoeIiIiJiYqMjI2Nj4CPkJCRk5OVlJaXmJiampucm56foKKipKWnp6mqq6yur7CxsrO1tbe4uby9v7/BwsTHyMrLzc/Q09TW2dzd3+Di4ubm5+nr7u7v8fPz9fj7/P+AgYOEhYaHiYuNkZaViP3c0Zf83duLuLy1rZqf/N2rrs3hksaZs5OHqPGfhIKq/yN5n4eItGqt8c/z8fr29O7s6fX7g4XcutzYs5rluN6IhouKkYSSCpSUlJKTlJWUlJOEkgmTkpOSkZGQkZOElIaVLJaXmJqbnZ+goKKjpKWlpqioq6qsrK6trq2wsK+tr7CvsK2traytqqmop6amhqQMo6CdnJydm5qamZiWhJcZlpaWlZWUk5GOjYyMi4mGhISDhIODg4SDgYaAgIGCgP/+/fr49vLv6+nm4uDg3tza2NXT0s/PzcrHxMPBvry6uLe1tLOxr62rq6mopaOgnZybm5qamJeVk5GQj4yLioiHhoSDgoGBgP/9/fz6+fn39fPw7u3r6uro5uXl4+Df3dzZ2NbT0dDPzczKyMfFw8LBwL6+vLu6v8vKvbe+EsXIvbOqpaSjoqGgn5+enZ6dnoWdhZ4EnZ2dnISbCZqZmJaWlZSUkoSRZZSTkZGVnJuVnqWnr66lnpmVlJKPioL49PT39PeGjIyD/v767uHe3N3c2tjb3+Pq7OPY1NPRz8/Ozs7Nzs3Ny8rLysrJysrJycnIx8bGx8fGxsXFxMTDwsLBwsHCwcHAwMC/v8C/hMANv7++vr29vLy9vb69vou9g76GvRG8vby8u6etu7q5uLi3o6en1Yp9AX6NfQF8hX0Dfn1+hX8Bfv9//38Bf4SAg3+FgAF/hX4KfXx9fX1+fXx8fIR9B35+fnx7e3uEfIZ9g3yFfYN+kX/pgI6BhIADf4B/h4GHgBR/gICAgYB/f3+Af359fX1/fn5/f4uBC4KCgYGAgIGBgICB/4KPgsiB/ICGf4SA+n8BfgICBAAwm6u/sKz02sjLvM2pjNW0nISKx5impoyCfX7Fzsy8ldKFLy4tc3B5cDMrKyorPzUshCuRLAItLIYtBCwsLS2ELgktLi8vLi0tLSyILQssLS0sLCssLSwsLIQrAywrLIkrCSorKisqKysrKocrhCqCK4oqgiuFKgErjyqFKwgqKysrKiorKoQrhCqSK4UshS0DLi0uhS+EMAUxMDIyMoQzhDRvNTU1Nzk9OTg4OT1CPT9GXF1Ya3iNlIyKhn1ydHB0gIKCiYWBh46PSo1OVVhYWFdQjWZ7r6aFoamcj6xma2+oWK9kjpOeu65dcpFtnLl1Y3dxjIybcthyc4HCi4RpSWxTO05PbnRDTlNSU1RUVVZWhCuELActLS4uLi8vhTADLzAxhDKAMzQ0NTU2Nzc3ODg5OTk6Ojo7Ojw+PT9AQEFBQkNDREVFRkdHR0hISUpLTE1NT1BRU1RWVldYWlxfX2FjZWZmaGlpamttbW1ub3Bub3FxcTk6PD09Pj9BQkRHSlNZY1yTZHmKbpWEipmKgnBlU3bNjpxufn1fg52HdnGDd6vEh6I0jbi81ompc6TExGxsx7ezvL1ob2vMdW+ccqDJsc3WbGheWlhUUE9MTExJSEhIR0dGRUZFRIhFNkZHR0hJSUpKSktMTVBSUVJUWFhZWltcW15fXV9hX19gYGNlZmVmYmBjY19fXV9dXVxZWllXVoVVBFNSUVCETgRMS0pJhEhVSkpJSUlHRkZGRUVEQ0VFREJCQkBAQEFAQEFAQUFBQkRFRUVGjY+Rj4+NiYSBf35/fnx9fnx7fHp7eHd2c3Jva2tpZ2ZlZGNiYV9fXl1cW1lXVlRSUYVQHk9OTUtKSEZFREJCQUBAPz49Pj15e3t8fHp7enh1c4RyNnBwbm9tbm1sa2loZmVjYWBeXVtbW1lXV1dVVFNSUE9OUFBRWGNkXFxTSERFQUBAPz8+Pj0+P4U+UT8/QEFBQkFCQkFBQkJCQ0FAPz0+PTs8Ozo5Ojo7OTpDVGpxcWdiaGxrYlxTT01NQmVWV1lcWFRycEBkW2RnblZQUVNVVUlDTFFPSkNBQD89PYU8BT0/Pzs6hDkDOjk6hDmDOIQ3BDY2NTaENIgziDKEMYIwiS8FLi4tLS2ELIMthiwHKysrLnFvLYQsBTBka3J0Kayyusizy6/G3eTsupPWpbyWnMuru8CTjoqB0LzdzKnyk1BdXZqUlI9dhFwMZVlbXFxdXV1eXl1dhl4CX16LX4VgiWGQYAZfYF9fX2CFXwReX19fhl4BX4VeAV+HXgtdXl1dXl1eXV5dXYVeBV1dXl5eil0BXp9dAVyEXQFeiV0DXl5dhV6FXwVgX19gYIRhhGIIY2NjZGVkZWWHZnRoaGpua2pqa25yb3F2h4iEkp2utKyrqKGYnJicpaenrqumrK6xWrBdYmRkZGNdqH+czcuhxsi+tb6Dk5bjcteFp6DF+OmBl8KMrOiRgJyUp6e8gPiQj6e7s7KXcJ53V3x6o6VmfoqLi4yMjY2PR0dISEhJSYRKgEtMTExNTk5OT05PUFFRUVJSU1RUVldXV1hZWVpaW1xcW1xdX2BhYWJkZWVnZ2hoamprbG1ub3BxcnR1dnZ3eXt8fn+AgoSFh4mLjY+QkpOVlpeYmZucnJ6foaGipKamVFVWWFhZWlxeX2FjaW1xZqdwh55+rpOSoJeRgntigdOggL5+fpFznr6nkYeaj8XPkbSgvsPri7Z9qsvPcHHXzcvR0G90cNR/eKh5ps+61OB2e3RzdHFwb25tbGtqamppaWdnZ2ZlZmdmZmdmZmdoaGhpa2trbGtsbW5wcnN0dXl5enx+fX1/f4B/gYOBg4OFhoiIh4WEhoaFhYSDgoSAf359Ant6hHkFeHZ1dXOEcRJvbm1ramppamtrampqaGdmZmWFYxBiYF9fXl5dXVxdXVxcW1tchV6Avb6+vLu5tK+sq6mpp6WmpaOjo6CfnJqZl5WSkI6MioiHhoSCgX9/fXx6eXd2dHFwbm5sbWxramlnZ2VjYWBeXFxbWllYV1ZWVamrqqqoqKenpaKgnp2dnJuZmZiYlpWUkpGPjo2LiIeFhIKBgH9+fHt8enh2dXRzdXR1e4ODfn0OdWpoZ2RjYmJhYWBgX2CHXwFghWGEYAxhYWFgXl1cXVxbWlqFWDJWV15sfYGBenZ6fn52cWllY2NanI6Pj5GOi6KhV5mQlpediYSFhoeGfXp+g4F+d3V0c4RxDXBwcHFzc25ubW1sbW2FbAVra2pqaoRpB2hoZ2dmZmaEZQRkZWRlhmQIY2NiY2JhYWGFYIVfAV6FXQFciF2GXAKhoIZbBI+VmY47RVI8SDlKPkU/P0IxKlVDPDMtREk+MjEsLSk9RFZHOnmWiK2rmnxnh5zBw8XEl4O5yMnKy8zMzM3MzMyHzQrOz8/Oz8/P0NDPhNCJ0oXRAdCE0QnS0tHS0tHQ0dGH0ITPA87Pz4XODc3Ozs3NzczMzc3MzM2FzAfLy8zLysvLhsoBy4TKCsnJycjJycnIyMmEyIPHhMYIxcXGxcbFxcWGxAXDw8PCw4XCg8GEwIi/Cb6+vr+/vr++wIS/BsDAwcDBwIXBCMLDw8TDxMTEhcUExsfJzITJgM3Pzs7T3+Dd5+77/vr59/Pu7+zv9ff4/Pr5+/3/gP2Dh4iJh4aB9rW1sNuVlnFURXyLjnLhiKhJTVh208Z1XZVddZVNN0lPTkxVQHhISk1gW3/Hu/eVgtbQ4dql3fb4+fv8/f7/gICBgYGCg4SEhYaGh4eIiImKiouJio2Nj4+PgJGRkpOUlZaYmJmampucnZ2fn6Gio6Wmpqipq6ytrrCxsrK0tLa3ubq8vb7AwsPGx8jKzM7P0dTW19nc3uDi4+Xm5+jr7e/v8fP19vj7+/+AgYOEhYeIiouNj5GWl5mHwoOfrom/sLPGwLqppICX6cv8nIy7mrj41sS6qJDh6JClNKSQt9Rtk4fP8/iDhP75+fz8g4eF/JKKtIK869Xs/Y2Yk5OWlpWWlZWVlJOUlJOTkZGRkI+EkUOSkZKTk5SUlZaXl5eYmJmanJ6foKOkpaaoqKqqqqmqq66srq6vr7GysrKwsbGxsLGvra+trayqqaqnp6anp6alpKOihJ+AnpybmZiYl5eYmJeXlZSSkpGPjo2NjYyLiYiHhoWFhISDg4KBgYCBgoGBgYD///37+ffz7uro5uTi4N/f3Nra19XT0M/MysfEwsC+vLq4trWzsbCurKupp6akoZ+dnJyampmYlpSTkpCOjIuJiIeGhYODgoCA//38/Pz5+Pf08fBF7u3r6ejo5uTk4t/f3NvY19XT0c/NzMvIx8XFw8G/v768ure3uLi5u8C/urq1rKinpaSioaGfn52enZ2enZybnJ2cnJ2chJtkmpqbmpqYl5aVlZOSkpGQj46Pjo2Okpypq6umoqWop5+alZGQj4j98/Lx8/Dt/v2D9O3x8fbm4uLj4+Ha2N3f3tvW1NLR0M/Pz87Ozc/Qz8vKy8rKysnKysnJyMjIx8jHxsbGxYTEFsPDw8LCwcHBwMHBwcDAwcDAwcDAwL+E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y9Pkh4zfrJvzUF0zjbsyLipGRjxXNisfJWlDSiYpSTsrLDJFLj80VkVFUDtUTlREk6W9ne9mdJSpyMeysMrLzc3Oz8/Q0dLR0dLS0tHS0tPT09TT1NTU1dTUhNUT1tXW1dbW1tXW1dbW1tXW1tXW14XWCtXW1dbV1tXU1NOF1ArT1NPT0tPT0tLThdIC0dKF0QTQ0dHRhNAKz9DPz9DPz87Pz4fOh82EzAbLy8zLy8uGyhXJycnIyMfHyMfGx8bGxsfGxsbFxsWFxAbDw8LDw8SHwwLEw4bEDcPEw8TExcbGx8fHyMmEyAbJycrKy8uEzIDLzc3O0NPU2NbV193b4OLn4+Tf397e3t3f4uXn7Pj59OjSpOvp1IycnnBYYYd7WGVpUWpQa1ZGgXxwi1FWWFZWW1V/akVHfkFMSYCKWGZbO2pYjsnsuYuAw3yFhc33/v//gICAgYGCgoKDhIWGhoeHiIiJiYmKi4yMjY6Pj5CRkoCTk5WWl5iZmZqbnJyen5+goaKjo6Wmp6ipqqutrq+xsrO0tba3ubq7vL7AwcPFxsjKzM7P0tPV19jb3uDj5ers6+7u7vLz9ff6/Pv90eSF7IHQh4mLjZGXoaq0rtiDkrhzqoq+gpye5NSzqcjP2brw+MWsnaCNh9rqnpK55sSG5oCdjZmag7+E0N7Rls3u9vn5+ObU6+eyzo6VooWtop78qbiUgeyVm5qWlJKQj46OjY2Oj5GSkpOUlpaYmJmbmpucnZ+gpaaoqaqqqaqusrKzsbO2uLi6vL27ubi5vL2/wMHDvr6/w8HBwcLCwcC/u7m3tLa4tLOzsrGxr66uraysqyWpp6Wlpqako6Ggn52doJ6bmZqbmZeWlZWVlpeZm5mVlZGMh4aEiYKAgYCA/vr18Orp5uXj4+Df3tzb2tjV0s7JxsXDwb+9u7q4trSysK+srKupp6WloZ+enJqbmZeWlZSSkpCPjo6Mi4mJh4aFhIODgoH//vz7+ffz8fHu7Ovr6ejo5uTj4d/d29nV1NLR0M/OzMvIx8XDwL++vbu5uLa2tLOxsa+vrq0XrKupqaenpqWlo6KgoJ+fnZybmpqZmZmEmAaZl5eWlpWFlD6Tk5OSkpCPj42Mi42Rk5CNi4qIh4WDg4KA//37+4CIhomQkYr26uXk5OXp9Pnt5+He3tnX1NTT0tHR0c/PzoTPCtDX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hDlcOjo6Ozs7PD09PT4+P0A/QUE6TJtnll5zQ3U/RTlUN0ygg3Z/rZqtpZeUmZySd1O7nH9ndoefoVaCfrZ2c5OvXoyOuauviYiv2MjB64C9k2qJkXZ7ZX9ntbOTRlSEKoArKywsLFc9X5mzqWthSS5VV1cvYHVYiH5qMjQ0NTY2Njc3OTo7Ozw9PT0+Pz9AQEBBQkNCQ0NFREVGRUZGRkdISEhJSktLS0xMTU5NTlBRUVRVVldYWlxfYmRlaWxtWWJ3g4hISm96i3imZpxjerufspSSuJdjeHZ2cZ2haOCJnCnyq8uvlWWsZYSveHhUXV+7q5GTe3fGsq/t5uWPg1VuZGVfWVx4kISEgoSAJXdUameHU2mEim5Tr6GDouaBX216g4xLVFRUU1BQTlBRUVJRUVKHU11UVlheYWRqb3x8eHZ3enuEhYiPk5aQ1ZWvm9uBj5nNkZbSo35zbmpowK6hnZyWjouMh4iJjYuHgoF+fXVzcnBvbmppZWJgYGFgXltbWlhXWFlbWlhVVldTUFFQT0+ETktNTEtJSExNTlJQTEpJSkpKTE1MSItOVG5vb1yjnKGYlJKRlZ+ps6qdpqKkqJ+Te3xzbGdkY2JgX11dXFpVU1JRUE9PT1BPT01LSkmISF5HR0ZGRURERENDRESFg4WFhYeLSlJbWFOei4J7d3Nxb21rampoZ2VmZGRiYmBeXl1bWVhWVFNRUE5NTEtLTElKSUlISElISEZGRUVFREVEQ0FBQEFAQD8/Pj4+PTw7hDx5Ozs6Ojo8PD1HUFRdZnZyY2ZWRTs8ODs5PkZSUEc/OT9NTUY/ZldUUVBaY2hBdUtKSEhHRURDQkFBQkJCRUtFRENDQUA+Pz8/Pj4/Pj9ESEE/Pz9BTmZuXE1JPz49Pj48Ozw7PDs6Ojk6OTo6OTk5Ojo5Ojk5ODg4NoQ1gjSFM4cyhDEWMDAxMjBfrKedipSVk3+if9qTr5fVi0DNuXzf6fKSg7Cai7ear5K6soqE5/WS6+XFp5Z3gIL2ht/b6qXXgrmo45qa8t/8sbPhirj0zdzZvNDGxenAY2VkhGUGZmZmZ2ZmhWeHaAZpaGlpaGmHaAFphWgBaYhoE2dnaGdoaGdnZ2ZnZ2dmZ2ZnZmeHZgRlZmVmimUBZJFlAmRlhWSMZYRkAWWFZAtlZGRlZGRlZWVkZYlkAWWEZIVlBWZm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ZmRjYmFfXl1cWllXVVRSUE9PTUxMS0pJSkpJSUhISEdGRkZFRUREQ0NCQkJBQUFAQEA/PT08PDs7Ozo7Ojk5Ojo7PEBQWWdybVtZSjw5Nzg6QUBBRUE4NDIxOkA/N0heVVRXU2lzc0FgS0lISEZERENDQUJCQ0FCR0xIRkNCQ0M/Pz8+PkA/Pz5DQz0+QEJFRkxMRj8/QUhIQz49PT0+Pj48PTw8OjuHOho4OTo7Ojg2NjU1NTQzNDM0MjIyMTEyMTIyMoQxFDIyY2++k8pqgX2Ein2ZpriSi/amPrve5uTd2JN7kYDYh7e4xML/4/ngwt6BpcCS7Y7E1/e8laeo3PWr6MGt+fvC9pGL6NmooqmdhqjsqZqJu7dhhWaEZw1oaGhnaWhoaGlpaWpqkGkBaItphWgPaWhpaGdoaGhnaGdoZ2doiGcGZmdnZmZniGYBZYlmCWVmZWZmZmVlZoZlEGZmZmVmZmZlZmZlZWZlZWaHZQdmZWZlZWVmjGUBZodlhWYDZ2hnhWiGaQRqamprh2yGbQlubm1ubm9wcHCFcYBycnNzdHRru5rNvoOtlf1jdZX4dmxtxNjrmru8jdrjx7H0mJnEb7SBiJWTld6kkqGW+cvfqaTIw86hl66RhtPY1sGh7bTzhpmkiKaCsnF9XIKNR0dHSElJS0tLbIz50p6tlGyZZKafwKqHr53Ie1NTVFRWV1dYWFpbXF1eX19gYIBhYmNjY2VmZmdnaGlqa2tsbG1tbW9wb3BxcnJzdXZ3eHh6e31+gIKEhIaIi42PkpWXm4aGhqOmqqNizGl0s3FpuYjWn8mFwuXhyqiBhYSwZpWIcHi1nqGQgZKfaru0yamIaG+LlGhoYbF54fPEvZqsiK+OcpFfopBnaaWsra6usCOxs7a3pZW5kJi9gXCOw56BgcaAfpC0XW1xdHZ0dHNzc3R1dYR0UHNzc3R1dnd6fYCGi5CUmp2io6SnqemGh4yUkpJneH2Cl5youWS2v4zJk5zR2LqBfnTX0cm+urixr6+usK2wqqefm5qWl5STj5CNioeFhISChH8BfoR9gHp4dnZ2dHFwcW9vb25ta2tramdnaGpqa2pnZ2VkZGRlZGRiYmlvdXFoxr+7u7i4tbSzsa6zuLW6vbmyq6mppJyVkIyKiIWDgH58enZzcXBubGtramloaGZlZWRjZGRjZGNiYWBf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eoZeWD1ES2d6ealcWoSeu/dsY0xHS0ZVWFFRXk5WW1FPTUlCPkhnV3KDsJemd36blpJ1dFBxdZWE36H1gYKCgoODg9raxs/QsrWyi5vngY+xkpzld2CI05GSk5SUlZaAl5iZm5ydnp+goaKjpKSmpqioq6usra6vsLCysrO0tLW2t7i5ury9v8DBwsTGyMnLztHS1NXY3N7g4+To55Ho5Jy3p9HUk4f4sJyXnZl74IP6i6bGhrOX5an+3aa/x6uQqZaG47u0xe6Hh8WJ+8n1vLDGk+Hqyc+7ZVfOis2LwcuA3Kjht73s7u/w8fP19vf55Z/VgfSOntigvbKWob6quqzdiJWZmpubmpucnJ6goqShoJ6dnp6fnp+gpKeus7rAzdvW0Nfb3emElqFVWVxkbnR5gIWQVVtfZWVpVrOJnI2nkpCMi4X/gPTu4t/b19fT1tTPy8rGxMTDwb66uLaxsK6ArKusra+trKyqp6alo6GgoJ+dnJubm5qZl5SUlJOTkZCSkY+Mi4qJiIiHhoWFhIOFhYWDgf359/Xz8fDu6ufm5OTk5eXn5d3a2tXOysbCv7y5trSyr62rp6WjoJ6dm5qZl5aUkpKQj4+Ojo2NjIuKiYiHh4aEhIOCgYCA//7+/f+Aho2Ni4mKhYODgfvs4t/b2dnX1tbT1NLPzs3MysfGw8LBvr27ubi3tbS0srKvr66srKyqq6qpqKempqako6GhoKCfnp2cnJuampmXl5WVlJSVk5KSkZKRkZGUnZufnJiYj4qJiYmIi4uJiYeGhIGBgICA/fn08/Xx8vTz8evm5OIJ4N/e3dzc29rZhNgt2trY19TW1tbU0tLR0tLT0tHR09PW2OHb193W0tLR09LQz9DP0NXS0M/Pzs7NhMwOzc3MzMzLzM3OzMvKysmJyB/HyMfHx8bGxsXFw46xb48tLD9LTFtWP0BCTCstM1pNBH18fXyEfQJ+fYV8Bn19fHx9fIR9Cnx9fXx8fHt8fHyEewR8fXx7hXyFfQl8fX1+fX1+fn7/f+F/IH58fHx+f359fn5+fX1+fX18fHx9fX18fX19fHx9fn59lnwGfX18fX59hHwLe3x8fX19fn5+f3+HgAx/f399fH19fn9/fn6HfQJ+f8WAFH5+f4CAfn6AgH+AgYGAf31+f35+hH8fgICBgH9/gIB/f359fX59f39/gIGAf3+Af4CBgYGAf4R9An5/hIAFgYCBgYCOgQuCgYF/gIF/f4CAgISBpoKDg4qEh4UEg4SEhIaDAoKDzYLHgYWAioHogO9/BX59fX59hXwJfXx8fH19fXx8AgIEAEKEl5XojsCNdq7Zq8Gyqb/Eleq2iNLx5YDGlJnqxbfetIqFkIOck7mYrsN2e8ylm7KKh5Cvj3p6jHq167VqNDIzMjKLMw80NDQzMzM0NDM0MzQ0MzSFMwcyMjMyMjMyhDMLMjIzMjMyMjMzMjOEMhQzMjIzMjIxMjEyMjExMTIyMTIxMoYxCzAxMDExMDEwMTEwhDENMDAxMDExMDAxMDAxMIkxBjAxMTAxMpYxDTIyMTIxMTEyMTIyMTGEMgMzMjKFM4M0hDUJNjY2Nzc4OTg4iTmEOgg7Ozs8PD09PoU/gEA/QkNEO1eAcWdrV5yWqmhdpJa6aZvSd3qr3n6bZXyydpVfQ2t6ql2YlJOKfJ+fvI+jYYCJ3W1vfaTKoeGzoJGOhGdpbXOEa29gb2lRVFUqKiorKyssK0ePamOQcm5MSWTJdIaHgXtlZWhvZDY1NjY3Nzg4OTo7PD0+Pj9AQEBCB0FCQ0RERUSJRoBHR0dISElLSktMTE5OTlBQUlNUVllaW15hYmVnamxvcmihp5uwko1UY2ptaH2eZGGqtHp5u3Cfa2eFgWN0mpiRVpKIi6uGoI+6qcauo156j5BuWl1oWpq2s6eZ646Wrs6Cco1bgGJIfH17e3x8fH1+fn9Ubop1WGyGsGGnZZdVUnR4fn5ESE1RUlNRUVJPTlFTXGJZVVNSUlFTU1NWWV1ianaFlJ6Snsp+2qLAb4nWkqbDvq3Jg5b/mLDknfeA8o2ws6ujoYaTe2xpZ2OrsKmlk4mEgH18fHl2cWxsaWhmZWBfXFxcXVtaWllZWFZVU1RTU1JTUoRQgFNSUlBOT1FST1JWV1JOSklJSktLS0hHSExYVVdPTZiTkpCQkJGQj4+MjZCSk5CWnqCgnJ2VjomBfn55cm5saWdmY2BeW1hWVVVUVFJRUE9OTU5OTU1MS0pLSUpKSktKSUlISEdFRUWLh4mNS1ZaX1tXWVhbXliWeXFsamlqamxrGmpoZ2ZmY2JgXltaWFZWVFNRUFBQTk5NTExMhEsaSkpJSUlISEdHRkZFREREQ0JBQUBAPz48OjqIOYQ6fzs9PUFAQEA8ODc4ODw8Pjo6ODk0NDo8PTZgWl1lOTlXVFpYUU1LSkdIRkZFREREQ0JCQUFCQ0VEQUJBQUBAQD4+PkA/PT4+QEFEVW5ti4lZQ0JES0xDS0RDYmtLRkNAQD49PDw9PD9DQ0I/Ojk6Ojg2NjY1NTQ0NTQ0MzMzMjKEMxg0NDU2eXPRz76SrY6OxbSZkbLkpbqplOBJfoiI74fLlIC25abhyrLP3qTewY/Nx9x7ypuC5sTF9M2ZjnuDqJnOpsDbhojLqaCteYmDwZOGhKWPv+XYmmdoaWhoaGlqaWpqaYhqhWsDamtriGoEa2tqaoVrBWpra2prkGoDaWpqjmmFaAFnh2gQZ2doZ2doaGdoaGhnaGdnaIhnBmhnZ2doaIhnAWiMZwdmZ2dmZ2Zmh2cGaGdnZmdmhGeFaIRpAmpphmoEa2tsbIRtAW6GbQxubm9ub29wcHFxcXKEc4B0dHR2eHhjhqGOnayKxMrpm5Pb0u6FzfWUj9HZnuCPpPOLq4dglqHzhNvJzdO57/Hey9SCsK/8hoaMm8Ci9Lq1sJyNgIWKhKeIi4CXi3B8iEdISEhJSUpLaMWahqeEh2xxj/yOpaenpIeDhpSVVFVVVldYWFlaW1xdXl9gYWFjY4BjZGVlZmdoaWlqamprbGxtbm1ubm9wcXJzdHV2dnh6e3x9foCChYiJi46RkpWWmJudicjGs9OzomZ2foB3i6hnabS+hI3neKN0dqCQbIGzpZpeno2YoY26osTJ4LrBcpKnqoJvcIFttOLhxab5mKrG4JyHp3ChfFylpqiqrK6vsYCzs7Vsi7KZbYaey3TAeLtqZ56qql5nbHFydHJzdHJxdHZ+hHx5d3V1dXZ3d3l8gYiPm6m2wLS+2n7lwtl3hbRvfI+Tj55icsaLoMqG1nTYg7GwraejipSDd3V0b8zQysO0rKiioqKgnpqWkpKRjo2Kh4WDgoGBf31+fXt7end2dmJ1dXR1dHFxcXJzc3Jwbm9wb21wcnJuaWZlZWVkZWViYWFjbGlrZWPEwL68uru6uLe2s7Kzs7Kws7e5t7S0rKeinJmYlI+MiYaEg4B9e3h1c3JxcG9ta2tqaWhnZ2VlZGNiYoRhHWBgX19eXV1bWlu1s7O1X2ZobGhlZmVnamSznpeVhpI6kI6NjIuJhoWDgYB+fHt6eHd2dXNzcnFxcG9ubm5tbWxsbGtqamloZ2ZmZmVkY2NiYmJhYF5dXFtaWotZMFtbXl1dXVpWVFVVV1hZVlZUVFBRVVZWUZiVlJtSUpCOko+JhoOBgH9+fn18fHt6eYR4P3l7end2d3Z1dXR0cnN0dHNyc3R1d4SWlquphnZ0d3t8dXp2dY2Te3d2c3JxcXBvb29xdHV1cW1tbm1samppaYVogmeEZhxnZmZlZWRlYqqI7fXcm7mpmsnEnX6x4qG/tI/aYTE5NlgzTTc2TVRSSENEUlRaglE1YHFVMFFBNmxiUVlKLzpKM0A9ZUZVwnFieE5MUUNHUplebzthV1yAw+PP2Nnb29vc3N3c3d3d3t7d3t7e397e397f39/e3t7f3t7f396G3wng4ODf39/e39+E3gTd3t7dhd4J3dzd3d3c3dzdhdyE24XaB9na2drZ2dqE2RDY2NjX19jY1tfX1tfW1dXVhNSE1YXUhNMF0tLS0dKE0QrQ0NDP0M7Pz87OhM0LzM3MzMzLy8vKy8uEygHLhcqFywPMzMuEzAjNzc3Oz8/PzofPAc6Ez4DO0NHQ0dLS09TT09TV1NXW19eprnZku/vIz5SPrcrY+sRftr5MP1BVTp1+a5VadoiUwWN6PlZaYYNec290YWg9T06APjo+SWZWsXuAsmNZbV1eREw/RUuOubDO8oGCgoOEg4OCjOq/gnFvlZOnoJhLV1dqdGtsaMT6kpOUlJWWl4CXmJmbnJ2foKCho6SlpaaoqKmqrKyur6+vsLGysrS0tbW4ubq8vL6/wcLExcfIy83P0dPW2dze4ePj5OnpwuWvpejboYqntbikweqQiObxmYe/j8yMhaW1i5/R18yAz53Ot53ZyKXFwarwlM7w9LGpocak/e/qxYC3b5ikwZmr44Cb4ayC6err7u/x8vT19veMsO7OkLG4zZHsmPyMh93t74OOlJiam5ubnJuanaCmrKakoaGhoKGhoqWnrLO4xc/Z39ji9YX85vWBiqJcYm1zdnxJU5l8ja1ut2S9e7WxsKqolZyPhoaEgfL07+jc1dHNy8zMysfCv7++u7m2srCvrYCtrq2srKupqaeko6KgoqCgn52cnJydnJuZl5eYlpWVl5aSjouJiIiIh4aFhISEiYeGgoD++vn39fLx7+3q5+bk4+Lg4ePi4N3c1dDNyMXDwLu4trSysa6rqKWjop+enZuZmJaVlJOSkZCPjY2Mi4qJiYiIh4aFhIODgoCA//38/oCBhoeIhYKDgoOEgPLk3tzZ2dfW19bV09LQz83LycbEwsLAvry6ube2trSzs7Gwr6+urayrq6mpqKenpqWko6OioaCfnp6dnJuamZiXlpWUlJOTkpGSkZGRkJCRkZKRkZGOi4qKiouLi4mIhoaDg4WFhYH++vj8gYH08fDu6ufm5D/i4d/e3t3c29vZ2NjW19jY2NbX1dXU09PT0tLT0tHR0tLT1d7p6Pj23dLR09bW0tbS0uHm1dLR0dDOzs7Nzc6E0A7PzMzNzczKysnJyMnJyIXJHsjHyMfHx8XDw7HAPlBUQDBUTEFQSUgvS15IX3FfWQt9fX18fXx9fn18fIZ9Fnx9fXx8fH18fH18e3t7fH18e3x8fHuKfAx9fXx9fX18fX18fX7/f+N/D318fX5+fn19fX5+fH18fYh8C318e3x8fX9+fXx9hXyFewR8fHx7hXwMfXx8fX18fH19fHx8hH0Efn9/f4iACn9+fn18fX5/f36JfQJ+f8WABn59fX5/foeAH4GAf39/fn2AgIB/foCBgH+AgIGAf4B/fn5/fX59fn+FgAqBgIGBgH5+fn19hH4Df4CAkIEJgICBgYF/f4GAh4GkggeDgoKCg4ODhoSChYSEBYWEhYSEjIPLgsmBhICLgeeAhH+CgOh/gn6EfYZ8CH18fH18fH18AgIEADuQoJJ68MXo4JOlp76Pl9iwwrqXrqWYi6rX3LiWzrPbm9Wewpmdgevhm5mNYZSx67aXqtqC1nPXVom3o4cziDQQNTQ0MzQ0NDU0NDQ1MzU0NIUzEzQ0MzQzMzQ0MzQ0MzQ0MzMyMzOEMogzBDIyMjGIMg4zMjIyMTIxMTIxMjExMoYxBzAxMDExMTCPMQQyMjEyiDENMjExMTIyMTIyMTIyMYQyCDExMjIyMTIxjTKFMwI0M4Y0gzWENgE3hTiEORA6OTk5Ozo8Pjs8PTw9PD4+hEBRQkNERURCP1Z6hZJ2fGB7kraLY4DBlHewiWbXjnGGi3RidZ56TICZkYFhu6mhYWeKqJKcq7K2xXaKn+ihjfLgkY+Fp2CTknZrqa1pdm45MCwqhSuAWVRwn5HMkG2Df1l0oYugeGttbcB5UDQ2Nzc3ODk5Ojo6Ozw9PT8/P0BBQkJDQkNFRUZGRUZFRUZGRkdHR0hISUpKS0tLTE1PUFFSVFZWV1pcXV5iZGdoaF6LrYVyepB4zZuccISGaV6DrV6BjsrAoo18bWlymoG0e8JYYYCcln+Ad5yOjLl/eF+FlISMYGFxi2NhrWxxyaew5av5zZKMX4FmbXx6eXl7ent7fH1+ZpZRc2mBmnq3aVN/jHNKREZGSkxPUVJRUVJRT1BUWFxgZFpWVlZVV1hZWl5janR8iZioqrNvb32MyLlllu+mj4bF75H51qDPkKCA4ovOuqmmpJqAkHluZGK/tLKtpZqShoF+e3h1c21qZ2ZkY2RjYF9dXFxaWllZWVhXVlRYVlVUVVNSUlRXVlVTU1JTVVdWV1dWUk5MTExNTU1KSU5SVlJPT02Tjo6NjIqIiYmKh4WFh4mKiIqQj5CPj4+Lh398e3hzcm5raGdjYF5aWFdWVlRVVFMTVFNRUlNTUVBPT01NTEtMTExLTIRLNUlHSUtHR49JT1RZXVVYV11eW6aPfXFsbW1tbGxtbGpoZ2VkYV9dXFlZV1VUU1JSUVBQT09OhU0ZTEtLSkpKSUhIR0dHRUVGRURDQ0JCQD48O4U5Szg5ODk5Ojs6OTo8PD5BVmRdV0I+SVNGODU8Q09eYUtJPjM0P0JEQ2BUVlZSUE5LSklIR0ZFRUZHQ0NDQUJCREREQ0NDQD8+Pj0+PoU9Kz5BS2FzhIpvUE9MU2pWTU5JWWRjXE9EQkFGRUZOTmBoX01COzs6OTk4NzaFNYQ0hDMbNDQ0Nn+DfYPElMGzetq7yuyOo761g7KLmIanQJywpILEuu/7nqqwzKCa6a+9wJrEkXyPs+jYrIrBv+el4avZoKeI9umgoJV5tbzXtZWz4ovTiPJpm9zIVWhpaWmGagdrampra2tqhWsCbGuEbAJrbIdrCmxrbGxra2xsa2yQawFqhGuFagFphGoDaWlqiGkOaGloaWhoaWloaWloaWmRaIVplWiMZ4ZoBmdoaGdnZ4VoB2lpaGlpammFaoRrhGwFbW1ubW2Ebl9vb29uZ2ZwcXFycnN0dXR1d3h4eXh2b4y5uNe4w4+grfvHl7H/wKXXsYT7mpvDwaSIn6SwbrTUv4+J/+rhkJHL57+20en07YGWqseeldf9s65+yXqsr4+N1uaTopVPS4VINUlKkoqm2cb7mYarsYag0azIlIWJh/KYblBWVldXWFlZWVpcXV5eX2BhYmJjZGVlZmdoaGlphGqAa2xtbW5ub3BwcXJzdHZ2d3l7fH2AgYOFh4qLjZCSlJeSe7rbqY2SsZDmtLiIoZ97a5i/Z4iT49PFp4R8hY+vlMOL4GFojKmlhYGlm6nOlI5unK+cqXN2iqh5dsOAhNPTrvTB++esrnSifY2lpqiqrK2vr7GzsYfCaZaDna6J0nuAY5qtlWVcYmRpbG9yc3N0dXRyc3d7f4SHf3t7enl7e3x+goiRm6atuMfIznV1fIbh13GVz4V6d5++csy5lLyIlnXQg8G0qaqlnJSDeXJv3NHOzMS5r6ihn6CfnJiUkI2NioqJiIaCgoGAf318fX18enl3eXd2dnd1c3R1d3d1c3IlcXJzdHN0c3FtaWdnZmdmZmRjZmlsaWZlY8C9vLu5trSzs7KvroSsgKurrq2sq6qppaGcmZeUkY6LiIWDgH57eHV0c3JxcXBvbm1sa2traWhoZmVlY2NjYmFgYWBgYF9eXF1eW1y3XF9iZ2pjZWRpame/rqKYlZSUk5OTkpGPjYyLiIaEg4GAfnx7eXh4eHZ2dHRycnFxcHBvbm5tbWxsa2pqaWhnZ2dmDWVlZGRjY2FfXVxbWlqIWTNaWVlYWVpbXWx3cW1dWWJqYFVTV1tkb3FhYFdPUFhYW1qXjo+Oi4iGhIKBgH9+fn19fnuGeQh6enh4d3Z1dIRzhXIzc3V9jZyorpeAfnyCk4N8fXqGjo6IfnZ1c3d3eH19ipCKfHRvbm1tbWxqamppaWhpaGhohmcaZmZgl7G3tria572E9cbW55+jlbGLvIWDeodbPzkuLnRSUFNBQks9MEdKNU5NOUFlSD9LXG5gP05TZDxDM2ZUTz5ed2NnbZDDcWdmTnKwb6iT4YWc8/GY1Nja29zc3d3d3t7e397f39/e39/f4ODg39/g4ODf34TgiN8M4eDh4ODf3+Dg39/gid+E3gHfhd6G3QPc3N2F3Anb29ra2tvb2tmE2gXY2NnY2YXXg9aE1YTWFdXV1tbV1dTU1NPT1NPS0tLT0tHS0YTQgs+GzoXNhcyJywHMhcuEzITNb8zOzs7Pz87Oz8/Q0M/Q0M7P0M7DraDN0dLS0tPU1NTV1tfY2NjXw97Mdo6O6ppmWqGbhGCKd4TJeUJ/TkxYelpLaWjbndyrVEQ0bGVjQU1ld2ZmaWt1aj0+SWhKSWl2kLdSuZtyZUpDXWBNy+aA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PDs7Pzs4Nzc2NjU2hTUBNIQ1GTmDw7WxaHG2l5N2sai8qNDJt7zh6bKHlM88z5X16rnAoavUhuXW0dvJo66m04GRoenS3KyZtc7Fwty2k46aspLp4822/WySoXDF8pKIdICQq1ZeXWZohGoCa2qFawJsa4pshG2LbAFthWwBbYtsB2tsbGtrbGyNa4hqDWlqamppamppaWlqaWqQaQVoaGhpaJRpg2iGaYtoDWloaGhpaWloaGhpaGiGaYpqBGtrbGuEbIBtbW5tbW5vbm5vb2+0oI5pcXFycnJ0dHN1dnZ3dnZ2cIO7lP2HhpigqpDx9b+IgoSlz9i62oWuqbHLrp+p2Wrk8+fc1fqH2ZOKkIO9tNjvkN6tjIun/IfI9LXk++HE56fliqmer5lTV5OQSYqGSklro62P65Pc8K2zp3u4pJuEyyG+yoyIdFRWV1hZWVpaW1xcXV5fYGFhYmNjZGVlZmdnaGmEaoBrbG1ub29vcHBxcnJ0dXZ3eXt9foCBg4SGh4mLjZCSlZeZgrKXwsHau6ffn6JYpKXBq4qmi3WUetz4ydqd0p6Y2Y/HjK15hYKcvnqamsiNea9ZY2KCv6Zsc36isKG4mMfPndWAoJd2jo+hdqOlpqiqra+wsLG1pZ+nvLSafojnxG3AkZt0bmlkZmpsbnBycnN0dXNzdXZ4e31/goSEhIF+fn+Ag4eOmaWpt8zN1+N1dHh4d4W2gJPRoqPPkqnP2dK70N/SyNrdtdfLnY+Ie3DccNTSxby0raejp7e6pJaSkY+OjImGhYOBgH9+fXx8hH5VfX1+gYV9eXd1d3h5end2c3Nyc3V1c3BvbmloaWppZ2ZmZ2lpaGdlaGW/u7i3tLOwsK+urKqoqKqqqKeop6aloaCenpqYl5STkIuIhYOBf317eHZ1dIRyAnBvhG1LbGtramtqZ2dlZWRkY2JiYmFjYF5eXWdqYWlwcWtnZWRkZmS7r6mhmpiXlZaXlpWTkY6LiYeFhIOBgH18e3p7e3h3dnV1dHNzcnFwhG8Wbm5tbGxramppaWhnZ2ZmZWRjYF9cXIRahVlFWlpZWVlaW22Hl6GZjXpvZndtXVNYanV0bl1YVFBPUFKYlZGOjYyLiYeGhIOCgH9/fn5/fHt5eXh5eXl6enp4dnV1dHRzhnI0c3R5goSEjI6QjYmMkJCIgoCDiI+OjYd9gIeDfoKCkZqMe3NxcG9ucW5sa2pqaWpqamlpaYVoGmdieYOo5oyiv6ifgriqssvtwbSx19+zjJnDR0YsS1M/LjQ/PydJP0ZDOCw4OUIzRkFTR0FcV1qXXmp4RTwzYWxEdYh9gdmItoNOmbN+X4W5m/KdnrnQ2drb3dzd3t/f3t/fheAG4eDh4ODgieEJ4ODg4eHh4ODgiOEI4uLh4OHg4OGH4Abf4N/g4OCF3wLe34jehN2F3IbbhdoE2drZ2YXYD9fW1tbX19fY2NjX19fW1oXVI9TU1NPU1NPT09LS0dHQ0NDP0M7Oz87Oz87Nzs7NzMzMzczNicwIy8vNzM3MzMyFzQbOzs7Nzs6EzwHQhc8QzfDRh7PR0czM0dLTztPW14TWbMS2uVWGR0aHdFtFbJ9+UWGu0p9ua4ZIWktcZ2FaifCUpWlsW1RmN3RNRkVAaFlkaDldSkJCUH1HgI9rmK/tYnldektXduLziIr08IHl14SBmdjDlfFbhaetzKmFcU5MRH2AimKnspGVlZaXl4SZgJubnp6hoaKjo6SlpqenqKqrrK2trq+wsbOztba2t7i6uru8vsDBw8bGycrNz9DT1NbZ3N3i5OfpwNuWhqGCi2LlyteE9vX3/cXuxZPKouTmsMl9uWBavY7ZY7CasarL0HWYlKWnnf2Clpaz3tyjkqjD4dDBinjLdWZVfr6frcTggJ/l6Ofq7O3w8fL09uDV4P3zz4F28uf8wdGZk5GLjZGTlZiampqcnZycnqCipaeqra6vr6ypqaqqrrO5xM7T3e7u9f6AgYWFhY2lZ3fDqafHgo7Hzsu6x9HJws7StdPJopiSiYD+gPXy59/Z0c3M0d7azcG/vrq4uLWysa6vrKyrBKyqq6yEqxmqqautp6OhoKGioqKgnpybmpmampiVk5KOhIyAiYiHiIiIh4WDhIL8+fb08u7s6unn5OLf3t7e3NnY1tXT0M/My8nGxMG/vbq2s7Gwrquop6WjoaCenp2cmZiYl5aVlJOSk5GPjo2Mi4qJh4eHhoaEgoKBh4iDiIyLiISCgYGBgPbv6uLe3dva2drY19XS0M3LycfGxMTCwL69vLsxurm4tra0tLOysbCurq6trKuqqqmnp6alpKOjoqGhoJ+enZqYl5aWlJSTk5OSkpKRkoSQQJGcr7i9t7Cim5WemI6GiJSbmpWKhoSAgICB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ent7fX+Eh4aHg4CAgYSJjpegp6ywtrvH1nt+enuFosXIj5ucnaSp0nmQ49134nZ/fdC5raCPgXp2c+Pg29K4raqnrKyvqKSblJGOjYuIgIR/gICAfn18fHt8fH1+gIGCgoB9e3t5eHl3eHh2dHNycG9wb21ramhqbnJqaGZmZ2doZ2RhYsG7ube1sbCtq6uqqqqnpqakoqChoKCenJqZmZiWlZSTkYyJh4SCgX9+e3l4dnV0c3NycXBvb25tbGxra2ppaWhoZmZkZGNjYmJhW2BgX2NpZ2hxcHJtamxlY7uvqqakoJ2dm5ylubqruq+WiYqQh4SDgYF/f35+fXx7eXl4d3Z0dHNycXBwb29ubm5tbWxsa2traWloaGdlY2JfXVxbW1pZWlpaWVmFWjNbXX6iq6ihmpCGfX6CdFtXZm5sXllZUFGeVFSimZGPjo2LiomIhoWEg4GAf35+fHt7enmGeAl2dnh3dnV0c3OEcitzc3R1dnh3eYKRkJ2dkIJ7eICBipScl4+MkpOOhoCHkIN9dnJwb3N1dW5thGuFaoRpG2hoZIt42vytX13ClZOL8ZGc0vHs0HrOkpqvpkM1TEY+PShIQz0xKTtFQDY+UjlAZjpFREZSNF4xa0BDcGQ7O1B1mLNnwpbJt5CIupH476G+rYyanN7U29zc3d7e39/fheCE4QPi4eGF4gTj4uLjhOKC4YTiBeHh4uLhjeIO4eLh4uHi4eHg4eLg4OGE4Ijfht4e3d7d3dzc3N3c3N3b29zb29va2tna2trZ2NjY19fYhNmE2IXXCNbV1dTU1NXVhdOE0gXR0dDQ0ITPBc7Pzs7Ohs0LzMzNzczNzczMzcyFzQLOzYfOBM/Pzs6Iz4DIjJ28sJmqgNv6wLSyyazU1dXW19KgyoJ7gWpIYHtZb2NzsGObi7mBZGNXelVPXU9VZUeFu3xiaEc5UWFTY4BiWlZQYWVTQF5gTU5xc0tVa356p05NYnpodPSizIuKmrC+loTe+I+t7q92d2N+YaxrikxESFqh3Yygwu2UlZaXl4CYmZqam5udnZ+goqKjpKSlpqanqKqrrKyur6+xsrO1tba3t7m6vL2+v8HDxcbIyszOz9HT1dja3eDk5urAiJLdh31/iGeP9pODgd2mwJaQupSB8b9io3qAemx23pufypSpoMuwxnF9OuGdoLn2x4yZy/+tgMCZoJvVl3CBPUdZc4Dw0o+GtcPm6ejs7uzk8vLr2s622qPN+eCsmOOImuGBk5CQkJKRk5eYmpubnJycnaGjpKWmqa2xsbKtq6usr7O4wsvS1tre4+z3hYmHh46huL2YoqOjq67McoXY0WzTbHBzybatpZmNhoSA//r58NvTzs3T1djSzse9vLy4uLKurAOsrKuEqoCoqamqq62trayqqKamo6KioaCgnpybmZiWlpWSkY+NjpCSi4mHh4iHh4WDgYD++ff18u/t6efn5OPi393c2tjV1NTS0M7MysnHxMTCwb27t7Wzsa+tqqmnpaSioaCenZyamZmYlpWUlJKRkI+PjYyMi4mJiIeGhYSDgoWHhoeMi4CMiIWHgYD38Ozp5uPh393e4+7v5O7m1szLz8jGxcPCwcC/vbu7urm5tra1tLOysK+ura2sq6qrqamop6alpaSjoqKgn52bmpiXlpWUlJOTk5KSkZKRkJCRk6i/xMO9t7GpoaOlnIuIkZaVi4eGgYD+goL/+vTy8O7t7Orp5+bj4xni4d/e3t3c2trZ19jY2NfW1tXW1dXU1NPShdEr09PU1dbU1t3m5u3s49vW1Nra4eXs6ePg5efh3Nrd49vX09HPz9LT0s7NzYTMI8vMy8zMy8rKysivnWiXjIman8laV13zsrK9s4BrSJpiW0RGB318fH19fXyJfYR8hX0Kfn1+fX19fHx9fYV8CXt7e3x8fX1+fYh+/3/Tfwx+fX1/f39+fn9/f36IfwV+fXx8fIR9hXwEfX5+fIR7h3wBe4p8h3sLfH18fHx9fHx9fX2FfAl7e3x8fX9/gICIfwd9fH19fH18iH0GfHx9fX5/w4ADf318hH0Ffn5/gYGGgDF/gYB/fXx9fH18fX1/fX1+gIB/fn5/fn5+gIB/f4CBgX9+gIB/f3+Af39+fX19fn6AhIEBgI+BCYCAfX1/gIKBgauCj4MJhISDg4SDhISEiYPKgtmB6YADf4CA5n8Hfnx8fH1/f4R9A3x9fYR8Bn18fHx9fQICBABFk+mpm4PIj4+zgq2MgZ+hkZS0evWi6KF7fdnZwdWU2dO4rbSXqpOslH5fSlS3WT5JLjMzMzQvM2t2OzU1NjU1NTY1NjY3hTYGNzc2NzY2hzeCNoQ1ATaHNQE2hjUBNok1DTQ0NTU0NDQ1NDU1NDOGNBIzNDQzNDQzNDM0NDMzMzIzMjSHMwUyMzMyMoozATKFNIQzBjI0MzMzNIQzBDQzMzSFMwM0NDOJNAEzhTQRNTQ0NDU0NDU1NDU0NTY1NTWENgI3NoQ3gDg4Nzg4ODk4OTs5Ojs6OliNmaVpXXqIZmpfZGo+Pz9AQURBYoFOdp6cX3tcYJ99WGGAcIKgZ2phanKPcnRigICphL+Ie4N+c3jvh7eQmaXljLl8h8DAc6G00W+ostiUoIqHe9RvkJReqWNfSFZdXYBeR1RHRlm1ko/rx4OKeYdtJnWEt2h8mXByVjQ3ODg5OTo6PDs8PD0+Pj9AQEBBQUFCQkNEREVFhEaAR0hJSUpMTEtNTU5OT09QUVJSVFVXWFpcXV9hY2Zpa29tYHR7dGuztXp4Z39VaGFVdWuJm3VjfK2og3ZynsTRh7iMp42ar7LerX7VfWNjl1VrnWJKXoV6015sp3Crr52giezZgoxyo5h9Y39/foKDhIF6fn55a2Zv4J5rk3WCa5KAlX9XUH9LVFROUlRSUlBRUVBSU1dZWFhZWVteX2FjY2JjZGhsc3mBiJCYmKVkj4x5YmaDhoqPlp2lwtv9msy1s76vs7eP8ebMsJmOiYael2rFtaCYkouHh4F5eHRybGxnY2NgXFpYW1paWllXVlhaW11fX1taWlpcXF1eXV1cWVYxU1FTVldbUEtKSktMTk1MS0pJSkpJj4yKi4uIhYSDf35+gH5/fnx6eXd2dXV1dnZ2c4RxIXJycm9saWhmZGRkY2FgX15eW1pYWFhXVlRVVFRTU1JRUoRRAlJRhU86UlhiX11dXm18dmtsbGdkamGPgX19fH6DhHuHr7aXm5eHb252d3tjXl9eX19dXFpbWVhXVVZVU1NSUIZPFU1PTk5OTUxMS0tKSkhHRURBPjw7O4g6Njs7PD5Xc4qpuqugm5KBdW1pX1dORVxtWE9NQzs4PT43X1hXVVRTUVBPUE5OTEpJSEdGRkVFRIRCY0NFRkZCQUBBQEA/Pjw8PT0/Pz9AP0FAQEJMaIKFaVdMSUtZWVpaV1VdXlxPYGRWWlBLQUA+PT9BQDw6OTg4ODc3Njc3NzY3Nzc4dmtla6SjZDs5apylqGp6id1+5L+AkcjhpD2X2KudfsSPhXlkrY1wn6OFocWE0pjSsIWK5t7YzZDq7sylvKSmiJSDh4Fyes50X19SZV9lY1NZmKlkamtrhWwHbW1tbm1tbYVuAm9uhm8Dbm9vim4Bb4VuAW+ObodtAW6EbY1sA2trbIxrAWyEa4RqDWtqa2tqamppamxrbGyNa4xqgmmQagFrimoFa2pramqEa4VsBmpsbG1tbYVugGlnb2tpjNLi05mPv8mRo4yGhWZzdHV3dGufx3uusOeJnYuQ8MiAj5qTsfCaqYiZoeCsmpalufSq6befl6aanuis47m/svmwwoicxqaArLXqgpvA+a6Rj5eR9omryH3ihXtYbnd5r4Npg2xqeeivn/Tyn7GXk4eSq+mLkMeHlnlRgFdYWVpaW1xdXV1eX19hYWFiY2NkZGVlZ2hoaWpqa2xsbW5vcHJydHR0dnZ3eHl6e3x+gIGDhYeJi42PkpSXmJqSeo6YhH3RzpGLfZZke3RmjXymtIxwiMPFnouEttnzodikt5uxxsn6yIrwhHFytGeDwndYdJ6V9XSCzYLR0p7BgIThz5qhhse5mH6lqKuws7ezp6+tn4iCkPTJiaSLmoCxt55tZ6VncXFucnV1dHJyc3N0dXp8e3t8fX+Cg4WHh4aIio2SmaGprbW8u8pxiot+cHOIjI+RmJyju9Dxkbqam56VmJZ+18u7qpqPiIqeknPdzr63sqqpqaSdnJiVlZKNgIqIhX99fX9+fn19enp7fX6AgoB+fHx7fXx9fXx8fHh0cm9wcXJza2hnZ2doaWhmZWRjY2Jhwb27urm2tLKwrauqqqqpqKakoqCenZycm5ual5WVk5OTkpGPjImHhYODgYF/fXt6eXd2dHNycnBvb25tbGtqamloaGdnaGZlZGRkPmNkaG9sampqdoB8dXV0cG9za7CopKOipKaln6jEyrG0sKOPkJSWmIaEg4KDg4KAfn18e3p4eHd1dXNzcXFxhXAVb29ubm1tbGtqaWhnZmRhX11dXFtbhFpIW1paW1xcbYKSq7iupaKbjoR9eXJrZF1ue2tjY1pUUlZWUpiRj4+OjIuJiIiGhYWCgYGAf359fHt6eXl5enp8e3d2d3Z2dnRzhHIvc3N0dXR0dHV2fpOmp5KGfnt9h4iHh4aEioqJf4uPhYeAfHZ0cnFzdHNwbm5tbGyFa4RqG2lor4iYhrS4mWRTi7K2xn2SsfiI3ZiKj7vjskcyUUA3LlY/O0YzPkhQMzExNEEtW0ZgOSwwUUtGbmRaS0lAUDtVbn9og73KrdefkoGh2snW0KOx4+iv3t/e39/g3+Dg4eLi4YXiBOPj4+SF4xTk4+Pj5OTk4+Pi4+Lj5OLk4+Pk5IXjA+Tj5ITjAeKG4wbi4eLh4eKI4YbgId/g4N/f3t7e3d7d3t3c3dzc3N3b29zc29rb29ra2dnY2IfaCNnZ2NjY19fYhtYP1dXU1NXU1NLT09LS0dHRhNAOz9DQ0M/Ozs7Nzs/Ozs2EzoLNhM4Nzc7Oz87Pz8/Oys7OzoTPgM7Nybmrzr60oqPsf5GTk45yxYJ4c5zP1NXWxK7o4o9wZWg/T0lNeXdMUk5Sh+BMV09cXoRgUEFSU4dky5NSUF5PTHBHel1jX4FVXkBAXkgrS01vQU5oempgUE1VkVyT5ZO5j62ChpadzJOW3auNi71xXpByS1xUTTo1Sdqljql5gK+mhZWWl5eYmZqbnJ2dnp+goaOjo6Wlpqaoqaqrra6vsLCxs7S0tre4ubq8vL7AwMLExMbJyszO0NPV19rd3+Ll6OvcopaTVZDosZmulr+Cp56GxZS75amNr+Wdno1bbmzgp8yytJPx/uvs1KH+ZJea7Y2l/KqCpqqX/ZSPz6npgNFh51N0e7HKqOjUwa/l6Ovv8vTx4evn0rOpr9vvnamNuaju8NaSjOGMlpaVmJubm5qam5qcnqKlpaSmpqmsrq+ysrGztbe8wcnS1N7h4+6AjY6IgIKRk5aZnaGnucrlhqqJiIeBg4Fzy7+0rKCUkpGgloD88+La1tLP0c3JxcLCLMG9ube0r6unqqqrq6uppqaoq6qsrqyop6emp6alpaSjo5+cmpeWl5eWkI6NhIyAiomHhYODgoH//Pn49vPx7+3q5+Xl4+Lg3drZ1tXT0dHQzszKyMbExMLBv726t7azsbCvrayqqKalo6Cfnp2bmpmYl5aUk5KRkI+Pjo2NjIqKiYiIiIqOi4qJiJCXk4+OjoqJjIXy6ubl5OXk5N/l9vnp6eXd0M/S0tLHxcTCwsJ+v729vLq6ube2trSzsbCvrq6urayrq6uqqaenpqWlpKOhoJ+dm5iYlpWVlJSTk5KSkZKSkZKdq7bFz8XAvbitpqGemZSQipaflI2MhoKBg4SA+PTy8e/u7Ovq6efl5OTi4ODf3tzb3NnZ2NjZ2NnZ1tbW1dXV1NLS0dLS0tPThtQJ2eXy9OXd2NfZhN8c3t3h4N/Z4OHd3tjX09HR0NHT0dDOzs3OzM3MzYTMHcvKycPhgeZpVHP/soWvopTPm6nm8GmoWWCOl3hMDX18fH19fH19fHx8fX6EfQ18fXx8fH1+fn19fXx8hH0CfH2FfAd9fn17fX5+h3+Cfv9/0n8Ifn19fX5+fX2Ffod/Bn59fXx8fIR9iXyFe4V8g3uIfId7iHyDfYZ8E3t8fH1+fX5/gH9/f35+f39/fn2FfIh9Bn59fX5+f8KAC39+fn1/fn1+f39/hYA4f35/f4CAf31+fn18fH1+fX5+foB/fn1+f35+gIB/gH9/gIGAfn5+gH9+gH5+fX99fX1/gIB/f3+OgQ6AfX+Afn+AgYGAgYKCgaeCkIOJhIuDxYLdgeyA5H8Kfn5+fXx8fn9/foZ9CXx9fH19fXx8fQICBAA8i/R8yXeAgZKl3Iu98nSd96GTy6Di56Cqk528lubBfdPdrJiRhoeEn7xESnNfXZhCPCsyMjMzNDQ0NTU1hDYGNzY2Njc2hzcFODc4NziFNwM2NjeJNgQ3NjY3hDYPNTU2NTY1NjY1NjY2NTQ2hDUFNjY1NDSFNQg0NTQ1NTU0NYg0FTMzMzQ0NDM0NDMzNDM0NDU0MzQ0M4Y0gjWFNAUzNDQ0NZE0ATWGNAE1hDQKNTQ0NTU1NDQ1NoQ1CjY1NjY2NTU2NjaENwE4hTeAODg5OTk6bG9vOzlnn4mFmWeKmlx2tFqvxlhiOD9AOVRKYjVVfH6RioiQhoOAiYpyuJfBqZOeZ3GhoanghV6klIyex254e55seHR5rcmVkJDGxYWWppC5aNuHt4jrjnDdjbCFVm1sW4JcrJSXsG9DL1k+bpZhdcTTvcLX0nBpyGkQyZ2UgoVPNDc3ODg5Ozs7PIQ9DD4/Pz9AQUJCQkNERIRFc0ZGRkhKSktMTExNTU9PT1BRUlJSVFVXWFpbXV9hZGVoam1xZZSasqd1o4GSb2h8eaduW5KfsprQhZu+sNd1nqO7j256iHKMh3x6aq23eHudkWqRWGVWeIuqY3m1mpaAs4WsZ3nrpXyOyI2IUX6Bg4aKjoqEhICQnXZeqJOQ6I2kcGhZk4iOYotOT09PUVBRT09PTk9QUlNVVllaXF5gYmVlZWdpam1xeICDipOXn6WytGFjbXJxe5HBuL3K/P6El87h+4aH7rapiOjevKmZhZJ/asrAwqCSh4R+e3VzcXFzcGplZGBbW1pcX15eXVtaXFtaW1pbW19gYV5dW1xeYWBbX19nYVxham5cUU5KSUlISEhHR0eNjYuIhoOEhYeGhIF+fX1/fn18enl4dnN0cnFycXJvb25tbW1ubmxqamhnZmVkZGRhYF9eXlxbWllZWFVVVlVVU4RSgFNSU1NTUlVUVVx2h4V+c21vdHV0aWpsbGNfXq2UgIB9foKEenmOmIeHg5SUj45/bWtmYWFgX15eXF1bWllYWFhXVVVSUVBRUFBQUVBQT09OT05NTEtLSklIR0NAPj4/PTw8Ozs8PDw9P0tSaoujvbSuqaCRgHRrZWBgWU5ecGhXJlNRSj02bmleWFZWVVNTUlFRUE9NTEtKSklHR0VEQ0NCQkVGSkxDhEFaQD8+Pjw9Pj8/QEVEQEBAP0Ric25kVkVFSlhZUkhISk1RS0xeZ11NSERBQUA/Pz4+PTs6OTk4ODk4Nzc4Nzc4O4F8xHSp656YbjxwrsKIjXaTepiUlYOrpZmqOqz9jdqEh4ycnb+Hw9qBq/a3rqd9zPGns6arxKn11Izi+LOjn5yZlMDJYnyph5zKXltNYmdoaWlqaGuEbAdtbW5tbm5uim+KcApvcG9vcG9vb3Bwhm8DcG9whm8Ebm9vb4VuBG9ubm+EbgZtbm1ubW6GbQRsbGxth2yCbYVsA21sbIZrBGxra2yEawZsbG1tbG2GbAZrbGxra2yLawdqa2tqa2tqk2sBbIVrBmxra2tsbItthG6ArrGpbGqm1sHPv5mq+I20+X7G8IOcZHR2YoN2m1qGoLa2udnn1OLN07iK2ur/5sHKiork5/D4l4Pd25jB+4eolLKTm5OPwdKsn5PSm4eltJjYhO+NtnbZl4P3tOKwd42NeZlt07an3pFfTY5bodmAjs7j4ebw4YKH14T/u8KnvW6AT1dYWVlaW1xdXV5eXmBgYGFiY2RkZWZmZ2hpaWprbG1tbm9wcXNzdXZ2d3h4eXt8fX5/gYOEh4mKjY+RlJaYmZuEtLjYuICpjKmCfZePxYdrqrnTtfilvu3c/ojCudeqhImVgZydjZh5wcqNgrmtga9xfmiWtcqAmtitsZHcpqmAfIr6royl3K2jY56nq7G2u7q3t7Grt8aSdMG1t+SqwYZ9cLSiqnm4a25vcHJycnFxcXBxcnR2d3l8foCChIaIiYqLjZCRl56kqrC1vcHHz9Jwcnh+e4OUuK+zv+rneIawuslnar2ZjHXRy6+gloiZhHLd2da8sKikop6amZiZmJV4kYyJhYF/f4CBgoGBfn1/fn19fXx8gYF+fnx9fn9+en17gHp3eoCBc2tpZmVkYmNiYmFgv767t7azs7Kzs7Gsq6qpqqmnpqSioZ6cm5qZmJeXlZOSkZCQj46Ni4qIhoSDgoGBgH57enp4dnV0c3Jwb29vbmxrampqhGlJaGdnZ2hsfoqIg3x3eHt9e3R1dXVubGrHtKWko6Kjpp6erbWmpaGuraenm46MiIWEhIOCgYB/fn18enp5eHd1c3NzcnJxcnJxcYRvgG5ubWtramhnZ2NhX15fXVxcXFtbXFtcXWVqfJSmuraxrKWajYR7dnNxbGNufXdpZmVfVlKjnZeSkI+PjYyLiomIiIeFg4OCgn9+fXx7enp5e3x+gHl3d3d2dXR0cnJyc3N0dXl4dXR0c3mOm5eOhXl5fYaGgnp7e36AfHyKkYl+A3p2dIRzCHJycXBubm5thWwfa2tramfCr9mk1P2is5FZpNbOkrSNtYuNoqiayMbBxzwrZi5SMTEyOE5dOWd2TmB/T3BZUXmnSzc5O0Q9ckomRUpJNzZfe5vu5KHX8qDv6YiIkc7c4N/f3tjf4OCG4Qni4uPj4+Lj5OOH5Avl5OXl5OTl5OTk44XkBePk5eTkhOUJ5OXk5OTl5OXlhOQG5eTk4+TkheMJ4uLj4uLi4+HihuGE4IffhN4i3d7d3d3c3N3d3Nvc29nZ2dvc3Nvb3Nva2trZ2djZ2NfX14TWhtUK1NPT09TT0tHS0oTRBNDQz9CEzwvQz87Oz8/Oz87Pzo7PgM7Pz9DPz8/N8/66wLvp77HZf093mlF+o4RuiHfSr9TVo5iTxJekW1hnZYKGcXVmZ09Jfo2cqaSLXl6EhW5+Sj+Ot15okl6KTkw/QkZEXWRNS01iUDlHVUaIco5HZEqDVkGTb8W+h3dPgM2X9Lup26aKiPeRyrdPUXxzZV12dEE9gH1x/siao+qPg5WVlpaWmZqcnZ2en5+goaKjo6Wlp6epqqusra6vr7Cys7W2t7m6u7y9vr/BwsPFxsfKzM3Q0tXX2Nze4OPm6uzA9d/TemplQai1r9fE/LWH2er3pPiWrNXDyGeahouJdpybq9vGoZaI+NOZb+fitOuKvZS4zdR2gJjhsd/K/ZFhhI3biW6svq3Nhdrl6u7y9fb19uzg7v66ip/d4PLO+rKolfLO1pb2kJSVl5mam5mZmZiZmp2foKOlp6mrrbCys7O0trm9wcnO0dfc4+fp8vWAgYWKiY6as66yutzYb3uXnaRTVZmEeWvFwauhmJKdjoD9+fTg1M3LgMrHxcTDxMXBvLizsa2qq6ytrq6tqqmqqqipqainq6uop6WlpaaloaKhop6bnZ+flI6NiomIh4aFhIOA/v369vTx8O/v7uzn5eXk4+Lg3tza19XU0s/OzczLycbFw8LAv768ubi3tbOyr66urKqopaWioZ+enZuamJiXlZSTkpKQZJCPjo6NjIyLi46ZoJ6alZGSk5STjo6NjYiGhP7x6Obl5OXk393n6uHg3OTh3t/VzcvHxcPDwsC+vry7u7m5t7e1tbOysLCvr66ura2rq6qpqKenpqako6Ggn52amZiXlpaVlJSFk3iZm6e2ws/MyMS/t62mn5uYl5OPlp+akI6NiYOA//z38/Pw8O/u7evp6ejn5eTi4+Hg393c29nZ2dvb293Y1dbW1dXU09LS0tPT0tTW1tTU09PW5O3q493V1dfd3drV19jY2tjY4OPe2NbV09LS0tPS0dHPz87Pz86GzR3MyrHy1LPhzl5L1s2G2ax0ge+h6ZqEta2U9ffJQQR9fH18hX2EfAl9fXx8fH19fHyGfQN8fX6GfYR8CH5+fHx9fH5+/3/UfwZ+fn5/f36GfQl8fX19fn19fn6EfwV+fn5/fYx8jHuCfIV7jXwBe4Z8HH18fXx8e3x8e3x8fX59fX5/gH5+fn1+f4B/f32JfAp9fX1+fX19fn5/woAIf359fX59fX6EgAZ/gIB/f36GfR18fX18fH1+f36AgH9/fn9/fn9+f3+Af3+AgH9+fYR+Dn+Afn59f359fX5/fn5/j4EHgH6AgH2AgIiBqYKNg4WEgoWEhImDwoLggeqA5X8Nfn59fn18fH1+f359fI19AgIEAD12j6OiwIl0erbDkcK44nnjkobV1qeYvZuPk5N0x8mop7Kqipu9ym0uMEdYQmV5gkhGWldbMGExNDQ1NTY4hDcLNjc4Nzc4ODg3ODmEOAc3ODg4Nzg4hDcCODeENhg3Njc2Njc3NzY3Nzc2Njc2NzY2Njc2NzeENgQ1NjU2hTWCNoc1BjQ1NTU0NYQ0AzU0NYQ0gjWJNBQ1NDQ1NDU1NTQ1NjU1NDU0NDU1Nos1ATSFNQc2NTY0NTU0ijUBNoY1hTYBN4U2CTc4Nzg4ODk3N4Q4gDk5OjpYumZ5OThdXqWLjZxoWmR06KaAY340QEA+OpZ1SFB5fGVUT3JpYm6CdoGKudCUcXB+eHx2eI+xelphco3MvXaT1ZGdvdKb07dsspmm28Lq6W2Dgoiu+sS2k47UlqVhnmONQ2tZlta6XVUxXUp1c7K7r5nsbcV9+YOIm5N2gK5pgEk0NjY3N2U6Ojw8PD09Pj4/P0BBQUJCQ0RFREVFRUZHR0hJSktMTE1NTlBQUVFRUlJUVFVXWFpbXV9hY2RoamxfZXCPqoWhu6KDcZaObWuOcZqdeZrQjo9zi6+wnIPAtojDboxVUZ2JwnKGrKLQomhqnIlQXIpqbIaflluOgGeUiJLPqq2fx2ydsn6Zk3GJjZaejoeJk5uQWYlTmpB7q6V1Y4tliWmGboFSUVNOTU1OT05PU1VWUlNVWFlbXWBhY2NlZmhobG90dn+GjZKWnaCkparAjePXwpnJ287mg5Sltdmh0f3yqofZvuuO1K6aioB9dW/Hu5+PhYF/fHd1B3JxcGxpaWOEX0ZhYmdkYV9hYV1YVldZW19gYl5dXV9lZmBgYmZdWVpZV1JOS0hISElLSklJS0qTkY2HhIOBgIB/fnt6enl5enp6eXh0cm9vhG0IbGxsamlpa2uEaWFoZ2ZmZWVjYGBfXlxcW1taWllYV1dYV1lbXmJdWVdXWnBxZ2x+hIuHf3h2cW9paGRcVVpXWFxZWqesn46DmIN2enx+gnqCiIaNiYiEfm9kcoBpYF5cXFtbWVlZWFdVVFJRh1JhUVFSUVFQUE5NTEtKSkdEQkSDg0hESFRUWWFZWWZqYISntravrZ2Kem9oY2BeWVlnbm1gWVNQRTlva2daV1ZVVVRUUlJRUE9OTExMSklIR0ZFRERCQ0NFRkNBQUBAQD8/P4U+Iz8/QUBAQD9ARUdNUk5CQUZRZF5RVllOUlpSVV5YSEdIQ0A/hEEFQD49OjqGOR84ODg8dXFuyWdqh7t1qa2jf6HmT5aJp86EY1pft46tQYS7pa3Hg4COybKczuX9gfKqqvDYoXmvpaCkrYPczb2xt7eWseX7ik5WeINlj624eHKPgohQnlVpa2xtbm1ub29uhG+FcANxcHCQcYVwAXGEcAZxcHBxcHGEcApxcHBvcG9wcG9whG8LcG9vbm9vbm5ub2+FbhBtbW5ubm1ubm1tbW5tbW1shm0ObGxtbW1sbWxtbGxsbW2EbgRtbW1shm0GbGxtbGxthGwBa4hsBmtsa2xra4ZshGuQbIhtgG5ubW5vb29wk9GNvGJjoo7aytXRn4qQo+HnuZvBW3R1b2Hps3OBvYqChIW8jaqzq56uoODoxpWIvaenq7PDvsWEmqea8OyFq/u10uT/tc68hMJ6pOzZ//KEkIt/te/Ovq6n+cjdhNWDt1eIcMP95Hx7T5VrsJ3s4ayw/4Hlgf+GgJm7r6DojLJnUldXV1SQWltcXV5eX2BgYWJiY2VmZmdoaGlpamtsbW1ucHFyc3R1dnZ3eXp7e319fn+BgoSGiIuMj5KTlZeYf4ONrcmWor6ilX6uqYGBqoS4vIuz76WriKjExK2V1uSc4HyfY160muWImcey7b56gMKpZHG0hJCfgL2xbKZ4wKCj0pyam86FosadtrGMr7S9xbu5ucG+rGqmacGvlrzHjnild6aAooWlbnByb25ucHFwcXR4eHV1eHp8f4CDhYeHiIqMjJCUmZ2lq7G3ucDBwMLI2Iq/wLeaxdHCzXJ+jJi2fJqwqYBsr6HPe7+ll4qEgn134dS7raajgJ+dnZuYl5aUj42IhYSDhYSFiYaDgoSEf3p5eXp8gIGCfnx9f4OCfX1+f3h1dHNwbWpmZGRjZGZlY2JiYcG/u7WysK6trKypp6alpKOkpKOioJ2al5aVlJOTkpGRj42NjYyLioqJiIaFhIOCgH58e3p5eHd2dXNycXFwcG9wcXF0gHBtbGxtfX10eIWJjYqFgH16eHR0cWplaWZmaWZmwMO4rKaypZyeoKCfm6Gloqqlop6ajYaQmIeCgX9/fXx7e3t5eHh2dHRyc3Nyc3NycXJycXFwb21sa2pqamZjYWKTlGVhZW5tcndyb3p9dY+ptrawr6WWiH55dXJwbGt2e3pwH2tmY1xTpKCdlJKQj46OjIyLiomIh4WEg4OBgH9+fHyEegp7e3l3d3Z2dXR0hXMxdHR1dnZ1dXR1eXuAg4B3dnmCj4uBhYZ+gYiBhIuGenl6d3RzdXV1dHRycXBvbm5tbYVsHGejjonJhoiVzY3V266Kve9pu6PC6qWEiILkqsVLQsJESFAwNC9CWGZts5lHhX58iWhyTkUuLDY3Kz8rMDM/Uz9fmNGfmrPi1pq76PrUwPW1yIf7k9zi4eLh4OHi4uLj4+Tj5OTl5OXkhOUD5uXlheYD5efmhuUP5ubl5ebm5eXm5uXm5ebliOaF5QLk5YbkOuPk4+Pk4+Lj4+Li4uHh4uLi4OHg4N/h4OHg4N/e397f3d7e3d3e3d3d3Nvc3Nze3Nzb3Nvc29za2tqE2RvY2NjX2NfX1tbW1dXV1NTU09PT0tLS0dLR0NGE0AbP0M/Qz9CHz4DQz9HQ0NDP0NDP0M/Qz8/Q0NDR0M/PxLl275an/sTGxmyPnHx7iJDYblmlnNPTx4KQkoprdVNKUpCTU1NVV09hY4OeiIRbdF9cYmRrcGVeknhaiYtKUmlPX2Z8T1lMMlVGVqeWhISCfFtKaJF0Y2ppb5/YYmtk7oW9krzS85DBiYD7odF7l4dqXHw1aUO4TVCCos33m9yGiZSQj4HFlZWcnJ2en6ChoaKjpKWmqKiqq6ysra6wsLGztba3ubm6vL6+v8HDw8THyMrLzs/R1NXZ29zf4uXluMG26emMY3RtbJDm9bSuuaPA5rrmqFpbWWx8dmtdj9yy2J/hjoXmw96PtoCXreDlp7j735iitoCTgu7Wiemd1J9yeGpEQ2Z5bZ+s7eG86u/1+/X19vzy24HNgPLhq6X8u57Ul8yUuKbYkpWYlpWWl5iYmJ2foJ2eoKOlqKqsrrCxsrO1tbq9wcfK0dfb4OTl5eXs+Y6or6+gv8i7xWhweISaYXJ/e2RVkou3bzS1pJuUjoyJhf713tPLycjGxsTAwcHAvLaysK2vsLCxs7Gura6vqqakpKWmqqqqpqSlpaemhKIJnJmXlpOQjYuJhIiAh4WEg4D//Pjy7+7q6ejn4+Lh393d3dva2NbU0c7My8nJx8bFw8LAv768u7q5uLa0s7Gvr6yqqKelpKKhoJ6dm5uZmJiXlpaWmJWSkJCRmpmUlp2foZ+bmJaTkY6OjIaDhIODg4GB+fny6eXs4tze3d7c2tzd2t7a2NXSycPKz8N3v72+vLy6ubi3trW0s7Kwsa+vr66traysq6qpqaempKSjoqGfnZubu7qbmZufn6KkoJ+lp6OzxMzLyMa+tKiinZqYlpKSmpyclJCNi4WA/vz79fPx8O/u7ezq6+nn5ubk4+Lh4N7d3dva2trZ2trZ19XV1dTU09OE0iTT09TV1NTU09TX2Nvc2tTT1dvj39vd3dna3trb4N7X1tbU0tKF0wXS0NDQz4XOH83NzK6UOXx5fm1FV2DTpmBOnbyU8a3x6trM4K/2kUwFfX19fHyFfQV8e3x8fYR8iH0Bfop9CX5/f359fXx8fIV+An9+/3/Pfwx+fX5+f39+fn19fHyJfYR/BX58fX59hHwBfYZ8hXuCfIh7gnyEe4J8hXuEfAF7hHyCe4R9Anx7hXwcfX19fH1+gH9/fXx9fn+Af399fHt7fHx8fXx9fIR9BX59fn5/hYABf7uAA39/foV9C39/gICAfn9+f4B/inwhfX9+gICBgX9/fX5/fX59f4CAf3+BgH19fn1/f4CAgH5+hn0Gf319f4CAi4ERgoGBgIGAfoCBgYCBgICAgYGrgomDhYSGhYSEiIPCguGB6IDkfwh+fn59fn59fIV9Dnx8fn19fXx9fn5+fX19AgIEAENaS/TAqZHV1o+Hs9u3sc/Egp142sKooouXfdbmxorOpoipdcakqWw1MzEoRTdCgIZwRWiZco9kNTU2Nzg4ODc4ODg3hDgEOTg5OIY5Bzg5OTg5OTmGOAo3ODc3ODc4Nzc3hDgINzc3Njc3NzaENwY4Nzc2NzeLNg01NTY2NjU1NjY2NTU2iTURNjY1NTU2NjU1NjU1NjY1NTWFNg81NjU2NTY2NTY1NjU2NjWGNgU1NjY2N4Q2ATWFNgE1hTYFNTY2NjWJNgs3Nzc2Nzc3ODg4N4Y4hDmAOjouv3l2dnk6U1xWkqOejW5+gn9WoJNaPDxSbV6Th3pUoJNhUmtlW1hoeaSDmXRnsqSGXn99jXyAdH2AYqyKva1xfbbQdnBx6IiOitnFrqiWi9Zzvnih5I6zq8hyh3eUgVh3anRsZYhcd2VeTXdWqJ6BvJl/utjV6m51j3eNm5QQaGQ3M1NAdI9NZzY6PD0+P4RABkJDQkNDRYZGgEdJSUpMTExPTk9RUlJSU1NUVVZWWFhZWl1gYmRlZ2psbWNfcn2ur4+4jnOKjYRzcm+Aqa6MjHWIq4uQzMXEzJO1qXdVX15rn4ees7F7f5agZnNUe3FbetXFYY6WmWN9ceOaqKr+h7O0iVuSuZVxj5WTkY2OkZpotWSib5WXcGdzgE5rpJlrcX2EUlJSUE9PT1FSVVlYW1tYWFxfXl9iYmNkZGRlZ2pucXV5fICGi5OYoqmvts2KndvY5Iy64bqgtuOVvILuuJSp5aGIj5nYuqKNfnNuZ7qknJSRjISBe3dzbm1raGhoZmFhYmVtcWxmYmJfXFlaWlxdX19eXFxaW15hUltcX19XVVldWVNRTkpKSkxNTk1PUVBPTpmSiYmIgX9/gX17e3l6e3l3eHdzcm5rbGpra2psbGtsbGtrbGxsa2poZ2ZlZWNgYF9dXVxbXFtbWluFWk1eXFtaWldcYG99hYSGhoSCenFzb2xqaVxSTZeZn52pWqpbYruqYY55eHJzdnN5lp6GgJiXhnRpo7ubamBiXVxaWltZWFdXVlVUVVVWVYVWUVdWVVNTUlBPTU5OS0pPUZm9cImtqZ6RkJGKhIZ9hZSrvL6xnoh2bWhjYF5aXGVoaF5WT01LRUlMPmBgV1dWVFRTUlJRUE9OTUxMSkpJR0dGRYREDENCQkJBQUA/Pz4+P4U+hD+EQCNBRkVCQkRES0xTV19STE1LSkxKRUhNSkNCRENBQUBAQD47Ooc5HTo8apW9yJuofpKNlHnT0UuQaW9xa2taZHdlZKDEUXli+9axicrahp7D97nD2OaxwYfQo4uVk6iP1P7dh9islbqC47fPn2dnYUl6Vmm3s5xij8yWuplnbW1ubm5vb3BvcHFwcXBxcXJxcXFycnFycYpyhXEKcnFycXFycnJxco5xhHABcYhwBG9vcHCJbwFuhG8Dbm9vh26Cb4VuEm1tbm5tbm1ubW5vb29ubm1ub4RuAW2GbgJtbottAWyIbQFsj22CbIZtA25ubYlugG9vcHBwUuGBmaOzbpSSg7/N0NWywLCpgdDsj2JrhbaIutrLit/qkH+njYKQjKHco6yTi+DSrYSioLnKsaa0s5XpqOy8mI/W842Hhd+Tn5681Ludn4nbhMiGluuzydn9lquexah7ppKPioCnep+Tj3WvfM/BmLqugdb95O2CiK2MgL/Rs4uYV1F9Yp+7cJxTXF1eYGBhYmJjZWVmZmhpampra2xsbm9wcXJydHZ2d3h6ent8fX5/gIKDhYaIio2PkZOVl5mahHiNkMzJkr2WgqKlnoqEhJXIyqajjaDJoajE3t/0pdvNiWNyb366obTOwoSQort3i2Wbim6S9u55rbK1QXaTgv+kqLn8hby1pGqw2LeKsrq7vbu9v7130nO/h7q+in+QYYPCuoKPnqZqb3BvcHBxcnR3ent9fnt6f4KBg4aHhIhqiouOk5aan6Woq6+2ucHKzdPjjJrGxtF+o8aki5i2co1gnXVgc6h5bX2Exq+djYR9eHPUwrm0sKulo5+alpKSkY6Pi4qHh4eIjpCNh4OEgX17fHx9f39/fXx8ent9fXl6e3tzcnN2cm5saYRmIGdnZmdnZmRjxL22tbKsq6usp6amo6OkoqCin5uZlpOShpGAkI+OjY2NjIuLiYeGhYOCgX58e3p6eHh3dnV0dHNzcnJydHJxcG5tcHJ9hoqKi4uKiYF7fXp3dXRrY2C9vsG+xmfGZ2vOvmipnJuZmJiXm6+0op6wrp+SirXGq4eDgoB/fXx8e3p5eXd2dXZ2dnV1dnV1dXZ0c3JycW9ubW1taWhQbGyiwYiUsa6mm5qclpCSio+brbq8s6WThH14dXJwbW51dndvaWRhYFteYVWWmJCQj46Oi4yLiYiHhoWFhYKBgH9+fHx6e3t5enh4d3d2dnWNdCl1dXV0dXp5d3Z4eH1/goaMgX1/fnx+e3l7f3t3dXZ3dHV1dHRxcG9vboZtHGuVpL/Fr82XpaiokvXqY6iFjI6TgYGTpoWAv/M7k4Oae0gqSFw1YI12Y9ak1c59LltnTTApKClNVU8sTTowVUNTZ3LW093UmvGaluvP0oOp/bHW7s3j4+KH4wrk5OTm5ebm5ebnhOYD5+fmhOcF6Ofn5+iG5wvm5ujn5+fo5+fn5oznhuaG5QLk5YbkDuPk5OPi4+Pj4uLi4eHiheGC4ITfAeCH3gbd3d3e3d6E3QTc3NvchNsi2tra2dnZ2NnY19jX1tbV1tbV1NTU09PT0tPS0tLR0dHQz4XQD9HQ0NDR0NDQ0dHQ0dHQ0YvQgNHQz4K2VGip0cbygnNkeH2Z5uyZd1aCu7KSuLPtUnKhiUd+iWiMf2JEQEtjmFZWWWaGi4FTa2Bmf21aYGVyjVV0XF5Od3E7RjtwNT4/WaGqX2BMwKH8o1Z5QlV+hj5oWGZqntrfwpWQqofJ5ems6J7Am2Z9aUhzdGuAUkR3e8bmgL2t9ZSAsoCZw5HsgJyenp+goKKjpKWmp6mpq6ytrq6vsLKztLa3ubq6vL6+wMHDxMbHyMnLzc7R0dXX2d3e4eTn58eu0r317I15ZY7L6uC9rKC49vjNnV5kjV9mcYCV0mWztqeJpaKk8s6Em21Ppq+9o7KPxcGWyfPCqfL5/ZuzgK33dmCejTtgapeDw+/vuevy8/T09vjwjPuI563v9bOevoCt+MiUnaS/ipWWlZaXl5ibnaGhpKWjo6eqqayvr7CxsbKztbe8wMXIzNHV19vg6O3w9P+Pmbe4wHOOq5N9g5NZbEZoSj5Qfl1ZbXi7rKCWj4mFgvXj3dbY1M7LxsS+db29vbm5t7Owr7Gytre1sKytq6ekpaWmp6inpaSjoqKjop+foJ6Zl5eYlZGPjYuKioqJiYiIhoOBgP348/Hv6efn5eLg393c3NnX1tTQz8zJycfFxcTEwsLBv72+vLy6uLe1tLKwr62qqaelpKOhoJ+enZybmoSYR5aVlJSRkpOaoKKhoaCgnpqVlpORkI6IgoD9/P77/4L8gIP+9IDl3dvZ2NjW1uXm29fh4NXLx+Hs2cK/vry7urm4uLe1tLOyhLFksLCwr6+urq2rq6mpqKalpKOhoKKhxtmwvM3Lw7y7u7aztK6yucbOzsi9saahnJqXlJGTl5iYko2JiIeFh4eA9vbz8fDv7e3s7Orp5+fm5ePi4uHf3t3c3NvZ2djY19bW1dXU1IfTUNTU09TU1NPU1NTW1tTU1dXZ2dvd4drY2tjX2djV19nX1NPU1NPT1NTU0tHQz87Pzs7NzczCjVBFSkewcV9Yb3CniIKAlrC/xXbI97JSkLHFEn5+fHx8fXx8fX18e3x9fHx9fIx9BHx9fXyEfQF+hH8Hfn59fHx9foR9AX7/f89/AX2EfgR/fn19hHyFfQd8fH5/f359hXwEe3t8fYZ8AXuEfIx7CXx7fHt8fHx7e458BX5+fnx7hHwTfX19fHx+fn9/fn59fn5/f39+foV8AX2EfId9Cn5/gIB/f35+f3+6gAt/fn5+fX5/f4CAgIZ/An59iXwZfX6AgYGBgH9/fHx8fX99foB/gH+AgH98fIWAAn+AhH0JfH19fX6Af3+AiYEDgoGChYEKgIGCgYB/gIB/gKyChYOHhAeFhYaGh4eGhIUBhIiDxILZgYWAB4GAgYGAgIHlgOF/AX6KfQN8fH6EfQJ+fYV+gn0CAgQAO11jm/2Ku+fk68l5ppziz7am0b/JiLqMgJaEfIiEiLGOr6L2r5SCxnA3MjEwMSorKypXTS8uMzc2Njc3hjgWOTg5OTo5Ojo5OTo5OTo6Ojk5Ojo5OoQ5hDgLOTg4ODk4ODc4ODmLOBE3ODc4ODg3NzY3ODc3Njc3NoU3ATaENwo2Njc2Njc2NjY1jzaCNYc2Azc2N4Q2Bjc2NjY3Nog3DDY2NzY2Nzc2NzY3NoQ3BjY3NjY2N4Y2CTc2Njc2Nzc3NoQ3Azg3N4g4hjmAOjo7M6TJY3JyNURSp3puan1OS1Fwk7+Eb5teU1GCmXZx0p6cXnZaaaxmd2qrYXpuqZVqTF+Wm5SUmIV6hWmsnnGYpKy5mNnBmtSKv5PhcGrPuOmhe1uPrnetvaCcsHhxmqFog3+XYl5rY4l7ZGuQXYyAb7WFpuSx8HaldaB2fbgbTzU3N1FYopbIkHhcOzw+Pj9AQUFCQ0NDREVGhUeASEhKSkxNTk9PUVJTU1NUVFVVV1dZWltdX2BiY2VmaWptcnR5XXZ2b2uO9XiXqXp3S2aTcneykMK2iJ535JdptraJmY2aXFl4iXyicrvYbaWLonGCWmSUfZiBU1RWbX2psHW6qJmw34qXaK+paX+Dj5GSj4uLnl5kprWXfIZ9W2+AhItxpsJxll1ngVNSU1hYWFZXW1pZW1taWl5iYmVnZWNiY2Vpb3RycnN2e3yGipOWmJ6nssNwe6CG15SvwqDpzOiokZW7kKXCrLrxrYDYuq2cj3pvaL6qnpiRjYuHgHlvbGxraWhnZWRiY2x1f4J3bGdnbmtoZmJfYGNpcm5qbHqAe25hXlxaVlFQTk5NTE5NTlBQU2ZiVVFOT5mVkqitjYiFjoh9fXx6e3x3c3NzcnBtbW1saWpqbW5vbm9wcXBtbWtsamhlZ2ViYV9dXVtaWVpZWVlaWlpZWFdWVVZcX11fZmx6gH6Af3p3cGtrZmlpWlJNlJigkZWTmqpds7i6nomAhnuBjo5+lpWIfoaFhoN1kaOnkHFyYF1dXl5eXVxZV1dZYmdfZGZrdmleZF1aWFleWVZTUlRaa3WHw7eLnq6pp5uNiYWEg3t7iKW2vruhg3VwaWJgX15hYWFfWVFISElJR1JPPmpYV1dVVFNTVFJRUVBQT01NS0tKSUdHRUVFREMCQkKEQQFAhD8JPj8/Pz4+Pz4/hkCFQRxERElOUlFLR0JDQ0VFSkpIR05aT0VDQkBAPzw8hTofOzs8PGugiamYpKJubay2prNQiXqIc5PByFqrp5aRnjtziZXMgav92+bdgqCn16za0vTs1XaOdHmogoyhjZO+lLCpwr6Une6pZmhnZ2VQTlBJfoBVT1dka25ub4RwCHFwcXFxcnJzh3KKcwF0hXMFcnJyc3OFcgRzcnNzinIDcXJyhHEEcnFxcIhxBHBwcXGKcAZvb3BvcG+EcIVvA25vb4RuhG8Fbm9wb3CGbwFuh28Cbm+ObgVtbm5ubYZuCW1tbm1tbm1uboVtA25ubYhuB29ub25ub2+FcIBd0MqDhapeeob5rZCEwYJ/gY+89Leb452FgcbQwLD97PWUu46V95SuoPSBmqH+0pV3m8XZ1OLVq6vBkuHGhZzM0dzF//qsxZDGmtCLgOmry52NbJSngs7hydLdmJzP1o6por19eYaCtqCQm9CKvqiLxJm+/r/1iMSJwI+c4G9RU4BYeYDjyvq4q4hdXmBhYWJjZGRlZmdoaWtrbG1tbm1vcHFyc3V2d3l6e3x8fX5/gIGDhIaIiYuNj5GSlZaYm52doHaRi4N5nfqIq8COjlt3r4eP16rg2Z2tieyxg93amLSmtXFtiZ6OtoPf+X+4lMKGoWt4spm6nGdnaX2Yx8uGzIC7mafcnbx3xMCDmaCyuLu8urjDbnPB07aZpp9yjaKuh8vnj8NygKVwcHJ3eXl3eXx7e319fH2BhYWIi4qHh4eJjZKXlpeZnKCgqrC3ubm/x87beX6ad7N7lKaMzLHAgmdib1tTf3WLwpZzyrSrnZKAeXTXxb64s6yrqaKak5GQkVCQjo2KiIeJj5edoJeMiImNi4eGg4CAg4eNiYaHkI+GfXp4dnJtbGtqaWhqaGlqamx4dGtnZWTEwL3JzLaxrrSupqalpKSjn52cmpqYlZSTkYWQAZGEkICOjIuKiYiGg4OCf318enp5d3Z1dHRzc3NycXFvbm5ucXNwcnd6hIiHiIeEgXx4eHR2dmllYLq9v7W5t7vEaMrN0Lenpp2gqaidrq6jnKOioZ2Tqre5pY2NgX9/f35+fXx6eXh5f4B8f3+DioB6fnl3dXZ3dXNwcHF0f4iTwruapU2xrqykmJSRkJCKiJKot727p5CDf3pzcXBvcnFxb2tkXl1eXl1kYlWekZGQjo2MjIyLiYmIh4eFhIOCgYB/fn18e3p6eXh4eHd3dnV1dYx0J3V1dXd3dnV2dXh4fH+CgX16d3d3eHl9fXt5foeAeXZ2dHRycXBvb4RuHm1sX5TVmrK02c+HhtLQuM9kpYKsiLXO3HnZvbqxsTiV0pJoTUpTWFtZPUJKnG7Pr1lXRzJMOy8xKy4+Mj5SNEhLX0UzQIzgwuHk5uCsn6WN0OWik5y83oTkEePk5eTl5ebm5ebm5+fn6OfniOgI6enp6Ono6OeI6A3p6Ojo6ejo6Ono6OjphOgF6ejn6OiG54bmiOUp5OTk5eTj4+Pk4+Pk4+Li4uPh4uHh4OHh4N/g39/f3t7f3t/e39/e3t6E3YXcB9va2tva2tqE2QrY19fX1tbW1dXVhNQS09TT09PS09LS0tHS0dHS0dLSh9GA0tLS0dDQ0dDQz87Q0dHQ0c+csG9NSLiasYvXZ0tNn8fAtmSCn15Tq9yRfKuidW6Nd4tOhllun2BYWZtLRE2ZcZOho4yCd4WKYVlgRnVkSE2PmKe3mGxFZjhNPGB7eeB7YnWZiXVrRV9XVVlvXICmuLvVzO+IiZyb8OjUxNar4XGAY5BiYYZXjlFuPnNpjv2ghoaTtpX2l8zV2NKdnqChoaKjpKSmp6eqq6utrq+wsLGzs7W3ubq7vL3AwcLDxMXGycrLzc/R0tTX2dve3+Ll6ezv8aiys6KtpMWm4PjEy4ajw56Fhld9nWpkWp2GYLp/Vqm78qOetdnAsWyh2JeDY7+ArM2Tp+fE69iQkZaOren6q4h/Vmloa7iV/qiXydXr8PT19O/1hIjo/uLA19CTutjrsP7WptqDjdeUlZebnZ6dnqGioaSkpKWprK2xs7GwsLCyt7vAv8DDxsnN09jf3t3i6e/3hIaaaJBgd4h4tZmcZUpAQzcxUFBpnYJrxLKqoJqAi4WC+eTf2tbT0c3Iwb25urq6u7i2srGyub/Dw761srG0sq+uq6ioqauuq6mqrq6moZ6cmpaSkI+OjY2NjIyNjI2Tj4iDgYD9+ff9/O/s6evn4eDf3Nza19TS0M/NysnIxcPDwsLBwb++vr28uri4tbWzsK+uq6mnpqWjoqCenpyAnJubmZiXlpSTk5WUk5OWmJ6gnp+em5qWkpKPj5CHgoD7/P33+PT1+YD9/v7u5OHb3ODg2ePh2dTW1dXTy9ji4tTFxby8urq6ubm3tbSztLa4tLW2uLy1srOxrq2srquqp6anqK60vNzVvMXMycfAuba0s7KurLTCys7Mvq2lop0LmJaUlJWUlJOPiYaEhSiLiYD68vHw7+7u7Ovr6ujn5uXl5OPh4ODe3t3c2tnY2NfX19bV1NTTh9SE00vU1NTT1NXU1NTT1NbW19na2tnW1NTV1dXY19fW2t7b1dTV1dTS0dDQz8/Ozs3Nxo2R5ERDOauNJChTbE6diMSH4ZOCbaiMa4aWeGYDfn59kHwEfX59fIl9A3x7fIR9AX6JfwJ9fv9/038IfX1+fn5/fn2FfAx+fn59fHt8fX1+fX2EfIN7hHwNe3x8fHt8fHx7e3x9fIh7A3x7e4Z8gnuGfAl9fXx8e31+f32HfAR9fXx8iX4Gf39+fX59iHwCfXyFfQx/gICAf359fX1+fn+5gBB/f3+Afn1/f3+AgIGAfn9+hnwifXx9fXx8fX5/gIGBgICAfX18fX99fX1/f4CAf39/gIGBgYR/AYCFfQd+fn+AfoCAiIGCgoiBCoCBgIB+gH+AgIGrggWDg4OEhISFD4SEhIWGh4mOi4eGhYSEhIiDxILZgYiAAYHpgOB/AX6GfYJ+hH0BfoV9A3x8foV9AgIEAEOiPJ6TXNuWrdT0n93duJKUypfcdK/Kzvqi3ILWgdTSoIiIgIKIdIWdbTQyMTIyMzQzMTQ0NTY2Njc4ODk5Ojk5OTo5hDoSOzo6Ojs7Ozo7Ozo6Ozo6Ozs7iToCOTqGOQU4OTg5OIQ5Ajg5hzgBN4Y4CDc3Nzg3Nzc4hTcGODg3NzY4izcBNoQ3DDY3NzY3NjY3Njc3OIo3ATaHNwE4hDeEOAo3Nzc4ODg3Nzg4kzcDODg3hTiAOTg4ODk4OTk4O0B2Pzs6Ozs7Ok6Ts7dpNTFMPlJieZo8RE5qh72Hm3CKbnt/lnJarn6UWWJnqG+ZopBffYiMc6ShPktflLCUdXR/foh7lpF2jq5nmIW445WXn8K+oOW2oa+2c7KIf+qmmIOjrbZck3NLY4h/m4RuZq93gIBnTm2Ae3KS16musNfRq76YkK+SXVhPW0+HdXeHo0Q6PD0+P0BAQUNDRERFRUZHSElISElJSUtMTk9RUlNVVVVUVlZXWFhZWltcXl9hYmNmaGhrbW90dUlikWVhbaeMbl95h3lPhbaVg7fTjp+DdXx+iHh4j5GNaYVaT4ldrG23xY5psq2Ab2KBiHu8nbeZdHBVeHrCXIiEqNqpa9r8n6Cvsm2Qk5GQjomJTlZWpZCCbnZ6iXmnbWp4l59hWIhRVFNVV1lZWVZWV1dZWllcW11eYWRlZGNkZmpubm1tb3R9foGFi5Wan6vckp3BvfyGhP/GjpOq1pqCq9jehJy4u/u7ke/Xy6g5lIBvzLqup5qTiYiDf3l2b21vbWpoZ2VlaG5zdm1vc3eCgnJpcoeFfYCKiYiBem5tZ19VUlFQUE5NhE6ATUxMTlBbXVVRT0yZl5mirKiclpKOh398f3t4dnRycXBvb25vbWtqam1tcHBub29tbGtramtpaWhlZWZlYl9eW1paW1taWllaWllXVlZVWFpcYWp1e3tygXVkYWJZWlpUVU5NmJiXnJiRkpqqtbq1rp6Okp2jtregmJOHenx7enNzdYWJiYmCfmtkYmJjaXZ8ZltbXGeCjIGKlI6FgIlvZHWNmYx9cWRvdYWMmLSikY+npaimmo2Dfn15eImmvMG6oIJzbmlmZGRjY11aV1FLQ0JDQ0JJUkxmWFZXVlVVU1NTUlFSUVJPTk5NTUpJSUhGRUREQ4VCA0FAQIQ/DUBAPz8+Pz8/Pj8/QEGGQD9BSFNTSkdFREhLR0pXW1hdY1pLRUJAP0A9PDw8Ozw8OzxAQnVtYXdz3JiYhICEsWC3XW91WaWVhJ+IoprH2Jkty2Z6fHqgkKjY4JTf+M+SkNep+IXHtsnvpNiW5YHo3LGLkYRxiISdv5hpamlphGoKZGttbW5ub29wcIRxBXJycnNyhHMFdHNzdHOGdIV1h3QBc4V0B3NzdHN0dHSFcwx0dHNzc3JzcnNycnOHcoJxh3KJcQ1wcXBxcHBxcXBxcHFxhHAFb3BwcG+GcAFxk3AIb3BvcHBwb3CNbwJub4Zugm+Fbgdvbm9ubm9uim+Abmm0bnBxcXBxbIS+yPGGWlqFXYeQl8xgaX+i1uW4up3VoqDK762I2p/Ui5aS+KjK2uWTsr/FpO3XXnaHzu7MrZiqqLqiv6CDm+yFtaPg/5WVnJCnmvnctpC3h8OWhPXN0LbJ5PuBxaVke7GkuqqEhOCOna+TcJScjKT5tsXA1vKAw+ulsNu+hIRyiXK1sKCk3GNaX2BgYWNjZGVlZmdoaWlrbG1tbm9ucHFydHZ3eHt8fH19f3+AgYOEhYaIiouNj5GSlJaZm52goV56s3Vvea2ffW2NnY9fmtmundD7pr2ZiaKXoI2GrrCjep1vYKNtxYTL9Kh+3saEd6Clk+3D2MGAkIhnjJHra52CttOhhfjwtLXT0YOxtrq7vLi0ZGppyrKfi5WbrpfGhYGSvdJ7bKxrcXF0eHp6eXh4eHl8fXx+foCChIiJiIaIio6RkpKRk5ihpaSor7W5vcbqjH2Zmspub96vgIKVt3thc5ueVGN/jcebf9nIv6SUg3Xf08nDuLIvqqikoJ2Xk5OTlJGPjYuLjJKWmJGSlZadm4+JkZyZlZacmpiTjoeFgHpzcG9ubWuFaktpZ2dpanFxa2dlYsXBw8fNyMC8uLSup6Wmo6GenZqZmJaVlJSTkI+PkJGRkI+PjYyLiomIiIeGhIKCgYB+e3l3dnV1dXR0c3NycXCEboBvcHN5gIaFgIqBdHNza2xsZ2djYMC9vcG8tba6xc3Oy8S5rK+1ucjItrCropqcmZiUlKCioqGal4eEgoKBho6RgXt6e4KWnZacpJ6Wk5qFf4qapJiOhHyCh5SXorepnpqqq6uroZiQi4uHh5Gnub+6pY6BfXl2dHNzc25raGVgWjdZWllYXWNgm5KQkJCOjYyMjIqLiYmIh4aGhYSCgYB/fXx7e3p5eXl4eHd2dnZ1dXV2dnV1dHR1hHRHdXV2dXZ2dXZ2e4ODfHt5eXt9enyFiIaJjoh9eXZ1c3NycXBwb29vbmRnaZ2Jfo+L/LWwiIWiznzdiJOXfcuLdbW30s7f86s0375/ZLxiPUhbdk9knKtgVUo2WChaZ0dTN1A4XDdoaltBRDcyMC84TaPO4+bm6Ojn4NPi5oTlDuTl5eTk5OXm5uXm5+fnhugO6enp6unq6enr6urp6uqK6Rrq6+rq6+nq6enq6enq6erp6urp6urp6eno54ToCufn6Ofn5+bn5+eF5oXlEebk5eTl5OTk5eTk4+Li4uHihOEE4ODf34bghd4H3d/d3t3d3YXcCdvb29ra2djY2YbXFNbV1tXV1NTU09PU09PS09LS09PTidIB04XSgNHR0MWd2LXQ0dDR0MW6b2NpUoSa3IifVlypgIK2nr6RY3dx8ZRvmcB9T3tYa0BCQqmgiJjQvatTY1R1wIeNQFdtc11TXFhaVWRZQVbTcoV8fGZFS0lHUlKy3YVUXE+sdkOCUlc9UmzJj7GzjqnzycG0iYjjqKSYc4qHZVd7vmZegGiAhG5iYnXh+sfCo8idhZR2dteHk56foaGio6Skpqaop6qrrK6ur7Cxs7S1tri6u72+wMHCxMTHyMjKzM7O0dPU19jZ3d/h4+bq7fCAksaTl6jTxqyQxsvCitnns52Yn4TKiHGdqLRbUnuUqpnOn4nFi/6Th9+wlsidoJ3OurL7gNze6qOti7Cj9IC0Un1WXIrMtL3D7fas6e7x9PXw64CFgv7hyq6/zOTJ/KSZpdPcjofhjZWWmJudnp+dnZ6foqOjpqanqqywsbCwsbO2u7u6u77Dy83Oz9XZ293l/Y5kdnqbVlu5mnV0gppiSkxiajQ8VmyfhHLMv7qmmoyC+vLpgObc1NDNy8jFv729vLy8uri0tbe8wMG6u7y8v7y0sLS6t7W0t7Wzr6ynpqOemZaUk5KPjo6OjY2Mi4qLi46OiISCgP/8/P7++vXx7url4N3e3NjV1NLPzs3KycjHxMLCwsHBwL69urm4t7W0s7Oxrq2sq6mopqOjoJ+fnp2cm5qZA5iWlIWTgJSYnaCemqGakpCQioqJhoWCgf/9/Pz59PT2+////Pfv5+fq7PX05+Ld19LS0c/NzdHU0tDMysG+vLy7vcHDubW1tLjEx8LGy8fBvsO3tLnDycC5s62vs7q8w9HHvr7IxsbFwLiyr66sqrLBzM/MvayjoJyZl5eWlpKQjouHg4ODKoKBhYmG9vDw7+7u7e3s6+rq6uno5+bl5OLi4eDe3dza2dnY2NfX19XV1YjUBtPU1NPT04TURNXU1NPU1Nfc3NjX1tXX2NfY3d7d4ePf2tfV09TT0tHQ0M/Ozcqkq6ZvR4NCKEI1MC41daqa7s7q8MP1XlWm9eXVbY9fBX1/fn1+iXwPfXx8fX1+fX18fH18fHx9hXwCfX6EfQF+/3/VfwF+h38Xfn19fX5/f35+fXx8fH5+fn18e3x8fX2GfAd7e3t8fHx7hHwBfYR8B3t7fn18fHyIe4R8AX2LfAd9fHx8fX19iHwSfXx9f39+fn1+fn59f359fX59i3wEfX19foV/hX0Bf7mAPn9+f4CAf3+AgIB/gIGAfn5+fHx9fn18fX9+fHx9fn+AgIGBf4B/f3x9fn99fX+Af35/fX59f3+AgYB/foB/hH0Df318hH+IgYOCiIEJf4CAgH9/gIGBq4IBg4SEgoWGhAyFhoeNkI+IhoWEhISHg8WC2IHzgN9/hX6HfQJ+fYR+hHwGfX19fHx9AgIEAC6Nl+2LW9ba9fKPj76Agdj1+ZCudrixgbq159KRk655m8mg58G7k6N9ZjQzMTAyhDSENQ03Nzc5OTk6Ojs6Ozs6hDsIPDs7Ozw7OzyEO4U8Azs7OoQ7Azo7O4o6Ezk5Ojk5OTo5OTk4OTg5OTg5ODmEOAE5izgFNzg4ODeFOAU3ODg4N4U4DTc4Nzg4ODc3Nzg3NzeIOAE3jTgBOYo4ATmHOIM3hTgBN4U4gDc3ODk4ODk4ODk5OTg5OTo5OTo8Pmp1ezs7PD48OzWOfYqiaDs+OVBbiZS7oZN3s7l4lq2cdYFnZleQkpvCeX56amVtmndWeXuwd6Fxf4lsgZ9hi31zdWt3fZGz0MjElneTwoGd8LqGvtW05vKBcZONxa6tgYCWtJKJckJnZmlQgINmdYjDe3tovZqce4eF4p56jMTNxcOPuGeeU2dWZIZysoWNfjg8PT4/Pz9AQUJDREVFRkZHR0lJSUpKS01NTlBTU1RVVVVXV1hZWlpcXF5fYGFiYmZoaWtsb3V5eHNppoh8bYbEgHqNX2ybdHFwfreBtIG+pWmCqn6Vhdd0YpVSSXeifmakcadtXp2nnpxormll2LZ4oI+wsZGsxc3PoNaggIOC46R2x4d/mJqalpCPkkqJdWxpX1d3d32be1iUaX29rINOVlRVVFWEWHRbXF1bW2BeXVxbXV5fYGJkZWhpampscHh+gYKIj5ypyX62qMHh8uen3cjijZ7Llv6KpYWc0rjQmIHfrYfft5p/cs29rqedk42Hg397eHNwb29tampoZmhqbGtnb3BobH15a3uXp8Cpn5SHiH5mX1tWU1BQT4ROJU9OTEtLS01OUVNWUU5MS5dQVqeoq6eqoJSSj4Z+eXV0c3FwcG6EbQxra21vb3Byc3Fvbm2EbIBqa25oZmZkY19eXVxcXV5fYV5cWlhXVlddYmJvc3JoZWNoYlhTVFJPTlFTTJORlJKPkZiboaS2tqejn5GRnZqjopyTiIJ7cHBxcG9xeIR8fn1xbmtpZmhvbWVdYm+HnqWLfY+WmJacl5Cjt72tn5SChYGFh4yUlpCSmqSdqaOVhkx9eHV2faO/uqiSfXJycW5sbm1lWlZST0xKQ0BHUFVeZU5/cWhYVlVUVVNTUlJSUFFQT09OTUxLSklHRkVFRERDQ0NCQkFAQUBAQEFBhUCFP4dAPkFDR0hGSk5Ya2hkaXBpXlpQRkJAPz4+PT08PTw9PkRxzHihi3rOq7F/yLBvfHZywTY3PjpHpsefP1pfjEdIPa2xr6FvnLrq7JONzJuj/uXsoM6F09KJwa/X7amap4We2K7TvtCuwqKaXWphYmttbW1ubm1pa3BxcXFyc3KHc4V0h3UHdnV1dXZ2doV1AXaHdQF0hXWGdIJ1iHQCc3SEcwZycnNzcnKEcwdycnJzcnJzhnIBcYhyiHEBcpdxAXCKcQVwcHFxcYdwA29vcIlvBXBwb29whW8JcHBvcHBwb3BvhHCAb2GZj7twcXJvb2xe0YurwKtqcmqQlr++8NjErfnemc3576m+pZuP4M3F1a2zoouKk9O7hb+4v6jkpsHPo7faismxlqabjpKgzurn/Z6HnMF6nO6Pgbzy0ff3l4mqm9DT46izyODGt5tcj4qOZq6Bja31opmQ1Nfhop6P8q6OmtWA59rahOGDxHOUfpTDmPmerbBWX2BhYWJjZGVlZmdoaWlqa2xsbm9vcHFydHV3eHt8fX1+gIGBgoSFhoeIioyNjpGTlZeYmp2ho56OfbeVg3iIv4SGpWx+sYWChZjQk9KU8MWGn8uSrJX8gnKxZYrBjXi/gbZ+cLLBvL1+0oOH/9WAicGx092wwurt3Z7Yn4yHfv6zguCimrzCxcTAwcRjtZeKhnhvmJiet5ZrvIGb7NelZHRzdHR2eHl6en1+f35+goB/f3+BgYOEhoiJi42OjpGVnKKlpamxvcfcgKOBkq7AvpPSv9N/i6x2vFxnXVuHfph2b8GYe9CtmIR22tHHwbkusa2opZ+cl5aWlZSSj46MjI2OkI6MkpKLjJmVjJeoscGwp5+Vl41/eXdycG1tbIRrgGxraWdnZ2hpamtsZ2RiYsNkaMvLysjIv7i0saylop+dmpmYl5WUlJOSkJCQkZGSkpKPjYyLiomJiIeGh4OCgX99e3l4d3Z3d3d4dnVycG9vb3J1dH6CgHl3dXlza2hpZmRjZGZgvry7ube3ubu+wM3Owr66r7C4tLu5tK2kn5qTdpKSkZCRl52VmJaOjYmHhIWKiYJ8gImaq7GbkaCkpaSno56qur+xp56SlJKTlZmgoJubo6mkramdk4qGhIWKpby4rJuJgYB+fHp8enNraGViYF9ZV1tiZWxyYayinJGPjo6NjIyLi4qJiYiHh4aFg4KBf399fHuEegx5eHl4d3d2dnZ3dnaGdYJ0hHUcdnZ1dXZ4e3t6fYCGk5KOk5iSi4mBenZ1c3NycoRxInBtaY37l7aPiPa1yJTpyIeelZD8V1ltXWO9z7lWfo23Y2Eu5/mHyqRrdarCX1e4pquzdlk5PSRVsk9GQ1Zcg0o9L07Ao2s5TkdoqMyX2Li+4oXlBtrJ2ebl5oXlE+bn5ufp6efo6ejp6erq6uvr6uqE6wHshesK6uvr6urr6+rq64TqAeuE6g7r6+vq6uvp6enr6enq6oTpEOrp6ejp6ejo6Ofn6Ojo5+iE5xzm5ufn5ubm5eTl5eTl5OTk4+Tj4uLj4eHi4eDihOGD4ITfDt7f397e3t3c3N3d29zchNsB2oTZBtjY19fW14TWgtWF1ArT1NTU09TS09PUidOA0tLR0MeAgVXdztDPvsG5m7xASF/ks86/6sSco8K6usmXkGCdz8lvvWxbWYJyboBeYV+HXFvG9cXvVl5Bqp+yml1QYkVjXlFZUUpSUmV+wedORkpTPkVnRD1gdVeTeDM4aXxsW1RIPE+Enbi1gt7QxoOjcXlstpabdJK3vFBPUpyAXU1UdmlwfFjPdvKdtJmtrVCaZI7bhp2foKGio6SlpaanqKmqq6ytrrCxs7S1tri6u72/wMHCxMXGx8nLzc3P0NLU1dja297g4uXn7O/puZ/xwaOTn92isOaQp/KyfoV0g06SX6Kof67hZWtZsn2J7Y69/Hyi3ITQmYCmr8vRm8eAlIK9n1Li0NTXqJfq4J9MalxxWGSxY2G7yMfz+fz7+fr+gOvFsauZjMfI0ujChLabn/rwv4OXl5mZmpydnp6ipKWlpamnqKenqaqsrbCxsrW2t7i7v8XLz83R19/o8oSZZG+CkpZ/yrvKdnySX4w9QDs5VFVxYF+riXLGq5qMgvg87efh2dPOz8rGwsC/vr6/vrm2uLe4uru6t7y7tbS6uLG5wMXPwrq2rq+on5yal5WSkpGPj46Oj46MioqJhIqAiISCgYD/gIL//vz6+PLt6eXh3dnV1NHPzszKycfGxcPDwsHAwcC+u7q5trW0s7Kxr6+sqqmopqSjoqCfn5+enpuamJeWlJOVlpWcnpyXlZOVkYyJiYeFhIWEgf///Pr39vb4+Pn//vbz7ujn6+nr6uXf2dXRzczMy8vJy8/Ky8p1xcPBv7y9vr65tri8xtHUxsDIysrJzMnFztbZ0cjBubq4ubm9wcG8vcHDwcfDu7Otqaio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aPWPsv7TpIThkcJ7s4N28YPAyojhneF1kXp3iOOl4s+Colh3SUaxZ4BMNTRPbYBgdFM2Nzg4Ojs6hDsKPDs8PT08PTw9PoQ9AT6EPYc+Bz09PT49PD2GPAI7PIQ7Ezw7PDw7Ozw7Ozo7Ozs6Ojs6OzuIOgk5Ojs6Ozs6OjuFOoc5DTo5Ojk5ODo5Ojk6OTmOOgo5Ojo5Ojo6OTo5hjoBOYc6Azk6O4Y6DTk5OTo5Ojk6OTo6OjmFOgQ7Ojs7hTqEOxQ8P3ZdwrlyaGejn5Wdkm5+3HqyPYQ+gDNdh32Im3BmmUJkc6dkWXNoVJpqcJdkdIeLpr59Y8la4lxhoFpRiY6PbGpttbeDb1y6g4B9wPFsc3mH8v+BpMOw8pHU3aaCnuZyw4KKfkg7TmJWYkNwjoJmqqCvY7dqhaSBi6baunfAiKa1ytOonZWliJqxnHB3kICcVHA7X2o9gD8/QEFCQkRFRkdHSEhJSUpMTE1OT1FRU1RWVldYWVhaXF1dX2BgYWJlZmhrbG1tbW9wcnV3jHeeipDYhZeaiHamnHiUmLG0kYWGvsGEqHzcmXyOo2BmgXOMWFFqipKHaXm5k5xWnJe9jZZ62tqOhbqNxoGzxurl555xe4q6X19zgGiSl5WRjouBhJGPY1pQYWlUXXttg4OXVE9zlFpdXF5eaV9YWFhWVVNTVVlZWmN6foRmZGJiZGdqbnF0en6Hio+jvuftoI6spard49j058fJ+PbZiaDlgPDRnoHcoobeupeAc9bJurCmnpiPh4V/eXVzb2xrbGpnZ2ZlZmhmZmhngGdoZ2JiZGpscXh4fXZubWpnaHFrW1lbXVdSUVFQTktKSUpMVHp8XlVRTk5OUFNZXqmnqqu+qpiRh3x5dXNycHBwb25ub25tbW5tbm1ubm9wcXFxcG9vcG9tamhmY2FgYGBfXl9iYWBhbnRyb2JhZl9kYV9bWFRTUlJSUVFQVFhSgFFOTFBXU5yXlJOVqZePnJelopqYlJCMjYKChIaCgYOBe3l4foOIhXx3cWtmY2Fmb3N/g3+EkpigmJmWoK+1trWuqqekoJiUlZCIf3hycHB1e3x7foR/cWhuga6woI+FeHBsaGZjYmBdXFhVVlJSeoR+fG5kVlNbX1hRdVVUU1RVHlNUVFJTVFZcVVJTU09NS0pKSUhHRkRERURDQ0JCQoVBA0JDQYRAAT+FQBI/QD9AQUJEUFRYW1ZJR0dDQUCFPyk+Pj6ScHBveXPh0LXApc2Gipq05YPmdYyVzIBJV1FWU0kuVe8xPjg1lzpTpnqI71uS97+dgsKgtYfFjoHljMrUkOqG7Yy1kIOl9bju6IS5e7J6b/KUy3tuZXmMr3qjiGRyc3N0hnWEdgJ3doV3iXgFeXl4eHmEeAZ3eHh3d3iFdwR4d3d2iXcCdneLdgJ1doh1BXR1dXV0h3WKdAFzh3SFc4N0mXMMcnNycnNzc3JycnFyinECcnGFcoJxiHIBcYZyE2i0idXujZKU5tvK6NSHg/6N3WKEdYBYi8WLk9OknKhtmKrwkIOmo4z5n6HEmLjW2/v5vJj2gfuBkfyVguLBvpeTk/jrwJ6A75GTq7L6jIaAb8vsjLTQsfKb8fy9prr6g9a8xK5jV3GSfZBmobawj/XJ5IDjibzfp7TQ/MSS3ZC8zeTVwL+zvKTE3sqIgpep2nimWZCcX4BiYWNkZWdnaGpqa21ubnBwcnJ0dXV3eXp8fn9/gYKDhIaHiImLjI2PkJSWl5mbm52dnqCgnqeMspWh64KPkod6u7OJqrDOy6eint7TkcKR+rKQp8hxeJmMqm1feqGqmnyZw6y3ZK+n1KCli/b7qJjOqd+IrrTh1/avh4WW1nF3i4B+uMLDwsC8rbHCv39zZn6CZnSYhKShvGlkk8F4e3t9f4eBe3t7eXh2dnh7fH2ElJeeioiFhYiKjpKWmJykq6uywdTv8JFsgYKMrbizy8KrqtLNs2x+q161o4Rvt4dzxKuUg3nn2tDHwLexrKilnpuZlpORkY+NjoyLiYqMi4qMjEaKi4mEhIaKi42SkpSOiIeFgYKHgnd2dndxbm1tbGlmZWRlZmuGhHFqZ2VkZWVmam7NysvL1cW5tKukop6cmpiXlpWUk5OShJGEj4COjo6NjYyKiomJh4WCgH58enp5eHh3eXd3d4GEgn92dnhzd3Vzb21qaWloZ2ZlZWZqZWNhX2JnZMC7uLe1wraxuLS+ubSzrqqnp6CfoaKem52blpWUlpqem5WSjYmFg4GEiY2VlpOXo6erpqalrLa5urm0sq+sqaKfoJ2Vj4iDgUiChYmJiIuPjIF7f4utr6OXj4V/e3d3dHJxbm1qZ2dlZYGIhIJ4cWZkaW1oY6WPjo2NjYyMi4uLjI2RjIqKiYaEg4KBgH99fHyEewR6eXl4iXeCdoR1Q3Z2dXV0dXZ2d3qBhYiKhn18e3l3dnV0dHRzc3JxzouVnK6V7+7QzrHjmJiUt+1/34SXo9+GXWl3e3FgSm+4Tm1VT5JbOsTI2Pg0fd2WfX+GW0orSFoxVSlcVDJYP5p8sEA7YrA0TUc0X4vkqoW/gdzM2cCqfb6Cz+K+5ebn5ufn5ubo5+nq6+vq7Ovr6+zs6+zs7O3t7ezt7u3u7u3s7oTtA+7t7oXtDe7s7u3t7O3s7ezr7OuF7Anr7Ozr6+rr7O2E7IfrBOrr6uuE6gPp6umF6Arn6Ofn6Ojm5uXmhOUC5OWH5IbiB+Hg4eHh4OCE34TeFN3e3d3c3Nzb3Nvb2trZ2NjZ2NjYhNcE1tbW14bWgtWE1oDV1tTV1NTT0rP9k4hmTHJ5iY2rxM1LOW87opHR09PSi5Z5V2ObmcCYo9TIxIllXFdliFtidU9mvtaVush6jTlxNT3jZFR9a2dPV0+PiYJVRIlafNeUlmRPVUNeXC5DV1yBT1xfTnJmjk1/mnyvg4Kz7MnmkJ5rYE+GdYJMi0iUv4BeaoGahHytaKeExJ6uqLjPwMb70nZfZInNnfmEyueZoJ6kpaamqKmpq6ytr7CysrO1tre5u7y+wMHDxMXHyMnLzc7Q0dLU1dnb3d/i4+Xl5+rs7e7qobKbqPqYpamhmOHkpa6vt9m6im5+kGe7la1TaXnLjZnNu+ifjbHq+disjoDK9MODcW6Mh1laoaVqWnKliGFSVoKA0Zl0Z1j1kYizpO/7/Pz8+OPo/vqkloSkp4CYyq3W0vWIgLT6m5yeoaOopaGhoZ+fnp6fpKSlqbO3vLGwrq6ytbe8v8DFytLQ1uPv/vyLVWNncYWQkaOhk5CxrZdWY31FiIBtXZx2Z7enlkmKhP/17uXf2dTRzcrGwr++vLu5ube2t7S0tre2tre2tLSzrq6vsbGytbOzrqqqp6SjpaGamZiXlJGQkI+MiYiGhoeKmZaMiIWDhIKAg4T+/fv5//Pr5uHc2NXT0M7Ny8nHx8bEw8LBv7+8vLy7urq3t7SzsrGvrqyqqKWkoqGgn56dnZycm6CioZ6Yl5mVl5WTkY+NjIuKiIeHhoaHhIOBgICDgvz49vTy+PDt7uzw7Ofl4t3b29fV1NPSz9DLyMfGysrMysbEwr++vLlRury+wsLAwsjMzsrL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e8OQubTEZ7mqhKCflr/T8Z2ukIaaiqeCnrDvoXy4xK+Aeolro1mIYrqd3YDBlrezvvfh78eg+q7f4K/Z2cGaqqK6+YK6tZhufoqlwMLBwb+0v8CxlsOSZoC3t6d6qHV6anFvc3qBgX17eXp4enp4dXRycnN2gZmjoqOUkZCNjpCUmJ2lrrO0u9nh8Zyqw3B2gnlseIyTodJ6gr+bv4qUem+5rYh00ryqoJKEe2vk18vBubSuqqamoZ+cmJSTk5COj4+PkI+OjpCSlJuXl52blZWQkJOSi4eHhIOCf319enh5e396dXFvbWlnZmhudX+AcGpnZmdnZ2hpaGbKx8hucM3AuaegnZuamZeXlpWUlZSSkZCQkI+PjoSNgIyMi4qJh4WEgoF/fHp5eHd2dnZ5fnt5foF+dXFxd3dubWxramloZ2ZmZWVkZGRjYmC/vr68vcHBxWdqx8jL0NDEtbS2sbOup6mlpKSlpZ6amZiZmZSUj42IhYWFg4aGi5GYk5ykp6GfobS/u7y+u7ewq6ikpaSbk4yIgn56e39/K32BhoN7dnmBnaGclYyDfnl0cXB1dHFxb2pmZWh4fH95cmliX2hsbF+nlI6EjReMjI2MjpKVmJKNi4iHhYSEgoGAf319fIR7A3p5eYR4hHeGdgF1h3YJd3d4eXl5eHZ2hHUudHV0dHNzcnCyi8Hc8I/WtMa9uv3ugNDso9K8y3+F3fp9e3/acXt1f3B7VohwhUZvoIbThzJ0VHdzynCUQEdMTDA+STNfXFaJ36GecMJvTG7gmkttwLbbeuWnytWvlYKc+Iv/zObn5ufm5ufn5+bp6uvr7ezsie0L7u/v7u7v7u/v7u+E7gTv7u7vhu4B74juEu3t7O3s7ezr6+zs6+zs7O3t7ITtCezt7ezs6+zr7ITrheoK6erq6unp6Onp6YTohOcL5uXm5eTm5eTl5OSE4yPi4uPj4uHh4ODg4d/g39/e397d3d3c3N3d29vb2tnZ2tnZ2YTYhdcG2NfY19bYhteE1oDU05m9sn90T2KFb1NIbnyYaYZbiaa/4piaoaSTfo2MYqSMkpuLrNmMl4lPYYFgbk9XVF9WU3mJn2BaU097kn98ZW5ViYeBdHJRV4B5k35iYFFu+5VsQW8wPnleNUVNRG51UFNwWJig0KGSoYyeseywgHmGg29/cIR8jYA8S2Nxf4Bu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d3F1fYGNmpuMgXx3cHJ0fH57d29rZWNkanh9dGphX19hYmGonpWPjo2NjoyOjpCPkpmYk42KioiHhoaFg4KBgH9+fXx8e3p6hXkBeIZ3A3Z2d4h2hncBdoR1MHR0dXR0dHNjtGygo7CDiJ772vvhx/bhu/P01rb02obb6+Kgy4yO4KFubJbpfZeAj1FcysSpiUty0ODZ2WVXZmBaMjZLRz08VV5D4oJwmo9gSUtxXWDZjWBKm+eoh67pjn/12tbXsYHhy+fn5ubew46x6uvs7Ozt7u3t7u7u7+/u7++F8APv8PGF8IvvFu7w7+/u7+/u7u3t7ezr3ens7Ovs7OuE7Qru7u7t7u3u7e3uhe0Q7O3s7Ovr7Ovr7Ovq6+vp6oTpA+jp6YXohOeE5R/k5OXk4+Tj5OPj4uHh4uHh4eDh4N/g397f3t7d3d3chduE2oDZ2djZ2dnY2NnY2dnZ2NjY19jX2NfX1tbV1JLYYk+ATk5IUE84XlRtXlJKS6yRZLTWvJTJp2Wbas7DvZyAwqrYpFSMmpFtUl5MY5KCSkRxXFpaXl98hXq11LyQiYCEbWtYTl1eXn+maW60iJtPSU1BX0JXWoNOlKF4V3R0jXystoB7y6qPtIuEenqLXU94ZmxhXVRgbG9oh1d+lX5zeLnsoLK/g6SfuXR0elpCUpyY58270L2irZaoqKqrrK2usLCys7S1tre5ury+v8HDxcbIyszNz8/R09TW19jY29zd3+Di5Ofo6u3u1sSOud6oju6Qkbj2y3rKwWWnZrBXja60tVd9bdt74o+2cZW13ZqC3oKQyKD8uPS7g86Wtp+AfeGjU213r9aRlGNxo3Vzw9d+wO6h+svz9vf5+/z3/PvlmZD6/ZLB+PTei5KYloeTlp2goZ+dmpmbnZyEm4Cam6CosLS0tbq9wL29vsHHy87Q09/h7IOLio2UTlBOjYSBjKVqhY9jinxvsJ+EhXdwab+wpZuRioWB++/n4trX0s/NysrFw8PCvry+wb/Av7+/wcTCxMbFxcPBvbm3s7Kuq6inp6alpKKioJ6bnJ2empiWlZOQjIuNjpKNjI2LiYCHh4eGhoqJgoP/+4H98+zm4tzX1NLQzszKyMjHxsTDwsG/v728vLu5uLa1s7Kwr6yrqqmmpKOhoJ6dnJubnZqYmJiXlJOSkZGPj42Ni4uKiomHhoaFhIOC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iNqg/L6zgGB6sYza78GtiJW64PnX1pL8rJ6+s2qFh7WCqKi7jZuTvPGnnsyty4rpoL+idl9oaWprbG1ub3BxcnN0dnZ4eHp8fn+Bg4SGiIuLi4yMjY6Pj5CRkpKTlJaZnJ6goaSloptq2bGPsqLBmm+N0paZnK7fhMPB57ChyNB9jKST87H5TYh1hpS1h6TyqXm8YYOkdniO/Yy2oY6qi4eXo4qG66qut5zWjO2C3YGGqXyovL7GysfBwcO3mXhjYY9ukaeOr2l2cnJ8fHp6end1dHR2hXeAdnd5fICFjI+SlpucnZuanJ2dnaCossvqfYSHm7ZfZmqNeovQroTMx3uMv62Xh3984MjHtqKUi4N9dePc1M3Eu7Ouq6ilo5+enZ2doKCdnp6am5yZlJWRjYuMi4iHiIeEg4B/fHt6e3p6ent5eHd3dXNycXR1dnRwbm94endwcG0ba2lqbW1re3lu0MzHyMjAu7Ovq6ilo6GenJuZhJiAlpaXlZSWmpmXlZKQkJCNjY2Kh4WDg4GAfXx6eHd4eXx5dXRzcnJycW9ubGxraWhoaGdnZWVkYmJhYF+9vLy6ur29wMdpa9HMzdbSysPAu7aztLayr66ur6+vrqinrqikpJuck5KTpKaUmqWhnKSmp6imra+4vr6/vb+6sq2uraZaoqGXkYuBeXR0eHl3eXh1cnBzenuMlJeLf3p1cHByeoJ8d3NtaWdmZGlxbmdhX19eWq6kmZSRj4+Pjo6Oj4+QkZSSj46MioiIh4eGhYSDgoF/f359fHx6e3p6hHkNeHd3eHh3dnd3d3Z2doZ3g3aHdAF1hHQpqdhWb1/yxMKnrL+D8efDsprMjLm4vM2H34Orvru93sRdbldnd/Lo48ZjVEenZMFZR5vIZGZXa73rjEZmhFNZY0xOWXdjWXWsdYYwLkGMfFQ/UrOkdbeEd1F56Yieqpd71Jbn576qmf/cmezs7e7u7u/u7u7v7u/w8PDx8PHw8fHy8fLx8fLx8PHx8PDxhfAD8fDxhPAY7/Dv7rWM4qGSvOvruebr6+vs7e3v7u/uh+8D7u7vhO6D7YnshesO6urp6unq6eno6Ojn5+eE5gbl5uXl5OWE44TiA+Hh4oXgCd/e39/e3t3d3YTcDtvb29ra29ra2tnZ2tnahdmA2NnY2NfX19bV1KnMVkaEZn9wQzUvUUpLPk4/YmBvdkNNkqXYhMLknNTesbbBg5Kiq2Nuy7qEWml0kq+AaX+CWGeBelhlXICOhIecU052W46NXI6Fk4mRSGNRa3ZiTGhwQ2FqbmqFeG9cXn3Dz3fX9G5ufb6Fso60h6aXZIePbGOARU1QZod8c0y6cmGYsIWqlo96lJnuk2xNc5ZhZcumt2a0m8bMppipqqusra2vsLGytLS2uLm5u76/wcPExsjKzM3P0NDR0tPU1tfY2dvb3uDi5Ofq7fD07eGO0byWmIPOt4CQwWl7mryya3So4Z6giaOAkICR6rzma5ayrMC54PyAwZP3kKnWmYmBwGlqk4NnU0FIfYV4i2h9mYyKYJV7+oqhzaDb9Pb8///8/v/wx56EgrySwd255YmXk5GcnZydnZuZmZmbm5ycnZycnp+ipaqytbi8wMLDwcDCwcPCw8rN3fJ9gH+FjUhMT3txfqqYbqKmZnSomIV2cW3MvbiwoJgxkIqFgPn07ebj29bSz83MysjExcPExsjFxcTCw8PBvLy4tbO0sq+ur62rqqeloqGhoYSgFp6dnJqZl5aVlpWVk5CPj5KSkIuLiYeEhliEjYuD//v49vXx7ebi39zZ19XS0M7MysnIx8XFxMPBwsLBv726ubi2tbOysK2rqqimpaOioJ6dnJydm5iXlpSTk5KRj46NjIyLiomIiIaFhYSDgoGA//77hPmA+PyBgP/7+v/89/Hu6ubj4uLg3dvc2tna19LR1dLOz8nJw8LCzMzCxcrHxMnKycrKzM7S1NfV1dXRzMnIycK/vbaxrKSdmZmbnJudnJyZmZucnqitr6aempaTk5SYnpmXk46MioyKjZCOiISCgoOA/fXx8O3t6+vr6uzr7ezt7+0h6+rp5ubm5eTk4+Lh4N/d3Nzb2tna2djY2NfX1tXV1tbWi9UF1tTU1dWE1ILThtQq0sWPgMeU4olYR2J3KlFkNzw+OzJSWV1+R2MvSmqLiJewmMiPuKHCXGJnCH18fH19fXx+hX2DfIV9hXwGfXx8fH18hH2CfIV9iHwEfX18fIZ/gn24fwF+/38Jf399fX18fXx8iX0ffHx9fH19fX5+f358fn5+fX19f358e3t7fHx7e3t8fY17BHx/f32Ee4J6hHsCfHuEfAR7fHx7hnwBe4h8Dn19fXx8e3x7e3x+fnx8hHuIfA57fHx8fX9/fn1+fX1+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k5CRkYyLiYeIgoKFh4V/e3p4d3V0c3JxcXFvbmxqaWloaGdmZWRiYWBhX1++vbu8u4C7xMHAy2tsbmvM09DOycO/tbCtrbKuqaSlo6KfnJ6mqKGjoaObm52goqCnsKuop6aioaCsu73MyMC8uLKzsK+rpqWckYmFfnZydnh3dnV0dG9qbHR3eYOKgnp3dG5ucXB4fHh2cWxqa2FbY2hkY2RhWqelpJiTkpaUj4+QkJCPjx+QkZCUko2LiomJiIiHhoWEg4KBgH99fXx8e3t7enp5iXgMd3d3dnd3d3h3dnZ2hXUxdHR1dHR1dHRxhbNebHBYqMbM69TDtoiEnZ2UqaqJ0+Og35bl8uCDj7BZYWhdnMjUz0iaTVA4SkliQFZYVHY+Q2F/jth0z1GIeNl6N0p7VF9UbWlKfGZPU05YXFs6YiucgY11RF6giq+cw8qv0ZSEmvPl7O3u7+7v7++F8Afx8vHy8vLzhPII8/Lx8vLx8vKF8SDy8fHy8vLx8vHx8fDa0NSusWF7zOrWtJvA3OHs7e3v74zwA+/w8ITvDO7t7u7t7e7s7ezt64TsFerr6+rq6eno6eno6Ojn5+fm5ebm5YXkGOPj4uPj4+Li4uHh4eDg39/g3t7e3N3d3YTcCdvc29vb2trb24Tah9mA2tjX19bRhIhURU+ScFJbXC9TMTw+Nll6ZUdCRHh4b46zoa63i/Kq6IuMgrTDrJuqmoyMpIBng2RbcXN3ZYd9Z1xncWK/hIOe5rlwbG7YrW56cH9CVVi9gUVSYWhaXm5nQlGNeWFNWqiefVjSw33xlZKDucOji+VuXoRwmW5OTkeAZ1mJbqpqYH3UxeundXFkh9WdjpeAgG5enp2Up5ijuMX3qKqrq6ytrrCxsrS1tra5ubq8v8DCw8TGycvLzM7Qz9DQ0tPV1tbY29zf4ePm6u3w8/b3pO2qmIinhY+SmPCsk6/voHSHYpOwa2LwsYqMr3La7KOruuuFiKmRr56ix+eAmpqIgJRufX7P/7t7jEKnrqXqpFJI4MS+cKnX1pXh8fDy9f6A//+A9+jkl4X9goD3/LGTmZqbm5qanJ6enZ2dnJydnJubnqGmq7G2ucnOvsLGwcLAv7y8vb7AxMzV297b5X2Jj5lSWFJeZneQj36FkZJpxcG4u7Onp6KZkIqGgftG8u3n4+Da19PPzc3Mx8XGyMjJxcK/vry6uLi1sbCvrq6rrKyrqKampqSjoZ+dnZybmpqZl5WUk5ORkZOTkpCOj46NjYqHh4SGgIWDhYSC/PX18e/s5+Pf3NrY1tbT0dDPzczKycfGw8LBwL+/vr28u7++t7W0s7CurKurp6WnqKahnp2bmZiXlpSUk5KRj46Ni4uKiYiHh4WEgoKBgYD//fz6+vn9+vn/goKDgPr+/fr18e3m49/f4N3Z19bU09DOztDSzs3LzMbIU8jIycfLz83MysjGxsTL1dXf3NbT0MvMzMnGwcC5sKqmoZuXmZuamZmZmpiWl5qbm6Gkn5qXlJGSlJOXmZeWkY6NjYiEiYuHhoaEgfv49vHw7+/thewj7evr7Ozt7Ono5ubl5OPk5OLi4ODf3t3c29ra2djX2NfX1tWE1kXX1tbV1dXW1tXW1tXV1NXU09TU09PU1NTV1NTTy5ZulKzChYZNQ1EzOjwpLTAzKzYwLU2nPkZTyb1ONmrDlqS2oM6TV1YHfX18fX19fIV9B35+fXx8fX2GfAV9fXx9fYR8BX19fXx8hH0UfH18e3t7fHx8e3t9fn9/fX1+fX60fwx+fn9+fn9/f35/f376fwF+hH2EfAJ9fIR9G3x7e3x9fXx8fX5/f39+f359fX5+fnx7e3t9fIR7AXyNewx8fX59e3t8fHt8fHyEe4V8gn2GfBl9fHt7e3x9fX18fX18fH19fHx8fX9/fHx8hHuFfAl9fHt8fHx9fn6FfBF9fHx8fn59fX18enp7fHx+f7SAEX19f359fX5/f35+fHx9fn1+h3wbfn99fX1+fn6AgH9/gIF+f4CAgH9/gX98fX5/hH4QfX1/gH1+fn19fn1+fX6Af4eBBIKBgYKEgQeCgX+CgYCBr4KEg42EjYPQgtCBioCEgeiA0X8Cfn2Ef5J9AXyEfYN+hH8Efn19fQICBABHhGLryKrYkNrjytiPjInExOzFtayXid/34IPrx+3QpaqCkdhygnabcXh40pzFn72vrI6TZl5jZZpTY3+geqeFRURBQkFCQUCEQYRCA0NCQoVDDkJCQ0JDQkJBQkJAQUFChEEBQIZBFEBChHl9Snx5SUdHb3VEWUNCRkBAhj+EQAE/hECEPwE+hD8SQD4+Pz9APz8/QD8/P0BAQEFAhT8EQD8/P4Q+ED89Pj8+Pz49Pj4/Pj4/Pj2EPgE9hT4BPYg+AT2IPgM/Pj+EPgE/hj6APT8+NoxnxGZqlaHLol13ktq4iHV2ZpOikoVoo3ZSMC5UPDxhb1UybVtCaGJZPk5UobaDlISDjX6GgKWWc2hwpLt2fmjUpK2ko+vB06Wkz7b15ZNwfZ+A452SkYqsxI7yjJGewayPh4ysmpF+p49XaHy0klN5nbqapISZZ8l7Z4iAlYDFfpWEWI3IwWm/hLeLnXZRgpR3YKB2rY6EhFBCRUZHR0lKS0xMTU1OUFFSU1NVVlhZWlxdXV1eX2BfX2BfYGFiY2VlZ2hrbG9yc3Z3dnpufoybUKituM6DzZqxo5l5uLprjI+yep6ah3zBe7e8gqmBZo2MU1VZiHlciFZfpaQzbZfMiJeku3m+1na0yXnSnpexfX56p2d5jJSYlJKQj5KTkpCQjYiOa0hgZEtkW39VWFlbhF9xYG5iXV5eX3txYVtjeoZyc3eDhIeAgIN8eXV1eHl6fHuAhIiMj5OgstXh74mWopmSsMXCyKiarb7HuK+3uKKZmZKEd2/Qx8S9r6ainJaRj4uHgn57e3l4dnV0cW5ta2pqaGVlYmBfXVxcW1tZWFhXVlaEVQtUU1JRUE9OTk9QUoZTgFFRU1JPUFFVVVdTUVJSoZ6ZlpWTjoiEgX98ent8enp7e3p6fH1/fHp6eHh7e3t9ent/e3d1eXuFlJCWl3pwdXyJjIBwaWhlYmFdXVtaWVdWVFNUVFNRUE9NTEpKSZCPj5GQkZGQkZCRq19eXLyup6egnJaRj4eCgX5+e3t6eXV0gHV3fo+ZoZqQlaWokYONk5ibmpmZlZOitsfK1czBtqyrr6aempSYjIJ4b2dhXmNmZGJiX1hOTE1XY2Zna2hnY19aX2BUUFVfZGdiXFxSP0BETFBKQXJoampeXF1ob2tuX1tcW1lXWVxgWVVTVFRTUlJRUFBQTk5MS0pJSEZFRUVECEVDQ0JBQkJBhEKGQYZANj9AP0BAPz8+Pz8/QEFBXrmKuF5FZpqowpiPdtRvzc3ffICjsKOqtnWjjq62s2N0f0NDcMazm0idf/fporxUzfDpy3J0gKvMybDBsaCT2vLYfPji9+O4vJim+oCbiLSIi5D6vOS//ObgwMiHj52i4YaJqrycxatkeHx7fHx9fXyHfQR+fn9+h38Jfn9/fn19fn5+hH0Gfn1+fn19hH4VcLmlrGammW1ocoWJcHJlfWh+fX19inwHe3t8e3t7eoZ7g3yFewF8iHuIegV5enl5eYR4g3mFeAF5h3gDd3d4hncFdnd2d3eGdgh3dnd2d3d2d4V2gnWFdoBtXNOR9oiKzrvY3IOdwunPta+5jNjY06Se5sePVFCKYmGfrIFSmpBllYCJY3uC+P/T18K2xr7OyuTYr6K75O2FnYH9ztS9s+G+4aSo1r7l3oaBjGt1yZSTj5OpxpLckbC4+Pavyczr3dSz8MF8kJvmu3Sk4fy3taa/hOShiaymnYDaio2XcLr464HxnNCkvZNqscmWgdSV2ayws25iaGlrbG1ucHFycnN0dXd5eXp8fn+Bg4WFh4eIiYmKioqLjI2OkJKUlZiZnJ6ho6anoqiSm663XsjCv++Q6qzLx62G19eArazNl7mon5jokd/eodGcequoaWpuno9wnmNwr7uCnoDflam2y43J7IbA24jXqJC5nZqIu3eKo7G6ury9vsDDxMPBvLO7i198fmF/daZvc3V4fH19fn6IgH1/f4CSi4B8gpKekZKUoKKkoKGjnpuYmJuanJ+foKaoq6ywvMfa5fGEjpiTjqW4tL2mm6izt6+nraucl5WOhXx24NvY0MbBu1y3tK6sqaajn6Cfn5ybmpiUkZGOjYyLiIaFgoF/fn59fHt6enh4d3V1dXRzcnFwb21sbGxtbm9vbm1tbGtqbGpnZ2hqa2toZmZmysXAvr26trGtqqalo6KioZ+fn4WegJyamZeWl5eWlpWVl5WRjpCRlaCdoKGMhYiMlZaMgnx8eXd2c3NxcG5ta2pqaWloZ2VkY2JhX1+9vLu7uru6ubm3uMhramjSyMTCvbm0sq6opaKhoJ6cnZmXlpaWmqWssK2kp7CxoZefoqeop6ano6KsusbI0MrBuLKwsqumpKChXZiPh4B4c3F0dnVzc3JuZ2ZnbXR2dnl2dXJvbHBxaWdpb3N0cGxsZlhYW2BjXlilnp6dl5WVm5+cn5SRkpKRj4+SlJCMi4qKioiHiIaGhoWDg4KBgH5+fXx8e3t7eoh5BHh3d3iGd4d2MnV2dHR0dXV1dHR80b73jWaAtqHKlaKJ7oHRzuCCf6OxrK3EgsOYxN7RgKCrY16QzNmxRUyQl0g1QCVMWGtZRWqKq8+KcqN4ip51vIldtpBzYWNcOkJhNzM2SCorMmJJa42OiqS4j47F1NDarYeCjpqlr4Pa7/Dw74TwBfHx8fLyh/MQ9PT19PT08/Ly8/Ly8vPz8onzGPLx8bflz9CHw6OVjaR4S6SBg+GE7O7v74nxA/Dx8YbwEu7v7/Dv7u/u7+7u7e3s7e3s7YTsBuvq6urp6YXoCefn5ufm5ubl5YXkHuPi4+Pi4uHh4uHf4N/f397d3d3e3d3d3Nzd3N3b3IXbgNra2tva2dra2dnY2NaxjtF3pVVsl2VuYDk+VmVbTVBmWHlobFFSmfbXi4Hiio7a9s6M5+6ZqX6ohZpZiHxkdW5jcGx0bG9rXlhkgotOUkeDdY9hXHiErmdmgm97cUyEpTc3ZExLQztRW1eHS0hfvb58hH2YjaLf9aOGn5XG1ZazgKGVcXFse0BuSYGrYHiWXmKomfBxakV0V6mOgIqE3LBpftyTw4ahxJidqqurrK2trrCysrS1tri6u7y9v8HCxMXHycrKzM7Oz8/R0dTV19ja3N7h5Obp7O7x7PfVz8DXgea8idZ6+9is1c19i6t6b3eHU2hwdJ21ktCyg8CWmeDigJqZpdnKg66Cm7bmkXjwnLDG2X5t4JLj93KJnWuYnKCHq4OqzuHt7/Lz9fn8/f799+35t4Cmq4WtnN6RlJaYm5ydnp+koZ+hoaGrpqCeoqy0sLGzvL/DwMDEwb+8vb6+v8LBwcfIyszP1+Dr9PqDiY6MjJqpqrGinaWtrqmmqaaegJqXk4yFgfn18+3l39zY1NLPzcnJx8XGxsTAwb+8ubm3tbWzsa+sqqmopqampKOioZ+enpycm5qZmJeVk5GRkJCQkZGQj4+OjYyKi4mGhYaGhYWCgYCA/Pj18u/s6OXh3tza19bV1NHQz87NzczLyMXDwcDAv769vLu7uba0tLS2gLy5u7qsp6iqr6+pop2cmpmXlZSSkpCOjYyLi4mIh4aGhIKCgYD+/f38+/v6+Pf19fuCgID++Pbz8Ozo5uLg3NrY1tTT0c/NzMvLy9HU1dLMztPTycLHyMvKysrIxsXM09vc4dzW0MrIysTCv7u7tK2ooZyYlJiamZaWl5aUk5SWK5mYmZiXlZOQjpOUj46Qk5OUkI2OioOChIaGhID79/b08fHw8vPy8u7t7eyE6zDt6+nn5+bl5eXk5OPi4uLg397d3Nvb2tnZ2djY2NfX1tfX19bW1tXW1dbW1dbV1dSE1YrUKdKvbJuDqJJPOTdTMCofVCpIUV4yKjE3NjRENpg+SFBKbLjRjoWOZlI4An1+hH0BfoR9BH5+fn2GfAV9fHx8fYh8HX1+fn19fn5+fX18fHt7e3x7fH19fXx+fXx8fX1+s38Nfn5+f35+f39/fn5/fvp/BX19fH19hHwBfYZ8g3uFfBR9fn9/fn5+fX1+f31+fnx8fX59fJF7g3yOewF8hH2IfAF7i3wDfXx8hX0Dfn18hXsifHt8fX18fHt8fX5/fnx8fHt8fH18fX9+fHx9fHx7e3x9f7SAEn9+foB+fX19fn5/fX5+fXx9fod8GX58fn18fX1+gICAgYGBf4B/foCAfX9/fH6EfxB+fX5/f39+fX59fX9/f36AkYEHgoGAgoGBgbOCmYPQgs+BjICDgeiA0n8Hfnx9fX5/foZ9BXx9fHx8hn0BfIZ9CX5+fn9/fn19fQICBAA/d7O6sqePz8WzzqSyPjp+cIZ68e/Ri2vWdnjVfnuklryQyXTZvnt6r7rFg8LRk5mveW1KQVNtgmt9VlJJsZSlhkIMQ0FCQ0JCQkNDRERDhEQHRURFRENEQ4RCA0NCQ41CHUNIP3uMb3PAjYqCY8KHQ31xOkFBQEFAQEFBQEBAhEECQEGEQAZBQUBAQEGFQAxBQUFAQEFCQUFBQEGFQAZBQEBAP0CGPwNAP0CGPxI+Pz8/Pj4+Pz8/Pj4/Pj4/Pj6EPwo+Pz8+Pj8/QEBAiD+AQD9AP0BAPztoeHGqgGeMwazwk2dtk6N8fpxyiGhjwq6FdH5MUmeJcXVJWGA/Sp1Hdz4zQ2ddm41Tn457gWtunIeJanCea4B4nX9zo7mL0PTRxcaLsqGRo/me5KCRicegrcWv8et9j7N/aKuLbpGCn6+Epnh+bImQdYeIkntprXc/oG22qK/x6Y+Ex6WRdmzHwZSVyr6YopZgWnJ9YYuhiXpdSnFHR0hISktMTU1OT1BRUlNUVlhYWVpaW1xeXl9fhGGAYmNlZmhpamxub3FxcnN1dXR1TVWocJhgmdN6tXtugZ+0f9WWr4F1gYWTrXOYz5lraLV2snlWTFBijmmVr5xnoHmTw3CrcNSEgJOPrr2dvdp+iYaPpo9kaYONmHuWlJCOioiJiYqJi4yLhFhbc2pJfmdQUlVXWFtfXGNqb2hjX2ZncXl0aXJwdoN1b2twbWxwdYOGen2Fh4WEf31+goSHjZirsrOvq7e/w9ZwdnyBhY+eoK2kmqCglIiIg3xxz8jBs6+rpJuXko6LhoaDgnx4eHV1cnFub21qamhlZGJgXl1cW1tZWVhWVYRUNFNTU1JRUE9PT05PUFFRUE9QUVFPTU1PT09RUlRSVFNQnZuZmJSRj5CLiIWEgYCAhYyLhn+EgIB/gIB8e3p7fn19e3h3d3Z1dHyDnJ6QioiFfniKmI+IhIODgX95Z2FeXmBgYF5cXVtYVlNRT01LS0qRkI2OjI2Mi46Sl5yhmpaZmJmakpCKiIaEf357end2dHFvbnJydYGYop6Zm6ShlIiIiYuQkZOZobS4vsPGz8rIvayoppyUj2CKioV8cWljX1xiY2RjYV9aV1BRVl9kYmJfXFlZWWFqZllPUVJeZ2RdTjw5Ozo8cGdkZG1uYV5idXuQSnxoYl9hXFlYV1ZVVFRVVFRTUVFRUk9PTk1LS0pJSEZHRkVFRUSEQ4RCDENCQUFBQEBAQUFAQYZAMD8+P0BAQEFBcI3Ghr5gpoWsx4C1fqWhl6272t/Hk4Hmy4+HdMrRk66scHFzcLiXlUeLytTPvaj59sTVo9FeUpeVqXjw6d6veO+MhueOg6Gf1Jzlhe7mkI3M3eiW3uupr9Gdp29sh6uzlqZ4a2TZwLpkfHx9fX59fYV+g3+EgAiBgYCAgYCAgIt/Jn5/f35/f35/f39+e3Knso+i3bTCtYPuxGK6kl5/gH9/fn1+fn1+iH2FfAJ9fIZ9inwEfXx8fIt7hHoBe4R6iXkDeHl5h3gUd3d3eHd4d3h4d3h3eHh3eHd4d3iJd4B4eHh3ZqmwreeokcH+2f3Uk4+4tpq09JnInZT2/sy+x4GFrPK7vXOHlGltwmieYFRrm4/HzYf54rCooaGuwsuxr96KoIa/oYzR1JnW5tLCxpfTxZGXw4qRkoJtoJCcnZfWyYmt3Z6I6b+nyL3d9r71pZ6BqLOZtMu/oYfYjruG64Dc1enso570ubSVifTrrab58bnbzoiFlqmCtcCyooBnoWlqbGxub3FxcnN0dXd4ent8fn+AgYODhYaHiImJiouMjY6Qk5SWmJmcnp+ho6Smop2fYmfOha5usPiNwY55j6/Tjvqx0JyTn6OvzI23+7B+fOOT1pRpYWV4soGx17x6wICBre+FtILpj5Wfn7bNr9b1iZR6qsGsbHWbqLWVur28u7q5uru8vL29uq9ya5aJYKSHa21xdHZ4fXuAhYmEgX+FjZKPh46NkpySjoyRjo6Sl6OlnJ+mqammoaGhoqSmqq21uLq8wMvT1uN5fYGGipOcnqSelp2clIqJhoB44tvTzD/Iw763srCtqaampKKenJuYmZeVkpKRj42LiIeEg4B/fX18fHp5d3d1dnV0dHRzcnBvbW5tbG1ubm5tbGxsa2qEaIBnaGlqaWpoZsnGw8K+u7q4tbGurKqnp6msqqejoqKioaCgoJyamZiZmZiWlJKSkZCPkpanqJ6amZWPi5agmpSQj4+NjId6dnNycnJxcG5ubmpqZ2VjYmFgX767ubm3uLa1tbi6vcG9urq4uLmzsK2rqKajoaCdm5mXlZOSlJKTnGats66qqrCuppuanJ2goaOnrLi7wMPGzcjHvbCtrKSempaWkYmBenVxb3N0dXVzcW9saGlrcnRzcnBubGtrcHd0a2RlZm50cm5jVlRVVVWmn5ycoqKZlpmlp7Zdp5qWlZWSkI6OjYyEixWKiYiIiIaGhYWEgoKBf31+fn18fHuFegV5eHl4eIp3AnZ3hXYwdXV1dHV1dXCfre6W+IbBi8LLhcCKqq2arbnb2MadhufKmYyA8+yg1d2OlI6S0aGGVFR/ST87LWTVW0pJ666H4+j4lszBtdGI/6F4gTs7YENIPFEvWUQvKzVCRTFOgFlHfq/pk6zj/cp+oZGBgvTptpnr8fDy8fLy8fHy8/Py8/Tz9fT09Ib1MPT19PTz9PPz9PT18/T09PX19PX08/PlxsTCypvGkMz6v4a15YTyh4bt7u7s8PHw8YTyBPHy8vKF8YbwB/Hw7/Dv7++H7hjt7e3s7ezr6+vq6enp6Ojn6Ofn5ufn5eaE5YLkhOMO4uLi4eDg4N/f4N/e396E3QTe3N7dhtyG24Da29vb2tnZ16jtnMDDjmR3e2Z8UklIX1VATnFab0xKho2Wh3Z6mf74rs+02ve3rOqDuJKKqKRpdW1MmHhdaV5ZXGBwXVt4ZJtSZVVTrIdYfo+IeX1miH1zfZBsUVRAP1tNXl5jmYpAR2BNTqx/W29qer+F7riUiIeilImDfIRzmoBieVDiyb+Jtnts07zNmzBkfmRkztCAwemIXI7CsrimpaWSivWqrKytra6vsbKztLa3ubu8vb7AwcLDxcbJysvMzs7P0dLT1dfZ2t7g4uXm6Ort7+jh5YiO76vMndXxjpOMiq3h867fgNFgYmJjbYl1xvzbkpfGftqxi4iPpf285CL+0pLQb5fXeciEn4d1YWWD5cTWw4yleKSWsIGArsfgve3xhPKA8/X3+Pr7+euZjM66g9u0jpCSlZeYm5ueoqSioaCkqKqqpauqrrWwrq6ysbK2usPDvsHHycnGw8LDwcTGytTY2tza3ubu7veBhIiMkJOcnaCemZ2blpGNi4iD/fPv7Oji3NnW1M/MzMnIxcPCwr+/vry6u7i3tbOxr66rqaempaQSpKKgn56dnJybmpqamJaUk5OShJGAj46NjY2Mi4mJiYiHhoeGhIWDgf/8+fb08e7t6Obi4N7b2trb2dbS0dDPzszLycfEw8LAwL68urm3trW0tbi/wLm3tbKuq7C0sKyqqaimpKGZlZOTk5KRj46NjIqIiIaEg4KAgP38+/n39vb19PT19vf08vHx7+7r6ebj4d7c2ddV1dPRz83LycnJx8zV19TQ0NPRysPDwsTGx8fIy9LT1dja3NrZ0sjFxL+6t7Syr6iinJeVkpaXmZiXl5aVk5SUl5WVlJKQkI+OkpeVkIyNjZGTkY+JgoSAF/359/b39vLx8/f2/4D38e/t7ezr6+nphOgZ5ubl5eXk4+Lj4eHg393d3dzb2tva2tnY2ITXAtbXhtYG1dXV1tXWh9WF1CrTwLBkaTqwq1gumnIvUC9CWUVKeqdfTzUpWkRAQTlXUjlwYlqDV3CdPDeMfRF/f35+fX18fHx9fXx9fXx9fYV8HX59fX5+fX19fn18fX18fH19fn59fHx8fX1+fX19tH+EfgF9hH4FfX5/fn73fwZ+fX18fX2LfCB7e3t8fHt7fHx8fX19fHx8fn5+f358fXx+f358fHt7fIx7g3yLewN8e3uEfAR9fHx9hXyCe458Bn19fn18fYV8A3t8e4l8BH1+fn2IfA19fXx8fX58e3x9fn9/tIARfn9+gH59fn1+f39/fn98fH2GfCx9fn1/f398fX1/gIGBgICAf35+f359fn19f399f359fn5/f359f399fn1+gYSAkIEGf4GBgoGBuIKTg8+C0YH1gIx/AYDHfwZ+fXx9fH6FfYp8BX19fHx8h32EfoN9AgIEAEDYcZCMltHVv9iimVk+aWlsRUN4j/6Qhp3MuYijucnAr5Geysav2bGIj6C+wJfcvG9mXWRfX2uaYrVdSDw6OT9ChUMUQkNDRENEREVFRUZFRUZHRkZGRUWERAlDRENDRENDQ0SFQytEQkJCQ0WMQ3p2cH6udXSKcm97ic2/gEJCRUVCRUFCQkJBQUJBQkJBQkFBh0IBQYZCD0FCQUJBQkFCQkFBQUJBQoVBBkBBQUFAQYRABD8/QD+FQAU/Pz9AQI0/BkBAPz9AP4lAgD9AQUFAQUBBQEBAOjJTcF1lXG+Zo/XjkXlseXuWjJemnoGXlWGJlXVxUoxgmWNWWkM1UIp7QWFcV4NtiVRPkXeBgXh1bGVieZpkWGy6haJvooGMka3ahnvRlYRWu96n0a+E4a+5tP2Uh82Ht46hmal1kGVkf3OqmWuLeMmbgJJ8gIS80cfMpZa5nppiicqIg4dwaHm7y6p1tqzBsZxtd31gqGlzbXGfU0NISUpKS0xNTk9RUVJTVFZWV1hYWlpaXFxeX2FiY2VmZ2hqa21wcHFyc3N0dXR2dmxPVH1wZ5ZZWICMgni+dbaMg7LMlrZ1l3yLqqSekoebh6p0hlhlimtzgG97cKGouni+g6WCbnV34ua9vcx4sq/qvYCJzaKHwpSakV9ilpOQlJKJhoaGhYaGgo5TkWqQT2h6UVNUV1pfYmNmaGVrcmxpaGpqdXlwgamYgW1lY2NnbXR5e32Afn99fH1/f4GEjaCysaqon56kssLN2WxweIOKkJeRio2Nh3p4MHdz3cu9t66npKCak46Lh4OBgH18enh3dXBwcG1saWdkYmFgXlxbWlpZWFhXV1VTU4RSgFFQT09OT09QUVBQUE9PUFJRT01MS01QUlNSUVJTUp6Zl5SQj4+QjYmJhoaEiI+UkIuFhISDgoKBf358e3x9fXx6e3V2enZ5gomLiH10cnRubnZ7eXVxbnRubG1rZmdoam1ub2tjYGBcV1RSUE5MS5WSj4+NjI+KmqSilpSOjYyMgI6QjY+Ih4WCgH97eHh2c3BwbWxvbGx5iIeKkJOSjImHhoiMjIaPoLCxsrS1w8XJuKSemZCJg316e3ZvZ2JeXWBiZGFdYV1bW1haWV9hXltZVlVZYW1sY1hSSkdWYVQ8N25raWlnZWJjZGZpZGtxdo9Ie3JpY2dkXVlWVVVUVVVUIVRTU1JRUlFRUE9OTEtKSklISEdFRUZFRERDQ0JDQUFCQoRBB0BBQUFCQUGKQCpBQnGHkORpa4h/rqmw9qhjypnShrDS0oyO4/SMz5e1yYXEmafAw5iKwqlF+IWPl6T69On5l5BtU4CWhWhwk5v8hYqLzsuMpr7Q18ikvOzUw/vJmaGt1NiZ4tuWmo2IkZqx2of+kHFoX2FqfX1+fn9+hn8BgIaBhIKFgQqAgYCBgIGAgIGBhIAegYGAgYGBgHuvcaGNgqvYjJS8m42dtO3eu4GBem+Ah3+FfoR9iH4FfX5+fX2EfoR9hHwBfYl8h3sDent7inqHeQl4eHh5eHl5eXiLeQV4eXl4eIh5gHdoWIuggI6Fn8bZ/++/p4qYn+fQxOnrv+LQj8vEvLqAzZz8iHyOcFWAt5BknJSGu4jGi4HjxLWxoKGXiJudvox5hbqc2JerkYugwOiHhey2mXS+kW+hi2Ornpab65Zw25bevcW+6qe+hJOtmc/EgaOV78Ss0aSy8Pbs7tG/4LWdgHiY/KmmpIiBhd/y0JHd2vf+ypmhsYLXk5qJjN1wYWxtbm9wcXJ0dXZ3eXp8fH1+f4CBgoSFhoiIiouNjpCRk5WXmZqdnqChoqOkpqWijWNqoIt+r2dkkqaJgtqIyqWczeu72Ze1kKPIwcOynrWbz4+ibX2whI+JlYzMzO+Fx4i3gI94g4zk89bR4o3Myu3Wf4Hgr5jUo66ecXi8vLy/vri2tre2trOsu2y1h7xmhaBsbXBydnx/f4KEg4eLh4aGiYmQlI2ataqcjYeEhYiNlZqbnqChoaCfn6CioaOmq7C0s7K1ur/L2OLqdXiBiI+SlI2IjIuHfnx8d+na087Hwr66NrexrKimo6OfnZ2cmpqXlZOTkI+NiYeEg4KBf318e3p5eXh3dnR0c3JxcnFwb25ubm1vb25ubYVsgGpoZmVmaWpqaWhoaWjJxMPAvLq5ubeysa+tq6yxs6+rp6WlpKKioZ+cm5mamZmYlpWSkZSRkZacnZqSi4mKhYSKjYuHhIKFgX9/fHl4eXp7fHx4c3FwbWpnZWRjYWC/vLm5t7a3s7zCwbq3tLGysLGzsLCsqqilo6KgnZuYlpSTgJGQkI+PlqCfoaSmpqCdm5qbn56Zoqy1tre4usTFyLqsqKGalZCLiYiEf3hzcG9xdHRzcXJvb29sbm1xcW9tamppa3F4eHFqZmBeaXBnV1Olo6GgoJ2bm5udnZqfo6W0W6ihm5iZmJKPjY2Mi4qLi4qKiYmIh4eGhoWEg4KCgYCACn9+fX18e3t7enqEeQV4eHd3eIR3OHh4eHd3d3Z2d3V1dXZ1dnWoq6/2g6Kqhsa1r/S+fumZp27SyMyUkOjzmduWwtGN8ri+2smijZ1/V7k/NTJCSkyg0k5WnYSu9snC192+pjteZ864QU9dYFFNNTxLRzpHPiwvNUlJRWCBxubHodHS8sl9/Mi+wqisvu/x8fHy8vPy8vLz9PTz9fT09fX29vX19ob1BvT09fX19IT1L/b19vX19vX089WRqqVmZ8yodJDAopyDmZmY8Ovpy6Ds6PHx8/Pz8vPz8vPy8vLxhPOC8oTxhvCD74XuFO3t7Ozs6+vp6uno6Ojp6Ofn5ufnheYQ5eXl5OTj4+Lj4uLh4eHg4IXfB97e3t3d3t6E3YbcgNvc3d3d3Nzc29WxjsumYV9GTXRmbl1PVUdHP2ZmbXZ5bLKidpV+qMB1g3vjkJ/nw4/R552Z+emrh1h1TkRwXWhuW1hWTFFZeHmWd2tZ7bxuVGFdeZdUXJ94iZfCU0RvVj9vWlZttYJOgU1WVGh4lmZ/S1J3WHCQb6KC17VfdKGEgOKwk6nC082AXImM0niUeU87NG2YioShtb7XkXWWz6ngoKGEfv+amKytrq6vsLGztLW3ubq7vb2+wMHCxMXHyMnLzM7Q0dPV19jb3t/i4+Xn6Ors7uznx4eP6ci475CLm7VRTdGi7bqqzMK5rIZ7WneNg7nHvt3Q543Fh5zuoqateL6X4ejdbHhYjpmPj3R4p6+m2IfMobLjjkirepb4v8O4jJfv8fL19fDw8PHy8/Dl/I/0uP+JsdONj5GTlZqcnJ+hoKKlpKOkp6errqu0wr22sKuoqayxuLq9vsDDwsHAwMLEw8bM0dXX1dXY3ODo7vn8gIOJjZCSlYSQFoyHhYSA/fbt6OXi3tvW0s3LyMfHxcOEwYC/urq6uLe1sq+trKupp6Wko6KioZ+fnZuampmZmJeWlJSTkpKTkpKQj4+OjY2MioiHhoaHh4eGhYSDgv77+fbz8O/u6ufk4+Dd3d3f29fU0dHPzszLycbFw8LBwL+9u7i4uLW1uLq6t7Gtq6qmpaipqKWjoKKenJyZl5WWlpeXloCSkI6NioiHhIOCgYD++/n59/b08vb5+PLx7+3s6+rq6Obk4+Dd29jX1dPQzs3KycjHxcXHzMvLzc7Mx8TDwsLEw8DEy9DQz9DS1tfYzcTAvLezr6uop6SfmpaTk5SXmJeVl5aWlJOUlJSTkY+Nj46Ok5aWko2LiYiNkIyDgP/+/TP8+vj39vX19vP09fj+gPj08e/v7evq6Ojm5ujn5ufm5uTl5OTj4uHh4N/e3t3c3Nvb2tmE2A7W19bX19bX1tXV1tXW1YTWAtXWhNUu1NXU1NPR5pB7iVb3X07JhoeHl4zpeGBM/XtaLSRMWFeDQj9KMFA7TFlYREtdPwZ8fX19fHyFfQx+f35+fn9/fn18fX2GfAJ7fJN9CXx9fX17fHt9frZ/An5/hH4BfYd+A319fvd/AX6EfYp8iHsafHt7fHx8e3x7fH1+f39+fHx+fn59e3t7fHyLexl8fXx7e3x9fHx8e3t7fHx7e3x+fHt9fHx9h3wBe458Fn19fXx9fHx9fHx7e3t8fXx8fH59fHyFfQ58fHx9fHx7e3t8fH1+fIV9AX+2gBF/gIB+fn19fX9+fn59fH18fYV8LX1+f3+Afn5/gICAf35/f35+fn19fH19foB/fn19fn5+f35+fH9+fX19f4CAgJKBBn+BgYKBgbqCkIPQgtGB8YCQfwGAx38Gfn19fH1+hX0MfHx9fHx8fX18fH19hHyNfQICBABAoJLUrdKai6Oulnmd/8qNbjk+fj93i5qZf3WP9aWss72sc8W1qYWimq+GgOHCtVhhPFFCQHCmXU1XbT8/QkNDQ4VEBkVEREZERYVGhUcCRkeERhFFRkZFRUZFRURGRUZFREVERoVEG75om56wgWxtfr9539B/wb95RUONhkRIQkNCQ4ZChEMBQolDD0JCQUJCQkNDQ0JDQ0JDQ4VCA0FCQ4dChUENQEFAQUBBQUBBQUFAQYVAAUGJQARBQEBAiUEDQkJBiUKAPTWMbGKwfV13b3O+pImLd1KAd2hlVH6cd4iASFOPenNfqGhoQz46Q0VJW2V4gnqPUZKngGqFsXZ4dYR9hKePgnzifniZdHPlyeZ9pICPlY+93rqK8dra+Iawi3qHkoN1act9h2Vfs421a3/SdpjFpZehfnpmd4GylqZ9daR8poOAcsB2rK/MyK97hMakpJuSr2e6gpe0ZoWZq2RhRUpLS01NTU9QUFBSU1NTVFVWVlhaW1xeYGBiZGZnaWptb3Fxc3N1dXZ3dXh3d1tvbHmEQ0WKSXtxgauEssdvf8e8jKZck4GHh3ppvneMeWGRor+copSunnFgoYfQwcZ0gMCpt4iAinq3pXeflnOSq8yKwYF7vWWbeK+5jpSdo5ial4N2cF5xbpOAkoZshU1mW1BRU1VYWVteX19fYGBfYWJhYWR/lIxvcHl5eGxlY2VpbW9wcXV5enl8fX9+f4ONpbWztKykoqu4wNHSz9NufH1/gXx3e3p54NXa1svFtrGpopqXlZOAjoqHgYJ+fnl3dXRycW1raWdlZWNgX11eXFtaWVhWVlVUU1JRUVFPUE9PT1BRUVJTVFRTUlFRUFBPTkxLSktQUVFRUFFQT5qXko+Ni42MioeFhYaFhoiHhYSBgoGCfnx9fX18e32AgIKEhX59enl5eHd0cnBvbWtpZ2ZkZGNhYGGAXl9iaWtxdHN9e3x8dm9vZ15YVlJQUE6Zl5WXko6OlKGnp6CuoZmToqWQjI6JhoWCgH59enh4dHNxb2xsa2ppbGtqam5tbGtvb3R/f4KJj5iaoKOnsMC7qZqRi4eBe3RxeHlyamRfX19iYmFkaF5haWNgXVxlXVpWVlxfa3p3aFhFSj4+QUM/NzVqaWhmZWRiYmN8d2Nqa295dGtnYlxcXVtZV1VVVFVUVFNUU1FSUlNSUVBPT01NTEtLSUhHR0ZGRUVEQ0NDhEIDQUFChkEBQohBLUBBQUNDQz9fe2ZRYUtoh3zEdHd2mnWa9IGz6dutvNa6gZOzp8J8lYSshYqh1UC0oe7P+sCQwM+ihqbgpZWOUV+hWZGIoq6QjJT7pK/L2cOH4MSlmL63xICU/6CNdJZeeGxmnu6LdH+kcXd8fX1+hH+FgBeBgYGCgoKDgoKDg4OCg4KDgoGCgYKCgYWCAYGKght+94rAwsSojJGiy47y6IbY3rF4ase5ZmiBgYGFgAh/f4B/f3+Af4SACH+Af35/f39+hX+HfhR9fX5+fX5+fn19fHx8fXx8e3x8fIZ7j3oBeZV6BHt7enuEeoB7cFrYn4/HpoaWhoP03qWyjoHCrI+WgMLtsr26c4jTvLuN+aCYWmVeaGpihaCwsY7NgevFoZGfwqKknK+qreHHrYHyi4yVi5Hj6/iNtZa3mqXEvo9otJmj0n+gjoNus5SDhtyPp5OBys70j4Xsjb3px7jHmJqKmpS8sdedlrOG2YCjjfCT0cnV0uSao+jY1sSz54Xrrb/hjKbC04eDYm1ub3Byc3R1dXd4eXp7fHx+f4CBg4SGh4mLjI6QkpWWmJqcnJ+goqSkpaaopHiXj5+wWVmsWZGAlr2JzPCEkOjbpcBorpmamIyF142xlW+uyt+8y7vWzIx2w6vw2eWPkcDLx4CYoI3RtISimIepwsueuo6g2nCxgr3Mp7fBx8LDvqmZknyWjbijvamBqWOCd2lrbnBzdXd5e3t8fn5+f4GAgIOWpqKOj5aYlo2HhIaJjY+RkpWbnJuen6Ghn6Glrre7uLi7vsbT2eXl5ed4gYGCgXx7fXx76+bm5NzUzMfCvLi0sTCwq6iko6Ohn5yamZeVk5COjIqIh4WDgoGAf318e3l3d3Z1dHJxcHBvb29ubm5vcHCEcYBwbm5sa2ppZ2VlZmlpaWhoaGdlx8PAvbq5ubi1sq+trqysrKupp6ako6OenZ6dnJuampubm5ycmJaUk5KRj42LiIeGg4J/fnx8fHh3d3V1dnt7f4F/hYOFg396enRuamhlZGNhwb+9vbq3trnAxMO/x7+5tb3Asa+vq6mopaOioHCdm5mYlZKSkI6NjIuMjIyLjIuKioyMj5aVl5uhp6arrbC3wb2vpJ2Yk4+JgoCGhoB6dXFxcHNzc3V3cXN3dHFvbnNua2hobG92gX92a2BZWFpcWVRSpKKhn56dm5ucqqibnZ6fpqSempeSk5ORj46MhosbiomJiYiIh4eGhYSEg4OCgoGAfn59fXx7enp6hnmHeIJ5hHiEdy12dnBqdW9ghZWgeJJqi6qOzYuNkLWaftBtucPlrsfy1YimwL/blJeZq319k7k/Y0lORVBNM1PGjI2wyI+t2Yyk7ZjOanC4pJdwoFlWWUU6LEA/NC1IPkYrP5hPQoDuiai7n9Dxk5WD8tvo8/LyhPMN9PPz9PTz9PX19fb29YX2A/j294b2bvX29fb29vX39vf29/f29/b29ePxjY2LlriKsKFaQmBnMWmP172Z5vOMgfDw8vLy8/P09PTz9PTz9PP08/Py8vLz8vHy8fHw8PDv8PDw7+/u7u7t7evs6+rp6uno6Ojp6Ojo6ejn5+fm5ebl5uXlhOSC44TiBeHg3+HghN+L3oXdAd6G3YDb2sCQ/XlpblBNTj44dGZTVUg9YV1aVVCX4XFycoS+1oTZmMWMyoqsoKCng6/VpHpegEl6c1xTXHpfYFRgWmOH58xKd1lpSkBziqyJdKKHwHWRoIFiQXRhdYBSbEc8TqhXOUKUUFVfUXdzmm9UoWmBytTDn0ttQEZXfqH4mpmMeIDminytaYJoZ2JFSmir2O+4ka5juqfO6pyFnrmkvJqurq+vsLKytLa2t7m5ury8vr/BwsPFxsfKzM7Q0tTW2Nvd3+Dh5eXn6evs7umk08ri+4CC/ILRsqOoVLzhgJTO4K7Pg8F/UFlaY4h3npqA7dmdzOG12Oewj+fBzJKhcHGJvoDLpJV6h5VePkpvmJaLepVWiNKL05zh8dLm8fb19e/Zyb2ew7jn1/zeqeWGrZ6KjY6Rk5SWl5iampucnZ6goKChrbe3ra+0trWvqqeprbCys7W4vL6/wMDBwsPEytXb3d7c39/l7fP7/Pz/gomJiIaFhYWEg//++vby7efl4d3Y1IDT0M7LycnFxMHCv768urq3trSysK+tqqmpqKelpKOhoJ+dnZuamJiXl5aWlZOUlJSVlZWUk5KQj46Mi4qIhoaFh4eFhYSDgoD++vf08vDu7Onn5OHh3tzc2tjW09HPzsvKyMfFxMPCwsG/v8C8uri3tbSxsK2rqqimpKOhn56dm4CZmJiXl5iYmZqZm5mamZeTko6Kh4SEgoGA//36+vf18/b4+vj1+fTw7fHx6efm4+Lg3tvY19XT0c7My8jHx8XEwsLBwL/Bv728vLu8v76/wcPHxsfJys7Sz8a+ubaxrqmjoaSkoJqWk5OTl5aXl5iVlpiVk5KTlY+OjIuQkJWamS6UjomFhYWGhIGA//38+vn49/b1/Pry9PT09/fz8e/u7ezr6ujn5ufm5eXm5uXlhOQF4+Lh4eCE3xHd3Nva2tnZ2djY19jX19bX14bWBNXW19eF1i/V1dTUvZnKuJKumfqo3pzDxYePoK2w5N9Qwk+LW0tEbuemWjM4PEYqMzE0Jyk/XoZ8hn0JfHx9fn9/fn9+hX0FfHt8fHyMfQ98fX1+fn59fn58e3x9fH23fwV9fn19fYR+DH1+fX1+fX1+f39+fvR/g32EfIJ9hnyKexZ9fXt7fHx7fH1+f39+fn19fXx7e3t8jXsEfHx8e4V8g3uGfAV7e3x8e4x8AXuEfAt7e3t8fHt8fHx9fYZ8Bnt8fX19fIR9Anx9hXwTfX18fHx7e3t8e3x8fH18fHx+f7OAB4GBgIGAgH6EfTl+fnx9fn6Afn18fHx9fH19fn+Afnx+fn19fn9/fn58fHx9fXx+fX9+fn1+fn19fn5+fH18fX5+gYCQgQmAgYGAf4GCgYG9goqD1ILRgfGA2n8Cfn2FfgN9fXyEfQR+fXx9h3yMfQF8AgIEAD6I6IJzgXeX4eBZaT44Nzcxl5DXqMq7w4h+g7+2kpGJ3KuJvpTsfJq/tozQfafIeG1MeztWPVtjkqVQQUJDRIRFhUYJRUZGR0dGR0dHhEiIR4VGAkdFhEYvRUVGRkVGREVERERAr6WNzGR3urzBu8TJdmyIaHVzTUJFRENERkRDQ0RERENEQ0WHRBlDQ0NERERDRENEQ0NDRENEQ0JDRENEQ0NDhUQEQ0RDQ4VCh0EFQkJBQUKFQYJCh0EBQoVBhkKAQ0JCQkNDQ0JDRENEQ0NBMnluWn+Fr3e1gX2TZouOZrFlnZeJsXSEkFw7Y1x1QFmHSWefaUZSPFV4wrt/m31pWIJtj2+LoKqgi5qHuIRzdM3QyKOSm4GCarGUwsmvw6Kkn4mHjvKwjtmfl+iM3oB4bMNtZpSRnaVxzL1oyWatbmmA4bVmi6XDyJ2doIaaboe+h5CZoMyniXlskW9kdmvGa4t3f896d3qfYztJS01NTk5OUFBRUlJTVFRUVVZXWVtcXmBhYmVnaWttb3BxcnV3eHh5e3t9fXpdVG9neomKR0pMToWFj7SpqOFxloTMaY+ly45uoLC7vIRud4jKr5qLbHiAk22cnmWnydOTn5+rvG1vx5Z2mLzOgd/oynyU2aa4kIWDjpWTlJSQjo5vjKF6hmexb6CGYnCHe5JMTU5QVFZWWFpaWVxdXVxbXWFkZmNsbGdmaGxvbGpnZ2hnaGpsbnBzc3V2dnh6foWYrLS0rqWqrq+7xLzDx8zY3nZzcNhx3uI01MvGyL65s6ehnZeRj4uMiIN/fXx6d3VzcnBubGpoZmRjYmBfXl1cW1paWVhXVVRTUlFRUYRQgE9QUFBRUVJTU1JRUVBPTUxKSUlKTU5PT1BQTpeVko+Ni4qJioqIhoWFhYSFhYSCgoCBgH59fXt6ent9f4B+f358eXd0dHFwb25sa2lpZ2VjY2NhYV9fXWBrbGt1b4CFe3l/enRvdG5nZmNWVFVQnJqYl5aPkZ6ts6KWlJGWpLSlgKKYiomEgoB+fHp5d3ZzcXBwbWxraGhnZWZtbWhmZmZnand3g5GPjpKWlJilopqUjoyHgHhycHh6dG1oZ2RjZGVpbGtlZmlmYV5eYmJYVVNiZ3R6c2BORTo5OTg4NmtqaWdnZmVjYmaAfmVjZmdiYmBfXltbWlpZV1dWVFVWVVVVGVNSUlNTUlJRUFRTT05NTUtJSEdGRkZFRUSEQwNCQkOEQgFBiEKCQYRCK3bCZ3FxPWxka79va2tjlExrZlZLit2AmImml8W0io68paqa9tWf6PuKgNhDkv+VgZiKrPzudZFoWVxZTrKh047Arcqqo43LwqGnnfSvn82j9ICw4tuc7Jqr4qanc7RhhmWSjL3Ifnl8fX5/gIGBgISBBYKCg4KChYOEhASDg4SEhYMFgoODg4SGgwGCh4Mmfm3mv5rYhaXT0d3NyM6FgLSIppZxZH2DgoJ6goKCgYGAgYGBgICIgQKAgYmAA3+AgId/Bn5+f39+fYR+hX2LfAd7fHx8e3t8nXuGfIB3VrinjLub3JDjn4PLj8PBmPuT8dTE/KbCx45lpI6taY/EcqXWnGt8Y4in3vuJu6KNgKuUrpmuq8K7tsqy4qOMjebl56KxsZiXgNLAx+Grr6GMgYxmW56OjuCjnLqb74+EkPuTj8Wt4eiZ7u+M/XnGhILmzISYyezUysLJqbqJrYDhnKitrebDoY6GsJKFm4b/iK6ap/2YlJPMhFJrb3BxcnN0dXZ2d3h5ent8fH5/gIKEhoiJi42PkZSWl5manJ+hoqSmpqioqqZ2bY6EobOyWlxcXJqekr+3uv2An57neqG76qWFsMbN1pyJj5/xzb23i5y2i8HGe8fb666wwq/TgYB62LCIncjOiP/05YaU563XpJiYp7S2ubq4t7OJs82eqYDSiMGpeIeonLlkZmlrcHFydHZ3dnh7e3p5e3+Cg4KKi4eHiI2PjYqIiIiHiYyOj5GTlJeYl5manaGps7e7u73FyMrT2dbZ3uHq7Hp5d+l36urh3dra087Iv7u3tK+rqiipqKShn5ybmZiWlJKQjoyLiYiGhYOBgH9+fX17enl3dnRzcnFxcHBwhW+Abm9vcHBwb25tbGppaGZkZGRmZ2dmZmZlxsPAvbq4t7a1tbOwra6tq6urqaempKOin56dnJqamZqam5mamJaUkY+PjYuJiIaFhIKAfn18e3t5d3Z1dnx8e4F9iIqEgYWCfnp8eXNycGdmZmLCv769u7e4vsnMwLi3tLe/yb+8tKx+qqmloqGfnpyamZaUk5GQjoyLiomIh4qJhoaGhIWHjo+XoaCfoaOipa+rpJ6bmJWOh4F/hoeCfHh3dXR1dXl6enV2eHZxb25ycWpnZXBzfIF8cGNdVlVVVFRTpaOioZ+enpybna2tm5qbnJmZlpWVk5GRkI+OjYyLi4yLi4uKhYkWiIeHiYiFhISDgoF/fn19fXx7e3p6eoR5BXp5eXl4h3kyeHh4d3h3dZz7jZ2vYJ6WgfiMin+DvGSZg2xcjNNun3GVg7OsfpnYq8Ww9Omu8uKZf9Q9PGI6NTQyQF+wise6namljNGRj4LjmbafxoTDhz0+U1UzKTUvUioxQUQ5k5CY3dLwmN6QuJvQp77Hxe/29IbzhPQH9fX19vb19oT3AfiI9wj29/f29vf39oT3MPj2+Pb29vf19fTksvNrc4mQ3HxKcVRLTypVmXC9raGJ0PDx8Mjy8/T09PX19fT09YT0BfPz9PPzhvIC8fKE8BHv8O/v7u3s6+vs6eno5ejo6ITpIujp6Ojn5+fm5+bm5eXl5OTj5OPi4eLi4eDh4eDf4N/f3+CE3wTe397fht4B34TegN3c0IvuvZh3XYVMaz83U0pQRkJ/TpGKkq16ZGhSkuJtdIWVmJPd/dqhwqbZzNPjVHp3VlBoWmVeY2d4al9zWXyAUEh1bG9PVGBGTVPT+qKzbXhoWFVoQDlod4GgVUGGeYE/U3u3U1Rta4GaibmsWN6F65B1kGs8RpPtzuCv0JzDgI9+glZUYl6LZUVGQVuZopJ01ITat6Tsh2h3tq+Bqq6ur7CxsrK0tba3uLq7u72+v8HCxMbJyszO0NPV1tnb297g4uTn6Orr7e/poo+0teH//YGEhYbNtYd8jef/hnSD14bJ0rZ0Y5aEjo6Rkou/4I6PkWNtmHyn5ZWFfXp/Y7WESuaIke6Dg1JeYlHEo9Nnd5VfvMrDwdLj5uns6unjq+T+ua16qZrx4Z2y39D1hoiJjI+QkZOUlJWXmZqZmJqeoKKiqaqpqKmur66shKperK6xsrS2t7i5urq7wMXP2dzh4eLm5efu8u7x9vn+/oGCgP+A///69fDx7erl39rX09HOzMzKx8XDwcC+vbu6uLe1s7KxsK6tqqmop6alpKShoJ+dnJuZmJeXl5aWloeUgJOTkZCPjYuKiYaFhISFhYSDgoKB//z59fPw7+3r6efk4uHe3dva2NXT0dDOzMrIxsTDwsHAwL29vLq3trSzsa+urKqop6WkoqCgnp2bmZiWlpmZmJuYnJ2Zl5qXlJKSkIyLiYSCgoD9/Pr59/Tz9fr99O/v7e3w9e/t6OTh3t3bENjW1NPSz87LysjGxcPBwcCEvX+7urq4uLi8vL/Dw8DDw8PEyMXBvLm2s62nop+kpKCbmZmWlZeXmZqalZaXlZKQkJKRjImIkJKXmZePiYaDgoKBgYD///38+vj39/X1/fzz9PPz8fHw7+3s7Ovq6ujn5ubn5uXm5uXl5OXk5OTj4ePi4eHh397d3Nvb2trZ2dnYhdcG2NjX1tbXhNY119fW1tbX1tXVzYWBhKjtleDkbfusvKrB+5T7tJCGj9pmyk5LQ6C2PWFiLzEvUFFDRlcuKUYCfHuHfIJ+hX+HfQl+fn18fH19fHyEfQF8hX0QfH19fH19fXx+fX59fHt7frl/hH2CfoZ9hn71fwp9fX18fHt8fH19hXyCe4R6FHt7e3x+fXx7fXx7fX18fX5+f358k3sJfHx8e3t7fHt7hHwKfXx8fHt7e3x8fIR9DHx8fHt8e3x8fXx8fIR7C3x7e3x8fn5+fXt7hXyFfQJ+fYh8DX19fH1+fHx7fH19fHuEfAF+sIABf4SAhIEaf359fH1/fX58fX1/f358fH19fHx8fX5+f32GfBF9fH5/fHx8fX19fH5/gH59f4l9BHx9foCMgQ2Af39/foCAgYCAgYGAwYIFg4ODgoPVgtOB74DWfw9+fX5+fn9+fn18fX5+fn2Ffgh9fH19fXx8fId9hnwCfXwCAgQAQ7LDzMGbnn/Spphya289PkiUenmIg53C3XamiJTJkLXdh5ade8fQod2ts3rMlXaqhaCCmqm5ZpKhTD5CREVFRUZGR0aFRxJIR0hHSEdHSElJSUhISElISEiERwJIRoRHLkZHR0dGRkdHR0VFRkVERFpbV662ybHOu6zItbrHw8iFc5WKQkVHl4hFREVFRUSGRQZGRkVFRUaHRQtGRURFREVERUVFRIZFBkZHRUVGRYREikOEQgRDQ0NChUMJQkJCQ0JDQkJBiUMFRERDQ0OFRAFFhESAQjFQQktpeI+sm6zBfaZ/b3lZk2Nfhq9wkJlmXoGelqeWc4KbRm1Kb2d0SExMoZp+aXlUfLPCoIe8o7aqtNDejYa2qbmyp5pyeG2XcpWXpZe267u+keDTi5ra1s2jkvCIq7Kti2qxlaJpoMDLbG2yapyigZeqlqG2oZ2up8ZRcpWAcp+cjbm40MW1hZd/wGa8gHtbr7OsiHashGNBS0xNTk9PUVFSU1NUVFVVVlhYWVlbXV9gY2VoampsbnBxc3Z4ent8foKCgoNvf2+BglZ+llFKTJNcjWaIvbBubqGrx5tkaWmUdoyodYXduruGd5Kjs6eObH2Ium2L0ZJ/a5vBnL8zmZibxa+H3qeCfNd0u6B62ISzfnpzhY2NnXORgVtXaXa7W4x9V4dyT3uSTEtMUFFUWFhYhVYFV1dbXmCEYl9lbG9wb2tlY2NiY2Vpamtsbm5vcXFzdXl/h5Wgnp2boJ2iqKepr7W/xMvXzcvHz8zOxry4ubatq6Scl5SPi4aFhYOAfHp4d3Z0cW9sa2ppZmZkYmFgX15dW1pZWFdWVYRUI1NSUlFSUlFRUVBQUE9PUE9PT05NS0pIRkZHSUtMTE5NlpSThJEMjYyKioiHhoSDgoODhYKEgYB/foCEhoKEgoB+enh0cXBubm1tbGtqaWhlZWNjYWFhYGBgcHt0dnZ5e3R4e3t0c3dwcG9xZ2BjXlanW2ZjnpOZuK6zsbS2tsPX2NTIqrKxmKC4qpWCe3l2dHN1cm1raml0e4iQmZeUkoSDhpCFgYyKiY6Rj4uKjpKSkpSRiIF6eIB/f3pwbm1ua2hub2trZ2dpZGJdWldVVVNRWmZsbWBNR0E6OTk3N21sa2tpaWlnZWNlR0drY2JgYF9eXVxbWlpZWFdWVlZXV1ZVVFVUVFNTU1JSU1VXUFBPTk1LSkhHR0ZGRkVERERDQ0JCQ0NDQkNDQkJCQ0NDQkJDQkJCQ3eLcyiUkXygO0FycLLTgGVkrZ6teVauvdzQmMq04ZWy0Nabi+a2vaaGvX6XPrjX4ua1uJXywrGdnKBoYm/AnpGwg6Ld5YWooKXCkrfwj6qmh7vnrs/H0YL0zZnUqrKfwdDrj8bMd3F9fn9/hYGDgoWDBYSEhIWEi4WHhAWFhISEg4iEHYWEhG+JfHTV0+bK5tO1y76949zZpYnPwmaEgNbBhIOWgoaBAoCBiYARfnFlfn9/f35+fn9+fn59fX6FfQF8hn2LfAF7jXwFfX18fHyEfYB+fHhThWt1o6e5yL3Vvavir6KnjO6Xi8jtjM/EmJfN8er/6JvP8m6ZcbGjuHNwaKK+vZmkhabF4sqpxai1ucTl7Kqh4cvApLfBgImavpKvq6iOpd2d1nePipLE5dfPd5L4ms/a6rqR6q7Rgsnp/YSI14PCvpupza7D4LKv08ryZ4CUs4KqpI7F1fLk2pO7nu6A9qibd9ra2K6J3KCCWm1vcHFzdHV2d3h5enp7fH1+f4GCg4WHiYyOkJKUlZeam5yfoaOmqaqrrK2tkqWMnZ9soLpiXF2saahwnNTEd32QxfCyb3p8qJKkzYyd/unnn4ytx+LcxISXt+aPneemlna5zICo1KajtNuuh/K0mILqiMLChP2Yy5ORiqSys8OKtJ5zbIaR3XOummuWjmGXvmNlZ2ttcHR0dHN0c3N0dHZ6fX+BgYKChIuOkI6LhoSDg4OHiouNjY6QkZGTk5WYnaKnrK+xtbu7vsLCw8jN1dje5N/f3N/e3dnTzs3MxcS8t7OwrSippqSkpKCdm5mYl5aUko+NjIuKiYaGhIKBgH9+fHt6eHd2dXV0dHNyhHEVcHBvb29ubW1ubWxsamhmZWNhYGFjhGWAZMbEw7++vr26t7W1s7Gvrauqqqmop6alpKOioaGfnZ2fn5ycm5qXlZKQjoyKiYiHhoWEgoF+fXx7enl4eHd3gIeCg4KDhICCgoJ9fH56eXh6c25va2bIaXFuv7m90cnLyMrLy9Pf393UwMXEsrfGu62gnJuZlpWWk4+Ni4uRlJxfo6eloqKXmJifl5aenJudoKCcm56fnp2fm5SOiIWLioaAfX19e3h7fHl5dnZ3c3Fua2lnZ2RjanJ2d29iXltWVVRUU6elpKOioKCfnZubW1uemZmYmJaVlJOSkpCQj46FjQiLjIyLi4qKioSJFoqMh4aFhYOCgYB/fn58fHt7fHp6enmIejd5eXl6enl5eXh5eHizqJTJvKbeWl6libPHfnVwrrLRlWOmuJ2ti6KJ1KfU79ydeu2xrpiRyoSiRj5aU1hOUziAipa0uMC4qa/UimnnhZCMXVqcvJlVOm9hKC8yKExRLEQ0UmTL77vxvZiA2J25n8XXy9r29vX19PT09fT19fWE9gL39oT3Avj3ifgD9/f4hfcv+Pj3+Pj49/f39vb29fb1rbujj/7ClJRdWUZQQT5GS1CBguPUhe3c/uzx8/T09fWE9oT1CPT09fT08/Pzh/IY8fHx8PDv8O7u7e3r6+nisIzg6Ono6uvqhOmD6ITnBObn5uaE5Qnk4+Pk4+Li4eKE4Avh4ODf4N/g3+Dg4IXfgODf4N/e3t3Sh8ychnFfYXFVY2FRZ05HRUNwVVmqpVWAbH253JGD6O6C/c+H3an22NWOkIGJppqAdX1xf76HZHZnaWhleIZMTG9nV1BkbkBMn8uzp5htR1p5V75aWGug/KBtZUZneUtvcIBgTXhuhmminKNYhPOWqZaHhYhda7WtgJWPuvCCoW5HWWBcZnNmemNKbn/Yb8fK5LLjs66fZ9G9uYitr6+wsLGys7W2uLi6uru8vb/AwcPFxsrLzs/R1NbY2dzd3+Hk5ejq7O/x8sbRlLKzkN3ugIGE847Fi6jl9Z+OSKXvxpCPg3xya6hfcOXw5MKAgI2Xoo1jqrDFgkxyT3WQhrynovLPzHuRTEbZe4BPu3OJjVj2tf+9ubDQ5OXzptq3kYydksaG1beJwL6Bx/yEhoaKjI6SkpOTk5KSkpSWmZ2foaGjo6Wqra+vrKiEpoCprK6usLGzs7O1tre8wcbO1NfW2tzb3N7g4eTn7O/y9/Xz8/X09PHt6unm4d/a1tTSzsvKxsfGxMLAv769u7q4tbSzsrGvrq2rqamnpqSjoqGgnpybm5qamZiYl5mXlZSVlJOSkZGQj46NjIqIh4SCgYGCg4OCgoH//fr49vTy74Dt6+nn5OLh3tza2dfV09LQzs3LysfFxMTDwcG/vbu5t7Sysa+trayrqaempKKhn56cnJqZmJecn5ubmpmal5eXlpORko+OjY6JhoeEgP6ChYT18/T/+fr39/j2+v7+/ffr7u3j5Ovk3dXSz8/My8rHxcPCwcPDx8nLy8fHwMDAw1e+vcG/vsDBv728vr+9vLy4sq2mo6eno56dm52amZubmZiWlZaSkY6NiomIh4aLkJOSjoiGhIKCgYCA///+/Pz7+Pj39vWAgfXy8vLv7+7u7uzr6+np6OeG5hfl5eXk5eXj5OPj5eTh4eHg39/d3dzb24TZCdfY19jY19jY2IjXM9jY19fX1tbU5Fsya3ur8YuE+Ku2wISal9Gq68aAwJxpoV9wWmVDb2hCLiRHSGRCLlYzMQF8hXsNfHt8fX5+fn9/f35+foV9AX6FfYJ8hH2CfIV9Dnx9fXx8e3x9fHt8e3t+un+Dfo19hH4Ff39/fn7ufwd+fn18fHt7iXyEewd6e3t7fH18hXsLfHt9fX59fXx9fX2FewF8jHsIfHx7e3t8e3uEfAF9hXwOe3x8fH1+fX18fHx7fHuGfAt7e3t8fHt7fH19foh8hX0Hf359fXx8fYV8EX18fXx8e31+f3x7e3x8fH1/roAcf35+foCAf4CBgYCAfn9+fn+Afn19fX6Af358fYV8KX19f318fHt7e3x+fXx9fHx9fn9+fH5/gIB9fX1+fn1+fXx9fH1+foCAhoGEgA6BgYB/foCAgIF+gYGAgf+Cm4LVgQSAgYGB6YCLf4KAyn8BfoR9C359f39+fn19fn5+hH0Cfn2HfIZ9CHx8e3x8e3x8AgIEAD+Kk+uLiKZosIuTxnmLZkZ/RmzKO0DAhIODY4qyzI+dprfmnfr/hKGZp4vFn11zk3evjWpua6NqL0FDREVFRkaFSA1HSEdISElISUlISUlKiUkCSEmFSIxHIkZGR0ZGRD9oVV29ttiMt9CknqzGwsh+cMCyckpIgIZHSEeJRihHRkdGR0ZGR0ZGRUZGRUZGRUVGR0VGRkZFRkZGR0dISnuWSUhHR0VFikQJQ0REREVFRERFhkSEQxVERERDRERDRERGRURFRUREREVERUaGRYBERD9Sk1tzbsW+dXBxfsOTvKWqcaabco5YjWF+jnl1m4ptlYFyQFhBZ5NxRz+hhKd+b4C4gT2smreejrOVzdh3kaLNurGI2Fpab5CHhamT24KJl6qJ6onTe7+bpYfd2JB3ipGBkYRyy3ujtHCWeHfRusaTZZCbj3rSusiyynl/foDKu7KE0t6xjq7PbXR1sHtVcU2qoLFybl1vP0VNTU5PUFBRUlJTU1RUVVZXWVlcXF1fYmRlZ2lqbW9yc3R2eXx+gIKDhoeHiFBWqcVxjJePWouMc01jc4GZbGjU3ryWi3txkbZ2cJGCc7h3nn+PcJeJo8VynLJoe9yD5G+bv6yPjoCpfMSniqeuct+wh4KPYu7HqmRuWKlqaoBsp3WfjGyRcYqbkKPgi41mh0tMTk9RUFBRVFJRUVJRUlNTVVhZW1tbXF5gY2RlZGNlYl9gY2VoaWhra2xub3BydHh+gIOGi4uLjpOUlpqepa2tt8C8uLa+vbu3sa6rraagoJiSj4yIhR+CgX9+e3h2dXVycW9ta2ppaWhmZWNhYF9dXFtaWVhWhlWEVIBVU1JSUlFRUE9PTk1NTUtKSEhHR0dISktLTExLlJOPkZGQjYuIiIiJiIeFg4KCgoOCgoKBgYSEgYCBhIiLm5SIgXx5d3RycG9ubGtramhnZWVlY2JiYmFgYWZwdnN4fXpvcHN2gH94cm5vb2ppZGFcrl5rbl+il6HAZWlsbGrX2XvW2c/FzbScttnFtJyFe3h2d4aFgYeFe3eDf4KgpJyUlpCLkYF4enV2io6IhoaIio+RlJmclZCLiIh9cmxscW9tcG1qb3RuamliWlVTVlVSUFJbW1lSS0tGPjw6PD4+cm5zdHVpZ2ZlZkhNcWJiYF9dW1tcW1taWVhXWFaFVx1YXltZVlVUVlVWV1VTUlBQT01MS0pJSEdHRkVFRYREBENERESFQzVEQ0REQ0NCQ0NCRDxhimlcakB6e9d4du99XlprpJ+QnuewoI7CrZ2X28DLrtj1kpPF5HHcyUCNl/qZlriD4623+5+5mWagbInlVFzemYiYiJ/Yt5XKxL35of74iaKpvJnrzYeeuKThq4SFg9+fTHt8fn+AgYGChYOGhIOFhIYJhYaFhoaGhYaGh4WChouFH4aFhWZopniD5rP6msvWppiv1dvkmoTb1ad0fqq3hYWEhASDg4SEiYMChIOPgoaBBYBzo7x2hIADgYCAin8BfoZ/iH6FfQh+fX1+fX1/foZ9iX6AfX19cofhiKKa9duOh5q099/y7diRz+qnyYnFkcjns7fQ0pjarKFYgWmf1apvWsaeycOcqe24Xe+s0aqbs4iRx4Gnn/LV34r8gn6Kvq6XsqDnhIh9oGOVWuWZ3J2mXMDsuY2jvLC/nYztpdLUi8uej/3i8Ld9pbekj/3R7M73nKSAori/upLo+sisxu6DiovNoW2WZNLD3YqLdZVUX29wcXNzdHZ3d3h5ent8fX6AgYKEhYeJi42PkZSVmJqcnqCipaepra6wsLGwY2nU+JKuvK5wp6iGWnB/j655dOb26bCZkYCn5ZWHqZyJ2pTCmqeDuLTT94zI3YSO/pD4grDTw5GAj7yS4reYtLqE7MiPlZR58MXEdIJoy4SEoIXMiL6tgaiBlL6brPCsrYCtY2VoaWxsbG5wb25vcG9wcXN0d3h6e3p8fH+Cg4WFhIaCgICDhoiJiYmMjY6Oj5KTmJqdn6Ckp6eqra+xtri8w8TM0M/OzdDPzszIxcPDvbu5s66sqqYhpKKgn56cmpeWlpSTkY+OjY2Mi4mHhYOCgYB+fHt6eXh2hnUadHR0c3JycXBwb25tbGtqamlnZWRjYmFhYmOEZIBjxMG+vr68ubazs7KysK+sqqmpqaimpaWko6OioZ+fn6GjraiemZWTko+Mi4qIh4aFg4KAf359fHt6eXh4d3qAhIGEhoN8fX2AhIN/e3h4eHV0cG1qzGt0dWrCu8DUbXBxcXDh4d7g2dLWxbPF28/DsqKcmpeYoZ6bnpuWkpqWmWmtrqqkpKCdoZaQkY2Om56amJiYmp2en6OinJmUkJCKgX18gH58fXx5fH97d3Zya2dmaGdkY2Nra2hkX2BdWVZWVlhXqKaoqKmgn56dm1xeopmYl5aVk5OSk5KSkJCPjo6Njo2MjY2Rj46FixOMjYqJiIeGhYODgoGAf359fXx8jXuHei95enl5dV2GrYN8h16pkvCGifCbfXd2koqCmcqRfmenu6uj/tzUnNXzmZDK9IP55EQ0NVM6OmNnpWVwwXSc4I69o3yhgoGURjxn2sHre2zufURENU9rNDg5T0B1uq+8rsTaYk4/X/L8ivT49/b29fX09PX19YX2Fff3+Pj49/j4+Pn5+vn5+Pn4+fj4+IT5Mvj5+fj4+fj4+Pf29vb19fWIpvSbq890yU9DTEtPXG9FfYVNdqzBo827zOzs8/Tz9vb3hfYL9fX29fX29PX19PSE8xny8vHx8vHx8fDv7e3s6eSvma3D5efo6enrheqC6YTnD+jn5ubm5eXm5eTk4+Tj44Tih+ED4+Hhh+AB34TggN/f3t3axdLZUV9ViXlRUG12nJSZiH5Zja1qo2yCeeHYdGuIqXjCgsSAzaCtyMGshOu4nqRoatfZhNtmhm1ecFhQaktUTnF7qlp+kZll2bF9jXNxRUZEdkRdNsy85VxkN4h9U0pZV1VlS0u9rJODUn+BfMra/rWDcWlPS9hfdLSMgKuzf2RlZX2IqVtZcIxTb3epwaTzkf+lwX6NleCAk66vsLCxsrKytbW3uLm6u7y+wMHCxcbIy8zP0NLU19ja3d7h4+Xo6uzv8fPxg4PX+ZvM2+GG1Oq3gJmfsNKNl8m74btxj5WzwJSNgYB8rY7dq9WjxYGnuGnJ3Fmg62C0kL+XbqZsSqSS185Weod5dW53f2iCoGbXkaaF3p2pzaj7ltvAgoNoV515m/Pg46Tmg4WHiIqLjI2Pjo6Pj46PkZOUl5mbm5ucnqCjpaamp6eloqOmqKqqq6yvsLCxsrS1ur7Aw8fJysnLzs/Q09jZ3d/jhOaA6Ofn5+Lh4N7a2NbS0M7MycfGxMLCwL69vLu7ubi1tLSzsrGvrayqqaelpaOioZ+enZycm5qbm5qZmZiXlpWUlJOSkI+OjYyLiYeGhIOBgoKDg4KCgID9+vb29PHu7Onn5uXi4N7c2tnX1tTS0M7NzMrIxsXExcTIxb+7uLa0srGAsK2tq6qop6WkoqKfnp2bmpmYl5ibnZqbnJiVlJSVlpSSjo2Mi4mIhYSC/oKGh4D38fT+gIGAgID//v39+PP16uDq9e7m29LQzszMzs3Ly8nFw8bCw87Py8fHw8HEvbm6uLi/wLy7urq6vLy+vb23s6+sqqWfnJyenZucmpiZm5gUlZSQjIiIiYiGhYaKioqHhYWFg4KEgRr//f79/Pn49/b1gIH18vHx7+7u7e3s7Orp6YXnCebm5+bp5ufl5YTkEeXk4uLi4eDg397c3Nvb2trahNkB14rYAdeG2C7X19fKjXxWZJabkOGB4J15nru+uoJrbGaLi1xYQ1BJPzRaRz83SFc9T1xWTpNZCHx8e3x8e3x8hX0Ifn9+f359f3+EfQF+iX2CfIV9DXx8fn59fXt9fn59e329f4N+jH0Jfn59fX5/f35+rH+CfsF/AX6EfIJ7hHyKewR8e3x8iHsLfH5+fnx7fH5+fHyFewJ8foZ7DXx8e3x8fHt7e3x7fX2GfAF7hXwKfX58fXx8fHt7e4h8DXt9fHt8e3x8e3x9fX6HfAl9fH5+fXx8fH2GfA99fXx7fX9/f317e3x9fn+vgA1/fX1+fn5/f3+AgIGAhH8jgHx9fX59fn9+fX5+fH19fH1+fn5/fXt7e3x9fX1+fH18f36EfSB+f35/fX5+fnx8fH19f319f4GBgX+AgYGBgICAf39+f4R+BX2AgICB/4KdgtSBAYCEgYSAhYHggIp/goDMfxB+fX1+fn9+fn1+fnx9fn59iXyHfYR8BXt7fHt7AgIEAEDcyd+VxtdHpXjZtLahhnuHeWpYcEKVjoxNf4WZjZFio5Dbx8yfgoumjoPDij6NdZKGw7ipqmA8QkJDRUZHR0dIiUkDSkpJjUoMSUlKSUhJSUhJSEhJiEiERylIaHg+Zq66kZ6Hja7FmJq+g6mtqdFwcEtGxpSASkdHRkdIR0hHSEhHSIZHB0hHR0dGR0aIRxNGR0dIR0hISYiDTE1KSUlHR0ZGh0UMREVFRkVGRkZFRkVGhkWDRIRFCkRERUVGRUVFRkaERYBGRUVGRkZFRUZFRjtvc19XpnaAqpCbklahZEuveXx4l5yBpppunV+DbYZqaFZGc3J5UG1kgV07eqR2k3OAb4tseGqugnPctrvHiarPjMR3eo+csIF4/JuKjO/b4JKLxrFzY7F8kbxuip6WkpqDsHdwy6WDaYyeZZyUu2eyt3+tfieDpJSSiKRvdqKQgs6dj3+GyILTmqyTdD5iVGV7n29fWUdMTU5PT1CEUoBTVFVWVlhZWVtcXV9hYmNmZ2hqa21wcXR3en2BhomKjI+Qjo2JclhTb3vAn4iLfn5RkoN1ibSBnnB8oL7Ep3qJ1MKmf4luiWJ5bGenun2GuYSjf5VkfYWQfWjQ5oPHxauc2al4y6TWhP62lbFscX1emJtZcIhzX6Hnl2p0yIebcRS89p2Vak1OT1BPUFBQT1BPUFFTUoRRgFNUVVZYWFhZWlxcX2BhYV5eX2JkZWRnaWpsbGxucHJzdnp9fX2AhomHi5CTmJ+gqq6qqKeur66vp6WgoaCYl5SNiomFg4F/fXt6eXZ0c3FwbmxrampqaGVlY2JhYF9dXFxaWllYWFdYWFlZWFZUVFRVVFJUVFJRUE5NTUtLS0lJBklISElKSoRMgJiVlJKRkY+OjIuLioqLioiHhoaIiIiJiYmHiYaFhX+Ag4qPiYd8eHZ1c3FwcG9ramloZWVkZGNjZWdiYWFjcoKDhYuFeX2DfIaAcm1qamliYVytrKaltmNhvL1mdMvMbGzN1tzb0s7Gv7CnssO2rJ6SjH9+iaiwwbWpo6KhpJigXJ6YlpKJhIR2bm5raXd1bXB5gIWHhYWPqKukmIyDd3BucHVxbm1qb3h8dGlmX1lUUFhaUlJWXFdSUE5OVFFMUGNyYU9DRURxcGxoaWmJTnRnYl9eXlxbXFtcW1tahFmHWB1ZV1hWVldXVFNTUlFQT09NTUxLSklJSEdHRkVGRoVFBURFRERDhEQBRYREhEMoOz08PEVAcKmrneehWGhsXork3d29sn2jwqGNpZOy5IPNlZWgitGexUT1v96itPJixYz93s3VwKuumZV1lWCklqlippuqk5l/vJvq1aRvhaC+rJjuvmCqjqWR4t3VzHxue31+f4CBgoODhISFhISFC4aFhYaFhoaHhoaGh4eEhgGHiIYEh4aHhoSHIoiHfYqiYITQ3oOvj5a5t5urzIq2vb73iYd9b+3BpnGGeHOJhQOEhIWGhIaDgoKGgwuCg4KCgny2qWtzf4mBA4CAf4WADIGAgYGAgIB/f4B/f4R+BH9/fn+EfoJ/iH4Ff39+f3+FfoB/fWWsromB8pec5cHx4Yrpk3bGiaaayeO02uen5ZHBprqcnoxsmbCwfqWZv4xcqZuJ1KLImpOFqZfNlYDaio+uiMv0rvCTl8m6zpyL/a2Ng+SotoFmk6uac7mFWKCDlJ2ksLKg1I2U48CXhbG3gMO35IHh2JDLlJa3maWV1omPt4Ckk++1p4SW3Zb2ucuzk1J9bn+GvY97cmNrbXByc3N0dXZ3eHh6e3x9f3+Bg4WGiIqMjY6QkpSWmJqdoKOlqayvsbO1t7W1ro1oY4ae58qko5OTYKmTgJvZkrCFkrbJ2buOnv35yZCqiqZwjH120tuUnfmgypqtd5SUopB25O6X4oDawbTts5Dav+WH9cOrx32Ek2+3vWuJpYxzt/+wh4nTgq6HvPS8sYRjZWhqa21tbGxtbG1vcHBvb29wcnN1dXd3eHl6fH1/gIGBfn1/goSFhYeKi4yLi42PkZOUlZeZmpyhoqOnqayxtbi/wsC/vsLCwsO/vLm5uLOyr6qnpaWjoXqfnZubmZeVlZSSkI6NjIyMioiGhYSDgoB/fX18e3p5eHh5eXl4d3Z0c3J0cnFycnBvbWtqaWdmZmVkZGNiY2NkZWRkZMfFw8C/vbu5t7W1s7OysK6uq6qrqqqpqKelpqOhoZ2dnqKkoJ2VkpCPjouKioiGhIOBf39+foR8gHp5eHiCi4uMj4uDhYeDiYR7eHZ2dG9uaszLxsbRbWvS0m522ttycdre4uHb1tPNwrrCzcS9s6mlnJyjuLvFvbaxr66wqK2rpqaim5iYj4mJh4aPjoeKkJOWmJaWnautqJ2UjYaAfn+Cf318eXuChH53dG9pZmNoamRjZmpnY2JgJ2BkY19ibndtYVlaWqWkop+fn7JfpZyZl5WUlJOTk5KSkpGQkI+Oj4eOGY2NjIyNjYqKiYiIh4aGg4OCgYGAf35+fn2GfAl7fHx7fHt7enqEey96e3p6enhvXGVjW2Ffk72yru7HdI+Sg67e2cCgsJKowK2qxbHJ74LPmaKykvK+3j5yTF86RqmInmRlVnvn4sCYlrSXy4xbX7SJ8LlzRnilbDREQEA2Nzs+OkR6yZSKdGyFvmBfcIHT8vT4+Pf29oX1hveD+IT5Cfr6+vn5+vn5+oT5D/j4+fr5+vn5+fj4+Pn494T1KPTOiKaMoarbcatUW0dhYkRwMz5Jf/FhY8unvc2un/S/rPX3+Pj49/aF9wr29vX29fT09fT0hfOE8jLx8O3u7OnTv7KMrdzl5+np6+rq6+rq6erp6eno6Ojp5+fn5ufn5uTl5OPk4+Pi4+Pi44XihuGA4ODf4ODh4OHg4N/e3dmhnHlweMVjZI14or+KuaWVqGdlXH+bZ3SXwshZd2mddXfIpNn62cLp3OzDhMx0Y8G1+LBqW8fWd09MbFFUYkRflW+AR1fbjKGWX6GbXVCJZ4tyR2KLx4CTbzNvQ0VZXVJRTmtKZYp0YmB7iW3nwe+P+8eAYYVTSF9Ji0tSNUdYUVPae29OY5Jtv4uktMiEvaisa6K2iqKcq66vsLCxsbGys7W2t7i6u7u+v8HExcfIyszNz9HT1dja3N7h4ubo6+7w8fP19+69gYWps7TkmNHLzIjtwa7D+q+wYKyzjuDYmaLt4sutxYKMjayfk8+YncDLc52AhNCEoKrBlYCsw4yYiLWIkWdte31jVbmAwN2FnbGN5fCHscezgKnVqHiKpUuDd4yH1c6sgoSGiImKi4uKi4yNjpCQj4+PkZKTlZWWmJmanJ2foaKjpKCfoqSmp6iprK2ura2wsbO2t7i7vb2/wcLExsrMztHT2dra2drc3Nzd2tkq1tbV0tDOy8nIxsbEw8HBwL68u7q5t7W0tLKzsrCurauqqaimpaSjoqKgh54ZnZqZmJeYlpWVlZORj42Mi4mIh4aFhIOCg4SCgIGA//z69/Xz8O/r6efm5OLg3tvb2NfW1NPRz83MycfGw8LCw8PAvbi1s7KxsK2tq6iopqWjoqCfnp2cnJqYl5ecoJ+foJ2YmZmWmJWPjIuKiYaFgv78+Pn/goD+/YCF//6AgPz8/f749fLt5uLm7Obh2dPQzc3Q2tzh29bS0c/QY8vPzMrHxcC+vrq2tra1t7ays7a3ubm4uLrCwL22rqmkn56eoJ6bmpiZnJ2ZlJOOioeFiYqGhYaJh4WEhISGhYSGi5CLhYCAgPv6+Pf29v2B9vLx8O/t7e3s6+vs6unq6Ofo54XmGeXm5ebm5ebk5OPj4uLh4eDf3t7e3dzb2tuH2QnY2djY2NfY2NiG2S7X2NjX0ryLqqmUlpWyn4KHsPqs2+LK38vEi26fnUhHTTs+NDhPPGhHN1w9vHNzDXx8e3x8e359fn19fH2HfgV/fX19foV9B359fXx8fX6FfQZ8fX9+fnyGfbx/BH5+f36QfQd+fn9/fX5+qn+CfsN/BH18fHyHewR8e3x9iXsBfId7Gn1+fX18fn19fH1+fHt7e3x8fHt7fH17fHx7hHyEew18fHx7e3x8e3x8fHt7hXwGfX18fHt7h3wPe3x8e3x8fHt7fH19fX59h3wFfXx8fX2KfA57e3t8foB/f358fH5+f7GAVn+Af358fn1/gICBgH+Af35/fX1/fXx+f35+fX19fn59fYB/gIB9e31+fHx8fX9/fn5/fn98fH59fX5+fX1+fX18fHx9f35/gICBgICBgYCBgH9+fn9/hH4FfX1/foH/gp6C0oGFgAqBgYCAgYGAgIGB5YCHfwGA038Gfn19fXx9hH4BfYV8iH0KfH18fHx7fHx9fAICBABAhYCkteLRl6nfk4CYeWV3znJOQFlhXldLRTdpYJ9+lq/lsuirueqPiriUwGrI172hw4/GnLBlQ0NbO0ZHR0hJSYVKC0tKSktLSktLS0pMhUsBSoRLBkpKSklJSoZJMkhHSUhJSkpMSUpJS8iqhNHOqba8t5qznIWUlKXCk8yYlnSJem5/S0lJdUZJSUhISUlIh0kDSkhJhEgBR4ZIAUeFSBFJSkhyaoaVjIVOUEpJSUdHR4hGhUeJRoVFBkZGRUZGRYtGAUeFRoBHRkZGRFdca1J6g4aPf3lnXWxfbW5wmJJ4lYJzlKuEh3+QkJmfeXd7cohlZTZNWJZEQEKUaE1upZmGVlzTk52/trnUhIqg7emZx7i5f3p7cGdtuOGenY6MsrubUHql6eqppb+dfujXepx4tnJqqnF7jHaIcpyeY5l9tYuNpc7il4DZcq6Tiq6ssc6knIBwco5cWY4/QqqSqX+Cf0tNTk5PUFFSUlNUU1VWWFhZWltcX2BhYmRlZWZoamttcHN2eIGTvsBjoZmbmJeRkGx7koRuan+HZ3F4UVKeZWFrlJC8kX+8jrOToMu+tMKFY3Kvbm3DiYiUm3Gugpt6y8CZv3u1xoCOtrqhdY+bldK8dIfauWiLYFlqlqWTmo5ygaKIbmxhjb7v8NPn2JKklIZRUlJUUVFPT1FRT09PUFBRUVBQUVJSU1RVVFVXWVlaWltcXV1fYWFiYmRmZ2doaWxtbm9wc3R0dnp+fYCDhoqRk5adn5yam6Cgn6Kcl5WUlZGOjYqEgyCBgH59fHl5eHZzcnBubWxsamppaGdlZWRjYmBfXl1cW4RaHVlaWVdXVlVUU1RVVFRUUlJRT01MS0pKSklJSklIhEkOkpKRkpKRkpKRkJCOjYuGiiSLi4qKjJKSlJCLjIqIjoOCgYB/eXVycW9xcG9tbGtpZ2ZlZWaEZYRigGdsfIaKioOAfHp7enVvbnFqYF5crbCsr7m9tmVnzMq7w8e5wdLd39PMxbqysLS2taiclpSTk6KzwcKzoJqZoKKdlZeYiIOEg4B3bWxoZWRlZGhpb31+f32Lp6yjlYh6dnV1endzb2tqbG5vbGdjX1xXUE9WVlNWWFVRUFBSUk5OKl1xeW1iTUlIj5SIdHR1dnhqZWVgX15dXV1gYF1eXFxcW1xdXFtaWFhXV4RVGFZWU1NTUlFRUE9PTk5NTEtLSUlISEdHR4ZGCEVFRURFRUREhkUrREVFREVFRYCDRHGcjsqFZ0lDPGamgHefjX2ikX+luoqJxJ+Np4uElY+dlkKUk7qx5v7Awd2yl7SXgpDziG9kb3x2fWVcU5V7womYtfK18XBv3LCo57L/h/bftrKxldy/15h7fJtngYKCg4OFhIWIhoSHi4iKhwSIiIeHhYgrh3uJiYmB9Mai5vPA18vQs9CmfZCSpbeO5KWqi7aQiJVxh4KjcYeHh4aGh4mGgoWGhIKFhoQVg4OEg4R8kIe3xaygbHJ+goGCgoGChIEOgoGCgYKCgYKBgYGAgYGEgIR/CYCAgH9/gH6AgI5/gICAf4B4kIyrhMTVw82zupuNpYufqZuekILJv5qw4cfJrdG5t+i1sLqLzZOdUnl832dhYo+LcKG+vMB8gfWztdO7vtOBgoeor5Lc0Mimp5OIg4LJ13uKkG+eprBkmqWe18Gj2L2N7eyFqJrnjIvRi5irl62Eu8l9rorZnZzC3ui2gPeR36yf382667aqmo2NtXRxsVNVzrbUoqGmaW5vcHFydXV2d3d4eXt8foCAgoOFhoeKi4yNj5GSlJaZm56hprPU1W3BvL28urOtgZO0oYWClqd6hopgYbNxbn2mntekj9Of0Ku97ezW35Zxh8mCheqjmq6xhdaTtJHr6aTei9LQgJbW1b6RrMK78s6EnPW4d5RtZ3uyxbS6rYubuJ+DinWy4Nnj8O7WksWypWZoa21sbWxsbm5sbG1ubnBvb29wcHFyc3RzdXd4eXp6e3x8fH6AgYCCg4aHh4eIioyMjY+QkZGTlpiZm5+hpamqrrOzsrKztbW1t7Sxrq2uq6iopaKhO6Cfnp2bmpiYlpSTkpCPjo2Mi4uKiYeHhoWDgoB/fn18e3t7enp6eXd2dnRycXN0c3JycG5ua2ppZ2ZlhGSAY2NjYmJhxMPCwcHAwL++vLq4t7WzsrCwr7Cvrq2rq62srqqmpqSipZ6cm5uYlJCOjIuLiomHhoWDgX9/fn59fX18enl5eHt+iI2PjoqHhYKCgn15eHl0bWtpzMzKytLTz21v3dvQ1NbO0tvi5NvX0snCwcLEwbmwrKupqbO+xsdRva+qqq2uqqWmppuWl5eUjoiIhYODgoGDhIeRkJCQmayup5yRiIWEg4aDgHx6eXp7fHl1cm5saGNiZ2dlZmdmYmFhY2JgYGl3e3RtX1xct7mxhKYbqKCbmpiWlpWUlJaVk5STkpGRkZKRkI+Ojo2MhosViomIiIiHh4aFhYODgoKBgH9/fn1+hX2FfAR7fHt7hXyHeyZ6dr3DZZKimNadjXZiVn7Kn4e0j6G+pIu0xoyR07udqZCfp6ygr0Y5NEtSbenpeHBRRWVodHmkYo6jgIOKsYiQjvKr42deQ0RCVzY4a0JCXGGTcNxURENeZ01JeNvo6fG19vb39vb19ff29vf3hPgW+fj4+fr6+vv6+vr7+vr6+/v7+vn6+YT6Lvn6+vr5+Pf257jy8/LRt5uT17tKusbspNiSWmVHSUpIwXc/XsZ4jIah8NzKpveF+A359/j49/j39/b39fb2hPUZ8/P08/T09PPz8e7s6tJvb+H7r3CFodjp6obrEerq6unp6Ono6Ojn5+bm5uXlheSA4+Tj4+Li4uHj4uLi4eLh4eHg4eHh4uHh4d/f3t3K0ZN9c9X+m6dvfmdfhmFke2h6YVifhGBqiqiqbnBwmN3d1eeY89X9h72H85+ShHiajpaLvteOnJ5kZXFxgH9CQ01cXkl7nKTgzl5YoJqyqlhxiEVmZZCK4qBhgl5dnZRJdIuAU2t+rG5yo46wyaOZTm+piHpSdFNOY51ySGtFXVxkw5t5oI+brqybyZ6n94OG/cPkxcn0pK2ur6+wsbGys7O1tre5u7y9v8HDxMbGyMzMzdDQ09XX2dzd4ej9/oH29Pb39/DnrMr53qaOurSVpryHiPCVj4POsf7RZthl0auhoOtSstXDkZH+mX79kmbT22bNVHZ509x++53ksF2G0n92lJet+35aq++qi4eAgJa/96np1qe3tKCYnoLDvGxZzJxtUPni0IOGiIqJioqKjI2LjIyOjoWPgJCRkpSVlZaYmpubm52enp6goaOjpKanqKmpq62urq+xs7S1tba4ury+wcTGyMrNzc3OztDQz9LPzszKy8nHxsXDw8LCwcDAv768u7m4trW1s7KysbCvrq2tq6qop6ako6OioKCgn5+fnpuampiWlpaXlZWUkpCPjYuKiIiGhYWFgIOCgoGBgID//fv6+Pf08/Dv7evo5uLi4N7d3NrZ19XU1NPTz8vKyMbGwr++vbu3tbKxr66sq6qop6WkoqGgn56enZuamZiXmJmdn5+em5mXlZWUkY2MjYmFg4H9/fr6/f77gID+/ff6+vT3+v3++PXx6ufk5ebk3dfT0tHT2N7gY+Da0c3Nzs/MycnJw7++vby5trW1srKxsbCxsrW0tLS4wsG9tK2mo6Kio6Cem5qYmJmYlZKQjYyIhYSIh4aGh4WDg4KDg4GCiI+RjYmBgID///z4+Pf3+PTx8PDv7e7t7ezs64TqCunp6ejo5ubl5eWI5ITiF+Dg4N/f3t7d3Nzc29ra2drZ2dnY2NnahdkH2tnZ2trZ2YTYKNfW1szl95efb3KKrtPPpo+w/8ifvYvOqZ5aXWouJkFnPj9AhG1wRl0GfX18e3t8hX0IfH1+fn19fn+GfgN/fn6EfQV8fHx+foR8An18hn0Ifn19fX5/f365fwN9fX6SfYV+BH9/f36mf4Z+v38Cfn2EfJp7hXwSfX5/fnx7fn59e3x9fHt7fH19h3uGfA17e3t9fXx8fX18e3x9hXwFfn58e3uFfAp7e3x7fHt8fHt8h30Efnx8e4d8AX2JfA99fn18fn9+gIB9fX1+fn+ogAGBi4BIf35/fn9/gIGBf4CAfn9+fn99fX1+fn18fXx8f39+f399fX18f399fXx8fX19fH5/fnx8fH59fn59fn59fn99fYB+gIGAf4B+hIAQf3+AgIB/fn19fn19foCBgf+CnILUgYeAgoHrgNl/EX5+f359fXx9fn9/f359fX18iX0DfH19hHyDfQICBABTmZyhv3q9i9WL12ybqKKheqhlYV6GWnGeVk9xonljsJ2H77+ovKNztIbMjGtxmJqXsuCPnHNrR0h7PUdISElJSktKS0tLTEtLSktMS0tMSktMTEuJTIRKBktKSktLS4VKP02Rz5dPTUahfsOtrI2oxo244ZKCkO6QjpOjmrdviHJ1d0hFQW+KSktKSklKSUlLSklKSUpKSUpJSUpJSUlKSoRJIEpKSklKSkqB1HmHd354gkxLTUlJSEhIR0hHSEhIR0dIhEcDSEdHhUYLR0dHRkZHR0hGR0aERwFGhEcFRkZHR0aGR4BFOkhucYuKV3RPm3xjp2yMcaSkZtb2n5V4oYpvbqWnjoBddoeio8NmRmpsj25jYVVg06SqYVRXl7agjsB4u313j7yY4ICQvbO8XH2DgVhGduSd/ICG2867aoP30Oqwu4W35NSa5cF0qpi6imCanKWXhJuSeaCP0q6juKa1n7JqioCQnMyVebR4kV1lvYaIdmBUgreltqlZakFMTUxOT1BQUlNUVVZYWVtbXF1fYGJkZWZmZ2hqa2xucHJ1epCyvspzeX5rWqShjHR5aaZebXm6fH1vUJ2IeV2Oll+KjbFvq72ylsjQ1J2Cfo+TlI+Hy7dyoG25zIGIjGx5wGxvw8+DmziVZYeIgH/OqHWBw6nclJyipnzDhFfattmJqXGNiJJ6p5CtiJZwqZ5WVllaU1ZYU1RTUE1OTUxOT4ROCU9PUFFSU1VWWIRZY1tdXl5fXl5hYmFkZ2hqaWpsbW5vcXR2d3h6foGGiomPk5KQkJCUlpSXlJCOjIyLhoWGgn99fHt6eXd2dXRycW9vbm1samloZ2dmZmVjYmJhYF9eXV1cXVxbWllZV1VUVFRVVoRVB1NRTkxLS0qGSQlIR0ePj5CQkJGEkzGUk5STkI2KiomKiYiIh4eHmcO0sLWfk5KatJx8ent5dnJxb29ubmxqamloZmZlZGVlhGSEYoBka4KEiYWDgX5+fnZ5eXdybGdlYV+8tbCqpqWjoJ2coauus8LNy87RycK5trGpvbimm5SUhIywycGyo5eRmaWpmbOtmY6Gh3t2cmdpZmZvd3dscHZ7hY2XpKSYjYJ5dXZzc29zcm1ram5wb29saWVfWVJRWVdXV1ZTU1JTUUxMU0JfaWZcUpNMUE+XfG5sa2lpZmRiYGBiYmZrZmFiZGBgaGp0aF5bWlhXVlRUVFNUVFNTU1RSUlFRUE9PTk1NTUtKSUmESIRHAkZHhEYHRUZFRkVGRYRGKUVFRkZHgWaGnJKV0Hecgl1mQmycOnZiaG5eyLjJwZ+Fg5KX3dqepunURKKtqsCT46H3ifmEvc7fxpbKmYR/mXuU2XZsjLSGdMehhO3Mo7jEktGn56mBh6SKnLTum7OVonFwr2eCg4OEhYWGh4aGhIeEiAKJiIWJAYiFiQqKiomJiYiJiIiIh4knhYTD+tuHiWm+r/O/wpm7qZHF6pmUddWHi6Gyq82BoYKUmWtsZZC8iIiGh4aGgoWEhgKFhoeFEH+p9I+fi5KOl2Zoe4ODg4SEgwSCgoODhIIDgYKChoEKgICBgIGBgIGAgYaAgn+FgAF/iICAe2R4raPKzYewfOqhiOibx6Pj2oTv8aCfj6u3pJTMwb+whrTJ48vhlmudns2ik5F9kPrX3o9/gtLxuJ7Bjc2Ck7jKnuJ1anxylm6NhIluXpHvhbV0Ya+ptIih1qDWtbeBw9fjs/7dme/O77d7ub3Zr6G+t5nMq+u8wNbG0a3OhK+Ar8Hyp43NkLF0g/WvrpN6a6TbyNnMbYhYbW9wcXJ0dXZ3eXp7fH9/gYKDhYaIiouNjo+QkpSWl5mcnaGwyNLceHyBc2jEu6GFjHrEboaO3ZiSf164mYxroKtsm57Ee8fk0a3t9vaxlY6nrLGrnvndhrR+5fijr6uCmNt5f+zWjaxLrHOan5OO376Kksm/9qe1ucWP6p5p/tXnosuKq6erh7yOr5CqgsW9a2xwcm5xc3BxcW1ra2pqbG1tbGxtbW5vcHFydHZ4eXh5eXp7hH2AfoCBgYOGh4iIiImLjI2OkJKTlZibnaGjpKeqqaioqKusrK6sqqelpaWioaGgnZubmpqZmJaVlZSTkZCQj46Ni4uJiIiHhoWDgoKBgH9+fn19fHt6eXh2dHNyc3N0c3NzcW9tamlnZmVlZWRkZGNhYWHCwsLBwMHDwcDAv769vLmAtrSxsbCwrq2sqqqzzsTBw7Oqqa6/rZmWl5WSj42Mi4qJh4WEhIKBgH9+fX59fHx6enh5eHl9jIyOjIqHhYWEf39/fXp1cnBta9TOysXBwL67t7e7wsXI0tjY2dnTzsjFwrzIw7ivqamepLzKxbuwqKSpr7OouLSmnpiZkY6KhIR2goOIjY2FiIqOlJmgqaiflo6IhYSCgn6Af3t5eHp7ent4dHJuaWRjaWdnZ2VjYmJjYV5eYmpxb2lhuF5hYLuqo6Ggn52bm5mYl5eWmZ2alpeWlZWYmaGZkpCPjo2Mi4qKi4qKiomKiYiHiIeHhYWEhIODgoGAgIR/g36HfQN8fX2EfAF9hXwne3t4uYKaoZu494vBrnmPWZq+U5qDk5l68NPn06uQkpqc0+S/1uzpPDUvTnJhpZF8M3Q3bqj9vW+v4sWne5yN9q+z0cifjG40LVZSRV9oOF1NkEFWcEVEXk1TMU2FwKGq+7P394T2Fvf39/j3+Pn4+Pn5+vn5+/r6+vv7+vyH+zj6+/v6+vv7+vv6+vr55NDIlP3Y65KZ4rtpbFWOb5S2nHOhXolNW42hlINAg2mljoSXkqS/9vj5+Yr4CPf49/f29fb3hfWE9Cvz8e/t269yZHt0SkJmhozI6uvs6+vs7Ovr6+rq6unp6Ojn5+jn5ubm5eXlheQI4+Ti4+Lj4+OE4gHhhOKF4YDg393OoaXqpq/QlqCCu3NsrnlzV5Kga76yfW9eaW9iYaqMkcR3yOmzm8OujejW8L3M6abI2oygl8W/2rFwYXN4e057e2xdmEU6OzqIk6NabJWRt8hrcVM9bGOHwcyvbJh6kmqql4ZtpJFwhnO1u5Lv8vBuSlprRm2BjmNQWGVuSoBMIVJeWHOWoaiZxJGN6trqwKmU3eKzvvSSwIatra2urq+xsrO0tbe5u729vsHCxMXHyMrLzM7P0dPU19jb3eTy+P6Fio6Hgf7xzai8ov+Fkprbdq+ngfrBvYvN7YPV2MiVq6+0i8umqpOxwMvDuYNj9c2O34TiuoixiXSU+ouU2TWia2N5iLFwo6ung3J9y7nzsuHp05HHwIT0vJCL4ZK6toxkqk1aUKOc9OuGh4qMio2OjY6PjISKhowJjY6PkZKTlZeZhJoCnJ2EnwegoqKjpaephKqArK2vsbKztLW4ury+wMLDxcXExMTGxsfIyMfFw8PDwcHBv7++vr29vLu7urm4trW1tbSysbCvrq6urauqqKenpaWkpKKhoaGgnpycmpiXlpaWl5WVlJORj42KiIeHhoWEhIOCgYCA/v38/Pr6+fn19PLx7+zp5uPh397d29nW1dOA2eXe3NrPy8rM1Mi8uru5trSxsK6trKqop6Wko6KgoJ6enZybmpmYl5aVl5+enpybmJiWlZKRkI6LiIWEgYD++vfz7+3p6OTk5urt7/P29fb18e3p5+Th5uLa1NDQzM7b4t7Y0szJzM/RytHQx8K/vrm5trS0srK0tbSxsrKytbchvL+9uLCqpqSjoqCdnp2bmZeYmJeWk5GPjImFhYiHhoaEhIMugYCAgoaKiYWC/4CBgP759fT19PPx8O/v7u7u7e/u7Ozs6+vr7O/q6Ojm5uXk5IjjEuLi4uHh4eDg4N/e3d3d3Nvb24XaBtnZ2dra2oTZMdra29ra2tnY2dnY2MbcdYlnW63CY/jlqeGJ5/eI577m656bg5I7JiQrPEdms77vWlAhfX18e3x8fXx9fH18fH19fXx+fn59fn19fn59fH1+fX19hnwDe3x8jH0Dfn59s38Ifn1+f39/fX6HfQZ8fH19fXyGfYV+BX9/f35+pH8Cfn2Gfr5/FH59fHt7fHt8e3t7ent7e3p6e3p6inuEfBR7e3t8fX19fHx9fn19e3t7fH5+fIR7BHx7fHyEewF8hH0Ifn18fH5/fXuHfBZ+fXt7e3x8fXx7e3x7e3x7e3t8fn5+hn0DfHx7h3yEfRV8fX59fn5/fn1+fn5/f358fHx9f3+ogIWBhoAUf39+fn19f4CBgH+AgH+Af4CAfX+FfTZ8e3x/gH5+fXx8fX1+f359fH1+fX5+fn9/fXx9fX2Af31/gH19fn59fn5/gIB/f32AgX5+fX6Ef4R+Bn19f4GBgf+CmoLYgfCABH+AgIDXf4J+hH0KfH19fX5+f359f4V+iH0HfHt7fH18fAICBABIu+27udeXdv+kv6aiboN4x3dYO4+QWrBkZTlBN1XGt/GLt4eSgX3dv3Js0Gdcgn20197OjW+anFY5SEdJSUlKTExMTUxMTE1LhEwMTU1MTE1OTU1NTE1MhE0CS0yFSwNMTEuETCpGz7yUwYOKhL6+ba+OfpCh95WNn15hfX6JoIK/yG1kcHbCjHuIbklLSkyESxBKSktKS0tKS0tLSkpLTEtKhUsgSkpLS0tMTExybIN2vKe6bXpMTExLS0pKSklJSEhJSUeESAhHSEhHR0hIR4ZIAkdIhkcBSIhHgEhHSEhIR0dHQFFeQ09LiEN0VXKPgYBvgm5SdGJ5WYuNpo+KimOohXRwPVuehoN90o51aYx3X5KgRql3YqNMUVR9Wna9z5Z2demYk3uah6ba3tKk5WhlnK6ktaTs3ffiusFx2vWggoa7qqR1vsuus6yEdJiFo5Cscn9riptkqMCZgIdpbnHDgpBrg3VleW3DwX6saZ1rapmckVi5n65udklKS0pLTU5QUFFTVVZWV1pfYmBfYGBiYmRnaGlpamxtb29xcnR7hImWorTLc4R/X1eknodmXlWXb3aJjWZieYiVc19Thbyrh3WTnra1lZa+gol7jaFzoox1kmRgpKGjsZJrQIqqfZBnjrX5wLmGgYxreb93u8SZ0GiupK3bwrFokN6qnH/JiJbBpMWqzu+cZ3Gxo1lWVlRSU1hbWldUU1FPTEuETHtLTE1OUFJTVVZWWFhXWFlaXltbW1xdX2BgYmRmaGlqamptb3FzdXd6fH+EhoaLjYuKiYqNjoyPjouKiIaHhYKDgn97enl4d3V0cnBwb29tbGxsa2ppaGdnaGZlY2NiY2NhYF9gXl5dXVtbWVhXWVlYWFdXVlVSUE5NTEyHSy1KSUiSk5OUlJWXmJaVlpSTk5GQjYyLiomJhoWDg5Kaj5SRkpSJiZiPfHRzcnCEbwpubWxqaWdlZGRjhGSAZWVjYmNiZWVqbnN5gYaNiImLgnt4dG5oZWVivbOqop2YlZSTlpeaoKqxtbq9wcjMw7qwpJWiuLGimJaQkKezu7eqmo6RsLGssbCdjIKAe4OHcm1oZ212cW5zgnd7iJaWl5KIf3x6d3V0b3FzcWxscnJvdnJ0bmZhWldZV1ZWVVI0UE6ZmJicUlhdWVVQm5eTkoVzbGppaGdmZWRjZXd+jaCDbHlxa2tvcYh+YmZgWllYVlZVVYdUEFNSUVFQT09OTk5MTEtKSUqESQNIR0iHRwhGRkdGR0dGR4RGhUchYm9/waR2blU7QTx8PkJMRklpbcC0qql026u5p4akdb/iQbfls8b0qI/+jde+w4y0pOyke2DCu3jGipFda1R17r/zibmNm5uS3/aQgf+Gf5CM1PvgxaCCwM6GY4KDhISGhoeHhYiEiYiKB4uKiouLiouGigGJh4o4i4uLdPPhpuKhtbbh4IHIjIGmorKHqsl5bn2ChZ6F0+h+eoiP57eus4hyiouKiomKiYmJiImIiIiFhwaIh4eIiIiKhw5/kpSrkOLF04elbnaFhYSEi4MIgoKCgYKBgYGHggOBgICHgQaAgYGBgICHgYCAb4WdcIN/6HGwh6/bsKOpvJ+AooSsicCPj3+MrYbfmJibW4Pdwquv5Mu0mrWxjNXia/itiK5qeHyye6PZ5r+QhfbBrpi+m7Xh6KqDuWpvmbi6p5KkuMivveCI+sSAb6TNvc+N4vzc6e69n76lz7XTkqOJnqSDy/C7k4OGg+iZs4CCoZWDooH285jRhsuDibfLtXDjw+GKlGRrbG1vcHJzdHV2eHp7fH6DhoSChoaIiYuMjpCQkZOVlpiZmpygo6axvMzfeYSBame/vJ10bWKsfI6lpXNxipuqgmthlc/AmIGps83cqrDamKCNpsKLx6OKp3FvyL67w7mIo8GFp3Gmw0f929STlJh4hNOKzdWS4HrHuc3+zM58sfypq4jRlqjqy+DQzdevd4jSwW5tbm5tb3N2dXNxcG5saWlqamtqampsbW9wcnR1doR3bXh6fHt6ent9fn5/gYOFhoaHiIiKjI6PkZOVmJufoKGjpKSjoqOlpqWmpaSjoqGioJ+hn52amZiYl5WUk5KRkJCPjY2OjYyLioiIiYiGhYSEg4OBgIB/fn59fHt6eHZ2dnd2dXV0c3JvbWtpaGeEZj5lZWVkYmLExMTDxMTFxMPCwb++vLq4trSzsa+urKqoprG1rK+rq6yjoqymmJKRkI+OjYyKiomHhYSCgX9+foR9gHx8e3p5eHl5fH+ChoqNkIyLjIaBf3x4c3FwbdTOxb66t7OxsLGytLe+xcnLzc/T1M/Hwbmut8W+tK2rpqW1vsG+taqio7e3s7a2qZ2Wk4+Wl4qGhIOHjIiGipKKjZefnp+bkoyKh4WDgn5+gH57en18e358fHlyb2pnaGdmZmViNGBgvbu8vmFlaGZjYL27ubiwpqGgnp6cnJuamZmkp7C8qp2ln5ycnp+tppaXk4+OjYyLiouGihOJiYmIh4eGhoWEhIODgYGBgICAhH+IfjJ9fn19fX5+fX19fH18fXt0b5OFlOe4n5N0V19UolhgeGFpiYnDwL6lgve0tLOQqofM1zpCTUZ7yEttXkJhS2mIyrvNubCh/Ome1rHlr8iXp8BTbjVTPD5GPHKrPEq8hpxmZamgUWRaTZDl27Dyh/cD+Pf4hfkF+vn6+vqE+wL8+4T8CPv7+/z7+/v8h/sq+vn5t4OFYHF+odSSi3TEZ1ythYmF0fukhYB/ZoNvvtqBhI+CjKrCtlarh/iH+Qj4+fj3+Pf294T2J/X19fb19PLw7daJrbOQelFmYcGaserr6+vs6+zr7Ovq6erq6ujo6IXnB+bm5ebm5eWF5IXjCOLj4+Li4+PjhOKA4eLi37m89arKnNCV2pvDuImBya1SNlxoqaC8bmZUYGhSlW6ls4GLvY58t9bH5r/Q/o6s1YfvyItyhbu6+aO1sb75lXGTmXd7nGRcc4hqUImAj7Lk7Y57Z4iRc4fOkdKOWVe13r7BZ3t3fHiJood/t9rZ4XBiRE5USIHOlkQrMDKAWi82KjApKyxty6uKe3a3Vne29MqG9MHVqdmcqqurq62trq+wsbO0t7i6vb+/usHCxMXHycvLzs7Q0tPV1dfY29fW3+fy/4aOjoOB9PnRmJCB3pejqMyVhLPQ2KyOicL+8LebjYbOqZmOjq6kobSyhKJwnr+LirW0f32If3miVrs9jKikhtr4so9YiJvGhoZpeuaJ9sX2/Y67gb3ESl9EhnmH5q+YwWZcsoWZ8O2HiImJiYuOkpGQj46Mi4iIiYSKCYuMjY+RkpSWl4SYIJmbnZybnJ2en6CgoqSnp6aoqaqrra+vsbS2uby9vr/AhL8jwMDBwcLDwcHAwMC/v76/vby7u7q5ube2tbW0srKysbKxsK+ErRKsq6mpqKenpaSko6KhoZ+enZuEmYCYl5aVlZOQjoyKiYeHhoaFhYSDgoGA///+/Pv8+vr39fTy7+3q5+Tj4N/d29jV1NLW1tDSzszLxcXJxLy4t7W0s7Gwr62rqqimpKOioJ+enp2cnJuZmJeXlpaWmJqanJ2dmpqZlJGQjImGhYOB/vbx6+nk4uHe3t/e4ebq6+3t74Dw8Ovo5N/Z3eLe19LQzc3W2drY0svHytLSz9DPx7+7uri6u7W0srGys7KwsbWwsba5uLm0rqinpaOioZ2dnZ6amZqZl5iXlpOPjImHh4aFhYOCgYD+//7+gIKEgoGA/v7+/fn19PPy8/Lx8PDw7/L09/v07/Hv7e3t7vTw6ero5gPl5OSE4wbi4+Lj4+OE4hDh4ODg39/f3t3d3Nzc2tvbhtoC29mI2izb2tra2dnY2NS/td9llumc2saskJ2H9YybzZqsvXNqdlg2RF49RY+Ipm5KVoZ8G318fXx8fH19fXx9fn99fX59fn5/f39+fX18fYV8B3t7fH18fX6HfQR8e3x+s3+EfQZ+fn59fX6JfYJ+h32EfgF9hH6lf4R+BX19fX5+u3+Efgl9e318fHx7e3uEfAR7e3t8h3sjent8fH58e3t7fHt7fHx8fXx7e317fHx7fX5+fX18e3t8fHyKexV8fH5+fX19fHx8e3t8fHx9e3t7fH2EfIV7Bnx8e319fod9h3wDe3x8hX0Sfn19fn1+fX19fH19fnx8fH5/rICFgYaADX9/f35/gH+AgH+AgIGFfzd9fX59fn18fn5/fn19fHx/f4CAfX18fH1+fX19f4B+fXx+f4B+foCAfn98fHx9gIB/f359fn9/hX2Efgl9fn19f4CAgIH/gpqC14HngIR/hoDefwx+fX18fH19fn9/f36Ff4J+hX0CfH2EfAN9fHwCAgQAQpbY8JyR4KKshXemn3rKbWt7YzQ7PkQ/QTw/Qz1dgtr2kKaaoNjM5JWXeY9TaPl0f6KmcX/HYUVJSUpLSkpLS0xMTIVNAU6ETQNOTU2FTghPTk5OTU1OToRNBk5OTU1OTIRNKk9qtWa3o8iDyWbSfGXngoZZVWVae1P83JefpJyTgm/JlWOFccd9TU5NTYRMCEtMS0pMS0tLhEwrTU1NTExMTU1MTExLTE1NT0thbrGouYSDdEVOT01NS0xLS0pKSUlJSElJSYpIAklIhEmLSIBJSEdISEhJSElJSUhISDxDUU1ddj8yP1pdcW5CQ4tkrH+SZ2ZmqK6R+JJ0nXh+blV4VH1uS1HSQV93PXBceFBShH9yhmJdPGBimVa6bGqcya6frriA85eIgJNIc4dtccrGmfKH6MqymYDVql1ljmdoyG52iG+OfoydfHO5nF9caYDTvF+NhYSsupx3fXGrfo5wrWRwZ5WNgYawnoRZUnSgeWW4ZnZLS0xMTU9QUVJTVVZYW2FeYWJkZGJiZGRmaGhqbG1tbm9vcHJ0d4CGjJWgt257gHh5iWqXkpphUpegcaSEtF99j5anYYmofoDWqnC4j5d1o3iIdYKLbMOUZaReuoC+eW+ryXrNuuqRjqm4y8SpbeLEbY98b6B+1dvCe85tyNuHp869zO9yyfbagHxxd9l0yp2hlKlZVlZYWWxxfGZiW1tYV1JNS0pLTExMTU5RUlNTVFVVV1ZWV1lZWFlaW11fYF9hYmRmaGdnam1wcHBydXl8f4ODhouMiYmHh4mLiUyKioaGhYWFhoKBhIN+enl4d3RzcXFwb29ubWxsa2tramloaGhnZmZlZGRkY2FgX15eXl1dWlpZWVhYV1ZWVVNRUE5OTU1MTExLTExLhEkBk4SWgJibmpeVk5OSkZCPjY2MiouJhYOAf3+AhoeCgH19fnhzcnJwcG9tbm9vbm1saWdlZGRkY2NkZGRlZGNjYmNlZ2lucHqDh46Sj4V4bGZiX124sqyjnZqYl5eZmZqbnKGmqKmoqa2zuLvDv7Omn52lqZiVk6GsqrG0tZ+UmbG2qqekgJyOg35/gZCCbGtxdIODgn2FiI6QkZKRjIR+f355dnl+fHl1bW1wbm1vd3ZxaWVgX11aVlVUUp+Zl5mYmJ2kp6akpqCRgXh0bmpoZ2ZmZWVkZWmPoqhes52tlpKEeIKQnllpWnpmW1lYWFhXVldaV1ZUVFNSU1JRUFBPT05OTUxMBEtLSkqESQJISYVIhEcuSEdHSEdHR0hHSEhJSUg3xHtlRT9eWlVKR0xMSXliVpi/fGpnZo55/JBEms3ztUmQuOOMk+aXmoaCxM2M/o6HqpVTX2VyY2xka3JdfIXS9H2vnavp5/i5tZ6+e4zxgZGtroCh/X9jeXB9goWGh4eIiYmJioqJioqLhIqEiwqMi4yMi4uLjIyMh4uEjC6LjIyMhoHcg86p4J3oeeybfeaCi2lniG+SY/HPoLC/s6qliOatgLOU6q+Li4yMhIuFioWJAoqIhYkWiomIiYiJiYmIiIh6gZHQv9qYpodfdoSGAoWGhIQFg4SEhIOEhAeDgoKCg4KChIOFgoKBiIKEgYCCgoGCgYKCgGdsgXeevWhWZ5OWp65oZa+P9cjdnqGa6caw2IaLx5W1h36teZ+lcWbuZZKEXad8qXV5tbSolouJWYyQy2nJl5C898C2x9Ck44eUdYVinbWJh8Oma8xrt/vnypfyfWd9sISK/YCguZrUocfJnY/ryoSBht3xgamloYC+1LWKh43Sm7GR5YSMg6Kgmp3g16RsaJfEl4HggphqbG1ub3FydHR2eHp8foOBhIWGhoeIioqMjY+QkpOUlJaWmJqbnqGmq7G7zXR9gXt8iXKyqbNvXqq9hr6X1myQoay8b5e7k5P9x4LUqrKHv4qaiaKhgve5dcBs4NaUhtX1nYDLxvybqsnNztLAfP3se52Li6+CyfbclPGA2/CgxvDXzPqCzurng4mDhPiF3rXAq8pubm9xc4GEjH58d3h1dHBraWlqa2pqa21vcXJzc3R1dnV1dnh4d3h5enx9f31/gYOFhoWFh4uMjI2PkpWXm56eoaSlo6KhoqKkoqOioKGgoRuioqChoqGdmZiXlpWTkpGRkJCQjo2Njo2NjIuEiQmHh4aGhISCgYCEfoB8e3p4d3Z2dXRzc3FwbmxraWloaGdnZmZmZWNiY2LFxsbFxcbHxsPAvr28urm4tbOysbCtq6imo6KipaShnpybmpeTkZGPjY2Mi4uKioiHhYOBf35+fXx8fHt8e3p5eHl6ent/gIaLjZCRkIl/eHJvbWvTzsjAu7i2tLO0tLW0tYC4vL6+vb3BxcfJzMrBuLSyuLmsqaiwtre5vLutpai3urGuraielZKSk56Vh4aIipSUk4+UlZmampyalo+Li4uGg4WHhYOBfHp8enl6fn57dXJvbWtpZmVkYsC8uru7ur3Bw8TBwr+4rqmmop+dnJycm5uamp2yvsFnybvGt7SrpCqpsrtjbmSjlo+OjYyMjIuMjouMioqJiYiIiIeGhoaFhISDg4KBgYGAgICJf4h+iH0hdlTyrpVvYIh6eWxtfX5rlHput9aojYSKpo3ciFmcsv68TjhGeWWFg0JUPEaU8oPxo47Y6omkuNSgxbvP2aWlTGNzTXtUTlhnkn9Pd7mSp4NQSERFNor+i5vJlszl9vb3+Pn4+Pj5+fr6+vn6+/r7+4j8QP38/P38/P37/Pz8+/v8+/z7+/v533bIkZJKwLjOg/DCpZlzjYOCxYyohOu/kY62o6nLorx8irqkrcf29/f4+PeF+EH5+fr5+fr4+fj3+Pj49/f39vb29/b18/DtxnSpm1pubbdggLfm6urr6+vq6+vs7Ovr6urq6ejp6ejo6Ofn5+bn5oXlD+Tk5OPj5OTj4+Pk5OPj44figN2okZuf1tiFg5fH3LvVm5ekU4Jt08vs4t55Z5dkY4+A2JPE8pt/xqmE35jPloSugN2gn9D56pbC14/Zrd+NueeopcGLjJmP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ZIBjYmJhYWFiYmRlZmpyeHqGlI+Ddm1oYV24uLWvqailqaunpqOioqSnqainpaSkp6mpsLm3r6qrqquxqKanra27taugn6Cqrqihn5qRh4mQqKaEdHJzcXZ8f3t+i52ck42NiIN/gIB7eHl/e3t6dHFsbGxrbnFtbGlnZGBeWlpYVT9Sn5uYlZOSk5eblpKMh350bmtqZ2VkZGRmZ2iFWmBgZ12vqpecjYyYo7dsb2izk3pdXVtaWVdYWFdWVVVUVFOEUhNRUVFQT05NTU1MTEtLSkpKSUhJhEgKSUhISUhISUlJSIRJI0pKS5lwdD9KOHFWRUtMTE2Ha5SYlVdyZ1hTcmixuH+u9YXIRfDcxI9h74HxsIJiftHYrcisoVZjfXmOaG19fn5drMec14eedumKz6bMwoSXoIjWmbOUzbrOvX5ul89xhIiIiYmKiouLioWLCoyLi4yLjIyNjY2EjAqNjY2MjIyNjI2MiY0ycZn5jb3RvrvIpn+jfGuedJVhV4Oosrt067WVl7mDqOF+jXiLpoyMjYZ9jIWKjIyLi4uEigaLioqLi4uGioKJhYoSfbrT68K/m/OF5saGh4eHhoaGhIWHhAiFhISDg4SDg4SEDIODg4KDg4KCg4ODgoqDgIKDg4N8VJteknxrn4RoY5dRf2Bgd9zdosCDjFtxu57+ka6GrPGNmYdhaHBrg+aPlWaDVlJhf4b5qZ3Kn2Zhb5bUhZa5r8DBtYam1662wIZyeemwrnWulseKql/I0Meml9yBtsP1tsCFl+ucjuvto+OjnIKB5uSI6cqAyKje7ImYgIaCkfOlg/zstsjWloaJ2bObdmR7r6fZlHj4lGptbnBxcnN1d3l5e31+gIGFiYeHiImLi4yOj5ivt6OUlJWWmJmcn6GorrDA2n1/cnuCkHVtuqBgi8W098XCbpakkbGncGxzsI/Qnov6sP/6vbzHicuB2J2WyKSxqKil6bWQ5KWIQfre1JvnurSlhv6s+bTUjKCA3KKF1ILusLGQwrKend2qyqC/36yAlNqKw5ClbnBzdXd7g3+AgIB9fHt3eHRwbWtrhGxTbm9wcXFyc3V1dXZ2d3d4ent8fX9/f4GDhYaGiIqNj5GSlJaYmZyeoKSnp6WjpKWkpaOkpKOioqOioqKhoaGenZuampqXlpWUk5OTkpGPj46OjYyEi4CKiYmIh4aFg4GBf39/fX18enh4d3Z1dHNycG9ubWtqaWhoZ2ZmZWVkY2Nkx8fJxsbFxMPAvry6urm5uLW0srCvrqyppaOjoqOioqCdm5iWlJKQjo2NjIyMi4uIh4aDgoF/f358fHx7enl5eXh4eHl5eXuAhYWNlJCHfndzb2vU04DQysbCwcLDwL68urm8vr69u7q4ubu8vL/Fw726u7m6vLWztbe3wLu1raytsrawrKqmoJmanq6tlYuJioiMj5COkJmioJqXl5OPjIuLh4SFiIaFg4B8enl5eHp6eHd1c3BtbGhoZ2Rhwb67uLe1tri7ubezr6qloqCenJubmpqbmyOcq2RpaG1nxcK2urGwt73Jb3Fsx7KjkZCPjo2NjI2Mi4uKioSJC4iIh4eHhoWFhYSEhIKFgQuAf4B/gIB/f3+AgIV/hX4he9WQomR9VJNxa31/f328hr3EtHGZiXVvm4u8k4udtV6fQ2ZwrtmGsTZbWGuBq7HfpneW6oWn8N7Lucvx8e2Kcmlog3pIOFRPkEpPXG1pVTRSLkg6Y9HYtc2IiPqj6vf4+Pn5+vmE+of7UPz9/P38/Pz9/fz8/f38/f38/fz8/P39/Pv8+/nzrm6gU3CXm253dI3jpbL5zd+ijMLW295byMaTdK2nf9qKrouiyvf29ti179Pd9/n5+vr6hPkD+vn5hfiG9xf29PHuzJfY0pZhgONYZfrj6erq6erq6oTrAuzrheoF6ejp6OiE54bmBOTl5OWI5IDj5OTj5OTj4+Pi04fzjLKqkM25jIPwgrGdnavZkWfdt46DkIlttnGlZpT9vrm1jImSoa2+v+yJyomBnr607bTL3YWOgZOTpWJo3N2RdYp2gMHGyIFRQE/Qu7GDz9v8YYFAi2djV1LOUNzbuZCRQkimk4bv+HB4U05VQlBxRGlXZoDhsealXk4+PDpEQDJZZDhQXEk3LV9JWYeGr8/A0buC9tKkqaqrrK2ur7Cys7S2uLq7vcDAwcLExMbIycrO3OLX0NDS09XW19jc3t7d6vuIioKIjpqIh/bUgbXks/j19o2xy8Hx1pWLhcWRv55lpIaS59SLjlXjbd2mkJOWoMuufjqzr227UGSho9t7pGGNiIG6tPavmV99eseejYdCkmWpf6qChWu5WkdFaLe8fHjIh8uax4aJi42OkZWThpUGk5ORjouKhIswjI2Pj5GRkpOUlZaWlpeYmZqcnZ6goKChpKWmpqirra+xsrS1t7e6vL7Bw8PBwcHChMEHwsHAwMDCwYTAgL6+vby8u7m4t7e2tbW1s7KysrCvrq6trq6trKyrqqmopaOjoqGgn5+dm5mYl5eWlJOSkY+OjYuJiIeGhYWEg4KBgICA//79/Pr59/Xz8O7s6ujn5ePh3tzb2NXSz83My8rIx8XDwL27ube1s7KysbCurayrqaelpKKgoJ6dnJuZgJmYl5aVlZWUlJSVl5iYm56alY6Lh4OA//z69fLv7O7t6ufl5OLi4+Pi4d/f3t/f3+Hi4d/b2trZ2dTU09TU1tTRzMvKzM/LyMfDwLu7vsjGurWzsrGys7Oxsra6uraxsq+rqaenpaGho6GfnpyamJeWlZWVkpGQjoyJiIaFg4KANv/7+fj29vj2+fj59/f19PLx8O/v7u/v7u/v9YCCgYKA+/v4+PX09vr/hYaD/PPt5eXk4+Pj4oXjHuLi4eHg4eDh4ODg39/e393d3N3c3Nzb29ra29vb3IrbhNoj2djN+37op9WArZqt2N3d1N13ze3CjtSCioHKvbhetq95Nj0SfHx8fn58fXx9fX5+fHx9fX1+hH8BfoZ/CX18fHx9fH18fYR8hH0BfIR9B35+fn9/fn6yfwJ9fId9Cn5+fn9+f35/f36EfQF8hH0Dfn19hX6lf4V9BX59fn1+un8afn58fX18fX19fn99f39+fHt7fH18fn17e3qFexx9fH1+fX1+fXt9fn5+f39/fn17fH18fH5+fXx7hHwTe3t7fHt7fHx7fH18e3x8fX1+fYl8A3t9fYp8C3t7fHx9fXx8fXx8hH0De3x7hHyCfYV8EH19fXx8fH5/f319fH5+fX+tgIiBSICAgYB+fn1/f4B/f4CAf4CAf35+fX59fH17fX58fHx+fn19fXx9fX9+fXx9fHx8fXx9fn19fH1+f31/fn58fX19fn9/fX18fYR+A39+foR9CX5/fn1+f3+Agf+CnILTgemAm3+FgIl/g4C+fwh+fn1/f399foV/BX5+fX19h36EfYN8AgIEAEG6mdaXp7zhhPeZn2nSjo2sbWaBOT1Aooc2PUQ/W5p7wb/E6rWsdOZ365mTqOPRr9zLmmpPkW9Mgqram05MTU5QTohPAVCET4RQDk9QUFBRUVFQT1BQT1BQhE87UFBQUVBRU3Slo+rtg5yIns6am3tVUlGFUEw8RJairJOOhm1xcJyoeX5AUE9QUU94dGx/hU5PTk5OT06FT4VOI01OTk1MTU1NTk9NR5eghXCvd36wfpVSUU5PUU5GTE1NS0tMhkoLS0lKSkpLSkpKS0mESgpJSklKS0tLTEpKhkuATEtLTExLS0tKWU1ON2FFZ29UUEZQRz9isq5+3ap5a2GGj4+waKizV0FzTIxOXYmPkXxwVlt/YWyso5agqrOukIt1qbCPoraima3a1sp/Wllzl7irlaTMy5FTtaqK3ImCiHvW13mbsLCplntnjrZwbqbLaK9/27GzxpHEbXOsonSAhZKeoICqerePopZ+h7CWhHa6mmyOdGd4ZIGEtlFJT1BPUFFTVFVVV1lbXF1gYmRjZGVlZmhpcoOaqc7es3l+cnJzdHh7gpCRmqzBsK/BdIZ+hnBuhLZ1nLSulmB7Y1pRc2+UgJCPqniIa3OPe2yokYN5c5fJbMh2p6KDgo+wpZpYqJ6o0cbec9mDiMNyhqKInZe/79Vqk4LXwa+4gq+Ar8WI6LuGh7eMpMGCkYS8ZVdYWVxcXl9hZmNiYl9hY2FYVFJQUFBPT1BQUVBRUlNUVVZWV1haWlxeX4RgCmFiZWdpbG9ydXiEegh8gYeIio6RkYSPKI6PjY6PjYyLioiJiYaEhISCgICAf318enl5eHZ1c3Jwb29ubW5sbm6Fbwxua2ppaWdnZmRjYmCEXw1eXV1bW1pYV1VUUlBQhU8tTk1MTU1PnJuZlpWTkI+Pj46OjY2MjImIh4iIhoJ/fn9/fn59fXx6d3V0cnFxhXA1b25tbGpoZ2VlZWZmZWVjYWBgYGFiZWVrbXR7c3mIiIN9dW9rZWFeurm2tLKxsa6rpqOhoJ+EnoCfoJ6ep6mnpqmrrqmnp6Win56gpqOcnp2cm52dmZiWlJSUoLaqnJKGfW5wcmtudY6uopyWjIqAe3mBfXx9enh8e3FubGtpaWlnZGtra2ZiYWhjYFtXU6Sgm5WTkZKVkI6Lg3tybWxoZ2ZkZGVnanONr167taSdnrRhtqORmV1sbBljqZSIcGNkW1pZWFdWVlVVVFRTU1JTUlNThFENUE9PT05NTExLS0pKSohJikojS0aG0WWHTEo+UFFLTU1OTk2RgXFbh4OAc6VgS3aJkdbMqutAnX/ecZWuwX7vqsGF3KGoyIqBpV1qYb+8V2FqZIWckL2tyMuzwIP7huequsHn1bfq7LOBeLuIb6u+2sl+iYqKioSLCIyLi4yLjIyMhI0Fjo6Njo2EjgaNjo2Njo2GjjOPjo+PkI+UtLrs321+hoiOh6yhhYaFin92V1+Vp6yKjnmCj4qjy5qtYYmIjo52mZaOr6+EjROMjIyLjI2Mi4yLjIyLi4uKi4uLhIobhmzB06qO1IiP2YyzhId2fYZ9aHyGh4eGhoWGhoUGhIWEhISFhYQMg4OEg4SDg4SDhISFhIQBhYWEgIWDhIODkoGAWJtroq2GgnZ/amOY/viR+dO4pIKbmrvdgZmid12caLdvisWVva6Lgoy5jJ7fzb7b2sbhwsaXu8uHf8WrnbDZ1fGtenycrI12b7L5771033+G5caslKHim4Gcs8+1opWInOqSlNX8gNqi/uXzyb31iZDQx4iVc5mngKHmnPDS4MGXm7mfppHgxIiwjYKWfJ2e42Zjb3Bxc3R2d3h5e31+f4GChIeGh4iLjI2Nkp2vutTfwpufmJmanZ+ip66utsbXyMjWeIV9hXt4lsyKtM3JqWyLcGhfgH6nkKmhxYqjh42yn4DLuZ2Phbb1keKLvcybkrfn1LO6qcTlgPT1juOVos2IlMuUtKnR7/N7q5bpy8HWocSez86Z8r+Ml8+nyOeQrJvfempucHN0dnh5fXt7e3l8fn12c3Bvbm5tbW1ub29wcHFyc3V1dnZ4eXx9fn9/f4B/gYSFiIuNkZSXmpmYmJmeo6SlqayrqqurqqqqqKmqqainp6alpqSjFqOjoaChoaCenJuamZmXlpWTkZGQkI+FjoCPjo6NjIqJiIeGhISCgH99fHx7e3p5eHd2dXNxcG5ramppaGhoZ2ZlZGVlZcvIxsTCwL27u7q5uLe2tLOwrq2srKmlo6KhoaCfnp2bmZeVk5GPjo2NjIyKioiHhoSCgX9/fn5+fXx6eXh3d3d4eXl8fYOGgYWMjIiDf3p2cm5s1inS0c7LysnHxL+7uri3trW1tbS1s7O6urm5ubu7uLa2tLGvrq+zsKyqq4Spc6elo6Gioqq5sKaflpCHiImEhombrqSgm5WTjIiGi4iHh4WChYV9e3h4dnZ2dXN2dnZzb25ybmxpZmPDv7y4tbW1t7Szsayoo6CfnZybm5qam52issZnzcq9u7vIacm+s7hmcHBpwbGpm5OUj46NjYyMjIuGigWJiYmIiISHEoWFhYOEg4OCgoKBgYCAgYGAgYqAJX9/f2/F/YG9enJadXl+gYGBf2/Dr42Ataqjgrp/bpxeWn56bp9DXmD/arJ7WjXKtfiysHFPX2Z4rpa9m+P5kqq5qMF8oJNulHZRVTeHQ2JMcVxlVTs/REZor75ii6+HmO3L+Pj5+fr7+oX7Cfz7+/z8+/39/Ib9BPz9/v6H/YT8Nvv7+vj0mW2xkX47Qm9hW2q10erv7rrfzY6YprvFkJddlrGvj9S71Ibp6PnwlHqIhMCf8fj4+Yj6hPkv+Pj49/f49/f39PLkqLToq27YaVWlOqbZ4bbQ48uWzujq6+zr7Orr6uvr6eno6umE6AHnheaH5QLj5YXkgOPj5OTj5OLk4t/f6s7GhN2Ox9/SzrXIjojD0eCB47jq6Yh3dYzlm4R4mIezhduF2PNx2sKqudT70c+6iH+KamSJvdyJdHlaWMV0Z3+LhPDvrrLEg1BCSq+akNqN0ldTo2VWSViVZoBaZaaNcF9JYJ52dIRvOlxPZmWMYVWofXmOgIVNbz9XUj9LOGJFQlBNV1c7LjZWY4bEtr7Em6Kh5IaWqqqrq62trrCxs7W2uLq8vb/AwcLCxcbHyczV3e3359LV0tPW19jb3t7d4u358vH8hpCMkYyTxP2Jwe7f04eyioiBmKbRsLOjsm5lT1BydYSinmWllLH+gN1sc6uYpKXTRZ6LT4esd9DKcb6GcGlToZ2NxXH+4tmLznWBaHu0k5qYtXJ5YFxKgKqLn8hsx7DulIOHiIqMjo+QkpKSlJOVl5aTkY6NjYSMEI2Ojo+QkJKTlJWWlpianJ6FnyKgoaSlqKqtsLO2uLe2tri7wMHDxcfGxsbHxsbFxcbHxsbFhMSAw8LCwcHAwcLBv728u7u7ubi2tbSysbGwsK+vsLCvr6+uraupp6empKOioJ+dm5uampmYl5WUk5GQjoyKiIeGhYWEg4KBgYCAgP78+vf08u/u7ero5+Xj4eDd2tnW1dLPy8vJyMfFxMLAvry6t7a0srGwr66tq6qop6WjoqCfnp5GnJuZmJeWlZSTlJSTlZWYmZaWmpmVkY6LiYWDgP/9+/b19PHw7Ojl4uHf3t3c29va2dfb3Nrb2dnZ19bU09HPz87PzcrJyYTGTMPDwcC/wMPLxsC8t7Ovr6+ura+2v7q3s6+tqqakpqSioqCgn5+amJeVlJOTkpGRkY+MiYmKiIaFg4H//Pn29PP09fX09fLz8fDu7u6F7STu8fb+gP/9+fb4/4H/+PT3gISEgPfu6+bk5OTj4+Li4+Lh4uKE4Q3g4eHg4eDg39/f3t7dhdwD29zahNsF3Nvb29qF24TaI9er/59t8cu3hqy62Nzd3dmi9Py5xPGZimJxrbXzQDZKTERdDHx9fH19fHx9fH19foR8CH19fX9/f319hH8Efnx9fYZ8AXuGfIV9CX5/fn5/fn19frB/BX59fXx8h30Ffn9/f36Ef4Z9B35+fn19fn6Gf4V+nX+FfQV+fn1+frt/hH4EfX18fIR+C31+fXt7fHt7fH18hHsUfHt7fX58fXx9fnx7fHx9fX59fn2Hewd8fHx7e3x8h3sHfX5+fXx9fYR8BH1+fH2GfAN7e32HfIJ7hHwBfYh8gn2JfAF9h3wPfX19fHx9fX5/fn59fX1/sYCEgQSAgIB/hH4Bf4SACYF+gH9/fn59fYR8B31+fH18f3+FfSt8fX5/fX18fHx+fXx9fX58fX18fn99fn58f3x+gIB9fHx8fX5+f359fXx9hH4HfX1+gIB/gf+CnoLTgeiAm38BgIZ/AYCEf4SAvX8Jfn1+fn9/f35+hn+Hfgt9fH5/fn5+fX18ewICBABAhKPSqZ/g5bbOjmujvXqScXNni7BcbqZ3STZFO0+/5NnclsO2p4OwwIN5idmBw3CA2KtESnuybWyqdE1OTk5PT4RQWFFQUFFQUFFQUVFRUFFSUVJQUFJRUlFSUlJQUVFRUFFRUlJRUlJUVEtn3e3Nz4aZr8C6poeGdnyiXGxLQ4Cgl0pmhJ9YiHyjg3xGU1NTUci1h8J2cU5QUFGETw9RUE9QUE9QT09QT09PTk6ETR9JTL6ompN3hoJrqYdSSnGVUHt8jZZPTk1MTEtLSktMh0uCTIVLAUqES4BMTExLTE1MTU1MTE1OTk1OTk5NTk1FNjdeP09pWFFVUEtaYVdJd0dqrKtpS4OQfmtjrniklsmK0qzO0Iaet4BuRFs9UbebpGRt05zEbm2fvZzlndL7vZ3IS09whUtshsSTg5+kn6iToMWuW3Nza7iJtrt4eIayomRrfYGlX5KJfSq8xHG9rmWiuneezJ3OmqLDkGigrY+bsIeOmZGpd5axa9CUa1iDwpeWeEyEUYBSU1RVVllaXF1fYGJiZGZnampqbHOCipWnvcCokJ2iqoucp4uqrJiYnqWqs8FubW+yeKZcoWi2eGCGcFikoaZjjKOBb9OHbKKwbpO3hqpxyHV5pM5xmqCkgLC4w2WRjnlklqu/rbzD0MWYmLmSmq95mbWwb+mcs36Jy5CYoaud9H3lnrOK/rWIhmh7dZ5TVFdYWltcYmJjbW5jXl5dWVRTU1JSUVBRUVNRUlJTVFVWV1pbXFxdXl9fYGBhY2ZnaGtucHV5fH18fX2AhoqKjpKSkpGRkpSVlJCRlJKQkJCPjo+NiYmJh4WEhISDgoB/fn16eXl4dnRzcnJxcnNycoRzAnJwhG6AbWtqamlqaWdpaWhnZmRmZGJfXVxaWFRTU1NSU1JRUFBRUaKfmpaUkpGPj46Ojo2Mi4mIhYSEhIWBf35+fXx7e3p5eHZ1dHNycW9ubm1sa2xsbGtpZ2doaWloZ2ZlZGFhYGJmaGlsa2lrbW52dXh7enZ0bmZfW7W1s7CvsbS1sKweqaqpqqmsrKqpqamoqqqqpqSnrKinpKKlpZ6bmpmYhJRxlo+QjY6OipCSjoiCenZvdHJwamx3qqCWjYmFenZ2gH56eXh4fHl1cmxpaGZiYWFlam5sZ2VkY2JeXl5ZVaWhoZ+fnJWPjYp7c25tbGxpZ2dxeo+nu2C+s7CpqrVlZWGgd3eHsWC1no+EeHZxZ1tZWViEVoJVhlQRU1NTUlNTUlJRUE9OTU1MTEuGSjBLS0tMS0tMS0xITk1MTX1q07V4SkA+YVtLTU9PTIlzfmxCRGzGg5tIUUl6mp2dvv0/YHyejYjb6rPXmIO5v4eijpWAsOGJnL+iZlRuX2vb9MfMiru0r36725WIo/mS5IGS8Ndka5XWg4HJlneEiouLh4wCjYyGjYSOBI+Oj5CFj1COjo+Pjo+Qj4+QkJCRkZCHdoTi7b+9cXeGh5ymnqCgqKxzkWtfiqWdaomvtmt/icCPq2uPkJB88c667aiTfo6PiI6Ojo2NjYyNjIyMjYyMjIeLG4NyfPTe1K2LoaiEp6t+boXCcKWlscR5h4eIh4SGAoWGi4UDhIWEkIWAhoWFhYaFhoaFdllZnGmBp4yCh358kZuKcq9ulcqwkG68uZGQieWht7/3u/mk1/azlLmvp2eGW2/tv8mMieWo/YqErNCnyX6+8r6f3WNsmMBqm8usanKv0sfxya21yIiKgoayd8nVmJ6NytuFj7Ov4oCxrJzw6ofKzILQ75XA7r+Am3KY6s2TtL/X3tmbrLKbz5S01ILzuIRwqfS1uZZncXNzdHV2d3l6fH1/gYGDhYaHiYqMjY2Pk52lq7fJzLqrtbi/qra/rcHDtbW8wsXM13V0dLF0tWSpb8+DbJyBZbe6tXCdyZeJ/6WA0NiFs9WQyYX8honK65O3tbScxMvjg6lHp5F3rL7PxNLN5Numt9qpv7uNoM7Kgvyp6IyO6LW4s6ST7PStw6HuwKiXepKKwGhrbnFzdHZ7fHyEhH16enp2cnFxcHBvb2+EcBtxcnJ0dXZ5e3t7fH1/fn9/gIKEhYeKjI+Tl5qEm4Cfo6enqq2trayurrCwrqytsK6trKysqqyrqainpqWlpKWko6Ggn52cm5qYl5WUlJKSkpOTkpGSkpKQjoyLjIyLiIeGhYaEg4SEgoF/f359e3h2dXJwbmxsbGtqaWdnZ2hnz8vHxMG+vbu6ubi3trSysK6sq6qqqaWjoaGfnZybm4CamJaVk5KQj42MiomHh4eGhoWDgoGBgYB/fn18enl3d3d5ent9fHt7fH2DgYKCgn99eHRtatLR0M3Ky8zLyMPAwL+/vb++vbu6ubu7u7q2tLe6t7W0srKyrqqqqqikpKSjpJ+fnZ6dmp6fm5eTjYuGiYeHgoOLrKKblZKPh4SEi1iJhoSDgoWCf315d3V0cXFwcnV4dnJxcG5tamppZmPDwb+/vru3s7Gwp6Kgnp6dm5uboaWxvstozsjFwcHHamtovKOkrcdox7mupp6dm5WPjo6NjIyNi4uLhIoDi4qKhIkNiIiHh4aFhIODg4KCgouBKoCBf3F2gIB5r4nv05ZwW12LeHl+goJysZSckltegvacwmp6aI9gU0tWxEI/Xm5ze7yaVKGvrNK8hFVsqXaC4Mver+CQksGmkdXyklo5dZaHSUpjSzxIZTBJKCxdrpKRaoJlc9Gst+b4+fn5+vqF+4X8hP0E/v3+/Yj+hP09/P39/fv7/Pr69NK2m5OUeXhUX25pjLnL1+j61J/Qrpqet8CqwvjThWp+tmbWpPj5+LNydNCq3X+7+PXV+YT6CPv7+fv6+vn5h/g39vTgtMzX1uRzhsjObj6ov5xR4JTJw67suuns6+zs7Ovr6+nq6unp6Onp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dnV3dHN1dHBraGVhXlhVU1JSU1NSUlNUVFSloZ2bmpeXlZKRj4+LiYeGhYWEgoGAf318e3t6eHl4d3Vzc3NxcW9ubWxra2pqamloZoVnDmZmZWRiY2RlZ2ZmZGNjhGKAZGdpa2toZ2VeXVuzsa+ywMrKwrq6uba1tra0r6+xtKmgn52am5yjpKampqSgnJiVl5iWkpOWkYiFhYSDgoKBfn+AfnpxbnB3fHl1gpePg32DeG10fH51c3RzdHd6c2traGRhYWVubHNybmxpY19fYmNiX1mura6vrKOdmZeIfnkmeHNteXZuibW5tLKrnIqQoa64sqiNenRvcImpoI+CfHxzbWZcWlmEWA9XV1ZWVVZWVVVVVFZVVFSEUxJRUE9OTU1MTEtLS0pLTE1NTUyETSeKeU9OT43DqHtcxYdNS0R+fVBPSICcjqFwQU+CeahnRVWg4PChjd08Y1PEpne1o7OdymtmzKaJgmzz6nCsp1dkXGJjYL+MoLyXvcCqrsC3su6H0LjH5Yi0hcxzwuzasb1+cYmLhIwOjY6OjY6OjY+Oj4+Ojo+QkGuPkJCQkZKSkZKSh7Tr/+KhibJ1gKCIf3x0trRtdsN7n8qrkWXYoFdgbHGoz5p9mXqPkZFmqN7miollkJBlaI+PkI+Ojo2NjY6NjYyNjY2MjY2MjIuIZnmqYFrr7HeUuJjKcZn6rWaKlYeLfISIAoeIhIcChoeIhgSFhoaFiYaAh4aGhoeGhoaHhoaHhoaHh4eFe4RqebCJ6eO72pyCm7ZkdbJ6pF+PyaPjgZugv7Pcrb6SpI2Qirav3rBqXmydqJng2LmfuaWe7c+2k9uZmvB4rtOfpZDE7uCTte2ouKKTpYyota7j2u/T38XCXKyOdPuxhZGnndnYpYiN1vza+9KAi+2TobLx1ry+nPrRuumHp9uqsKjniq6w3ueM2PvQwXqNgWBwc3RzdXZ3eHl6e3x+f4CCg4WIkZebu66tvrW/vLGwqq22qKm7z87R1Mng3dq/u77E0m9ycXiDg3Z1dGd2Ze+Lt3bBsrO7pJfMlqqHiemOgqqM5pmW9L2Dm5GOibhctryPgu20snO3kOq3qNTyyZKv/cKddoKkkODPjPW3x7uKpqiH1KWon4qBiITXhtTNc3GnvstqbW9ydHV3eHt/f35/fnx7eXh4dnVzc3R4d3d2dXV2dXZ3ent8fH2EfkF/gIGDhISGiYyPk5WXmJ2enqCkpqmtsq+wr7LC3NDEvb3BxtHV297g2M3Nzsa/wsK9vLi0saymo6KhoZ+fnZ2cmoWXhJYKlZORkJGRkZCPjoSQF4+NjYyJiImIhIB+e3h1cG1sa2pqamlohGk70MzIx8TBwb+8ubi2tLGvrauqqaimpaOhn56dm5qZmJeVlJKSkY+NjIuJiIaGhYSDgoGAgH9/fn19fHuEeWF6eXh3dnZ2dXV0dXd4eXh3dXNubGrR0MzO1tra1M3My8jIx8XEwL/Awbm0tLGurrCzs7S0s7Kwq6inp6imoqOkn5iWlpWVkpSSj4+Qj4uFhIWKjIqIkZ2XjoqOhH2CiImChIBYgYJ9eHd1c3Bxc3d2e3l3dXNvbGtsbGxpZsjHx8fFv7u4t66ppqShnqSinazHycfFwrmvsrzDysfCsaWinp+twbuwp6OinZmVj4+Pjo2NjYyMiouLi4yLi4eKQImJh4eFhYWEhIODg4KBgoKBfX6CgYGBgoHAoX6Bf8rTu4B99rx9d2Gys4J3aLCsmcuIV3GupteQY3u+lp1YTo5LODOiblFqS0RJkI2A8IdLi4fTg4bj04yllainlN+Oq5lzaqK4u4NPTWk3WjEzWShCUv6m7XirY4+MqPD3+Pj5+fn7+vv8/Pz7/fz8hP2J/gX///7+/YT+av38/Pv6+fnXuqny7X9skV1hd2tmY22qjoqf+Wyo7raVWubAg5OBjHPujJTApej4959RU5R5g5rz9IKC+Pn5+vv6+/z7/Pv6+vn5+fj4+Pf39eWLxeqNgsrsgKXLVPCgrbjCk3FNPWLI6+2G7Avr6+rr6urq6Ono6Ibnh+aJ5QPk5eWF5IDj4M7dq7nPnPLn4/DFvNnRgKLklPuPoemu5GWAlKGNyYeXa3xncHiNidP6nJOsvVZLeoSkgYSrkdmaaF+Xb3boYXat0t+ysNTRnGaNYXRQU1ZKWmxefH1+bWJ1mIX7r5PolH1NaE5relc9Ml1mV3ZaQLJJQ1N7fWu2cI1jXXAwMxRVWFJJWDJRTGjQp9b9/+iGrLaLoYSrgKysrK2vsLKztbe5u7y9wsXH2dPR3tjd3tfY1tje1tji7u/w8+z7+vns6+7x+ICDhIiQkYyMjISXhPip5JT25+fwxqHlbWlUX6BmSG1sp7GTlnmReId8UV9YVGtptoySiOWX2nthc4p3X3aE47+HiHNi8ddwiGVpi5SOl4XCk5eMemZ7dGPBbPTWiYPO6/mChYeJi4yOj5KVlZWWlpWVlJSUkpGRkJGVlZWUk5OUlJWWmJqbm5ydnZ6enp+goqOjpqirrbGztLW5urq8v8HExsnJyMjM1eHd19TT19rf4OLk5uDc3N3Z1dfW1dPQzczIwsG/vr29vLq5ubi2hLWAtLSysrGvrausrKuqqamoqKempaSjoZ+enZuZl5WSkI6LiIeGhISDgoKCgYGA/fv49vPx7+7q6OXk4d7c2tfW09LQzsvJx8bEwsC/vry7uLa2tLOxr66sqqmnpqWkoqGgn56dnJuamZiWlZWUlJOSkZGQj46OjY2OjY2MiomHhIKAgP78+fn7+vj08e/t6ujm5ePg4ODe2tfV0tHR0dLR0c/PzszKx8bGxcTCwcG+ubi4t7a0tLOxsK+vrauqqqytrKuvtK+ppqahnKCko5+dnZycm5uYlZOSkI+OkJKRkpGOjYyJhoaFhYWDgP/+/v78+Pf29fLw7u3s6+vq6e/5+vki+vf19PP2+vz8+vPu7Orr8fj17uro6Obk4+Tj4+Li4eHh4IvhQ+Dg4eDf39/e3dzd3Nzc29zc29vawMnZ29na2tfDlNDa0PldUEmY3ubNw4i/8dq2h9pQQWpoga3K4PrTn8r/amQpKWOCfod8A3t+foR9Bn58fH19fYZ/g32EfBF9fXx8fHt8fH19fX59fH1/foR9AX6wfwF+hH2Cfod/BH5+f3+Hfgt9fX9/fn58fX1+foV/BX19fX5+nn8Ffn9/fX2FfgV/fn1+f4R+t38Ufnx8e3t8e3x9fXx9fXx8fX58fHyNexJ8e3t7fX5/f318fHt7fHx7fHyEewN6e3yEewl9fX18fHx9fHuGfAN7fHyFexF8fH9+fX58fHx7e3x8fH19fYV8g32EfAN7fXyEe4d8DX19fXx8fnx8fX19fn+zgIqBH4CBfX9/gH+Af39/fn59fHx8e3x8fH17f317fH98fn2EfAl+fXx9fYCAf32FfBR9fXx/gIB+fH1+f358fX19f35+f4V+B39/fn1+f3+Fgf+Cn4LUgemA338nfn5/f39+fX19fn1+f39/fn5/f39+fX19fn9/fn59fn9/fn19fn59AgIEADqTtfuFvKfArsSCYm1lmqB9pmGQmFVzRk5PUD1a7NahfNLrlMzTgIWFpbWfrZyr28ObX863rIHQf3BOhFAIUlFSUlJTUlKFUwNUVFKEU4ZUA1NUVIVTSlRTVVRUVFZYVsuMfaOCm7S+sLS5urWkgf3z/5GNjY+Lmaee7414n11hbqZmUdeeWZJ/mo2xubBLVIt3SlNSUlFRUlFSUlJTUFFShlEdUFBRU1FTVU9cfI55cp5XjpGafEVzz83LUFBPTk+ETQFMhU0BToVNDExNTE5NTU5OTk9PToRPA05PT4ROhU+FUIBCRzxpUWNEXpg/ZWdFPEh9P2djh22yiqeDnI+eqsKqjYfFtJqUwlI5W059YoeT8nCnrtp7ZUPOrc3RfdTvt8LceGR+b5CRdm9peLKHgmioq5WdnKNvoVZ6f2l/X3CQrqmxhaCtib5z6tWGn3FukcOb0G3C9ayGun55nMKLjH+JloC5y2t3fp99u9qeTW9mTVVXVVVWVVVWV1dQUFdbXV9gYWRwlot5enuHmqalp7G4qol8eXqLoaunpqTB3XltpKXCbGxpX2FlaW5zc5Naf297hmOyXo16jYt8imh0hM+Ht3Nzf21roXNwzMGMZ+x7oWaCi2ymhZyLjWu7lZeou3eyg4Ce3srHoZKtg+Tl6ZyJpp+ix3fWja95oLnCsnSTn5SuV1dYWVlbW1xfYGFiYWBfXltaWVhYVlVWV1pfX2FfXl5eXV5eXV5eXl9eX19fYWJjY2RlaGttb3J1enuAhoeHipOqopuhucXPzdTa3MvDzueEoqack5STjor6zbuupZ+YkzaRjouKiY2PjIqIh4iEgYCBgH99fHx8e3x6eXl5enx7e3t8e3x9fH17eXh2dm1oZ2djX11aWVeEVjxVVVRVVailop6cmZiWk5KSkI2LiIWEhIKCgX9/fn17enl4d3d1dXR0c3Fwb25ubWxqaWloaGZmZ2dmZWWFZIRjYWJhYF5fXl5dXFxdXVxcXmJeWlpbYGJhv7y5tba0trW1sayrr6uur66poJmZlpyipJ6ZoaamoZqVk42Ok5OVk5aWkZCNiIF9e3l6fn96c3l8fXx0bnKBgXt2dXFuc3yDcmyEa0pqaWZkYmBfYmlucHl5eXpyZ2JfX2JiYVxasVtfvrKmo6Ohk4qHiId9c3CApayrs7eso5eUmZaNhoR/h3xtdXtzdGtobGhiX11bW4RaGVhYWFZXV1dYVlZXVldVVVRVVVVTUlFQT0+ETTNMTU1FiXFMTk1HSVBKxo1PUU3Qm5C5r2JRUYOzoEROyM2xj4ecfkxPR0ZDVVLcn4L4xII7TnmxUZB8raPXg3KRgKuihdB3l6ttpGx8hIRVbM7WxYmv25ajxXaIjq7Alo2drvvs0n74yMeH55SbgYyEjReOj4+OkI+PkI+PkJCQj5CQkZGRkJGRkoiRhJJFkZGPipOQfuGciMtqeYyPhYmMjYuBZ8rEzHVzdXV0fImG3I6azYCCh9OEdfjHicejs5fI2NVtj72eb5GRkJCQj4+Ojo+Ph46EjRuMhoeMi3x+j6qghr12n5exomSP9+TofYqJiYiEiYiIh4cBhpqHgIiHh2xxYqV9l2yPzmGfm2hebLZinJnIi8OC76ixmq6xoZWUntyagILod1SIdb6Kt6H1lM63/puGX/7N39uEx8SpwvCWh7Cjxt7BqoqX57illuqcbs/Aw5/RgLCxj5qCo9n4+fegztSQ7JDw+qzGioSv7cbvgt3WyaPjmJTI/rWlgJSgrdDjhJ6gxJvy9L5gjH5kcXR0dnZ3d3h5d21tdn6AgYOEhYynoZGTkpyqs7O3vcO7pp2doKu6v76+vNHleXPDxNl0dHNtcHJ0dnh1n2aNgI+abstpnoinoIuhgZKc/qTXkIqOg4S2gozl1K2B+4vChZqfgLqfubakhdiptLPKRYS5mbHw6Mm6sdWg/un2o4yvo7TfhfGrxoy/3djKg6e5rtFqbG5wcXR0dnh6ent8e3p6eHZ2dXV0c3R1eXx9f318fHx7e4V8c319fX5+f4CBgYKEhomLjZCTl5ido6Sjpa6/urW7ytLY2uLn6d3X4PGCkJCKhIWHhIH239HHwbu1sa+sqaiorK2rqaalpqKfnp+enZuZmpmYl5eUlJSVlpSTk5OSkpKRkY+NjIqJgn59fHl2dHFwbm1tbGuFaoDSzsvIxcLBv7y6ube1s6+sq6qop6Wko6GgnpybmpiXlpWUk5KQjo2Mi4qIh4aFhIOCgYCAfn59fXx7e3p5eXd3dnZ0c3JycnFwcHBvb25vcm9sa2tubm7Z1dLPzczMysnGwsHBv7+/vrm0rq2srrKzr6yxsrKuqaemoqKko6SjpDCin56cl5OPjoyNj4+LhoqMjYyHg4WPj4mFg4B9gYiMgHt6enp5eHd0c3Fwb3F1d3iEfUF4cW1ramxramhlyWVn0MjBvr68s66tq6uloJ6nvMDBxsjBvLW0uLexraunq6WeoaWhoJqZmpeUkpCQj4+Oj42NjYiMEYuMi4uLioqKiYiIh4aGhYSEhIMxgmuuoXV4b2dugHDnt3uCcvOrk9DXiYCCv9fOYXTs+MaVnqqSZHJkZl1+a+hhV5VZRkgqW4MxaFFmT3BJltWsqFqD6aCZrIT6tdrv7YSHm7bqhIO1f2iiS2VITVs+RTA3YKrxjZRbfFV/Ub/X9ff4+Pj6+fn7+vz9/PyE/Qr+/v79/v///v/+iP9B/v79/fHy59r44q1oWVH2VVhsbGhqbGxvaFejoqJiY2ZlZ2x3eded1PqytpHWlJ6Crs/opYpUenWViezasJrr+fqE+yf8/Pz7+/r5+fr4+fn5+Pf03OHq58SXin7EVrKiZkygppSQq2eDxuuG7Sjs7Ovr6+rq6unp6Ono6efo5+fm5ubn5eXm5ebl5ebl5ebl5eXk5eTlhOSA4+Kxp4zrhLCMsOqS++Sel6XhkPTs2Yy4asd9gXeblH9wbIrVeWRjv62Byqf9Y2djlImylOycpobcuai2eLCTfqHjnMDWhKTAe2tVTHhmYVVzWjlxd21TZz+N3calrn1ua3B5UW1pVXc9bl5HUjYvVWVVfEyttMF3flNQXmpJSUiASkxjXTQzQbe9/LHohK+wlqqqqqusrKyurKeUkaWztLa4ubu8zMe6u7zDztLT1tvf3dPR0tTa4ubj5OPw/oKA8fL+g4SFg4WGiIuNicmAtZeQs4n5hsexr7+oiWJvpfZ9hHiJh2uAa0uBl5KOaKRMfHKTWFZpnsCWi3iEVKiRw3QxbqXAx8C3qJu9jqZ0h2xIc0GR1X/UqKGewt7w8ZzI4NT+gYKFhoiKi4yOj5GSk5OUk4WREpCPkZKUmJmampiZmpmZmpmamoSbgJydnp6foKGipKaoq62ws7S5vb6+v8XQzsrP19zd4efr7Ojj6fB8f358eXp7ennu5t/Z1tLNysjHxMPCxcXEw8G/v726urq5uLW0tLOysbCuraysraqqqamnp6alpKKgn52bmJWTkpCOjYqIh4aFhIOCgYGAgP76+PXy7+3s6efmR+Lg3tvZ1tTT0M/My8nHxcPCwL69u7q4trWzsrGvrayqqaempaOhoaCfnZybmpmYl5aVlJOSkZCPjY2NjIuKiYmIiIeHh4WDhIGAgP769/Tz8O7u6+jl4+Pg397b2NTQzs7Q0NDNzM3NzcvIxsXEw8TCwsHBv7y8ure0sK6trq6uq6isrK2sqqeoq6mmoaCem52ipJ2amZmXl5WVk5KQj42OkZGRk5KSkY6Jh4WFhYSDgYD/gID//Pj59vXx8O7t7Ovp6evz9fX4+fYl9fLz9vXz8fDu7+vq6uzr6+fn5uXl5OPj4uLh4uHh4eDh4eDh4IThAeCE4T/g3+Df3t7c3t3d3Nvc29qWdpWqwqSAlNKltM3G2K+sVUO80LHU1/lngoKwuPp+N3V1rpW1mJ6Mzph+MzhdISMGfn18fnx9hHwMfX5+fXx9fX59fH1+hX8Ffnx8fX2FfAF9hHyEfQR8fH1+hH0DfH1+sH8EfX19fot/g36Ifw9+fn59fn59fX5/fX5/fn6FfQR/f35+nX8Hfn59fn5+f4R+BX9+fX19t38Ufn59fHx9fHt+fn1+f358fn5+fHyRexZ+f35+fXx7e3t8e3t7fH1+e3t6enx8hHsDfH59i3wDe3x9hXsHfHx9fn1+fIR7Bnx8fH18fYR8EH19fXx8fH18fH19fHx7e3uHfIR9B358e31/fn+ugAWBgYCAgIqBOoCAgH9+f4B/gH+Afn9/fX19fn18e31+fX1+fH1+fHx9fXx8fH59fH18fn59fX58fX58fn59f39+fXyEfoN8hH0Lfn6Afn9+gH9+foCFgdCCiYPHgteB54ADf4CA03+Cfod/BX1+f39/hX0Ifn9/fn19f3+GfQF+h38GfX5+fX5+AgIEAD9zSmSShe2Zy8R1oGx3VK6Y0HK0429tTHlyS4x9t+bUiaOwqYeh1p/Dj52g5bPTf7SZsrN3msyJvENRUFFSUVKFUwxUU1NUVFVUVVRVVFSHVUZWVVUqVVRUVFVUVaeYjJdYjZ683siEmZmbqbSjlI6aoIuEnqusloGE9+Xq49TYy7JeSqnU9O7q+dTTcXjWxbnVl5PFzGqHhFMHUlJTU1JTU4hSJFFSUlNUVFdWT5JnxIupoImUmYNSfsV8llJRUVBOT05PT05OTohPCU5PTk9PTk5PToVPCVBQT1BQUE9PT4hQgE9QUE1HRzVBRjhkVEVRREtLWEJwdW+inYuSjcKIln+XiL23xmvOhK2oaXhOd164tFjFgZCw2I1PUW1Vd3WGvcDoz+uUcoJjeImEW2NccYZ6p5qTtKyEjICuwpNrg59loF5TX2hgh4iBmaLPr3qYisVysabCkn+Ehox7xJaOiXOAgG/chpu9boyFloJyclBJZ0dRWFpZXFlcWVhZeGuUVGJgYWFneYGJj31/iZuuvbGnm5e2y5R3d3yKl5mZnLPG09K4tWhxcXRrV1ZZWVl8aXODXKmQrYpr0YawbpmUlMpxdcDMk3t1gXmuw8mpsHeDp5bDkGpykq1ppXxokr+dhq2jSK+vjdOooJ/pq9J3wI+FqKZ1xcp6nomWsqt5oISffKSNvV9fXmBhYFpaXF9dXV1cW1paWFhYV1dXWFtcX2FjZGRiY2NhYF9fX4ZegF9gYWJjY2Vpa25yd3d7foWHiIqLkpqcmpyhqa6xrK+5vsfL0Nzs6/Hgv8PGurW7v7uwraOdmpeWkY+UlZOTmJaTjYqJiIaEgYGCgomFfnt7e4CBgX18fH+DfH18eXZ3d3RwbGtqaWZiX1xaWVlZWFhYVqyqqKeko6CempqXlZWVKZOPjImHhoWDgYGAf358enp6eXh3dnV0cnFwb21tbWxsa2poZ2dmZWVlhGSEYoBhYWJgX11cW1pZWFhYWVhYV1hYV1ZWrKqrq6qop6anpaKfoJ+ioqSjoJyWkY6Jh4mMj5KRk5SepaCkmJWOi46Qlo+Oj46Qko+Kf3dxcXJycm1qdHR0bXBzdHVzcnNzdnmAh3FoZmVmZWZmZGRhYGNlaW50eX14d25jWldZXFxZVjyrrbG4tq6ur66tp5qbn5+XjoaFma+0rqWSiY6YmIWAgIOKnZB4c25vbmxxbnd8dGdeW1paW1pZWVhYV1eIWEJXVlZVVlRUU1JQUE9PT05OT05IanGzeLu8w0eKcbx+U1GNibZ321dQU26fmmiWdG7FsaPJSlVQe0VWVkfX2qXgzvNQf11+en/PjZWhh5mFoWmxfc2Ov9mAimmupF+Qf6eolWGAipB2icafv4+hjb7G55bnwcrJjLnxne1ljY6Ojo+PkJCRkJGRkZKQkJGRkpGRkpOGkgeTkpOSSZKShJNMkdrNsbaCtsKyw6dqeXh7gol8c3F6gHJrfoiId2Vow7e8urK5trSBcL2+2NbG2tPWeIHr1NXy0czy/YC0kJKRkZCQj5CQj5CPj46Oj4aOF42NjY6LdLSF+Z3By5afuqZ2ouKWsoeLhIoCiYqEiQOIiYmGiA6JiIiIiYiHiIeHiIiIh4WIBYeIh4eHh4iAiYiDd3dXaXJaoIZxh297eYVlrLGt2smwtLP+n6qZlouns9Sd+ICHvZi4c62L/ft3uKSmt+Cham6Wc52Kkr2zyrTAspynlrjLvJqika7Epf7LhnzZq6yw2+OrhqfZju6Cg5abgqumfLrKyMmbxa76j+PR9cKCip+tnPW7q6SHkICA/Zu54oWjpbagjYtiXYNbanR1d3l4enl5e5uHvW2CgYGBhJCXnKCTlp6rusO8t7GvwtGunJygqrO0tLfI2eHj0dBxd3l7dWhoaWhnineAmWfDrMuffemcyHyqsKfjkIzi9LWRjoqUuNL0useMksO2162Bj67HicyNhqzcs5W8rMkpw5bfv62h9sD0kMadjri2gNTXh6ybq8a7h52Ztom3oNlvcHF0dndzc3WFd4B2d3Z1dHV0dHV1eHp8f4GBgYCBgX9+fX1+fX18fHx9fX5/gIGCg4aIjJCVlZicoqSlpqets7W0tbvAxMfDxs3T2dzg5/Dr6d3M09TOys/Rz8jEvrm3tLKurbGxr6+zsa6ppqWko6GenZycoJ2YlJSUmJiXlJKSk5SQkI+MiouJh0yEgH9+fXp3dHJwb29ubWxratTS0M7MysjFwsC+vLu7uLWzrqyrqqimpaOioJ6dm5uamJeWlJORkI6NjIuJiYiHhoSDgoGAf359fHx8hHlLeHd3dnRzcnFwb25ubm1sbGtsbGpqadDPzs3LysjGxcPAvby7u7q6ubayrKiloJ+goqSmpqenrLCtr6eloZ+goKOgn6Cenp+cmZCKhIZqhYKAh4aFgYOEhYSCgYKBg4SJjX95d3Z2dXV1dHNxcHFydHd6fYB8e3VtaGZnaGlmZMXGyMzLxcXEw8G+t7e4ubWvqam1wcTDvbOtsLa2ramoqq24sKKgnZ2dm5ycoKKelpGPj4+Ojo6NjYaMAY2GjECLi4uKiomIh4eGhYWFhISDcIqM663y9Plow4jXp351vK27kPByeH2QwKiItI6E0LvG92SAd6xhgn5j4mxeY1fNSI2OvW2OyE1XWEhjifWGnmvJt7XBlr+e/vGJtJiicGVDT1pgR1mMiHQ+QGKASlRX3rKHWn2s0FHAkfL09vf3+Pj5+fr6/P38/oT9g/6L/3GA/////v3+8+H5wIywuNaNmYRTXV1gYmZgWlliamFZZXFxY1FVoZufop+lr7azr+Cmr6iYp7DGiofMhl1w+e7d7GmX7vr7/Pz9/fz8/Pv8+vr7+vr6+fr29PHw7erjr8qb43m460hbu9W3o3Z3pd/s7YTuB+3t7ezs7OuE6gjp6Ono6Ofn54TmAeeH5gPl5eaI5YDk5eTk49rEw4ygsJL/0rnftcnF0IXb2sbds5+Od65wjH5za4CPrH7SWmTT1++Fz5/qzYyBs6+Ns5mFouClxpOEkY+Tf43M5Kt1ept2TVJDWG1egm1LPn5pYU1vgHtyqJVHcjQnMjlCYFdBVVpcTzk9Q2M+VlNzbkFURERGhllJSxM8RDVmPk9hM0NV2MaOk4iKt4SdhKqArKysravAnsiRsbOzsrK6vsPFvL3Ezdfe2dnX1+Lr2dHT1djg3+Dg6/X8//f4gYWGiIaBgYODgqyUmLWBtovduYf6o9qNx7274oqCn9GElGtmdEyEw4l6cKGejmyFcHFnel+YWX+XhXWbh4e84bn+yb2NlXXshIZZW2haR4mllbQplrLY2ZZsnNCg2rz+goSFiIqLiYmLjY2Oj4+PkJCPjo6Pj4+RkpSWmZuEnAadm5qam5uFmoCbm5ydnp6goaOlqKyxsbS2u7y9vr/Dx8nIy87R1NbU1tvf4+Xn6uzl49vU29za2Nvc2tbU0M/MycjFxMfHxsXGxMPAvb28u7i2tbSztLKvrKusrKyrqKenpqSjo6GfnZ2bmZeVlJKRj42LiYiGhoSDgoGA//37+ff18vDt6+jm5YDk4d7c2dbU09DOzMvJxsXDwsC/vbu6uLa1s7KwrqyrqqmnpqSjoaCfnZybmpqYl5WWlJOSkpCPjo2MioqIiIeHhoWEhISCgoD//fv6+fb08vHu6ufn5eTg39zX1dDNysXExcbHx8fIx8vLycnFxMPDwsHCv769vLy7ubavq6ipqB6op6anqaiopaempKOgn5+en6CipJuYl5aVlJOTkpGEj0yQkZKTk5GPjIiFgoKDg4GA/vz+//76+/n49/Pw8fLx7u7r6u709/b08e7w8vLx7+7u7/Lu6+ro6enn5+bo6Ofk4+Li4eHi4eHg4OHhhOBG4eDi4eHh4OHg4ODf397e3t3d3N3b26ZyO5vZrqOMle1Ec6fIptTDlly5jsK+ZzxGn7pibIB6qtCV0MD7kNLMk8MxMyYdjQV+f359fYZ8F31+fnx9e318fH1+f35+f35+fX19fn19hnyDfYh8BX19fHx8on8BgId/hH4Bf4V+k3+HfgN9fn+IfgJ/foR9Bn5+fX1+fpx/A35+fYd+BX9+fX5+un8Ffn5/fn6FfwV+fXx8fIV7AXqIexh8e3t7fH59fXx8e3t9fHx8e3t8fX5+fnyHewJ8fot8BHt7fH2GewZ8fX18fHuHfAF9hnwDfXx9hXyEfYd8Dnt8fHx9fX1+fn19f4B/i4ADf39+pYCKgUiAgH9/gH19fn9+fX5+f35+fn1+fnx8fH59fH18fH19fH1/fX18fX19fHx9fHx+fXx9f3x9fn+Af39/fXx8fn58fH18fH19fYCEfwWAgH1/gISB/4KggtWB6oDXfxl+fX1+fX19f35+fX5/f35+fX18fn9/fn19hH6EfQR/f39+hH8GfX5/fnx8AgIEAEVnRlSxnk90Y3TReeeDdFr6h5OOdKqYePiK7NKimo7RhMrj5XxuaXfhpLV3iMdpqalXpsaYgZKkh0RSVFVSUlNUVFVVVFWFVlxVVlVWVlVWVlVWVisrVlcrK1YrVVZWVleQvs67ze+PlIKE+9PkmKq6ubK1v6yVhIOprpT+gYjx6eTPmszfmLCZiIiGhIL3hZCKqYjktZGydHS0w01VU1NUU1RUVIdThFIbU1RUVVZYVoGnfKuXmo5uhJybRIW+WFNYUlJRhlAET1BQT4ZQCE9QT1BPT1BPhFABT4dQB1FQUVFRUFCFUQtQUFJRUVFOTlFRUIRTgFA5PGFPiH2IhWdHlaaetNqBr46Rs8G/kYNnqY9SRYlBUlJ+Ysv4+F7UW0laTnOQe5K5q4VhaH+KcW6KWmZhYWnFjnnWrHyJhXRtnZ9zaVR+joVmXlthbZaTraxzb8aEj7G3u3LEbqOGd3O5bKt5ioyMi4+7quOdkWdxdnNOUFBTgFtgYWJpZWtuYFNdtoRoiVxnc4SJeIWgp5iVp7q4t7GQoKa81IB5eHqBjZWUnqelqbCwuWxrX15VVFVVg1xqhHBza4O0baSZdIlqi2mpcIngroeM19PGfsbHuMDZaqDL13KthaZ5erCstnd7xIanzaONgrDTuK/y9auJb9XUpNeUZ57gq5icoJ994oh0eLrldoV9ql9dWltdWlpeXVxdXV1cXl9eXVxdXl5fYWJkZWZlZGRkY2JjYWBfXl9eXl5fYGFhYmNmaWxvdHh8gISGiYmKi4uMjpKVlpWWl5iZnaOorre/vrq2sq2FqICmrK+spqCdm5uinZiWmZ+ns6OclZGOi4mGg4SJiYSEgoGAhoyMioaGhoiSi4iCfH58f316dXBvbGhjYV9dWlpaWVhYr62rqaeko6Cem5uZmJeVk5CNi4qJiIWDg4KAgH98fHx7enp5eHd2dHNxcG9tbWxsa2poaGVkY2RiYmJhYA1fYF9fYGFfXVtbWlpYhFeEVoBXV1ZWrKqsrKmsqailpqerqLKuqKOfnJaPiIOBgIOFh4iLjpWmqKOflo2GiIaDio6PiY2Mk5SKe3Vxb2pqaWZiZ3BvbW1tcG9tbG9wdnt/hnZnZmRjZWVlZmppbHVzdn2Df391aF9XVFVXW1tWpqGfpailpKejqamjmpqdnqaakSCOi4qLj42fq7e5o4p9en6Po6CKfXVuamx2dXmCdWlhXoRbUFpaWllZWFlYWVlYWVhYWFdYWFdWVVZVU1NRUVBQUE9QTG5q4pKQloymqqqjr3p0uoXFss3FTkWcu6e6danVrJejtHxQ+bukfEGA4+y09s+mPH5Za3y0apV6etyA4nqRbt1ij6GUwLKPw1mReGx+b7Vpq8bcgYCBkfy3xoyo34Df43jf8cqlo8+9Z4+MjoSRApKQhZJak5KSk5KSk5KTk5OUk5NJSpOUSUmUSZSTlJSUvd310+PdeHVmZcKhsHWDjY6LipOFemxsiIt60Gluv7m2p3+luYWPeW1raWhoxWtycYlyxbah0ZWM1/BtkJOShZGGkAWPkJCPkIaPFXmpyaPavqOkiojCsl+s4YJ5iIuLjIaLhYqHiQGIjYkIiImJiIiIiYmFiIOJhYoGiYKEiYiFhIqAhFpflnzGvLq5l2vJsq7B6oKjnMX78e65hoLn0nhkvV50cKmF5+Pwd/VvYHtsj6Gkt7V+amqHsMStmeSaoJSaiOvBhLXZtLWunIzW4qWihKy3zY+KhIaLoq/JrJCO+qu44u72kviBwqiVleiE0oijnZ6godPA97GydYuNj2RqaHA3dXl7fYGAg4d+bnParYCpeoKKl5mOmK6zp6a1wcHBv6mzucnaop6eoaattba9xcXHzc7VdHZuboRnd5pqeZd/g4CZ33m5toKbe5h+voKX7cOmpvb3yoHR4s/M94O/1uaG5ZbYko7U1N2cldWVtueinI+86t/I+vrOpYr367fiop7jsaqrsKOR9YKAjbP+h5aPxXBwcHF0cnN2dnV3eHd3eXp6eXh5ent8fX6BgoOCgYGBhIACfn2GfIB9fn+AgoOFiY2SlpqdoKOlpqWnpqapra+wr6+wsbK1ur/Ey9HQzsjFwb2+v76/vsLFwr27uLa2ureysbO4vsK5ta6rqaWkoZ6foqGdnJqYl5yenpuZmJiYnZiXko2OjY2LiYWCgX57eHZ0cnBvbm1sa9bU0tDNy8nHxcLBv768uk+4tbKwrq6rqaempaSioZ6dnJuamZiXlZSSkY+NjIuJiIiHhYSCgX9+fXx8enp5eHd3dnZ3dXNycXBvbm5tbGxra2tqa2ppadHPzs3LzMjHhMREwsfDvbm1s6ynoZ2bmpucnp6goqiwsq6rpaCbnJuZnZ6fnJ2cn6GYjIiFg4B/fnx8f4OCgoGBgYB+fX5/g4aJjYR4dnWFdE92dXd9e3yAg4GBe3JrZmVkZWdnZMTAv8HDwL/Bvb/Au7a1tre7ta+urK2urq64vsXIvK6opKewvLmtpKCdmpuhoKGnn5eTkZCPjo+Pjo6Oh40BjoSNQIyMjIuLi4qJiYeIhoaGhYV1k4L2v6u2n93SwrzUnZLyrt+gu8hrYq7WwNmFqvO5r6DHo273ucalWp6/eVdvjblPkYSmXfGoz6aVbkGzc96Q3U6HuMDGu6KEOVVEUG1aikeBj65dY5KAonZlbpN5VfT6hPrq6Kp/wOeV7tzj9fX29/bw+Pr7/Pz9/f3+//7+/ob/CICA//+AgP+AhP9L98eRxZTqyWFYTEyQdYVZZmlsamhzaWZZWW90aK5WWqGYmYttiZ92dF5WUk9PT5hSV11zW5tpRXiznLOSgen7/P39/P39/fz8+/v6hPsa+vj18vDu66zE583A8WRugkO3xIfBl8Sp1e2F7gjt7u3t7Ovs64TqBOjp6OiE5xLo5+jn5ufn5ufm5ebl5uXl5eaH5YDk5eTk5OPW2uLg3OTk5OLYj4nPpPbdqbSvgamJgYi5a3x6bVqCr4hNQoKjrojZjaye2qjDpc2T/YeMuJ6voencpVxUgJmvhmVVd1BKRU1PeWZDWX9qalJUVoB9tVg3VFBOOTQ/TkBPVF5SPTNcNUFMVVQ2eEhtPy85ZD1TO0g8PIBBQ2FkfIeBgZOhxJefnaep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a25xdXd4dWRiZGZpcXR1dXV5fn9/iYmBe3JiV1NSUVOsVqminaCfn5iUl5qbm5WVmp+el5KIiSKOlJ+fnKusra6fk4R8fH6GhoJ4cGxpaG10bWtmYmBfX11dhFwFW1taWluEWQNaWVqEWT1YWFdXVVVUU1NSUlFRU1CCqIS3foTQlaqDfa+4sG15m7mr4WizxNKdu6SupI1+oqzKiY33gYP7h5/Lq6uqSPKA8HXXeNuBvIuji3ZplJt7uJGWt5W6esaBwrRqyIeojpad14LGjtbQtrabu6xsbaB+kYGuf5elzoDlzoaTk5SMeo6TlJOUlISTCpSUlJWVlUqVlZWGSlCVSpWVlXS0r6Onm4ZwsL/GYoZ9e3pwdXl4hYhyc61zlI5yuqDKb8edsqG4boOKfnhzfHh1c3yJkHu/13CJhXi/0ap1jJOTkpKTkpGRkpGRkIaRFY6MhZCQePeT+unz7t75mmWWrqGjioSNB4yMjIuMjIyEiwKKi4eKgomMiguJiomKiYmKiYuJiYSKh4sDjIuMhIuAiV+MWV9YaY2XpHxkpqzGsraUmuCGhq+Noaa92cmhoq+ti4KSdozBk7fPwn2jfGKulKax2tJ1fZDZs6Xvj42C7f3CtvaGzdGvlaqfl6mXhfHZ2qzGzdjG74+qloiIosuQ3rmAi4mAm6P1nZjv47TzgfjFipKqyezRyrRyu2BproOAaHV3eXx7fH5+fHPQfp+Yh5tui6KkqImLk5idqbi+vLWtwb7L4byeoKKlq62vs7q+wb/CyNTTzs3MzWdmisF5tLXJ64O8yXXReGrGitLpw/rftr3EnP77ieOYuMLSgpG/h5aZmaWbiZGlhqx7uY/Tr4Kkjt2s2M27t6G7nYaMsvxO5KmPkruCnMC4oJeQvav6x3V7idTVa2xvcnJ0dXV2d3p8f4GBgIB/gIGEgoGCg4OBgoGBgIGBgoKDhISFhoeHh4aGh4mLj5SXnZ6hpqemhKeApaSlpqanpqaoqKiqsLO2ury7vLu4tbGws7Szs7W2tre4usC9xc7IxcnBxMW+u7awrKiko6Kinp2bmJmamp6fnqCfm5manJqYk5KYlJWQjY2Fg4F9e3h2dHFwcXB3dW/a1tTQzszJycXCwL+9u7i1tLKwr6yqqKenpaSioJ+dnJyAm5qYl5WUk5GPjoyLiomHhYSDgYB/fX18e3p4d3Z2dXV0c3JxcXBvb21tbGxrampqaWpq0c/Q0tHMy8vMzM3X2c3OzMW8vLu2squnpKKjoJ6foaSkpqmrqKKbnJuXmpqlnJybmJuglYqEgn57eXd2eH6FgHx8fXx9fnx8fX+Cg4RUgXZ1dXZ2fH59fXx/gYGBiIiCfnhuZ2RjYmPJZMXBvb6+vbm4tre4trW0tbi2sq6qqqyvtre1vr6/wbexqqWlp6uqqaKenJmZnJ+bmpeUk5OSkZCQho8BjoSNg46FjYSMOYuKiYmIh4eHhoV5uNSh35Ob9rDDkYu71LeAirLg0OuC2PP4udajvaaLgbKmklduvVhj2nZQZk+Jr0hpl+5F7oPfn8+ZYElMUZO3kqO729V+hVenVn+DTa1YlaSYoppjuHK4rZCLg3TGj4WmqsV3h0ivwde4/bW28vT0xJHR+fv8/P2G/oT/BID///+GgEb/gP///5HKYHulfW1XhJCUSmZgXl9YW2FdZmhaW4xbcnBgmoaoXqeCk3uTWmxvaF5cZ2JdXWJucWajvl9wm4Cbka2d5f39hP6C/YT8hPso/Pju6tbt6rvFgflrdklSbpaGlbaHqd3q7O3v7/Du7+/t7e7t7Ozr64TqgumF6ALn5ofnEObm5ebl5uXl5uXm5uXl5uaJ5YDk5OTl5eCX2o+Yi6fV0ui5kMCvmIKScoiaQjFHSFdQTU53rrDCwsnB3ZR1qX6nqpqQ4quA2K3KzuirVIemsWNmlFVKRHaMb1twSWqLZ0BacUhUTjlma3lSZlRcWGU+V0o/OEFMLlNGLzUqLlpGWTtFYlpEaDmNZENIToKb0Offg4DlhZfwqpOnqKiqqqusrK2e+YGtkJ3Aj63Aw8WztLq8wsrT2NfU0t7d5/Lg09XX2t3f4uTp7O/w8vf///7+/v+BgK70muro+rlpjeCKzoqD9qnDhbSen5G8dG6grXemk7/svXSLfoKQqLOQfWxYbGB3gq92poVxZpWisOiSfodncy5YS1yU0u2cZlmjX37Go2h7f8+Z+eKFjqD+/4GChIeIiYuLjI6QkZOVlpaVlZaXhJgQmpqZmpuampucnJydnp+foYSiCqGjpaeqrrC0trmEvAa+vb28u7uFvIC9vr2+wsXHysvKysnGxMHAw8XExMXGx8jIysvKztHOzc3Ky8rGxMG9u7m4tbW0sq+vraysq6ysq6qpqKempqSioJ+fnJyZmJeTkZCOjYuJiIaGhYSFg4H//Pr39fTw8O3q5+Xk4t/d29nX1dLQzs3KycnGw8LBv769u7q4trWzsYCvrayqqKempKKhoJ6dnJqZmJaVk5KRkI+Pjo2MjIuKiYiHhoWEg4KCgYGA//79/fz49/X09PP39O/t6ufh4N3Z087LycfIx8bFxcbHxsfHxMK+v768vLvAvLu6t7e4sqqlpKKfnJuan6Klo6Cfn56enZuam5ucnZ2clZWUlJSWlx+XlpWVlpaWmJiUkY6Ig4KAgID/gP76+vr59/b08vDvhO437O3q6efo5+rs7Ozv8fLy7uvq6uvs7ezq6Ofm5uXl5ubm5OPi4eHh4ODg4eDh4N/g39/g4ODh4IbhPODh4ODg397e3dzc3NW573I4QjxaiEc9MixLOzpVQXFZWcdpZ1dlQFs3OThBOkZkay89djw1XS8hLRkpMwp8fn1+fX59fn19hXyEfQF+hH0dfH18e318fHx9fHx7fHx8e3x8fH18fX59fH5+fX2EfgN/fn6WfwSAf39/hoACf4CEfwp+fX1+f39/fn5+jX8BfoR/BH5+fn+Ffo5/CX5+f35+fn19fpp/An1+hn0Cfn+EfsZ/AX6Efwd+fX1+fnx8hHsEfHx9fYd8hH0Ffn5+fXyFewR8fX19hXwLe3x9fXx8fHt8fHyFewR8e3t7h3yJe4d8A318fIZ9B3x9fXx8fHuIfAl9fn9/foCAf3+LgIR+gn+pgDKBgYB/gICAf3x9fH5/fX+Af399fH18fX1+fHx7e3x8f3+AfX5+fH5+f399fX18fH19f4Z9CH99f358fHx9hHwSfn2Af359f35+f359fn+Af3+AhYH/gp2C1IHngAJ/gNp/CX59fXx9fXx8fIV9gn6EfQF+jH0Nfn5+fX5+fX5/f399fQICBABenISz+p+uw/Crodh04YSCzIv0h5Rv8M+9aaRq1tqxgbZ8T4fRk7VuaUeceHyicdywXJeqXq7ZXI7DfoWHUVhZWK+MWFhZWVhZWVhZWFlYWVhZLFksLCwtLFksLCxZLIRZRU1hf5CdqK6irLTVybmWk42Jj46FjZaxievrjvK79+C8yciEnpP4io369eDh8vmHjI+px72ig9GFfGaz0XZWV1ZVV1ZXV4ZWH1VVVVRVS5JUV6GEceqgdbu4l+idkKqOg6VWV1ZUU1OMUgFRi1KFUYZSA1NSUopTA1RTU4dUgFVUU1NIYTk1SFZWU0dLU0lnU3NskF+Sf4mVbL9lnr5ycmtsdYVpWUdReG1XaZZpTHB0TE6Jf2DThbuzeJZpYm1gZmCDmoR+YaGWcr1tb5iQh5iLdo14xnK/mZ6pw9lyuJ3Ibqm2gYzBjXyytKS03Lqncayrf4mz4seRZJlbgJWggFWLoZRjUVxeYWFdXlxdXGGEonmilLmfaWZnYmZrcn2LmarAyp2juMXeyXl7foCEhIiKjpKUmZ2eoKOjoaGgoZiQnp9TVaCDxrW+jIWHcqO1maTcjYeIdYTHcJSMi6HQt3+5icy8jriwgsBttbl8j36ihKyb8ZaGzHeCg26nnJ18gJTon8TQ5+DppXjZwbm70Kigg8JurJOEqqyoVFRWV1lbXV9gYWNiZGVmZWVmZmZlZWVkZGNkZGVnaWxvc3mDjImBhKWTgXZ0c3N3fYOOmI6HhYSFhIWEg4OGhoeIiImKjZCUoKagn56jqa6xrKSZnqShoZ+ioqaqrLza9oL47+fqgPHw49rZ0cvFuLe1trW0ra6yo6iurbasnZOMjZGQkI6MkY2Jgn+Cf3p3dHBsamVgXmRkbn3px7rA2rSpqKeko6GenpuYl5WTkZCPjIuKiYaFhIOCgoGAf358e3p5d3Z0cnBvbm1tbGlpaWdlZWRjY2NgYF9fXl5dXFtbWlpZWVhYhFeAVlZXV1eurq6wsbCusbS5v8XHxL+2raaipqyvpZyVlI+JgoKAgH+HjJeYlI2ZpJKOnKCVlKKZiol8cmxpZWFfXVxdX19hYWFiZWdpbG1vd4F8cnRsam1xeIGGhH15eHZ3dX2Ae3JlWlRRoaGgpqakpaGim5eUkJaYlJOOj5OUko8nkYyNkZiSkaCpoqKroJCGhXx2dHRzcGxpaGhoZ2dlZGNiYmBgX11dhlxJW1tbWltaWltaWltaWVpZWVhXV1ZVVFRTU1VUTs2Avo6+jryCvbKH1+Kgr2Jxw96DeGe1kNjIjX2xvL+Ng7+8t5mx0+b+z4e+8Euxm530urvN6crK/IHthmVzUrVgmHehja9/unfOuYp2zY1jpueOyoqFYsibkaKE9Lx5y+uCq/eLwfispaF6kpKT46yDkZOVlZWUlJSElQSWlkqWhUtMl0tLS5ZLl5eXkXF/koiAhYh+iIykm491cW1pb29pb3aJabm3csOhx7aVoaFre3XKcXHJxLK2xMhtcXGJn5iBbLOBkIPT/ZuPlJSTlISTipIYccV6hMyihP2hhsbJnfOjoMevlcR9j46Oh40IjIyMi4yLi4yPiwSKi4uLhYoBi4aKhIsEjIyLi4WMgI2Mi4mJdZpXUXOMjINudINum32umNCBvKClvpj/i+DmopObi4SwkXxkaY6TcYm1iW2enGprraJ+2m6h5Z7Mo6ClmpmEzdqosZHo6K/6jKPa3NG7ubK3lO2C2bGxzfvsivTB942/yLnF6rmk6tzWxuLyzIHGt4eYvvLepnS1bpmuOrxmqMK4e2Z4eXx9e3x7enl6ncaQxbnjvH2AgH6AhIuUoKy4x82wtMPO4NKgoqSoqayusrW3vL/CxciFynDLvrDCw2RkuZTq+eOolZJ8r8OvtPialZaIn+6Hsripv+PDjceh9tKn49qY4X3N3pWkj7KLu6TqoJXfhI+WgcOxrYmb7LbExuzq87eL+r6ztMudpInYfMurmszT1GtsbnBydHZ4eXt8fH1+f39/gIB/hICAf39/gIKDhYiMkJSco6KbnrKnmpKRkJGUmZ6jqqWioaCgn6Cgn56foaCioqOjpaistbi1tLO2u729u7Svs7e1tra4uLq+wMrb6Xbk39rb4N/X0c/KxsO7urm4uLaysrKrrbCusquinZqanJqamJWWk5CMi4yJhYOBfnx7dnNxc3OAeX7y2tTc6dPMy8nIxcPAwL27uLa0s7GvrqyrqaimpKOioZ+enJuZmJeVk5KQjo2MioiHhoWEgoGAf318e3t5d3d2dXR0cnJxcXBwb25tbWxsa2tqamlp0tHQ0M/Ozc3P0dTW1tPQy8S/vL7AwLiyrKqmo5+enJybn6Gnp6OepawWoJ6mqKGfp6GZl46Ff317d3Vzc3R1dIR1Xnd5en19f4SKhn+Ae3l6fICFh4eCf359fXyAgn54cGllYsLCwcPEw8LAwLy6t7W4trSyr6+wsa+trqqrrbGvrra7uLm9uK+oqqShoaGgnpyamJiYl5eWlZWUlJKSkZGFkIKPi44+jY6OjY2MjIyLiomJiYiHhm70kNCRz6nSkM7FhLC7q7aAidbkmo+F1Kb02paEtd/lZ3/n592yxPD8pmlQufZLNl1jeXRyToh6rbReopNgSDWXU8CPdG+0q8GXxKNkVsakhM64Y5ewqZHjlYhiXryVhuWfWGrwq4qfuV9IpODe5811vebu+/39/v7+hv8CgP+FgFL/gICA/4D////vqY1rbGRlZmBpaHxxaFZTUk9WVlFVWmhRj5JdoIenlnd+hlhjX6ZcXKKXi5GanldbXXGFgW1fmHWko4+2p+X8/P79//3+/f39hvwf/fmo+bnO36dZt15ZXkcqR3t8za9XurXr7e3v7/Dv74TuD+3s6+vq6+vr6enp6Ono6ITnBujn5+fm54nmBeXm5eblheaI5YDj3+C97oCCuOHh06240a/tocml/qnMVkVNQopKamA6R15QUKDUxZyPj8eYpMKgkuPLnJ7YuqnyWnPxsqNTWIRQVUJ2fGJZRHFulYRAWWtodGxfVpJ0ejxfUlJkcIVJfF1xOU5WQkNYQDVvZFFTZlZIM1piS0pbh5CLju+WybriiYDh88mdjKamqKmpqaqqp5e54ZXeuvfon6mrqquusrnCytTc4dDW4Obw69TW2Nvd3+Hk5uns7/L1+Pr7/Pz9/vHi+PqCgu60kO3nqpW5mt/ur33jd4yadHTmjK6ke7P95ptRgcjurvLgduWDlMqUuZnBdcKx7Y+OiXeScVKCXk5BVy9tsM3Js86ktHjRbmOnv2WlitWOxra28v7/gYKEhoiKi42Oj4+QkZOTk5SVlZWWloSXgJiZmpudoKKlqa2xsa+xuLSvq6qqqq2ws7W3t7e2trW1t7a2tba2t7e3uLm6vL/CxcTDw8THxsbEwL3AxMPExMbFx8jKztTYa9LRz8/S0MvIxsTCwL28vLu5t7W0tLGxsbCwrainpaWko6KgnZ2amJeWlpORkI+Ni4qIhoWFg4WDXP/z8/r99fLw7+3q6Obk4d/d29nX1dPR0M3My8jGxcPCwL++vLq4trWzsa+urKqop6ako6Ggnp2bm5mYl5WUkpGQj46OjIyLiomJh4eGhYSDgoGBgYD+/fz7+vn4hPZ/9PPx7+rn5eHg4N7Z1dHPzcrIxcTDwsLDxMPCv8LDvby+v7y7vLq1s6ymoaCem5mXl5ibmZiYmJeYmZqbm5yeoZ6bnJeWl5eYmpual5WVlJSTlJSSjoqFgoH///7+/fz7+vr59/bz8vDu7ezq6Oro6Obl5ebo6Ojr7e7u8Ozo5oboA+fm5YfkV+Pi4eHg4eDf4ODg3+Dg4N/f3+Dg4eDh4OHh4eDg4eDg39/f3t3d29vZjZI6T0SKgWs9UU9SO0Y6S2ZBRJ5VKyxNMFxQNCtfTE8sN3hfm3RYRj45Jhg3SoZ9hHwRe3x7fHx8fXx+fn59fX1+fX6FfBx9fn17fHt9fX99fX18fHt7fX18fX19fn19fn5+hH+Cfo9/AoB/hYAGf4CAgH+AhX8Dfn1+lH8Dfn5/h34Gf39/fn9/hn6If4R+A319fpR/DX5/f35+fn1+fn19fn2GfsV/gn6JfwZ+fXx8fH2FfAR7fHt7hnwXfn9/fXx9fXx7fH19fH5+fHx9e3x7fH2HfIR7B3x7e3x7fHyGewR8fHt8hnsEfHt7e5B8gnuFfAx9f3+Af31+gH9+fX+KgAF/hn4Bf6yAEIGBgH97fX1+fYCAgH9+fX2EfiN9fX59fX1+foB/fH19f35+fnx9fnx9fn9/fn1/gHx+f31/f4V8F318fH+AgH5+fX5+fX19f4B/gIB/gX+AhIHhggGDuILVgeSA4H8GfX18fHx9hHyFfQd+fn19fn5+iX2Cfod9BX5/f318AgIEAEepkY3Am4uv1LCwd321WExl+J/Yrdz3n/ailkdtooHf3sGfXJ7ba2BrgtCMc7+i0aSCsYiJdcF+d46CnHJUqJ2nb36tqF1aWYVaBllaW1otW4otSFstWlxbXV1aUoGGqo+XuN3WlYSBhIWE74KPn62+it6Qlvy7iZ/MztvKguXY8t3dyq+1qZeanPTa/oqYl4iHnWmzf09ZWVhYWIRXhViEVyBYUFdTpYiMiciWivHByIaSoYWEy5ybWVdWVFRUU1JTVJFTA1JTVIVTAVSGUwhUVFNUVFNVVIZVEVZVVVZVVlVLX0lPRExOT1dXhFiAWVdIWVlke4CHd7Kei7ayjZpyupaJvpRKSkRnn4o+S09ZVmZpVz9DsY+ydHr9pKaAV6CaXFqFX2heU5WAdXuFi35+X2x8eaK1k7m+sYCxvLe6qqC8u3NvaMCCdoGHqc7LoLe/hMiSjIq2yq+Ev16Ecqx3TmKInVBhaGZhXV1dW2GAqaiznoGMfpytUWRlZmlscHR6goqVnKOzyb3HsXx6fX+ChoiKjZKVmJqanZ+fnp2dnZ+goFFTmmh1e826araYsmN5bYxwlbu7pHmqu4iK2qyct4R9e3nchp+dcnKOtnRmyJF8i8vO5OWyp5GdjXB6qcGz0pG278C0pqGLooSYfZwNhIvMqJyRsmqsZlxdXIRYCVpbXV5eXmBhYIRiKGNlZWZmZWVjZGRlZ2lscHd/jKCosrnHwbWOgXt3fI271tSyj4CAjYSEgICBgoKDg4WSsNjk7u3e08K8wNPf2bm+076ro6KgoaOlqK6/ycjCwru/yMa5trawqq+2t7ClnJmSk5iXkpWWmJedl5qVmaCblZSVi4WBgIJ+e3VzcnFvd29nZWZwec6rn7Ddur/Br6+sqqinpKSjoqGhn5uXlJGPjoyMiYmMiYOBgB5+fn17enl3dHNxcG9ubWtqamlnZ2ZlY2NiYWBfXl6EXQZbWlpZWVmFWIRZgLS3v8XO0tLS19XZ2tbOwrOqpqOho6akm5WboJqenJWgpKOYm6unpKKnmpyjn5WXnJKEgHduaGRhX15cXFtdYmtjYWJnZ2lucXB4e3V2dHNxdH6Ii4qHf3l0c3Ftbm5taF9ZV1dUpKSlpaWjoJiTj4uChYWKiYmMlZKDjJedlpWMLYyRoaGUj5uajoF2cnBwb29tbGlnZmZlZGNkY2NjYmFgYF9fXV1dXl5dXFxbW4VcP1tcW1taWllZWFhYV1ZWVVZTcc2fgZOAea2455/CxdHpf4qus6G/ac+iop6fnLDOzrShupmgyq7SzLeRm5imlEemmInBlp672dLUiI3JbGWEvmCWdn2Jg7KCoF2HwJDPqrOxcabzenp8n/OUgOLL9te05cfFpvuinL+ut42B3cvhgKDg2ISWlYWWCpeWl5dLmEtLTEuETEVLTJhMmZmYmJmPeoVshHB0jKWjcGJlaWtqxWpzfoeQbLNxdMKRb4Gon7CPXa+svq2qmYOGfXJ2fMexzW95enByoYHdq3yFlYWUKpOUk5STlJOTk3uGdsmdkpjfmof9wtmMmq+cn+7CyYuPj46Ojo2Ojo2OjoSNBoyMjYyLi4SMgouGjISLEYyLi4uMjIuLjIyLjIyMjY2Mho0NjIx5lXB9bnR4fo2NjYSOgItuhYOSrrzHmfjGufry0cqL+s+p1btlZ16MtI9WaW5+d4KJdVdczsfNg5P/r9KGguz1korVjJGLgt/Vt77B2ryWg5KqqeDauurUzI3X+N7l3NDc0YSTiOuOjZ+ouePD2fTmneOflaHG26+KzG2aitCTYHiluGJ1f358eXp5eHvFgMTPu5S1n7/UZH1+gIKGiY2SmaGpsbW/0MnUxqCipaeqra+ytbm8v8DDxcbIx8jHysrKyWRktniUjfzegsyo1WyJf5d7o8jSsI7S1puo8sKr1JSBi4P8pNTBgIq0z3pu1qF6i9Xw5uLAspGzm4OMwNfM8ZvC7au2uamboYOdhJp8RYPCnKmn1Hq8c29xcW9wcHFydHZ3d3d5enp7e3t8fX9/gIGAf35/f4CDhYeMkZihrbK4usHAuqSbl5OYo7vJyLmmm5ujnISahJuAnZ6outHW3NzVz8bDxc3PzsHCy8O5trW1tre5ur7GysfBvru+xMO8uri1srS4ubSuqaeioaOgnaChoaChnZ+dn6GempmXko6Mi4qGhIGAf318gHp1dHR6fNvAuMbm0tfYzs3KycbFw8G/vb27urezsa+tq6qpp6anpKCenJuZmJaAlZSSkI6Ni4qIh4aEg4OBgH99fHx6eXd2dnV0c3JycXBvb25tbW1sbGxrampq1dXa3OHj4uHj4uLi3tnSycK/vLq7vLqzrbGzrq+tqK6vrqinsK6rqqykpqqmoKGjnJSRioF8end1dHJxcXJ2enZ0dHd5en6AgIWGgoKBf35/hIo5iouIg397e3l2d3Z2c21oZmZjxMPEw8LBv7u4tbOurq6vrq6vs7GprbK1sa+pqa62t7GutbWtpqGehJ0InJuZmZiXl5aElRGUlJOSkpKRkZGQkJCPkI+PjomPO46OjY6NjIyLioqJiX6W0bOap52Usc3Yn8OZnP2RoNa0qdWB6cOnpKusrdnYx7XPpaPW0ebR0YlhcJybRjIwNT9Ba02mlIhQVq6Ekse3PnJYTFV3nXOki7v0gJtxv96Sf+CNpZfD92pHb2iXkpR1UGlWhXR2m4M7TLTWufpBc/e8m/eE/Qj+//7+/v+A/4qAb/+A/////vzluXJPXlJYaXZ0UkdNUVFTn1ZeZWlqU4xYWpZyXGeHfo1qRYiLlIN+blxeWk9SX52Mp11jZ2BhsY2wybr7/P79/v/+/v79/fz9+/z8/P35wNau23dHcoBJL2lFWD1khHqAls/y4e7v8YTwGO/v7u3s7O3s6+rr6urr6ejp6Ofn6Ofn6ITnBObm5uWF5gLn5YvmgOXl5uTlw+WrwKGhtszj5OTj4uLi3K3Gt7TI279dhHNmjXtgZT13b2KQoIWfkNTfioOkrMW1oKGviIbU+dyav8qSsk48iHpJWtyo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wMG/ubW8q6GcnpSPi4iKl5+spbC6qp2tnJORk5WTkZOMg398dGtnZmVjYF9haG5+iYN/enlyc3CEb0t1d3V1dHuGho6LgHRsaGVlY2BfX11dYF5cWlenpKGakIuMjIaAf4aHhYmJiXp1eJe4pJeSjYmKg3x/gIh/eH19cG5sa2tpaGdmZWSEYwpiYmNjYWBgX2BghF9IXl1eXV1dXl5eXV1dXFxbXFpaWllZWFhXWE9qbLjYWphQiLrwhLD6j8R46e3Hbpelc+d0gr2A4qm25ZzN2YvdksaRl8uim4eYRYqZzd+VmLWDnZ2YeeqDwZhii7VfjLt0ZJPIb5Cbl/H50uSqleGVtIDDvfHv08jmsOia84XF1bjIz6L/mdKilIC6686QgIaYAZeFmFJMmExMTU1MTUxMTU1MmpmampqbnIeRiIeKyKSUpmJuYYl+xKyMsmV5v5XBenl7d36wZpWflKCjraPHbWhpbmmyt72gmK6KbIOkxIyz48mLl5aXhZYilZWVlpWVlZSVktbGtJvvgpiA233m8offjLCp2v+Vd5CQkIePhY6LjQeKioyMjYyNh4wGjYyMjY2MhI2MjgiNYFp0YolvXoWOgI+Pj4yHZ6RvcaLPxoP49szTy7C3zKupyYFuo6Vch3mvZJGPma2pVJqrxaOpiNPTgv6M3LHEho3ydYHKgOK0waWdqJ+D/JGdtsaer6aC8vyB5aWxsrbB1t3T6/yP96OYq8P12ZP0hK74kqS44nq8z4Gv07q8e7KkuHWDf3ChunV3Mn97fMbWmMvdtJqcdnp9f4KGipCYoqmvt8HCt7OtpqOkp6msr7G0t7m8vsDCxMXGx8jJhMqAZGTAsXTG3KWLzKKwypJ/pG2M14y6j8rnwpDIydbniYiyg5PCuNzUhZecq9q+vLmDgpWDf6/7y4aoqZCUlOqHu9zl0/OfwMmJdeN+3JKx3fiVj7O1fIB+goB3dHJxcHFydHZ2eHp7e3t8f4OHiIaGhYaFhISDg4WGiY2UmaSgrruAvce/pp+YlZmZnaStqqWdnqmfmpeYmZulpJ+hscfU0dDJwbO7w7SttLKzs7S8tLCxvbW3wsDAyM26s72vqrCzsbCsqaeopqusrK2urqenoZuXlpeimpeWj5CTlZWVl5iUjpCRj42Lh4WAgIB/fn15dnV37uXa1dTR0tLNy8zLycc/yMfHy9LVzsK6t7Wysa+urayrqaWhn56cm5mYlpWTkY+OjIqJiIaFg4KCgH99fHt6eHd2dnV0c3JxcXBwbm5thGxLa2trbXBxdHXq5eHd4OHg39jUz8zPz8zIxMa9t7O0rKekoqOprrOvtLmup7GnoJ+goZ+dnJeSj46Gfnx7end1dHZ7foiOiYiFhICBhX5CgYKAf3+DiYiNi4R8d3RycnBubmxramxqaGZkxcLBu7aysrKwrautrqyura6loqS0xbixramoqaejpaaqpaGko5ychZoMmZiXlpaVlJWVlJSThJIJkZGRkJGRkJCQhI+EkASPkI+PhI41jY2MjIWHcYWB1P9yxGiev8GO0cZ9z4z1/OCBo8OB4YSUxIj1srjqptW6ivOQwJekyHVndI5KJzRdajY8bXic2+OZ1oLV44621JLa3G5CYqyMtdih3uXQ3nZs5ZGzme+BcXl/bH5eZ0BiL1FQephgSl5muVNFWG3kg2C0+vv9/f2E/gX///+A/4uAfP////78+eyQcGZlapB0aHhGUEZjXZmKcYpNV45ykGBhYmBih05xemZxfod8m1VSU1dTjpOVf3ePdllriq2UiGvF0Pz8/f3+/f79/fz9/Pz9/P388/v+1YpvK05OYDJaVjVzXp2AuslBmOvt7/Dw8fDw8O/u7u3t6+zr7OuE6gfo6Onl4+foheeA5uXm5+bl5ubl5ubl5ebm5ebm5+bm5uXm5eXk45eBmJDRo5Xk5OPk5OPj493VofqipOT40nyckHh2b1todmRrg5SU7L+L07DXm+Pg6uP2gur005iXd+71V5dLfmlfS0/jnIiqO3VhbFNZZmJIiVFNY3BYZFhDcYFAaVVjWlhgXWuAZWdlOm1HR1VicVdEXDpUiGq70fOP5eqRvMnh9ZO1sMyXpaSPuuyanaahm9rus+vBd6PEnaOmqKyusre8xMnO1Nzf3NzZ1tXW2Nze4OHk5+nr7vDy9PX3+fr6/P3+/4CB9eGG4bCQacvGydakn9CDVeWMe12Q+6xfsriKsGk7tYBQPKOJiYJWd7e//8/V03uJl4N6mdfFcGxSZI6LmC2Cja3h+Z/OxZBv74G7gX3O946Cq72Dh4eJioeGhoWGhoeJioqLjI6Oj5CSlJeZmJiYmZqEmUianJ6gpKeppq20t728tLCsqqysrrG3trWwsLaysK6ur7C1tbO0vMfJx8fDwLu/wr25vbq5u7q8vLu7v729wMDBwsK5tbivrK+EsAaura6usK+EsHutq6eko6ChpaGgnZqbnJ2cmpqYlpSUk5KQjo2MiomIh4aGhIKBgf737+zs6uzs6+rp5+bl4uHg4eLh3dfU0c/OzMnJx8bFwsC9vLq4t7W0srCvraqpp6alo6Kgnp6cm5qYl5aUk5KRj46NjIuKioiHh4aEhISDgoKBgICEgYD//Pr39/f29PHu7Onp6Ofj4eDc2dbV0M3LyMjJyMrGyMnFwMa/u7m5ubi2trOvrqymoJ6enJiYl5icnaOloaGfn52em5ubmpqbm5qZmZqcm5ybl5OQjo2Mi4qIiIeGhYWDgYD9+/n28/Hw8fPw7+7t7Ovr6unn5+zx6ubk4uLj5Rvk5ebn5OTl5OLj4+Pk5ePj4+Lh4eLh4eHg4OCE3w7e3t/e4N/f3t/f3t/f34TgheE34ODg397cyNGaaDhYx4n0i3JfWD5IVS5RQ11hVUlVPShNKCs5Jks3PmRQXEErSDhBKyg4LSUwQCB9fXx8fX18fX1+fn17fX1+fn18fn59fH19fX5+fnx7e4d8A319fId7Cnx8fXx8fX18fHyFfgR9fX1+jX8CgH+LgIx/hH4Of39/fn59fX5+f39+fn6EfwJ+fYl+hX+MfgN9fX6Tf4R+EH1+fn59fn19fn1+fn59fX7BfwV+fX5+fox/B35+fn18fHyLexF9fn59f39+fH9/f358fX9+fYR7D3x8fHt8e3t7fHx8fn18fIh7AXqGewV8fHt7fIt7Anx7hnwBfYR8EH1+fn6Af35+fXx+f39+fn6EgIJ/hIAJf319fn59fX5/q4BDgYGAgH9+fH19fX9+fn+AgIB9fn58fHx+fHx8fnx9fX1/f319fHt7fH2Af4B/gIB9gIB/fX5+f358fH1/fnx9fH1+gIR/DYB+fYB/gH+AgIB/gIH/gp+C2YHjgNx/Cn59fHx+fX58fHyEfQV8fXx8fIR9CXx9fXx9fH19fIR9AXyFfQR+fn19AgIEAEiumoeD64Pao2l9S0NmdHpPU0lTdUlji23Ry7V7beeD1fvz3K26vqBmqKWBcdHSf3LPu6e1sseG44eXgILRi3l9qoOBg1xdXV6EXQdeXl5dLi8uhC8BLoUvTy4vX2BhYnTGyanwpp3BuZSChs6l9+yik6yo2cuKpr6IlYqI8MGKt6LAscrJ/JGNpJKGh/rRgPmG5Pn389iPhrF4dV5cW1tcXFtbW1xbW1qHWyBXi+LVf5j2iZqJho6E6qKhvpOXU1tZWFdWVldWVVZVVoZVAVSEVQNUVVaEVYRWBVVWVldWhFccWFhZWFlYWVlaWVlZWlpaWVpaWEpWXGJjZjs/WYRagFtbWlpbV0hMWD5GZotYiYeazLiqu7fN4ayNfWZPWVh3h1ZUSz9oQkdVb3XI/qnBq+BpiY+frFmli7CdpImEfHSdgHmc0M6MlpWXwezznK21kHuZhJmPh5uNpHF3heeRm53Wz3ueruPWeputmHR41pWlfZ+7m2u8fXJrZ19ngmmrgHxsW12lcGqZnqpXZmVrdoCGjqCmtbbC0NWthIJ/gH6AgoWHi4yQkpWXmpubm5ydnp+foaKkioCmhI/Sd7d3g8e5p5G5l7BuomytfHV3c4OG5buKeYiLd7utlJuphHarypudtYbX3I3FgIGS08d1gJ97wp/x4995nurSqpPI0OazKK2W76fW0LyPfeF3d3V0b2phXVtbW1xfZGljY2ZobXZ9e3Jwb2xqaWiEZoBobG5zfI2gp6intLy7t9DJvb2BeHt+gIODgoGFhYaapbKroY+NkJ28ubajl6GVlYyNj6y/u6ujlJCfqKuuyNfYyb+5sLawsK2wq6mop6OjqbO2qayqr7Szpaijr6Onq6WioJubkZyXlZCZlIqOgHh2f3p1eXVycHRzbm7Z1eHn4RfgzMC5sbKysK6wusrNzMfCvrKtop6amISVMJSSjoqIhIKCgYB/fnx8fHt6dnVycG9ubGtqamhmZWNjYmFgYF9eXlxcXFtaW1paW4RagFu4vL3Dz9vXzsTCw8XExMPFw8TFxcXR0cbAuLeon6GpqLGwvLOspZuWvKKWiYiIiIWFgod/d3JvbWtpa2hkZnB2h5eTh3t4c3BxcGpoZ2praW1sdHBtb2xtZ2JfY2RhXVxbWlliYl9bsaadmpeTjYmFgYB+goF+fHl2dHJygrmsI6OblIyEeXFyc3R1dHJvbWtpaWhnaGhnZmVkY2NkY2JkY2RjhGIKYWFgYWBgX19eXoVdBlxdXVxbXIRbM1pVglNUR2mQeVpCTHajeqithYHd6uKBfte/0pryl5inotyjnuC1u5mkrISop3jxgIeY9UWsk5yC7Yr0v4SlbV6Nj5FveFtzlWJ9pnyjd5d6geByvdrTuIOPnqp0urKCgvr9nJLq7MPi5PWc+IutlZ34opKTyqmPoZKKmQKaTI5NSpuam5uZoJ6EtHlyjYluYWOdhsm5gG1+eqmla4CNZXBpabyZaYl6jIKTmsZwbn5yamnEoWG/Z7PGwr2wc3vFh5+XmJiXl5aWl5eXhJYel5aWl5aNfLP75Iui+YmPhYSVkf+frumrvG6RkpGRhZCFj4iOB42OjY2Njo2GjoKNio6Fj4SQhY+AjHWHj5SWnFhijZCPj4+Qj4+QjYdvcIdcaJbPh6+sw+q3l7myytWig6iAaHl5mXJtcmdXjVpjc5SBzfmhs7D6hbWtxP6E9sfz8brFyLWt07aTrPjvqLq7tcP//srg2bubraq8raa5ssuDh5Hzmq++9d2Mwcr+74mtt6t+j/mtxaKAzvDCh++ShIB8dIKlgsaIfXF1zomCvMbMaX9/hI2Vm6Kus73AxdHVvqalpKSlp6msrrG0trm8vr/Cw8TFx8jJysrLyqmXyJmj9IjNkJvq1cefw6HDecJ0uJGKln6YnPLpro6knoLWxru58Z2BxemzrseN19mQxn98kNbSgI2nhsiAq/H47YSl7t+hjs/HuLOsjOuf08jPpYnte3x+fn16dnNycnJ0d3p9enp9f4KIjYyIh4aEg4OCgIGAgYKFhouRmaSnqKixt7q3xsO6upiSlJaZnJyam52dnqqzvLaxpaSmrr67uq6psKenoaKjtLy5sq2lpK+1t7nFysm/urWwsq2Aq6qsqqiqq6inq66vqquqrbCup6ejqKChpKGem5aWk5iUlJGTkYyMhIB+gn57fnt5eHx7d3ft6+/x7Ond1dDMzMzLycnP1tjW0s7Kwr+4tbOwrq6trKuppqKgnpybmpmXlpSTkpGPjYyKiIeFhIKCgH99fHt5eXh3dnV0c3JxcHAFb29ubW2FbF/Y29re4+fm3tfV19fV1NPS0dHP0M7T08vIw8K3sbG0tLi2vLayrqekvqqhmJeXl5STkZSNioaCgIB9fnx6e4CDjZeUjIaDgH5/fnx7ent7ent6f318fHp6dnJwcXFvbIRqLm1tamjKxL68ura0sq+srKurq6qnpaSioaGoxr24sq6ppaCdnp+eoJ6em5qamZmFmAeXl5aVlJWVhZSEkwaSkZCRkZGIkAGRhJA5j5CPj46OjoC1d3lki7WScVhnmMSFvayAieT28piZ5OXssNyDnq2b2q6h5sq1iKCvgJu5gN95Z3v5UDI1gUFkRbLmmOOokNy9r7DPiL7qorfUkYJLe4Wp0lqWrKuRYGBwt4V5QzJAxc1OO3ZnP1VTc2+ISUM4d2cyKjllh2ey5fn6+/39/f7+////h4ABgYeAR////vzegXdgfE9MYmFPRURrYJeLYUxZW39+T11gSFJQUpB2PmRQZV9qc5tWVGNYUFCYfUyXUpKkpKCSX2VeZ7b2+/z8/f3+hf0C/P2E/Bj53bHXr2owOF0zMis6U1xdTW2/asaG6u6G8Bjv7u7u7e3t7Ozs6+rq6enp6Ono5+jn5+eF5gfl5uXm5ublhuYB54XmgOXl5ubl4LnE1eTr74Cc4eTj4+Tj4+Lh3NStr9GLkL/lc35odYlwZXpxdpCGf9+Nibi6zWidsZ6E0YySrq1oo9GNjHqsU3BubnxEksC8unJrb2hhqsJdUrqlW453bnCOjWZ4d15QW1RTTk1VTEgwOD+EVVRRdWdCQFKL44Cx68aVgJXiyu2Zxvm4W+6wo6KdgFylnfunoJGI25yGnI/nhqWmqrK5vsPKztTW2uHl3dPT09XW1tnb3t/i5Obp6+7w8fL09vn5+/z9/tO++8HO/aHTlJ/Ux7q788nqiqiH1mJlc5aicbHWhFGWcHfDcph8rVpbePHDtNeY7+WTzoKEldTRMl1dWHXWnqzopFWB2OGrm6+ofq+Hd+2O2rPbqI/9goSGh4eHhoWEhoWHiYuNi4yOj5GUhZeAlpWWlpWWlpaXmpqeoKKmp6eprrK2tru8t7eppqiqrK6vrq2wsLG1ur++u7W1tri9u7u1tLe1s7Gxsre4uLWzsbK5uru8v7++ubaysLCsqaiqqKmrrKqqqqytqqyrrKyrqKakpaCgoZ+dm5mXlpiWlZOUkY+Pi4iHiIWEhYOCgYOAg4GA/v7+/fj07+vo5ubm5ePj4uTj4d7c2dXU0M7MysnHxcTCwr+9u7m4trSzsbCurKuqqKalpKKgn52cm5qZl5aVk5KRkI6NjIuKiYiHhoaEhISCgoKBgP///v7///z49PLy8vHu7uzq6ujm5ebk4N7a2NLPzs7MzMvNycbEwL4lzL+7tra0srGxr7CsqaajoaGgn56dnZ+gpKeno5+enJubm5qamYSYO5eYmZeXlZSRjo2Ni4mIh4aHh4aFhIL/+/n49fTz8vLx8O7t7Ovq6+no5+fo8Ozp5ePh3+Di4+Pj4uPiheEG4uHh4uLihOGE3wLe34beAd2E3gXf397f3oTfhuA34eDg3t64nKKxhqbJiI+CmsetTEtHNzxXZFY4Mmp1VzhOMDA4L1k9NWyWlGZPVz0+MydSKzE0UIR9C3x9fH1+fn9/fn5+hH8Dfn9+hH0FfH5+fHyEew98fHx9fn19fXx7e3x8e3uEfA59fHx8fX59fn5+fX19fox/j4CIf4h+BX19fHx8iH6Ef4p+hn8Ffn5/fn+HfgN9fX6VfwZ+fX1+fn2GfgZ9fn59fX7Af4Z+kH8Efn18fIp7FXx9fX1+f399fH5/f39+f35+fHt6eoR7AXyEewN8e3yIewF8mHsEfHx8e4V8Dn18fHx9fn5/fn9+fH5+hn0Tf4CAgH9+fn9/gIB/fn1+fn19frCAIH1/fn5+fX19f4CAf399gH98fX2Afnx7fX19fn5+fXx9hXwrfn9/f4CAfoCAgH2Af399fHx/gH98fn1+fn5/gIF+fn2Af4CAgIGAgICBgf+CnoLVgeeA2n8Lfn9/f359fX5/f36GfQp8fHx9fXx9fX18hH0SfH19fH19fXx8fXx8fXx9fn18AgIEAEqSi3TTy93Sx358mmFbWFRdXFpIV1RwQGTFmfrEtvyS3ZaDwJLv+4Sgk4r0t7+Zc2ywkZ9iq8Glh9G+oda9wtO+n4NyWl9eX19eYIRfDWBgYC9fLy8wMC8vLzCEL0hhYmJmaNP70p+Ay7ulxtfa6IKZu7LO9aCbmZXP04ukx4KRgpH/1/+Bp8rI44mP04axrd3F1OD32snvierksIhYYV9fXl5dXV6KXSNeX12UvfK9x+uB9a6OjeX3eObsgbZYXltaWVhXV1dWV1dXVoRXDlZXVlZXV1ZWVldWV1dXhliFWQdaWltaW1tah1uAXFxbW1xRNz1oSlVQTVNbXFxdXF1QbDhUR3FBXFlHPmB/fIiWkpHLqrOOoKWf0FthbGpfeF9ucGdQRE9Hg6t6j+Oei6yivZd/nLx8kIhsZX6QnIa5spq+entoaKCV2pWznKKsgp/PjIeZor22ns6FhJh+mpjFcbTedYyLmX97ldGAhI9neJCSZWa5sniWU4FrfX6knFiPi4+zoXOZe15ZbXaGi4KKj6Owram6zNrDg4GAgIGDhYiLjZGSlJaZmpubm5ydn5+ipKejrGqcgIWejMTFbKyrvn+7hqx0l6rAd4TffsSoh7J1nNnAk4KOjcN+uZmLsZRz28G54pjTn+mOwHuArIWS27bDq6rThojh/OaEoJKIyLHTmZy0zJuh1NbaaWZkZWViX15dXV5fX2JkZ2tsa3GKlpJ4c3JnZWRjZGRkaHmJeoCKppOFgJSVkaPR1Mm9jICBhoiDgomTpcnRyaGptrfDzKegm5qonJSinZycqb7Oyp6Fgqi/zMS9zsfCu7SAs6qknpaRjZKTkIaQmKqpqKyblZWYqZuRlZCRlpCfkYuTmZeSkZeXlZCHenFpz9TW1tXSyL281dLS2Nna2eHZ0MS1sa+urrCvrayrrKuoqKWioJyamJiXlpSUk5CNi4iFgoB/f319fHt7eXp3dnNzcm9vbm1raWhmZWRjY2FhYWCAX19eXl5dXV1cXFtbWrW1trW2tr7Fw7q8u77DysvBxsnJw8fT0s7JvrWrpqCfpKiopaexqJ+Zm8jBk4mQjop9enh6fHNtaW1uaGtwbW1vcn+PjIR2cG51cW1qYGNjYmJjZWRdXVxbW15gYmJgXVlZWllYYWZkX1uooJmYlJKbh30hfX16ent3dXRzc3KXtKmfm5+RfHFxeYJ7cW1rampoaGhnhmYgZGRjZWVobWtpZmVkYmNiYmFgYGBhYF9fXl9dXl1eXV6IXTJWZmeRjH6Fd5WgmVRtZ56Bnc2yiIODio7KqKf6n4HJ6sqanrSYmNOwnN+6zbTE44TQ8keEnITi2NjIx5KkyXqIcmeIi3Nge3qSVYTWcLKOhLxipnNptIKXx3iglYX7zd7Fh4G/p8+CwvPKmPLduPDK4+Pfua6Zh5qbmoWbB5qbm5qcTZuETYVOSE1NTpycnZ1vrMGhdV+ZiHiVoZ+xZnCEgZi0eXJ0eaqja32eZ3BlctOzwWZ4lpqzaGufYoWNsKCmssWoo8Jtvr67r3+amZiZl4WYAZeEmB6Xl5iYlXvD6/XN3ep/6J+Kkvv+g/jvjNBtkZKSkZKFkYSQAo+Qio8Fjo+Pj5CEjw+Oj4+Pjo6Pj5CQkJGQkZCEkYSQDY+QkH5VYaFzhnl1gI+FkIB8pFWBbKZgjohoW4vAs662qIa3koR4lI2Kwmx6jol8mnp3j45rW2dhptaPjt6OkMbE1sOpyNK9zr6NgazGrJz66K7Vn52HicmftbfUtta6r8Xcsqy4s+HPtuOTkqmOs7TkheL5gqGapIyEoOiXrHWQscCJieLokbRlm4mboc26boC2qrHcwIKoi25qgouanpifpLG6urjEz9vMpqSlpqapq66xs7W4ur2/wcLDxMTGx8nLzM3Ey3y0k5q5mt7aes+94IbEjsN9q7HNipX+j+C5mL6YuP/7vIudq/Gc3LydwaCD/+W54qnmoNmPxY60np7vxdOvquiOj97r13eTlZjOuoDWkpy2yKKu5ejsdnV1dnd2dXR0c3V1dnh7fH+AgISTmZqLiIh/fn59fX1+gY2XjpGWpZePjZqcmaTCxsC6oJeYnJ6bm6Cos8fJwquvt7nBx7Swq6mwqaavrKuqsrzCvaSVkqu7w8C8xsLAu7e1r6qnoJyYm5yalJugqaampp+dnoCfpp6ZnJeXmZWblJKVlpSQj5KRj42IgHl05+fo5+bk3dbW5OPk6Ofo5+zn39bNysnHx8jHxsXExMPAvru5t7SysbCvrqyrqqilo6Cdm5mYmJaVk5OSkY+OjIuJiIaFg4KBgH58e3p5eHh3dnV0c3JycXBwb25ubWxs2NfX1tXV2Ujd29TW0tPV19fR0tXTz9DV1NHOx8G6trGws7SysLK2sKqmpsO8oJmcm5iOjIqLjIWBfoCAfH2Afn5/gYmSkIqBfn2Bf3x6dXaEdQd2dnNzcXBwhHFJcG1ramppam1vbWpnxr+7ure2u7CqqqmpqKiko6KhoaCzwry2s7auop2coKahnZqZmZiYl5eXlpaXlpeXlpaVlJWWmJaWlZSTk4aSC5GRkpGRkI+QkJCRh5A1j5CPfoSLycOlrp3G1tBuhIPJlrHrvo5+oKCw77KY95R52PXCfYWsrrfVkXfdteCzxMlYm+JTNX6MmIxlYoGSseCf5qeO3/CtmNDS4YG56lKCXVGNRoVVT6tuZJlvklw4dnjY8l1Xh1NRMklhekRVUzhIN0dBO17CvML0+fr7/Pz8/f7+/v//gP+MgET///77hIGKck47Y15TZnFwg1FWXVtqgVhWWGCIckpZdE9WTklsUnc+VW5ziExPb0NdaIJ4f4udh4qlWqKjb8y59/n6+4T8BP39/P2E/Df7+vfvquetilJcZzVUOTI2i4xBYo5Tw4Dj7e/w8fDw7/Du7u7t7e3s6+vq6urp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zcy2rKumsbezpqOnnZmVk5OEkoCTkI+LiYaDgX9/fn18e3p4d3Z0c3Jwb3BwbmxraWhnZWRjY2NiYWBgYF9fXl5dXV1cW1q0tLKytLW4vMLMvrTBwrzBwsjMysXG0dTOz8K4srGkoZ+gn56doaKdpNXMup2MmJuQhH97dXFxbGdkY2FlaWppa25xeH53b29ucm9wc2RlZF5dW2FjX15aWVlZWllZWFpcXV1dX2RmamdiXKyjn6GknouCfnx7eXh2dXV0dnh2iYt/fIyHe3BvbmpramlnaGhoZ2ZmZ2ZmZ2VmZ2hoaGdpaW1raGVlZGNjYmJhYWFgX2BghV+EXgJfXoZfMl2JmKJqpnh1b7eqmZlqrKqur2tqrrqMknp6lc/Jt42JkoTohLnf9rt+ZtfwxeHg2vGORW2BZoJ5yXugy7izn2LKho2NcGWJjGBZnXLZt47Fg6aDhoV/lZGtj6LG8O6O77SGisyuv+WymdHwmsfkr6uD3p7Z3siHm4WcAZ2GnAdOnU5OTp2dhk5HnZ2enp6kdcVta3OPeWl8ubKLnJ1/qXpea4Spb2hlo5enm5Zno3eUZ3KIo3S4vaqss6CLj4hveW6FeHqolp+ttomHmpqamZqJmYWYFZFzwN7A9rLVgPLo6If5moCRhKLDhYaTBZKSkpGShZECkJGGkIKPiJAHj5CPj5CRkIiRAZKHkQuQkI5kbpldXYSJjYeQgGxiiHp8f4KAkpGJbqD3v5izvqbEZ3WLr5DQgKiXmM6IdmWAcXlvm5+5mIOzpqG++M+lhsqmzLiViJ+TkH6nyZD6lJCbj+e3wIHLwNTt2ceyvMOusaCYxMe64u/ni46ssq/I0K/No5TKdp3I6tDN76PT3Iqn+JrSgKuArpnKqWNtgMpzecyeu5K0d4mJjI2PkZifqK+qs7nK1sOkpaanqautsLKztbe5vL2/wcLExcXHyczHj46FtsOttZe0oNiwg7+Ke5nD0oitvpDYjMuEy6Pej7uDlJnN1L6A74zvy4CZd8a0tbP0saOq6H3QvpKyzI2g6KrYm5z03Xuaqcjw6OC+gKSa1M2s1qHR3d3f397fb3BxcXJyc3V3eXyAg4aBfoCFio6YlpKMiIWDgoGCjZmZl52aipChn6GiqriwssTEtqytr6Wjq7S0ta2spqWiq66xtrCnnpucn6CioqKjpKeYkZWSkqOsubCvsrCynZmelZOSkI+MkJCQlJ6lpJ6YmJ+hA5+gnYSSgI+OlpSMjZORkY2Ni4qEenfo5eHv6d/c39zX29jg29HN1Nvm5+fj3trSz9fXx8PBvsXHw7u5urSxrqusq6qqqqmnpaOgnpuZmJeWlZSSkY+OjIuKiYeGhYSDgYB+fXx7enl4eHd2dXRzcnJxcG9vbm1tbNfW1dTU1NbY29/Wz9bUT9HS0tPU08/P1NTR0cnCvb20sbCwrayrra2pr8zEuqSZoqOak46Lh4SDf3t5eHd5e3x7fX2AhIiCfX18f31+f3d2c3Jxc3RycXBvb29ubm6GbShsb29wbmtoyMK/v7+8s66rqqinpqajo6Kio6KsrKelrKmjnZubmZmZhpeFlgGVhZYJl5aWl5iWlZWUhJOFkgmRkZKSkZGQkJCGkTeSkpGRkYq7uciHzZGTiOHWx8mH1r/G1YSCyNyesoGDnebdppF/cWbDiKW5n5yJfuzmtsLBmqFiWS1QQ19IgFFnmJZjl5X92u3tqpjn8JeG6oqRfcPwkMWWhGKwqnWbZIKihHKN8debkYxaVmdaN2llMDk7NjQpS0HE6+vE9fb4+fr8/Pz+/v///4D/gICA//+BhYBF///+/PvCWZdPSE9oWEReiYtocXFZe1pEUGB8VU5Ke2+Fbm9Ney4vPVFkdFaMkYaKjn5qbmdXYFtoYGaMfohtpL679fr7hPxC/fz8/Pv8/Pz7+/jx4aHSaUZmTWVQdlRfVGcwPjpfidfF7e7u8PDv7+/u7e3s7Ozr6uvp6uno6Ojn6Ojn5+fm5ublhuYE5ebm5YbmhuWA5OTj4t6Zls6Cj83X3OLj4uDh4eCmjcq/w77Ix+He0aXRtHVqe6hpb0Zah8CapWB4fsj9mKOYuoeqrOfR27SUmoqSm+2rb1B7ZHdrYFppXllYZYd/11Ryh3+xjIlQiHd/jH5sVlVWUFBERllWVGNydERCSktDRk5IUEp46Iuy59mAt7HThHqaT4LHoe59uYeHfr3EgZD1gYrakqaX2JSrrbCytbe8wsjMytDT3Obe0tLT1NfZ2tve3+Di5OXn6Ovt7/H09ff59K2uocS8uqudx63ztoSyqZSo1tyi0sN22GK8d55ftXBjPlBmeJdkYaBq4oVJr4zPk4rB0oBdeP9+nntta2aScXGnYnVpcZdKeox6se3F2M2yqebfv+m26vj6/P3+/4CAgYKCg4SFh4iKjI2PjY2PkZWYnJybmZeWlZSUlZqfnZycmJGVn6ChoqeurK22t7SysrSwr7S2ubewrquqqq+ztri2sayqqqytr4SugKyjn6GdnqmutK6srK2tpKOno6CfnpyZm5ubnKCjoZ+enJ+gn5+dmZmZmJaVl5SSk5SSkI6NjIuIg4H++/j9+fTx8+/t7evv7Ofm6evv7+/s6ufi4ePh2tnZ1tnY1tPQz8vKxsXDw8HCv7+9vLq4trSzsbCvrKuqqaimpKOhoJ+egJybmpmXlpWTk5GQj46NjIuKiYiHhoWEg4OBgYD//fv6+vn3+Pb38/Dw8Ovs6urp5+Xj5eXh4NzZ1NLOzMrJyMbExMTBxNHMxru1t7izr62qp6SjoJ2cm5qbnJubnJudnp+cmZmZmpmZmZaVk5OTkpGRkpGRkI+Pjo2NjIuKiomIKIeHh4WDgf75+Pf29PPw7+7s7evq6uno5uXl5+fm5OTl4+Dg39/e3t2E3gXd3t7d3oTdC9/f397e3dzd3N3chN0K3N3d3Nzd3d7e3YbePN/f4ODg3+Df397P4ltZUEpEXVNuYvjxPTxPdLlUaG86LS8lKTtUYkEyPEBAjW+x0GSclKTrlWljX2NfMgV+fn59fYZ8A31/fol/BX5+fX1+hn0Efn17e4V8BX18fX19hHuCfIh9BXx9fX1+jn8HgH+AgIB/f4aAhX8Mfn19fn18fH1+fX1+hH+Gfgx/f358fHx9fn9+fX2Efo9/AX6EfQF+l38BfoV9Bn59fX1+fYZ+vn8Dfn1+jH8Ffn5/f36GfwF9h3uFfBJ7fHx8fXx9fn9+fX5/fn18fHyHewF8iXsJfHt7fHt7fHx8l3uKfAV9fn9+foV9BXx8fX18hX4OfX19foCAfn5+fX19fn+tgAR+fX59hH4RfX59gIB+fn6AgH5+fn1+fX2GfCx9fHx8fnx9fXx9gIF+fX1/fXx9fX99fn5+fHx+fX18fH5+fX2AgH59fn5/gI6B/4KKguKB6oDZfw1+fX1+fX5+fn19fn5+hH2Cfo59CXx9fn59fX1+fYR8A319fgICBABU0oX+o7G7woybpa7djsl3TnpNSVleT0pWk3S1U3mvZY+/2tGEk+CMvKmqjauihId+zImQl7uCf9ybz6OEjY7ErWl3co9fXWBjY2JjZGNjYmNjY2RihjFRMjFjY2NlZWdqxrXR+a6Jp769m7Sb27Stx9754saH2Ni38bOo/d3JjN/Ti6mxsNi/t6uuqZydpqq0pZ6cpKa3leu3z7aggVhjYmFgYWFgYF5gh18zYWNakoOocM6SgIbyvn6CpMvIgqGpYWBeXVtbW1pbWlpbWltbWltaW1tbWlpZWVpaWltahFsBWoRbBF1cXFyEXQJeX4RegF9fYGBVPklYO2eFXHZ8TUxaT1NJPztWXl5aWFduYjlMT0M/SX1+j2+DmHbokduI0ry8l4XaT01PV4V3gn5RU3FyZXBXfs/SvIuNhXt+gfbHh6ath7CAcrqbt2+yc32hoM+3k5iVkKyeqIuInpXUweLMgtnsf5Z2h8awhO+3xYdogIDajp9yo3K4lGW6u6eUd4aAacjAZ015gaCAybODf3d7fHh2d3p/goWLi5Gcsbi9j4SFhYWHiImLjI6QkpOSl5iZmpmbnZ+iqJ1qZY2Xf2/OdHyPwbOIq5yComq3jGebsHmGio/ZlWXGk4V3i8rpoq5/sG6eksGatZ58s5yxh5yMLtPJgqyYmLPS3t2LlLWMiuLLsam5kaikg3q4wKK8u4ystra2tbWzsrGxWlxlY2WFZIBjZGVoam50d3p+fnt+f39/gX56e3p8gpCcn6u4sZuRjpeTjoqJio2Ni4uJhYF/gH+BiaKts52UjpGSmJ+4pJOTkIt8eoB6d36Fl6y8rq2RfHGEgnmAe3d3dnh8iYmMlZKIgoaCe3t7dXZ3dnd3e3NtbnZ4dHJubWloa8/IxcTFyoDDt7e5tb7IwtPU1dnZ2tXOycDBvLa0sb6yt7/Az7u/u8K7sqGUkY2MjI2PkI+MiYeGhIOCgYB/fXx7eXd1c3Fwb25ubWxramloaGdmZWRjY2JiYWBgX15dXVtbW7W1s7KxsbGysrW6urKusLrMys/HxcnMz9vNzMS5sqigm5udnICbnJuzr67MxqWZiIOChYJ/enZvbnRuYGBgYl5hYmNnaW52dG9ua2lpaGZlY1xcXmNlZGFhX2BhYWBhY2FjY2ZkaW5rbGtoY16ztLG0r5uNiZqCeXd2dXV0dXh2dHV1c3Nxb25samlnZmZmZWZmZ2ZnZmVnZ2ZmZ2hoaWpoZ2dmZQplZGRjZGNjYmJihGEDYGFghV8BYIdhM2JhYVBmbbTZw32Ll5K7uYaBoK+qooqHkaGBxorYwseRnY3k89P8zelydnWQzp6BoeWAnkhgRYhbU4KZfJ6inNR7yo9tomRde45wYHa7gNBujZ14p9vs1Iix9oOtjamNrKuNqJrgmb3F25CN+pXamYqZouSrg5KMvI2Hk5mGnQaenZ2enp6IT0ufn56en5+euYqjv4JnfZGNc4NynIaDk6i2oYxgn6WNtoV9vKqca6uucoOEgaabkIiKhnt7g4iPf3p6gH+RdLqQqb+0oH2bm5uampuGmiCZmpmampmZgKyeroDaj4mC+8GEf53g2oij05KUlJWUlIaThJIIkZGSkpGRkZKFkQGSjJEFkpKRkpOKkoCAXG6EWKHJhrG8c3CGdHpqW1aAi4yFhYWfk1RxdmNca7Onu5m5vpa9ZcF+tprKtmfjbWVqbamOgYNgaZiMhJdwocvJ17+4pKmnnO6wjoR+ZsJ9heOt1IrHm522k8fxycPGvNC0tKCnubbJyvHMhOX+hKCAjNvHiufO3pl2jvSksICIyYngtYH+6tO0mq6mg+71gGKRpsqh8teYjoCJjY2NjpOYm5+jo6ixvsbLrqanqKqrrK6vsbO1t7m1u77AwcPExsfJzLx7c6K3mIX/jJmm582WsKeKr3PEm3CwvomWlJ3+sYL2q5yUoun+u+GY0oG3u9WszreGyMjLjp+PztGHvR6Qi67e6fWLmr6NierDl6vNj6ixh4LC07bS1aPM2tuF3Qbc3m9xd3eEeGl5eHl6e35/g4iKjI+Qj5GTkpKSj4yKiIiMlJ6gpq2uop2cpKOhn56foqGgn5+alpWVlZadrbW5rKagoaKmqritpKOhnJGOk42LkZiirrStqZeJgo+SjJCMiYqIioyTlJabmJKPkI6KioqFhjqFh4J9fYKCf357eXZ2d+ji3t3d3tnRz8/N0dTQ2drc3t3f3djX0dHOysjGzMXIy8vSxsjFyMK9s6uphKWApqakop+dnJuZmJeWlZOSkI+Ni4mIhoWEg4OBgH9+fXx7enp4d3Z2dXRzcnFwb25ubWzX19bV09LR0dHS1dTNy8vP1tbW09DR0tPZ0M/Kwby3sq2trausq6u5tLPHwaqil5OSlJGPi4eCgYSAdnZ2d3R1dnd5en6CgH18enh4eHcIdnVxcHFzc3OEcQFyhHEfcHBvcXBxc3FycG9saMzKyMjFurOwuKynpqWjo6Kio4SiC6Cgnp2bmpmXl5eWhZUBloeVDJSVlpeXlpWVlJWUlIWTApKThJIDkZKShpGJkjKRjWuBiuLPx5Whtbjm0JaZmMbKsKSaqa6JzJfewK2VnJHjpI+YgcGEkISl0n1bfapWcVAgJUsvH046NT5GQn47bqWo8pOEwOywjabXUpOlwrCCnvHy5qbf9mWVYF9Oe2Fiv6O5YmxiWDo3UjM7NCw+TFVNfV84rcCwzN/0+vr7/P3+/oT/iIBN/////v799LNnfYpdSFtqZllkWHFjYml9g3JjQnFzZYRfXJCFdU19gFJiYVx8fHNsbWxlZGpub2FeXmZkd2Gge4xbVZao+Pr6/fz8/P2H/DX7+fTuvZqVTFZlY145bV06Ky9jWUJd9OTr7e7u7+7t7ezs6+vr6uno6ejp6Ojn6Ojn5+bn54bmAeWF5gPl5uaE5YDk5eTl5OPj48WKqMyDzOyM6/SgrdKzvaGIgcbY2c/Oze/YgK6zloug6LDTyvizmqFOn2emcJ+4SPyNjoKE98iYpoWHwq2qt5jnv6CVh31ubmljqWxjU1NFiD9QtGyddF+Bcmlba414cG5lalZXRUlVVV91hGBGcGw6TzlDVWxNb4Bjx6mClN12gX3HecOua8z41a6Eqp5nvdqjgrOmsJXnxJagmaiusLGzuLvAw8XGyM7W2+DV0tPV1dbY2tvd3d7g4drh5ujq7O/x8/b345OLvLWKiddneX/g5Kiiy6rUiuutgaZ8h4enpYldRYxFRlBpaWRFoGTaioSW7bjXcEB+noB7U26Yz7+OpHmPrnWD0mSaj42E5X9GhqSKpbOVjtPnyujtu+f2+Pv8/f3+/v6AgYWFhYeGh4eIiImLjY+RlJWXmZqanJycnZual5WQkJOXnqChpammpKSqq6yrq6yurq2urKilpKSkpaqytriyr6yqrK6vtbCtraynoJ6gnJugpICorKyqqJ2Wk5mem5yZmJiVl5eZmpydm5mYl5aVlpWSk5KSkpCRjoqKjIuKiIaEgoKC//v49vX08Ovp5+Xm5ePk5efo6Ojm5eTi4d/c29jZ1tbW19nS09DRzcvGwsC/vby8u7q6uLe1s7KwsK2sq6qopqSkoqGfnZybmpmXl5WUk2iSkZCOjYyMioqJiIeGhYSCgYCA//78+/n59/X19fTy7+3t7Ozq6ubj5OTj5uHe2tbTzsvLyMjHxMTDyMXEzMi+ubKvra6tq6qmoqGinpmamJiXl5eYmJmbnJuZmJeWlZSUlJOSkZCRkIWPhI4fjYyLioqJiYiHhoWEgoD8+/r6+PTw7u/q6uro6Ofm5YXkD+Pi4uDg397d3Nzb3Nvb3IrbEdzc3N3d3dzc3N3c3N3d3N3dhNwJ3d3e3d3e3d3dhN44397f39/e3dWNPztMSEsyOztOZDomJTiGcHtmNzQxLzcpQDs9KDVUqGNcUlGrusOkqZZfOFSCLyGCfoZ9hHwFfX1+f36Hfwd+fn1/fn1+hH0Ffn17e3uGfIJ9hXsDfH18hH0EfHx8fYR+kH+IgId/AX6Lf4l+DH19fn5/f35+fn9+fYV+kX8Gfn5+fX1+lX8Sfn59fn1+fn59fX5+fn19fn5+vn8GfXx8fX1+jX+CfoZ/IX18fH19e3x7fHt8fHx7e3x8fX59fX5+fX1+fXx8fX1+fol7AXqEewt8e3x8e3t7fHt8fJN7A3x7e4d8EHt8fX5+fXx8fH19fXx9fXyHfQx8fH+Af318fX19fn+tgAR/fX1+hHwEfX5+fYSAEX9/gH59f36Af3x8fHt8fHx9hXwHfn58fX9/foR9G3x9foB8foB+fIB/fHx9fX9+gH9/fn19foCAgJKB/4KFguKB7IDaf4J+lH0BfId9AXyEfQF8hH4HfX1+fXx+fgICBACArdipwNy+uYn76OPZ3Yuznry7nGtQUE+M24N0SV6Xr7fMv8KHgI7IuGzEx4GMkpq0o4x+gLOgk6vngOSFhaeHq8l9gppbmKK9YWRiZmVkZWVkZWZkMmUzMmYyMjJkZWdnaWp49Ona+5OSko6GkKS10cLMh6iXmeSIjpjvqO+LkJdOhfDx6uzJuLqw9o2EkIOI/vnr8YaJmabBta+Zm5C1icNmZmVkY2NjYmFiYmJhYWBhYGBjYVpdyreB2qibj6a0uY6fgcibj2JkYmBgX15dhFyEXQxeXV1eXV1dXF1dXVyHXYBcXV1dXl1dXl5fYF5fYF9fYFpeXmFhXjxDQGJ8VYx0X2xVX3dVVohRmklRXllAXVVNdVVVdWdDbVZ1RVh1Xmj7oo50opTrbJV5XHtpcEJUg3/QeX9NbWdKvKnImpSLqs9zjtvX8eebmJDM73ePnnCkpLyfpYNzg2Kjh52LgG11poC0ldyQlIu6kt6WrdiAmHzFfHdrqK69i6aIaHyyp45dgbm/hXFwpbtPi4R2mL3PenOlsmyLh4aBenh3d3qDjJGfkoyHhoeFhoWGiYuGiI6ClYKKeJmWnJyenqKmmGxvZZF3hsSajXaA0bmoa6m2wWzE18jGooC/yLR/hqjBaaGatzSM2LlripyVqKd3nd+bydPNmNqXlet1f42m7cmLn8SBl9rTlK22sbTij4R0l5azs7O0qIy1hLYEtba3uIVdKlxbWltbXV5hZmZpaW1xc3N0cnFycnJ0cGtpbXN7fICJlIWBiYqNjImEg4SEgIODem9yeXh9gpObk46Sk62iopuVjomIjpGCfHt8founuLKYorK0no6FhYeMpKCTfqSil4aWhXR1ent1cnV2d3NzcXBwbWloZWRlZmZlYr+8vcC/u7q5uLWysLCwsre8x8LBxs/MzsvLwL+5saukpKOioaGoqaClsaadmZCQjoyKgImKi4yNkZGSk5CRlJORj46LhX96d3VycW9vbmxra2poaGhnZmVlY2NjYmFgX19eXl1dXr28ure2t7a1srKwr6+usMHN0srFv8PS2NHBvb2tpqmgmJaWlpSVmqahqcrGoI6HhIKBfHl3dG5sbm9iW11fWVhaXF1fZXB0cW1pZGBdLlxbWFlaXF9hYGBgYWFmaW1xd3VzcnBvb29ubGtvcGbAvbaup52Zk5SIeXd2dXWFcy1vcXBvbm5tamloZ2ZmZWRjZWVlZmdoaGdnZmZmZ2doaGhmZmVlZWRkZWVlZGSEYwFhhGKGYYNihGMyZWRfdsWZhI99k4awjIqfjn+toaiLrK7Wz6uXfIaY9J63iZOF+YTpZ4TD/dPp9Inw54iAWMHIx6+/mYriuZy52Ii6i4WYmXJsbWaq+puOYXCIwdHpzNeCboHQ3n7LxX2GkbfCq5mLms21pbTvgfeHkruStOaPnLB6wdDtiZiQm56enp+fn56fUKBPT6BQUFCfoKChoKGQzL2sxXNxdnJpbX2Km46ZX3htb6dianGsdrFjZHArZbavsbGYhIqJxG5lb2VpwsC4vmlqe4GUiIV4enadkeyZnJybm5ucm5ubmoWbIJqbmo57fe/Ag/+or4qNvtONpX7SraGBlpWVlZaVlJSUi5MDkpKTh5IBkYmSipOAkomPjpKTjllgYZK5hNikkaaDiqZ5fcJy12h1ioJdi31wqn59qpRgl3ikYHiihIG4faSPrnLlg76NeKeCmVlvrpKqc5NkjoVj8JfPv8im3fiAdoqNraFtiqDJ6YOVpYC8vcisvK6XpoLKm7OffYKQp8mizYmal8Kb8piv7Iuqi9eAg4F0u8Tcor+kfJjbxbN3oeTuoYuK2+dksJyTvuv7hYO+xnWXmJqYl5iXmJugqKy3r6uoqKipqaurra+nqq+euJmoksC6wsTFxsfJtnx+dKyIpPq3pJCh99GsdrrD0HPO8OHfq4zZ5M2PpODwjMKz4KT53YmlzbPQ1pW+9azr7vBbo+uhlvCCiYaf8dyOsMuHmdfflqfVusDlk4l6oKbLztHUyKjZ293c3d3f4OFxcXJxcnFxcHByc3V3e3x+f4KFh4iIiIeHhoaHg399gIWMjpCVnZWTmZufnp2amYSagJmYjIKFjYyRlqOppKCioq6pqaeknp2cn5+WkY+QkJipsq+gpKysnpSOkZOWoJ+XjJ6dlo2WjIKCiIqGg4WGhoSDgYCBfnp5d3Z2d3Z1ct/c3d7c2NbV1NDNysnIycvN0tDO0tjW19XUz87LxsK9vLu5uLe8vLW3v7exr6enpqSigKGioaGio6KioZ+goaCenJqZlZGOjImHhoWEgoGAf359fHt7eXl3dnZ1dHRzcnBwb29ubtzZ2dfV1dTS0c/OzszKy9PX2tXSztHW2dPJxcS7trewq6mpqKenqbCsscPAp5uVk5OQjYqIhYB/gIB2cXN0b29wcXFzdn6Afnt4dXNyCHFwb29vcHFyhW8zc3R1d3l5d3d1dHN0c3FwcnJt0tDLxcG6t7S0r6elpKOioqKhoaGcnp6enZ2bmpmXlpaWh5QBlYaUhJUElpaVlYiUhJOGkgOTkpGFkoSTNJKTkpKBkv28iZWDqqnQoKS5oYe5na+NvLLp6LqngpOu9ZzNeV1yvmHhcJG23bfNr12wuGaAKZ/2cVRzRoO/dES/z0tmbWGDo4+knZGHi5mojodzgE1mUrh+VlqL+5mrfUZYctqndmFXUVBCRUNVMVgtPmo/OEMsYZCGs8Kupd7A5vz9/f7+////gP+AgP+AgID///79/PvAppKCl1dVW1ZOUV9qcWluRFNNTndDTE9zWX1ISlYnTIF8f4d1XGNomFJJUEpPkZKQk05PYGNyaGhjZWV5OdTs9/n6+/v7hvyE+xn59NiunrhVRLGGrkQyXH4sNChrZ2Sm6Onrh+yA6+rq6unn5+jm5+fn5ufn5ubl5ebl5uXm5uXl5ubl5ebl5ebl5eTl5OPU3dzj4tuDgYPT9aG1fnKJZK70rK/+hf2SsdTIjNXAoP3AvvvWkN+s7pCd3b2JjGiiss9O2JDfma/hjNeFj8i+mYO5lbF+hvKHlIqdjeKtWVNWWmpiQ0GAZG1xSUpJLl1bZ1xZZVdwZHtWZ1JAQkdUa3eLU3x1eVO6YmuYaYhy06GejdrYvYCco4Ge8tOxgKHisYiam6X/hue5fKjN0ZiNruWLtbe6vb6+wMHDxszQ1tPS0dLT1NbW2NnZzs/Vvt6xyK7k3uns7vDy9N2ZmYGlmJTbxq9qa/eA7pyL2uz4ifXboZRMd7VxTktSdJdXdkivY3FsX6GrhbTKf4JmUHd5fV+xmp7laXFzq/dqUnyTaJLmzYyptqS81IqThK+55Ons7uHA9ff6+/z9/f7/gICBgIGAgIGCg4SFh4qLjY6PkpOUlZWUlZSTk5CNjI6Sl5mZnKGfnqGjp6eAqKemp6inqKelmpKWnZyfpKuvraurqq2rrayrqqinqaiin52enqCnq6qkpKaknZmWmpucn56blpual5OWko6Ok5SSkJGRkZCPjo6OjImIhoWFhYSDgf35+fr38/Hw7ern5eTi4eDg4N7d3+Hh4ODf3d3b2dbT0tHOzcvNzcnKy8iAxcO/vb28ubi4t7a2tbSzs7GwsK2sq6mopqSioJ+dnJqZmJeWlJOSkI+Pjo2Mi4qJiYeGhYSEgoKBgP79+/r49vb08/Lw7+3s7Ovr6+jl4uTl5OHc2NfSz87Lx8TEw8LBwsTAwsvIu7Swr66tqqinpKCfn52YlpaVk5OSkpKTlZkQmpiXlpOTkpGQkZGPjo6NjISLNoyMjY6NjYyLiomIiIiGhYWEgf/9+vf08O7t7evp6Ofn5ubl5OTj3+Hi4eHf4N/d3dzb29ra2oTZAdiH2QTa29vdhdwJ29vb3Nzc3dzbhdwE3dzc3IXdA9ze3YTeMt3btGdQMzQ1Lzs/WkQ+PykwTV1NPkRKTEgyfiUrM1NXzFo3XYBG45K6nYttdnM8iG4rCHx8fXt8fX19hHwRfX18fH19fX5/f39+fX5+f36HfQx8fHt8fXt7fHx8fXyFe4R8D318fXx8fX19fn5+f35+fox/CIB/gIB/gICAh3+Efop/gn6EfQZ+fn59fn6Ef4l+hX+Efop/A359fZZ/BH19fn2Efgh9fX5+fn19frt/En5+fn19e3t8fHx9fn5+fX18foZ/KH5+f39+fn9+fn5/fX1+fHt8fH18fHt8fHx+fXx9f318fXx9fX99fH6Hewx6e3t7fHt7fHx8e3uEfIh7AXyJewZ8e3x8fHuHfAp9fX9/f359fHx8hn0Mfn19fH1+fnx9gH9+hH0Ef39+f6yAGH99fn19fn58fH1+fYB/gICBgH59fX1+fYR8L3t7fHx8fX18fH1+fXx9fn18fH19fHx9fX99fn99fIB/fH19fn6AgH5/fX1+f3+Ak4H/goKC5YHsgNp/AX6FfYN8i32DfIR9C3x9fX1+fXx9fH59hHwFfX58fH0CAgQAT7TBoGuM16aTlft7Z4eodITnrcncidx5gcJ5fpmw4ZyPhpaXge7Z4ZJkb1aQxNrIeoHMjImDjrTvfbmjmsB1yHnhn4HedpF3aVlkrGZmZmeFaIBnaGhnZ2hoZ2ZoaWpubuKDjYyemIiS5cvzgYCFjpqVq6aZ2L3H4u61xdOOxenLxdHQtLWrp83X7IPA79nk8u/2xvaek6DN48jQz4TUcWloZ2dmZWRkZGNkY2RiYmNiYoxVVcSfeMiGkqfyp8zPg+6Oip5mZmViYGFgX15eXl1fXwFghF8QXl9fX2BeXl9fXl5eX19eX4ReA19gX4VggGFgYV5OT05GVlxXWn15fE+BdHuRkZxxdX+CXVKikERibl1iXGBbYGVmWllZWFl5iUWWnZWVp1eltoGulKeMV8GDhq9rWIaWh1lmc2GSqIuKf4WaYsrbj7TAj8OQk4Wfj57bkXmEfoCNjopswI+SpJ6IrISto9vSaauvwnW/hbjkN5yMdJ5htGSqYqRyrG2qpcC/Z4Zsa7WwwIZ9d22nkXZ6fG2Kz7yAfomNfnh1dHR0eHx/g4WFg4SEhnSHhomLf6VmiXqqd2STZ5afn3uep3tylKK9eHCWin7KkbSQiJJ2Zm9wioPO3HOFl9mugWqIwK9osIpkkHV+f3ekh3BsgL/JgL2ny8K147KuhciE1pnPzo3UuK3wlp1tgs6PndzKuKe7tLCws625v8HAvbu5t4S0QrW0s7CwsltgZHF3cnN2dXZ6enZybmpmZWNhYGNla3Bvb3F5d3p/goOGhYKChISCgIF/d3Z4enl5e4CDgoB/gIaQjISAXoKCgH56en+KpJaRk5enj4R+e3p4eXuAmaynop6Ed3l3bmt0bm5sa2xsbWtqamtraWdmZWNhZGPDwry5t7i7u7Wwr66trKuqpqWmpaSjoaWjoaChoaKioqGgn52cm5mEmC+Xk5KQj42Mi4qJiYmNm6WnpqKgnJuYl5KLgYB9e3l3dHJxb25tbGtqaWhmZmZkY4RigmGEYIBiZWvNwLy5ube4uLi0srK0t7nE0MrDwsDS39G/vbqzra6fmZKOjoyNj5iqqbe0o5mVjYmBeXFrZ2RjY2BaWltZVlRUVlhZXmRmamtpYFtZWVlYV1laXFtbXWRjZGNkZmpvcXFycm9ramlpam9uZcK5saeimJONjZGAe3p3dHRzcw5+eHJxcG9ubm1ra2ppZ4RmB2VlZmdoZ2eHZgdnaGlpaGhohGYIZWZmZWVkZGSGYwRiYmNihGM2ZWRlZmZoWuTLioOHeKfDcuGMh5O2qvapuICVwredlemYjYpqr6/bpXCpY5iFtd3bs7msjI/VTXaKr4SO16ukqaSCeKPFjZHAcM+pffuSldSSlL/V/KSPloiql+/t9al/kmyctNXllZjujoqClcLNisu2meeB3IDGt6X9i7aGgH6D2pOfhqCGoVSioaGioqKhm5a/aXRyfXdpb6qZuWJiZWxzc4N+daKIjp+qdH6HZIOgjYaPmIiDf4KhorNikbKlq7i2vZvFeXN8orWgq6ZtxZuenZydnJ2dnJycnZ2FnB2PtnNz7KyS2oKRu/K439iV/aOnvYyXlpOSlpaUlYSUCJWTlJSTko+UipMFkpOTk5KHk4CUlJOUk5STj3V4dmuBiIGHxL3Le7qpwNnhwJuapq9zaNa8XYeYgomFi4OOlZWDgH99gKu1YMaqiXGddr68jbF5k4px3aO03oV4srBwYX6JgL3BeJOmrdOB7/Jvdn1bnaOomZheofK0qqiTjZykoobwraq0pY21lLe47qxyvrzbhDfUl9P8rp9/r23CbbVmr4zAhcK75fGBrYeD2NvyrqKRgsislZyhhJfq2JCJk56XlpWVlpianaGjhKaAqKiqqqurra6bwnqdk8yMd7B6tsLElcDHkoSmtOSUibOrmPm1z6KbpIludnaRmPH9i52o98SbgKPk5YXErXWfjpmejMmvjI6i6OyW1tTSwLTiu8GIxYzinem8ls/HrvaKsYKZ5oek6tvLtdLQz9LVz9zg4+Pi4d/f3d3e3t/e3tw+3N5xdXiBhYOEh4eIi4yJhoOAfHt4dnZ4en+EhIOGjIuNkpaXmZmXl5mYl5WWk4yKi42Mjo+Vl5aUlJOYn52ElCuVlpSSjo6RmKWfnp6gpZmSjoqJiYqNjpqjoJyXiYGBgXt5gH+AfX19fn99hHyAenh3dnNydHPl4dzY1tfY1tHNzMrIxsXDwL+/vry7ur28ubm6u7y8vLq5uLa0srCvr6+uraqop6ako6GhoJ+foKesq6qnpqSjoKCcmZOSj46MioiGhYOCgYB+fXx7e3l4d3Z1dXR0c3JycXBwcHJ15Nza19XU1NTT0M7Nzs/Q1ds81tHQztje08nFw765urCrpqOioaChqLGxt7Wqop6alpCKhIB9end3dXFxcW9sa2tsbW5ydXd6enh0cXBwhW4FbW1sbXGEcDRxc3V3d3d2dHJxcHBwcnFt083Iwb23s7CwsqqnpqSioqGhpqKdnp+dnZybmpmYl5eWlZSUhJOKlIKVhJYFlZWVlJWGlISTAZKFkweSkpKTk5OUhZMwevDAl6GmjLXmjO+XopTCt/yZmHuhubicleiIi4l6voWukYe+cLqhwdPZn42ccm2wUic9lUQtd5rC44OnmNXikkuFOWB3UapdNFSBmNr0fEExKzyak4hkbousw42kerH0ppbPYVxSUFlKL0g+TshPYjRaW5jRdqthU6KKzMz7+/z9/f2E/lT//v7+//7+/v366NyfU1xZYlxSVYFzi0xMTVFYV2FdWHdYWWNtU1plQWB1X1dgb2dhXGJ3cHpEYnlzeIeDjHKXXVlhgZaEj4lXrOT2+Pn5+vv8+/yG+zv6+dbOl5zYeZqARnmwaVmOUm9lqsSryubo4uTq6+zr7Ovq6ejk6Ofl5N3l5ebl5ubn5ubl5eXm5eXm5oblgObl5ubl5OTds56fjsTQxbWwub6I2YuFkI6InrzL2I+C89GFvNa/z8vSyNjg38bAwby9+fiD7p52WJ2ZwrePqGCDl4zTrOfniKnM0l+AspVrkZpdiLyYwFiYmVJWVzldQk1dbyhLa05MUE5OWV1pdLVxVmdjUWJYaIChYoLPteZWgFdzytHWuJ/Jg/eD44HSlduP6+r9+XqsgHSYy/+WiJef8cRqamFiqP/ToqKtu7u8vr/AwsPFyczNzs/Q0dPT1dXW19e+34uireGPhc2I2ejqsejwsZ3Mpe6YYX6mbKqQ3q2GvJWBiomlm+nbaGpGYjw5K0uLgUdPmoBPWlhJWqV5L1hRaZ2vYX+nd5DC67W8haBZg0GzTInSqoLGb51lgcqHofzw08jm6Ovs8Oj2+fz8h/sp/f7+/v3+/4GEhouNjY+QkZKTlJOSkI6Mi4mGhoiKjpGRkpOYmJqeoKGEo4ClpKOjo6CZl5iampyeoqOjoqCgpKemoaGioaKjoaCcm52ho6OjoqOhnpuXlZSUl5iYmpybmZSOioqKh4WLjI2Li4yMjIuKiYmKiIaFhYKBgoH//fn18vPz7+vo5+Xj4d7c2tjX19bU0tTU0tHS0dHS0dDOzcvJyMfFxcTEwsC/vX28urm4trW1s7O1tbSysK+urKqqqKako6Ggn52ampiXlpaTkpGQj46NjIuKiYiHh4aFhIOCgYGAgP77+Pb29fPz8PDu7ezr6urr6OXj4uXl4NrW1dLOzsnFw8G+vr29v8LBxcK6t7Sxrqumop+dm5mZl5STk5KQjo6Oj4+RlISVE5OTkpGQj4+OjYyKioqLiYmKiYqEiy+KiomHhoWEhIWEgf/7+PTx7uzq6urp6Obm5OTj4+Lh3uHg4ODf397d3Nzb2tnY2ITXBNbX2NeE2ATZ2dnahtsB2obbAdqH20Dc3Nzb3Nzb3Nzc3d3d3NvboG1TPEVKK0F6RFxIOkBOQXQ+Rzl6UkxBU1ctL1iS2U5serLmhP+9iGdkTT42OixRBH19fHyEfRZ+fX5+fn19fHx9fHx9fX5+fX5+fn18hn0Ne3x8fX5+fnx7e3x9fIZ7Anx9hHwHfXx9fH1+fYR+A39/fpd/AX6Hf4N+iX+WfgF/iX4Kf39/fn1+fn5/fpN/Cn5/f319fn1+fn6EfQV+fX5+frR/DH5+fn9/f358fHx9fIV7C3x9fX1+fnx8f35+jX8ofn1+fHt7fHx9e3t8e3t7fH17e3x7fH58fHx+fnx7enp7fHx7e3t6eoV7hHwCfXyJewF8iXsQfHt7fn18fX18fX18fn5/foR/AYCGfoZ9AXyEfQx+f35+fX19fn9+fn+agAZ/gH+Af3+KgBl/f319fnx8fXx7fH5+fX9/gYGBgH9+fX59hnwMe3t8fH5/fH19fHx9hnwLfXx9fH2AfX5/fnyFfQt/f359fn19fn5+gYSAmYH3gueB64Daf4Z9Cnx7fHx9fX18fHyEfYV8DX19fX59fXx9fn19fn6EfAV+fn19fAICBABL/rnydeXMgsN2k+J8XWOybK/WkIGTv6jmoaPNzszj/NXImby1e9it33deeG+NV5qkxb+EkYXkdu2pe/WHhZmssX9/eMt1wZ2adnpdhGkFamlqa2uGanNrampsbGtpq7Xdx/WWk5H81OiQnJWWiYDpgfH/5oOE/eDRgZDRiJycuJu4qrmrtPuE/JCSoYf68fD27+SRrJPkornXi42wrJx3a2poZ2hnZmVmZWVkZGRlZlJrXVDk0teKh3p0q/J6e8yenZiXZ2abWWNhhGCAX2FhX2JiXlBYW2BfXl9hYWBhYGBgX2BgYF9hYGFhYWJiYmFiYmFjWFKQfHFpTVCOYIaFnHJdn2pucKi3YldbY1uDh4ZzY3ZpY2NnYF1YZGJramVqU2piRWSgdW6CW8ibkPS6zLCHz7NSgF5/uuuZqafDurjLtsrbeZrH5oGJ94mAr4Zw6bB/j3bQqPnbhJSNyX6dq4C6gdiAnYijjamyhbl813iBj5e0ZaRljrrEnIVtcnF7dn99n6B0jNt5iHJ8q4RtpWd2oqeO0quBbIF5e3h3d3p7fX+AgoGCgoWEhoeHiIqFaZ51rs1+kMl+jnKVoLN/nIZieXm30nusdKiNl5NVb5GGwXlxl2qogYqTvLTHyKrIe/GQcoOobXybrn7eb9C6iYuMe9V8gZTab8J4d8b1d6Lh8bifju7lgfx42ISlxuOxitjG8ubWy8zMycK+uLa1s7GxsYWwKLZfZW5wbG1ub3FydHRzcnBubWpoZGBeX2Fmamtra3BwcHR3eXl6e3uFfYB8eXd2dXV0dXd7fXt6eXl6fX58e3x8fH17eXd3eHp6gX17fHt4eXVxcHBwdXeQk418eXd5dnl5dXtwZGlnZmdoaWdmZ2hoZmRjYsK/wsPCwsG8uMPZ0LzKtrCsqainpaOgnp2al5WWlpSVlpiZm5ydnZ2cnZuamZmZlZKTkY6MiiyKkJaXj4+TmJ2Zko2Jg4CAgHx6ent5eHd1c3Jwb21samppaGdmZmVlZWRjY4RigGNmaGrNwb69urq4tra0sbGztba5vsLLw7vG29jLwL+2rLConJeRjYqKio2Pj5WXkpOPhoeAdWxlYl9dXFlYV1ZUU1NSU1RVW11dXF9hXFpZWVhZWFtaWllZW1tcYGRmZWVnZ29taWdlY2JjZWNkY8C2rKagmZKPi4uEf397eHZ2GXN6dnNxcG9vb25tbW5samppaWhnZmVmZ2eJaAdpaWlqamppiGgGZ2ZmZ2ZmhWU8ZGVkZGRlZmZnaGhgrfTOiY6Sh9aPuJzSvnXUt/OsjpeAmbi4rrbpmrrDf4TMaJyAj2h2kZO+wZaO85DhTa1qsYfivXnChnXchmx0143R/quNlreu9Km88vXu9Orl2JvS24XhwO6Pb5iMqWqzvMzMgZCF9IDMwoP3iI+kta+GkYrfldm2xJyFgKCghqGFokyjoqKjo5qblHyfkLGawHVycMeruG53dHJsYrNju8WyZmm7mpBUW4laYWFzXXt5gn+LwmW8bWt5Zr6ysry/r3KFb619k6dyeJSOoZ2dhJ48nZ2dnp6cnZ2dm5ZvmH1o4uLXhHiAgcT5gorryLqztZKVw3mVlpaWlZWWlZWKlZOEbHuAjZCMkZOUlJOThJSDk4WUgJWUlZSUlZWVg3vUtamdcnbWktXY4rCQ85Kpqd/6d2Zpc3KipaSUf5yTiYuQiIZ9j42YmI6Vc5CDXGyDj5GzedOdibFt4tmv5cRrr3qmzOFseJDf4dGszeX/isb0zmRUuIC5moH0so2qofDM+vOKn7z3jKi1kcd06ZOueaCdrsKOgMuH2YaUqa/JbrZwn9nappN8gn+JjJ2exdKOpvWYs4ii1aGH14WSq8aq+caVfpeVlpaXmJudn6Cio6SlpqeoqaqrrK2ifbuQzvmWo+qQqIm0wNWYtptyiZHZ/5fRkNeptbZ/o433hnukc8aPpKrey+LexOOG8KqJm9OEj7LOlPSJZPzrr6qhkvuOk5fmgdeEi9Logqe65aqpjf7zfeuI8YyxzvytiuXG7uzl4ePl5OHg3Nvb2tnY2drZ2trb4HN4fYB+f4CCgoSFhYaFg4OBf315dXN0dnp+fn+Ag4SEh4uOjo+Qj5GFkoCOi4qJiYmKi4+RkI6NjY6QkY+Pj5CQkI6Ni4qLjIyRkI6OjYqKh4ODgoOIiZaVkYaDgoKBgYF+gXx3enl4eHp6eXh4eXl4dXRz4+Di4+Hg3tnW3OXf09nOycbDwcC+vLm4t7WysLGwr6+wsrO0tba1tLSzsK+vrq2rqKinpKKhoHGjpaSgoKGjpaKfm5iUk5KSj42NjIuKiYeFhIOBgH9+fXx7enl4d3Z2dXR0c3JycXJzdHTk3drY19XT0tHQzs3Nzc7P0dLV0M3S3NnPx8S/uLq0rKmkoZ6dnp+goKSkoJ+blZSQh397eHZ0cnBvbW1raoRpTmpucHFxcnNxcXBvbm1tbWxra2tsa2tucHBwcXBydXNxcG5sbGxtbGxr0szFwL23srGwr6ypp6WjoqOhpKGgn56enZycm5qamZiXlpWUlIWTipQFlZWWlpaFlQeUlJWVlZSUhpMBlIeTNpSUlJOUhN72sZisqJvlnuW62s6D3cL3pIl6ZJetnZib2YzM2odioHusloGBg5Kd1oh3fq5Zo1RJLmFCTDVSlKl1xmqGj9KMp7A1QUw+LT4vQ3ZaqqxuVlV05fNNaEekwI7byuSRw+DPwGlxYY9HbFk2dUJOSVRVUEw/oIyGbpSfT6b3+fv7/Pz8/fyH/YD8/Obo2p6dZYRzlVlXV5iGkVRaV1VUS4pOlp6JUFKPaGIpPFs7RT9IOVVSWV5mlEqITU1VSIJ+fImLflVlU4RjdIdhYVR2ueT09/j6+fv7+/r6+/r6+fHiluKyh6OGcl4/QEh2kUx5etqwlqnW4deh5+nr6uvq6ejn1Obiw4+vtwTX3dfghOUB5IblBebl5OXkhOWA5uXk5OPHqsqpnL+coM50kY2stneuX3F4sM6Wh4mUibjV1cm04NjMztbMybvV0eHh09ys0LqGinesmcyTyoFxhkbS1sfFnoblrdze2VplbaPHvILRzKt6x8eNRzJhQ0g1SYpZTl5QhGyVjlxmp8JWXnpthkSAYGg1d56Z6VNnVK2Ak6G5xO2G3YeZxPLNuJmfoa+mqYy5wImFxIyhc5PesGJuRFFw06nfz66burq8vb7BwsXGycvLzM7P0NLT1NXW1siWsH6JoWSF6oyEhtXm9LPeuYSkmcTYW29Ohkirt4mSdMqZjr6BzpiMdFhQVFpMV1GtTFBGgmhCTF1Do0mdrpJ5ak5KoIFtdZdqw2V4ssxcYzF4PpaT1ZlGrnbFjJqT9LOM68vu8PDx8/X29/f29vf29vb39/j5+fr9gIOGiIeIiouMjo+QkJCPj42Mi4iFg4OGiYyNjY6RkpKUmJqbm5ycnp+en56em5mYmJeXmJqdnp2cm5ucnZ6cnISdgJybmZiYmZiZmpmal5aWlJGQj5GUlZiWk42LiouKiYmGh4eHiIeHh4iIh4WGhoaFg4KB//z9/vz69/Pw8fLu6enk4uDd2tjX1NPR0M/Ny8vMysrLysvLysrJx8bFxMLBwcC+vLu6ube1tLW0s7Gwr6+vrayqp6Wko6KhoJ6enJybdZmYlpWUk5KRj46NjIuKiYiHh4aFhIODgoGAgID9+vf19PLy8O/t7Orq6ejp5+fm5OLj5OLc2NXSzs3KxcLAvby7ubq5uLq5trWyr66ppJ6cmZiWlZORkY+OjY2MjIyNjo+RkZKRkZKRkI+NjYyKiYiIiIeHiISJPYiIiYiHhoWEg4OCgYCA/fn18u/t6+nq6Ojm5uTk4+Lh4N/g4N/f3t3d3dzb2tvZ2NfW1tXV1dTV1dbW19aF1wXZ2dra24baAdmF2gHZhNqF2wHahNs13Nvb2rnlZ1I3QDwwY2h1UVNlRG9PXzprTURyWl9lVlhKt/2qSHeYyptne1xaQltBMSlOJlgSfHt7fHx9fX1+fn1+fn58fXx8i32EfIN9hHyEfgR9fnx8hXsGent7e3x7hXyEfQZ+fX19fn6Xf4V+Bn9/f35+foZ/B35/fn5+f3+FfgF9i34Cf36Ef4Z+Cn9/f35+fnx9fn6Xf4N9hH4FfX1+fn2EfgN/f36vfw5+fHx8fX5+fHx7e3t8fIZ7CX5/f39+fX5+fpB/CX5+f318fXx8fYR7HX17e3x7e319fn17e3x8e3p7e3t8e3p7e3p6e3t7hHyFe4R6A3t7fIR7BHx7fHuEfAd9fH58fH18hX4Gf35/fX1+hn8Ifn18fHx9fXyFfQt+fXx9fX1+fn1+f5mAFH5+fX1+fn5/fn+AgH+AgH9/f359hHwIe3x9fn99fX2EgAR+f359hnwCfXuEfAF9hHwDe3x7hnwLfn18fH58fX59fH6EfQ9/gH19fnx+fX9+fn+BgYCXgfaC6oHrgNl/AX6GfQp8fHt8fHx9fHx8hX2FfAp9fX1+fXx+fX18hH0HfH1+fn1+fAICBACApdeb6u3/n4ClXrKqgodxvrKDreCgxYnq1eiqeHGd4cHRgXVvlpKEaIiIUlRGi42UhHl/t6mJ0fmt84j7m6h/habqhJGmnNO2bnRlampsbGtsbGxtbG1tbG1sbWxubm5v2snMju2E4oXx59GAj66vwM2E+P2J583mw4b61rLZ5/4s/oaYndeRpqa25qe/oLmauamtiqqprJ6my8vdqsX7mtSEq6GahG5ramlqaGiEZzVpVn1QYpWWiu70jYPjhYLYo3t2rKiYl6VWfZdcZGNiYWJgYWRgZWNYllNYX1dWX2NiYmFhYoZhgGJiY2JjY2RkY2RkZWVlUFqBoIphVGaafpSGanF9cnuiY3J+Y2hSepBPcHZrYGxpY1toaWdZaWpqamtsZ21vZZrkfpumfIhKe/nge55xi6aTaGighHiQ3Kjan5CEkbGuXWB6seKp3MqSo6hye6qTfHqCf6aUlaKQ4n5/1uG/p9vTgIm7oOWVw6mvjNaSp4G6qW2BoKBnhmWmW5RwaajFtXqXcsWllX6FmX1rqniCc7aCbWh8fHl7e3p8fX5/f3+BgoKDg4WGiImLjmO7pIiUn6Sb09yBjsm/fI20jXt3bZyqdWS2o25wcp6PjnbY1J27mMZ/xoGVvYu2lpajp4Ztsrqseoy1sHKXiJlveInAg5TErr6Hxoi5mIOOlIuYzH+beNrH23/cqYOfdNrHxsjk4NnVxL68u7u5t7e2t7a3t7e6xGpvcXN1dndzcG9ub29vbWtqaWlqZ2NiY2Voa2tram1vbm9xdHV2dnZ3d3Z2d3h4dXNycXJydXd5e3l6hHeAenl4eXp7fHx7enl5eXh3eXp3eXR0dHBvbm5xeHVycW5tbGtpZ2hoam1og351bG93a2dlZWVnZ2dkysbBwsXGxcXK39nMxdPTy7Osraqmo6Kdm5uZl5WTlJaUlJSVlpaXmJmZmZqZmJiXlpaUkZKTkJKcoJiXj46TjIaGgX16eXhrd3h4e3p6d3Z0c3JxcHBubmxramloaGdnZmVlZGNiYmLGx8bFw8S+vLy6u7u6tba7vbq/w7+6t7KxwNfOycK7sq6mp56VkY2LiYiFhYOChIGAfHl3dnBpZGBdXFpZWVdWU1RTVFVVVFZYWViEWTlaWVhZXWBfYWVnamZlYmBeXVxdY2RmZ2RkZGVpZMLDvbitp6CXkIqEgn98enh3dXRyc3NycXJxcG+EcAtvbm1sbGpqaWpsbIhqGWlqamppamttbnFta4CDfm1sbW5saWhnaGiEZjtnZ2ZmZmdoaWprVnbAjJNwfXNzfni6maaHpcSBg6WHt5KooHKJ5pXWh+LS6710tLrNsa7LhMTWkLSjl057hma75fakjbxyiZuanYnw3JrC+ayWht7g96KIhJDy2c5+ioaZkp98nqJob1qvr7ijjYzZsIbY9b/xd/aProaUvf2MocK//tiAmJahoqGFogOkpKOFpE+imZWOksilpm+5ZKpluLKkZG2JjpmnaMDIarefupJnupmEj5nAnVdob6Nlb3OIt4WZeoJ8koOKboeFiX6Bnpushp/QgKxjgoGKlZ+en5+ehJ8enp6ZbZZmgra5hPX2j3bfjofHtJ+T0tOxm9B2n6mBhJYPlY6OlIiUjne4bHWHeXiKhpSAlZSVlZSUlJaVlpWVlZaWlZaWlZN0gbnO3YuEndTC6cWXsbmQo8iBmqB6fWSfsmKHkomBl5eOg5aYlYCYmJiZmZiQmJmIgpeByNmdsWOivsKeuYicwcuKiNC5mKCRh+fGiGGM3tR/eoSAfmvh36PQzpaUnI6KioOk0L6vs5n0joqA2siyva7AjMmq95/dqr2d9a7Jl9XFgJvCuHOTbbpoqoqByvHdl66L8Ma0mqi7n4jMjZqO25l8epOVlJeZmpudnp+hoqOjpaanqKmrrK6tdd/CpLG2w7Hy+ZKk8d+Po8+hjYx8tMKQgv7djY2Ms5qZif32ss6y65XnmqfUo9axq6mAu6aD29vIpsjAisKewY2SqOGhpey5wYfIjsOfhpmak5Del6yMxbfchuKtgKWA3r3Eyufo5ubf3dvc3dzb29vc3N3e3uDoeX1+gIGChIKBgYCBgYKAf35+fX17d3Z3eHt+fn1+gYKCg4WIiouLi4yMi4uMjYyJh4eGh4eJjI2OjY0NjIuKi42NjIyNjo+PjoSMUoqJi42JioWFhYOBgICDiYeDgn9+fXx6eXh4eXp4iIWAe3x/end2dnZ3d3V05+Tg4OTj4ODh6eLZ197c1srGxMG+vLq2tbSysa6trq6ura6ur6+EsICvrq2srKupqqelpaWjo6eppKKfnaCbmJeTkI6NjIuLi4yLi4iIhoWEg4KBf399fHt6eXh4d3Z1dXNycnFx4uLg4N7d2dbX1dTU0s/P0dHP0tPRzsvIyM/Z0c3Iw7u4srOsp6Ohnp2bmZiWlZWTkY2LiYiDfXp3dXJxb29tbGpqaQppamlqa2xtbW5uhG9CbW1vcG5vcXJzcXBvb21sbGxubm9vbm1tbW5r1dTQzcbBvLayr62rqaalpKOioaGgn5+en52dnJybm5qZmZiYl5WVhJSCk4mUEZWVlZaXmJmXlqCgn5eWlpeVi5Q5k5SUk5STlJR0lvGjqIeZhIuSkea9xJWqt3B/t42qkb63eofrmtJtrqHS0X7Gq9uvn9aCpbpqdV9kgFFIHTl0dmJXtYdLU5Skl/zJQT2I2EAsTUdENCgqTXaAZFBqbExTpJnf4pyrgvHH6cOCYsiYYZGhbH5Mn1xEQVqGekVTpJ7YrVew3vj5+vr7+/z7+/v8/Pz7+/v239bGzcCBflKKSnxLiIiATVRpbneDUpebU5R9lGxJfUpCXGyAY3M9QlB6RE9TY3xndVZKWW5ialRpaGpgY3t4f2eDrm1+Rl9og73y9vf3+Pn5+vn6+eeJlIG0wMJOd4+CUFdEJ2+Sw5Tr65BH/aycZ63m6Onp6Nzc4snh1aPCkqLKtLXS4uTk5IXlAeSF5QHkhOWA5OTj4+Lcq7PHppV5nYmtjJaOcXV6ZGyhcpjJqKuHua6Euc3Bu9/h0sXf4N7B4eLi4+Li1N7fx4psgr/qmNmI0YymzqiCeKXvw7/U0qG4d3DLsm1KeerSiYlsXUo9cmdUi4VPUVxQaWVUpai+lnd4vHVpeW2Au2iKWrJtpk6RbouAtvp+no3p3nNsfqyMvI7ygM+Uir7x8ay3i76RiZukhlhFdlNqfbGejpW2ubq8vsDBxMXHyMrKzM3Oz9HS09TV0439x4qoaXWeiptzfbPvoMPvuKWaj8WnY0mLfUlzc7Stk47+5cHmpI5YejxPaERMPFWXY2lesHmXN01UWnNop3ZRa2eBb1rAg5KN1Ym5SX2CpIM40Xe4dWJVdFvHt4KmdNy+x8/q7e7x7/Hy8vPz8/T09vb29/n6/YGDhIWHiImJiYqKi4yMi4uLiomKh4SDhIWIhIoLjY6OkJKUlpeXmJiEmQSamZeVhJQvlpmampqZmJeXmJiZmZmam5uamZiXlpeVk5aXlZWRkZGPjo2Nj5OSj46MiomIhoaEhQmEioqIhoaHhoSEg4CCgYD+/fr6+vn29fLz7eno6eXk39zZ1tXS0M7OzMvJyMbIyMbGxsXFxcTEwsLCwL6+vLy6ubi2trW0srOysK6sq6yqqKakoqKfn56dnJycmpmYl5WVk5KRkI6NjIyKiYiHhoaFhIOCgoCA//79+/j39PLw8O7u7Ozp6ejo5ubl4yzi4N/g4t3a19PPzMjGw7++u7q3trWzsrGwr62qqKWkoJyamJaUk5GRj42NjIaLE4yMjY2Oj4+Pjo2MjIyKioqLi4mEiCGHh4aGhoWFhIODgoKB//37+fXy7uvp6unn5uTj4+Li4eCE3xbd3d7d3Nva2dnZ2NbW1dXU09PS09PThNQK1dXW1tfX2NjZ2oTZCNzb2djZ2NnYh9k82trZ2trZ2tnZ2NeXdXQ5QjldXWp4h8NOXUZOYj9OknN2Pzxfj4njaqVUgXik+YGLZoFqWWdDR1IkNzU/Cnx7fX18fHx9fX6FfQt8fH19fH59fXx8fIR9FHx8fH19fXx8fX5+fn9/f359fX18hHsGenp7e3x7hXwJe3x9fX18fH1+ln8Nfn5+f35/fn9+fn5/f4R+BH9+fn+Ffod9iX4Ef39/fop/CH5+fX59fH1+kn8Lfn9/fn5+fX1+fn2LfgN/fn6NfwF+oX8Hfnx7e3x9fIp7CHx8fX9/f318l38UfHx8e3t7fH59e3t9e3x7e3x+fnuFfA17e3t8fHt7fHx7e3t8jHsCfHuEfAh7fHx7e3x9e4l8Hn59fX1+fn59fHx9f3+Af39+fX18fH1+fX18fHx9fYR8Bn19fn1+f5mAKH5+fX59fX59fX5+fX5/gH9/f35/fn18fHt7fH19fn99f359f39+fH2LfAR9fXx9hnyEfR58fX19fH2Afn5+fX9+gH59fn5/fn19fX59gIGAgICXgfiC54HsgNt/AX6JfYZ8hH0cfH19fX59fH19fXt7fH19fHt7e3x8fH19fn5+fQICBABP0duDgtTv5d2Bnd+5zXtuaYGetuNsiY3KwcXUtompnda2q5Gmy9BvU1lVVkxSonJmjny6m2LNqKS00rrHvax5hrKwost3goardl9rbG1tbYZuA21vboRvgHBwdOHi9quH1tmAhvLgqaC8y8Dlzu3z3NqpyaSttoDjmYyYipOpwMGTl5mowbvJ7uWeuIPi78qDifeFiPi9j7r5ieDgoLSs+v2FdHNubGpramppaVuEyp6Yeojl0vHrtHuS846qlJVVo4rgkopOz5ZmZGNjYFxYYFhgT5SYVl5jFFteYGRkYmRjY2NiY2NjYmNjZGRkhGWAZmZnZ2hgQFdvenmKelp9mnp0rl+Pj6O7YohtbmRbXoJUTFxpWGZlY1hjamdbampqa2xtb29nYonR0XaxwGFoTMKXUNCbg2KLZqe4a4Fo5Z3ssXalu+vNdIixj5yaa3J6d8npzsWYqphhm2W4usHMoZualpaswpexuv/Ww/TVdcyAvqx8oK1mycB2ZFabiVpmZqxwfptyaXJ3vXOItG6YgZdxbZyve3dceHZ3eHl6e3t8fX5/f4CBgoOFhoeKjI59eJx4w4CPpn/d0HuUvpjKsL1jn6iTeLWgpZmxwGtz27zskba5rLSvjXV5mYm1dKqYh3qTa56ulH+nm4B7t9Rre4lcpM+sknJ+5n3Yo47Ngu133+DKbZDIzYWeusGlvoar5Iezx7+6uri3tre4ubq4t7q+wMLAv8PJaWtxc3Nvbm1sa2pqaWtraWhoZ2ZlZGRmaW1ucWxsb25vcHJzc3OFdIB1d3h2c3JxcXJzdnh5fHx+fn+AhIeGi4yMjX9+fHx7enp6eHl8fX6GlJaTiXmMlJ6Ye3ZxbWppZmhpaGpraGxue3iJhHqJgHNqdn+EfvLzgejZy8bBw8G/u7i4ury3srO7p6KioJ+cnJqYlZOTlJSSkpOUlZWXl5iXlpWUkpGQkUSSkpCPkpWTkZGJh4WEhIF+fXt4eHh2dnZ0dHV0c3NzcnFwcG9vbWxramlpaGdmZWNiYsTEw8TDw8C/u7i3tbS0sbCvsIWvba6srLDIztTKxLiysKOcmJaRjIqHhYOCgIKAfHl2c3BtamhlZWJgXl1bW1lWV1VWVFRTU1NUVVVVVlhYXV9dXWBla21sbGhkYF5cWVlaXVpcX2JkY2FgXbi5ubayrKOZkIqIhIaDgnx4dnV0dHSEcodxK3BwcG9vb3BxcnBtbGtqampra2pqbG1yb25xeICCfZ+oo4R5fYJ5bWpqammEaAFphGg2aWlqYWNsm8mMc47NrdJ8ol5/2oqxprnJxpTajZrli5iSk9fR3P32t3h/jsiYjb+3zbXjp6yJUbSiSE3C5urshrL2o8yNg4Kbu8jgd5aGsrbM2cSVra7zsZyPs937i215Z3FkacSIhbWcyrqBz7K41tfD0dHBg3+strLjmKSnzZmLo6Kjo6Sjo4SkhqVxop6Ri9G5xohnpaZiZbuxhH2Vp5m0o7jAr6mEmX2GiWKfeWpqaGJ7i4lpZmt+k4GRs7Bug2CluZhnbbpnZ8GXbZDCd6Wgd4mBzM14ip6goKCfoKCfn32b8seqiJHnzfP0rYSt+ZSusL1syZLzq7hm7cqElhiQg3R3a4FpwMJtgY5+hYmRlZGVlZWWlZWFloCXl5aWl5eXlpaXl5eKWnygpKXFtH+x15+R8Yimp9bniLqOkYN7fK5wZX6Reo+QjH2OmJaCmJmZmZqZmpmMgFac7onR73yCX86SY9CxmH21h97+hqWA1Hzz34iGn8n8j5CAT2SnhIWQiPj42NaKipV9tX/Iy9HmsK2moIaCj5u7yoDu4c7o3Ynw1s6Wxc979eWKc2O3n2t6ftqNm8CIfIyL5Ieo0oO2krSLgLvNi4drkJGTlZeZmpucnp+goqOjpaanqKqsra6VjrWJ55OlzpL9646r3bLnxtpwsbuhiNTJ3NTi+4iM+s/3rdvoz9PGo4SNsJ/aj8Kwn4OrgLvQsZi3rTGNjt36hZWXt/LGm4WW74HgqJTLgPd96fPjgKnCt4qpnayvt4+285O+1dXU19bW1tfZhNsO3eDi5OPj5ep4en1/f36EfRt8fHt+fnx8e3p5d3Z3eXt+f4F+f4KBgYOFhoeGiFmKioyKh4aGhIaHiYyMjo+QkJCRkpSVmJmZmZCQjo6Mi4yLiYqOjY6Rl5iWkIeSlZyZiIWBfXt6d3h5d3l5d3p7g4GJhYCIg3x4fYKDf/f3f+3o4+Dd3dnW0oTPIcvIxsi9urm4trSzsbCuq6usrKurrKysra2urayrqqimpoSkQ6Oho6Oin5+amZeWlpORj46Mi4uIiYiHhoeFhYWEgoKBgH9+fXx7enl4d3Z1dHNycuLi4eDf3tzb19TS0dDPzcvLy8mEyEHGxcXH0dTWzcnCvruxramnpaCdm5qYlpSUko+MiYeEgn99e3p5d3Z0cnBubWtramlpaGhpaWlqa2xtbnBwb29vcoR1N3Jwbm1sa2pqa2pqa2xtbGtqaNDOzcvHxL63s7Ctq6uppqKioqGhn5+enp6dnZycnJuampqZmZiElwaWlZSUk5OHlBKWmJeWmJufoJ+usrCgm52em5aElYuUNJKDhZHI9JKCtPvN95K8d5Hspc28p6zIjb2Xp9+El3yZsLe40M6/i5J5qoN4u7Kufn5eYFhQfGYfFHR8bU9EdcReqJSHiJB0aJSGSDteTEJVSjFQlsVpTkZTW7qhl7SQqpWU7GiU15qg1YuTeXVsb2d6c1NLXm1qY53G2LiltMz4+fr4+fmF+oD7+vr5+Pjy6cqzwY2SYkh4eUhKjolkXnOFd42BkZiHgGV0XWRkTWg6SDlBOzheWkdHSFhsVVd2gURTRmmEaFFTllBUnXtWcpdjbG9TY1ybnHO05/X29/n4+Pj3r4384J1kaYtci/1xQqZrP1Op0oTST1yc4oeK7uTn6OfdxZ6Rghqvi+3phLfWvMjO2uLc4+Tl5eXk5eXm5OXk5YTkMOPj4uLg38uErauEi7LGmcbwp3mrXHN6psyjx6zHr5aM1pmRudS11tTQu9Pg3cHg4YXigODPtDuCvGKm/J6kge2tibuCcIz4vujTY7qPwmbVwodpianwjXZhLDJaTk5RUZOlqbRnWnKSu4aKTNP3x718fF9aVUxbgZSefomEWO+9mX+nt4Tgr5KShPPQgpCGyZCY06CSkoHfc4rhgJFbeHF9w+SmnYGytbe6vL7AwcPExsfJgMrLzM7P0NLT1NW2rdim8aOjlFmKalBhc6354vWB0du/m9WQhHB2dFt2yebxqdi7q69tVkpdU096NFJPP2hASn+5fmhHUVpNlZBhZEJXb28/bW2NjvVql61kn4j26PVzrsCnb5gvgLvDkrz6n8ni5Obp6uvs7e/w8PHy8/T2+Pf5Cvr9gIGCg4SEhYWEhi6EiIiHh4aGhIOCg4SGiImKiYqNjIyOkJGSk5OUlZWVlpaXlZSSk5KSk5WWl5iYhZlbmpucnZ2cmpqZmJaVlZSSk5aVlZWWlZSSj5GSlpaQjYuIh4aEhISDhISCg4WIhoiGhIeFgoGCg4OA/Px/9vX29PHw7urm4+Li4N3b2NbT0c/OzcvJyMbFw8PDwoTBgMDAwL++vby7uLi3tbW1s7KysbCuraypqainpaSjoaCenJycmpmYl5aVlZSTkpGQj46Ni4qKiYiGhoSEg4KBgP/+/fz8+ff18/Hv7u3r6ejn5ubk4+Lh3+De3uDf39rW0s/MxsTAv727uLe1tLKxsK+sqaalo6GenZuampiXlpSSEI+NjYyLiomKiYmKiYqLjY6EjUKMjIuMjIuKioiIh4eHhoWFhISEg4OCgYCA/vv6+PXz7+zq6Obl4+Hf3d7f39/e3t7d3N3b29rZ2tnY2NbV1dXT0tKE0YLShNMP1dTU1dXV1tfW1tfZ2tvbhdYD19fYhdeG2DbX19WitM/0mDhCffvCsGSxgG1kSlhEVFQ6UHk6LU9em22LiISNo5CBraVhk2BOf3FWPjs2MzMEfHx+foR8AX2EfIZ9BHx+fX2HfAF9h3wBfoZ/CH18fX18e3x9iHuCfIR7Bnx+fn18fpZ/h36Cf5N+iX2Lfgl/fn5+f39+f3+Efgl9fn1+f39/fn6MfwJ+fYR+hX0Dfn59hH4Jf35+fX5+f31+i3+CfqJ/DH58e3t7fH18fHx7eoV7CX18fX5+fn19fpV/HX58fHt7ent9fX58fX57e3t8fX57ent8fHt8e3t8hHsFfHt7fH2Fe4J6hXsFfXx9fHyEfYR8IXt8fHx7fHx7fH19fHx9fX1+fHt9f4B/f39+fXx9fX1+foR9DHx9fXx8fH1+fn5/f5qAEH+Afn9+fX18fH19fX5+f36EgAN/fnyEew58fX1+fH5+fX19fHx9fYt8A359fYV8I3t9fX18fHx9fn18gH59f3x+fYB+fn9+fnx8fn9+fYCBgICAl4H4ggOBgYLige6A238BfoZ9CHx9fX59fHx8hX0QfH19fH19fH18e3t8fHx+fYR8CHt7fX5+fn18AgIEAEzk2qilhaSTv8KpkpWenO2GoaKXjpvqmaX1kcbYj3eB1q67rM/Ppr2CZpN5qNTKq3lomItWZJPKmJ7An9R2zn2ek7jDVmJofk1lbm9uhG+GcIBxcW1ucnJwcsui75jChs2ltNOzl4fgo77M6dHVxZSxvOPIsr2Zh4DR9+6Ao5C24YmUna2njKymsaS1sJ2u0tfizOnZj5KshO/pjrGynYTo8I+mhXBubW1tbGtkW6eUqNbp3uqLhJqSd/SvfYqxsZCNf61RkIdeaGZmZGRjWJSOnoCIh6BWZ2BiZVieVp1lZWVmZGVlZGRlZWVmZmdmZ2dmZ2dpaGdoWHNzX0VPUVxUXqCDf5GWkLXQp6xVhrXCgHBgXn9wb2p2c2BscVdwbHRPYGxtbmVWgdPgW3BKR15uWov06Za92V95SqZ/rrt29IWbfJmOmumWh4/l5ayRjruc3IB8faR4kceOeqOzgpuQn55+1cyWu7ifo5/bwsHHm561xpW4bX2DZH6GVYCJh42jkLVcV31maJyzfsCatcbIxnPAoZJmaXJ4eHh5eXl6e3t9f4GBgYODhYaHiouNj3x/t5hwsLN2pq/C2pbIgZqDpo+ZpajBrIh4uK5vj7WP2cR0flyKiJ3Uk4CmdYiNcM6Ie2yFanzKioV3pJx8hrqo6uigfrHt0sLlh4fVdtKVy4TdypF/m6SFd5qV7MKLjqaspbGzsK+vsLGxsrO0tre4uLu8vLu7vcDFy9BqbGtra4VsFW5ta2loZ2ZnaWtscHN3enh3dXZ5eoR5gHp5dnZ3enyAfXp7eXZ1dnd5fICFiZCbqbO4vrCjqKGRj4qEgH+ChISEhoiGhoB/goF6fIGEg4GQhXRvbm5wdnp5end8e315em9scXN4dXeBhOjd5u/n4+fc29nJv7y6uLSzuLW1rammp6impaOru66lrLWwopSTkpKTlJWVlZOSA5KQjoWMHoqJiouLioiGg4OBgH58enh2dXZ4enZ4enNycnJxcYRwInFvcHBxbWpoZ2VkY8XEwsLBwcC/vbu5t7azsrCura2sq6uEqnCrrrzHxcrHv66kl5KPjYqJlY+QioKAko2AenZ0cnBsbGpnZWVjYWFfX11bYWdaVlVTUlRWWl1dXFlXWFlZXGJlaWppYF5hXltcXGJkYVxYW1xdWrOysLO1sK6iop+emJOMiYaEfnp4d3Z2d3Z0dHRzhHIBcYRyAXGEcipzcW9ta2tramtrbGtuhZyRgXKEi4qdp6mkf3qFgXZvbW1sbnBra2pqamuEajRgg3ZeXlXgjHmMiuN062No9tBspozDsoLL4abbt9SQldewm4rtlnF71avN0dOajpeU3KCLVMfHdHp4mYmq9rOUpp2L65q9vaqWp/iIdL+O1uiXiHryvb+5xNnJ5qV+uJbI++/DmYK2qG59uuKwucKo34j0nLux5/BviJagZpSjo6Oko6WlpKWlpYSmgJmXpqKUk8aAtnGUaKB8i6GJdmm2gZefs6SnlXKIjq2ajJR1cGSmubxacWh1nWJmdYR6YHd4gWx4e3Z8kp6ml66fa2+CaLq1aYeFd2i1vnKHmKGhoKGgoKCQfdSzwNH22uuHeamZifmygpvT1a+EhNltr5J+l5eXkpaMereowaumE8tukIKEjnfAcMeSlpaWl5eWlpaFl4CYmJiXl5iXmJeVlnyioYNfbHF+dYC1iIiWnJG6+rKzaKje3JSKenmnk5ONnpx/kJt0mJGdboeZmZqKdJh5qniVYV16jnKs5dmit9l2oGLDgLzNiPdohZiyf2qSko9jen+ypZjVuPCMo9CMf9eWkMK7f5qWp7ON+bVwn52alJ3dwYDM47S53e2534yYnniXnmmZpa2tz7HdcWWQdX62yJboutPm7uyIzbSndXiIkpKVl5iZmpucnp+hoqOkpaeoqausrq6TlNKtfcfPj8bG1/Sn55mukricqLa77c62ovLhibHYo/3Yhp6mosD7ppe9iqurif2mlIajiZD1r6OEw7+LoD7ovv73sZDG//Pn9JKV64LVoOSN7deTmKmYqoO2m87ll5mzvLnHyszOz9DR0tTU1dja2tvd3t/e3+Di5+zweYR7gHx9fHx8f359e3p5eHh6fH2AgoSGhoaFhoiKioqLjIyLiYmJjI2QjouMioiHiImLjZCUl5uiqKyvsaymqKScmpaSkI+RkpGRlJWTko2LjIuIiYuNjYyTjIN/fXx9gIKCgoGCgYOCgnt5fH1+fH2CgfDr7+/p5ejl5+Pc1tPRzcrKgMzIxsO+u7y8u7i2ucG7tLi7uLKrqqipqaqrqqmop6ako6GgoKCfnZydnZybmZaVlJSSkY6MioqIiImJh4iIhIODgoKBgIB/f359fXx8enh3dXRzcuPi4N/e3dza2dfV0tHOzszLysfHxcXExMLDw8TL0M7Oy8W6s6umo6Ggn6WgZaCbl5aempGNiYiGg4GBf358e3l3dnNzcW9xdG1raWhoampsbW5tbWxsbW1tcHJzc3Nvbm9ta2xrbm5samhoaWlozs3Ly8zIyMG/u7m2saypp6Wjo6KhoaCgn56dnp2dnJybm5uahJkImJiXl5aVlJOHlFaWoKqln5ihpKSssbKwnZqfnZmWlpWVlpaVlZSUlZWVlJSUg62cenlp9aOTrqvrgeV4guPyh8Gsy6F/weOeypXGXnylloFr0ZCAhpx1m4O1pWxZWYBsZoB6hT5ROVFYcoVaMDdPcLtcY0VjXUp3UUBrRHahU0ljdU5jUEpXt8SukeOx6OOxhHJ4pamLiYekfnOATJ9DlrW3sf/0hMLhyorc9vj4+Pn4+fr5+fj5+fj43df17M/L0F+DTWlJdlxmdWVYTYljdnyMgYFtU2Vog3VtcFdcPmpmam0uQEQ8XEZIU11KKD1JTDdJREdKWW99bH5uVFVoVJaLS2ZhVk6JkFhrwPX19/b29/bWrvLds2Gxc3RJXKBDWKF8N2vT5qw1Mf6Uwlaq4uTl3+TQs+O62r+975PRvL3OmL2L49ri4+Pk5OXl5eTlh+SA4+Hg39/a2rXl5LiDlJ+wmZyfb2hzcXKk9Z6ggNT6s5Cqq6/00tTL5uG30uKn3tDj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t6menJORkZCQkJGQj46OjIuLiomKiomIiYmIh4aGhIKBgYB/fHp4dnV0dHNzdHJycQNwcHCFbyFwcHBycXNybGhnZcfHx8XDwsC/vby7ube1s7Gurq2rq6mFp1Goqra/t7vBsKWZko+Pi4mLnJKOhIGSrZJ8dXN4c29vbW5paGZnc3VqZWxwZlxWWVdXV1tbXGBiYFxZWFdZW15eYWFfX2BdX2JhZGReWFVUVKeEpRaopqWfmZiepaOblY2FgH16enl4d3Z2hHQFdXV1c3OFdCpzc3NycnBvbW1ta2tsbG1tb3J8jYuInKKiraqgoI56jJCMf3FwcHFzbWuGbDZtbWR/pWJqWF9ggJijxL+15dFvlILUruSCsKmykK6C4fP8itXsjbSu3f2U6dy59OKLo7KT56CAw77EqWh3g6aB+Pm4yZ+m0NeI9ojwx7CPdMDl1PiL89nst4G7m7qSrYKzhJe98+aQgpfzjZKasauhyv2TprDHhOK8yL1lm56ipKSkpaWkpaalpqanpqeoqIClbZluvayUZsKFW5S4k7F4iINwlXyccXWInaGEoZiup4uTaHq/bJmAfLCgjLVqcHd2ZmBkj7J0W394eoaXinqtq6GSbnK6ZXlognCahX5nZ3ugoqKhoqKioZmCt4K4oaft8YG3gO+Si5zDenWCvJvGgJ6qfpiXmJiZjIBryLVzZcFr1HZqtNvZz4bIkZeXmJeXl5iZmJiZmJmYmJmZmJaCl5iYl5aRlpUalouYsbCxnfDY8YPdzO2ynbrF4ehufpiamZmFmICSkpmYkWCceoulZ4Z5fZm+c5mNhpWFcX/hnaaMgZ2Y8OWForuYlYV954OvcXXDXndYnXOCxtKqjG66/KCGsHx14d6Lr3zg2M+Nt7ewrafUjrCsusjq++Xnwc7QdZSxYmPCkZ34jIGe2XeCZnuCiI+ni+b6m+fdq4mMj5GSk5SVl4CYmZqbnZ6foaOkpaaoqausra6voXahm5WznebH3KSEmtHwkYOxsIzkuZTZwZSz/py5oIzq/cfwrom+/Judm9n7mtfzlv6Fn5+m+I+skunw9pHTtZel9Ir8wJv/9vuXqaKcnZqdmIigu6qT4//YrIip5bS8v8LFyczP0NHU1NbY2IDa2tjY2dra29ze4uXr8vl9fXx7fX6AgYKBgH99e3l5enl7fHx7fH1/gICAgYOFh4mKi4yNjpKWm6ChoaGZmJ6gnqKlqquusq+koKGbmZeXl5qalpORlJ2ak4+QkZCQjoiIhoWGhoWHjY6Pj42Fh4eJi4uJioWEiYqKhYWGgX999ip79+vc2c3Ix8m+wMrX3d/Z29zQysfFwL67ubnBysPFxrGwvbyzra2pp6eEpi6lpKSioaCfnp2dnZybmpmZmJiWlJKSkpGPjouKiIeGhoSEhIOCgoKAf39+fn59hHxpe3x6d3VzcuTj4d/e3dva2NbU1NLQzszKycfGxMPCwcDBwMDBx8nExce7tKynpKOgn6GooZ+Xl5+tnI2Ih4qGg4OCgX99fHuBgHl2eXp0bWtsa2tsbG1sbm9ubGtra2xtbW5vb25tbmxshG0ja2hmZWXLycjIx8fGxMG9u7u8u7axrqqnpaSioaGgn56enZ2FnIKbhJpmmZmYmJeWlZWUlJOUlJSVlZaXnKOioKqsrbSyrK2jm6Kjop2XlpaXmJWVlZSUlJWVlZSGqL6Bi293dZi5xd3TuPP5gLeU4LjviMi8u5a1b8LD5W2z136ir9Xca6WMcqS2Z2VaWY+FTHZ/iWg1Oz96SoJ5Tm2jjkE+LFg2U3lzRTtgam+QVmhBPkMyPzhOP3tirm6SrLuyVVJerKSumm1waH6SXomq6o/trsPJgOXr8vX29/eE+ID5+fj5+fn39qyuiNqO14dsRIhMMXKGa4BaZV5UcV16VFdldnVYdXF/fGVrTFl3PV5GY10/SkhJUlI/MzFUckIlSkI6R1teUIB7d2FSXJlSX05iTm9jXE5OZNzz9PX19fT13K23XVpaTGluSaAym2Q+WLyfmHlSYN2wlqCt4ePk5YDlx7aT/saZgciP/Y+FwnVvZlbd1OLj5OTl5eXk5ePk4+Tk4+Li4t2+3d3c29rT2NnXy9X+/sF/v8zVg8Tk6cPAyMan85Wv2Nrb2trc3N3c1tbg39WL3rDJ7JjHsI5z8abby7/VwaOs03V7WlaXmryqX4yzf3h9Za9bqVZdnDxMNoByiavzxYqJjMa3w7K0X1iUelyUVN/HnVaSe2VUXueq06acmszvyqeCkMuMx/OFh/hpUJhTW6H7nK6Nn5+ck66Ixs99tO3Oqayur7GytLa4ury+v8HDxMbHyMnLzM3P0dHS08CMwbCxspbEo3BVVFmqwZuQycKc3NKZpHuAenZchWZ4dbXon6R6SWxxPktMbYQ+n1xCgEpzV2+3Q1o7k3O5RXdMVFjScYBVU7GbzJ2JbU9zX2mjjK69pGj17+lXYqb7x8/T1dnc3uDi5OXm5+jp6urr6+zt7u/x8vX2+Pv+gIGAgIGCg4SEhQeDgoGBgYKChISAhYiIiImKjI2PkJGSk5OVlpmam5qam5iYmZqbnJ2en6CgoZ2bnJqamZqanJuZl5aWl5eVkpOUk5ORjo2Ni4yMi42Oj42MioeHhYWGhoSFg4GDhIWDg4OCgoD/gP706uji3tzc1dbb4Obm5OHe2djX1NHPzcvKy8zKyce+vcLBvbpourm5uLe4t7e2trW0srGvrq2trKurqainpqako6GhoJ+dnJuZmJeWlZWTkpKRkI+PjoyMi4qJiYiHhoWEhIOBgYD+/Pv6+Pf19PLx7u3r6ujm5eLi4t/f3dzc29nZ2drY1dTTzcjDwL6EvCq7uLWztLW3rqilpKWioaGgoJ2bmpmamJaUlJOPjIuLiouKiYmJioqKiYmHiDuHiIeGhoWEhISDgoGBgID+//37+vn39vTz8Ozr6OXj4ODf397e3dvb2trZ2djY19fX1tbV1dTU09PS0oTRhNAh0dHQ0dLS09PS0NLU1dXZ19bX09TT09TT1NTT1NPU1NTVhdQ107maamVvio+bxNpzZXBugIY/MDVQPnmH7O/HpcNZlJDVVoSnYmuR3sA0emhJcp1AMyw1X06Gewd8e3x7e3x7hX0QfH18fHx9fXx8fHt8fH19fIV9D3x9fX5+fHt7fHx8e319fIV7CXx8fH19fHx8fZV/BH5/f3+EfoR9gn6IfY1+BH18fXyFfZZ+A39/fpV/gn6FfQR+fn59hH4Jf39+fX5+f35+iX8Pfn5/f35/fn9/fn19fX5+n38Sfn5+fHt6e3t8e3x7fH18fHt8kX+EfgZ/f399fH2HfwR+e3t7hHyCeoV7gnyHexp8fXt9fn18e3x+fHp9fnx8fHt7fHx8fXx7e4V8BH1+fn2FfCB7e3t8fn9/gIB+fHx7fHx9fX9/gH9+fn19fXx8fX1+f5+AB3+Afn59fXyFfYV/DH1/fnx7fXx7fHx8fYd8AXuHfAN7fHuIfIN7hXwKfX17fH19fH1/fIR9Dnx/f39+fH1/fn99f3+AnoHwggKBguaB64Dcfwp+fX5+f39/fn59hXwRfX19fHx8fX19fH19fXx8fH2GfAd9fnx7fHx9hH4CfXwCAgQASaG32ZeGqpnZ9oS7iIj5hKDsscnxtM6q8Or5momxqb1+xNmJjpTw0HvJo+N+mYvfeHqfuF52zdzdwXODjauIkafJjrJyX25wcXGFcoBxc3Nyc3NzdHV1aJOkvPCc943nuMvXjpaS2bCTj4qSo7b+kbPL7ISGpY6H8NTOmczXroiyw5bTj5S0p8uriJOhr++aiZmQ6eL7j6SjvNmBnYmGja/It8TAjNKBi3VldXJycmxxXotyppDKwuaAkIberZaNrHuFeOR8hFGjgVlqahlqaWlpYlumnnlyi5CPnXezn5jE7ZhnamlphWiEaYBoaWlqamZaYUBSYWpoZWhTZWdZal1gVHhyaFnAh4+Zkom/e6+BTV9xamReWG5ub25vbm5sbWxsbFZveI9r/Zp0eYeCV1l0XKRa1NulaoOgm73Gurt4uL3XgLtUq8CZg97mtn90sKrFdoPmU4e1mcXG45Tm9Jl4zJGi5dOetY1XhoBZqYF6q594lcacdIRVVIiX04G7x5F6k3ORsJtXkHGNuHGBaLGob3d5enp6daBgcnx8fn9+f4KEg4OFhoiLjo+RkoJmvKRwh4xxvZ7OwdCNop/Df7qhgLmCsavAbXGQfYCmt8S1r2y0a5BvjInQ0ZzIxH+Og3ekkpGOs5rRhYO9doCbj5OJ0nSx3oB/pOvkhJV71c3qiXzn7ptygbWnpHbIlqqrra2vsbO3uby+v8C/vLq5ubi6vcHEyMvY297d3ujt5OHg3t5vb21ra2nOy8vMzWdoaGdoa21ub3N3fISKjpCSjYqIioqIh4aHi4+SkJeVmZyknJeYlpWSj4yJhoSDg2aBgYSIh4aFg39+gYB+fHd1dHRzdHR4goiLkYiIiYqHhIL16evg7/Lo5ujxgPqBgf7u8OXdyraknJqjp6fD6unp2sC4t8C0r66uu83HwLqtnZWRjpSelY6PkJCPjo6OjY2NjIuKiYmEiCOJioiKh4WEhYSCg4OAfHp5d3Z1dHJxcG9wb29vbm9ub29uboRtHGxraM/My8nLysrGw8LBvby6ube1tbKvrq2rqqiEpmylp6etrKuyta2jmpSWjouJj5mbi5WduaKDe3R4eHZvbW1raWhujIlycnduZF5YU1RXWFtYWWBkYl1ZVlVXWFhaWlxcXVtaW1xdXmFeWlempKKloJ+enpycm5ycn6ehlo+KhoJ/fXt5eHd3d3aIdS52dnV2d3Z2dXR0cnFwb25ubW1ubm9xcnaLmpOnpqaqoJ2aj42kr5eIeHSEhnFvhm03bm9vYXaUj5uIcZx7xamF3pSkqLaqm72tu21oV3FtXIuihavyvKOd7Yu+gIDCqqWr1cbY/KewhFGwm7CLY4Njp9WBw5OL5per/LbZ/qnBqsC/4I6bwrTTj+TWiI2U/u2U6bX4krqS8YaEw9h0j+D2+eKFipzGo6bE2Zfdk4Keo6SlpaWmpqWmpqeEqHipqamEmKjN7ITMda2Jl6Nuc22niXVoZXOElMh1j6C4amuAcWzCoZ53pKGBZXyMbJtjZXl1kodibX6JtXBfbm2qqKtgbW+BnF94bmNlh5qImJRromR9gH2bo6OjlpJyo4e2o7i42GuRhd+mkZzBj6KJ94unasWYcZeEmRWWh3zBopGJmaauw4fKpJvI87WSmJiEmQSamZmah5mAk4CNXHaKlpONk3WOkXqTf4dzoZqNe/6krsjAsOaS16VheI6IhH55mZqam5uam5qampmYd5COrXafmpedrqlwc5l+4G2o1cqOmMzI3uny2YP09Ol32W61sVReidjXnobLs72Wk+hrqJtxnK3lndHmpYKJb6jHjJO/mWCUZL6Wl82AwpO27riLn2hmo7P1ltjvq4urgqHDrWGefaTbgpt2yb9/i46PkZKKvnSKmJqanJ6foKKjo6Wmqausrq+wmnnauX2WoYLar+HU25ivsd2TyLWY5qHl5euEkqiTlcDp18y4gNaAsIegofPhuO/2j6Gfka+mrZHRrt+UjcyGr6i0mfWAhsX2iZG86PCPqoPn1+mQgvDznIOKybetgtymu7/CxMjLztHT1dbY2dnY1tfX1tjc3+Lk5+3v8fDy+Pz49vf19Xt7e3p5ee7r6+zueHl4eHl7fX1/gYWJj5KVlpeWlJOUlJOSkZKVl5mXm5udnqGenJ2cm5iXlZOSkI+Qj4+QkpILkZCOi4uNjIuJhYOEglOBhImOj5CKiImIhYSD+/T27vb48/T0+YD+gYH/+fju5tbIu7Wzt7i6yuDh4tbHwsPJw7++vsLKxsG9ta2mo6GlqqaipKWkpKOjoqGhoaCenp2cm4SaFZmYmJaVlJOSkZCQjoyKiYiHhoSDgoSAKX9+fn19fXx8fHp6eXh3dnXo5uXk4+Lg3tza2NfV09LQz87LysfGxMLBhMBAv729wL69v8C5sayqqKShn6KmpZugpbSkkYuHioqIhIOCgH9+f4+Mfn1/enNvamhqa2xsampucG9samlpamtra4RsJ2tqa2tqa2xqaGbKycfGxcTDwsLAv768vL66tbKuq6mmpKOioaCgn4WdBZycm5ychZsHmpqZmJiXloSVWpSUlZaWl5qiqaevrq6wq6moo6Gssqael5een5eVlZWUlZSVlZaVf5i6rLipjsCS3raO7LPM196smdS81YF2Z4iBapSei5PDrJd/4IjPZV2UnnNsprONh11gaYDSZFRIO0UuVohRaTdHn3FMVU5LYE+HqkFAdTk5Z1Q/JjtILSwzVkdKd3G/g96O02BombGOndCTgJprVXDQvoasl3rswbfo8PT19fb29/b2+Pf4+Pj39/bzsKGx7+BloFF3YG56VlNLd2JWTEtXZHGUV212h09RYlZSkHNzVHZsXW9GU2JBPD9BTlNjUjE9VV1NMSgxN1xVZC44PFZkRF9ZUEtmb2Fva057S3KYpdvz8/Pbx5CUfoRtaFlcOVxLdmJHVKt9u22PVLCF04SG3uLj5OTcxK3WlI2Fe4em3GeASVKEjbnV4OLj4+Tl5OTk4+OE4oDg4Ni7uIOoxtnVzNKly8+x0razm8zSupDwgJHZ0o2gVK7PhKbIwbuwqdze39/g4eHi4eDg4K/Mxe+ZbrTW3/TYoKLGiveCdWVfSXeilqWot6drr4qMXtOCpJAzQlOP4MKAjIqhsnKbhbhuQ2d4xImhmX5iU0WXj1BxosCBwoDtrICXyrebq8OGp9ONi9jJrmbH5cGt06rL++eAzpu76Y6PgeXonautrq6wpdGJqbq7vr/BwsTExcjIycvNztDR0biC8tiRoZiI3aDepG5bnqmahdq2f7lvkYOKSExQT2t4mYi1mDltQFM3RE1/dGRxvTw+RGGlkKJYj4tlaGh/U12enEKZ/YZmmlqGm67eZGhPoWybmW2k55uBltHBtYbut83Q09XX293e4OLj5OXm5ebn5+fo6+3v8fL09vb3+Pz9/f3+/v+GgIT8If6AgYCAgYSFhYaIio2QkZOUlJWVlJWVlZSTlJWWl5aXmISZhJiAlpaVlZSUk5WUk5OUk5KRkI6PkI+OjouJiYmIiIiJi42MioeGhYSBgYD8+vr2+fn5+vr6fv1/f/z6+vLs49rTz8zNzc/V3t/f2NDOz9HPzMvKysnHxcO/u7e2tbW2tbW0tbS0tLOysrGxsK+urKurqqiop6alpKOioaCenZybmpl1mJeWlZOTkZCQj46NjIyLiomJiIeGhoWEg4KBgP7+/Pr4+Pb08/Hw7+zr6unn5eTi4d/d3Nva2tjY2NbV1NPR0c3JxcPBwb28u7q6trK1trmwqaajpKWjoqGgn52bmp6clpWVko6MiYiJiomJh4iIiYiHhoaHh4YwhYWEg4OCgoKBgID//vz6+vr49/b08vLw7erp5+Xk4uDf3tzb2trZ2djY1tbW1dXVhNQG0tPS0tLRhNAdz8/P0M/Pz9DQ0dHS0tPV1NPV09PS0dDU1dLPz9GE0j3T09PS0tPT0tKkkp1ESXZ858bxZjqOhk9fl1s9z6Lgq5WNv7aStZ+RgZh1bVHLffliNGyvXEloXkFMNjhcBX18fHx9hHsHfHt8fHt9fYZ8DH19fXx8fHt8fX59fId9Dnx8fX18e3x8e3t+fXt7hnwHfXt7e3x8fpV/CH5+fn1+fX19hn6JfYR+hX+EfoN9hH4BfYp+AX2EfoN9hX6LfwF+i3+CfoV9BH5+fn2HfgZ9fn5/fn6Jf4l+hX0BfpR/AX6NfxB+fn1+fn17e3t8fHt7fHx+lH8Vfn19fXt9f39+fX9/fn18fXt8fHx7hnqEexN8e317e3t8fHp7fXx7e3t9e3p+hXw1e3x8e3x8e3x8e3x8fH6Af39+fn18fH18e3t+f4CAf317fHx8fX5+f35+f4B/f359fn1+fn+HgAF/lYAZf35/gH9+f35+fn18fX5+fH5/fn18fHt7e4V8B3t7e3x8fHuNfCt9fH5+fHx9fHx8e3x8fn1+fn98fH1+fXx+fHx9fHx8gH58fH1/gH9+f4CApoGGgoWB0YKKgQSCgYKC5YHrgN5/AX6EfQd+fn9+fX18iX2CfoR/BH59fX2GfA59fn58fX19fH18fX59fgICBACAn4f1uM24uLPxmd29ud2626GphdSJiPGUmKG9vaWfjbahg6TFvZaLo8PLp6ZOvLzgZr2rlXe81nzamU1ZWqVfSEyQWVJWrGhyc3NzdHV0dHR1dHV2dXd4eXGmh6Dfke7VgPbfkZeA3KqK4MCG5+rMzoac7+7v2uPQ2dHFrLSbpr1n4+/IxpPJvbynkr72zK/v2Iulrra314ns0dnQ0ZyX78nyjpWEko+ppZiG9sj7c3VrcKy7mcaii/XW6+7njJzjn4yBjWWAg32DX2ijX2xra2prZ19VnIeBj3ekdoDg4sXF1OV3jmVra4dqhWsvbGthQ3lggVBCZ1xoYYlvSkaFVEl3XZKloqOcqrR5ldaghWSMS0qIWpZlcHBvb2+EboBvcHFxcGxeVpuvaYTUk25wgLyfkYCSw86hhaPQz8NvrrhxyvLByvOr/Jm5b3q2u4CglYaqpa6H87jUi7GS3r/yz7jppK3z219ph2tteXd1w7dwaXawbH94pIZ8b2lZf4CaZ2hui420p6iWaaWibnd4eXl6c6jOaLaGen6AgYOGkICPiIeIiYuMjpGSk5WCh52Mk6B8nd+52NCSyL7YmaW3or7CybjIiI16wGmVlYjL+M+EipeFynCMeH+Cos+Agn6gnaKmioVzd8mfk4m01Ht4fKx4x5Kg1e+KpcyK6J+JgrqVla+lpNGFlbGxsLGxs7O3ubzAxMvO0czJxMHAwMHEx4DLz8zNztDQ0tTT1NTS0tLU0tHQz8/U3OV3gIqMkZGRl5ecnKGlqbK4ubm2sqynoZyMhYGBgoWHhomNk6Grr6uyqqSYjo6Sko2HhYSBgoOAf3x7eXh6fHt7e3l2d3t6eXh5enx7eHN3gIX+9ebb3/Dj7u/l39PP5IH4ybrjge/m8H3x4s63upqct8GzusbIpZqzx7SxxMPBwsKunpWOi4mKjouJi46SlpqgoZ2ZlI+NjIqIiYeGhoeHj5SPj5OUl5WTjIJ/fXp5d3V0cnFwcG9ucG9vb25ubm1tbWxramnPzcnJycjIx8fExMPBvb28vr65tbSysK6sqqqop6empYSkbaOlq6mblpOQjpWoraSPkZqcmY2JhH5/e3RtbW1ra3iLiXZsaWdiX1pVU1VeYmBgYmJeXlhWVFRVVlhZW1taWVhYWFZXWFitq6ilpKKfnJuanZqapqmropWOjImHhIOAfnx7enl4eHd3dnZ2dXWEdmh3eHh5eHh3dXV0cnFwb3BwcHFydH6gnKe+wsu8t6mUiYqUl4aAfnV9iXlxb25vb25vb3BxcHBvfcidbJJf2ZWpkJl1jYu1gcnBrpVYZnVhn3GGltuK39LgjImnlZDPuIPV5M6NyaHpmUmjgvbJwsK+wfpuwLnG8sDaqqF5wHNmwYWHfLHLsaGgw7iVs9fAmZmv2uvNzWPWwud51r2rh+Hzh/q1YXN1yXNeYb12bnPaiaSlhKaAp6eoqKmpqaqpqJqWtW+b1HK5qGLAsG5wYaeHbbSUa7S0oKFog7+2vKqypq2nnIiLdX+MoKaSkm6VjoVwaJa5nIy3n2NwhpJ2lmSmm6OSkHFyupq3cXRndHSAgHpqwKfMjaOMl8rWttuzkevP59HnlLXmpJR9kn+blpOgdYi5eZAcmZmamY9/bcCXkbWLzISH8vjg5f3ohK+LmZqZmYSaNpmampmZmZqZiGCzl7tzXpGCk5LHnWpgtnRhnn3A8+HRuszalaLtybCGuWNitXvJiJqampubmoabgJyXkHxiabuGrOjAk52r89fCnpDA07aYzeTb3YLl9pjo07Tn7Gref9uMkrS6goKLfrXTr2LmgHtuqobQ2e17scCMrbjabHeZeXyPk5Xq5IqDkNh/lYzDn5WEd2iTkK5ydXyZlb+ur55ts7F6iIuNjpCJx/SC2Z+Umpyen6GoqKWlgKanqaqsrq6wsJmbsp2ksYmv/9P/4aLd1fSwu8rI9fP94+2qqZTnhrTDnOj7+KKctp/kgZqMmJvZ+5eala6qxLSMl4GCzb6ak8TziHuGw4bjo7LY95a54pX8spOQzomaxLCp1YycvL/CxMXIy8zP0tTX29ze3dza2dnb297g4+XkgObm5+jq6+rr6urq6+zs7e3t7O/0+oCFiouOjY6RkpSVmJyfoqWmp6aloqCdm5OQjY2Oj5GRkpSYnqKkoaOgnZiTk5WVk5CPjoyNjouKiIeFhIaIh4eGg4ODhYWEgoOEhYSAfn+ChP/79Ozs8+zy8u3q4+Hsffbc1Op98uvr59vOMMDApqS5xcDEyMexrr3IvrrFw8HAv7OqpaCdnJ2hn56eoaSlp6iopqWioJ+dm5qZmISXfpmbl5eZmJmXlpKNjIqJiIaFg4KBgH9+fn59fXx8e3p6eXh4d3Z16Obk4+Pg4N7c3NrZ19bU09TRzc3LycfFxMPBwL++vby7urq4uLm6t6+qqaakp62wq52doqShmJWRjY6Lh4SDgoCAho6LgHp3dXJva2lnaW5vbm5vb21saYRogmmEaoRpPGhoaGfNy8nHx8XDwMC/v769wcDAvLazsK6sq6mmpaOioaCfn56dnZycm5ucm5ybm5ucm5uampmZmJeXloSVGZaXmJyqqK66vcK7t6+knZ6jpZ2amJWZn5eGlTiUlZSVk5CJluW+grNw8afGqreInaLLlufbxbBtfI1yt3qCocOU6cXNnJ2kb3fTrU+EjalQiGisd0uvVVZqYnFTTmYxh1pYcndwR0YsaVZBUyspNURJTUgrNDAvQUhBLUJMT2/c+4DLpdaAooGvh/BqMXOqgqKo84+Cg/yRlIzurvH09fSE9YT2gPT08ueqvbhikMJZin9JkIFQT0h8aVSHb1CEjn10RWONcop7hX6HhHtsbFdcZG9yaGlJbmpjSklif21YUTcoMUk6Mzs4UUFBZVxXVZR8jVhbTllXXWJhUZB/m7Xwv9XPzsKrak+hY3lrgXvQwmNBMGGHj2KEj4y3ipXI4ePj4tCzgIzdgn/dhu9eVZSThczvqGy4wuHh4+Pj4uPi4+Lh4eDf3t7FhcmX0ZGCyK+8kO/Pg4n6lInepcHCtrOWodVzbqrP6bbtjYLlk+XC297e39/g4eHg4OHh4NrOr4JL7L/v4/WulGGk9vFbR26fkH2foZmcWZCGZbSrh7G9Qo9SjWxKgGuLY2BjUH/ZbjaCSkZQhF64yrZCjJNynYe1hZe3nZ+om4z09Ip+k/CiwrjxwaCgmYK8u9mEhJrFvOzT1LuA0taVpqmrrKyj5Pxb2rmzu72+wMHDw8XGx8nKzM3Nz8/QtbbRtrrCj53KqJbbduCqioOfz4+TlKOHfWlmRpJ0s5FtXMPLsWVXWTRyTVlFTE+YgURGgYCapFp2mXJtmIVtlYj6kYZ5vVfDi6CL+Vd1k2OjlZODnnuEqb+86JqnyMzP0dLU1tja3N7f4OHi4+Pj5Obm5+nr7O3u7u/x8vP0hPU39vb3+Pj5+Pj4+v2AgoSFhYWHiImKi42PkJGTk5SVlpWVlJSSkI+PkJGRkpKUlJaVlZWUlJOSkYSSEpGQkJCPj46Ni4uKiYqLi4uKiIWHgIaGh4eGg4KBgYH8+/n08vTx8/Hx8e7t8Hrx6ebuevHq5uLc087Ns628ys3Mz8vDwMfLxsPGxcPBv7y3tbOwr6+xsa+wsbKxsbGwr6+urKyrqainpaWko6KioaCfn56dm5qYmJeVlJOSkZCPjo6Ni4uJiYiIhoaGhYSDgoKAgP/8Vfr59vb19PLw7+7s6+no5uXk4uDe3tvb2djW1tXV1NLRz87OzMvIxcPBv729vL24srGysrCsqqimpaSiop+fnZubnpyXk5GQjYuJh4aHiomHiIiHhoaGhTCEhIWEhIODgoKCgYCA//39/Pn4+Pb09PPx8e/u7ero5uXj4uDf3tza2dnY19bW1dWE1ALS04TSBNHQ0dGGzwLOz4TOGc/PztDQ0tfY2tfW0c/Mzc7PzczMzc3OztCI0TXQzMe0hYJzYZuR/XtwxeJlP0O8m/jf3umMq8Wd9o19q62g26u3r9HIYlfUzDVPTHUsNSk/PgR+fn19hXwFfXt8fHuEfAF9hHyDfYR8i30KfHx9f3x7e317e4R8D359fX9/f31+f39+fn9/fpN/F35+fn1+fn5/fn5/f39+fn59fX5+fHx9mX4Bf4R+E319fn5+fX19fn19fX5+f39+fn6Jf4N+hH+Dfoh9jH4Df39+iX+IfoZ9gn6TfxN9fX1+f35+fn19fn5/fn5/fn58iXsJfH5+fX9/fn59kX8Qfnx9f357fX19fHt8fXx8e4d6D3t7e3x7e3t6ent7fHt8fId7HHx7fXt8fXx7fHx8e3x8e3x8fXx/f35/f359fHyFfQd/f39+fn1+hH+Dfod/A4B/f4eABX9+fn5/l4AQf39/fn19fH5+fn18fX5+fIV7hHyCfYp8gn2EfCt7fHx+fH19fH1/f318fHx/fX5/f35+fX1+fnx+fHx8fXx+f359fH5+gIB/soHRgo6BAYKEgQGC4IHqgOJ/FH58fH19f35+fX5+fn19fX59fX1+hH8Zfn59fXx9fHx8fX5+fX19fn58fX18fX59fgICBACAjfqflYnWhMzk5tiz8YeF9db7yr6N9Yyki4+856OFipCOgMZy1IjqtLOxaG1uqXyAeHqku8J6zY3Vk1ZtcGl9U3WIidyggmZ0dHV1dXZ2dXV2dndzc3R40LHDkay816/uu/C9vdOb2feqz+jpw97MqcDC1aK54M3RuLbAxcShp7aA49vdqp+cl6Wt2qfWqLT7xMuEsdjB2qe8lpaex4WFqJaIxtCBjqa17J7799DUvnhzYIxhdmZlmcagxOWUkoyti4f0i4CxvotkZ2WiZmtrbGxsbWltYYCJkaDmg3TW8vORXV9Zf1ltbW1sbWtsbGxtbG1tbW5uak5sbFVmaGqOaaaAYYuibmF3TntraLRxeHqwds2Tmo1cYFiLeKeqY0htaW9oZHBvcHBxcnR1dnh4dmilYXxajVy7gMKuhL6ahNyI77mwbGd9mNifbtOL3cj4gvKLoZLSmfr+xtHMiN62vbGo3O+B45mgl/D6kOqscLZ0fHSMW3eaY6J/kYavnXVmdneAWmB+WqhhmW29i3SigIeLj4+IgXl6fXx8briymayWXH+AgoSFh4uMi4uKi4uNjpCSlJaam6B4fLielnrSec161siUbcSV1m2GfXCwqaisv7KjdXWKn2iR1Y6Zk8WVempoj3+PxMyp3aBxorKWg9Z8nZnOn4KHl3nkxbJvrJyFqckdfHJ1qrmH7cm2pZOnfbW0srGvra2vsrS4u72+v76Fu4C8vL2/wcPDxczS1dXY3erzxtCu2t3d3dzd4Op6e3+Gj5iYmp2emI+UoKusqqqlqaKbn5+TjYuGhIaHiYmMkJqklZacp6mrp66ikpqtq6qgnZqcmIyGfnx/i5ONhIB/goOGgIB+fX19gYWBjob/+4T48f6DgYKDgv6A7OXhz7GoqIDZ+fjx5erizaC+tL3Evq65xsO3rKafnKWxn5ednaeilo+OiY6Li4yUmJycm5qbnJyXlZKOjIuLiYeGhoeJiomJi46RkouFhYN9e3l3dnV0c3NzcnJ1dHBvbm1sbGtratTT0s/R0MzHyMjHycXDwb+/vr3BxcK9uLOxr66sq6utrTqop6Wko6Kjo6GdmZaTkpusrp6Kh42OioeGjYqHdnRubm1ra3CEgnt2bmhjYmJkY1xhZmVkYl9aWFdWhFRFVlpeXl1cXFlYV1iuq6uqpqWjoaCenpubmpiZnZmUkpCNioiGhIKBgH58e3t6eXh5d3Z2dXZ3d3l+f4F/eXh3d3d2dXVzhHJXdXl9gqCrxsTRysa5oJOIgIF7d4OHcnFyc3BwcHFxcHBwcXJzdXd0XVh7nth2duPElNiGirCeYWGqjLaphFl0tYWolaV58py1v8fhg8Cuqo+Vm5Oiw6KUgHrnjZqE+pry4NfJpuCLksKwyJqXcMN7oIZupNaYh5qNopDag+aO+sDIyn+DgseIhIOMutjpi+mY+LRvkJWLkGWRo6L4spyCpaamp6enqKmpqaqqm5qdo/jS4J2UmZd3sJK3k4+ddKS9g6G3tZesnYCTkqRwh6ueopCPlpuZg4aOZa2qn3t0cXCDg6eBm32GxpWVYIqokZp+hW13cZdhX4F0bZCeYWyEi7F6zcenqaSOknSjdop/fKKjl87Oj6iisISC/6Wa1tycgYCIyIKTlpqbm5mRmH+ak6+4/ZiA4en+snl4dKF3hpoBm4magJVvmp2Cm6Ce0J3dkbjumYilaqaXjuGimpzQmtyZwrd7f3S6pdbafF+Tj5ePiZubnJucnJ2dnp+emXhjbJ9xqnztqvfSoOGngqSA4srBgISYzvnej+RitK6kbvfD0bTfjtnGn6bbgOu0s6CKg8t146V1ZMDDfrWmgdiJkIikbY62gHrKoq6mz7mHdoeJaXCRZ7ptrn3inn6qgIeJjI6KioWJjY6Qf9zax8uwbJmbnZ+go6WmpqenqKmqq62vsLGzs7OGi8+pm4XuiOOC7OKwgtml8oOhpIvW08/P4sPGiomeo4Cs+q65reqskoWCtJ+m4OjH6LiFqcSoneSMm57kt5iJJp2F89DHhK+ikKnchIOCuL+Q8dPOvJeogru+wcLDxMXHycvO0NLThtSA1dbX2Nrc3N3e4ebn6Onr8PTQ373q7/Hy8fL1+oCBg4eKjY6PkZKRjpGWm5uam5mbmJWZm5aTko+Oj5CRkpOVmZ2Tk5abnJ6cn5qSlaCgn5uZl5eVj4uIhoiNkI6LiIeIiYqHh4WEhIWHiISIgv75f/n2+n17fH189Xvt6ufcysRxw+Dy8+zk49zOqsO6ucLBucDGwru2srCtsretp6upraqjnp6bnp2enqGkpqalpKWlpKKgnpybmpmYlpWUlZWWlJOTlZSUj42Mi4mHhoWEg4GBgIB/fn5+fHp6eXh4eHd26+ro5uXk4t/f3d3c2djW1dSE0kbQzsrIxsTCwsC/wL+8urq4t7a2trSxrquppqywsaabmJuZl5WTlpSSiIaDg4GBgIGMiYSAe3ZycXFycGxvcXFwbm1qaGhohGc4aGlqamppaWhoZ2fOzcvJyMbFxMPAv729vLu7vLm3tbOxrqyrqqinpaSioaCfn56dnJycm5ybnJuEnSybmpqamZmYmJeXlpaWl5ibnaqvvb3Fwb+3qqOdmJmXl5uclpWVlZSUlZaVlIeVMYtya5Ou9IGH9+Kv/ZKk3L10bsqv3MGcaomybsWVu4bSfJiRcotgkXyJlGZpdoCKhoVJS14xWD1jN05TV1lNVz8+aWNPT2FNij5cOTU+UE88JSUjI0YgSStad36ym4+S1n59b0phd/JcUDBuwZbM1sizg7Wva7mMoajw8oTzAfKE84DxxLXGzJyOuKOBeWZEbWeBaGNwVnmPY3uLinWBbU5XVWQwRm1ydGlocnh4WFtZgYJwVE1MTWZgb19iWVR2SUMwPVJQLjQzLC5BW0JFZFs5Wm1ITGZmfVyhnH59iLPCkKCXlK2LT1tfkGtpqI1kQkVpe5ng0n+lk7i8nsvU4uPi3hTR1qiVgsq0vYtvkGCRxqKWmK2c3ojhgODf397e3dzUm86xd2qJksymxmGd9rCUo5bjs3GbbGhtwK+ycsaUmauZ/qjH14WCz83Zzsje397f39/g4ODf39ehR4zgg7aAf096b196SE2AbrGmoGxUaHZ7hIPOQ4d6XEKdn51dgl+FkHVhmE9ybG5eYkqRS7uRTTx4iGKDcE+7gIutsNiHkrSB0YCLp+bYrpeZsYmMvYTri+Cb9bGRyJecnp+goKOeo6eoqpfoqpGut4S3ubu+vsDBw8TFxsfIyMrMzc7Oz9DPmZXYubCLeFKracvKdlGoo55Xb49kc3+EmqPUvpF3cmJqbINvjoKwT0tHNXBTR19GftWVdl+jkISagEdyr+Wud5ulgN2xrWaQdVlziV93cLPKi/rcvr2ns4bGycvOztDR0tTW19ja29zd3d7f4OHi4+Tk5ubn6Ors7e7w8PHx0+XE7/T19/f29/l9f4GBgYKDhIWGh4eJi4yMjI6Njo2OkJGRkI+NjY+PkJCQkZKRjY2Oj5CQkJGQjI6SgJKSkZGQjo2LiYmIh4mKiomJiIeHiIeHhoSFhYaFgoF/+/Z69fTzeHd4eHjud+3r6eTd29rk7Ozm4t/b07LJwLfCycbHycbCwL6+vLy9ube2tba0sa+ura2sra2trK6uraysq6qpqKinpqWko6KgoJ+fnZybm5qZmJaUlJOSkpCPbY6OjYyLiomIh4aFhYSEg4KBgYD+/vz6+ff08/Lx7+7t6+rp5uXk4+Hg397c2tnY1tXU0tLQ0M7NzMvJyMbFw8G/vb26u7axrq+trKuoqaeloqGgn56cnJudnJiVkpCNjIyMioiJiomIh4aFhIKGg4WCOIGBgYCA//79+/v6+Pb18/Hx7+7u7ezq6ejl4+Li4N7d3NrZ2NfV1dXU09TS0tLR0dDQz87Ozs/Phc4Czc6EzRrOzc3Nz9DX1trX19TOzMrIycnMzczOzs7NzYTOOc/P0M/OzszLs42KrqHtUnN1xcyaMUXD7J6A+pSEtbqRpq1Ty4vMp8V3oJZKYUVwO1KoRklQIjAoMgd+fX5+fXx9jXwGfXt8fHx9hHyFfQp+fX18fX18fn19hHyGfQN+fX2Efwh+f359fHx9fpF/iH4Bfap+CH9+f359fX1+iH2CfoR/g36Gf4V+CH9/f35/fn9+hX2GfgF9hX4Ef39/fop/hH4LfX5+fX19fn9/f36TfwN+fX2EfAF9hHwHfX18f359fIV7BXx6e3x8hH4EfXx8fZJ/CX58fn59fH18fIR7B3x8e3t6enqGexN8e3x7ent8e3x8fHt7enp7e3t8hHsgfHx7fHx8e3x7e3x7fHx8fX5/f399fX59fHx9fX5/f36Ffwh+f39/fX5/f42ABX59fX1+mIAJf35/gH98fX1+hX0Yfnx8fH18e3t7fHx+fX59fHx+fHt8fX19iXwWfXx9fnx9fn18fXyAfn5+gH9/fn1+foV8C35+f39/fn5/fn9/soHRggaBgYKBgYGFggKBguaB6oDnfwh+fX1+fn19foR9Cn5/fn5+fX1+f36FfQJ+fYh+A31+foR9gn4CAgQATNGAjI+YqsuotsSl5MX4lIr6w423jvPmnd+K85z6hYaM7eOrvoq6ubuX6Y/Gv4Z6nIuf2nBtcIuBk5KNoKrEZoafkZHfoYlyd3Z3eHeEeIB5eXlutWVvpIm1oq2Q7s6DnoCC89eB4pmLlZGQtO3/8OL24tvojKKho46avc+ejfGtyuersLex8KzJgtK8lOSR3uivtq7UzI6OlPu+mPGSp5+UqP7Wg/fvzZaMjOnJwbq8ZHuKXYnZ9aKo06aLh4GMuo+fnJJeynJ0cm5ibm5tbR1vb21mg3uNe3Jz3r/kf36rY3BvXWpwcG9vbm5tbYZugG9vbGJUdHF5p416bH2cxl9zjVxmcHJ7lIira61plZWXbrtiY3B2l1yCdlNwanFvY3Jzc3R1d3h5eWpsd16bk5KzrbGieppoup5reXz096eZiI9iZFRyi4iCzISC75W80cKgi5m4q57q2KKWoa6DgI6H46uC4PPc+dbJsrS5oJd6gLWGgZG+f7uofMRwkoJqa6WNnpyue6qHrqLGeXrDxHSqeJ52f3uHqGvAk5R9gICBgoOEhoiJioqMjY6QkZKUl5qdoHV7d5yupbyzmtanidZ9iKuGuJB0tISHpsjNb7jXlZGvhNCafJaCx5Jqw2uSraF6fOGKjY13zW7N4YKJe7R/gIR0fpmBhX17w8aGo2/L33bA7sb4y8/m0rm4trKurK2trrS5u8HExsK9u7q3tra3t7i4ury/wMLGy83S2MeV2pGBr8Hs8/Xt5uXp7+/u8O72hIqQkJKXnJ+emJiVkIiKiIeJiIaGiImKi4qJiYqIh4WGhoiNjYqOj4+Mk5WOkI+LZYqMi4eHhYOCgYB/f4OHjZedn6OfmpiZlZGPiP//9O6Ah/vw5e739+vq49rKubK0wtPm6t7f18OVvIOZx8Cml5qcoKyolo6Ql5KMiomQmpmdlJiYk5SaoqCZk5SSkY+OjYyMjI2OhI0QjIyKiIeHhYWIiYqKiYeEfoZ7gHx8eXd5eHZwb21sa9fX2Nvb3Nva1tLLx8fEx8XCwsG/wMXJzMnAuri1s7Gvra2vrampqKampaaloqKin5mXlqGjn5WVmI+KiYmNgH52cHZwbWxsbW1tb25qaGZlZGhwaWVhXl5dW1lYWldUU1NTVFlYWFdXV1ZWrKyysquqp6SiBqKenZuZmIWVGJOTkpOPioiGhoWEgoGAf358e3t5eXh3eIR5CXt7e3p5eXl4eIV2GniNgnx6eq/Zz8bCxsChlod8eHZzdXp7cnFxiHA3cXJzZ253eXVlm5mngPiiopK/y6l5nMOWunDCvXCfe4iGlLGllZ760+a+uKPdndW98em+u8G1nYC7b36crMDYqrbSsde8+5N9xJt1oW7QvXnfc9SL7n18hPrvo8+Sqrq4qsuj3Nidl7eYvfGCgIKck6ykp7rC8H+TsKSd8cWsnaanp6eoqamqqquqqIzigorFmtOKhm2ljFx5YWa4qGaxd2t2bG+MsbeuobOXlZ9gdHV8bXmUn4By0oCMnrCAgYODuZKmYqOOdMB6uLKLhYCUl21qbbODbLRxenF2f8OkZ7qznHZvcbWZnqzMdZyfb6Ln2JeZqqKcjYWhx6TBwrV125ienJh8mJubnJycl4uvjpGGhYT4xO+FhtJ/lpV5jpqam5ubmpubm5qbmpuampqVh3Win5rHzLOZrICX14unyoGInp+nrpjljteFtqm+keiChJicw3qmnW6WjpiWhpucnJ2enp6fnYmKmG9jos74zuPKlL+FzKaMmYCt9s7L18+EjIKcu4hWqYGN8KvV/O++oXpyiZju0JaMk6h4Zmt6s3Fl7/aw6v7nzczct7OV2p+auv+H3MaW6IKolYB4creetK6/icWd07jSfn/N0X28ibCDj4uazoPTsKuVmZqcnp+hoqOkpqenqaqsra+wsbK0s4OJgaOzscjBr+jCj+KOkL6Y0KuS2JmdyPTfcb75q5i4kfOoj7SY6LaE9oO32LCShv6Tk5OD3IPq84uQi8mTioCQoYSNho7B0Yyuhlvw74bF9bPvz+L107a5vL2+wMHDxsjLzdDS09LR0dDPz9DR0dPT1NbW2Nrd39/i5NGg3piLt8jy+Pn29PX3+/39/Pz+g4aJiYuOkZKSj5CRj4yNjYyPjo6Njo6PhZBzj42LjIyMj4+OkJCPjpKUkZKRkI+OjoyMi4qIiIeGh4mKjJCRkZOQj46PjYqHgvr58e57fvLq5enw7ejp5+LWy8bHztfl6ODd1sqhvY6gxcG0q62usLWxp6KipqOenJuepKOkoKGhnZ6ipqShn6Cgnp2cm4WagJmZmJeXlZSTkpGQj5CQj4+Ni4qHhoWFhISDgoKBf39/fXp5eHh37u3s7u3r6ujm49/d3NrZ2NfW1NPS1NTU0s3Kx8bDw8LAv7+9vLu5uLi2trazsrCuq6qprKunop+fmpeVlZeOjYeDh4OCgYCAf35/fXp4dnV1dnh1cm9ubW1rBWpoaWhnhGaCaIVnEGbNzc3OysnGxMPCwb+9u7qEuBe3trSzsrCurKupqKempaOhoJ+fnp6dnIebBpycm5uamoaZHJiZoZyampq0x8K+u726qKOblZSTlJWWl5aWlZSKlTSEjJSUkHzAus+O/aifoNbZrY285bfeheTeiL2SjIiYqL9kWIZxgWd7bo56rseVlZmFpZeRgGAoOJqRSk1AUFRGTFJsM0N7W1R1P5iEU5BIcEJ/RigpQ09AOik4MkVbmcGv3JCn0oOBZC5JLi0lOYHDu8P5qZJ4QUyPv8nc7u/w8PHw8fDw7u3nkqmFhV4/vnNfQmZXO1RDSYuATIVZTlVMUWNvVTIrRDEzOSo9RVVNWW93QSZab2R6g1lXWVaHen9Gal1PgkdvYkk+TUk4Jik6XEQwflFZOjhCimxLdHVvWVhZiGp5nuaU16iKwcl5RUVPd5J8V45KYMLTwIOozN7e14zZ4eLj4uDXvst2bFpvcLaLqWdw+KbQz5rD3N7f4N/g39/e34TdgNzazL2l261zk6bfysdpkH6jl4C5vp52f3isZr6RrIzHial9oJ1lr4LI0JrVzNjVwd3e3t7f3t7f3Li505RDbpLRb1dNQU87emGmwYV43aWFYl07PjWKtmY0bkJHj2h4faWfhVRDSlV7c15XWI5XR0xefkVJ2cR1orWzx+T74NWVgL5iXnajasbRgPSIxL+aiuXM5tvvpNuRtrXzk5Xt8ZLXlMmYpqSwt1rItsyxt7i6vL6+wMHCwsTFx8jJycvMzM3NzJWShbnJu3qHrfSWnep4krF8no9hglqPm+P0hNfctqd+cpaBg41zkmxGf0FuaFZbOZZ8j6N/zWnfz2VmgL1wL059dqCKkkN8uGtdelmhqmSv/5n+3t/i5MDCxMbJyszNztDR09TV1tfX2Nna2tvchN4/4OHi4uTm5+jp1KHgl4m1yPHz8vPy9PX3+vv6+fp+f4CBgoSFhoaGh4mJiImKi4yMi4uLjIyNjIyNjYyLioqJhIoRi4uJiYyMjI2Mi4uKiYiJiIeJhoCFhYWEg4SEg4F/ffXy7et3d+ro5ubn5+Xn5+Pe2dfW2Nzi5ODc2NKmw5WkxsbBvr6+vL67t7W0tbOwr62ur66urKyqqKmpqainqKmpqKempaWkpKOjoqGgnp2cm5uamZiXlpaVk5KRj4+Ojo2Mi4qJiIeGhYSEg4OCgID//v78+2D59/bz8vHv7ezs6ujn5eXj4eDg39zZ2NfW1dXS0dDQzczLysnJyMbFw8LAvr28u7m2s7GvrKuqqaikpKGfoJ6dnZubmZiYlpSSkI+NjY2LiomIh4eFhIODg4KBgoGCgIGGgFz//v38+/r5+Pbz8vHw7u3s7Ovq6efm5OLg397d3NrZ2NfW1NTT0tLS0dHQz8/Ozs3Ozs3Nzs3NzM3NzM3MzMvMy8vMzNTX1tXT1dPMysjGxsfKy8rKzc3OzczNzYXONs3MoK7Iyb6aqr22RG5HRlRoVExd9PTC71JqfkuRooaMlI3iUzVIQFFAYUxcHGXyc2NzOUc9PgV9fn5+fYh8AXuGfAF9hHsJfXx8e3x9fXx8h30MfH19fXx9fXx9fX59hH4BfYR+CH9+fX19fH1+jn8Dfn9/hn6CfYR+Bn19fn1+fox9in4BfYd+g32Efoh9Cnx9fH19fn5+f3+FfgJ/foV/hX4Ff39+f36FfYV+AX2EfgJ/fo1/hn4GfX19fn5+mH8lfn18e3t9fn18e3x8e3x+fXx7e3t6e3t8e3t8fXx9fn18fH19fpJ/AX6KfAt7fH19fHt7ent7e4V8BXt8e3x8iXsEfHx7e4h8BHt8fHyFexZ8fX1+fn18fX18e3x8fX19fn5/f35+hX8Wfn19fn+AgH9/gH9/f4CAgH99fX1+f5iARX9/gIB/fX1+fn1/fn5/fn18fXx7fH18fX6Afnx+f3x9fH1+fX18fHx7fHx7fH19fXx9gH98fX58fHx/fn19f35/gH99foR8DH19fH5+f3yAgH99gLiBy4KEgYKC6oHrgOl/BX5+fX18h30Rfn1+fn59fX59fn5+fXx9fn6EfYR+A31+foZ9AgIEAEjV3K+ly4aMx9aEfJ646JKYioWMy4yKhqis+L/Q54eu+cq3r8Cgv8+IdJhomKGEeH9+z9GPsZB1w2+jjJC0s3lYvHmAv39VdXiEeQJ7eoV7gHORtZqih8ituaWq1eeZpueA/ofRsdfm7ZCI+urBvsGbpq3thef7geOZuJ2A2ITQ58f/4r+F6ZfE1suoj77H/KbY/LPKsKuMhJ6ForOYmNn2mr63ncvfn5ec0pSm49C5j6V/qtzexbbEgeuiidHVXVl1aWKwdXRzcmtucG9wcHBygFyN4rSle4t8ysvD4NKgaHR0c3JycHBvcG9wb29vcHBtaHCsYWlne4yyb11Ja6N+X6FsnF9XXoibvZaZb1yOZpSvdri7zHOxVkxmUGF1dXNicHh4d3J5emdUg1VPe5ODm4C91ouIqIHVxYtiebXls6ajhoipyqB5fPGxtsLhv5u6gLeJnZmPrXypkJq3x6iglojNhKP00Yvdj6zGv2qPX22Nunt4nqKJrnK1etV+epJgX6qjraueq3x+icKHjLXLb7KdfIlyasN4gZF2eYGCgoOFhIaJiYqMjI2OkZGSk5WXmp2hv7nEqcq1naeZv3+536yRp6nPq6Nx3nHOi3jNfsGBQbl1eHFziKyAdaqHwXW9fm9/sfi674XY6HrlgrnPsudyho/Si6/QiW/i3IHRzLOHxX3ChuitfpCwuLWyr62tr7GyhLGAsrSzsrOztbe7vbu9wcrGxMbIzdDT1tXBrpK5j3vJwePh3+Dh5OTk4t/e4OLk6O57gISFhoaFgH97fH1+f39/gYOEhYaFhYeGhYKAfn18fX17fn57fX+AgoSFiIqKi46MjImEgoGBgoSEhYiJiouMi4yKiouD+eDm49ze6eXY0tB40tjTz9HU1dXPzM3My9Haycq9mZmRfp2popWRjIqKj5OQhoSCgoWMmZydnI2QjYaCgYeIhouRj5COjIuJiomJi4uKiYmIiIeHhoWFhIOCg4KBfnx5eHl8fH19fHt6d3Z2dHFubdvh5OPg4d3a1tPT0tDKyMXFwcHBhb+Awr+7trOwsLGwr66sq6urrqyopqSmqKmjoKChoKOuqZ2YmJKMh4F9d3Zyb3Jvbm1tbGxsa2tqaGdmZ21wZmFfXVtaWVhXV1ZVU1RTp6qqqqmoqqmrqqmop6empKKioJ2bm5mYl5aUlJOTkpGQjo2LioiGhYSDgYGAfn59fX59e3qEeQR6enl7hnojeXl6jLCeenh8frPWwLiol4qHfnl1c3JxcnN0dHJxcXBwcXGEcjZzbpNni7GPjtm3vo6MotvJm9Dbr3mkt3N4zW5023DkgY/Lv4WJdn9eg6WnmoqRp7yZvsP6i7VL292lm+GJltnliYOfp5JyjoBkirJ5fI14l8SovsyDo+TOwLjar8venYqSc62okpOVlOrNosimgMuBtZmcqt2fbMOCmN+bbJ+mpqiohKl+qqqqp5Gf4rSliuWNiniHpqFqdq1nu1yPgKCsum1prJmNjo5ueH+nXqq6Yadxi3pduWaeqpTAp4VitH+kp5Z+cJiTvYCkx3mWiH50ZG9id4V2bKnJfY+LdJmjdXN3oXGLyr2rm8eMvfDDx66gfdudkubwc22QhX3TnZ6enY2ZhpwPebbwwLyRq5vmzMf22sCCkJuAlI2a54KPjqrH2YuCZJPlqIDajMWDeYC8x9yirZF7vYW924zT8+2P4XRkhGl/mpuYgZOdnZ2VnZyEbKhtZKWtqc+37uqvo72p98uigJvGxJvM37q8+PLDno7KwuH8/uqt0dGivXSNuo/Ola3F0MGeeWy8VnHjznLjntjx5nymb3yApt6Nkbzhr9iB0o/0gYSkbG2/tr66qsGUnZ7YkpLJ5XvLtY+af3fkgpWrho6Ympucnp+goqOkpqepqausrK6vsLKzs9XY2bDVx7C2qNSTzPbEnLG+4868hP973ZqC1YftmtGGh4mLocCgh86l65Dkn4mU0v/Q4Y308Yj2isHMw/4hg5Ca3I2s2ZGB7c6B5Ne5isKCzInptoGSqrS2ubu9wMLEhcUyx8jJycrLzc7Q0tLT1NnY19ja3N3e3tnFupm/loTtyOvs7O7w8/T18/Hw8vT0+PuAg4WEhxeGhoOFhYeHiIiJiYqLjIuLjIyLiYaGhYSEC4WFg4SGh4iKiouMhItcjIqHh4aHh4eGh4iHh4iIh4iHh4iC+urt6uPk6ujf29rc393b3d/g3dnX19XU2NzNy7+eoKCMprOvqKSgn5+jo5+Zl5aVl5uho6OimpualpORlZWVl5manJqamJiEl4CYlpaVlJOSkZCPj46MjIuLiYeFg4KDhISDg4KBgH59fXx6eXfu7/Hw7ezp6Obj4+Lf3Nra19bV1NPR0NDPz87KyMXDwsHBwL69vLq6uri3trW1tLSxr62tq6ywrKSgoJuXlJCNioiFgoWDgYGAf35+fXx6eXh2dnh5c3Fvbm1raglpaGhnZ2ZmZsuEzIXLKsrJycjHxcTDwb++vLq6uLe3tbW0srOxr6+trKqop6alpKOioaCfnp6dnIWbBZqam5ubhJpemZqZmaKzqZmZmpu0xbm1rKWenJiVlJOSkJKTlZaWlZSUlJWUlJWVlZaNwYW03bSy+dLqpp2+6NKs9/rYjcfjjpb4gYT8hP2TouZ3SGd/jWiRu4BZbm1teF2SrMF4p4CwsE13ukc9Y286P0RJQjVAUD9YfVVof0xael9dfE5kXkhJMTE5SY6YnJyHcElBpKa7t2lCTSwgNEmzg2BP4tuCd1181ayK3Orq7Ovs6+vq5+nq2qhl1lxKWvpsWU1demJCQnlGhDpVTXaAk1NPWjIrMikvLi06KWl7QnFPZEsoN4A2cnpnkXtcRottfXJZTkJMRGUpYW8vRz41PDY5JD1POTxCUzxWVjZhbFFTVnZSa6OWnJemUq7SdVFpUEihTnq0toOEtqmawNzf3+C02eHi4eHf2pvPdmNygbWiyYqesJLAp9fY2dvc3d7e3d7e3t3d3NvJvNX8n8jF4uvGjqqIwYDjlmercbKjkZmXnseDjLKR1H29xVObzati2pKBkpSz19nVuc7a3NvP2ti5jK+IicmDT1dUZmdKTlJOkJSRiKeKfmttdFlZdYZyVWJ+Znd2kcNudI+gu01AW0poVF5hb3N1UE2RMkGjk0+ee7zb/pmVi5qu0X5Nc3iTsnKkfLt0nYDTjIzy4+riy9VZX3zSmZ7S64HCppqvlIvaV3CumqaztLe5ury8vr/BwcPDxcXHycjKysvLy+rOwsXuzVqqn75ix/2hp6m98LKySpeL7Z2S95eqj+RrXGh4dXuRSo1Za0d2UUZHWmKAuJPuv2TiiLKPi61ZXYXmlLnXSmShsWSWcU5fcF5Bj4nztoaas73AwsPFyMnKy8vMzc7P0dLT09PV1tja2trb3d7e3+Dh4uPj3sa0m7aWhNjI6ens7e7x8/Pz8vP09vf3+X6AgIGBgoOEhAeFhoeHh4aHhYgGiYmIh4aFhoRehYSFhYaHh4eIh4aFhISFhIODhISEg4KCgoGAgIB/gH+Af3zz7Ozq5eXm5eHf3t/g4N/h4uHe3dvb2tnb3c3Jvp2ksJesvry5t7W0s7Ozr6yrq6qpqqurq6qop6akooWhgKKjo6SjoaGgoKCfn5+enJyamZiXlpaVlJOSkZCPjYyLi4qKiYmHh4aFhIOCgYCA//79+/r59/b08/Hv7u3r6ejn5uTk4eDf39zc29nW1dTT0tDQzs3MycnIx8bFxcPBv7+8u7u6ubezsa+sqqimpKKhoJ2enZybmpmYmJeWlJORE4+Ojo2LioiHh4aFhISDgoGBgYCE/zv+/f39/Pz7+vr6+Pf39PHx7+zr6uno5+fm5eXj4eDe3tza2djY1tbU09LR0M/Oz87Ozs3NzczNzczMzIbLGcrM0szKysvL0dXQz8zJyMjGxsXGxcTIx8mEzITLOszMzM3Mr5NUj/OYkHtloUo1OGWDY3Bmb6PvrHBCSyIqZG92cqvBVCNipLWIsPd0NygfODkrXk1FNFyEfRl8fHx7e3x8fHt6fHx8fXx8fH19e3t8fHx7hXyFfQp+fn5/fn59fX1+hH0Dfn59hn4Hf399fn59fo9/in4PfX1+fn19fH18fHt7fH5+iX0Ffn19fn2EfgF9iH6HfQt8fHx9fHx9fHx8fYd+gn2Efod/BX59fX5+iH0Gfn19fn19hX8Bfo1/B359fX1+fn6FfQF+lH8Ufn9/f359e3x+f358fHx7e3t9fX2Fe4J9hXwIe3t7fHx+fn2PfwR+f399inwFe3t7fHyMewF6iHsGfHx7fHx8iHshfHt8fHt7fHt8fHx9f3x/f318fX18e3x8fXx9fH1+f4CAhX8Vfn19fn5/f35+f35+f3+AgH19fX5/mIAsf35+gH9+fH5+fX1+fn1/fn5+fX18e39+fn9/f3x9fn18fX59fH58fHx7fHuGfBR7fn57fH1+fnt9fH19fn+AgH59foV8Cn19fH59f4B/f4CmgQaAgYCBgX+RgcaC74HkgOx/hn6GfYJ8hH0Ufn59fn59fn59fn1+fn1+fn1+fn+JfoV9AgIEAIDDu8G0lXf8gLex3fDF3+G3lpqDh6OD9pqmgpqch7eBu5vF09KewHfXvNGB1MunX2lpquDMdIqGfJKbhoWSkGtstci7vXR4enp7fHuGfHx3bHV8dcienIqg2cz3saWV6NqXj7CO48uxkp/hgYmGkLGqopC8q7mk+Nbo7cXI8vfisIC7naDhj4TdrcXKu/H++I3y/K/djfeAnNXSoN2B+5OE0ti2tsy38ZuAvZTV39zmkI/g366sl9Cp2IKt6ICnmd6Goaurc3loc3Z1c3JxcnFxcXJyZY1ydJbKmpuZnp/oyNqFq2RzdHJ0cnJxcXBxcXBwcXFsnmiCrGxxbWdMdWRnSIBZkoNgWn1RgW+hb7+1hah8d4pue5hWY46YdF6AZnZajU9JSWR7c2KAjmabs7CNb16FqvWMq8BrhcSvcXWOwIuvdJTaYZrAcnaws4uFp8K5xLlmfWrcmrbQyq5wnZPXp42Q8PKwiLGyrNJtzZiIZLZ4nbSLqId6xXii1on4yW+vaIBgsWypcXeTu4B6c6LOdq21fXh/v5vHu57PhI53g4uMh4aFhYaHiIuLjI6PkJGUlZecnp+goYqml4ewznjhyY+teLGSi32eo5uNom+GncyrfX98mGmci6m2d8RsyceNfp2UjaWCteRzsYDAfuOnfoPDx3dqiODk0r/Vj8vh1YmKkFi0kN2u3JjQ/8T45oOzs6+tra+1ur69v8PHxsjM0dfWy8/e19vf3dTMzdHU1sLXvJnQgKV+pYGO29jZ2tba2tnX19rc3d7f5Ors7u7u8Hh5d3l6fYCBgoKBhIJ6gYKEhoSCgYB+fn+Cg4SJjpWWmJCRkpCVmJ6fnpiXk5CLioWDgX19fPb39vj39vf6+u7m29XU0NDR0MrGxsjJysvP1Nna1NDOxLairbO6mMytop2ysqyjjYyEg4KBfnp6fXx+jpCcnI+VkoiChnp5e4CHi4+Pjo2NjYuGioSJgIaFhYODgoB/fn17eHd1dnh8fX19e3d1c3Jw3tvZ19nY19fV1dTU1dXTz8vNzcXFw8HEwLy7vLu5tbWzsK+zsq+vrK2wsrCwr66sqqyso6GirK+zr6mbk42Mh4F8eHRyb3FxcG5tbm1sa2tqamloZ2ZlZGJgX15cW1lYV1dYV7CsO6yuqqmpp6eop6epqKenp6Wko6GfnJuamJiWlZWUkpKRkJCPjYyKiYeGhISEg4OBgIB/f319fHt7enp6hHsBeoR7Hn2Tq7ukfIWYpMXEs6aSgXqCe3Z0cnRyc3N0dHRzcoRxOnJyc3R1dKDHsYSYkY+Bq6SLmLOOc6O3oIt1vm51b7iNknDafXeQ1Kh/dWuW1MC5tK+Xl4fQ4c6YzJSAx7idopuH/4XA0evxr7nmrI6RYXWObe1scmOKfXiyebyf3drwr8+H9s/jhOXfuXF/gsvu5YCTlYidpo+HiamChc/q3ueaoaamp6edpamqm4iSppXlpqmXoPjKwoZ4aaqWcGB/ZKeNemdzq2FmYmeAgXhph4GHer2kr7eXnL6/rYFNiXV1qG9mooGKoZC10dFzxLWCo3fJZX6ypnasYL1oV6SjgJKoi6VwXolpm6iiq3Jxs7CUqpTNmMx+ls1ynIjRlbnQ15Weh5Wenp6dnZ2FnBSGs4+SpO27vru5tfzU6JnLf5aamIacgJucnJucnJLQhKvhkpqUjmefiItjfs+qjn+ha6yS1JX02JnAmY+Zi6nNdIWrtIRwmH+bdbRmXF2BnZF8p7eBxvDSuZB4rej/v+HegpHh3pOlotSm656S2IPJ/aOt4NCZm9Xqz+P1gY+A4ZaY8OTLgbui4r6cjsLGfl6wx5DvgPS7gKt33oy60qjAkorlirW/d/rYfcZ2bcZ6xH+Gp9SSlo289IrI24iNkta14suy5ZivhpKbnZycnJ+fn6KjpKanqKqrrK6wsbKzs7OXtKeVv9+E7uGcwofKraeMt7Gznr6EpKfes4SMjLWAsZi2yYXeg+zkopTGt6bPlsnxgMOLxYj5YbiFgtHdhoKd9/HattWb0vPdj4yVvJDiuuKc4f7a9ueEtLe6vL6/wsbHyMnMzs7P0tTX2NTW3Nrc3t7b19na29zI5cea1IWogLeKlOLi5ufn6uzr6urs7u7v8PT4+vv8+/2EgICCg4aHh4eGh4eIh4eIiYqJh4WFg4OEhYWGiIqNjo+LjI2MjY6PkI+OjYyLiYiGhYOBgYD+/f39/P3+//3z7ufi4d3d3tzX1dXV1tbX293e3tnX1s2/r7a4vJ/IsailtbWwq5+dl5aWlZOOj4+PkJmZoKCYm5mUkZOMi42PkpSXmAaZmJeXlZSElYCUk5OSkI+OjYyLiomIh4aEg4GAf4GCgoKAf358e3p58e7s6+vr6efm5eTj4uHg3drb2dbV09LRz87Ny8vJx8TDwcDAv769vLu7u7i4t7a1s7Syrq2tsLGwrqqinpqXlJGMiYaEgYODgoB/f359fXx7enl4dnV0c3Jwb21ta2ppaD1nZ2fOzMzMysrJycrIyMjHx8fGxsXEwsG/vbu6ube2trS0s7KxsK+urayqqaenpaWko6KgoJ+enp2dnJybiJpgm5qampuirrarmZ2lq7y7saugl5SXl5aSkZOSlJSVlZaVlZSUk5OUlJWVlZPH88+euaKpiMTClJ2znYjDybmslO2EkIjFlLeH+pWQn3mMkYh+sN58bqO7hGhYgZuki7WUgH11XX+GRWA3Ypqcdlppj1JKUz9OaFHTRU06RTpBTDdFMDkzODo9MXxktjtJS2uFjqrWYUAoMDArYXQyLzOGj5vK28Hbydzj5ubiwsDm5bNxk9Wjxl1USID30ZJcUENoTkYwVUF3XE0+VohLTUc3NysrLSQuM0BadH+Hb3mUkoNZaV5QU3tWT3RZYoJuh7eUOYh8XD4sTSQnYGQwOTBJMzE/UTc1MkBcMDNXRWV1b3lSVYiGcn5yVESPQlVZRl5TeZ++2OXH2bHJ3d/f3+De4ODf3tyxxIORXMHb2vDZ0dWdp5vmoc7W0tnb24bcgNvc2cnbpIz0wdXNw47VusCImcOLcpPfitWw3H62sYa8qrCUh5qygHeu1JqRvY/Uo/qNgIGz1samy+mw/fezqrqahn2MUmB1SUlQS0d1fqBetlVjcDpqdUZYfXBcXXB0am2ORkE2sGVTdHVoRlxPemdkYoKQVTlvgVuOXrVfi4r6gGvR8Y6HfGKPV4OCW/zvi8aNi/2S1Zieru2UVkZxwnfEsX51faGw6OjFnl18k6awsrW2uLi6ury9v7/BwcPExcfHyMrJycmowrCcxuNx2uacnnSpm3pvpaywooBLirvyz5CMjpJof3NqZUmEWXSNUjprbWeUOVZQPGV10m6Qi3xsasPMWFeT2MPUutZ9tcnOcHIwXU+LYI5zr+Xc/vGLvL7AwsPExcfIyMrMzM7P0NDS09PU1tbW19ra2tvc3d3J58qczYOofqlzlOHj5efo7Ozt7ezu8PDx8vX3+fr6+/x+f3+AgYKEhISDg4OFhAeFhYSDgoKChIGEggODhIOEhIKDhIJdgYCBgYCAf359ffn4+Pj29/f39e/s6ebl4eDg393a29rb29vc3Nzb2dfXz8O0tra6nse1rqu7ure1sa+rq6uqqKSlpKSjpqampaOjoqCfnpuam5ycnZ6fn6Cenp2chJuAmpmYl5aVlJOTkpCQjo6NjIuJiIeHhoaFhYOCgoGBgP78/Pr4+Pb29PLx8O/t6+vp5uXk4+Lh3t3c29rZ2NbV09LPz87My8vIyMfGxMPCwL++vby7urq5t7azsK6sqqimo6Ggnp2cnJuZmpmXl5aUk5ORj46NjIuKiIiHhYSDg4JCgYCA//79/Pv8+vv5+fn49/f39vX08vHv7uzs6ujn5ubl5OLi4ODf3Nvb2tjX1dXU09LR0dDPzs7NzMzMy8zKysvLicoXzM/LycrKy9HQzMrGw8LExsfDw8XEyMeLyTjKysq9qaFPS1tDQUCi0y41ip9YSUdWp2ZiP0M3NjE0Q1BbRU8vRYu3m+T1WEyw1WY9KzJGWjBNSAF9hHwUfXx8e3x7e3t6e3x8fH19fH18fHuEfQN8fXyGfQ5+fX19fn19fX59f359fYp+gn+Efo9/i34HfX1+fn59fYV+BH9/f36JfY1+G39/fn5+fX19fHx9fHx9fX18fX18fH19fn1+foV9CH59fn9/f35+hH8Gfn5+fX18hX0Efn19fYR+kH8Ffn5+fX2FfgV9fX1+fpF/BH5/fn6FfyR+f39/fnx8fH1+fn19fHx7e3x8fX18fX18fXx8fX1+fX1+f36Hfwx+fn9+fX19fn58e3uIfA17e3t8fHx7e3x7e3x8iXsKfHx8e3x8e3t7fIZ7BHp7e3yEe4R8CX59fH5+fXx9fYR7D3x8fX59f4B/f35/f35+foR9D35+fX5+fn1+fn9+fH19f5qAg3+GfgV9fn1+fYV+C3x8fX9+f39+fnx9hHwJfXx9e3x8fHt7hXwlfX19fHx7fH1+fX59fX59fX+Af35+fXx8fX19fH19fH5+fH6AgKKBCYCAgYCBgYF/f5eBt4L2geSA7n8Bfoh9FH59fX1+fn19fX5+fX5+fn19fX59hH4JfX5/fn59fn19hX4FfX19fH0CAgQAgLPmh395s5TYxJCorKuQgeqshYaUhKit+daThMvph8eZtN2HttWngHi9dbi+c6C4k3/KyJqxiKjH8oKzzebWc4abuoJlenx9fX10r9Z/f2qVtNOKmN6MhafAyOGx/sfAjJW255LExqi42eHyhvXJm4+LoY+Di6y9yc3Gx8Ha1ezbTNXNgYX6x5L375Whjb/7oJT7tcbtwaHOwZTD8IaNhpingKyas8r/hKTohOGA+4TLwbzN/Ojcmqfaj7P7h5mfrnhynnK1e3d4d3V1c3KFc4BtcKCGh8NioZ+cXbmfjZp+foVbsnB2dXRzcnFycnFxcnRxg2+DimpzcXJuaHFsUFtoeaNclnFRYG6gf6OVanJkYV98hXCYdJFfa5WcdGZSZWaUZ0x/b3WukIOrgG+nVt7Dv3eVgsLGfIxmYoaruGSriLrDvWl+c3trd5+pmaPGcYCqa26j1KB93tSHiJ+Wkpf5i/HGi+q3kryjoL+zs4KolIat1oClstX9rZi5jrO1mqiUnJSJs36Pf6Npg4+UpJZ2kXuzsYWDl+ORoJiPl5qbnJeWko6MjY6OkJKTlZibnqGjpaalpoeoeNzG17uQh6ypc8+i3XXlepWkrnmOhryW1oClh85/isGb07t7g8asw4OxrLCOtrq0kYtxzm7jfNR72uB1lumnmpif96bErp63e76Lx/bv7n27is2QoJbCwb+/vru/yMXFzszAx8HGvbiysLq8v9na2NPZ4OGfq4qFkYajw82XxJ/X1dXW09XV1NTV19ja29vf4+Tk4+To7O/veoB9f4GDg4SCg4SEhIeKi4yKiIqLi42Tl5WUlZWThoOChY6OkJCTkZKTko+Mi4mHhYOAf/38/P2AgYKFhoiE+fDk39zZ3ODi39vc2dnV1dre393X1Mm6u760m9XNvrqqurmupJyVhYOAhIWIi4qHhYmJiI+Uj4aCe3l3dXR1gYaQjhyJipWIgIiIh4eGiImJiYiGhYKCgoCAf317enp3hHWAdnl5eHh57uzt6+ro4uDe3NnZ09DQ0M3NzsvIx8TGxcTAv769wL+7trS0tbOztLOyr6+3t7S1uLSup6upqqeyta3Auq2blIqGhH96dnNydndzcW9ubW1sbGtramppaWhmZmRjYWBeXVtaWlxeuLi0sa2trKimpqanpqempqelpaRHpKKfnpybmZiYl5aUlJORkZCPj46MjIuKiIiGhYWEg4KCgX9+fnx8e3t7fYF9foGFfH2Ij6OZlIeApqentLismouCe3d1dXWFdAFzhHQ+c3NzcnN0dHV3eHaxmHrEloGDiHh3eG+a5srCsLqzyGprzK39bLtutqSMpcKQcZR6m+PWY3x6yarFltzXhtyAquuDjobCgNzOpL5zhJuG2aGBdnNvnJ2tjmpmrc13upWwypC/4ZqQh8yCvsWArtaqluPWsMOZrejzgbnd9e2Blq/Nj32ipqenqJHS66Sqiq3Z95qu85iIt7eisIerkoFiZXmgapGZeoeip7Jjs551aWt6ZGJfiJmZoJiZlamjtaRKnJZgZLuTarm9bYJxj8+IecOWnsalhZyWdpS3YGVlbnlng3WPqNJkc6dbqF62YZiRjpvHuLWFoM15kNNxho65iIPBh+Kdl5qdnZ2HnBaTiM2sr+N5x8KscdfCqbeCgoxz3ZGbi5yAmbGChLqOmpmZlIyZkm16jZbhesaUaHqNzqbOpnyNf3+BnKaJvJa2dIeXg4iCaoGBuIFeno6b7Lmh06mX3m3/4N6Lq53/8pypi4LAw++B7KbU9OyUvbKqjIS61MW74oneh4nC0paT7/iVn62tpZHve7t1bfWfnt/Fv+Lf0prMtqKAwvmcxJ2x9L+szp3Cw6y7pbCyntWZqZ2vgIywvcmwjqmIy8ONmbL0q7Wmlp6ipKWjpKOjpKSlpqioqqyusLKztLS1s7KSvYz/2ODFp466yIrsu/OA/oKgvcyKkpHAnebDmO6Ymsyl6+CTnObF5JvaztSn0MzMnpeA2YH9hdGQ6fxWkaL4rJ6Unfq4zbyev4C6j8L04+2Mu47Ym6uWu77AwsLBw8jHyM3Mx8rHy8jFwsLGxsnW2NjW2NvZoLeZkJSOs8nRpNqj3N7h4+Lm5uXk5efp6urr7/KE8wj3+vz9gIGDhYaGB4eHiIqLi4qFiA+Ki4uLjIqJhIKBhIeHiIiFiV6IhoaGhYSDgYD+/fz8f35/gICBfvTw6eXj3+Dh4d/c3Nvb2tvd397b2NXNwL68t57Nxr27r7m3sKqkn5WUkZOUlZaUkpGTk5OYmpaRj4uLiYeGhoyPk5OSlJiRjZGShpGAkI+OjYyKiomIh4aEhIOBf359fX1+fn19fPb19PPy7+zq6ejm5ePh4N/d3Nza2NbU09HQz83NzMzKyMbEw8LAvr69vLu6vbu5ubm3tLGyr7Cus7OwtrOsop6YlZOPi4iFhIWFhIKAf35+fXx8e3t6eHd2dXRzcnBvbWxramhpatFc0M7MysrJycjHx8bGxcTExMPDwsHAvby7uLi2trW1tLOxr66ura2rq6mop6WkpKOjoqGgn5+dnJybm5qampucmpubnZqZnqGppKKcm6qpqrG0raOal5OSk5SUlJOGlECVlpSUlJOTlJSVlZWR2rmN5aWHj5CKioqCrvq6ztPn3vuFge7E/4TWieC7l5vnqoOskpGGvW+If45lemicuYnNgFatd5xyVy5PXWehOUCCYZx4YEZQS1pfcV1DPE1ZNUhRPD4lQFozJidAMzc9LpHvraWef1VDKzFGVCM3Q09hSE91jD6C0N3i4+GYna3K4pJEkPJjUWBaVZiReX5faVZAMzU2XUBodVFddnWAR31vRi8sJycsLTxnb3twc3B/d4Z4am1pRkqIaUyEk05oXXWWIj92cFxrSyMxOTItPCAfKD1KNUs2NDlZIixYNmU+eEJsZWZtkYJ+V3mnTEl0UGU8pHVez2r+2M/T3N3d3d7d3d7c3Mhp7MDSspfq7MaS+Ou+ymxbVo36wNfY2tqF24DZ2NjRzHFjsbbT0tHLv9LGk5OSgLuM/8aPqLfOod2FiKismm1sh5jtxPaYspdwoK+VtrT5noDSs3+cxbWXalv7hsKIcENVQoFyN0dIUbWCakJviX10gENMPTxJVl9rYGNuQWs5M5VcO1CKjE5bYl1hZKBTi0RMnVxSe4dpX3r8oUKCj5VqjY64fX6yinLJrLDhuOjKxbml1HqOXGJPV4KJl4+BnHikxZidmLCBqramr7GztLa3uLm6u7y9vsDBwsPExcWFxoCktILsre7KmZa/oH3rlv+E7I2vqY+Hn5LTrPCPaqZuZVpLlLKDeWlfiF6NhoBPSkddTGSAz0+WXsF4y89zjPi2lZOftJONdWmBQz5EiY/IamC1ktaCrZq7vb/AwcHCw8TFx8fHysnKysrJyszLzNDT1NXV19SernNmh4WTv8mPxiOf2t3f4eTl5ubm5+jq6ert7/Hy8/P09vf6+X5+f4GBgYCBgISBCIKDgoKBgICAhX8vgH5/fn59fn9/f35/fn1+fn19fX59fX17evXz8/F5eHd4eHh26efk4+Dd3dzc2diE1zDW2NjY1tTSzMC9u7acxsG6uq+6uLazsK2opqWlpaSjoqGgoaCgoaGfnJybmZmXlZWEmAOZmpuEmISXgJaWlJOTkpCQjo6NjYyKiomIh4SEg4ODgoKBgP/++/v5+Pb18/Px8O7t6+rq6Ofl4+Lh39/d3NvZ2NfW1dPT0c/OzczKysnIxsTDwsG/vr28urq4urm3t7azr62qqKelop+fnZycm5mYl5aVlZWTkpGQj46MjIqJiIeGhYWDgoKBBID//fuE+VL49/f39fXz9PPy8vHw7uzr6uno5eXk5OPi4N/e3dzb2tjY1tbT09LR0NDPz87NzMzLy8vKycnJyMjIycjHyMnIyMjHxsbHycjIy8vIxcLAwMHChMSFxYXHPMbHxsbGx8bGvOXCh91dNllYjVoyXr2OQ0RDYkBJLC5KMlMoSC9uOS04ilyv3Jh8UbeSsZ1XOFNGYVxiew99fH19fXx9fHx9fHx7fX2FfAl9fHx8e319fHyGfYJ8hH0Ifn19fn19fX6EfQV+fn19foR9hX6HfwV+fn9/f4V+AX2Hfod9iH4Cf36KfYt+E39/fn5+fX1+fX19fH19fH19fHyGfYZ+hX0Ifn5+f35/f4CEfol9BH59fX2Ffo5/hH4GfX9+fn5/h34Cf36Of4R+iX8Xfn18e319fn9/fnx8fH1+fn9+fXx8fX2EfiB8fH1+f39/fn5/fn59fH19fHx8fX57e3t8fHx7e3x8fIR7AXyFe4Z8hXsCfHuFfAN7enqGewd6e3t7fHt7hnwdfn18fX18e319e3t7fHx9fn1+fn9/fn5+fX19fHyGfQx+fn59fn9+fXx9fn+bgB1+fn19f39+f359fn59fn99f399fH5/fn9/fnx8e4V8BH1+fXuKfAN9fX6EfA1+fnx9fX1+f3+AgH1+hHyEfQl8fH1+fX5/f4CggQqAfn6AgH+AgH9/moGzgoSBh4LpgeaA8H+DfoV9hX6HfQh+fn19fH19foV9An5/hH4MfX9/fn1+fn59fH19AgIEAICSy2+v08+ijuSZxc2hruCe+f6Q2qXm8uHopueEib+rp7KrxonsxIrAnLuxo3vprL9x18vE7NjXpdOgpKnAtICMkYHxqst0f4B3xnuOfHl0f4V7xLy859Ry0baw3J6Dj5Hcl9Tt+96Qqs6lvLeww6CThPXtgaKGs7Wru9e5vLa5z3vS2NbehYin7ITCkrqEtZOrt/uN6cnN3r+D+o+ikoiGtazT3cPLppiGwrq9/6jwm6yvqIigspSix9f1m7+2y/Xi3dBbfX17enh2dnV1dHR1dXV0Y3JxcsRndrFlXZWUgYP483x0kZRsd3Z0dXNyc3NzdHV2o29/g2JwdHSEc4BckrlcXVNhqVptbmBZgX1jqWWceV58ipxuX155ZW+BuYFjmoFjT4OXlJN2snN9ZIGXi6DbnpF8bl+0tarUbYJfgXyKfqWFrXmRcGS3wdO8qLOdnLlvj7ejhG2wjnyYeJnX98Wn37/hiXHAj6fDz4jOuMGk//vGgImHp7ypqHqIkYB8h5Pfi7aCuKjOwIfIvcmyiHHLnq2iiXmPmXOqfZKQkZGSl5WPjY2OkJCRk5KTlJWXmpyffbPEpnzNdIJ7zZqUb63Jm6SXmKmFiLl4xoiCoM3W3Nyvw8zdp5ejqtOTvKOafIWmfa6Ymayfybum58+cjYDPxsebjN7e9pmAo4G88ICxq9ug0dit7tboy9GIw8nAvbazurW2u8bAu7S1tK2ppaOkq7bI4eDc29PR38rXtcF9nL7nprjE1NbS0NbNzs3Nz9HU1NXV2Nrc3Nzb3uHj5ent8/d8fYGFiImOkJKVlpWQkZKSkpCMiYWEg4WE/P6GhYSGio2SjYWEg46HiYqIjYCNioL++/n7gYSFhoSGhYL9gPrr5uPe3d7c1tLT0tLU1dbZ2trZ2s3O2aeNvsjWvsbCuLKtp6CcnJWXl5mbn6GfmpWSlZWWkYN3c3FxcG9zfH6AeH+PjH97iYqGhYeIiYmIh4aGhIOCgYGAfnx6enl4dHJycubt9fTw7uvs6efh3kna19PU1tbX2NPY1tHRy8rMx8TExMPCwby7t7W0s7Wzr62tsLGzt7K4wbSppKOrr7CtpKaxqZqSi4eCf3x5dXNydHhzcXFwbm1shGuEahlpaGZlY2JhYV5cW1u1tre0r6yuqaenqKemhKVHpKOjo6Kin56cnJqZmJeXlpaUk5KQj4+Ojo6NioqIh4aGhoWGh46GgH9+fXx8e4eKgY2WiIGHppCPh3+BkZyYmaCjmIyGfHiEdQN0dXWHdIZ1OHZ4eHe+yXp2YoCc5IeLu9O6iOKMgM+a0YqKn7nEoLCciIx+b83Gin96j53mnKxwiubf0IuU16R/gJ/UeaWuv5GS7Iy2lp+q5pvT7Zype83SmZ5rv3RqnKSSm5m/h+29lsKnxJetgMar24Dhyr/57NS/zquju8/GiZyfifXN+5SoqJfsgauelY+Bn4/T2Mzvxn20j4undV9laaRvori8p3B7l3aHg32ZfnVqvbVlfWmEhH+KoYmOiYmUQ5mhnaNiZHexcJxqkGiQgJGYznTMoqe0lGW/anZmaWePh6OvmJ9yaF6He4C6fa51hoZ8ZneBe4y3sNuMg46z9Nzp7XKEnoCdnZ2cnZycm5ubmYCVkJHVfJHMfHCoq4iS/fOBh62xipydnJydnZycnZydnNiQjKt/lJqamZmalnrB9Xp+b4Dlc4iOgHinknrUhNSwjpaexH5zcY13hYfJm3q+qINks9K9t5vjl6mClpyTufOSmIyKgNfT3vuMu4Swp7KY3rXpqYCph4DU1u7VvMW5s9uAi3CEloTbpoSnibTEyaGNf63PhoXJpMHi/af0197D9ePIjZuh0+XAu4mTnYqUn/Gh1JvPw+3doNXc9NGgfdaswbObi6WuiLiGmpydnqGjo6Gio6Slpqeoqaqrra6vsbKLy9i0juqBjYDkpJh9ze20y7WwrHWGkbl204yPr9Hb7PvL4Orkt6PAveW1+r2ykqzTmMqtqcO26bm19NGRj4bU38ufjeLP7aKIpoi7+q+s4ZvN2Ln009zJ5JKvubm6uLm9u73AxcPBvr6+vLq3tra6vsjT1NPT0M3Mw/PR0YSnxNqlzc7R2dra4N2E3kfh4uPk5efq6+vs6+3w8/T2+vz/gIGCg4WFh4iJiouLiYmJiIeHhIKBgIGBgPv6gICAgoOEhoN/gH+DgYKCg4SEg4D8+vn4fIR9Dn59e/F47ujm497d3tzYhNY819fY2djW1NLGxcqmjrfBy7vBvri0saynoqGcnJ6en5+fnZqXlpeZmZSMh4SDgoGBgYaIiYWJkpCJiJCQho+Ajo2Mi4qJiIeHhoSDgYGAfn17e3r2+Pn49fTx8fDt6+jl4uHg4eHg4N3d3NnX1dTU0s/OzszLysjHxcPBv7++vLu5urq6u7i5u7awrq2usLCuqquwq6KdmZWTj42Kh4WDhYWDgYF/fn18e3t7enl4d3Z2dXRycXBvbmxramjR0dBZzcrIycfGxcXFxMPDwsLBwcDAwL68vLq5t7a1tLSzsrGwrq2srKuqqainpqWlo6OioqKho5+dnJubm5qanp2anqKcmpyqnp+cmZqgpKKipaiim5iUkpKSk5KJkwGUhpM4lJSUku71kox2mrjnhJPX7dmO7Xht6rz+o66wvuaqybCipZCC6dKik4yvkdmJnXt955edWVWEnYOAYpeBmn5pNzREO3JJRqL1mIy0i3FOWVZda0B0MS89NEo9NkpBbUpCTFpEPTNDg36GYXRvaJxGPy5HLzc0OjomLkdIVqTnst3fusVRoMKkmUNle4VPd7twiZlmYnNLNzE/aUpzd4N6VVNoTlZTS2RUTTZYZS1RSllYV2FxZGdkYGNKZnFuc0dJU39dfEdqVUI2LzJhNVhjYEc7JD09STIrS3FshYt0dkU4Hjw8RHpNd1VlZ1hIUFFVTnRyjXJAYF2cl4WMgtbY2dnb29uE3IDb2dnTpce9wvGVu+2gkqGsa22gjUNel6q119jZ2drZ2tnX19bT94NdfJHG0dDOztDKn/L3jZGLpv6UuLOKlL+Uhvio3VpIZY3mkJmQt5iaht/RqvzUmoGx3suVdPiEhmVra2JobklUPjpBcGp8o3RzR1BMVmeIbHtKUjU+dGZtbIBiaWVsfT89N0ZQUKhzW3NZi4WNamBAcoBGWG1JW22No7KYm56ejbKDeXuXssLUkZ6+hqzA+abXeX9w1dR5foqXtZuC4Ke+oJh9oapzw5Sqra+xs7W1tre4urq7vL2/wMDBwsPExJng88WW7nyWityqqYKXjp+ima28lZrDgtuYg26y5u7x6H/Nu1d4Z6Oy3nTAkpaBh4VPZ0tIWmLIuaboqHh9hNLDs5yW4dLon3BSUnCWblh6YpSye3/Csq60fKu1t7i6uru8vb/BwsHBw8PCw8LBwcPDx8vNzc/OzcSz0ZmDUoGfyJOvws3W2Nnc3oTfGuHj4+Ll5unq6+vr7vDx8vP19/h9fXx8fH19h34QfXx8e3t7enp6e3r083l6eoR7A3p5eIV5C3p5enl47+/u7XV1hnQN43Hg397b19fY1tTU04TSGdPS0dDOzcDAw6CJr7jEtru7uLW0sa6rqKaEpRuko6Ggnp2enp6bmJWVlJSSkZGSkpORkpSVk5KElICTk5KSkZCPjo2Mi4uKiYiHhoWEg4KBgID//v38+/r49vT08vHv7uzr6uno5+bl4+Lh397d29vZ19bV1dPS0c/PzczKycjIxsTEwsLAv767ubi5uLi3tbS0s7Csq6mmpaShn56cm5uZmZeWlpSTk5KRkI+NjYuLiomIh4aFhIOCgQyA//37+vj39vX19POE8Tnw7+/v7u3s6enm5uTk4+Lg4ODd3dvb2djX1tbV1NPT0dDPz87NzczMysnJycjHx8fGxsXGxcTFxciGxBDFxMPFxMTBv7/AwMHBwsLBhsNAxMTEw8TEw8PDxMTA/fa+s4qQdnpNVHBRlIyENSs8QEksP0FLSDtEOj1OLy6Kf4zBuJdLR1mooHXtVUg2NlyRhBJ9fH59fHx9fXx9fHx8fX19e3uHfAJ9fId9hnyEfQV+fX19fo19hH4DfX5+hH8Jfn5+f39/fn5+hX0Ef35+foZ9jH6EfQR8fH19j34Hf39+fX19foZ9Anx9hHwDfX59hH6Gf4h+g3+HfoR9AX6HfZR/Bn5/f35/f4R+gn2Efo1/hH6Jfxh+fH19fn58fn9+fX59fX59fn18fHx9fX2EfhB9fHx+f35+fn99fX18fH19hnwBe4V8Bnt7e3p7e4R8hHuEfIl7BHx8fXyIewF6hHsEfHt8fYV8AX2EfAR7e3x9hHwbfX5+fn9+f399fn18e3t8fX18fHx9fn9+fn59hX4Bf5mAhH8dfn5/gH5/gH98fH19fX5/gH9/gH5/fX5/f359e32EfAl9fn17fHx9fn2HfCN9fH5+fH5/fn59fX+Af4B/f358fXx8fH19fHx9fn19fX9+f5+BC4B+fX1+fn+AgH+AnYGZgoKBlIKEgYiCAoGC44HpgPB/CH5+f39/fn18hX0Hfn1+fn19fIx9C3x9fn9/fn59fn5/hH0Ffn99fX4CAgQAgMXkftvDwMigmeKW9pOnvMmO66DBqqnc7I2WxfTyypbPjpu/k8WDp4mDoouueYyu17/Z24euiZd5i6/Fw5CbdoXvzc2ToGuAfHR/yZ3SsrHccqetyJe4reqmnYy/+4vZ/46RlJaQ/tb7hMLWwbvRto25iqzS9cnf6tTE2c/Jw7OugMDJ1cTV3dTyz7eHg5iZzdq8lMWmjtyHxtv5z6OxjtbX0OX4jtn41ouIj5bOy8u52oP979z9u7HLooKxyrr9k+LXw2h9fHx6enh4d3Z3eHd4eHl5eXt8dY1xl5KyXaZcnZKB5bbXdpx0dHZ2dHR1dnZ2dWuMdYZrmGV3dXJ0b3RzgFWPh6lzUVxrjY+gjH6wa6lagXFhaqVklmJoYWaPZFKSsmygbmiRgXCKqKSFq2+hjY+ofZXen6hopWFlboWXbrhmn4pyY4iarb6us850fOqacHjHhd6ZfZyBtHKvis2V+rCIi8e2h5t7xJSoz3iWj9rynZbSdYzB0YKvzWSKuoKWgHCTcs6fi5aRuYa+eW6Pn6G2jXHS2qOst9WVkmyKiomKi4yMjY2Oj4+QkJCRkZOUl5qdoMiKkHnZoJl/m8XAhHpthHO9wpSgiYmNvoqD56p3oa27g3rF3XKIt42IcMuuj7GhhHZ3xKHSioHrp8yR9L7V0qLc0JfMqKm+h4rEhq+SgLx/k9DufKLZ1v2tqpW8sKmooKCnrru7tra2uLqyrqWhpbC3xdDh2MiwqNjKpnrilsm5wcmUpOje39vW09bPy8zOzs7R1NfY2dra2d3e4eTm6e71+4GEhIGDh46OkJaVk42Ni4yLi4qIh4iIiIb//4D09Pbz+ICBgPf28/mDiYKBO/j8+vv8/f759fbx7e7t7urr5N7a19XW19PQz87Mzc7Q1Nba3NO9trSm5s/P1r3Jwrqzraahm5qamJeYhJodlZeUkY6UlZaHeXZ1dXZ3c3FydHd8hIiHiouJiYiFh2mGhYSDgoGAgH9+fHt5eHh26eXk4+bo5+Lg4uHf29vW1tPR1djV0tDR0NLQzcjDwcLBwLy7vLq7uLe2t7a1sa6rrK2rr7S7v66koqSkoqCdnZyYlJCLiYWCgYB/fnl3eHZzdHZ0cG9ubGyFa2xstclsa3FxamtmZGJeuLOyr6ypqKalqKmnpqSkp6akoqKho6Shnp2cnJqZmZiZmpaTkZKQjo6PjYyMi4qKiIiHiJeYmpCHgH9/fn19f4B/iYeBg4WGgn99foCJiYWEgn5+fXt5eHZ1dXV0dHSFdUB0dHV3dnZ3d3h4emx0fm59uuOYwsuGlNeCi42O6NuK1ICds6TX1nRyyNS1aITT1Gisvbi3Ztb8ta6Gh9XNx6vOgNfxjd6Xi5V+d7Z/0Y6NnMaN9paLb4ijwG5updSsjnynd4Cki8p/rIWInIyohoa76dPH8JnBgpqFg7PDwpypiJf26PCstYOjnIqA2rb718v2hcO/16TJs+yDeGePwG2nxm9yc3Nvw6LAZYqdiYebiGmOa3yhu5ieqpmRoJyWkYh+Ro6VnI+fpZqtlYZpY3x+oaePeqqGcLhsoKi/nH2NcKWjobHAbKq/o2RbYWKQhJiJpmK/taW3jqDBi3SpkIa3kt3k5YCcnZ6FnQGchZ2EnBSdhqCJoqzLcbVwuqOM+9PxgLWXloWdgJycnZuMvJmYkMSCmZiSlpCWlXDDseGSaHqKsbnKsKbuh+aAr5eHgdl+unl/dXq0gGewv3nPkZG+s5DB0dChzIbItZ68iX+hqe+IwIKOl8DtnPOF2LWcgb7Z6uzbvt2NjvWAg5rzhLiTjaud35HWpfOT3ZiYlXOrZauO1afC84qwgKDHz5+Z+Yaf7fWPzvBxls2Oqnuhfu62o6yk0ZLZj4exvcHPooL37K3EyO6so3aWmJqcnZ6foKGjo6Skpaaoqausra+xsdyjq4f7w7iJqeTZlZmGpYvS1q2qi4yXw4iB7bJ6nKfJk4Pg7oaZyaahifHOpdW9n42L57PvkpLgsNCRWem66O233cGSuZ2nwYaZxouzkMCAlsfmiKHR1f+ps4+wr66ura2xtb29u7u8vb67uLOwsre7w8fQzL6ssdjevYf4k+TIwcONmNjZ3N3e3t7b2tvc3d3f4uXmhOd+6uzu7/H09/r/gYGBgICBhIWGiIiHhISCg4KCgoB/gIB/ffb2e/Lz9PT2e3t88/Px83x/fXz29/X09PTz8e7v7Ozt7Ovn5uPe3dnX2NfW09LR0dHQ0dPT09LKt6+wo+/ExMm6wr65tLCsp6KgoJ6cnZ6dnZyYmJaTk5aXloyEhIIKgX9+f4GBhYmLi4WNgIyNjIyMi4mIh4aGhISDgoGAfn59fPb08fDy8vDt6+zq6Obl4uHf3t7e3NvZ2dfY1tPRzszMzMnIx8fFxcPCwL++vry5t7i3tri4urmzraurq6mop6amo5+dmpiVkpCPjYuIhoaEgoKBgH59fHt6eXl4eHd2x9t0dHZ1cnFvbWxqX9LQzszKx8bFxcTEw8LBwcDAv76+vr29u7q5uLe1tbSzs7Kwr66sq6uqqaioqKalpaSjoqKoqKeinpycmpqamZmamZycmJmZmpmWl5iZm5uZmJeWlpWUk5OSkpKRkZCRiZIDk5OShJM1g5STgpLg/6zc6paZ4I6XnGfW5aP0kLrRw/T0ioPz/9SCmOHweM3RurZywr7CtnSIvW+JjcuAY3ZEa21HRS86V0dyeX15qGmUUFQ+Um54UUlNdWhJPlI0MFZSjkVuQTtEMD9xa3J1VURVSHEyLSA1Qj44LjcqK1ZGTURgise0lkZLltydWGZislJjgL+y/V1NN2KETX2WVVlYWVWWd5VMWWpWU2BWQlBEUnKCaGhwaWJraWxuZ1iAY2ZrY252bHlqZFNHWEg2PTEmSEpQXS1QX1tYXW1Ogn6Ai5lUh45oMSQuLFE/Zll7RYmEdHtca4llWKNkXW+HydyLnNDT1dfa2tvb29rZ2NfX1tbU09Ghw7GYo+eNsIXAoWy3lplUq8vJ1tfX19bX1tTOu9dzV06loc7JucC9x8eAleLZ/b6LmLHiyMvFs611lWVyV1JO2aL2oqqfnvCliOnXgO2Ogo6EgJyu26LHiLekhXRFQ2p0fUBuWVZocYJKVzNZX0tIbGtvcmdvdz1Ab0qEotJLWVBBYVpxcJ9twXSQcIlpQIs6T4G+aVyKSWZWdYl/Uq2PtM+gUpDngrP3qKuAjL+A7ZaHdHrbmbVdQWCbqsaNd9v1sqzB7JCthKirra+ys7O0tbW2uLm6u7u9vsDAwcHC9Z6qlPOoj5Ss2MCbfU9iTtbUqLmbmaPRlIrysYWmtL5lgI2YYmeTm3hUj6OZrltSQF1uRHpFfc6QzoTvwd3WpNfFk7mckJQ7WWUyTlBUYl1AsqBUjZV375+Zja+xsrO0tLa4ury8vb29vr69u7q7vL7Cw8fHuqmu0seoZ59RoZ6ztYKNztHT1dja2tnZ29zc3N3g4uPk5ubm6Orr7O3u8fPzhHlqeHl6eXp7e3p6eXh4eHd3d3Z3d3Z16ut16uzt7ex1dHXo6unpdHV1devr6efn5eTj4uHh4uLi4d3c2tjX1NHS0tDPzc3NzM3MzczLycKwqqmd6bu8wbK9u7ezsbCtqaampaOioqKhn56dm4SaCZmVkZGRj4+OjoSNAo6PhpAZj4+Pjo2NjIyLiomIh4eGhYSDgoGAgP38+oT4gPbz9PHv7u7s6+jn5uTj4uLh4N/d3NzZ2NfW1NPS0dDPzs3MysnIxsXFw8LCwL++vLm4t7a2tLSzs7Gwr6yrqaempKKhn56dm5qZl5aUlZSRkZCPjo2Li4nj+oSGhoWFg4KCgYD+/Pv59vb19PLx8O/v7u3s7Ozq6uno5+Xk5OLgQODf397d29ra2NfW1dPT09LR0NDPzs3NzMzLysjGx8bGxcXFxMPDwsPCwcLCwsHCw8LCwcDAv8C/v7/Av7+/vr6EvwTAv8DAhcGCwoTBNZ1dc6G88r1bX5ldUnhFgnMtS0c2UTNOUkBHRjAsfIZRU2VxvpPebzVwg9qSjaAyLUYvVHOdBX19fn18hH0DfHx7iX2IfAV9fXx9fYV8hX2CfoV9g36IfQd+fn19fX5+hH8Cfn2EfgV9fn59fYd+BX19fn5+hX8Efn5+f4d+hX2XfoZ9hHyEfQF+iH8CgH+IfgR/f35/hX4MfX1+fn59fX1+fX19l38Ofn5+f35/fn5+fX19fn6Mf4V+iX8QfX18fn9+fn59fH19fH18fYV8C35+f39/fn5+f358hH0JfHx9fHx9fXx9iHwLe3x7fHx8e3t8fH2EfId7Bnx8e3x9fYV8BHt7e3yEewl6e3x7e3x8fH2EfA99fHx7e3x8fH5+fHt8fH2Efw9+f39+fXx8e3x+f318fHyEfQR+fX5/hH4Bf5iAQX9+fn99fX1/f359f318fHx+fn5/gIB/f4CAfn6AgIB+fH58fH19fH58fHt8fn18fHx9e3x8fX57fn9/fH99fX5/hIAFfn19fXyEfQt8fXx9fn19fX+Af52BC4CAf35+fX59foCAoIGZggOBgYKFgYOChIGEgqmBAYDHgd+Agn+KgPB/CX5+f39+fX18fIR9B35+fn19fXyGfQV+fXx8fIR9EX9+fX19f359fX5+fn1+fn59AgIEAIDjmHrBk5ycvaXTlIqeicx9gcd8oYXUmK2HweSmvJzO77/up5Pre4ON/ax52p+0is2W1dR+iYWYjKm0u5iDiXyGetl6goS8cMJ7iZ52i+WAenuO13modna0htDLtMDqhOiJlv2Ai/7pg4bu5Obgx8u6sKS92MLzi/XO1//LwaOXr0mzw9Xs4t/n2OnnwJOA3qucn5qnl8eSk67mhbnc5JnMtJSdioKtzYOGjoaUmKrL3PmR5vOL74emkt6M8Nu69fn6yd2fcYikcnx7hHqAe2x1e3t2c35/eMGa5YWgfnx+a2RpVoB9j3ipZXZ4d3V3d3d4cFiAn3p7fF55cWCtW2N2Tmidk4OFYH6UmWxlwJWGZGCus5DLYGZrqm1bXIFpXWt+fbqPrG2fi3bFeIqFbaKRz2ZesI2Ibs2uYMCteYNmqaOGlHdulp2gs466oeaAlIz2t4/I8a3Nxo+Fiqt4i5i2za6v+6DGr4iajo2pmZLd2tusxH64k3rCsL2wjYeZlH6RjnB7wNZzad3HybZ0aoB6enDSfaeBenx/u59+x4OOkpGOjI2MjY6Qj5CPkZGUlpmcn6OkvNGiys+UiYGJzo7Fe4i2pJnl2JZ3d9jdd8p5lJ3Nxt7HjoqWvYGSjp3Mi216eoDRwrRw1cOCl6rurLzjksKsgLDv9aHVhpOE3bStsLf+0uGE356bqLfTmdzCsZ+ppqKZmJqepaanqq2uqaWioKKnrbG3tqexmKiGnbGks6mqv26uzcjf5t7m6OLX2uDZ1dPQz9DU1oTXgNrd3+Dj5uv0+/Lg6Pf75Nfd94OFh4b/8e709fyDg/2Ag4H3/Pz39ff19PPu8/bp7+zh3+fz9e3v8/f78/D07uro7erp6OPj4N3Y2djV2NPS09DOy83Q0dLa28aMpsyuvsLFw7q6trKtqaKgnJqYmJiWlZaWlJOQjI2Mi5CUlI+GgIODf4CAfnx8fn9/goiLjIuMiIiHhoaFhYODgoB/fn18e3t7evLu7Ovo5OHf3+Hi3t7c29za1tLQ0tTTz8/MzM3PzczGwsC+u7q4uLW0trW3trWysbCvrqyqrbGopqOemZiWlJKRj5CQj46Ni4yKhYOCgH16eHd2dHV3cm9vbm9uUG5sbG7NlrPf02xwdHBrZmNjv7q4ureurKutsbGqpqOkoqOjoaGgoKKjn52cnZycm5qbnZqWlJKSkI+OjYyLjIyMiomKipyon5WLg4GAf359h34df39/fn9+fn5/f4B/fn19fHp5eHd2dnV1dXR2dneFdj13d3ZzYnp1dHmy1HhtdKl2fsR/mYbohuS0w9F2vGpwb9C2tq2ilpt7unuN3pm8rZmtdmugoqCm1aOzhonugPqvjthmXWuQYoRwcJeU1oWL04ilZ5aBlXGWpXiBcpu6nbuBfOeGgn3ssoDip7qU0Kbu8YyTf46Yl6aznIqejpCG+JKXl9mE5INooIii8JiMkJPtiKOAg5lkn5uJlbdmtWt3yWZvy7praa+traSPkoaHeJCjkbhouZudwJWReW2ASYCLl6ynpKqeqKOGbGKyjHd+dIVwrGlwhMBojKiydJuJbnloZI6jYWVkXmZkboyftmqltGavYH+XyYHrl4ipxdqr4q2DqcqQnp6EnYCcipadnJaRnZySwK/6mq+UjZuDeIFpnZurgMd+m52dnZydnZ2RdKrZjYeeeJqOeuB2f5ZmidC9pal6nsK/jID8u66BguDxo/h0e4LShW5vm4FxhJeT1KjAibyxn/mXo6GIyJ76lYnvdmWG4uuD+/u9xYXRxrDAo4jZ0N32qua8+YCVcK7GptvcruzcsJSZ1pGanJGnmbL9XoSZi6mgosOql8rF/tTxj9utjOC/39alnKWeiqekf4bf/oyA9OnuzI6DoJSThvOTyZqPjY/ZwJXajpmcnZ2enp+goaKjo6Slp6mrrK6wsLHQ9cP78aebj5n2tviZpunRsPrtnXqE8uJ4w4CTmMy+0sOcmqy+jaKfsOqhgZKTk/Xu04Lu3JufuOaxtM+NuqqAwPztmL2CmYrxw7Wvtv/N5Y3TnJ6hvNKd4sG2nKmrqqioqa2ys7O1t7e0sK6srK6ytbe2payWqJO3yMbWwcHYgajGx8rT1Nre4Nzc393d3Nva3N/h4uPj4uXo6YDr7O7y9vr06u70+Ozm6PZ+gIB/+vTy9PT1fHvzent67/Hw7+7v7+/t6uzs5+no5OXo7u3q7O7u8O7r6+jl5Ofn5uTh3t3b2dfV0tTR0M/OzcvMzc3Nzsy/kqTCqMm9wcG7vLm2sq2ppqGfnp2cm5mamZiXlJKSkJGSlJOPiYiHhgqGhoSDgoOEhYWJhIyAi4uKiomJiIiHhYWDg4KBgH9/fvr49/bz8O3r6+vq6Ojm5ePi397c29va2NfW1dXU09HOzcrJyMbEw8LBwcDAvr28u7m4tra1tLaxsK6qpqako6Gfnp+fnp2amZeVk5GQjYuJiIaEg4KCf318e3t6enh3d9mgwfXfdHZ2dHFvbWxB1dPR0M7KycfGx8TCwcC/vr69vbu8vLy6ubm3t7W1tLSzsrKvrq2sq6qpqKenpqalpaSjo6qtqaSfnJubmpqamZmEmISXAZiEl4KYhJcGlpWUk5KRipBBkZGRkJGRj4t6ko2Lj9fxk3+FxIiL44qplfCX8KfX2YXogYSD+dzB2MG3n4zglZ7ys+Oqn72GeoSgpJrbrLVzhNeAVzg3XDMxPD8uUFZXnqqqQFV/QXlAY1hgU3lqSE1KXWtiWFFUzHZfPGqYcrWefj1VP0g8JjQpOSpARTUvLjgjKyhDKS0nf2Z7RjhPQDxbRXJpSWthYYmbfUJuaVpphUyKUl6YTVacklRPfXd4b1lbU1dLXG9lh0yEZmuLZ2daT2FIXGFqeXl1dnFzc14/Ols+Oy0zMjBGQzo6bE9qgH9TeWdUXk5NdYA3OS0kLzExTVF5SG10RXg+U6CtcthfWGqBsVNdsFN+qLbYhNke19a2y9XUyb/Rz76+wLSGubysyqaPnYC3q7RRw5nQhNWA09LRv5e8lUQ/hZPMr4LvhZrDh6vnzdLJnc7Yoq+T03F2SEyTm2fcg56r/aeTkM6rma3JwOKajF2Bdmj5p5TIo8+QlklLgUJLanqLRZmMaXE8UE5FWEQ9aWtvf0ybpYJKQGrepc+ManRma1ZXe2Jobml0bIazPF5rW8y7jHVwcoGAdHmVq3fYiXewdqzCj6fEupypsJGd49N6WY61zIJSP1ZTUGWjfIeEd3F6jG1w756pq62vsbGxs7W1tba4ubu7vL2+v8DA5+5/wN+fl5ec43XpWnatj6f/8qOEiPrwgdGdo9zN38pZWpBvPFpga3xsVHhscVyOZj+FbGQ5aKuotc9RjsCtgHfc4Ze+fYdkn11eeUF5pJtay15dkk1ogdXAs52srq+vsLGztba3uLi5uLe2tbS1t7q6uaWql5Npp8C2q5CPlW6dt7G/xsvO0dTU09TVhNcZ2dve3t/f4OHj5ebl5urr7Oro6Orq6Ofo6oR2P+vr6eno6HNz5nNzcuXk5OXk5eXl5OPi4uDh4eDf4eLi4eLg3+Dg393b2tna29vZ2NTU0tHQzczLzMrJx8fGx4TGNMS4jaC9pce6vb23ubi1sq+tqqeko6Khn5+enp2cmpmYl5aWlpWTkI+Ojo6NjIuKi4uLiouFjICLi4uKiomJiYiHhoWEg4OCgYD+/vz7+vf19PLy8e/v7uvq6Ofm5eTi4d/e3t3b29rX19bW09LRz87NzcvLycjIxsTDwsLAwL++vLu4trW0s7Oxr66urq2sq6mopqSjoqGfnpybmZiXlZSTkZGQjo2Ni4n2rHXE94OEhISCgYGA/yn9+/j39fPy8O/t7ezs6+ro6Ofo5ubk5OLh4N7f3dzc29rZ2dfW1dTT0YTQG8/Ozc3My8rLycfGxcbExcTEw8LDwsHBwcDAwIXBBMDAwcCEvwO+vb2EvEi7vLu8vLy9vb69vr6+uqyAvbauttiacZue0mtfl4WcSWhedkJDQS89JiomRzw5PE1dWUGBWEy/tqxFUuKnhkxTPTZAMzsyPHIEfX5+fYR8hX0Cfn2EfoJ9hnyDfYZ8Ent8fH18fX59fn19fH19fX5+foh9BH5+fn2Efgh/fn59fX5+fYR+BX1+fn9/h34Lf35/f35/f35+f3+NfgF/ln6HfQF8hH0Ef39/foV/A4CAf4t+Bn9+fn9+f4R+iH2EfpF/BX5+fX5+h3+Ffot/BX59fn5+hH8BfoR/C359fH19fn59fH5+hXwJe3t8fH5/f31+hX8bfn5+fHx7fHt8fHx9fH5+fHx7fHx7fH18e3t8hHuHfIZ7CHx7fHx8fX18j3soent7fHx+fn18fHx7e3t8fH19fHx7e3x9fX5/f39+fn9/fXx9fHt8fYZ8BH18fn2EfgR9fX5/l4AMf318fH1+fn9/fXx9hHwIfn5+f4B/fn+EgA5/gIB/fHx9fH19fXx7fIR9I3t8fHx7fH19fXt+gIB/fH9/fH5/gICAfn18fHx9fXx8fH18hX0Ef3+AgJuBBX9+f39+hH0Ef4CAgKeBhIKGgQaCgoGCgoK9gQGAxIHggAV/f319f4iA8X8Ofn1+f39+fn59fn5+fX6EfQV+fX5+fod9AXyEfQd+fX19fn9/hH4GfX19fn59AgIEAIB3gcVtlJWW8pTJp7Ov0Jx5l6TZn4SXsqLmvM7AkuPf6d+rirvm+c3q2Pp8r/CmqPKOv7CdyIOZlZ+R/Jy5xeF/6N3Gy9y5wpp6jo6lh5Odf8T2h27Ua+m7hJuf0q+rqL/h4fTexMy93pKbopCagM29wN3w7oqXoPnv4dPF0NbCzG23oL3Xv8u/w+jlsOWD1bOTjrm6q6mhuNai2OaH7fuF3fKBqdHZlJP+z9GLtMKFnbHa2Man+d3vp+CZ2NDr68/j/4/nh8mUdX9+fX18eWCbdX1+Wlh2dbV2frbUe2d0Z41mYGJyV11bf112eXh4hHmAaoG0mrG/wGB6aJl7jWZqaqiChmB/YLiB2GOekJSE026RsMuCYXpygV6EVY6kg3qFdZFzboaowa1vd3uNsXl9vI63lZL3vpmDa4Z7bXZfkoyn6a6fhobDj6rB3uWPiY2A4bXk35bKeoCgyI31ns1+mad8xpeRbH9tcvmA8IN+14c1wpqp2b7Ub3/BsY1wen+1iMtlmYXMvWq0kIqa07a1v6TZfX2io4OAZ5d+bcWRkZKVlZCOjpCEkYCTlZeZm5yeoKRwbqyQuaun2mrHgHx1hXdwg3rXo453eqy7qMTSi3qek7yGta+0tLisyp2QetF0ocF+ztfScqPD0LGrtNu0jZnMtr3DyeGNsrbVypymk9rKlZKVmrbnzprVkteVo5+en6CenZygoKKko6GfndeDla+vvLbi0eTaiICFkWyuaduce53rsbnp5OLd3uHd3uDg4d/h3drZ19fW5N/e3t3g5Orx7NXKy9Pj4NXQ4YH28PDw6eb4+/Ps4t/k4NjQ3N/d2Nbb49/a6ePW0dPMz9rf3t3d3+Lu7u7z69/Z2+Dn2dXQzdDR2uPc19PW0MvHyM3OzM3T2Ly3t7utxjHCvb7AuLWusKqjnpyYlZSUlJGQkpKQkI6LiYmHio2OjISAgIGBgH59fX6BgYGEhoeHhIaAhYSEg4KCgYCAfn339/Ty8O7t6ejm4+He3Nvb3NvY19bV0tHT0tHQzcrKycfEwsC+u7e0r66urK2ur7Gysq+vrq2vrq6rqKewo5ybmpiTj42LjI2NjYuKiIiGhYKDf3x7enl3dXRycXBwcXBxb29uypWa28qIbXFuaWViYL26trMPsbKzs62tqqmnoqKhoKCfhZ4VnZubnJubmpqZmJiWlJKSkJCPjo2NhosYiouMi4mHhYOBgYCAf39/fn9/fn5/fn59h34KfXx8fHt6eXh3d4R2RXBxdHJ3eHd3d3hep4dptKNxlmuNfpC3la+Ps4J/hXi8l5aQrm+wtKW/p4lsrYC4t3G5npqI0ILkk4mojITd4JSLz9/e5YCIhO6BpqWQzYeTcHpxo5uFnKHynVFVjIOufZKFY6SempaKcojF3LzD0vmHu/yolPaXy6Gk14eYjpmZ/KvD6/GL/fze9f/W3aGGnKOwfqazkN77mn3cdOKKX3d5pImAgZGrrrytnKCYrG92e2xyYJuNj6e1uWt0eberoJeMmqKPlWqFeI2ijpeNjqikfbJjpY9zc5GSgIp8k6eLsrBmr7xjprJigpuob27Bn6Jnf4lje4OenJB8t6uzlMx5p46jmpSpxH7qlOa2kZ6enp2emXe9kZycbmyPjdaGgcbpgXWLfax/d3qPbHVyjnSYhp2AnIis6sPivu54l4TBmb+DgoLUrLKGqoHzmfh9wqbBrf6BuOTtmnSSjqR8oWWqzZ+Rno2zkYmp4vbsi5edtN2ane/b+9qUuauvpZakrpO4ibGe6Prc17210oen1+Pgf2F2duyPvMCGxYSJt8mS+mmYiambj3SRl3SHe4PJbv6VjvQwm/C+0P7V4n+T49mqfoiOy5/kcK6g0+2A8LKlr+rR0d+99ZCOzcSYmoO4k4DVmZuchJ6An6CioqKkpqepq6utrq+weXvNnM7AwPOC9p+am6uOmaeX56aRiIi4t6PHyYt7nJfYpM+6wsPNxu+ul4LliLnkl/vu6oSszt6qrqzFqI6dyr/BwL3HgrXM8MyYoozO656Km5W67+Cf6J7olaSlp6qrrKusrK6vr62sqafoipmvrrQgr+ji+fiWlKSAyIDwpIKl3qar1NXY2Nrc29rd3d7d396F34Dj5eXm5ejq7e/r4dvb3+bl4N7le/Ty8fDs6u/v7Ojj4eTj39vf4d/e3uHl4t/j4NvZ2tbX3N/g3+Dh4ebn5eXi3Nra3N/a2NTR0dDT1dDOzM3LyMfHyMjHx8jItq+srqXHu7m7vLm2srGtqKSjn5uamZmXlZWVlJSSj46NjI2Pj4CNiIWEhYWEg4KBgYODg4SHiIiHh4iHhoaGhYWEg4KBgYD+/Pv6+Pf08vDw7eno5uTk5ePi4N/d29nZ2NfV1NHR0M/NzMvJxsXDwcC+vby8u7u6urm3t7a2tbWzsq+yrKinpaShnp2cnJybmpmXlpSSkZCOjIqJh4aEgoF/fn18e1x6eXh3ddSjpPHcknN1c3FubWvU0s/Ny8rJyMXEw8G/vb28vLu6ubq5uLi3tra1tLOzs7GxsK+urauqqqmppqalpKSko6Kjo6Khn56cnJuampmZmZiYl5eXlpaWl4SWGJeWl5aWlZSTk5OSkZCPj4+OjoeIi4qPj4SQO3TFrX7ayoW7gZmWpda1xKa/mZKWjOKlm6HLht7hyuHDm4vJmdfciuK9qp+7fO6YpsWZh/7okZHS4NzvgCguXVGEtZipgGNLU06OXjZWP32TNDNXTH1WZl1FgXVjZElBXZGjZF5U4pyy7oBeglM/Miw4KUYpRDBPNjZCRyxGOzo2YYh6NSg2SDk4co14n2dsj9mD6147TVJ2YlhZZXuAjIF5enaDVFlbTVJBbF5jeIWKU1paf3BsaF5rdWVsgGBcaX9rbmhodHJUe0Z7aEEsQzYxLCw7QmeQhEx/ikyAiElld4RUTX9QUThTUCw0V25rZViHenyEwmSCVHNmTFRvZd9kZoex1dbW1tXOk9vD0M+Ag7q0+XpqdZ5si6+WtJ+VnLqFlopnhsfT09TT0tDOssnzkHpph5HHnJeLyKKSgJbcraNysXvif8mUw6yVdqBbd4yTnoW0tLeVzoPf+Mu/zrfktpm51JeLa5KhuOyfuY9shX1QgH5wZ1FgYFFdRlNEZXl1aGNjdEtfa4iIUUFPWt9gjoZSe09VgpBnrUZegntvfkqmsY6oiH2CTahXRX1UkIOszauripfeq5yMnaPlgJT+gbyQlYs/b3tYUoN4dHRzp2REjoFhYTZheX/lp6irq62vsLCxsrO1tra4ubq8vb2+voGBtqXUwsDxY5VsgmNuhHBsdemwmoGLwsGr1dORhaebkIGEUU9LXWqrlZt+u2ptkU5zf5xYbI5nnqypy66LloG0vcCzyYCif5BQd1NzbbWygHhijo/AoISseNaYp6mrra6vsLCxs7O0s7Gxr++OnrGxs63lyujdhHaiaYxg56JkgcmboMTIy8zNzs/O0dHS09PV1tjZ2dra3d7f4OHi5OPh4N/d3uDg39/hcubn5eTj4uLh4N7d3d7e3NuE3GHd3t7d3dva2djY19fY2trZ2trY2dnY19TU09HT09LSz83My8rJx8XFxcPCwcHAwcDAwL+xqKeopL+4t7e4trOysa6rqKekoJ+enZuamZqamJaVlJOSkpKRkI6MjIuKiomIhIeAhoeIiImIiIeHh4aGhoWFhIKCgYD///78+/r49/Xz8vHu7evr6ujo5uTj4uHf3t3c2tnY19bV1dTT0c/PzczLysnHx8XExMLCwMC+vr27u7q5t7S0srGvrq2srayrqqmopqWjoqGfnp2bmpiXlpSUkpCOjo2Mi4mG8ZZ0remhgoJOgoGBgID9+/n39PPy7+7t7Ovo6Ofm5uXk5OLi4uHf393c3Nva29rZ19bV1NTS0tHPz83MzMvLysnJyMfHxsXFxMPDwsLBwMHAwL+/vr+/hL4Cv72FvgW9vb28u4S6SLm4uKisr6u5ubu7u7qHsXeZ9LKlo1JZkX/PdqlzxWU4QEFZQTQnPiE2QS44MiwuSGVZYUdkiFWSjz7hjnqVXS5HNy0sRExYWgt+fn1+fn59fH18fIR9B35+fn1+fn2FfAR9fXx8hH0DfHt7hHwBfoR9AXyFfQF+hH2EfAJ9foV9hH6DfYR+Bn19fn9+f5J+hn+GfoN/lH4CfX6LfQt+fn+Af3+Af35/f4R+g32FfoV/hn6HfQV+fX19foh/AX6Hfwp+fn59fX5/f39+h38Bfop/AX6FfTJ/f39+fn5/f39+fn18fHx7fHx+fX18fHt8e3t7fX5+fn1+fn9+fX5/f39+fn19fHt7fIZ9jnuDfId7AXyEe4l8hnsUent7fHt7fHt9fn9/fn17fHt8fHuEfBh7e3t+fn18fX9/f359fn9+fXt7fHt8fHyEe4J8iH0Dfn9/l4Aaf31/fn5+fX17fH18fH59fH1+gIB+f3+AgH+EgAN/fH2HfBd9f399fXx8fHt7fH19fXx8f4CAfn5/fIR/CoCAfnx8fH19fHuFfQd+fn5/fn5/kYEBgIaBD4B/f35/fn9+fX5/gH9/gKiBAYLMgQGAwIHkgAZ/fn18fn+HgOt/CX5+f35+f35+fYt+hX0Bfoh9C359fH59fX1+fX19hX6IfQICBACApr+W0pF7rIanjZbD4tr4vJOvpJSM5oroypyV1NHZxOWPj9H9hPOyjvL+gr6rrXu1mJmIj/DYjqGy1q+YpcvIlabGoYZson+PmIixtbigv3DexbjgurCsooOivKGOivn9javLxs7m4oWam4jmj+/x/9Hv8bm61aKQrpv/zMjDwfWA+M/Fssu4zsvn+tnLh6qahpa5p6aB957GkPzs46Ky4+fZrp2F8+rnmrPJ5LmXwJj6jtugy4+wupmkhci+veTFzvH/5IXx1LiBgYB/f2+gnWN4fp6kpda1cJC6rt+1iYC1dqdqa2Vzepdoe3l5enp6c29SsaVxrtpvqWN2tsF/eGSAhKx0i4xruYyQeoOaco3ChKSac2/PoIiebGN4nFx3V4aIiG6jgGxka9l6gIN2bJF8aKivkoiazqaQgshssIuPqqeXfo2WapScpLTW+M7Z69regtyefcuBvbrSzbjGy+CKxq/etdJrhXer95iOfdaLoYSKsm7DjY+Mvbm5tni5noiAfG5wkLiWyqGccXq05KSezMGbfNFqbXBrpNeKbJp3j4+QjYyNjY6Oj5GSlJSWl5qcnqGfiNd3l9SQtrmosJCpaWmAf72BmtR9sJ7LpdHHqNWIsojZeIOeeoS4wIV6uZKSbIV8g6xzeHGhhH6orbmKhrl8rvqE+KSgr5KgeNb/qamA97XNw4rHgdeUs4LvkbOZpqWnqKOhoqWorayrqqip1NztlpS8g8yzcYCviYWutn324t6BtMOPwdnY19jY19nc3drg5e7q5eDd297n7Ono6+zx7eTc3uPl5ODg4uPs7Onp6ujo7u/k4drZ2s7EwcXDw8LFydHMx8fEx8DIwcHEx9aA2tvc3+Lp6+ffz8bJx8nHxMO+vsTP1NDMwcPDwry7wMDAw8TGnrS8vJqev7y5t7m1r62uramko52YlZaTkpCRkZGQjouIiIeHiYqIg39/gYKCfn99eHR0dXZ1fIKDgoODg4GAf4B/f378+/n29/Py8O/s6efm5uTf3drZ29vZ1dJJ0c7Q0M7KyMTCv7+8ube1s7Csq6mop6Wlpaaopqirq6iqqqmnpKGioZ6bmZiUkI6Ojo2Ni4qJiIeGhIOCgH58fHl5d3V0c3JycIRvXJN5hY+zh8qdb25pY8K9urezr6+vsq+tqqilpKGfn56en52dnZucnJyampqZmpmamJeWlZSUkpCQj46OjIuLi4qLi4qKiomHhoSEgoKBgYB/fn5/f35/fX1/fn19hX4RfX18e3t6enl4d3h3bKWPtWOEeD15empws4lqs5p0yq5xenJ6c8KAfnCq9KJ3dd2UlMCswsyJtX+h5X+EyJqvxIKFdbSGbtS8wKy4mpWgm8WugMnhsvaWiK2Vvpubk6ijucSHq69fbdJzxJ94ZIRwiXubZF6fz3HPm3/O3HCUkZaDx6KdiIrS26Cor9rBqbbjtKS5ua2cgbOOm7OdxcTTrdeE9N7L36GihXZkgJF7bmvFu26Dm5yfsa9nenprvHHBvcOjuLiQkbCFd5J9yJKSkY+3gLmbj4OQgpaRp7KWkmeLh2x7i4B7ZdGJlmXDyL1/iq+1rYZ5ZrevqnGIoLOGd5t1uWulc5hhgIx5hlyNe4WXiY601c6K4/DfnZ6enp2LwrJ3kZi6w8T50oeRzcDy1ZqS0obKhIZ+kpq1gp2dnp2dnZSOau7akdXLhtB6me7ZqJZ8gKrSmLaqgd+nrI+mvJCw8pfAw5CB9buUvoR5lcZvlWmdnp2BxaSLhI/3j4uIlJDCl4fi386faJGEqpn4lOjHz+fOwaeurI+6uMDNyNzk157C0G+bpZnTf7apwcOqnYv2reWT8m3id5ODntWVoov0nbOZqdyK2aSpotzd6+KR37eZgJN+ia7Wru/Wy4qMt/m8t/biupDshYONhsDrqIOvgZmam5ycnJ2eoKGipKWmqKqqrK2uqpXme5fiptfd3OrG1oiMpav3ranghsmi2qPKwKTWh7aN/omSrIiX29+kkL6YoYCbkIrDiIeIr5GLsreqe4C3ian/iumWnLSap4PZ76mpgO29wMaFyYfal8KQ/Jq7mKWnqauqqqusr6+uq6qnptv18JCMrHzLvIKTuJWVub2G9uPrgaO2ibnQ09TU1dPW1tjY2t3h4uDf3t7g5ejn5ufp7Orl39/i5OTi4+Xl6+vr6Onn6Oro4d/b2tvX0c/R0dDQ0tXY1tPS0NDM0MzMztDXINnZ2tzc3+Dd2dLNzs7Pz8zLxsXGycrJxcDCwcG+vb+/hL4worCxrpSZtrW1tba1sa6trKilop6ZmJeWlJOSk5ORkI2Li4qKi4uKh4OCg4ODgYB/hHwDfXyAhoOAgoKCgYGAgP79+/r49vXz8vDu7evp6OXi4eDg4N/c2tnW1tXU0tDOzczJyMfGw8LAvr27uri4tra1tLS1tLSzsrKxr66trKqnpaOjoJ+dm5ubmZiYlpWUkpCPjoyKiYeGhIOBgH99fHt5eHd1nICQnL6V2qZycXBt2NXS0M3KyskqyMjFxMLAvr28urm4uLe3tra1tbSzs7OysrGwsK+vrayrqqmop6alpaOjhKIUoKCgn56dnJuampmZmJiXl5eWlpaLlVKUlJOTkpKRkI+Ojo6By7Pdd4yNjo6Pjn6N1quH3byQ+tWGkYyLi82Yk4G367GJgfupquTZ3fyQuZSsv5Sj+MPU3I5yhMWTgObWwMHEnZKypL/QgDJAO4RPf7ufvqJBTV9QYWY5RUUvJk83eXFUQ1RCWE5oSTyEq1uHUjKBvWFnY2BdflwyLStBTiouPT8+NDE1NzAxMSwnJWYpLDYxUFJkiph6qlRt0G+DRjY3V2VUTkuKb0VbbXJ1hYVOXVxPjVaMjpV9i4xtbopsYXdikmJnZmGJgIl1aV9kXGtkcHtjXjxUQz0pOTc7MUwoODGaq5lhaIaQjGxiU5OIhE9ZY4BNWHVRgE54UmM6TV5WaEFUSVdhWlhqkZyPuWTT0tPT0tKz0bKPv8fK1NXDsoqBjIHQ94dsh1/0rLGlwMqxntDR0tHQ0MK5hvLcqKBuXOidrbKsqMGBgITCcpl7W41reHjB0YyWjGKFr2ZT4p55romCouCRvYnL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x8jIycnHv7u8vsK/ubKxtr6/vb21uby3pKC2tJOht7Stp6anpqShoqWmo6CclZGPkJCQj4+OjYuKh4WGhYeIiIaDgIGBgIF/fHrz8e/q5Ol5env19Pb5+Pr5+ff29fLy7+/t6+ro5ubk4uDf3dvZ2NXR0tJtz83MysrKyMTAvru5tbKvq6qqqKeno5+enZ2dnp+ipKSjo6KenZ6dnJyZl5WTkpGRj42MioqIiIeGhYSCgYB+fHt5eHZ2dXJxcHFxcY67dsjuvZSNeLDNxsK/u7i1srGvsLCurayppqakoaCfnYScLJubmpmamZmYmJeYl5aWlZOTlJKRkZCOjYyMi4uLioqLi4mJiIeFhYWDgYGBhYALf39+fn59fn1+fn6EfQN8fHuFekd5cZqNeIBseHl6ent3uMKPrJ2xx8iWoL67tLCJmsjBq5WRzr1/ms/Jo6ey0cR03oiEaXt7nHSY13uOj4x2fbi1uJOKvNWzpIDIm7etjL+gjpKnjfnt7/+Zi4Xesf+Eg7aUiI7KlWprnJdeYItxs2Wfls2iaYyDgfX41ZyWluaCl7LHpr2Vnp+CmaiUqt3d57GP/e3HntyUgPGPxsRwbcBxiLWbwYmBq6Wdfaxnd4Jxy7fAn3uNi4Cfrph/fGyxumZ9h5munYOmsoB9ZWqytq2lYml3al+mhHCVcYdlXXB8lceLsaPGY755n5u6tbuypIZpermplcJynJC3rpp7X2VgsIWakItwf4aOmJ+aoY3clJydnZ6Zoo2Rg6NsnZrQp4+RjNK64+nCxPCKe5OcmpudmZOcnZ2cnJyTdbnLt5Gj45L724eln4uafICK5faZpuqlz+bch9XJmZTM8/2i49PW0LXyk7KhfZmbnYOxYZmI04x5euOSwrfViZu6hoS44/yimZbJspDiy6Gvv868s9jY6cuonoeLnaGEvGKTsa77k+t96KSZg6mqy5mKtpuGoKWB45G5vebae7jR3NPE3o2imrK5gP3O/aKTxICVldmO76XxzNDUjr2jwYuH8Y68s/nEq8Ps/MSX9XaXmJmZmpudnp+hoqSlpqipqqusraqM7Yx7vJb17eqJu9HknJOh3Zmbkt2NlLmExaOGo4nci5uroZGQj6yEn82B4b6L/aeLkIqs57uVlNiU5nqdioaSuZeDyZiZ+qaZjubLsYDVn9KjtoCqqLfdno6Wi5yhoqSmqKmqq6upqKalpKecmML0xJ7Jz6aCqIKboaPQlJPIjdyuwMTIzM7NzM7Pz87Q0dXY2tzd3t/e3+Dg4eHg4eLj5OHh4OHg3t/g4eTl5ePj4eHi3tnY19XW1c3HyMfHxsrPzczJyMbEwsPHxsTJzgzP0NLT0tPW1dLOzMqEyT7IxsC/v7/Avrq3t7m6ubi4tra1tKWjsK+Pm66vrqurrKyqp6empKKempaTk5KSkI+Pj46Ni4mIh4aHiIeGg4WAgH99e/X39/Ty9n1+fvz8/f39/Pz7+/r4+PXz8vDu7ezr6ejm5eTh4N3c2djY2NbU09LQz83LysnFxMPBv768u7m4t7WzsbGwsK+vr7Cvrq2tq6qpqKampKKhn52dnJqamZiWlZOSkZCOjYuKiYeGhYOCgH9+fHt6eHeVyIHQ+8SZJJeBvN7b2dbU0s/My8nIx8bEw8HAvby7ubi2trW0tbOzs7KxsISvKq2ura2sq6qpqKempaSko6KhoaCfn5+enp2dnJuampmZmJeXlpaVlZSUlYSUV5OUlJSTk5OSkZGRkI+Pjo6NhKushZ5/i4yNjY2J3Nuj1rnZ9O/Bvufq39Kku+3bvKmG3tOFrOn11cvh/9KE5Y+OiJObuIms+ZiqpqOLkbnAxp+XzOG/vIAxMkJCRbyVW0VnL1JpVF5KLzVPPUYfNFRTVmycflNXbGVCOGRUfkZycpZ3RW9QSWh3cTsyMEkgK0ZAPj8sNDwsOzEmKD85Oy4qXItMPnRBOo1WcKs9PXI7OlVReWFXblZFT21JWWVaoIuRd1djYFh3fmxdXlGJhUxdYnODcVp7f4BgSk+Cgn51SE5aUER1UUBVOTU5LiMxOVRacXqcS49dfn2UkpaMhG5QUoKFZ5NcfmpxYVlFMTo5ZlliYVU+S0ZUU1xudHr3ws3Pz87GpXt7aKKEk36BVVKji6RjpLd1V5+Cm73KyMrNx7zP0M/Pzs2/kuXYoJWnvj6M1V5vlKvGkoBrnK2ng25WcJ3anK2obWOFm82Bj3+EgnztkMnIosPFyavigMSU5K6TktSaz5uZfZCLYV58xP+dXWjokUh6eFdnYW5nYnVygmJQS0tPUV1cgD5dtL/lZphYoG1qVnKEmId3g2hbjbCW867ay/DThaaelI96Zl58pq9vMYWFj1llloBRcI9y3ZZ+Z2NaNkU2UkpIdkxTRVpVUm+PmJ98/YGlpqapqaqrrq6ur7GztLW2t7i5uLWU/pGEumyxpolPcnB5bGeIbmtjcISHm7SGyKaJoIzmZVRaeGBIVnBOUK6E0qJQjEtASktp44dJd8SA3XyfhIeDnYWEzJJ+11JkUGK1pVOgZ69Yr2ufj4qlZnaQip2ipKWlpqipqamop6alo6WZirzcrpOsg5tna0yHZHW9hHW0hs6jt7m8v8DBwcLDxMXFx8jKy8zNzs7P0NHU1NXV1dbV1YTUFtXV1dbX19nY2NjW1tXU0tHQ0NDPzs2FzibQ0M/OzczKycrKycrKy8zMy8zLysvLycjFxcTExMXEw7+/vr69vIS4Ebe1tbW0tLOypqSwr5CXrK2thKwlqqimpaOgnZuYlpWUk5KRkJCQj42Li4qKiYmIh4WEg4ODgoKBgIT/gP7/gICA/////v3+/Pz6+vn39fXy7+/u7ezr5+jm5eLi4d7e3d3b2tnX1tXU0tLQz8/NzMvKycjGxcXDw8HBv769vbu7uru4uLa2tbSzsa+urKuqqaipqaempaSjoqGgnp2cmpmYl5aVlJKRkI+OjYuJiKbReLj3zaachNT9/fz8RPz6+PTx7+3t6+vp5+fl4+Lh4N/d3dzb29rZ2NfX1dXV1NPS0tHQz87NzcvLysrJx8bGxcXExMPDw8LBwb+/v769vby9hLsBuYS6iLlRuLi4t7e2t7a1tLOgfXxagZexs7S0tKjlm1qempN9VDZudU5GQS49VDsxLjBGTS4uSEc+OUFNSChVRDUtOz9TO0JIMUdCMzJCPzIwJiM2Rjs3hH2Hfod9EHx9fX59fXx9fHt8fXx8fH2EfBB9fXx7fH18fHx7e3x9fX18hX2CfIp9gn6FfQN+fn2FfgF9hH6GfYJ+hH+OfoJ9iX6Df4R+hX+Dfol9hH4Cf36Kfwh+fX5+fn9/f4d+jX2CfoZ/hX4If35+fX19fn6HfQF+kH8Ffn19fn6GfQh+f39/fn19foR9C3x8fXt7fHx7e3t8hHsFfH19fX6Ffxt+f359fH5+fnx9fXx7fHx7fHx7e3t8e3x9fHyUewd8fH19e3t6iHsffHx7e3t8fX58fn59fXx+fHx7e3t8fX1+fXx9fHx7fIR9BHx9fX2Ee4R8BH19fH2IfAN9fn6WgCR/f3+Afnx8fHt8e3t7fHx9e3x8fXx+f36AgIB/fn9/fXx8fX2FfAZ9f359fHuEfBN9f319fn58f4F/fH99fn6AgH9+hH0QfHx7fHx8fX1/gH9+fn5/gJCBhIASf3+Af31/f319fn1+f4B/gIGA/4GkgYaAg4HtgAl/fn59fX5/fn7mf4R+h38BfpR9gnyHfQR8fH18hn0Dfn59hn6JfQICBACAqIeOcnaidNG8wLybzIvW9ZuN4HKttdK7qYzikLWIppjtsvut4bm1sbGLyZL5i6u93rmFmePdmIK7wNeq1bOivJrmd6GLtc2Y2JCPiJvVxnuUvazBm56DiKamsODZv8nB2IL02829g7zR9vz3g46D9ayrjJysiY79hYKpxPPU3bJl09mD/oCKg/mHi42Rkui6ut/bzp2ozdaAq+WH4OOLhZGbvtrFgb/7qcXI/YezsbKOhYGLqoiGgLPlyJ2XhaS5nKLFrceHqrttgWl2gq/GvNJhioPTorWnsNXfyZy828vhp4KCgYCEfoB9fHx8e3xxVn6CicPCrsXhkm2OmGRnkWGmrmCPyuKQoVemfr92qJOJsZadj5SAdbtwjodxi4uDo6l+r6W5kqVZg6KJepBxX2eOutmIXm34oKFfooFha4iWnamdnXl8lIp0qbyBq7DruJ96nnyM/5CT2Z3Ri6GnkPzCiuvgsoicdoCkba7DgXeTiY/uksaFq6KomnLYsdt2lZR/a3mTd89pc393f3Gvz52kv5udgHx7Z7qRz76dgIqJiomKjY2Oj5GSlZaXmJubm56ho46VpqqIlWltnKWelXGfyMJvcnanrGqRu7fGm43UenWEvoB2koJ/lZyOh6z5ytHAcnaHfMDUroDOh+x6uoTfy4GtpcK9qdnQ8+PA3oe3o8WLz4/V9Ynsjqemp4TomJaUlp6foaGjpKOmp6qng9Cx6fK66vnX0OGTjMO0nu+5kJTrur/EwMHCvrvAy8/Lx8XAxMrR1NTY2dvc3drX1dTV1dnc2uLj393d5Ojm5uXo4uLh4uPe1tbW1IDU0c3HyMfIxsrJwL66s7GvrKmwrKqttL3Kzc/Nx8nSzcjBvbu5wczMy8K2sq+ztLWtqaittre1srW2trefr7Dkr6C1r6Wem5ycm5udoJuYlpGMh4aKkY6Mi4qIh4aFgoGAf3+AgH57eXn19/fy7urn5OLd3d7i5eXl5unu7vD08DDw7+3r6+ro5OPh4N/e29nY2tfW09DNzMzLysrJx8XCv73AubGrqainpaWin5yamJeEll+XmJyfop6ampqZmZiXlpSSkZCPjo2Mi4mJh4aFhYSDgYF/fn18enh3dnV1c3J0c7CQpo+8gIeAsoSVxsK/vLu4t7aysa+trKuqqKempKGgnZybmpqZmpiXmJiXl5eWloSVIJSUk5KUlJKRko+NjIyLi4qKi4uKiYuPk4+HhIKBgYGAhH+GfgR9fX5+hH2GfEh7enF7pLLchrNuent3s8e/uYCab5zHn4qcr6aFraV0iI6ddbqS1sW+voSqnJO4ucd1iZFzgtvb0OV3f3uEutOBc+HLspuhvZeAt5Cigo2whdPWytmy44nt/JqA84SlzN+2uYPtlrtrj4Z+cr6Gq3JfiYJ9zILAdZu4zsF/itDNhniqqsqLr5qTrHnXh7GRyuSv7qKek6/124it1cnIjZltgqa1sLasmqCXqGa9qp2QZZKivcW/Y2pmvYWFbnqIbG7AZWWAlrqfrYNinadnw2JpY7pmaWdpaqSFgpudl3R+m6FafqZkrrZsaHZ7lqmWY5a+gZOVv2GCholwaWFseF5bVYOgiXJzYnl9dXyUd45eo7x6lXKGmdDj2v5zoZPaq76pxebr6Z/N/NXZwpyKnYCcnJyRcKagt/361OXQtoiPu3l8uIHI632z9uC8yW3SoOGDvayx5bfZzsypk96BqKGDn5+XxdCa2snorcFtp8ermLOIe4GLn6qMeITzcoeAw6aHlay/w767x5OFoqCRsqh1fYGze1+Gu5WY3Xqh+6usdJadeNybYYvnrWiqf7B4yYDNloqopaz8o+ihxbvCsoX5x/OIsq2qnZ/Cje2DjpSRlpHZ8rPH4La+moKNgdyl79OuiZWWl5iZm5ydnqChoqSlp6ipqqqqq5SZus2quIKK097Qwpu+4uiKjY3U54O16M7LlYn4iYqZ5ZGMo4qHrbCimr7y9e/bhIicitLfudyO/l+HtnXJ0IG2n7W4l8va+uzF9Yipmr2D1pjS/I/zjaewq4PtmpucnqKkpaalpaOioaKdhvDB9fm99frv6eabltW3nNunh53us7e6vL/BwcDBxcfHxsbGyMvQ0dLU1NbX2ITXBdjY2dnYhdpw297e39/h3t7d3NzZ1NPS0dHQzcrLysrJy8vJyMXCwL67ub67u73AxMrKzMzIys3Lx8PCwL/BxsXCvrm3tba2tbCvr7G0s7KxsLCvrZqpqOunnaupp6OjpKWjoaGhnZuYlZCNjI2OjYyKioqJiIaEg4WCgIB9e3z5+Pj18u/v7+7r6+3w8/Ly8vP19PT19PPy8O/u7Ovp5+Xl5ePi397c3NnW1NPS0tLQzs3MycjHxcXBvry7ube2trSysa6trKuqqqmpqaqrq6mop6alpKOioJ+dnJqamZiYlpWTk5GPjo2MiomIh4WEg4KBf359e3p5d7maQK6awoqTjseNotnY1dTSz83KycfFxMPCwMC+vLu5t7W0s7KxsrGwsK+ura2trKurq6qqqainp6alpKSjoqGgn56FnRGcnJudnZyYl5eXlpaVlZSTlISTApKThZJRkZGQkJCPj4+OjYyBkszQzaHVf4qLh9fn2caUuILC6L2mw8/AjrvCg46pooDGj+jq6uyrr7mwwtPYjKa5hKbi8uv8j5uWn+j9lIDk0LmwudavgDQxOioydltiPVE9LD0rT24yOE0lMUFSREdBio6/UG5vP0ySaXc6LGVUL0xDeExIR3jJaEZcVjMtNjlXSEIyKzRCciIrJDQ6LEN3iVhJY1FRWIJKc1BDOC05P1V+gXh4b3xLh3NuY0JldIqUjEdHR4pfYU9bZlFRjUpGWWmGcH5dZHB6T5BLUUuITU9MTE5wWU5XPUM1OjJDJDxoSISPVFNgY3WAcEFqlWZoZY09YGRnVzQlMkMzMTRJYU87ODdHUkJEeFhVRqTlnsKQrcPqsbb1hpJ7f2hfS5LeyrtimtacedXJy8uEzIDNzs3NzczKu43HkaHexp1oSIVBVMmAgr1tcciMZ1NfSJWB+py2UHJcf+WRiHFuZVzBfb+7pMjIwPbrwP68/dr4gI/Fv6TNppFvX3F3eYF+zUhZRWxaT1dhZ21tYmVQTVtYSGhiS1FWe1RCn7qsd5likORqYVCFjF+3eUFW5alRvICe2ofWrIpYSkxwnWJ+PJCpZlY6elNwO0pGWUhmglB6Oz1BQDwyVmBBT3ZGPzhDRFOIf9PYvJWio6WnqKipqqutrq+wsrKytbW2tbSeobeUdHdrVo53XWZgqdraS1pQgptOmbS0zpiLtG5tX4gvUEJPU1xdTF2c9tGPckFASEJdxSyaflbqaq13y9B9oZmvsZXGs9JxerlrnYqkc7KGq5Rz1IKQoqmF8pyen6Cio4SkYaOioaCbbbik3+Gdrd6ptH9fY5ajmtWigJDlr7Gztbi5u7u7vL2+vr/AwsTFx8fIycnMzM3Ozs/P0NDPzc3Oz87Oz8/R0tLS0dHQ0M/NzMvLysrLysjIycnIyMnKysjHxcSEwwPCw8SFxTvExMXDwsC/vr6+v7++vLq5ube3tLKys7KwsK+urq6trJmqqu2nnampqKinp6elo6KgnpuZl5ORkJCOjoSMgIuJiIaGhoWEhISCgYCA///+/Pr4+fn39/f4+fn5+Pj49/f19PTz8vHw7evq6efn5eTj4uDf3d3b2tjX19XU1NLRz8/OzczLycjIxsTFw8LBwL++vbu7urm5uLe2tbSzs7Kxr62srKqop6ampaalpKOioZ+enZuamZeWlZSTkpKQE4+PjYyLioiG0JuWlb2Ij3XDnbaE+EP39fLv7Orq6Ojm5ePj4d/e3dzb2djY19bV1dTT0tLS0NDPz87NzMzKysnIx8bFxMTCwsLBwcC/wMC+vr28u7y7urq6hLkHt7e4uLi3t4m2TrW0tbS0srGumGlEZmGh9JmvsaXC8uZqbKNATFE0Nn1EOixCPDAqLzAlQzNQOz85KzYxM1FQTz00RS1TbVBQVC8wKjFJZ0g3QDc0LzBBLYN9hH6GfQZ+fXx9fXyGfQF+hn0Me3x8e3t8fX19fn19hXwFfX19fHyEfQF8hn0BfIV9BH59fn6EfZJ+AX+KfgR/fn59h34BfYp+Bn9+f39/foV/g36HfQZ+fn5/fn6Lf4N+hX+Hfo19g36Ffwd+fX19f35+jX0BfpB/AX6FfQF8hH0Ifn9/fn59fX6FfQR+fXx7hnyEewV8fH5+foR/G359fn18fH5+fnx8fX19fn58e3t7fH18e3x8fJF7EHx7e3t8fX58fXt6fHx7e3uEfIR7CHx8fH1/f359hXwNe3t8fH19fXx8fXx8e4h8AXuQfAZ9fH19fn+YgA5+fHx8fXx8e3t7fH19fYZ8CX18fX+AgHx9fYt8BX1/fXt7hXwnfn58fX59foF/fX19f39/gH99fXx9fXx7fHt8fX59fX9/gH9/gIGAj4ECf36EfwR+f31+hH0Hf4CAgYGAgPaBAYCpgfqACX9+fX59fn59feZ/Bn59fX1+foR/g36MfYJ8hX0BfIl9g3yJfYR+BH19fn6HfQICBACA4oyxqbXO6ubikaWos4zHgNai2piwwLu31uKenbaGvZL/joybmoSLkrGLjOWb0cqn2+Dhnuq4vt+R0bP23NCxtozThZGHraCNzXWVyZJ+pX6JoJTQjY6gkI51ha7Z2ubG6eC7i4fgg/zg4oWNjNvgx9XIrsCJipXv7OewhZmRn59okqHL3c6/hdLzipCRp97q18mH09basc/TmfDr/uacg+j909+Rg/HMyMjEweHQnej9tNzugY6QxrW48aHXs5CvlYup09j39peQpYm6g2OXesyMyuR4r7Ojo9PnyrN1/Z99c4SDgoGAgH+EfYB8fH1+aph+i4WRs42Tg7vRtY5xcpd+eo9+hc11foZydX3Ex46Gu6tXX7WRhneZi5uup352iKNqYnBqdXh7YqW9fYWcgoN1ipDPlIKKzaKAvG1mcHKmi6iTe816oLCwuuPGr8yG8/eGt9dvpo9xm46ZkomcganOtfuN0ZzFY5K+fzKAyNiYspdvcoHIsK99fKXQvHXMxcpidpycud7Ii25/t7+Uhmx5y4WHhXuNtLy1lbl5iISJgIqMjI6PkZOVlZeZmZubnZ+g27KKmJKGhK+Qnm7Li46A1WdscIGvfbqQqpqFlozoecKEiXlu0qCQudmy1oumo4KdxHu7uJPJxpfdx8ekirG/k4KKvMG8o7y/s5e13cuVkJWez5DkgMbtvpGHlpmanJ2fnJiZoKCfp6eayNafmLLVgKTRzKietLiCno/Qtr25rKKsrK+0ubaxsLC8vrezr7K1ubu+v8HAxcPDw8TDwsTEx8jK1NTR0NTb4OHi4+Pi4+Hg3tnT1NLQ0c3LycrLycfIy8rLxr+9urezs6+wsLS4wsHGzMbFyszHwby7uLzDyMfEvrq5ubi7tq6oqautrKytgK6wsK+qleWWhaKsqJ+alpeZmZaWmJWSj4uFhISFh4eIh4aGhoSBf318e3t8fPjx6+nt6+zr497a1tXV0tTY3dzb2tzd4ufp6err6+nl4+Hf3dza2dfW1dPR0M/Oy8fFxMbFxMTDv727uLayr6qop6Wko6CfmpmWlZWUlJWWnJuafpqZmJeWlZSUlJKSkJCPjYyLioqIiIeFhIOCgoKBgH5+fHp5eHZ0dHRyc5J25aKIu4Wn3IufnsXCv726uLWxr6+urKuqqaenpqSioaCempqinJeWl5aWlZaVlZSUmZeVlZWWlpWVlJGOjYyLjIuLjo+Li4uMj5COiIODgoGCgYSAhX+EfgF/hH4CfX6EfUhrsqB5npZ7lr+BtXd0dHu10I6RjI+0jKKRb6fPjnK5kaP7iX6Vt97MgG2vpXGixo+vrnB9eY2QmtbNZruG8pXCraOsgsCdrHeA8p/Psszd0+Hpf7u1z5jbh8OHwaq607ae9firo6lopo3ab1lmeW9+f4d/hbZYpbaX4t7HlOeztcx8u6Kny9O2zJTokpaXvKaT2Yin5KiVyZeepazmhZauo5OBl5ikpKuVramJZWaza8u4tW1yca+0naabhpZqa2y0sLaEZXRzdHJhbXWVpYl9YJizZWtrfJ+klopdlpahgpyccrCuw692YrfKqr54aMadm5WSkqSYc63AiaSoVmFfiYCBvoGvi26BcGN7jo+irmxxqnS2l3WtjeSg5v2BurGrsennzq6B5qWOiIadgJydnJydnJucnIXFoqWwuOG2rafw6uy0kZHElZu6p6qrnKCpjYqR4u6jp+vagIDttqiTuqy92sWPiKvVhXiLg4OFk3265Jyrx6q/l5iMv3Vxis+td9+ShoeLyKHGpY30iaCtrbnfon60aJy+md3fgK6fkqaEjZuZqYq33HGEYNqxRt1rndCTl9z4qsu1goaT3s28j42/89WH6ujzhI/T4On25JyBk8X5saCKi/KVkI2FoMza0aLJgZGTlJeXmJmbnJ6foKGjpKWFp4Cm6cygta2dn866x4P4kZKM8YCCiqDkm+qmvKCHjpr7jfWXmouG/LagyPbg5o+1q5C04Y3Mx6jmzpz1zsyZfqG4lXaFt8Szt8vLxZ6oycCLiZaVx4nyis79xpWDkpianJ+goJ6en56dnpuSwt6pnsDknNrctrHByYiqk9KjqquoooCtrrK1ubi3t7e8vru7ury+wcPFxcfHycnKysvLzM3Mzc3N0dHR0NLV1tjZ2trY2dbX1tPPzs3MzMvJx8jIyMfHycrKxsLAvr26u7i5uLu9wsLFxsTDxcXCv7y8urq9v769uLW0tLKzsKyqq6ysq6qpqKmnpKGV55SInqWkoZ+enhmgn52cm5iWk5CMiYiIiYmIh4eGhoWCgH9/hH4Z+/bx8fLx8O/r6OXk5OTi5Ofq6+rp6uvr7ITtL+zq6Obl4+Hg397d3drY2NbV0tDOzMzMy8rJyMbFwsHAvbu4t7a0s7Oxr6yrqqmoiKeApqakoqGhoJ6dnJqamZeWlZWUkpKQjoyLiIiIh4aFhIOCgH9+fXx6eHeYe++rjcKOvO6YrqzY1tTS0M3Jx8XEw8HAvr28u7q4t7W0srGwsa+trayrq6qqqamoqamoqKampqWko6Ohn5+enp2cm5ycmpqam5ubmpiXlpaWlZSUlJMNkpKSk5KRkpGRkZCQkISPTI6OjY17z7WKo7KEtN2f04SAhY3M5J+co6TZsamzgqXkporAk5r1kICs4fv4kIS3sYyz56fv75GUhJistfz/gOqe7rfr0qitlaa1x4uATDVLPDdzelZnLjQ5OzpWMUo8WmlZRkVQVFJytpxGnXVrUD1EWkZsUkQeJFIvcl9Dvt2gQkhNVl8tV1NpTkhER1JtKiknODEqRD5rfEg6XnRUOzloOjQ4MC0lNVVsbXJjdXFXNEh9T5uMi1ZZWIuPeXx1Xm5PSz17eXlVQj1ESExpSlRqd2ddSmuESk9PXGptZ1goNDhEKTlENHR8joJZSI6ii6JiUH92e2lkcXpwVGyAXU1HLjUrSD1IWVl9ZU1DODhTbGx8nGBmy2/Fv4yuiq+cpbRWVFBUUNCBVGVqok56o8fJysrLy8vMhMuAysnIqfLBlI91mVtVcoVrg5tbeIJGZcx8QkA3YK2qp32Zm3J0/sNSQH1vaWiqp7nx9J+htsuRlIegpae4jX6ro7Hlu4ptdnWtYWN/kWNKf09PTkxwYYluWotLYG1tb4NWSXtKa5We5MVyaIiddlh8mo2SbMf1TFFN4cL6gb/1koCAi3pQYZJVRUJOXGVFS1ppWD9zbnJASmJkcH5mQj9JW1Q6MSVAcDs/TEtbibfFqNeMnqCgoqSlpqapqaqrrK2usLCxsrGwr/jOmp1wTYu7hIxqioWNdeppeGZXpVWfi62hiJCQ6XKGR05KR4R3VFunp8iNmZ13d5xVeHN2hHh7tGhlpaCAo7qUdnips6yVn5aJWo6hrXl7Zo9TQqhvo9i3kYOTmJqbnZ6fn5+enp2cmZG8lHBYks9Mva10hm91WIxmyKGmpqSfq62vsbO0s7S1t7e3uLq6vL6/wcHCw8PFxsbGyMjJycmExybJyMnJycvMzMzLzMrKycfGxcXExMXEw8PDxMPDxMXEw8LBv769voS9gL/Av8C/vr2+vr27urm4t7m6ubi1s7OysbGura2trKuqqqmoqKaloZrml4ifpKSjoqGioqGenZuYl5WSj42Mi4uKiIeIh4aGhIOCgoGBgID//fr59/j39/Tz8fLx8fDw8PHx8fDv8e/t7e3r6+rn5uXk4uHg3t3d29nY19bW1dPSWNDQz8/OzMvKyMfHxsTEwsHAv769vLu7ubm3t7a1tLSzsbGxsK6trKupqaempaSko6OhoJ+gnp2cmpmXlJOTk5KRkI+Pjo2Mi4qIh4SmhPqtjslvre6fqMGE9DXy7+vp6Obl5OPi4eDe3dza2tfW1dTT0tLS0NDPzs3NzMzLysnIyMjHxcXEw8LCwMDAv7++vYS8Bbu7u7q5hbgGt7e3tra2hLWItE+zs7KysrGvi8KoZj9QNnKHiOGXmlNv1omdrHFGWy0yYDUwRnVgVy8xUTE3Mj0/PysiLzAqQn9YW1AzLy0xOUZYUCZHM1kyWk8tKSQ3NUcsg3yHfQl8fHx9fX59fXyIfRJ+fX1+fnt8fX18fH19fX5+fX6EfIN9hHwBfYd8hn0Ffn59fn6EfZV+CX9+f35+fn9/f4p+g32MfgN/fn6Ef4V+hn2FfoJ/hH4Hf39+f39+foR/CH5+fn19fn5+hH2Efoh9hX4Jf39+fn1+fX1+iH0Efn19fpF/gn6HfQZ8fH1+fn6KfQd+fn18fHx7hHwEe3t7fIR9D35/f359fX58fn9/fn17e4R9hXsGfHx8e3t8insBeoZ7D3x8e3x8e3x8e3x7fH17e4V8D319e3t8fH19f39+fXx7e498BXt7e3x8hXsFfHx8e3uEfAF7hnwEfX5/f5eAIH9+fn18fH19fHx9e35/fX19fn18fHx7fX5/f4B+fX17hHwBe4Z8BH99fn2FfCV9fH1+fXx8f39/fH6Af35+f319fH18e3t8e3x9fX1+fn9/fn+AkIEBgIR+DH9+f359fn18fX5+f/uBAYCmgf2Agn+EfgV9fX1+fuJ/g36FfQp+fn9/fn5+fX5+iH0HfH19fH19fIZ9Cn5+fX19fHx9fHyIfQN+fX6LfQICBACA0cORpneHv7LJh7ifx+Z/zKvbqJ3h04CpheTXotCshLnAovG36/yfuu6ds4iBlc/474ydpsOazsLrrKXH9qK5mpmFnY7ShoyDy4PYl660gonR+HebkICEhoTZiajDw7Hf8Pn61s++vObr28vYztvn7+7uy8ionY+MnpHx+f2/woeAhbCrxKSxtaXM+YqN8cWLjpvg2cWtk+H3xI6E4Juzl++U7sDe9ISZlZba8ISBhIOHm8uxyeaN9aSHnquKpIbow7+O7r6wuuyKj4/HbpaJgfKqwszPr52Ys8Hczsjoi7Z+cIWEhIKBgIB+fn59fX1/f4BqnGCMn5eecJh0urN3sZuAmZ3Aupp6oXt4nmqAeIGNa5eBe3arsW6Vpp1rZbGeia+DkYWMh42WtGqVb5yzire3cGJoinqpf4uznqj8q3/coXyltXaTnJO1obzwutOYi+6YhKmAhpWF0MCrkHxed5KVsnu6hI+/cImgo22vq3rCxn5+xHOQkticv251wYt7yrOAm6R0aXpyzJaQyrKAhoRrnp6j1Jl4d4GgzqJ7hIiJiYiJiYuMjZCRkpOVlpeXmJmZmpyffXacpp14yGrEgZh5q8+abrqAcW9sjra5p4SEpJJvmreTdIONpKCAvIVw5ouxmqSxdJWMo66aj6vAm5vLg+vofoOBlcHFmJ3EneGZ9eSAn42mtK3Hj+7sjOH8nZ+cnZ+hn5qWlpman47c6ZfgzPCz7KenzNGEnZa+k8q/na+ppaOio6eqrKupqauurammpqqsrbCxs7S0tbS0tLW1tba3t7a6vMDAwMXN1dne393d397c2tTR0c7NycjIxMPDxcPFyMnHw8C9u7q3tra1tbaAt7u+wcXCwcPFw8G6trm4ur2+urq3tbOysa+rpaOkp6OjpKWnn5yAo7PoxpqfoZuWk5CRk5GNjY6Kh4WAfnx7fH+Bf319fXx8fPPw8vHv8fT08Orl5OTl5ODZ1tXV19TT0tPX19bW2uHg4OHk4+Hc2tna2NXT0dDQ0M/OzcvKyMUhwr++vr6/vr27uba0srCtq6ilo6OhoJ6cmpiZl5aVlZWXhZZSlZOSkZCQj42NjIyKiYiHh4eGhYV1vMKBgYB/fnt0d3d2dXNydHPQjquNisnIinXCjqrBqb69u7i1s7Kwr62tqqiop6alpqito56eoZ2WlJWUlIWTJ5SVk5eUk5WWlZWUkY+NjIyMi4yNjYqKjI+QjIqHhIOCgoKBgoKBgYSAhn9Sfn5/f35+f39+fsdprrmthJe2fnfYmJ6KjtfYxHetu5KR5ax4sIyv2tmIgeS6i3eT0258up+wb5p3aqZ0w2/nxLPHspK7nbKs9IqA0LnNpYmH64Dp15q7ipCvqr5/zrDV8onirpaarvjweruM/7+rs6FuqsGmxG6g2oSh252Wf01lrvXganuGvJPby9eSo7Lwmruop5eokPGRl4bHkfasyd6JnuP+g5qWi4aRgueXrpyUhaq6x82wqZiXvb2snKmmsLi8t7mVln9vaWhyZ6y8wI2UZmFihHuPemt6dJG1aGi1jmlscJeLiYt0pLGZbmaugJF7vHjDmrXIbHx5eqa3Xl1eYGJznYmUolujfWx4fGh/Zbiblm+ujX6QuXZ+ecF7qYWJ/cnQ5N+7oaO5xOnSwtmUtYuDhJwDnZyciZuAhMZ9pru7tIPChd3el+jFn7rv98aekpmXwoibho+7ib+gmJzz4I68yr2CfNm8o9OjuKqur7SuyXWxhL/arPjxopKHm5LJkpPGzrDpvJb+nIDO8JKqvLi4lLvfrrx6e5VWY62LjpWNxbSShpNuiKqzwYWBPYvJeJGqrXnFxZPb4I+AieaUr7LuntqBit2Tk+XIus2LjKKG3rCz79OdqI2HwKSu56aEipO16LN/io+RkpOUlpeYmZqbnZ+foaKjpKOjo6KigH+vwbKB9oX9nsOLrMupgNWgjImCtd/FtoSIn6mCtd+thJ+nurmPvZeF/JG7lq21gqCQs7aqlbfSnZzGd85F2X98ep3U1Jmf2K/cmt7ckoWgr7jHjOXrhs7tkZSWmJqcnZuZmZiYmYfZ76PnzfTC6q+uz92YqK3Qlta7kaOkpaWmqayvhLAUsbOzsrKytbe4uru8vb6/v8DAwcGEwhrBwsTFxsbJy87R09PT0tLR0NDMycnHxsXFxITDCsLDxMXFwr++u7uEuEW3uLm8vb/Av76+wL27uLW1tba3t7W0sK+urKysqaWlpqalo6OjopuZg7DA9dGZnJ6dm5mYmZqalpaVkpCNiYaDg4KDhIKEgVWAfvr4+Pf19ff28+/q6urp6ebj4N/g4ODf3+Hj5OPi5Obm5ebl5uTj4eDg3tva2NjX1tXT0tDPzczKx8bGxsXFw8PAvr28ubi2tbKxsK+tq6uqqKemhaVZo6OioqGgn56cm5uamZeYlpWTkpGRkI6Ni3zKzoaFhYSDgHt/fn18e3p4d9uYuJaPz8+ahN+ludK70tHPy8bFw8LBwL+9vLq6uLe2traysa+uraqqqqmop6eEphalpaSkpKOjo6KgoJ6dnJybm5qamZmYhJkMmJeWlZSUlJOTk5KShJGDkISPUY6Pjo6OjY2Mi+mBzdm/l63NjZf7p7ijoPTm2oDF05yt/siNvZjH58mBefG/hoCt6ISX8L7JgLGGgNmP+IT40trz2bm9xde6+piZ48/hj5ua+YBLSTI7LjlkVFM9SDFDWjQ6QVBKdHU6KEc9T22plWFSYp64pD5qp2hoTyc0LiQ3UnNrRlZFQT+nx5hOX2poWmxXXTU2KUUnKSxAOIZPU0k0RWRKJTUwJyYpK0cwRV5eU3GClZ6LgnNzjZB+b3p9hoyNfIZaYVI8OkhLOVhpdTxOP2hFXFNhVk5SSl5/TUyEX0dGO0BDKSQuPFZeQkV8aXZjlGKlfJOoW2hkXn+LRkJERkhRP0NITi9QNjs7QUddTYp3bkZoVVBGY0tcYMaNl1xrrZt0nZViP0NtjI5NfKNMS1uexcbHx8jIx4bIgMfGxKXujYtvYkkunEZQWVdVUlKGnNm1RzU3OGCPuo1bj2qEjo9jgoVneZGqkIKign3ponaqu7jL1vuUzluQ05O02WhgWHqR0XheenNqnX5cmVVRj91WVlxgdFp2hmVnQ05tNUuXgox9W46FX2evhaa9v+iZWiGi9ZGwzs+JxpdRgI+DSlmaUFRShVduRFhsPDpsZF5vSjlFP3NbUGdpR0VAMUtWTmlbX4OMsem6iZSanZ2foKGio6SmpqeoqaqrrKytraysq4iDqqyUer5Rklx/fq7Pm2/HdGhMYnl6up6EhZqGXnR1ZlFZaZp3RUVfYt2DrpCmrEBgeF9hkUyUoXqVJqZv1N2CfGZjkJ2TlaaGoHa8yH1yk55qiGufwnnH6ZCSlJaXmZqahJk6mIXZ3pG0aXx3cXt9a21XUH+7hq+2kKKjpaanqautrq6vsLGys7OztLa3ubm6ury9vr/Av8DBwsLCw4TBF8LCw8TExcXGxcbEw8PDwcDAv76/wL++hL+Avr+/wL69vLq5uLm5t7i4uLq6ubq6uLi5tra1tLOys7S0s7Kura2srKqop6enpqWlpKOinJqGt8T92Jqfnp6enZycnZyZmJaVkpCOi4mHhoaGhISDg4KBgf/+/Pv6+vn49/Lx8PDw7+3r6ujp6ejn5ujq6eno5+jm5eXk5OPi4N+A3dza2tjX1tTU0tLT0s/NzMzKycnJx8bFw8PBwL++vLy7urm5ube1tbOysrKwsK+ura2rqqmpqKalpKKioaGfn56enZybmpmXlYTA2pCQj46NioeMi4qJiIeFg+CTiIyOz6yAXIuRzevU8O/u7Obk4+Li4d/f3d3b2tnX1tXT0tEj0c7Ozc3LzMvJycjHx8bFxcTEw8PCwcDAv769vby8u7u5urmFuAG3hLYHtbW1tLSztISzV7KysbKxsLGxsbCwr7Cvq+dHVHlQRUlgO0h9VrGXbtm3+pvGdkM9U2VjQDBuh1QpKj5AMjUyTCksPTM2LUAwL0owUypOSD5TRzY3OkVASSghPDM8NzE1XIJ8iH2EfCp9fX18fH19fX59fn18fX19fn18fnx9fXx9fX1+fX1+fXx7e319fXx8fH2EfBJ7fHx9fn59fX1+fn59fn18fHyEfYd+AX2gfoV9i34Hf39+fn9/fod9CX5/f35/f39+f4R+hn+FgAF/hH0Nfn19fn5+f3+Af39/foV9hH4Ef35+fpB9AX6Sf4J+iX0BfoR9gnyGfSR+fn59fHx7fH18e3t8e3t8fn17fH5+fn19fHx9fn5/fXt7fHyGe4J8iHsEent7eot7CHx8e319e3x8hXsMfH5+fn19fn57fH5+hH8CfnyEew58fHt8fHx7fHt8fHt8fIR7hHyHe4J8hHsCfH2EfgF/moBYf359fX58fHt8fH5/f359fXx8fH18e359f39/fXx8e3x9fHx9fHx8fX19fn5/fn58fH58fH59fn1+f3x8gH5+f399fH1/fn19e3x7fHt8fX19fn9+f4CAgI6BE4B/f359fX59fn59fH19fX5/foD6gYSAnoHygAJ+f4+AC35+fX5+fn19fXx94X+CfoR9FHx8fX19fn5+fX19fn9+fX19fHx9hXwEfX18fIR9DX5+fX19fn19fXx9fH2EfIZ9Cnx9fXx8fH19fXwCAgQAgJihqbbMqZfnr52biZehg+Kb3X2QjYuSitjWn6rU6YHy0quHgpv0neCAzaN+luuI1J2NsZHJnM2S04e6w7mgy8jM24fW292yqJLChHqJv8d4i3q16pB5zaLJ1I+Qo63h7unZ2bK1yujk1sGiw9KyqNaym5WQgIr4k43x2NW1w7GDgIWMi7bwgJavga+OloWA8cqgje3GnrnX8ZWwprK0vsfkhOvpyNDE7eeTmf/qi4Tv7Jihmom24d3y6dP1lrvppJWPv/u9kq+m6YH5paqIiIl+zbrcfW+vp7/C4ezznJms3Z9+g4SDgoKBgH9+f35/f4CBgn1joWyXoNJoj212zZiFgLV7o3pnbo27cK1+iaXCtYagYZKMfWttoH2NdFqcc7u/vXbGY6B1Yap4e7N2d7KVfG9oeYzRs4JmnaJ0eIP9o5KJfpNqi4yKguWPj7r50ZaQ6KbBw3VhfLrjubSehm+tmXq6/ft7onlukXyEp4KSt6zDqJt3waC247qg1LDJu6uVgIe2hISE8rG0gpqIho+Zm9qO0diokoTKsI55hoaGh4eJioqKi42OkJOTlJWVlZaVlpeZm5p5h5yB2HXddNKdcPWsjsV4c3XEjpO4tH6jkKiRt5qdosvU2+R3oKXHvbj4vIy4lal7fZbi53bcrcT0x7+Xl8mKsq31uYuq2K2YhoG4gIKQnuzznp2A5N+EipybnJydmZeXlJOVmp33qojCearRe3bOoY+cpM+Vg4vF5KWhnZuYmZueoKCfnqCioqGfn6Kkpaenp6mqq6usq6yusLGxsLCvs7W4urzAyM7T1dXV1NTS0tDMyMbFw8K/vLu7vL27ur7FxMK8uLe2tLOysbKzILW6vr+/v77AwsK/ura1tbS0uLavged+o6Cjnp+dlemWhJtHjurfsI/GkIyXlpaSj4yLjYyFhIWFg4F+eXdzdHV2d3Z06Orr6unk5Ojo5+rr6+vm4d3d3t3b2NLQ0M/RzcrO0NPT1NTW1tiE2i7Y19bRzci+wsXAwMPFxcXEw8C/vLq5uLi6t7i1s7GurKqnpaKhnp2cm5mXl5WVhZNSkpKRkZKRj42Mi4qJiIiHiIiGhISEhYSElb2F4cd61Humu3d1dXRzcnJxiqjPeX26iq+02MeSprenubq4tLKxsa+uraupqKmmpqqsqaGdnJuYlISThpIOk5aWk5KSk5OSkpCQjoyFiwKMi4WKDYiIh4WEg4KCgoOCgoKGgVV/gIB/f3+Afn9/fn9/cW61nY6Jhb/VsbaLrX12z33Tv3S0rKV8ipWedMmC0vfUrZTlh7Odn4OJn8x+fcxxh2xuwXD1g5mXf6yDnoeV7IiLmKvue6yPgKKxudTprXfGjX2kk6mzkvOew4OhoZ6WkOrqh67T/YH337JdQmatarF2xKOFm/CKxHtkeFyJc9GazXestbmj1NbiypXg7+bGppvemoCN3NyHmYLH8aOJ4bPH75umppWzuLawqo6TodDl0K6GoKqShqyGdnVqXme/Z2esoaGPkoVbaFphYIGtUGWBWnhobV5dtZd6YpyFcY+mtXCGgY+FlqK3bL+9oaidvrN1d8qzZF2pqmt+d2eDmo2hoZyucpGpdm1rl7eNdpCHxXHkpqyGh5CI5cjrhIG9w9ey9fTgoqK4/baPmpubnJubiZqAm5Z5yIjBideAqoSN7sOoyZzYmomDeuqN1aCvueTWpsaGz7Oxi5TMnKiNcLiN4/LbmP6Az490vICL042I0sakiImLpPSemYXHuZSVfOKskn+DvJW3vL+p0ZeRseiQZ16Yc63YgnKIladwxa+bf8uujMPixoKrgneciJXAkqfLveCAyreK3KTG7s678szg2c2aldCamZr4s7+OqZKcqKy5+aLs6MWkj9W7m3+MjY6QkZKUlJaXmJmbm52dnp+fn56fn56dmoGZq5DzgvKM+7qE9auP2oORk/+5wdvLlK2gxafWuMG54fH88YC0o8fTwPqthcSqx4iHoe/zgtmhtNu1uYxciMeEprL/vZG12sGqiHSvfIee7vagm4TczXh9jpGTlZeWlpWUk5OUlfCwmNKCtvGBgtKzpKe02rGHlsvdm5yenp6hpKanqKioqaqrqqqqra6wsbO0tbW2tri4uLmEuwu6uru8vb7AwcTGyYTLgMrJyMjFw8LAwL+/vby9vr68vL7AwL67ube2tLS0s7Oztbe4urq6uLm6ube0srGwr7Cxsa2F8YKjoaShoJ+Z9JudnJyaj/Hps53Wn5CWlpiWlZOSlJWRkI+PjYqHhIF+fX19fn18+Pj49/bz8PDv7u7v7+7r5ePj4+Li39za2dragNnX2Nvd3dzd3d/e3t/f3t3d2tnW1MzPz8vLzs/NzMvJyMXDwsDAwcC/vry6ube1tLKwr62sq6qpqKelpKOjoaGhoKCfn56enJuamJiXlpWVlJORkY+OjYyLiZ/KjunSft6Br8h9fXx8enl4dpC23IOGx5W/wuveo7zPuc/MysPAHcC/vr68u7q5t7a1trWzsK6trKuop6alpaWko6OjhKIdoaChoKCfn56dnJqamZmZmJiXl5aWl5eWlpSUlJOEkgGRhJCCj4SOg42GjEqLi32J3senlp+/8NPbrNeZi+GO+uCE07zCjKCmtYLrit3+2b+g847Gu759ssb5k5T3iKOChuiF7ZzBuZyXoLycoN+jm6mv6oi/o4A/Qjc+SmtCfFFAOjhSQTFQRGk3QTgvMjFBSDR1cl9BeIRZMyI+c0NwLT84LVB/T2xJPk43SkC4pcxea1uCkNCNWUg1WlY9NzwxVEMsLkxKKSYhOUcqI0A1SkcwMUpZdIGHg31nb3iBcW1xaH+Jc2aIVUxFPCYugEI8YFVhRlRXNmM5Oj1WeTI+WDdKSUw/QXRbTC9ZPzYuPlc1SFlkSm2DlFmfnYSLfpuKW1yhiUlDeHlKPDoyOkJCXFQ9TTtefldRT2ZqRUZCOkorXGZrSDBOZLVohltten+KfZ5GbT5RWbzAs8OGxYDGxcXFxsXEwsG6lOx3cUVYYlg2NlpNQ2d/tn1VNjhlLUtjjrSPoHOHXHp0Zldhk3CUrYi7aXuyfkqsc9yWhuagqrmEmMyBZmBgX2iicnJjdWhRTVOVZmVPTX5JXVldYo1eXGiKXUc+aFKW4puHnHprP9rWuIzgxIbAtcabzZqMuICgp51qbHx7i4qGWoJmcpOfiZpsaV9dT09vSj1CgmJhSVJQSkFSUXtRc4SUmJTix6KHlZeYmpubnZ6goKGio6Smpqaop6eoqKinpqKGlKKG33zhYLdzdvCtkcl9Ylyja2eTpnikXneInWZihL23euxwYmKyla7ypoC6h35Tc3Wr5SduvqK137mvk4zGh5ublImIpr6mmHhmom+And3wkY1nvcd2e4yOkJKGlE+TlJTqnYnEcmS2TnDBhHJqZGh5eIXI2Jydn6Cio6WoqaqqqqusrK2urq+xsrO0tbW2t7i5ubq7u7y9vLy7uru8vLy9vb6/wMC/v7++vr28hLoBuYW6Cru6ubq7u7q4t7WEtISzMLS1tLW2tLO0s7Kwr66ura6vrqyJ+4Wko6aioqGd/56gn56ckfbqtp/do5OampmamYSYgJWTk5GQjYuJh4WDgoGBgID+/v79/Pj39PTz8fHx8O3q6uno6Obl4+Lh4uHg3+Dh4eLh4ODg3t7e3dvb2tfW1dPMz9DLzM/OzcvLysnIxsXExMLCwb+/vby7u7q4uLa2tbSzs7CwsK+ura2sqqqpqKempaWioqCen56dnJycm5mYKpiXlZOSosCQ9dyG6Ym11YmIiIeGhYOAlq3CV2GreahnupeYpd/R6+ro4ITeGN3c3NrY2NbV1NLS0dDPzczLysnIyMbFxYTDGMLBwMC/v7++vby8u7u6ubm4uLe3t7a1toS1B7Szs7OysrKEsQawsLCvr6+Frk+trq2trKyrjUhIOj1weWB4T1pApXJXjmzeoztGQUEoO0pHM1lPgoh8alm4VUg3OS8qNFEuLUwqNCorVSpaLkU3JjAnMzExSDItLjVRLT87gnyFfQN8fX2EfAZ9fX18fX2EfoZ9BH59fHyEfRd+fX59fX18e3x7e3x9fn19fX59fXx8fJJ9B35+fn19fn6EfZx+A31+foZ9hX4BfYV+hH+EfoZ9iH4Bf4d+CX+Af3+AgH9/f4p9B35+f4CAgH+GfQJ+fYZ+CX19fX5+fX19fod9AX6TfxR+fn19fH19fn59fX18fXx8fX19fIV9BXx7e3t8hnsFfH1+fnyFfQx8fHx9fn5/fnt8fXyGewR6e3t8hHsBfJB7F3x9fXx8e3x+fn17e3x9fn5+fX19fHt8hn8BfoZ7g3yEe4J8iHuDfIp7Bnp7e3x9foR/m4A3f35+fn1+fXx8fH5+f399fnx8e3t7fH19fnx8fXx8e3x9fHt+fnx8fnx+fn9/fn18fH59fH5+foSAFXyAgHx/f358fX5+fn19fXx9fH1+foV/AYCPgQGAhH8PfX19f39+fXx8fH1/f3+A6IEBgIiBAYCGgYaAmoH1gAp/fn9/f4B/gH9/iIACf36GfQZ8fHx+fX7ffwF+hX2EfAl9fX5+fX59fX6EfYV8A318e4R8hH0Qfn19fX5+fX19fn19fXx8fId9hnwDfXx8AgIEAICV0p3pyZyT/ISehYvrvrDv06y76IOv5YPtu6ixu96VkseQ3NOwusquhbibkZabtIJ458Hvj7TRytm93Hvat7jgnainxtCXmaF/bp/JxobQk8nSrqfegcTIj8OPhcb8hevexsfQz9nQz6/M2+7p46OL14jazqzW5u7Vsr2Z7b6k14DcjKGto+WGvd2+m5u2vImcmorIsfihtNasgqGfy+Ts/92Ak4K/u9vc7IyTu/eF5NfQp7CytpmGqJm7w+W1ue+GiIqAtsbRkImQq5qQnJSQgMzHkXvce5Wv3t+Jgtbnpq94h4aEhYSEg4KBgIGAgYKBgoOEgGCBZcrhqKto4eCLfoDRin+ml5Xo1MCdhMeMZ4W+l5x9cn+FiIu2f26Yt2d5eahqw4l3i3Z9vofal3uztb6mkpyitMOxqKiYf3SN9diDgaKH0GqTlZTb6M2PiqiMwbvC2bOwiI/q4dSFrX+X2nB2+amiy3TZzJy3rYN/pJOicIbSu4qnx9KLmZmipIG0jID4nMuFyZR0mZqF2n91l7PDwKaf2btxe9HYw8ttdXd4vHeGiIqLjY6QkJGSkpGSk5OVl5mdgpDQzIV7gsaWdJbZ7u6gdYm6qJa4r+vjpp14fdvDb6muatGVk4OL08ejrv2SsnmGyemTd9WFrezc+4DA7NPCge6KiYt96eKQivWAzICa7ISP9/btt763t3yPl5eXlJGIjo2OkpaXmdiPt4abxZ6u342diOGhkL/Kvq22jJqXlpiZmpqanJyeoKCfnp+ipKWmpqepqaqrrKytrrKxr6+ur7C0t7i4u7/Dx8jLy8zKx8fFwb28u7m5ube1tLW3t7e4vL28trGvra2qq6utsWexs7e5urq7ubq9u7axsLCura+hwl9ccqB+o4+AmoJEdqxqj4qxhXpttZpomWZkXo23tdJ4fHXYctSlf3NlenaFm3nC27yFerXH2c3Q2Nve3uDi5OTi2dXT1dXT0c3JyMjJyMbFyMzNhMyA0NHR0tLSzsHilI2ck8Cylr6/wL++vb27uLe0tLK0s7Kxrqqop6Sjn52bmJiXlZWUkpKQkI6Ojo2MjYyLioV/fXeAfH98g4SDg4GCgoGBwYebyXiTpZvlz352dHNycXHfpnyWlq2Ip3+Rht2gmt91bq2jqZugpqGorKKopqalpKMWo6OioJ+cm5mVlJOSkpGRkJGRkJCSkoWQDpGRkI+OjIuKcoGIgYiIhYkHiIeHhoWEhISDhIJYgYCAfWlgZV9iaWdzbmxiZ7SQnp93s8uC8XGbhH3Dy9q6eIuZjNSN19N+uo+qr4iAjdV91YF8zHTB+oWe0ISepqfAcbGc1JNxeYKqdm6+csaGh4a433qgyoCYy6Xz6ZqW+n+Uc5D63Mj92a7N6ZfJ9ofQyaGw0vmcotyj441ooaZ0fayYlJqrzouC77CyVWWPnMei2YDPpLTdpa2qw9yhm6GOiL3P1I/2l+biubX+gNuxm9yhksffbcC0oabBvrzD2snLwLizsYJurWOmoIyqsq+ciol0wZOFpGWgZnR6eJZViaiRcHJ/iWZ+eGKDfbNzgp2AWXZvna2zwq5jc2iXkKmptG5yjL1ls6ObhoN5hGtdenaCjpaPibFkZmdklaGodm11mKKQjYaKiNu+oIXrhay/4eqKhuTsqcGFmZiYm4Sag5mHmoCVc6CC6uivyoD5/qmb8qSUyr6x3PvrqKj4ooSt8cDtxKGoqay376uOv9uDn42IifekjqGGhcaU8KGBsZaihn5ycoqhmcjbt5WTk+DeeXCyo/iCrrqmt+TJiXyUYnx7gJHCto6QiZ/imcKNqv2Dg/1fnOCB9eq108WTkbCeroeU6YDNkb3i9qWxm8HDmtKf2ZLRiNGUhb++juWNjsLu7OvOuvXJeILg59Tedn+Cg9SDkpSVlpeYmZqampmampuampubnIGS396KiqDkt42w2fD4r5Kl29rF4Mv6+cO1jJT88Ia9u4L2q6uSjtPSo7D8jLiHm9vgl4Hbk6zXzeNztOa+v0F534uFjIDS1YqE8ne5kuSAkPL04q3DtbaChY2PkJCPiY6Njo6Pj47PmM+UrtudqOicqJrvsZbV2bewvYmZmZudoIWiAaSEpQ+nqausra6ur7CysrOztLSEth21tba4ubm6vL6/wsPEw8PCwcHAvby7ubi4ubi3toS3bLi6urm2s7Kwr62urq6vsLGztLO0tLOztLKvrayrqaqqn9F2dI6/nsiunbygXpbRfq+r0JKIeMy3f7l4dnOfyMflgYaA737suJOFdouIl66J0evNlYnG2Onf4ubm5+fm5+fn5eHb29zb2trW1YTTCtHQ09bX1tbW19aF14DWzPirp7iq38+jycnHxsXEwsHAvby7uru6uri2tLOwr66sq6mop6alo6OioKCfnp2dm5uampqYk4yLhI+LjYqQj4+OjYyKiYjLkKLWgJ+1pOzdh3t7enp5eOqwi6Wou4Stg52P97Ov+YN8wLW4qbG0rbi6sre1trSzsrKxsK6trAuqqKempKOioaGgoISfgp6EnXqcnJuamZiYl3+PlY2TlJWVlZSUlJOTk5KSkZCPkI+Pj46NjYyMinZtcW1ud3SAe3lvc8mpw6+NztaJ5oOwqJju4/rNjKizn52f5/aLxanK1ZyQituO2IeA7IrS/5bG8p3D0MXshNa045SOiJqLi4PZieN+kpPJ9YLC4YBJSz1GPVmK+W9yPXSmSzRGSD5ASiQ+TylFajlDTVA9PFIwcFg5bmFKR1lGREpJT0plioN7LTVadMGB84iWbJaFRFFyX04uMzsvKjxWQytAKz1SPTc7JTxGLkEsKWCWUpOIeXRqa3hqSEVnfIaBhWFRfjRHODBIe3FnYF5BblZZZ2luSU1QUmAkX1tdTVFTWURZTDxPM1ovMDUxJzs2X3eBmYtPXVZ6boSBgFVZbZZPjXxlQUVANi8jNTY0NkldZYVNT0xFYXFyUUVDXJNfVikjPpFwhF+MVWZjY24gNGxzfcuZvLy9wcLDwsKFw4DCwsHAvraIsYHFkm9UKVhaPEGjm4y0aUtVWVlBT7GMWY2mhIhoXWppdW6IiJnXyVZcQElRf11klqCl87vtnY/AeX9mZl1ab4hwgH1sVUtVgXNOUWZai0xlaW19rI1QUHBHVlxcacq0o6pbdPi07qB084qS+Duf3oO/17/c0IZnfYB+jFhikX88V3vGlYdeaWNOb0t8SmBJglVGXl9JhEhCSlVfZ2d6+tmAiu/76vOBio6P6o+bnZ2fn6ChoqKio6OjoqOjoqSjiJXgyYx0Z8h7V3jV7PqoZG2GgHFwjPPYfn9hccGPO2KoQnZrgl1kp7SYoOaFrnBbnuGUXc5tptnS6CZ1uPPEwnrSgXtracvbiIPlbqx+2Xlu6+HLmZWkeHyDioyNj46KjoSPIY2Nyoa4inzDkaPhfHll15VZvsK5sr+Mm5yen6Gjo6SkpYSnDKipq6ytrq+vsLGys4S0AbWEthu1tbW2t7e3uLm6u7q6urm5ubi3tbW1tLW1tbSEtYC0tbW2tbSzsbCwr7Cvr62ur7CwsLGvrq+urKyrqqmoqKif3ZeVquG/7tPC4MaCuvuR2NL1npOE4NGO34qJha/W2PSHi4X6gvPBm4+Bl5Slu5Xd9NSdl9Dg7+bo7e3q6uvq6ejn5OPi4eDg3t3b2dna2tjY2Nva2drY2NnX19bV1IDRyvmvrsWy6NqnyMjHx8bFw8PBv7+9vby7urm4uLa1tbOzsrGvr66trKurqqmoqKelpKOjoaChmpWUjJaTlpKYmJeWlZSTkY/Vj5XPcGSWqf3YioWFhYSDgv+5b21vjmevhmpWgXuJ/I2K2czRwczSytTX0dbU1NPS0dDPz83MzAzLycjGxcTEwsHBwL+EvhG8vby7u7q6ubi3t7a1nK6zqomyhLEDr7CvhK5ara2trKupkYWLhYiSj52YlYiM8Z9MQkO4yWN6O11HN1JKWDsuOENNTTpVXTtZRTc/TF5haiyLPTpZK0NQLz9VLTw8QjsnPTZFRTAiJC0mJEItQjoxKzRJLUhggnyGfQZ+fX19fHyGfQR+fX1+hn0Lfn59fXx8fXx8fn2HfIR9gn6FfQF+hHyNfQN+fX6FfQF+hH2EfgF/kX4CfX6KfQF8hH2EfhB9fn59fn9/fn5/fn5+fX18hH2IfoN/hX4IgIB/f4B/f36LfQd+f3+AgIB/jX4GfX1+fn1+hH0Gfn59fX5+lX8Hfn59fHx9foR9A3x9fYZ8gn2EfIp7BHx9fXyFfYR8CH5/fn57fH18kXsFfHx7e3qFewV6ent8e4d8GX19e3x9fn5+fHx9fnx7fXx9e3x9fX18e3uEfAh7e3x7e3x9fIZ7BHp7e3yGewF6hnsGfH1+f4CAhH+EgAF/lYAKf359f318fXx8fIR+gnyEezt8fn18fX19fHt8fH58e3x9fXx8fX5+fn9+fXx8f399fn1/gICAgX99gHx+f39/fn1/f32AfXx9fXx+foR/BH5/foCOgRSAf35/fX5/gH9+fX1+fn1+foCAgOWBAYCNfweAf39/gICAhH+HgAWBgYGAgbuAB39/fn5/fn6/gAt/f35+fn1+f39+f4aAA39/foR9CX5+fX18fX19ft5/gn6GfYR8iX0JfH18e3x8fH19hHwMfXx9fX1+fXx9fX1+hH0Gfn19fHx8hX0CfH2GfAN9e3sCAgQAgJTH+LvaoIemqISYta2KqNOgi5PFnZCXrJlzlNPxzM2zp6bjrp6PkIm91eGjip2oi/HozMupnMPe5aaj8Mb2dtHJoorDtoyNk3ycttqr5quqxMmFfYyrtau6zvn60vP1ierUuaaupbKJk7C28N+Z1u3z1LafnrbZ+92ilIWOkabsaP2kppi5zMSQyYykkNbc8fnTsoCkifae0t3jgY7CqcPYxaqvpOnQ2Njw+5/k8I+K4cSrtJOshvf18qGs3o6F6o2RgLrf+YmP47PypJ2AoqSU7PPUfKnC4eTQsYd86n2Awn3RxryCfoSDhIKEgYCCg4SFcmV9vcKQuZjrv59xg7mFqc/ErpKxvG2p1m19k26jiHB/mX+KpoR4a3d7Z2mjgWl7f49vv6bEonh4dIJ+zoflgXb/k6qplZuMe57y5b+fjX7IgaLl67Hmpdq8qMKZt4iLcq74wpeazpfA4fOY8+SS74WHg4i/qL6ov7TA6YC7mJGk1r2ugeiTw96iho955aiyq6ioi5qcnZWMm7xykamqsn1jdGVXUVZQV2RcYFdkW52zuKNxjY2Njo6Oj46Rk5WXmp+bo5Byjoa5mXRvr5O42JmivrSvlbXGw3Bxd8CSwZmkh6mArL6N2KOPnMG9td1/2ZGZzoTZorO7yuL74n6ih4nA5Prz+pTjnK7BxYG02Ovrk4OC24iUt3zOuZORj4uPh4yMjo60hIWXwcyIvJKJlJ/G5N18nszNxcd3nKaAk5OUl5aWl5eZm5ucmpyeoKGioqOkpaenqaqqqqytq6usq6ytsK+xsrO2u77Av8HCwL+9u7i0tLOzsrKxrq2EsICxs7Ozr6qpp6alpqemqKusr7Kzs7W0s7W1sa2rqKimjcFUTUVJS0hBeHh4eXZ0g0JDREZ5h2lrj0lHRkJCQUNERktLloeQhnp3enRtbHJvdk9uX2pufV+EVaxzhIeFssu5wMfR0szLy8zLysbBv77AwMG+vsLDxMTDxMSxx8nIfoCujnJraW5wiWeft7m5uLe3trSzr6+rqaqqqqinpKGbi3+BgYKHiImKjY6NhXJnyIa/anx0a3KTZbKtbV1ovKd2lbPHwNh7eaiyee262aX/2LGfwYiUl3WEq9u4eXjLzrKtgnK+yd67eG6dbnt6cYx8p2xsbnyzjKKpYG6EeJSWmQuZl5aRkY2Qj4+OjoSPf42Ojot3i4FhqGhsaWi1dma2pl12mGmHiIeHh4aGhYWEg4B7eG5flpB7b6WRh32Cf4J/f3d4eIJ/mZuIy6jL1pLvo2mTqLy248ODjZvsnaTXpn+DhYOO09Pfk8bdyuN6qqmvhMN8cbHJytOBv7KroHh5jHJ5p86tee/g5Y+uhsuAnsX/p/2zjp+rgm+froOyyaiJoaS2o567qoCNzP7OxMmqvu2FamR3Vo7J6quMrb2V8OS6uIeNucWhg4bfyut82tujebWdgYuch6vY973Oya/P1JGBoKi8s8rk9//J0dRuuqupubqxvpWoubm8qniqu76gi3Z7i6GwpYB0aXFvhbhqvXl0boOXiF+Sb3pwnqKxwqOIXHFjuXacn6RcZIl/lKKVgYZ+sJqjorbFfbG4bmirmoyCaXNguMq/a3eWa2SxaG1ij6C0ZGyxj7iIfXCWmYrW0d2Ar9P59NqtfoHygYXGienOwY+Pl5aWloWXgJiXmJiXgnSW6uu038PVvLuPpN2Px/vzzLG5xYS69ISbvorZspaky62tt6ydi6eriYCVqYCWkY54tqbOt4GJh5iV6ZnkioLom9DSubakhJDB0LOYoJfIgIq5y7nGep2Lh4BtkGOkhbq+bYGeyqbX6vKg/dRQm3een67mzNe6yr67Ode9pKzI5cmviPSizPC7oKCA2qnCy6qqkJ6essK0yf6dt8XX3J5/kIF1dXl3fIqDi4GLc7fKz7t8lYeWgJeYmJiZmpShkoGvqOLBk4i8kMHzyczm2tm10NrWgICJ1q3vuLSaxJXG1aXqp4ie0NHD/47zmqbYmOOnuLTT0+TOn32BtPbp5++a35qn4b56ocjh5qOHgNuSlbqG5LOIioqIl5qWiImIuYuJms3ckryPh4abzPb0gaTUycnUgaSvHoOVl5qcnZydnJ6fn6CgoaOlp6eoqamqrKyurq6wr4SxC7CxsrKzs7S1t7m7hLwHu7u6ube1tISzgLKxsbGysrGytLSzsa6tq6qoqampqKqrrK2trq6srK2sqqimpaSkkd9rY1xfYmFcrKyrq62puF1fX2CbsImJr2FgX1tdXF5gY2ZjyLrBuKyprKaen6Shp2mLeZmcqXWga9WNoJ2Sv9fDy9HZ2tbU1NXU09HOzczMzcvLys3P0M/PgM/QvNDQ0IfLspyRlJmctnmswsLBwcC/vr67ubi2tbW0tLKxr62omY2RkZOWmJqbnp2clYF25ZvgfJCGfISvft7VhnKB572Iqcjf0+uEgLO7gPez0Jn01ayizZOhpoKRwfTRh4Db3bezjYDW8fvWioTAjp2dlLWh0YSGiZTTp73EL21+lIijpaempaShoJ2enp2cnJybm5qZmpqXhJeNbb9+gn182ZV82cNuh651kpGShJFikJCPjoyIhXtrq6WOgcaom5WYlpmVlo+PjpaVsqmf48n86YPfq4S9yeTM/OuVm5zKkp7krYOUmZKj7r7cl83Y0vWOyLKuodWNktzx8uuey8GvqIaNg4WNyOzJjPnx8466ndmAN0RDNGJbiJ+pf1NpdSsrLzIrKTg2MjI2TUI7VWlWP0AxK1xCQURYMlmKf0wtNDk+aWl4f0dguZ9WO0rAp9GCk4dlK0M5LS8qKDNCZTI+MTpQcC0sKzc5MjlARlNvkYtTjYRkPkhEPiw3P06EfFd5g35kNikyODtmemBPRFhOU4iAiFVFRFRdOzlLSFVTb254hmxcPj09azUuPkMzN05Zb3pyZWlii3J7eIiWYZCPVE18XDc1Ky8wVVFKKTBDNEWATVNKa3iJS1KCX4xoVC00LUVdYU4siqLDbz8+LSJFKDvBpvqbn6Wnvb2+vr+/vr+/v769vLucip+9rYJrS1xLRS+AR4qKnIV8WT5ffoG67G1+uWeCZl9mjHR2gHFyWG5YOjpbXkFMeoaFv6jwxH+YpKWctG+4dnPBZnF2amNeSll8jIJjXFGBUVuHnYeWWGhkdVtafU22k+GgO3y1w7S7k6uPwYozYlNza2aordCkloqJl4Fwa3GCenRcm2lwiWxTWkAna09Ta2drTVVVUFlUXVw4SWuRrqOYnZaYoKOjp7K1v7O4is3h5dKGhJ2EnoSfgKCfmqeZdnZ6jYxfXLeQwtGAfsaOeZvHy7hdcmSNbadkVWZZOIlVWZSLZZeStrbZcrxYn89t0Y63ut3X6tKegYWnxebq4IHelXy1nXKbr8fTenZr1GlsmF+lroaJiYeXj5mKi4m8joucy76Fso+Gh5rJ6OR+lr65xdNqoK+HmZqcGp2en5+goKKioqOkpaanqamqqqusrq6ur6+vhrEIsLGxsbKzs7SEtYS0BrOxsbGwr4awAbGEsA6xsLCurqurq6qrqqmpqoWrgKqpqqmop6alpKOT+omDgYGBgoH49vTz8/H8goSDgsz0t7TPgIKBgICAgoWJioD68vPr39/g3drc3NzfgKSQ09Xdj7WA/p+zsprG3MjP1dvd29va2NjX1tTT0tHS0dDR0dLS0tHR0L3Ozs2G0sW7uLe2usaBr8PDwsC/v769vbu5gLi2tra0tLKysayflpmZnKCio6SmpqafjIH4pPGEm5CHkL6J+OuWgI//zJO11O3g+IuHvraB8X6TdurUpqLgoK61jpzIrHxeOHybwI9IR2ymx9mVk9alrq6y2Ln3mZyfsfjG4eyDlrGiwcPFxcTDwL+9vr28vLu6urq4t7e2tJ6zEKmA45CZiozvs4735YCi0Y6FrmStrq2srKyppaKWgM7DppXkopOLkZCTkJOMiYmHfnNuPWZmhYpKf1cwMjVCRFRDMk1pimFHZE88QCUrNGFTZy1PV0tMKjk6MjJLLyhAST9JMjg+Nj8kIzErKjFJPzJhWUoySEJmDXx8fH18fH19fX5+fXyOfYJ8hX0KfHx9fHx+fXx7fIt9A3x8fYR8BX58fH1+mX0Efn5+f45+k32Efgd9fX59fn9/hn4EfX19fIR9g36Hf4V+CH+Af3+AgH9+hX0RfHx8fX19fn9/gICAf39/gICFf4R+BX19fX5+hX0Kfn59fn5+f35+fpJ/AX6LfQJ+fYV8A31+fYV8inuDfIl9hXwKfX59fXt7ent7eo97Bnx8fHt6e4d8Dn19fX57fH1+fH18e3t8hHsBfIR7g3yLewN8e3yGewF6jXuFfAF9jX6Ff5CAGX9/fnx8e3x8fH5/fnx7e3x7e31+fX19fn2FfDN9fHx9fHx7fH5/fH1+fX18fH5+fX5+f4B/gICAfYB/fH1/f35+fn18fXx8fX17fX5/f3+FfgGAhIEGgH+AgYGBhIAMf35/f4CAgYB/fn6Ahn+CgOOBiH+HfoR/hH4BfYt/jX4Nf39/fn5+f39/fn9/f6OAAX6HfQF/pYADf39+hX8Ifn59fX5+fn2HfwiAgH9+f359fYZ+hX8Rfnx8fX18fH59fX18fHx9fn6IfYh+nn+Ffgh8fX59fX5+fpF/hH6RfYR8A318fIV9CHx8fX19fH19hHwMfX19fHx8fXx8fX1+jH2EfIV9hHwHe3t8fXx8ewICBACAhZXHjMyQpZeM7ujQi9+ls5mRkquJfcJ0mK6uuKrhyXrzo6mSqpit0PO2xeytlt972ZCBgcnRnL2aleTBncj4pfK2m7+StYOQkLmMhsWprq24r3jnftd4m5quy6jDsq+2vcyk9Ifo1umOmrjXi+272eizzLCUte7bzqO9jNnHvfGAmJSuwqnSiZrNhLaJk6qu/8PGisORhaiis+mrupbJ6OjvkrTK4MfCnMP8qLbh6cKFjIGhrOP3lJjX05+8zsHwkIiNkdeDjr+DmIHnyNLN2ZXYgIGRnujl0MG71dLX197FfoN3v3HQhYCEhYaGh4mHh4eJiIqOcHqMh3p5hqmvfXmAhJtvdYO92cqPhau9dbeQhph6inx7eWyqctCuiG2gu26DdoK9rYWUXaydgoiQiY+FlY6FenrucHqpf6t0b4W6kIK8najAnMK8sI6D79ymv9+Ej56xhYOMnMGSnJ2n6ZWl34TQ1pHKg228xq3t2PyJ176YnqvLwn2P2bWTltTD2Zsqo5u3y5+pt553drnH2Zukj3CTX25onHA+REVCREhNQ0FFS0hLR1SAh4mJhIqAjY6QkZSWmY3WmYF1yrym6cPBqbajlqaOl3B8uXmvps5/pb+bwJOElo3Itrl9qpx35aaUtKR8q9TEyKevj4Wi6PLz0Zqjr9K3kOPImMGAr7Hj6K2ZiKuHgJex3rHYy8iQjYrXfr63i4G/pJO0jbHM53x6zu2EyYmyuInC8dvXtpsKg7jJkJGSkJCQkYSTgJSXmpqbnJyenqCioqSjpqaop6anp6WmqKurrKyusbS4ubm5uLm4t7Wyr66trKurrKmnqaqqqaqsra2qpaOioaCfoaCipKWoqqysrq6sq8+QqqajoZuZUpaWiouJiXl5d3h3c210fnN0dWhsX2xXdH+Cc3BzcnFxX1tfX15cXVpegF9hYGJfYF9gY1peWV1fXltZVmFpaH6HdYlqknypsKCgnZihmqCMmKWglo+LkaSztZvHq6XHln52WlZWV1JbbHSWsLCysLGwrq2sqaemo56CzrWbbFRLRkhJSktKR0hUXllHclaYj5KKgXh/gH2Af3Nti4uBfIF/fn2Af3+Usr2MgNeM8efV2cuWnJSWc357cXHJq9LAoqHZwLF80oCOk71xa2dsX2dvb2RscWptbGVvZF5iZYiSXHFrblpemXONmZGIgbRpaZmrnWx4j4FvwLiwuKatn5nCsayyuW9tfrCCfbV1ba2Ma6SLk5GNgn+Ejod/fMJwb2vegXR7enWImpSgRM6C6Y6gp+G0rHOTo+d86XiztKmVhfLIlX6brbKdlZKAlrjWyLq704aKoXSIjX3p44nFxIeOfoN4i7/Mvq98pdyilaydgIeOx3zRp8GHgdbb5Ga6uLOXg5+km47QharGyLKh5rGD6LW9h5Jth7WrjrzjqpXvhN6RiIjAupW5j2q6qpebyaX5qnSafJ2CjZjJmp7gocO+uLiF5Izog6OatcKSmZa7sq+infaS/t3/m6SoqXC+jp+vjpqRdoywn51/jmifkpKua2xweIp8mGNslVuNcXN9gsOUll56X2R4fIS6h553n6yys2+KmK+LkXOIvX+NqqyTaXd1d3Kas3d8q51shZ6UtGpocW+dW2SPa3Zlrpe4n7+M03dvipzp99XCwcvN3ujt14mPg895z5GOk5WUhZWAlpaVlpR5kLGtopurq6uZm6nIhZiu6Pj2npi2vHzfs6XDqLWep7Wc7ILx4bONxOWGd5On6smipW7Hq4+Plo2Vm6eanIiI+5CZqZTGkoV2amBzvL2zsH6jrGlcZczGpZ2FaXh4s45qTlyxo6e2quiUtuF4fHt955uB1ty379D/lP841J2muPPhkaP01ay0++30iKmxwcKgqraxgYnl8/Wis7OOxYiooeGTX2pqaWtvc2trb3JxdHF8lZCFkYCSk5SUlZaXl4npoJOD1sy4/dzRr8nT0NinuYmK0oC6tuyKquK25JeQqqHVxtmBqKSB/7ORwMGKwe7R0qfCjYSr2uHiypaapuC0jeHIoL2NvbHX06mRireOiJ284a/q3LyDhITXi9++hHy/ppaym8Da+Ih/1/KFz42ytn+/5uTsuwaihMTXlJaElyWYmZqampudn6ChoqOjpKSnp6ioqaqrrKusrKusrK2urq+wsbO1hLYHtbS0s7Gvr4WtgKyrrKysq6ytrq6rqKimpaSjpKOjo6WmqKenqKempdSMo6Ggn5ymY8DDuLi3urOuq6uqqKGprqWooo6Rf45wm7C0qKWpqKajiYaMjoyLjIuPj5GRk5CQj5GTiY6IiYuJhoSAiJCNpauZsoKpiLi/rq6sprCpsJqntK+loJuhtMPFgKnluLHev6WdhoCBgn6JmYylu7y8vLq5uLe2tLKyr6uP69O7jXRsaGlra2xpZmdyfHZlonnMw8S6s6murauurJ6ZtrmtqKiqpaKmo5Kiwrx9vHLNwbS+y5ygnKmQk5SXg+K+5cmppO7Qv4/0iauz9ZOOiY6BiJCRhI2SjI6Mg46CgHt/g6y5c4iDhnB0w4yntauimNB3d6/Cs32OrZ2A8OTV49bazcro2dXW4oR+jsWLh8l/eMOefcOmqqOel5OZopqRk/GBg4D/k4mLi4eww6yw9pH/p8XD8MDMkae3/YLxhLugl4+B79iakbHY1KunkYCZxPrv3t3rnqylh6icm+D5FJbWypeilHyHneTV1byBsOecp6+lgDgyPi9dUGRkaqWoXik4LjMvOS0+KixEMElIS01CSj0yUzhBOEU8aHRqYXBeKyo2Hz4tLis8b36bUDV1ZUtmjlaJZy9QQjwpKy1ANC8uLzVCYFcoTStUJzI3PkA9ZVlCUUxmQkopQTxAMThZeVKJYWRqTjopJC5EV1tbZEZpYW96gERMSldQWzhJXjpiW1lcYIZWYD5OPkZFKClXWXdaeH6Ih1RrdoxgYkldg11rf31nQDcoNzZdVCcyT0knOEVhiU5QVDZsP0ZdQ0VBfm5oa2IrQSQ4MWxrlkA7U1Y0PEdi4aiwmbWAn6ituLm5ubu7u7q6urm4sYmJfVxnWUhKQjY0gDhib2hqkIyIXJfC14bYf3uOeHVja3pln1+fkWRUY2k6N2N2vdy1xIHn0K6uuq2ys7qun3uA1mFbY05xS0RMOjlLfWtpdVSInD09SaOejJBqYW9bnn9dMTqdtqDHjpZsuslaTT9VjWpQmIp+vqndd6R6YGphd4RsaoJ4ZWONfItHgE9leHhaXltYQztldIBPXE1Kr6LmztWehZudnqCjpKCipKiprquzrZiYmJmYmZqampubnJycjdGggnfSsbL6x82stYN9ipelVoO8gKyUsX+amV6PQDZAMEUyXUyGaFaYb4+zjV+HucuuqJCRh7De5ObRm5+Qv7GG1cWWmmKjkMPGOJmFdapyfIuy2H2osLaDhITXeZe+hX7Cp5mymrvU4HuD1uR/yI6yt3/D6PDuvKCGytuWmZmZmpqbhJ0Wn5+hoqOjpaWlp6ipqamqq6usraysq4WsBa2urq6vhLAGr6+urqyshKsYrKyrq62srKurrKysq6qpqKenpqampaSlhqaApKTVi6Khn5+dtIP59/j39/j88Ozs7Ovp7Ovt8+fIz7PGi9X49vTx8vLy58jExsjIycnJy83Ozs7MzMzKycXGwsC7trOwsLGxsMbMuNOTuI69xrW1sq21sLahr7u1q6aip7jGx6z9urLh0Lq1rqyrqqquvJyqvLy6u7q4ubi2tLSAsrGtlv/o062UjYuKiomJiYiIkpuSgcmQ6NzYz8vFx8PBwLy3tLu6trSzrq2xr7WenLCrbJZasKSYotKnq626oZ+YnmZxYod8hGlrclpQnFl2e+OdnJqZkpWYmJOXmZiXlpOXk5SYmMzXhqWdm4OL6KXH18zBuvqRjdHq0IiLuJl4eOrk3eLd3trM2NLV2OCFkKDqp6LsmZHmvZPbu7Ofl4+IhIGDfnfadn94835xb2leVUFYVmlGfz8+QmRHNiAqNVwsTjREZF9cQWhhVi8+PEpQSTU4WkFkQz0wKzM1NSgsKStNWzdVRS0sJSwpKTo/QEEzRE85Pk9UDXx8fH18fHx9fXx8fH6JfQF8hH0BfIR9AXyFfQp8fH19fHx9fX1+iH0CfH2GfAJ7fJF9A3x9fIV9iH4FfX59fX2Ffo19AXyFfYh+A31+foR/hH6HfYJ+iH+GfoZ/Fn59fX18fH19fHx9fX1+f4CAf35/gICGfwV+f35+fYR+in0Hfn9/f35/fpB/AX6LfQJ+fYR8AX2EfgF8iXsIent6ent8fHyFfYR+AX2Gfgd9fX18e3t6iXuCfIR7D3x8fH19fXt6e3t7fHx8e4V8DH18fXx7fH18fHt8fIl7AXyHe4J8hHuDeol7BXx8e3t7hXwFfX19fH2PfgF/j4AffX59fn59fn19fn59e3t7fX18fn1/fn18fn58fHx9fYR8CXt8fHx9fHx/foR8H359f32AgH+AgIB/foB8fX9/fn9+fH1+fXt8fXx+f36Efw1+fX6AgYGBgH99gIGBhIAXf39/fn+Af3+Af4CAgIGAgH9/gICBgIDZgQGAhoECgH/CfoJ/loAEfoCAf4p9AX6QgJJ/gn6XfQd+fn19fn5/hH6KfYp8AXuEfJZ9hn4BfYd+gn+EfoR9jXwMfX5+fn9/fn9/fn5+jH0FfH19fXyLfQF8iX0DfH18hn2DfJZ9hXyGfYV8gnuEfAICBACAsuCDmLx4h7/JmpfK977Uyr+JsZafssLpjaut8IrLrZPV1ZuIhYK9yO6Qt6XIusq5uNyryMmcveTp9OWSyKiolYmXmsOoopXwgriKsHyUoK2X073D4MWF3IWTe4fLqHmEgYKExamEncbmkIWFv7n47J7usa69oait7KWfppCYm6WAmIiNuqKOkKay95u2ysy7huKvnYjdooGOiIfrpIKKnIqEt7DKm8Cb5oGcraaZmKaWpNuFmKSLl6aE76mjwIWh84edo+aE1uHWo7P0pYuYvLKThoCK/LOwpa+doa/Eyuh/eoe0iLDGuLx7g4KFhYSHiIeEg4mFZXmLbaV4Y5Ktcn6ApY6VhmaUu3q7id3WjKdtob6zZl92kl61kbSHnG6dydOVaWLBpLpjf6Z2l4WjsbN9fq+npZeUZ3BtdY+IaHeFsLSGlIWuo6CXpZ+7pMvmr+SEsY6EjaCEgOiqidzJxpzan/DOjK6CqrmXzrfWgoyi657im29zpIF2vZZsycnW9aqAt5qan66y25m/wnJoequ7f2qWYlWMm186Pz49Pz5FQj9CRENIS1qMfISEhIaHiImKjI2PkZSXh7mZfdfUlM+Vj72KqI3Ps69/c3yyp6V51IeHdHx8pJiMnY+64LOElcmQs5fLyYytjeSn5YrNhN/j5YnSvsnyrIN0xNaOlJuvmMlOoa+81vP34aXQo/G2moGGheuyyff8q/+kr4PX5u97f+HanJ+fp66x6tOOjOWZo4iK3+KMi3Wpk5uoe3p+bYqRd216ia6WlZLMfZefoaKhhKBnoqOkpaanqKqusbGzs7OysbGvrKmop6alpaWjoaCkpKOjpKempaGenZybmZqanJyen8qflorMppOztKuPoo2eWKGikouCintpamlxb25pbGpsamxXZmh/b2N5b2toaGlmaVxZU1RXVoRTgFZYXFpXWVpXWFdWUlRRT1JWYVdLSEdIRUZHS1uKhIyLhoZyq5hfbHWikGB9f5Rel5B1rX9tc3BQT0xISVFMUYO7ynWNioSAdGzI1LaLYUuQk4eDf36DiH9peHx0ZmZmXE9+eYSBfnpxcnN1c3eDind5eHByZ3JrZHtxb4z584bagMWxqoSF2KCenXNgm5lrcdnSwJyWuLqVfoXUc27DtmNmYWRbYV9laWRlZGJeW1hPSlFXU01UVV9bZWBjbWN1dmticGlubnBua7bbdsq8rKe3vG3KccTFtsLQbnClxbGce4V4h4GGeHR4dnl4c4B40pB3y8zd29G2wtnjwo+BhIq5Q7SMq5N9c82FvPuchriHhqWRgH2JlI7Zq5qnmZ+biM2ntMNxd+yJcYyblrTNzJGH4NzSoaJ12djIraXJwonRutTVhJiAq9NviMOhpsPAhIbX66/y0r6Qraawy8T3l8e384fKrKC7762Zh29/uKl+l5LMxbmysNigp7afnc7iy7V/zJuUint0c5mLk4n4jsmSy4WSqL6WzNnB1diK8pOoiHednIaXiHB5xr2Nj8P5mGtqlJC7qXawiICRgH2BtXRzeWludXeAcWRmgHBhW3R7q3KJmJqOaad4a1eJZ19qZ2GyfF9ndWljiYWYdpNpn1tqe3pxcHhwjLZnZXtoe4pqu31+lmR9umd4fahhob2ZdY3GfGZupKeSgICK8qq9rK6dnrXO2/eKgpLBjaLLwbmIkpKTk5KTlJSTk5SPcpS2juKYhJimkJCAt7ynoIK914/inPfckcuJx+T5kJCUxIPtwdCMmYbN4f6Dh4PX0fFslcaNsJO0vb5/gby7wq+uipOAjrGihYmBs8p5oJysenBtdnaxndzbk31ZinWLiKNYbuG3oP3j06Hzq/GHfJyWqbu17d/jgZK59JrdpYGKupWG1rGI7+/763mAlY6ZrcHF967e7YyCl9/1l4zSkH/TxoZdZmVlZ2ZramhrbGtxdH62h4yMjI2Oj4+QkZKTk5SVitejgODblPOrnduq0bDw29+QgJrCw8SM5pGhiY6Ux7WmrqDW7sCEmeGetaLm3Ju9nOCi+IzKiNnb3IfCtcnvvpaF1OOCla2lnb5cnqXA3P76y53jqfO6lnh+fuTC4+/xrPairHzj7fSDgebQnaGdwLyz48uDlO+fqomM6u+Rkn2/qrG8kI6Rd5KYgIGOm8Kqqqbghp6kpaampqelpaanqKioqaqrra+EsA+vrq6tq6mpqKinqKempKSEpoCnqKimpKKhn5+dnp2enZ+f1p+Yjdm0oczDup+ynrxuw8K6uK61r5+dnaSioZmbnaGanHaKj6KXh6mioJ6dnpmXh4V/gYSDgIKCgoSHi4mGh4iGhoWCfH17enx/h31yb29ubW5uc4G+vsnJxMKa2cZ9i57YwoexssJ1u7uHz6iWmICXeXl2dHR+eH+l0OSBm5iRjYB65u3SqIBrzNDDwLq3wMO6n7S4qo+Uj4Jusqy2sbCqoZ6epaKkrrGhoZ6am4yXiYaTjIyY58touKiak3J6wZWeoXxstbaIh/f02bOjydSkio/xhI7/7ISHgoZ6gX2FiYSGgoF6d3VtaG1zb2pwcoB9d4R/foqBk5OHe4mDiIWGhYHj/4fu49XU4eOB8obw8uPs/IaC0O/Tvouik5qTl4yJi4eMiIaQifegi/Hw+vPj2Or5+tjBnamz1Nam1KWZh+mT3/uZibOJlreThYGNnpbixMC9x7ewmOext9OIjfWXj5eofNHs56mf+e3iurCJ3w316sG12tKF0KjQ3YuegERZMzlZO1FwomhXZFpBPTFEMDw0NENLbT0+PGA2RjE3S046LzAvUHtnQl5DLzY7M0BoOjY5RWB6hY2CZI9tbUo9OjhgSD01UjFAMDceKyY1OUJHSE9CLlIvOjM5ZEQnKywuLDtCKi0+SThET2xcampLUjwwLyQlOU9LTVFDSVRPbktEQUZALyVBUHNPYnFzak1vRUUmRT49IicmaVhETFdOSWdkclx1PE8xOkRZUk1QPDNHLzo4LygxKlozOEcxZJRSXVV6RXFuaVFLc1ZNUmtdQigmMmM+MjowNTIzNTtKZJixrk5mo615pLW1tre3hLiAt7apg4JjPWRWNDo6Mis9Y1hGN0xwW9dw2eijymKIl6FTT1VpR4+FnWRhR6OLdkBNSofE8Ya11JjJt+Lt6Jmd57zHwZVeYFNYYVdDUVNbaUt+hXZZSEdaWal+7cN2XUV6Y3FNVEFUvbSr8L6Ua9txpFRNYE1mfXOZmrpxhJurXYSAZlJNc3VjdGREdYaMgT5NSlZkam6FVW5hNDlHZWtQdtqslc6vmIaYmZmam6Cen6Oko6ipsumQk5OUlZWWlpeXmJiZmpmKl5975NmUxYiPqY14Zsygr397d7WddnLfiFhDSDpdSEo+QGBxiWNqYWGmk7DCgniW46T3kc2M3eDhjbdeu8rep2tbzdtzbpSOj7iQmrfVzunKmdOczaGReH5+6LvA8fOv96OtfeXy+Hp75NShn5uzsLXmz4WT86OnjY/t9JSUg9TAxMyjo6SAl5uGlqGv0768ue2MoaWnp6eoqIWnBqinqKqqqoSrgKyrqqqpqKenpqamp6enpqWoqKemqKinp6WlpKOioaKhoKCfn9mfmpDkxLPjzsmxwqvdiurn5efl7e/t4+Hi6uvi5eHr4uWpw83VzLry7Oro6Ofi0cbFvru/v76/wMHBxMTDwcHAwL+9vLSzrauqqKmjn56dnJubnKOt6/L//vz4gLPx3I2hu/fpqNvd3oPV7ovZvrKxr6elo6Kjp6aqt9bqhZ6blZGFgPT94ryahv788fLq4vLw7c/o6tOtta+hhNXLysjHwLu6uru3tri1srGwqKqjo56fpJ6chbqiUJiUiH9qdLWTpKmPhOPUgFmRn1xTXF5YYlhVjlp3vOOSlJSTgI2OipCSj5GOjoyMioaDiIaDg4eJjYiMi4uMh4uIhIGDhYZ+fnx55u535N/a1Nvecdlu1tnO0t9uasXU3bN6oomLiIGCdG1rbGloZ2XHamK5tcfCuLq4sbGqiUA2PUBJNTEyKSdPKzpfOj48MS5BQEVZVkxEiWJAOjErMChNQURVISUjRSYbJS4xSEtTQDhpYEsyMSNVVEtDRUpJMVJHVWBBQwR8fH19hXwEfX18fIh9B3x8fH19fXyGfYR+An17iX0BfIR9hXwBfYl8B319fH18fHyGfYR8BX18fX19iH6GfYN+hH0Bfoh9kX6Gf4R+hX0Dfn5/hYCEfwZ+fn1+fn6EfwN+fXyHfRV8fX19fn9/gIB/f4B/fn9/fn5/gICGfot9A35/f4Z+jn8Efn19fIt9DXx8fX19fH1+fHt6enqEewZ8enp6e3uEfAt9fX18fX1/fnx9fYR+Bn9/fnx8fYx7BXx8fHt7hXwFe3x7e3uGfAV9e3t8fYZ8BXt7fHx8hnsEfHx8e4V8Bnt8fHt7e4R6i3uIfAV9fXx8fZB+j4Aaf3x+f35+f3x8fXx9e3t8fHx9fn1+fXx9fn6JfBF7e3x8fXt8fn58fX18fn+AfoeAInyAfXx+fX1+fnx9fn58fH18f39+f4CAfn9+f4CBgYGAf36GgAGBhH8CgH+EgBF+f4CAgIF/f4CAgYGAgIGBgYeAhIGIgLuBCICBgYGAgIB+hYCCf5Z+AX23fgd9fX5+fn19hH4Ff359f36MfQN+f3+HgIZ/kn6cfQJ+f4Z+hn0EfHx9fYp8BXt8fHt8qn0DfHx9hnwDfXx9hXwEfX18fJF9A3x9fYt8in0EfH18fIx9AXyLfYJ+hn2FfAZ7e3x9fX2IfIR7gnwCAgQAgLqxoreMca2F1oCjjZqiyNHOhdKKxIOusXR/t42Uxr+f3cmTdnTE6oXNgPT0lPG+1a21y/C8hZPZ8Yi1kYDvvo+UhJeD4pD+qoy6ocB7+uv1mNuNicv2sobiiZrf+H2x15Kek36YkfGFu7C4yqyJnOOVv6uGm6eorpzA08rQsqmsgLnIm4r4+YO7qrLgmdDj1dWd5YS7+fm+roWMprmKjdKAob/D7s64mtfP9KHn1fvDiPCki5icp521s6iUi6Hcvoii2uHL86qnuP2qkKetstPS36WZheWSibPHjbPBtMd5lHN6zpGkrYuN3bK0vXR5gYKBgoOFhnByh8ikbnCDprPTgM+/i6p0d4RytbWPtMCC2ILAlW9mg2aLu6XhjKqVncW7mWywvq9uoq+gfpF3fsGijaNpZbWvcXTIgHx2kIuAjJGxv6vrmdm+p7ONzKmZjq3imrKZoqW1fJDppLOxpJmfiYng7s7SkXaHqKylgIGpr3LEerBmwOHeju2ofXuM8qi9gKvcy7OGh5q3ZW9wbpSls6qbYFV1kV96R0tIRkM/Q0ZDRUpISEtaWcF9f4GBg4OFhYeIiY2Pk+DWj8O3052AyNOSebBxdYqquJjL0YqV3sduz8K0xcxqeoeRl6TZ7H3g66SxfLbGipTJ0MS+0tHR0teu9oeNmabx0oaprYWLm5HGgMvlouDl2YXk07fet4O19dSDy3x5oX//p4+1lcio17iVxoa8nK3foIVujIWJgISFhoWzgnN9TUNDQT4/Q09lhUxCQ0JHS0pJTVSFl9V0kJmZmJmbnJ6en6GjpKirq6ysrKuqqaeloqKgn5+fnp2Yl56dnZ2eoaGfm5mYlYR5f3JvgMOXfX6RcmRaW2pHV1ZSSpV9dniCfHh1d2pnYWJgZWRjaGNlaGRiYmVMZWZwaGZlZWNmbl9WT0xPUVFPTk9RUVNQUE5NUlNVWkxPUE5YWVBLQkJBRUM/QkFERU1dbGecenV1cHB+e3R0WF2BbZKPjGpdVGdkVE1IREVGSElNUmKEgFNSUFFRWF9eZWFbXFdaWE9PTlFMTVBQlIF3fHVtYGh0ZWVvcXB0bG94enZ2eXd3eHh1eXh1dW576Y2CgL6TytytlN3xip2GnJjT18KwmI9/f5C0j32KjHXHe5tgYWVlZmxhYmJiZGBfTFNNTEl5Rm53UU9camrLvm/MbmnKzNLPgL7L0My4ydN0csBzbnTIdHVu02vRv9bP1sJ8dW7ScnaD0XDS0Lxy2Hy04XKzd9J6x62pumySu8aqcWh1cYuDoJ2f4vDl3oeNitSmg39+cpWDgn+Kd5Zmk5B5iaS9r7PYwaKin4rts9CSis2egYqBq3yVr5CY36uporaIk/nUnN7EgJuTm5GTh9WUxWixna2z5urafNiX25mt0YGUpIN/p6Od09GhgYKrf2rRi/bTf+ii2Lm1uMeqeozn84Ccc3vpsnl1dIuCxHHjn4CfpdKD7PTyhLN6kuLuxIz3la7W4IC245asnomigLJ7zrG2qKF4gLR3lIpmanV3fW6FkpOVgX9+gISSdWKkoVeBd3yecZytpKJ2p16Cp6Z+gWdrgJBpaZddfpORsZmLcpOLoWiplLGIXKt9c3R4gISPh310dXqrkm6Dqq6ft4CJls2OfZaFn8O7yYeAbLuDlbrElbXCvdGBnXh/1pCjrpeI2sDGz36GkZKSkpOTkX6Nsfaph4ydiuHlgPP5qsiWlKCK3OKjxM6Q14nLqYKFsIu+9tXoq+rFxPPPj4jO9PGU0dvBkp57iMarm61zcMPQhYz4r5SMtaqdrLHEoHOter69rJ10eYCkiZqhYZSJtp7DhYK9r8vFrq6slJPQnpuyk4qNoq/Bf4C/zYS2kuKC0f78p/HAlKK354LUgM3/882TorzwhI6JgabF4+bgjYSuuoO2bHFubWplaGxrbXFwcHOAgdmGiIiKi4uMjY6PkJGSkuXVjMC+0qeLz+KlltWRkbDo5qr87pqi/NqA/PDg9P6AmZeerLfw8ofs8qyxg7zbn6fNycPA0dHU1Nau94qVlqft7Zm8qoOEopnIXMbdpvXr1oHj2cnowIi16s6H44+Ap4X2q5S1msa5+cCWzZXMscHtt5J2kpmPgYSGiInCiXypb2NhYFxeYWyGqmthYmJma2ppbXSoquh+mJ+gn5+hoaKjo6OlpqiphKoPqaiop6Wko6OioqOioZyahKGAoqOjoZ+enJqNgol7d9SqkZq1lIR5eYZgd3JsY8KpoaOkoaSgpZ6Yk5STmZeVm5aZnJCLh5FlkI6hm5ucmpeYmYqCend7fX18fHx+f398fnt6f4CBgnd3eHZ/gHZyaGhna2plaGZobHKDmpHPpp+el5eopJyhgIatm8C6tZGEfY6AiX13cGxtcXN2eoCTwHZ1dHV3gomFjomBenh8dnJzdHdyc3Ry07issKifkJelkpWdoZyhm5yjoJ6fnZWWlJmQlo6MhYiL2nFoaKB+sMGShaXPfZKOsrLf4OHMppqCio2uloiJkYrlm8mAgYSFhYt+gYCAgn19Z3BqaWS1Y6qybmyAeIaG+/CH/IeC9fn++en49vjl8vGJhuyIgojvh4aD/oD54vrx8eeLiIX7hYWQ64D48N+B84bP/IDXhfaH5c/B1o+y2e7RlICNh6KexbCy8vb68JWFdcGfh4uKhp6Qj4yRhbWAppaNnqDg1s357L2+q5H2vOWwm/azj5OQwYyNzaANoue0uZ66eX/TsJfYxYBVTFE7RUJeWpFLbDsyODU7QCMvKz8xSkkwLTk4P1pBMkhCLiomPzw8RiFLeEZqQj80R1xqW0hhhLVvdVZgtJBXRDE0LXhCcU1LUz1BIkxITDVHNTVESkAqSjNDZ2IjMTgxNS8jOjNcNUFMU3FUTl+DXWY/LC0mIitDV19jY1lbWoBZY1M7W00rTUxLZk10hH14Um85Njo7NCsuRFtqTE1tP1Bsa4Fya1FJRF45cGRsTzNcLisvLjMtPDs0JiAvR2lbbouDe45gZF2ENTBGZVx8aUw5O0VgOjQ9NjI0NzA0K2CDjcBAZmV6MMbEssuPobS1tbW0s7CViGtxUjo5QjtMWoBabEdDOTU3Y9rQl9HVjJdsjWZPSFxFV3+IpW+KhrONgF1eg6u4cb/iv6y7lprwy7rSiIXq7YGG2mFgVmRfWWNoc15HgFWBmp5+XUxitH+Oh0eEdphQVUtVnbbIhHBuaF1SdGNhbFNMWnN3c1hYwLFTWj5ZTH+5vnKQZkxBVIc/aIBqeWVjSmxqWT5ENT9QRVG69LWjpLOK6JWYl5iZmZ2enZ+ioqSkq63ujo+PkJGRkpOUlZWWlpbu3ZG/t9mlh8vWbE19cWVnlo2psdZ0k/7bYm1kcm9nWlI3NUdLgIdVsdiirHaVw2iO0MvFxNTW2dzdtf+MjpKo7sqPmo9udnWIyFG80X+mt8V92LW11baCtuzQh8KDgqyI+q2Yu5/OtcTCntCH0NiUkbiZhpmjnIWJi42NxYyC4Z+PjI2HiIqVsNmYkJCQkpaXmJuh2L74hZyioqGEohCjo6SkpaWnp6amp6alpaWjhaKAo6Oinp2jo6KhoqSjoqKgoJ+TiZCDgOa/pbPryLSsqbeEppuOhvnb09Ph2t3f5+fi2tva4t/d5eDh5dbLwtWK1Mvv5uTj5N/Y0MvCubO0t7e4uLm6urq5uri3uLi3urGwrKanoZ2bl5iZnJ2XnZiUmZGfvavmvLWwrbW/u7fKpKSAysDew72xrKqsqbGqn56eoKCipqq88JCTk5WapqWjqaKgjouOgo2QlZKSlZCM9trRz8rGv72+t7m3tbS1tbK0srCwrqyqqamloqCdm5Z3plhSVoxrkKh7dWyYWHSi4N+bfGBYUU5TU1l1X2BfXGzPfciHiIqKiouDiomKioiJg4WAgoKA+oDz94KBg4WF/Pp/9nt88Pbx8+vr6+nj5ON0c9xubW/acHBr12vXz9jZ1tNtb2nNaWhpx2HIu7Jjw2C1vWK3Yr5gtrWssJyhnpaXkj4xLCoqNy4+VmuGWzpFSXtGLi8ySl5gXVtbUlYsMC0nLi81LTFIPSs7MSdKLkk3MWoWSD5NRFMqNDo4OFpKRTFLQ0NmTkxqVIR9CXx8e3x8fXx8fIR9A359fYR8in2DfoR9BX58fH18iH0JfHt8fXx9fXx8hX0CfH2GfAd9fHx8fX19hHwCfXyEfQN+fX2EfgV9fXx9fYZ+iX2MfoJ9hX6Gf4J+hX0Gfn9/f4CAiH8Efn19fYZ+jn0Bfoh/DX59fn5+f35+fn1+fn6KfQR+fn9/in6KfwR+fXx8hH2EfId9Bnx8fX18eoZ7EHx8e3t6e3t8fXx8fX18fHyEfQN+fn+IfgN9fHyLe4N8hHsHfHx8fXx7e4d8BHt7fX2GfAd7e3x7fHx8hXsBfYR8Bnt8e3t8fIV7C3p7e3t6ent8fXx7iXwGfX18fH19kH4Bf46AGn9/gH9+f35+fn18fHt8fHx7e357fX1+fX59hXsBfYV8DXt7fHx9fn9+fH18fX+JgBt8f358f399fnx8fn19fHt8fH59fn+Af35+f3+FgAJ+f4mABH99f4CEfwh9fX5/gIB/gIWBA4CBgZZ/goC0gYOAhn8BfoV/z36KfYJ+ln2XfqJ9BX9/f35+hH0CfHuUfAN7e3ySfQR8fXx8hX0GfHx9fH19i3wMfX18fX19fH19fXx9hnwWfX19fH19fXx9fHx8fXx9fHx9fH18fYp8iH2GfAJ9fIx9AX6OfQZ8fXx8fHuFfIJ9hnwEfXx8fIR7AXwCAgQAgPSp/M6Ec7Tn6KWx1LeIhoC9gtWR0abAmMfwq4uhpZy6rruktIuA3I28vYij9IiDzarD84LJtb/Zx4LbjYjvhYH4xbXemsjQxYyWm6CQouuahtiFjZXJjpWMm4byiaSmrXiHsX+bmeKe6bu0u66t38OnkZDDpaPqk7jGx9bb2r3cgOTb26PtgJTvroyF667At9Djl4Omzs7VuOXCzP/Q/6e2i7G6z9K4gpGv8v6smqqXg4/p26T28c+Cka+pj7LLiZG5ztXNiLWozrOE+4O6lJq837KF/u6+tbya6dXHmsLdl8vtk2/AiLbep6uLpqO0032Dg4Z6e3K7q722t7fTkK3JgJ5shrO4gna6ncmUn9jpfdPLmmhYa26KdVeihZK1u2525qBxgZxndKG9oKF5xIm9l7Oyd4e0baWOmZ6Jh4SEfYrcyOH27d/TdKeVsJ+K7ZajhKjtlZSRwpD3msqEt469s5HR2u+wwdeFyIyzt7C7nMd0zrSij22Dcoqr2IeWi5uKgK6tq2+Tz7OGm6xxdZarc6NykIGIajxBRkRHTE9JSkhDS0pITUZGT15hfJHSe35+f4B/goSHiImIiYTFwIBsiryif6WKi3iSnodmfcDJp8B0wqqNk7i+fLmuwpZ+i5jHhb2ae4qll3fRq6l+op+Uk5abo3mppIuXnsWDedCi2oehgMmS1HjRj7vumpiVjrXScI6or7ynop3CoMTLg3tvdsyHc66dV4eNr3jQrI6Skmybsbxkr2RFOTg5PD1BPDpCQT49PT4+QEJFREVJS09YdF9bqH+0bGt4gIaIhoeGjpaZkYmMkZiXk5KRj5CQjo2MjIuNj5GSlJaWk46OzXdsbGNigGBjUX9bW1VVUFNMSkdEgm9nbWpja2diYF9gXV5eX19fYWBgYV1jZGZIYGBnZGNhYmJpXFRTTkpKT01NTkxMTU5NTktJTllUVElQUFNVRkFBPj4/QkE+Qn50d25shnRzbm96fHZ0Zl5YZ25VUVFeYVNRWGJOTkdCQ0NDRkVDR0xOgFd5Qz07Oz9EU6OjtLannIN3c3yAeoFsc2p3altgZm12fHdtYF9vcXltZ2Vka2JwdGBvdVpQVGyG+fzYrZaV1sC2woDwo6CCta6SgcyugaCarYjDr4X2eHSGjGJdZWFmYl1qb8JvW1pjT1KldmVocXuGwb23qqyyvcHIv9Zqwc+7gMS1vL6/1sDR2L7SyszNzszAt7XEs9zJ29necXPK4tPfzqvL6uB56HrHdtrLzYWipo6MkYmVn5mpdoV5v9fQiouE4ee3v4qo69Kp7Mqw76nXz3B6b6DLnYTahn2Wtca0mYnRg4bbq694gbi6l/7XdX10xsHInZq2+qaEmeazsv7EgKeM/uqHgb/P1JHJ8tKefo7XiM6T5bTArtr+mZCjlprBurG1vJ6GeWu7xpWV1nN1sa6433C6ornW0YTtfHbqeGvMnp6xaXOPl3CKl6mYmOSKf913iZHWlImQrpfyjaqgv4iZxI+doNin98S9xbikw5aAbm6Qe36na4OOi5ijqI+jgKmgn3SmV2GtgGZbsIiQiZyocFtyhoyLgKKWm7+cvnuCbI2SoKGQZ2V8pq5vZXltXWagpoXPxK5rdoB5a4eiZ22NnaqkaIyPuJt3z3CejJOXv6Bpx7ygpayN2sO6mszzpNv7onjJirPhtL+csbDF4YuQkZGDhH3U1fzcrMv4gs/ngMCHpePHpZffuPi3qcL1h+vlsoiIoKjFqYXPocz65IOd8qSQstKWodDnsbSI4JzamNDAeZbSfcGtwrqfqKaTipffvKiGbZjJgb+jw4JSnHR7Z4uYbn2X6Z3aqeCX16vLyqaNfOmTnNSW8qLQ18nivfKL7+XCsoSWgJu0/Zeeeq6rgObk0oGw9c6jzdmCkqfVkOCt07q7k2BnbGptcXRub29qcnBwdW1ueIV2kqbnhYeIiImIi4yNjY2Ki4bOyJCFlsS3mc7CtJW6w6uGmdvz0fCQ8dOxt9/ik9nH1KqMlpnGhc2mgpq5tJDltbeNtbGpqamsuXy2oY+cq9qOitOg/pyhgMSR4YjfkMn6n6aen8fnfpu+x9LLv8Hcu+fmkIZ8jPCXh86+b6Sjwo3xzq2ytXutytl0y3tmV1ZXWVteWVlgX11dXl1fYGFlZGVqa254l3Rwz5TJeHyKkJOUlZSVmJ2fm5eXmp6dmpqZmJmamJeXlpeYmJmZm5ubmZeW45yQkYmHgIGIbKV7enRza2doZGBes5mRlpKLlJSRk42OjpCPkZGQk5KTkIeRjZRiioqamJaVlpGWhn9/eXRzeXh5eXh4eXp5eXd0eoR+e3F2dnh5bGdlY2RlZ2VhY7KjppmZtp2dlJShoJqaioR+k5aAfHyJin57gIZ2dm5oaWlpbnBsc3l7gIWvZGBeXmNncs/JxMe9vLyxrrO2sLaeo5ynnImPlZymqqWakIuZmZ2VkI2MjYuXmYWQmn1xbIKB0M21lH99vKOcnmjDlqaTyMWLhdjRiZ+UqInaxIn5hIigroB3f3uCfXaBivqJeHeAbG7bsaKlrLHA+PTs3tzf6u/47f2A6u7egOvc3unh9+n4++b38O3w8fDi39fn1/jm7/X9goPo++334cbq//2H+4brgfLv7qjFxKqurqOzycLLgJSK0uD4pKag+u3O14+w1Jx75NK8/cj39YKCi8jwwYzxmpCe0/LRu4julZvysruBmtDSnfPUg4aC19jpqbe885VwfrKLlMOYgG9ej3ZQQmSOgVhYTzYmJiI5HCspPz5JO0tgPUBSQj9IQjUzPDo4Ozw1LyJRhEZBRTJCajl4jpWHo2uxWljAW1GKV0U3PzxLVkdXRDs1Q0c4LUU8QDVILTIsOj93LysrLSIrOi83Ol1FWEFDST1Iem5eVEpdTUppQVZdXmZtdWJ0gHVrbUtfMi1wVUI2d2VuZ3Z9UDc7RDRHNyxMcIx2i1pZTm50fX10Ujo/V1w/MDwvKi5UaUdcVzgqLEU2KDE2O1ZvfY2ISVNQRkkzZC1lRD1ufE5ImpF/f2pRf3FEMTNZguukh4WqYZJfk8GCeoSu4amysrGen5fxuoKHV1lkOVddgEEwOUhKNzSil8vCtrbzdfaudVJMTE9eXUuhd5ypz2NUjFt1mrphc73Oycuc7J7phdrQj6znib+Pgn5qamNiXGKVe3NOPXOkfti1yG8zaGBqV3ZkSEdryYOis8ljwYt1alFTOHlcYnlEgV+GkbO0kZ5ii3Jxak5ZTlprkFJOQVpWgGNZTDJWnncwWmxBPktNO7KS49K/qISOkZKUlpiYmZmXm5ucnp2fo6qJo7j3jI2Oj4+PkZKSkpSQko/i24qBqNXCirpsgV+XsZlmZZPa/OdZeE5KUFtuM09JWkg7Q2Owcq+Uh7Sgq3n3wsScxcK+wMHD1oStmJuzv++EaruS3H+YbMCAg1pfP8zKWH9saafGiaeXzdu9rbfxuvH+n5aIkPqglufSl4VkcYHY48vo7JPD5fSA5JWWgYCBgYKEg4OGiYqKiouMjo+SlJWYmp2kxIqG/qragYiVmZubm5ydn6Cfn52dnp6enJycm5ydnYScgJ6cnJ6fnp2cnJrzzMDDvr2zvZfYrKqnppmHkoqCgPfRy8rNy9TY1dzW1NXW1tjZ19za2tXI2NDai8vG5eHe3d7VysS+vrexsLmxsrKzsrS0tLOysbOzsLCqq6uloZiVlZOTlZiWiYTSwMe7wM65tK2rrK6rqKSgoL69ta6pqqqmEqmnrKyvpZygn5+gnZyfo6ar24SFgIaGguPXp56queXk49/Y1NPIycbEvri6ubm7ubi0r6yxsLOqoqGfn5qdm5WTk4+PjpN1q6WZgnRuro+IiFOZeqm39/ZrS52IZYN5jGvCr27Ja3ORsIOAhIKEgYCFg/+GgYKFgIH/8e3u8vH2/vz59PDl7Ozh2+pt5eTi5N3f4NrletjX3dDT1NPS0tXJycrLztXP1dHNZGPAxcPGvLK+vL5ivF6xXr20taKsq6epp5uemJKdWVdBUEVNLyknW2hZYlJojmpHcl9ppI6dmEpUSUFKPS5GKiYsNUU8LClJKSs/OkE2MUVRVo5nPTIuVUFNTkREW1NBPFBAW4FnFH19fHt8fHt8fH18fH19fn59fn19hnySfQF8hn0Ofn19fHt8fXx9fHx9fXyFfYl8B319fH19fXyFfQF8hH2EfgV9fXx8fYV+iX2NfgF9h36GfwF+hn0BfoV/AX6Hf4R9hn4GfX19fHx8h30BfoZ/Bn5+fX1+fYR+BH9+fn+GfoZ9CX5+fX5/fn5+fYd+h38Cfn2FfAR9fHx8iH0KfH1+fn19fXx8e4Z8CXt7fHx9fXx7fId9D35+fnx8fHt8fX9+fX59fIt7EHx9fHt8fX18fH18e3t8fHuFfAJ7fYR8hnsEfHx7fIR7BXx8fHt8hHsGfHx8e3t6iHuFfIJ7hHwBfYV8AX2TfoR/joAKf39+fX9/fn18e4l8A318fIZ7Anx7h3wJfX1+f359fX1/iYAYf31+fH+Af359fX1+fXx7fH19fn1+f319hX4ZgIB+f39+fn5/fn5/gICAf35/f35+f319fYV+AX+EgAOBgICafwWAgH+AgKeBAYCIfwF+hX8BfoR/yX6rfYd+rn2HfoV9g3uFfIJ7iHwBe4R8iX0BfIZ9knwBfZ18gn2JfAV9fH18fY58CX19fXx8fH19fYd8gn2HfId9AXyIfQV8fX18fYh8g32OfAF9AgIEAICngJyuqpd8gZTRla6zfdKioonm5I7QfImAkKODtYmRd46/kKHJn4jhq9yMgLeK95f7m72uooaUw8Crn8qRqIeqqojc+8uq++aPoZPugqSSusj80feFoqG+rnygpL/9hIF21MC23oqDf4yQjIyc0Yyvu8SKnZqVyay31Mfcxt/C2IDvwo6joI3uu+bArZWfusLN8+LUxJGXwoijo/uXn4z9nMe9ori2pJKksK3W4drQ3Pyh69PirNv+m4HjrfuPgs/4ssCigIW44YrghsLHgK+8rcne9pWjlI2bnpPwpoq30qWPpqq0wM2LmMXQypyPa3dzhHxwo3qrlLFvpKDQ3IK6o4Csw2WSyZV4snzAl4W/8Ke7mKF/Xl5To2Z6hF6viqOdforRnaBhn6exb29qcH+ViqSBiZqjpMCX04q4h4i80Mulsu+drpmVkpVvcX9uq4zDm+Cgi/iOluS1s8y3d7h6qN6fv+/U6ILOeXN4h4KjbXaUeHW9l5u80m2bioaVmJKJkoCnq8J9kaB/iIaxsWiThXa4vGWDZEFARUhISUlOTktKSUVLTktIRURLTVRbYJlkZ2NRS1NZX15cXFhYW5WCVV1/Z4FbZWfHyopib27HcH96isKhiKuOq3Fud352cbG7/Z+hu5aNe5pss3d9XXx8gIN+emCbpNSEplychNeFpcump4Dir428qKDIp66G0ofHlXi8edKmioRzvpV/eKmBcpyKZKGNz5KqpriLb56KvGJYVWFiYVhBbXBzcG1vcTo4Oj08Ozs8Ozw9QUFERkZHSEtOUlRYWFtcaoqbY3GAiJ+biYiRmZeVmJmdn6WZhoKVmJOLhoyVlYyQjI6If0tfXVxYVoBVW0pwWFNTUF1VR4l5m4xyZmlmX15ZV1hYXVhZW1xcWl9dXVtYX2NjSlhoZGFhYmNoZ1dUTU5IR0pLS0pLSklJSUpKSEtVUlZGTVBPREQ+Qj05PUKKjG9pZGpsVVlfZFdsanBmXFBNTU9LS0tGRUdITUVNTk1MQUJCRENDQEJFQ4BHS1hobGtsbZi4qLOkjId2fH98dXJwXFxVV2V2dXJzb3Z4bF5wgHZ3eHFzbGVnbW9nbGNcZm+KtNTGnJ3KhPOugN2V4pn9g59ilO72epKElud6wbKPcIWcx5JqxWptzW2ncczHyI6osZSJfm9dYn2avMvBzKrHwM7Lvs+PlrXEt4DIrMTEy9i/zc/EzMrMxdS6payyzLTObtp50nbard7MzrLQfoPzvtPp0drNvcJ+j2+Agqynrn6b1nvd5q2g3tmYpLWypcbY2oGC1eLA3NqRvPKPg5jJt8edlqKej6yRi5aX3ZqzrY2k6eq0otSy8H3avLfes3XytcOTuOaR+OaLo4CCa5y1opWDipO3m8DKjLWxq4jl75bKhYmAhY6XzY6Qhpiynp/apFCHfs57eLaB13fykbGQk4uKus2so8l+pYR/tHnG+ZBYnJl5jX/beY12l8T5xvJ9lZe9voKnrbT3j4uD2NW33Y2PhpifkpKI0omHjpdkcHFylH2Hl5Chl6mSoYCyjmp8cV6qh6aHemp5jpObtqijiGZlf2N6e8h5gnPOgKGYf5KTgHR+e32Rn5OXprtpq5+lfK/Nf3a9i9Zqb6bDh5OFaWaqzXjPdq68bpawip2su3B+dnB8fHSzhIO827WcrbCw0c+Lodff15uKdYR+j4d6upTGrcqFycjs+YDNwIDB+ICvqKmh3qH1tZa/97HIpbqymJuG5Jy5tojyyeDJpqL+1eOE7On6lIqEipCfo7+UlaW8t9ut8abToZPc6dWostiHd09ZV4KGh5N7v2SIgb10YIRpovvEtOPZg9+Po+6hYcGmwnDohY2UiaDEhousj4nhpMXh4YKwnY6IjqWWpYDb4fqRqcOao6fU0oO7rp/164ixk2FiaW1ubW1ycm9wb2tydHFvbGx0dn6EicZ9g4NwanJ4fX17eXZ2eLitdYGmjad5g4Lo+K2Ajo3ljaSeq/PJsMu71oOAg5SEhsDK+qSx0p2fiLmE1Zmldqusr6+oon6usdiHvWysj/N9quuxp4DgtJfGrqfPr7eQ5pfZm4zVlPPGqqGR9ryflc+gir2secSq+rTHy96qgcOs44J2dYeJiH1hqauuq6epq1dWWFtcW1pbXF1eYmJkZmZnaWtuc3V6enx8jbXHfpChrMjCrKy3wMC9vr/DxMvBrai+wruzrLO7u7C0srSspGOEg4F+eoB0f2SReHJxbHJrX7qpw6Ocj5KOiIaEg4WEiYeKi4yOio+PjYd/kJKTZniYlZSUlZOWkoF/d3dxbnNzdHN1c3NzdHV1cnZ9e3ttdHV0amljZmFeYWW9tpqUjZGVfoOHi3uNjZKIfXRyc3hzdHRvbHBzd2x0dHNyZWhnaWxrZ2pwbgRyd4yrhK+AwLyxxKiXmJmhsK2moJ+LiYWGkpyfn6GaoaOXh5urnZ+gl5eSiY+Vlo2Qh3+Ghn6ctaeDg6tw1JNstnOyf+aOsXGm4e6BpJGf/IPi0ZKBn7XvuIH0gob+htiI/vv3xNnmzMG1qpedts3w9/L33Pfo9Pjk87291t/i5tHl5u/24ep48Ob07Ozi7NHFz9Lg1PGA/In1g/DF49jp2PGJg/zW6Pvs8uXb4aKvkJyiwr7Mo7zxgOHznIvl6bKyysa96+Xbe3Wdx5nP26jI9YuKsfK54besvb6uvrSis6vynsCfjbX498O597v/kfXfz+7Uh/PIuoiRu3Dyx2F/gF5RZ2VuaEhBRF89Ny0hQTw3JzhGLEgpLi0rND1OPD4uJj0tNk5MKUw7UDY9Szh3MUpDbFJufHKDkHFoflBlYFtxTGZ1TypOTE5lUYRJXj5LQlFHZkA4LztAN19fZmoqIh0/TVVZLDo1KyUnKzVLPWNoaj9FSkxlUVpiXnBpdmRvgIBiTFtMOXBbbVtLQ1pucHiMenRFOi5AMzNImWBoWqZrhHxkdXlqYGRGPDpJP0s+Vjx3fHxWcWw9JlZDQjErbqBseW9RNz5ILUwsM0FEUFBfcm2EUWFbWmJgWn5iSEpaloGFf3/msVJ9y+bQa0+Cm4+upJPXoObFx2OFg3RyMlNKgERpKzlMPjJrSpKdb6G+q9eLhWFNRkNyTXCIU7xql3tRXJeJb0V6fIVXa2Z1kqW6spmauLGOoZXrredybsDNn353mV9KKTc3ZZ2qt5DZTWZrq1hET01+15p92dRr24Jvj2Upclp8SHxGV35fi6VnZWhpeb1tbG6TgXZdUElMVldUgGZeYUBHSzxIS2diO0dER6TBfZW1gIaMj5GRkpSVlZaXlZeZmZqam56goqar7Jegp5eQmZ+lpKKgn6Cg49+itNm6oIBRSXt0j0hcXauNtWlx0mtbY1FZKS82Q0IwOXDAkYPCgrl/x3jdwdSP3d/k49zVor+uvYPhibSN1XJ6mXSggMmfPGRBNatxUUKvfohpoeB88dOxZZ3dl7ao9LmXs7SJ6cH2tm6kwaZpucH8saOkvry6rY37+/z7+f39gICCg4WFhYeKi4uPjpCSk5SVl5mdoKerp6W76f6dscXS7ebQ0dvn6OXk5Ojp7ebU0OXo49zW3ePj2NvX29PLgra0s7OugKayjMWlop+YmoWE/e7ktcbEwsfGx8TCxsPMys3P0dTQ1tXTx7rW2duPpt3d29ja0cfDvryzta2psK+wra6sra2urq2srKypr6OspZuXl5OYko2RkOPHu7e0s7KuraqppKalp6Kfm5mZoaenqZ+dn56inaalqKucnp6bnJiWmZqbgJ6hv/j9/f772IOFoHOEjrCy0czJx8S8uri2t7i5trWysrGvp6iloqSimpqZlZOWlpKRi4yMinCInI1xcJ1kwINgnl+IWNSg3Y3LuMh5lZGX6Hri1mlTjKu1mXnxfH/5f/KD+vj85/L29fXw6uLn7fH8+u7u6O3n7Njg58rP29rcgN3R2tXV3NPS0tHRy87P0Mm/wMrJyMpkyWbEYby1v7y5prJhY76ytLmrt66ur5+qmpufq6Cjk5isWqqiVTlTVTQ9T09DUIuMTE9jhViFn46OjE9SW0U6Rzs5NzMyNiswKDFNMzUsMj1nWj5NZ19eLltLSk1HQHdGUjxXZDxmfDxWBH19fHuEfIp9BHx8fXyOfQ18fH59fXx9fXx9fH18hn2FfAV9fH19e4R8AX6FfAV7fHx9fYR8iX0LfH1+fn19fXx9fX2HfoN9kH4Gf39+fn5/hH6GfwF+hn0Gfn5/f39+iH8Bfoh9EH5+f39/fn19fXx9fH19fX6Efw9+fX19fH19fX5+fn9/fn6JfwN+fX2OfoZ/hH6CfYR8BX18fHx7h30OfH1+fn1+fn18e3x8fHuKfAd7fHx9fHx8hH0TfHx9fH19fXx7e3x8fX17e3t6eoV7EXx9fXx9fn5+fXx8e3t7fHx8hHuFfAJ7eoV7Bnx7fHx8e4R8BHt8fXyEewF9i3uFfIN7hHwFe3t8fH2Zfo5/DH5+f39+fnx9fHx7e4V8BX19fHx8hXuIfAF7hHwBfoR9in+EfQd+f319fH59hHyKfQR+fX5/hX4EfX59fYV+Cn19fn5+fX18fX2EfgF9iH+Hfp1/o4CIfwF+hH8Dfn5/yX7ifYZ+EH1+fX5+fX18fHt8fH18e3uEfAF7h3wKe3x9fH19fH18fbR8BX18fXx9h3yCfZR8BX18fH19inwFfX19fH2FfJB9AXyEfQJ8e4Z8AX2GfAF7hHwGe3x7fH19AgIEAIDAo4bdlqmv036np96h0HuFevSKovOEfX6jqIuPdIuLnKWgrsiKiZyai8GgpZ/cirPjrY2urZacrpz0hdWC4rDI6beo1e/psIT6jPHjsICLw7yIzfTdkoChi4Dz/4zRdIDQqse/yuLTmIuDxe35yMmysaq2gp6bnpGe5qOvw6aMnICt66Ckgauzt+u8r8udp7K30smy17mfqsD89evO0eLxmqzaxZSt176z85XAuOnA0piE3tT+1KHykfvInbemjYuBwcSMmqCFuqvo2JGuwYnkrYbx266T0ZC/2PH3wK7S/Kmk1oP8rZbum3GCuNDE1oSDfJh5y6SBmn1+jIGGePu6rYDAv33Qs4tpgIFfqavJ2294xLiRhG+bwW54j4CehWWlZcaGcbSWpKnZsrbDf3SeesJ3gqd8YHOdjaR13nSorrKQp9fFk+2gx7HqX3CLhoCBsdWLnYVkgLWBm4L73s5y34Cmt7i9d9/pwqmMqIHAd2zQnopriKanh2vOkof8jpCg1TF22cp9n6zIg4+ea4eLnaVomVlhdUJCRUVHSUxMSElJSkhIRklGQ0RITlBQVFleX3U8hD2AP0FCREVGR0hGRT12XIupbmm0dZhhpcqnm6V6crvFcK1+r7lugdGZgdHpz92UtJKjnIR4WF57TkpJiIaKiW2QfJ99g9F9iY15lcie/pvqstbrkeSl7cWay+WRuqFww71lc4+QhL/KX2rDtmqPi3aecL5SioyIT2qJakNCRXx0cWuAbGxsamxvcXh5d309Oz0+Pz5AQ0JDRUZFREdESUxMS09OTVBPUFJXXmNqaGpwhldbV1ZVVVRRU1NUV1RVWlZQTUtLRkaHaVdWVlVVUVZLmlBRTmuIhH95dXt6d3Jxal5aXltVVVZWVlhYWllbWFdVUVlYX4NVZGVjZmVhaWJbUEuATktGSElHSUtHSEdGSElJRk9NTERSUUpARj4+PDg+jHVqXWpvY15OW1FjWWZobmFdXEhKT0pKSEM/QD9CQEdLT1s/PkBAQUJCQT8/Q0NFU2Nkao+YsZahkIWFf4B9fHBoXFhaWmZ9gYd1eoZwbHhzhnpoXl5dXVtVVVxfYFldZYyAiMPC6seenMnYxMq7rq+k342DmYuQYoF2d9SRnHymtn3Tu2WChaq8wriqw8C/s6fLfnWIbnN4b111wcfIa6aunJeyrrS1p4ecqrezrKq3uNXJsLzR0q+xx4zYrsKexnXR4tLDvcWgysLH0dbZfOz74MfJvtC5oMazf2xadVqQhoxLdMrr4N3m1+aB59K04Nl3pnyB/oCIif3h5oyGtqnT1Nirrr3GwqievoBueIiNxcq4hdbAr6KJeXaykom14IzfhoG7soLxl4qJtbWGgLitjfCXpLfji5uv3ZnhgZOE9Y2T44iDhrC5g4qDkY+ho6WquZGIdmN1sWmQk/eUxda0m56wnaOwqf6H7oDRray9y4XP8qh2a79ps8eqfYnUyJbU8c2UjKOOeP/3jdaBg9irx8XX8N2ZmIzUzvW/qYuMhI1leHV1bnqjd4KQe2h0gH+weH1fgIOFrHZ4lnqBiIyfl4mTgG54jbi/u62svMN9jayae5CvmY6/an2BqISPcF2io8Kee8F2up5uh3ppa2mLim1ygWWYp9O6hqCdecOGdcCdf3CkcpGltrmRh7jisqjSh/iunPWedIq408TijY2ItZTyzJuxlZqYlpWE8sHGgNHJm/CfnYykoIPm3+/0g4r188LEo+v2rMDRye+rj/SK6KCh+tTl4ff76POZhLWJx4CQr5N1isGqyoz+h6+0t4OR2ruPx11oXJx0h6mfinuStGFqYH+ezpqPcvnp5YPhoIpdkM2Mx/fMuKjaofucgfXJooiYvs+ifeWDa/CRl6XvgI7w8pKx0fGnrsCSsqK0z4rSfIW1ZWZoaWpsb29tbW5vbW1scG1pam92eHl+g4iLsV1eXl9fYGFiZGVkZGVlZFqxgrnolI7lmc6A1PrVydOZjOn4j8qY0NKCkOaqk9r7z+OowqKyuKGUd4epbmtowLy9uYGYg6mLnt2OnY6Kp9mdgP6m+L/d9ZDrqfTQqNTsnt3Dhe7ng5K1s6nm9XaE7eWFuKaPxYXlaLW3tWuKtJFgX2Oxq6umpqenpaaqrbO1srlbWlxdXl1fY2BhY2RiYWNhZmhqaGtram1ub3F3gIiRkZOatXJ1c3JycXJwcXNzdnNzd3NsaWZlYGC5knt6e3t5gG94aL1wbmiJpbOvqZiLko6Tl5GFgYWGgYCCg4WHiIqEi4eGfneKgI6ud5SVlJaTjZSLhHp0dnNub3BtcXNwb3BvcnFob3Jsa2R2cWdjamFiYFtfvqGSiZGZjYZ2hHmKfoaHjYSCfW1vdnJ0cGtlZ2RqZ25zdoVjZGZlaGlraGlogG1sb4eho6exsrebsp+LlY2cp6eakoqFh4eVp6SunqOwmJWjnKyij4SCgn58d3iAgYJ6foCKe6WjwKWGhKyymqKQeY2S0oKNoJepdIyDf+WgqInDzo7n5oCbpMvX4+DU7Ovr5dr5saq4pauwppao7vb5g9rdzcXf2tvWzbPKyuPngN/U29745tLZ7O3Pz+mr8M/mx+yD9P/35Njkwtfc3OPy9oPy7Ofa187fyMDdz5+MfpJ3qaC0meT55OTy3eeI/tm17/eIt4eE9n2EjuLF4KiXt6K74ebIxuD2+tPHzY2FkZqQyNyuiubCv7mOhoDLp57H6on0jobIoHK8gYR+qpB6gINvUI5fcFlYMFhAPjBCKisoUzQrTSYpLkJHNUA7MSkxLCw7OzZbRDYsUUFAMFFFamNGOz9ndHNhPX5VcztaXHl4X1SFimRBOX9Ja3xmNzxMPTJZaHs8MzQ7RIJ8N1EgHj01UU9xXWY7KSE/TWBncmxsaW5IVFJOTllwT1thU0VQgFiAWFxGXV1ee0tMa15laWp6amVNQT88RmGMko6MmJxmdYl4Z3qUg3qPMzlIYkhONTt4f5d5WX5DXUxAREAwQFFlYFVSXUBZNEhYRThVMmtcRIBrWFJ/Vmh3g4VnXHacj2thNIeSjHlngaKhvY/ZqaajzKT5w6PIppJdUEg0YEtDgENJRFtAOC03QDZ2bph+YXLKo1trVIOVYF97dIZWTIVGilBFYmBtbIRxepFtdr2AfW2Yq66Sq/DP0pPwgYmajmBku5Fxkzc7NmSJs9a8dXtxmENMXJ+grGRpXdyztHqmkWQnZI5thKeDcmqunJ12VZGCb3VkbVycjKZWQY1LTF97GjxrXj1CR2I1TEwtMFFmpXnbkIbpiYqLi42OhJEBkoSTgJWWlpeam5ycn6Knq/KFhYaHh4iJiouMh4iJiYuB/rHm5XxieKTHPG+bxr6ngmyCmnFtcFJYQ0dkN1N/gKfZpW2Dmo+hkZqxz4yKhv33+PVxgnmgnMDkjmiCaVaBibaCbUhmaVhqPWiOXV9IUb2dcNvkn8GipLOZvIx1urOd53VlgNBX4Int4uiRs93LiIiN9vHy8u/v8/P3+/37/f7+gICBg4OFh4mJiYiGg4KEgoSJi4eJi42QkpWXn6y3wsfIz/aTmJeWlpWXlpaYmZyamZmXkYyJiYOC/MqurK2trJypkvOfm5O6y/z988F6iZ2vurq+vbm6ub2/wMTJyc7Ez8nIgLmuybvT9KXa1tHJw769wsG2sLKup6utqK2sqaqpp6iolKSXhYmMoZmKkZqRlI+Jhtu8tbOysayqqaijpaKlpaOgq6efl52koqSbl5aWmZign6e+lpWYlJaVlJWUlJiYnL/v8e7BvHxtn4Rhg3uhxsW/u7i1s7KzsK+wrqiqop2fgJ2ZlpWSkpKQj4yMj4uJiImJd2uQiZqJcnKXmn2IcWFzfrFdpKet3ZmUm4Llmp6N19SKpZxibY/h5erm4unp8fDs993c4t3m6uHc4/vz8HXN2MfJ0tnc39fGxNDFwMHLy9DX1s3LzszHxMu7zcC/t8FnxsfAubq9sreuq7e2rl69XcS3rbGpsLGirKqfl5SUjZmXl5Cts6yjo6WTWXxqXoN1NFRET5FPVUqJjI1MQkFHa1tMMTs7QTYwOEEmIR0rLDk5NS5CRElKRjY1Sjc4Tk87Xj08aFY7d15oS2paUQR8fHx7hHyFfQ18fX19fHx9fH19fHx8jX0Gfn59fn19hHyIfQR8fHt9hHwUe318e3x9fHt8e3t7fHx7fHx7fHyFfQZ8fH19fn6EfQZ8fH1+fn6JfY9+hn+Efod/hn2Gfol/iH2CfoR/BH5+fXyFfQF+hH8Nfn59fXx8fX19fn5/f4V+h3+Efgl9fn1+fn1+f3+Efg9/f39+fn19fn5+fXx8fH2FfAJ9fIZ9B3x9fX1+fn2EfIJ7h3wDe3x7jnwFe3x8e3yEfQl8fHp7enp7fHyEegR7fH18hH0TfHx7ent8fX18e3t7fHt7e3x7fIR7AXyGexF8e3x8ent8fHt7e3x9e3t7eoR7A3x7e4p8B3t7fHx9fX2cfpB/Ln5+fXx8fHt9fHx7e3x8fH19e3t8e3x7e3x8e3x8e3t7fH18fXx8fX1/f35/f3+Ffgp8fnx+fnx9fH59hHwCfXyEfQF8iX0Qfn19fn59fX18fX59fHx+foV9C39+fn5/fn5+f39/j36jf5aAin8GfX9/f359n34Bfap+4n2HfoZ9A3x8e4Z8hHuGfIJ7mnwBfaF8AX2NfAF9m3wRfXx8fHt7fHx9fXx9fX18fHyYfYV8gn2FfAF9hnwBe4V8AX0CAgQAgKKB7XW64b7t3MbvgMqqqvDT+8u7qJrQgni8mJm0l6OdhIzhwdq+/dfYr9iYtPJ6wIzDy6OFm5mSqI2e0JKVoIDRiu2JnPP1jMmPqvmJvOuvv5D14Iieq67d7ZW3wOmRyJeUoq2b7vD438nIsKTP0NDIvseZ/PSTremGidmD6O+3gKm/6aa6r520otrK14CaoZudzrOH9IbT5rePjfKE6+eJioaZgYmH8KDRxoqgqaapu8SljrqphoX7oPbg1cn3saWos6uxjs2hzZ6tsYCY6/qFu4jd3aPYvoChw7qB/I/BlonDseqoiv3I0sl30trT0YKCX4J4go5xlomJgZLTs/vAgLWQmdaEkpqNXm2UYmmNz7d0b16ZdGFwaXeiZ5l2xKqFk3iEdqCtqLurdI+zhZiCjpmoiG5kR1xvjL9ybpTHiL37paK62e728+XZp6SfqJ6eot2Dyry5gZma6GOil3OMyZirqsyCfdiXxrSmjraBwoqUlLpyipvl5pqblpfUwn6NgIh3bYCywMiQfqeQ2KG9lphodUA/PkBEREJHREJDREhHR0hESEhHSktMT05QVVdWb293eHVvfn18fn1pZmFkZWVmZkphk7OOom+HfnGCuGhhi2Nyv7aTbL69dJfB0Jyvs/TstnXG4qVzS3ZufoifpL1pa5mlsZvPqLOfnZCzoHrDZrmT0ZuKvOR7qO3VoXNyw9ONyVqdaZFuUlCtkY+Vl1mianR/aoGjhm9vaGVcjlVmZWZrZmtqaGtpbGxtcHV1cW5tcHN1dXl1dXdzcXNzc29ydX+HhYpJSkxLSUxNTlBVXF9iZG6ERIVFgEZFRUhHRkiPgXl1dHFzdVxQUFJTVE1Tf7xISHprfH99dn1lbXNlamJhXlVXWlZTU1VhVlVVVFNUVFBPU1yMYGRuaWFdXF1YUFNJSkpGRURFRkZGSEpDRkp0ioSCd25EhmdqQT49RXiQhV9UV2dlUlFFU0tPVWJpYW1MUFFmXU1DgEdAQD09QkBFR0ZJOzw9QD9BPT49OjxAQUVPXnWxho2sjYeM8tF7h3Nxa2RranB2dGduZWVnYV9wXWZuXF5mXllaUU1aSFBaZl3doqr20I3PwZz1nbDv+puMh7WXjMbQb7uo0K6fu86RoHLZgKmqupDIwLipt7WqlbKjqHN1jZRcgHJZq3Btta+smomIbY2AdauQk42WuIaKsrfHs7W+wcOor6KeuLSoncnX4NvatrSwi62/0dvQ8fLl5dvJrrvVm7G8oGZbWIBZnKyWvOXo892rp8V+k4TW1tN8ereZtcGDqH7G9M6glcWAubiyvsy0pmp1kbLH1dufpb2YpcaprY2vFa2xtY6Mi+28kMaX2JHzhN+P8ty25oCjh/OGuMvJ+NW/6obTrbP40uSpmbmr546F0qmkz5KsqYyT7LTcscOqv5l+ZJDpgt+o3MGmjqSljpiBjOeQhqB8pGvAcY/IsHTZc4PdcLT+usad+/qdsca35u6Nvc33jLuRoLzKmOr19ODPu7WPp6Spn5Kac7u7b4KqZGegYq+1iIB8i6x+kYd4iICpnqRgc3p0eJ2IXaFXm62IbG6+ar68bW9tfWZvbcSAoppodn1yfXuGcWuRhGtowny9rKGTtISOf4CAiG2bicGWkJ9kgsrQbJJnqKiCpo9hd5KNZu1+sIx6u6zppovxyODWgeDe3N+Li2ydiKqvhKWasZql6crQ0IDGla39h4bQtoGV1Y6Ru/DpppmE6bSSna3C443er/Dasq+bs4rh7r3h04GxzqW3lIyhwa6Sf1p3hJvah4ya2YG0+KKh1dbIioqMjpy1qrupa4muXo7W2ZzHcdR6zb+JpshnfMTpkovKt/7k463eoPSxw7zohaGw7e56fZGj5diEo4Cok4KPxd7grpevo/i//dbgnK9hYWJjZmZlamZmZ2hrbGtsaGxubW9xc3Z2eX5/f5GVnKCgn6enpqurlpOMkZOTlpZnhMT0s8aVsrGMqO+Dg7KAivTVooXa1Yam0uuiwcDr+8eB6fa9kWyvpLO908zqhIOzwLes17i0vLSXx7iJwYC9mumdjMP2iK356KuDgOD5rO90yo63i25s1bm9wch0zYmJnYCXtpuPlpKRgLt6lJWYnpugoZ2hoKOjpqesrauop6yusLCzrKuqp6aoqKimqay2vrzAZGZoZ2Zpa2tudICHjI+aumJiYmFhYmNiYWNjYmLCsKejo5+goIB1dHV2d4Bpc6rQZGOkeamvpJSmhY2DhY6Gh4R8foOAfX6AjoSFgIGBg4N5c3WDuoiPmpSLiYeIgXl8cXJybG1ra21tbXBxam1tq8CzrqedZreZoGBhYGe2vqmIfX+Mj3h5bHlzdnyEh36NcXJ1h4BzamxmaGNhaGVrbGxvXl9gYmNlY2RkYYBiaGltfJqmuZKSqpGXlf7jnayalY+MlI6YmZOMi4qNjIaFmIONl4GCh4V+f3Jsdmdud35yyZCTzq56s6eHxn2MyM6KkIzGrpbV3H/Opr+tq8fepLOE+JXCxtmt2dPUzNvW1MHd1Nyop77DkaWQ2IKB4N/bybWwnbqqodTBvrXE8oC6tNTc5dPc3+DezMvAvNPOysDn7vPt9c3U0K7N3fjx6/f16+HZ0LrG2q/CyrWIfXmaerbKtdv68vjzwr/TgqWN3PbXg4zFo7PAiLOMueTPrqDUh8/Lydf16NKJjaXQ5vD+iZ/OlpO1squStb67yZeQh/C9iNum1IzbbMGHxsKs2YBsV4xWhI9qe3BmUiRCRU9LX2xZQ0k3SDUxbm1bOiswLictUkRqa2RHSkVGO0VjLElGTEpIRl5GQzUsSGk2S15CakJzSFRlWkx0Skl4OT9CPjo1XV5HUk5MWolQRjI/KTgzNDQxQEZWTEQ6PkBRcXV9c2pwTYGDTFhxR0lvRXyAXYBVWnZecWZbaWJ9dnRGU1lWWnNlNU4wXWRQTFSSUpWUVlhaaFReXqtthn1VNiYrPktIS0tuaFZRjlFbVEtJS2NpXV1gZE9oWVo4TW83NUSBQmZLg4JlemdFU2lnSnM5fFQ9MzdrfWdhyPfkluzgu9alpYGudpGklbiqe09IWExdSIA/M0ZgPDhLTjU0XT89QovAa1NEfmFMWFNbfUtsV3xyWE5JRzpddlte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ho+NiZBISEpLTFNZX2Rpe0JCQUFCgoOAgIB/eHZ4dHVzb2VeXFBNTE1KgEhOWG+AhF5jfnqH8297j1hkr6BfYWlVVWNWUlFUVFNRUE9RUlVOVV5QXV5fXGBaWlphWVROSEdGRUZCRUVCSUpCSW6AgHNtWWVnWmVSVW2Qn4RuaVBLTGlhW1JETE5LTGR1YExGT3pMS0I/QDs7PD0/PkFDSkc9Pj5DPz85Ozs8gDo7Pz5DSU1se4eM5ujd4M1scnt0gn9tbINyhWB8bH15cWtiVVVZWWBgVlNUVFtWUFBf8dO83oSc5q71iueu8aCHsYuHeKqrlZB2guuolnpyhdDU2Lx8prqhrZOXwa+2k6KYfpO3jI6Ck6J4cIO32KWMxKOjoKOUinNojZmtnJuqgHumh77nycTHsbmslISVvdDEyeSNzNjYl8mfed671uaG2tvKw8vNsN3OuNDHunWqY21gi8KZtMb57bnIh5Tn8oazkJeOmqOd6PCava3dxqKef4qyqICRtK+mk3SppW/FkHCxz/z96q+yyPGRv4Z5uOqai+P3opu0t6vx1JyXyezOgLbFxrjN3ZfS77DSd+HrynmUoJZ05p3+tJ2OmZ/IkabTpZar7syZbpqOpV9eWn98iLSosqbT6IZ/u9Kok/Lfvf7GZ3a9l3eombGd0qCEqfK7fbSnwPzP0+CJeoGtxfOSjLuTs7/ik/eZrca4y4GVioCIkZJvuby3iGFia2BiaHiGgIFyY3l1fWNopY14m2NrZLqsaXV0bWqNk7BiaLVgrr5za2hqxnZ8e4ekvbOFcoWCdHySjHVlo4yjdKScjXGNgZaWdoSJhH2HnLt+g9aJcHhw2GCsZnLAs6l7fnSOpb9gnIeFh7WO34/O8YmJ1petvX6Kdq3ShPmJgfmPsr7d4ejHgJ2Hnfnj56mdpd/T6OGAjKn068a+pYuKnavO1qCUlIyCkPqtzcnJ4OXNvJGUbKqH3e/jgqaYdsr6j9DGpbGYqYDGua7Vt7S1ZF5XVKXQoP1RnsJ2wnVzeHWHxJaDjaCgW2S0pszwva2lqKvF1YW1uaOGjcaSlN6rjpKeycLa0vWqgKGCg/nDuLHZsJGL1cymoq2mvry6wV5hZGVkY15fYmZsZmhqbG1ta2xrbG5sb3JydHJwdHZ5enZ2dnd9e316fnR3Zah8iL7Tp5XE762S3HexgcPLmcKghPuJ86bpjdib/IyW1reWkN+xgJmZst/ki9e9ut+/oZWCq5qKou66xLzVgM+s45G8iMa1se/um+KTosbezXGwdbW6qWX3zai0sWOepIyyq53Sh3WEhIl9pYiMjZCTmZianZ2dnKCglqGlo6SpqKKalZSWnJqboJ2joaSpnZ+gqrq8usPBvcZlZWhpanR+iI+Vr15eXV1eubq2t7OvqKWkoKCdl4qCf3NxcG9sgGVtdXqqsHiArqSc94yFn3N/ys1+fod5e4BweHx/goB4eHR+f4JtdYNqhYeJhomDg4OJgnx2cG9ubG1pamtoa2toaaCtrqGZh5SXhpOBg6K/yrCYkHt1c46AgHpqdHVwcYSQf25ocZhwbmRjZmBhYmNmZGhnbmxhYWFnYmJeYGFigF9hZ2RpdHiOjpSS6e3q5eWKjZCOmZ+Og5qJmn6Jjp6UjJCHd3d7fISBeHV3dXl0bWt18b2nyHCDxpvaeMOXyIVxnYWIebi8oqOAf+GumYWCmOHj99qVyda+z7e4z8jVtMq8rMDmvb62vMCinqzi/8207MzLxcjAsp2Yt8bfysjhgKrEquPy6OLj0M/Lsqix1vDp4fp54/bwruC+ov7Z+PqE3ODPw87MttnNwNvTwY/FhImBpeG30dP29tXroKnq/4nRoLSksK+i7uey47TeuaSjgpSymH+b0sjToobNwIHlp4SsuPvV66ixy++Mx4eCx+KIid3coJ6poJS7s5KVr/PXgG12gXGIll6AmIODM1JcaUReUT45YjFRNz9IXVZcLTJSOTBLZVxQND5ETyoxNT0wKT8/S05xczM4VVQ9QGBcTV9fRFB9UztLXHpkiDstP0U6Kz49RlM/SWhQS0s6OUE0LzoxNzA2IkouOE1KV0loZWBiZmlPgH17XkJFTERESlllgGFUSFxXX0pPdGBQb0VJRIJjSFE4MDNfantDSX9EdYdVUE1PmV1kZ3CElY9nLitAOTtEWkpFbldxP0BHNTBJUmJ4VmJhW1Q/TUxHSFxDPFVFgEd/TlqWgX1VWFBOaGhEcT47VXVOe0PE/6Cg4lmPo4WijMjUb9N/i/xmX1FOU1JTgD47RHNeaUlFQkphZV4wPGGCdmhfSEZDTVdqZ1NKSEVGS3hVYlJaYVdec1yDj997tbu6eaillOTnpvKqhYJ+jWmmjYWoj4WCPy00MG2KabA/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QkFBP0E7RItZY2dgXmFlU1BbXFpYanxjWFFKRlFhbk9PQ1BLUlyOZ1JHTktzSUZDPDs3NjY6Oz8+QktHPDo8Qj4+ODg8O4A6Ojs7QD4/QEyCq/7VxNfJxdfUYHNgWFVydKaYinF/kH9rVVJcWl5cYVZSW1hjW11g4K334IKIsq3UqK2JnuOD7O+Ykn2VfIdyr9a2iXBlqHWSjIdztHSbjY1voqXfuaO5npOrwJOofb2zvL+3ybmnnb+xqqCLjop8f36CrKusoICXs528zL67uKyOj4R+uN7j1tLG7MC9vJy5qKt41+Xm+Lno4NXjgfuJh9/g06nEt3FcdYebeaXH/taLhLykjY+qr7Kt0HSWiOSCjIB6maWIqMK8muLOoMB0vHDQnJS0i4l10se/mq+zttm2h579oJ/Y3NjoweqQ95Lprs2ts6SYioCZo3fstZGHx8Kt2ZeghnyDk5i/+tSpvdTjxYubs8OSkJ+VgZzOfnObbZx8RW+th4qsxKenpdyJs+DukLOHfNePqXxqoHiJ3JPD1ZR52a+y72y3e9uak+WImJi3hZWY84XExsuJptK/lazE53jibY12eKxosK6/mJ5vumVlY2h1fIB1d3a9YHVkkHBaYHKchHtecH6BaLV7uVurXmGZj3GBgpB0ZqmRan6XoraydKWBim5+hWGOcJSIabKS9Jm/m2GkrnWToJ92XMlroWeKdGerfoVyXGBqZ3mHgHh6hH+itaihrYWQjMvHtdnYo4eqprfKdGO/gJXbw+ek59jE0L65lICB2+O26NKb3vqJpayvwMa9k6GX/ovti5KFqI+K3IL254uembOhtNaFz4us29bh0vnVlXZjhIPTwfrS47L3kHaeiaeGo7WG1tuXWE6IycnQU5CytpCAhoKefKNun+LeX12Si7zS6oPg9Y6rppOsucqZpZGQgfOhboubvMnUwsuTn4CtqbeKmZ+Rt6egy+PGl+75sLK3tLKwurCrtLyys7O1rq+ysqytq6i7ubq7vb/CxMvJzszQ03FxcHZwdnh7eXCfg4Cb57Kmu9H8iKiAsH6K1N6/pJPWi4iLhKGVnouTr+OimaXwzJX0+nyCjYOkndfFtrGIuYzkrqHt8rPIteaUsoCIj6Dx75Sfl7/M7aXN3Ief25C9rpuL6Pabtef5k73FnYyHuqK14ueWjoN/oHR9foKIjYeFioyNj4qNjIuUlpaXlZ6htrmui42VlZGUlZagoaOemaCeoqmpqbC4v77Cv2RobHuHiZKkube4urS2tK6loZ6dhoKHdMGAgX5yY2JvboBgZ153cJ6OopiLi/F4ydRwc4lt64OMgX9+33p0eHt5bGledHt6XW5vYYR/gYt/fHl0cW9xbWtqaGlpaGdnZWNXYb6Ij5eLjYyVgn2Kh4iIlqaNgHtzb3uJjnd2aXZvdn2jiXRqcmuNamlmYF9cWVlfX2ZlaXFsXl5gZ2FiXFxhYIBgYGJhZ2RmZGyRpv/aydzU6vLnfI1+fHWLhraonYqUoJSNeHV9fYJ/g3h0fXiCeHh2zZLXwmxxm5bDlJp4i8Ftyt+blX2hi5uBr820koZ2vIWmnZ+Y04a2rqqK1Lfz1brQxb3W5b7WlOnd39DL+ObUvt/Tz8mwsbKlpaey3dbYxoC6zsHb29zeycuoqKGczfT27efb7trRz7LNvc2I8vfr977e3MvOcdt8gN7Z27jg0JR8j6K9msXg/uWcot22lo7CztTB8oSnkOF/nZeNucKcucShhufEn8eE2ITyvqnCmYiF0r28pqKiptmvkJn5mJTE5/f3s9qJ+ofHkqWTjqqhf4BdaEmNbVtZgH5ofU0zOTpDWDQ+ZDsqPUJXUzk4NkgsMDQ+Pl+QV0JSOl5BH0BlQjtKTEJUSG44U31YQFEzKVUtRlRJak5XkF9+jGA9TkJLUi5VM0stLFVPZ2JSLC03ZCtMQkQpKkM4OUtXaD6HTGxdW3FKfXyHaWxOhkdHRkpVW4BUVlaIQ1dJYUYsNEpnUkw4QTYxKDkqYjptPUJoZkNRXWRRR3NkUGJ6hZOMXWU+YDQ2RjlWSV5RMlA3YEBQSTlyfFJkbWpROYJMYzoxOEFsVFdUQUZPS1laXlNRV1VuenRZZl1ha5CMnsverIyOl4PBhoPskY/CpcqYmWhZVkRLOYBDZmxNaGJJYG5CTlVJTVtbTUxIhEF1SVNAUUBDcEB+eEhJO0tBQ1E2Y09msd+7nK2rlJOEq6vgu8Oq7ZCwboOIboRhe4lkjJRbKypMi5WlO2qbiniVr6jGd6Nrh/PiRjFbU4R8nmappFduZ2+DfoFmWF9cQXhYRE9lboGVeHBPSoBAMj45QUM5QzlGbHJ+ibf6wMTRz9PU1tPS2N/b3tvb2dnX1tbY1tTe4ePj4+fp6e7v8/b5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b2ZNSEVwVEdEQTs+OjY2Nzg7OT0+Qjw3PDw8Pjk4ODaAOTw6Ojo7PUBTl6Ki5NzBtMS1psFbWVxgrqrTrHxxfYx/aGJhYWlmaFiUVFeTVVhex6+NjaupqsScpPHq5fngru6BhdbVjnR4jGbMi4FgaF5Wo6KCiniBgHGyi2ybyLyxyb+gqLO5doq+vKnDycXItLZ1t5SgsY2ja4uCl7Gpl5aAiJaOqMa3moaufIF3o3jg0enk0NO31LSpweN5e+XdzerS+tLpzpiPh/DP27evzYxrg3tWgYrFx4+reXHMiLWvlorDldegv4uJiLK47JO9vqLEw5bFkKDmzd2u1JWGxK+XnLjNecSwq+Ox/47mnJbCvJCCisDZt+d64eK6i5zqiYSAe+bEvZaMt9G68rnGuH13jaGS9pfikZSKjIOwqpeQobDSlNih0Lyyn3XJbE5SlFeWc8Hekp2p0OGCho3shs2T3sfHeauJfIaQp5Str5OY2NvJzJKsdonBja/OkXqPjuiG7fiA8YXhpLbndoeLephzZmdjpKuYZaaYi3mPeZ91Z3iAcWN3b21xsY2cj6qEmFtdZbFkmKiXaHaUnKOiqo6oeLBveW6jvMOEbKK8m6K6coR9eomfe4FnktDZzLjIlKWkkqycbGBsg2+LuLjDfGaNu6ahg3GNWmSRjnqan7d6g23Ka3OzjoqbnISJiYvf34GSn6SficOQtomahpqiwKyfhNuA2bWg17+K2LzZ64GVjoSHhviGh/L8+P6Rh9jb5ue1td+e9uCxrrLzg+K5kdeT4pCwdZ6WsHKmc2+Jws6clO6I+uy3nbPA74+C3OFnSGbcolZ/sEmIo83Q2PWbcZyf0VJvnIqSm6+av6/SzrnQzrnjupmYvIJ2jLvJurHF2bDO8s2AnsiEtY2rqK6g+KmF5YCBjIiOj5eOlpqfmpqcm6OloaOmlI+cm5eam5KSmJymq626vL/P1sjK221qcXN5cHPDw4WU7orcr9TI8+nkqq7LjtqsvtGorpvzqc/oo8mtmabCtr6IgMiWhr6FnN174vLYxZmXcJSfy6W4+/vqtdq45qmAx+6k0N+shZGBj4uZyYPl2NOApnZycdf62sfCntfg3N/Lmqt+pOLR7PljYXt4dHF5enl0b3RydXR6e3d8gIB8en2El6aco4V+gIeDiIuNio6bpaCfnJmXn6akp662s7u/wGFmcYCJjZWrorGwsbSqo5+UhLPTsKjldXVybGdpYmWAvGlijKTBy4aBeXFqbNLYaWp25t15g4JufPR2c3BzdHR1d2ReabBoYXKCfoB/dnZybmpra2hmZ2hlZmZkYmHAvL2mg5GHhoGFgIV4d3yDjp6Mi4V+c29vfnV/fG9rcn2FiIZvameLdWlnY19iXVlZWlxgXWJkaGFbX2BfY1xbW1kCX2GEXoBgZG+UnJri3szB3ce/8nd2eHy+uNiyiYCOmZWHgoKDioeJd9BzdctxdXnXmXt4k4+PrIyNysfBzr6Y0H2BxNOWe4Skcc+TmnaAdmvFwZqnjKaijeuqhbzz49Ds6sbR3eSRnubp1+/u9PLe3YPgwcrbs8eTt6vG2tG7tqyzs9Hhz3qyoMCVnpXFgfTh9u7l58veyMDQ+YSB7eze8df91unbi4uJ89PtyMTkroqeknahp97XjayDgdqd08KWkcmd6qC9gouGs7XvsM/Ixeu/j6uLj93X/8n4uYfFyqWmqsiA2LSt1abmjtaPgq6dkJCOvOCz+IG3rptVg9WQhIBDh3xuS1Nfd15qVltHMk1OX1RcN0ErLSw5OlRANzo8QlQzbnqAboNcSnU1IyhPLkhAXn5QTlFjZjEpLlA8STRaVX5Vd2ZaW15VRFE+LEFqbGdlPj0mN1ZUcFcuKTo5Uy5fZDhaLVIzO4BLVVZVcFhQTUJLXWVBamlaTF5NY1BJV4BRRlVST1F7YGhXYlpjOzckMx01OjQnKkNYZYGLeoxmjlthW4aZmmdXgpV5fZQtQTIxTUdDTDlHZWU9Um9MWk5NaGVKRE5ZTFePa1cvNkprZG5SS2A/R2RbTmpvg1liSoFIUYRfZWY9LkQ8Y/TocH901c6y542bc3hUU1haV009aIBrXFRiWUBtWmhzPUQ7O0A4iD4/fYR3fkk+cmh8gGJdbklyYkc/RF0vZEpOq4qgbdKS28/imdOKhISd7rxvoWPAroJuf4eZWFGNkjUoQI9xQVyfLWCO5+fw5Ihjo67MLUBgUlZphGZqdpObhn6Ih6N4V2JpUE1JTlpuYGqDaGJjX4BHRDRRREtEPzlXN0KzcpGiYWOds7O2uLq5uru+w8TExcXBwsfHx8rKyMjKy8/U1t3e4evx8fT+g4WJi4+PkOXokqz7bo1rnlxlaMWGo7as97fXrL7KbIl7T6tM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Ojw8PDs5ODk4gDk7ODg4O0GehKCqqvXNzfvLoaHJuJyfdc2Yrn2PiYiFe3x0WVhiYKOguMxosNG8boGqpNmZtvCE/Ovm0bWD1IGMlfKttnJscG54emxdT2ZiXFVXWJJoeZqGeYakn6Kkqq+YmqyqwHaZz7qsus++w6/Cu7Gbtq6Cp5tklp+flJGbgHeGvJyvm4SOoIiWq890sL/n7tbIuLSUn+SA7+nr1OCqwN6/4JZ8nHvV1s2kzryYgpqJjpKR296JhqTjzYN7iNWE0sTd4Mefg+WZ1+7Hfal2lpGwu+HK38C6kKl0wYCEjN6Pt5Ofya3ulNSJu97Zj5Wgeu+I69a0m9nG+aPU38XggMnSoIDu4HXgu2GqmZehbq+Mp5m14ojo84HDtorR6PX7ldykn36Qsp6hio3IX1l7gZOHstnYr6RxgtzMpc1/npXBiH61dt177IyS0JzU7JfR0d6PinFtmI2JrZxriYCQqZGllcrV4XqVg8Rpc2mKe21niYylcm+VvHpgZmWtgJ6DgIJ9enpxjGWbqoyxpruXbmGmm5WfeZWntmmFi3+Bb3aBi63IdGmqp2+dk71ll3p8l4F8hI2Qfri2uqu2oa3TnNKDcJqmiI21pI1lj5NljNiYZp6cl6xvXHCciJGjoLzJo5OiuYqUzXhy4/D3gMPcwXSYfaHS/Lf0qYmEka+smZDngMaZkrrz8ezL0fPx6fjR2ebp6Pj6zN/v9O3Wq8re2omsjpCxpLeCg+bZ5tOX9sf7cnFmZXuQdcVwx9q/rpf0hoXj/Mri9uD5iID94GNMaMa6drVIcN3gc5jlqsuIhFmCo5yejJeVo7SJkLa0vMDEtJ+JnpGRmp6A+9Kt1buz9/uDgK2144z9pKi0oprcs9f6/PnCw+9zdHJ0eHd5fYCGjaCgppyLoKGnrZWTiY6OipewuMG3ttXNv97WdHd0e4B9dXVxhZb8zaXg8P2nnZnvzJF/kHONiYfB7Nf2voiV2bCq2ba2k8jDzvyoqK7xgJKJ5YmQz86YrHLK9KyAqa/NhpTtgKbw2szy9NiIq4mTkPzTyLLyiOCIafmE6tfYzp38d93N6YuBunh3d92WeYDCkpCOrqGwYmZnamlpa2pscHJ0eHV9e3x5en57fHd/fX19hIaJipGVn4+Vm5qcoqqoqaazr7O6t8NnboCHiY2QqLTD1Z+If3jq6tizhL9ybXBvYWSiabbDm3yJm31xaWZnbohtucpmwdO32ca5uXNv5X57d3d1d3lwaaR1bMN7iYN/g3t3Z2hnaGdlZWRnY2NlyL+1sLCqtoKYlYV7gHp4dHh3gYqVe3p3d3F0cnN0fnN3cXF4i42Cbmdnf3dtZ4RhgGBdXFhaXV5fYF5eYF9fX15dXVtdXlxcWl1h0Y6eqaPry9b20Kux3OPQ04zWobCHmZOOjo2Ninh2enfZ2ev+hN7y439zk5O+gZvOd+TRx7Odc7lygZfkorl9dH5+kpKBcWB+enRrbWyygZvIp5SVuLO8xtDVvMfQz+KKpu3YzNbzgOXg0ube2sbd3K3QxIy6xMO3ub2ap9+/zribqLWhtMzygMvR6vLizsXPp7b3hfjy+N7uu83w1PSrha6C597TruHQvqC4n6irrPTujIOZ6tiDiprsiObe5si4ioL5nOP32IHDkZmemafazue81LW8kuqPlI/IcrSXr9Ot4Y3FgqfKE8qRkJqB64Dv4qWvzYGkVKOjzt+AQlBXRX+IUZJ4NlRNNTU9elpcVEpZN1FfLUVJNWBpcYZPdW5jOTI7Q1xLRVwqL0BDVlJtgnZhUzcvTkhCZDdVU2tZYHxTn1SWPi1UNEhpWXuChkdPQkRdXkxYOTIzLjpFP2FgfmtsNkJLjE1XT19UTUk+LDhCTGyIVD9CQ3BPa1yAXVlWVlBoSml+ZYiDkFokIzFHMCspODs4KU9aUFtLX2twi6FdUXp4Vn93lk94QUExPTwuOUpGcHJiUHNvd3pGU0lTeYJwe4x6YzVRVDJOk3BIcHJxelFCTGZdaHV5iXFhaHWMYmmUWUZVRXdD2XmNPIaOqM65iMqDWFJZWFtdVHGAUUtRYnFvbGJham1wbnBtdYVwgnlgYW16emxeZ3ZwQVc/QEpHTTEwSUpJcGiccMCciIuKlJ+MxYDQq5Woc5xPUZKrgpahgpdRSaaHLCk+gpNUpStMpcuCpcGAoG1mM05rdH9pfG9oaF9fgICblYl3bFtnYE9RUDZyc2NvbG5aYzGAQ0pbR3JLVUVBMT5NZ7H58n5vyaCkpKWnpqeqrK+xtLi6u7a9vsTFvr68wMG8xMjQ1tTW6O3s+PyDh4iMjo+PkIuNc7aFdoJuekNlUOvrsJawhY+sodCkdXNhNDRRSW3FqVxLtqqnn16ffK2HlIfzh5Dz+pydiNLmmFdxhL5HOo6AiY9pXnd2TEVFQF1W1rZufrd1xXSO9nbi+MO6Z86L7JeHLzWDoqGggZynrOXDycXm3viLk5mbmZyenp+hpKWnqKqsrq6wsrGxsLS0tLW5u77AwsPIx8nLy83Q09nb2+Pp7vL3/oOQqrG2vMTY4vD90risoLCEZHtu7JaNlZKCh9aA8fvOhIurm5iVlJWUaYjf2Iq0esjZvlyKgoKggJmenZ2mqJ2S2JmJ9ZSjoZ6dnZuSl5WWl5SVk5SSkZD87OLe2dTUxdTZxLjCubWsrqqsrL6xpKOjoqOjrKuxpqynpqitqZ2Xl5afpZ2akIeFhoaEhYKDhYWIiYeGh4aJh4WGhYOAhIWDhIOEg/5yX2Jhfn6IhXZud8Tv+PpwTENGST5HPzJRWluBgIGB+Pn8+Hn17O+FZ4WFrXSNtXHUw7iej2yvaXqt4ZzQnoigosC5qJeBp6eZjZCMyXqbz6RmcHNOaVy10MbJz8zEWlWtysbJ0snJwsnFw77GxbzFxbO+v7+5u76ArK7Iub+4r6qzr6q5vGCxsr7JurOro5+gsF61tbOusKSoqqiyqGSrWKuvppinn5mOkYmSj5GtqlxbWXpsQSsoYEVGPGWYlmdBUDlBOzwmLB8oKEhSUj06P001PCU5Nzg3bUVeNTpVRE09TUd1iYZlZFtOhj9ZTzk/elFwMV5yUE+EfQZ8fH18fH2EfAF9hnwBfYZ8hHuEfId9A3x+foR9hXwFfX18fH2EfAt7fH19fXx9fH19fIR9g3yEfYJ8h30LfH19fXx8fH19fXyKfQt+fn59fn9/f35+foh/iX6IfYt+Cn9/fn5/fn5+f3+JfYh8A319fod/CX59fHx9fX1/gIR/A4CAf4h+hX8Kfn9+fX19fn19fYR+AX2LfJ97h3wKfX18fHx7fHp7e4R9DXx7fHt8e3p6e3t6e3uHehZ7e3p6e318enp7e318ent8e3p7e3x8mXsBfIh7hXwBe458pX2Jfgh9fHt7fHt7e4R8AX2EfgR9fn59hHuFfA99fXx8e3x8e3x9fHx+fn6HfQl+fHx9fXx8fX2JfAV9fH19fYV8Bn18fX18fYZ8BH18fHyKfQF8hn2yfo9/Bn19fXx9foZ/hH6DfYh+A319fod9A35+fYl+BH1+fn2Tfsx9AXyEfYt8kH2EfAh9fHx8fX5+foV9D3x8fH19fXx9fXx8fXx8fY18AXuRfIJ9pXwBfYt8AX2LfAN9fH2PfBJ9fXx8fH19fXx9fX18fHx9fXyEfQF+jn2FfAh9fH19fHx8fYl8Dnt8fHx9fXx9fH18e3x8AgIEAICSnJuFmYbVv820lJyM1Ky3ur/d6eOI4qR3h37fuWuph4+Ijqmbc715xad7tY+W2ZrIguKa/YmKta6Vq6DEk4m/jX2b/r2FrNaA6r6BfLOO+ab8hIni8/Gi8NWxh6anu5iu5r6OhKuYk46QnaanmKq+qqferYaw74/tzoz76JOsyYDHsaaj3YCRioraso/JpeaA1rjHwoaZouzb8vahpIOhwMyJnZGjiseVhYaIscnXrq6TuI3e+5Kf5XZ62pDs1bvt06njg7e17/aokeGF2u7F493jqY67gdHa876xwLnprvaqrfeArpv2ve3z6oLw9pGrqNC+yJeugnR6yKxvanVmY4CxtGx3npTWyKx8dYN/lHJ1v4ScWpR3fJt9fnJ+u79swIBwy4ipqeByrIS7wsi3jYzUh4JrXLJjprBZfGKpyGGGkKCif5eef22hdL3Jtaq7647HmMybyYTijYipiaXi1ZbG3qfJz4WHiXKii67N0aeyrbu+yoq3kPnOw7yyp7aKtICp0YuesnNrz5WJnpeLeHx5jHyeQkA+QEBAPkFCQkRRZmFlYGlpYVpgV1RiX1pgZmdcXm14i3ejjqSuUkpQVFlVS4V8dFtsgGidq3S0dH5fYmlRaaB6nn3NeaynddSkhrOOxnePkq1yg4BziHbQbmuEdrvFrXLNw4ygmISIkcy9eYCRt5SmwLfXx8/U3qW12ouir0xHTEulrIRFplh4eKhJrcmUm6VyT1iD2ldNdFJLTFRXUlpdb25lOz4+QEBBRENJRURHSUxNT01LV1FLTE9PTlZYV19dWlxhXmNmaWdtanBxcXZ7f4pKUl1ncqmBknh4V5+Hn6aUpeiIjIlMhIx6f4BjZFVzv1RdYWlUTUvkS4+rR0ic5Ompp6WrXG5bVVtaVlVQUFGKeFaLVldZWFBKSIdEP0E/Pz8+PkBHkX9/cXV/cYJphHxlXV9ST0pJTFJjbk9QS01KRUtXVV5JUFBQXol6WkdGUYJZTktEOjw8Ozs3OWs5OTg5Ozs4Ozs6Ojg4NoA4N205Ojm2qY+KoJqE0+H9sdfs1a+ser3Bs+TK53jmusjf3J+SrKWyxNNxdXmqi93PzKWbhJCWuLecqai73/STgoPE5Hute2N1kHWChlh/U2pmaZNbc4BsgG57l32Ec6WghayckbDagdWixp7Fm2+5nsmit6W5l82tmbCbkZCTnYCOpb6Yma+RhpKhtcfXu8C2xOG5o6qfpLrc6v3t8N3Bn8C1isST2K/TrbXTu9m+zJ6Vca+DdHLf3c/LydzPzdvMhWnChYf0nNDKccOzv7XmprrPjaHRwdCIp5WEe32u03TlnKaAxbeCpY35vMKlgP2bo92RvPHrm4L9zJmf2NfLxYCSpqCEkXvIvbKAkZuHwKGenq3H7duM3p+AnI7j34XHnZSBkKqqgNGGzLWMjkRUwZmKU5p00HJwjY97jIi7gHzAjoOj7pp/ptqK8s56gqOH+Z/dcXnDxOiWmJSRe5ufm4SProxsZIxtbW5meoCBdH+OhXyhhmmMu2+5n2i5r26DnICYhXx4p19qZWWeg2qXfqhdm4mOj1x0eKGbr8B6dl5si59reXSDbZp1Z2hrhZenkZJ9mYnT5H6d9oCG8Y3x4rnqu5/VeZ2f3NmGa6VsoK+apaS2gmePZ56gs42FjpDNmcN+gshmjnzJntXf3n7x9HSGmvvx+rbBn5CV5dyIkpGBhoDX4ZmgycDbx9OqqaysyaSd9avwj9aox93KxLGi7v+B24aC7pe/uOSC15TM7ejivL73rbKfi/6G2P2Jro/q/YKl3u3PmsfGq5DFotrBZmmV0Gqgc66X0orcfISngW6AsqDb+r7p8KO2eJW1o7m9yKanjpmuzJS4hv/ZzbWzqsmSw4DC8KjB0YiA6ayhw9SsqrCcrqntbWxpa2xta21tcXGAlouLiJCNg32DenaEf3mDiIp9gpCasJ/JvODsc210d316b7OtoX2TroTN247WmaGEj5dzk9ac1Kf4k9PQj/7Fot2o34WckLuJkpKEoIfzmZ2xme3q14zz2JCipo2LnOHKg4CRv6K01bzt2url+MDQ/rLJ4HFsc27p7rJr43iYneBo2vakqMCUcH+a6Hxtk3t0d4GDf4yNq6mVW2ZkZGhpbGxzcG9xdHd4enh3gnx3eHt8fIOEhIuKhoiOi5KVl5eenKGjpq2ytcJncoGMjsWUooaWcsyntbqmr/uasrBlrq6jr4CCg3B+vW59gIVxbGP1Z7LQY2Gt6uW9vK7Nc4F5cX18eXlwc3O4n3SzdHl9enNpY75jYGVkZGNiYmJmxrOxpqWtn7CTqaeRiYp8eHV1eYCOlXh5dXV0bXN+fINvdnZ2f56UeWlmcZp6cWxlXmBhYV9aXK5cXFtcX15bXl9dXltbWYBcWbFcXFrgoYmGnZN7z+D0uNjx4djXjcjFt/be/oD6yN74+8rL2tHW7PqKjIavfMK4spCUf3iApp+FkIucvtl/c3q63Yi/i3KPrY2ZoWyeZ4iBiLl4h5eFmoKRqZGcl87GrNHBrtT6h/HA4rniwYHSvN3D28zfwvPWtczCubW6w4Cxvt61uc2up7DC1+vt1uDT1vLUrL+9vNPv7v7w7uHMstLOpN6x7sTcwMHiy+PK5LqshsibkoD669jP0uPS0t7inYHuho3vpu/zh93DzMHvuL3LhKrU09eLq6mbgpLA3oPcj59zv62BqH3So6uddt6ZjLGDt/n2oonwmUtPenu+tIAoP0pMS0iTf21RR0g7U010a2FgU1UzaFVBRE6EVDBJS1tWQ1ZIKT8iS0s4Px0sZ15IL1pIeUJCTkI7SUJpXGCPXU5nn2tPb1opVmAtL1BDcFl+Rz1uenRSLkNUQEU2RDpEc1hHQElHREVEVV1eWFlEPjlJJjBUn1mHb0Z+e0ldc4BzYldRcUBKRkluWUpjVE4bMSssKSUiKTBHOkk0OihLb3tTX11oWHdZUVRWaHlqOj0yNiBIVkRhmE9UlGaRbIGPk53TeI6N08tjR21KZ3F0gIOSZzxjT3h3gWVgZ25/VHxcY5pQZVebXVJCSShOSzRESN/irGt7Y1hVi35BSlBFP4BZY1JTWlx0ZWVPSlBRZVpVb1htRGVXYmxiYVdWe4U5Yzk4YjhFR1AvTjZhhoGc6ez0nqGTjKpXmaNOYVOVqVZqjY13YG1eWFVwVZB/PkZrtliLW4ZnmWmtV192XUc8eX2+8pCmpmdjSFCAZoGKm3iCaWVfaVdzVotujGxwXlhESIBYUkBadk5Pc1RFTmdbgI1rc1q4kJ6en6GgoKKioaGkq6Sjn5+blIuPi4aKi4aLjI6MjZOfs67L2fX5gYOGiYyNhJ/EjISomWh1dz6Hq6ies7eNqup60ZXKSWNRRJ9kXOR2VT50eoFNY1lxWnCpuMSGjMzEnobPmImSflJhaX5PN4BwelFcXU1ccFBumHNxp4+kxIiKi47o6+KM04ZvX9SNo584T2iRm5+Kf5+Su6moqbCxsLO46fvYh5iYlpydoKCjo6OmqKqqrK2ssK6vsLK0tbi6vL/Av8HDw8bHy9DU19zg5erv8vuDm6+5nsGLpZbBl9aZhXhxgruH1tuF36DU7Wqkn5CHwIaUkYSPk4aqjt3CjomzmHa4knvbgmSKiZuYm5+YoKD32YnikJuamZaMgvaFjJORkZCQjoyC8d3c1tLTy9HK5urQzcy8taypqamrtqSgop+enJ+wqqihqKupscK5pZiWmrulnJSShIOAgYCC/oGCg4ODhIOEhIWDg4OAgYD/gYGA+WJHTl5UPHGGjGVqirPg6GlTRk1rX202Uk9Yf4Wr7PHv9ff6aWJxb1+xp5+Cm4lucZ2ReoF/jarNcml4ueGr4bGWwd+7ydGQ0o25s8Hxpp2TgolVZoZRZ329xL3Ixr7Du1m3vse7zb2AYsK9wLjCv8W9zcK9wLa4uLq6rrPIs7G/sqaprbu/wbaxtLbEuKyjnqGhqrK2sLK0qKOdkIukmrKiopyjqJ+nnqGQjYGdjIlWrqmem46SjHtMXUEmPkRPokoyRio+NT1DUjtHNDw5UjwwJTY5KCotQ1cuZlBcP2BmPkhHeWFxalESl3Jlek54fV49PY54JipKTVI/hn0EfHx8fYt8AX2FfIJ7iHwQfX1+fX19fH5+fHx8fX19fId9A3x9fYV8GX18fHx9fHt9fXx8e3x8fX18fHt8fX18fHyVfQt8fX59fH19fn9+fod/AX6Ef4V+An1+i32GfoV/AX6Gf4R9hHwVfXx7fHx7fHt7fHx9fn5/f39+fn9/hX4Gf39+f35+iH8Hfn5+f39+f4R+CX19fX59fX5+foh8gnuFfIl7hHyGewF8insFfHt8fHuEfAl9fH18fHt7fHyFewd6e3p6e3t7h3qHewl6ent8e3p7e3yEewV6e3t7fIZ7gnyQewN8e3yHe4V8BXt7fHx7i3ynfYd+DXx9fH19fHx7e3x8fX2FfgF9hXwge3t8e3t8fX18fXx8fXx8fH18fXx9fXx9fHx8fXx8fXyEfQN8fH2RfIR9DHx8fH18fXx8fH18fIp9AXyLfa9+hX8Tfn9/gH9/fn59fX18fH1+fn9+fYV+An18h34GfX59fX5+h32LfgR9fX59h34BfYp+t30BfJB9BXx9fX18hn2JfIR9BHx8fH2MfIR9hX4EfX19fod9BHx9fX2RfAR7fHt7kHwBfYZ8AX3GfAF9inwKfX59fX18fX19foR9hHyLfQx8e3x7fHx9fHx9fX2FfAR7fHx7hHwKfX18fH5+fHt8fAICBACAzJyTi4HIx5fqtL+wyKigmqao1d2x3rD9sIyLl4bVgXWkgc2gp5PChn+3y+GDudyJmp3P4qbthuqvpdKf3Y6n+4zFoLvQ8ZGEmo6zsN/tr56/06P2sO75foCB4NHJkpyz16XFn7Ouv6eNjIqbop37zrDbtKLn76bAzraSrdO/lrWAu4+E2qyP+NHX+Om+nuKEj/uFsteczrTpz7XahtD5hK2ki6GYmZGWrLicisGjpKaspq2pwo/+vYeOtnWRhZa4p63zvNa1as/IrZ3Ir66sxcGItPW0pcjKseTVtaGtxqHDuonUk9Kdgu/y44nCvLHw84yzl+/DnpejjWeRkZtrbbGAnW2Gi4OavqmfZldmYqGWZH2IkZGTXquuj353eYyyzXyV23mGvIqogJS+lJLIeKhqYK9kXZdxeYGVnmnJfH6NboaFjF6/knKhe3Ksu++jzO6Knu2sgerp8M394rmm4a3D4aDGu62Mlp+k1cKflJyus46fwNzIte+Fieqz0HKi4YGAhKmFhrywiXqMd298kLK8wJCmrmhlYF9fXFNOTlFYWFllY2dhXamMkYiqWlmeVlRWfY9UZF1jZm9lcYaFgnuMkZqqnXSvcJupyI1/bWbFU2FlXVhxhoOOfmzMfNDJ2LHFh3DUtsR7xoOLfN+nyWqmhYN1ebVssJTLe8B99dq93dOAg4Ld2r20qMXOs4KIuaCTjZh0PT9HYrFHekhNgoOfUKTLg8y0i1FIUJ50kENPTktGS0tUUlRbVWJ1dG13P0BEQ0JGQkNKRkdGSE1TS0hLS0tMT1NTWVRVVVdXWFpeaGtoZGpucHF5fotRdbbigX59zGvMa4aJldbDqHN5rn10a2mAV1FPeqxITLxZUE5Or9/Dj7i7ucjCurjLpcPOWpBSVlNOTU9QTHVNjVRZTFCMgUKEQj88PT49P4yQlYd4bm2Cd2uCiJSGYWVUV0tTWHBkX1lZRkRYTUBKSkpRT1xTUGWDfmlWU2ydXFtJTEY8OnZ1eD9xPXBtbTo6azo6Ojs3OW6Abmp3QD94c7mCjJ2Unenw/Ya6qs+Di6a3oazty9CE1qesyLHGvca1obHDcpKR5POr9f7ZkKvhmZuIi8uNgd72t6ugm4OJt19xfJJzdnxtfmFlaF5RTk1go8x9ncWWdYufkJiymZCvf4p2paiauaDAr5Sjn7SZqaydmKeWsZOumLuAraargpGRna61q5vBsLfJoavXm5ahmbW93ObZ0OvdwqPGpIfMoNCom6XGvoDJzcfOrXvBsp/p2cCquqHLqICRopOqkIF1isfhwdKzp7Dat/H4v5jhy7Guoberr4OzrZGFh5TLo4DFh6OPjN/w9d3hwfC7g4DB6d+i0OqRgdHQx5WAw6efjJDSvJzLjb+pw5qZiI6Tu8644a3kqYuTopP5nISxh9KjtKHTkIvN69FKXp+NlJKrkXG7eMyqqMiq8YOc6X/Anrmo6JaNmpa6q+7lqpmxwH3CjrXxgGJf2c2mdICUqYGZeoeEkIBra2p3fH/IoHqpe3uqtICLj4Nsf56LbI6Ajmlcm3pnspecsqmPd69ybbpheZVykIOblI7AeKmxZ4eEcoh9fXZ5hpB7bJOAiJCIe5WjuXzmvpWezoWajaDApprstNXFc97SsnuQfoB7n6JvmsaYkquqiayhkImRnoWck2+ufLiCatjs2Xy5xrrvsWOsnP7ApKzQxYPDtcSHhfeA4pi/t6nL0pimjoaXkergmqbEwuDVhffbsLy2trDR8Y2M7oGTxpO0mKC0tbf4h8qKhfOLheSxsLPK4If7oqq3h6+uz4Dzt46/kJP12dlzpc18hsWUbs/Av6rnxJpbp6zV/7z47tGqrY2ywqCRkpGJmoivzPPRiOaGj/W66oG4+pOAlMOjn+DToZmymJqqueDc7rro94WBfH1/fnhxcnR4e3eFgoV9fOXI0cfneHjddXB1vs50g32EiZGIla6uq6TAw8zhzZ7wjsDT9qyeiIX3c42TiYGWpa22oIf1lP7w/c3knID639KD3JWehvzB7H/TpaCTkdWE0qTLgMaD9+bS7d+Ah4fq79fLu9/p05+f0sO+w82gX2RthPJouW9yq6zectD8m/PKsHNtdL2aumR7e3RwdXaDgoWLgZG0sai2ZWdnamxva2x0cHFvcnd9dXJ2dXd4e39/hH6AgoSDhIeLlpmXk5yho6avtMBukrz+kIiH3YDqgpKcntvFz5KM45OQjomAdGpmjKVhY+NzaGpl2PnXuNzBvsrLxbrhwOXxd75weHJuaG5rapppuHJ7bm+/s2G4ZGBbYWFgYsjCy7urop+zo5mrrbSujpJ/hHV9gpmNiIKAbGx/dGdycnB2dIR7d4WZnIt5d4mwfXxsa2hhX72+v2K1X7iysl1frl5dXl5ZXbOAsq2zXVy4gqt9iZeMkuPs9oe5ruOUlK23prD62uCM4bPB4Mre4Ovdz+T4hJqEw8qY4enJhqDagoV4eKp4b8HXnJmQiYCbwWuDk62Kj5iKnH2FjX5mY2VyxemDsNKmla/OurvRva7Oi46Dxsa31sLgy7vCwtK7z8u7wdDB27/Ru+CAzsHEn7OzwNbY08Pl0M/fu77wt5yxstLf7/n01PHi17fVwaDqw+jArbnfz4HY5tTwz5HayLr87NXDzLnSsYZ4j6zGrY+WoeP+7Pviu8n2wfD0uqH/58awp7+8u4m9vJeHj5bInH3Lk7yUl9jg8uDUqr6cfYjI8fG10YdFW4N/xYeAM0E3OUeChmiBXmhhSUpRVGhZXGNOWGt5YU9KTzJdPD1YQVg8PTU8HyM7XVclKl1QRUhpUkBtVH1USVE6a2J2sVdsXG9rk1AzOjRgbaSaaFF3mFhxWHp8PjAufGxuTFVgclpkUV9dZlxPUFFZY2amXi9ILSxKYV5iX1ZEUWtcRGKAZ0g5X0pEc2JrenZfP1k0LWwjNDMpSyk2Nik8JDlCTW1sYHNqaGFhaHFjWHNsazpERU9CRDxqZlxic09kU1VpXnfstuXkg+/bvGBqXF5ZfIpcdaJtT1qDco2Fenp/f2J7dluGW3thQHZRSCQ8ODhFTC55gaxzamlzZE1tXGNGSHOAZkljXU1ccFNZQTpCSHl9U0dmZ2tqRHVxWWBeXFhockE8bDM1STpLN0VLUGCGWtCVmK9vc7hzeXR5d0qNUltzWG5uekh3VEJ9UUWJfnNSgaVrbqV3UJmWh36+l3kxcYyxwJzKxI94ZWR1lXJWYWxhbVJXcoOFTKJSSKdud0BacTohOUFBVHhzW1VPRUhZY5CUfm2k5ZCblJuhoqCPi4iAgoCEhIGA/fP28/+Bgv2BgYP4/4OJiYyNkZaapbCzsNDW09C+epZrnbl0cFZcXvqCq66qn5hWjMenO4xv0YWAZqB/Mpm/smiDWkVsm2WJhLVdV0NPiEeTcrxumz92yo1uYmVqaZpCd0Bra2pPbHOPuenbjISIjGnIhPuPjq5q3IuanEfBXYaAmJechqDZjKWlpKSmpqytr7Oyx/Xu3uuSlJCanqGfoaSkpqWnqKypqqyur7Gztre6ubq8vb/Aw8fKztHT2Nzg4erv/I+vt+OHionqi5GNYVFhrIvYsHTkeouqooeAgJmghIH1hICKhPnGpuLrpZdujIB3savFvY76iZaQkYiVj5GAxorpi5aTkfTuif2MioWNjYyJ++zm3tXRzdDLyM/U5OvM0b3EsKqprqilo6KamqCalZmampydtqulsL7FuJuemsiPjomHgoKA/v/+gfuA//z8gYH7goGBgYCB//35/4GB+XRWQExaT06DhH06QD+lYlpbRzlDal9kNFVNUF6Kqe+Atcfo6tlCUHGirorS3cWFoeZ1fXJvlm5mtMmKjIqDhMvbh6W92La/0LnOrLrItomKj4jM4lSWq3+ClrC9xsa+t75QUlS7vrnFu7/AuLm4vre7vbi2vLW/t76zurOzsqOprbS5tLSitqu1ua2tv62kop6hprGysq21s6yfm5SNpptbp6GTmamdXKaonKGijZqLjqahj4eVkpyRiFVVQzAvPzlFRUJGSTs2LDkzUFRENk9QMy4yNTo3L0Q9PTA5QHZJOFQvQUpOj5ubj3NieGhLR4R9g1aISyRFWFRTPIV9mHwBe4V8hH0Ifn59fHx9fn2EfAR9fXx9hnwJfX18fXx8fH18hH0EfHx7e4R8C358fX17fH19e3t8kX2CfIp9hn4Gf39/fn5/h34EfX19fIR9AXyFfQN+fX2Pfwh+fX19fHx8fYR8EHt8fHx7e3x9fX5+fn9+fn6Ffwl+fn9+fn59fX6Lfwl+fn1+fn19fX6EfQR+f319h3wFe3t7fHyKe4R8iHsBfIl7A3x8e4p8CHt7e3x8ent7hnoEe3p7e4V6hHsJent7enp6e3t6hXuFeod7hXyPewp8e3x8e3t7fHt7hHyDe4Z8hHuDfJJ9hXwIfX18fX19fHyPfQh8fHx7fHx8e4V8hX4bfXx8fX18e3x8e3t8fH19fHx7fnx8fH18fHx9hnwHfXx8fH19fZZ8hX0NfH18fX18fHx9fHx9fId9AXyRfax+En9/gH5/f4B/f31+fX19fHx9foR9hX4FfXx+fn2Efo99An59iH4DfX59hH4EfX1+fYd+tn0MfHx8fXx9fHx8fX18hn2EfAN9fXyHfQd8fHx9fX18hn0EfHx8fYx8gn2EfoV9AXyHfYJ8hX2SfAN7enqNfIN9wnwBfZJ8kX2DfIp9h3wDfX18hH2IfA59fXx8fH18fX59fHt8fQICBACA3ZaGznvTjZ+xrZiPptTpzKKaroCRzeu6ofSNptLCuYHopI/oiNnV7Ny2b7ndiqrEmZl7za3swMDD9NHEkdHQmaPLh9uordDGpdSUsJ3S5X7Rjrfuu5HzgeuDhaHkysap35Sz4fjfge7vhIii9LudkrDFuNOapYmcx6C0oqCvorKAi9nV8NCSxM+Wl4Ld/6O3trGy4JWUwJub54vB257wr+3QoMXxnLOXm6GE7Z6Jf5m4jqzY6ObCk4uLfoWSiX+LzZuEytaiqLLcxLmEtZqh4cqDlZ/niKjeyp+ViZ2Slpeyu7ud3JGGiOHvjqSB787W6sCX6JXjs4qWhLShj6u0vbCAiXd4h4F7hWuFvIqWfISOgZmHhG5soF6VfXt6coG+q6mlm5KDen6KyYLUgszUrZSbrJehhbxno2OInr2caX1rpp1jf4tv1Il+hKypndKMnPWB4Pf1wY77lf2iuePxcoGEhoCIfLZzm6e+ksyzwLOhg5OHw5Camdjzlqm5d8a10diAeNzQt2yjlm1nWZ17qMmvZnWkycNmxmZsZbjAZq6XicOwvrGMmam5joV8iKKWqLCfiJCRUlZcXGRya2tjaWZfprCMs2C1b2x1s2q1dJuOnol3bXp6ZIKkaXacuI+C28nOq7SEqIuihMbDkYLMy3KmiYyscHbSsHuXo6PSeIGNfbWAkYOD3pOrppO6j6uRto+th3tIQTs+SGVJeD5IjJdHRqRuc3R1ZpBqSUpShklJTk5MT0hLS0tRVllXYFdTXmhnPUBAbEJCQUJDQ0RGQ0ZGR0tJTU9TVVNTUlRXVVhbW19iZGZjX2hybXyQTYjb0nXXp5HSjKGUrNPWsq2OaZymXleAToFQgJVGU8Wu0ElMS6vWwqjRzYyjnIygpL66UY1ITE1PUFGPSXFHiFVTU1RMRIF5P0NCQD1Cl6mTf3N1eXZyenWFdIR5VlxQTmOGXlhdW1tQR0JYQj5ATUNETF1QTHSPeGZjaIKURVRDRUt5cnVubXR2dnBubGxubm9wb2xtbnCAcXmYhsmykpuZkpbvoJCFpKitloWFeYKjnJyIhdztxLGgwLevzr+qzc1smL7r5OayldOG6YKV6Irwo8O1l560jv/E7deMbq1nurF8cnp1gmFqcWFYWViKs6O+dZ99voZsn3Sil7PJxJTHq5+QoKbDpKOOmKC4oqaVqpeno62vrcaAo76/gW2Voquny5OuoKKzlrG8jZusl7bceXfiz952dKPMtazMx8W0xbHQsPTuxsnFtKC12MPQuoKmt4KsppuHh5iIy3LBrHZwnpOBcoJy0JWOz+yaxpuarYSWso2tsdyvu8DEy9+LfL2nt/H6laeTjpGJ55uge83QqI78iPyo/q6AzaeMyorokp2Dk5SQoNPFwIqMl3KI2ey/pctyquvu1Y3+t5nykffk4ebEgMuLSmSim4+E0nWnm67T9snTlsvXkI/imeegp93GtOGcybvn+oLQcoi2i3bQcM1si4Wptba1vnWFqr2wZbq1ZWh/u5J/b4mVeqZueFtukXKEc3SBdoSAa6CaqZhukJhycF+iun2ZmIuHoGhljHJuy3WszHmyfrShhqTGfpF5fX1pv4ByeoqQcpTf+tnJn5ebkJOdlZOSxJiHwc2qtsPay71xinN4s8BwgJPbeKjEqIWEe4N7fHqNk5F+vIJub7rSeJhtz9PN7sCSyHPNrKDHo/niuNHP+vqA1K6wwqqpmYCEs8bPwr7SverMsJiez4HfuJWlpK/jvrmYnqCQhIaU1pr/luvZp6y558nuuvyU/5WtyeuyiqeH2NuMpMSL77ehpMbSw9tcbNdzutLWupTfgM6MnbfogIeTp56onueNqHGYi8CQkJapjaeZ0oh6odn0lLPGheXH1PuAhOL/8YzRyZOJhOis1P/RiZTb//mD+4KHgvf7g+rLwPnn9unH0uDxzcS3xuDU5+rYwsfLcHR8e4WSjoyEiIWA3eOv84P0kImV34PXjbuz2b2nl6egh6fMg4+63Kme/Nzs19qe2qapjdncn5j04IC+pKvUkI340YqWpaLXgISXjsCAk4aR87DAtKbWpsWc167ZubtrY15ha4pvrGJvyNlpZtWGjIaTgbWObG5wqXJze3l3e3F3dnV+hYeFjoWBjZmbXmdko2ppaWpram1wY25ucHV0eHl9f358fH+DgYSGiIyPkpWUkZynoa/AZKnw1onorZjxlaSmtd/n3tSkgKPPfXB4aahpkKxfbNTC6GNjY9Lz05fL0ZKfpY+wtcrQab9maWlqbmy/ZJNfqXJycHJsYbSpYGZfYmBk0d/Gs6WorKaiqqOynKWigop7fIuph3+FgYR4b2l8aWNnc2hpcoB0boylmomCh5erZnRlZ2/Aubyzrbi7uLSzsLKzhLWAsLC0uLW5ybjz35qXlIqQ7ZKHgqCor52NkoGGpKChi4nq/9fDstTM0uHfyez+gJmnycLFn4PAd9N0hNJ4yo6lm4aKmn7nrNPImn7HdM+0hX6TlqN7i5SBc3VztNS90YCwj/m3mcqcybvZ9eaU2snFs7bD48XIscC808LEss6+zcSA1NHO7Mnd4KKQtMnGxvG/zb20w6zC0qKrybrX9oOE8+DmgIC77dLF5uTY0ODR6c7289zh29K4xuvg59SfwsiZw7ifcICzkeWJ5suPi8epk5Gkh+CXm9nsq8+Vm7eJnrl2jMDrsMjR5czrko3EwMfr8ImLnZyUd+mprIXOzpNehFEEeVf/pIA+OTpTOGlJRklmOkE7UYJ5VmlrPE14hmtgezRJVFtfP2hJQ0okPz48PUMyU0YjMVxIV0FtOlpiZk5XS0g+YGxRU2RJZF9ZTD8zTEyPbXaURJFQWndXUIlDhkRIUmxiamN8VWF5kZBQlYhKTGCKaU8+Lz0tTkFRPUxkTlVIS1NOXIBQcGh2aE9jaVVTRGpcTl5QRT5CMjY5KCVFITA8LDlNi4Zxi6ZmdmFhYleea2eATz82Tl1bXFBpYWNNWl9FPT5/eo7Fz8DV3OLUxGNrW1yTnWFiaqtWZE6BeXx1eHBrY21ya1huMjVCeJ5eVk2gbDpHWFuqTG9jXGVNhnZiY2ZwcIBfU1VcU1RISUxqZWtmZW5lgWtdUlhpPnNeT1JQT2ZUVEFAOTMyPUVpP11EjoRfl6KPf6uSsmSZV250hHRNTUp/ek9ka0V7amJneoB7hD9MrWGXtKmFZqpgmm97jbt2bHV7go6KsF5lRWVjj2poZHJXbVN5U0VcoaVXdmk2XHKH1YBaamdeRIaJd1BCZVKEs45HUpbw8nrze31/+Ph98unk9fP49Ozx9vjv7evx+fT8//r09fqBg4eCi5KNjYqIiILs236HVaBOTFuJOaRpaX3uza2YwnY6dptTV1uhX2mflZ+je1bXjKVxnJWEhcaDTD9QWI5QSGOATYWQiHcya35HdIB9fkyEbGlPSGCGcFVZe4zi+YGDg4aAYozhh4vy7ISEs1hZS3p1mYyVmJDGnJ+joaCkoKWmpqutsbGzsLG8ydCDmZHunJydoKGgoqOKpaOnrKyusbO1tra3uLy8vsDAwsbK0dHQ1N3h6/uDysCcktWfiod1X1VKrMz756CCfdeUh4CA2YeHl4GAmL6lg4GD4N2qMmNsYlJmTYmigJyC/IaKhoWLhfqHvYPNjpOLh4+D8OmLjYCLiYXy5N/Wz83KycbExMbO2+HAyretuNW3oqOhoZ2alZ6VkpOXkpGTmpeYscjJtpyPo8eLhoCBgv38+Pbx9vf2+Pn3+fr9/Pz6+fz7/ID+7uj90c9jVk1IRYVNRjhAPEM6Q0A2Ojo3OEEqWVhRRElMbI6xtKLvxUNLi6+mrZF2uGzLbn7VcL6DlI2ChZFx2Z3Bxsmq+oz5vpiSwdDeqsHNuJ6io/O/tNZyjFCysq3Asb++vaapTKa1trG7ubu2urGztL21trK6s7i3t7u1tYCwua+hnqiwsKu+pK+psbClp6yim5+foqtYW7KtsVhXnKajmqWqm6SjnKeVs7Sno6OiloyVnZ2ZgYeShpmVkldXQCxeNlRFKyE5OiwlKiM7KCxMVDRJMTI5LSw1MDc/VENCR11qVTYmP0pmmZpVTDI6TE6VTDw7h59vR0w5NjR7Qw99fX18fXx9fX18fX19fHuEfBJ9fHt7fHx8fXx8e3t8fH19fX6GfQd8fH5+fHx7jXwFfX18fHyFfYJ8hHsOfHx+fn19fXx9fH18fX2EfAh9fX18fH18fIt9jH4Bf4R+CX9+fn9/f359fYV8B319fH19fX6EfYZ+hn8Kfn9/fn19fXx7e4x8AX2JfoR/BH59f36FfQF+i3+GfgR/fn9+hX0CfH2FfJ17AXyHe4l8BHt8e3yFe4R6BHl6enuEegl7e3t6ent6enuIegN7e3qGewN6e3qEewl8e3t7fHx8e3yNe4N8hXsBfIR7Cnx7e3t8e3t8fHyFe4V8CH18fX19fHx9l3yMfQ98fHx7fHt8fHx7fHx8e3yFfYd8BHt8fHuIfAh+fHx9fXx8fYp8A318fIV9kXyHfQh8fX18fH19fIp9AXyUfQR+fn59pn4Pf358fH5+gIB9fn19fXx8hH0YfH1+fn59fn19fn59fX1+fn59fX1+fX1+h30Cfn2GfgV9fn1+fYZ+gn2GfrV9m3yFfQF8kH2NfIJ9hn4bfX59fn58fXx9fX18fHx9fH19fXx8fH18fX19inwIe3p6enx8fHuJfAF9sHwHfX18fHx9fZ98hH0GfH18fX5+hn0FfH19fHyJfYl8hX2CfIZ9B3x9fX18fHyEfQN8fH0CAgQAgOHJoI74gt6owJysnovX+vWSubvcyZPA4ryHpPHFr67fm3B6h9GUjfTYsobE0YObz/C7q/j8udCWs7jLtYSDe6umsdegm5/Fpsl/ZM2b06vjt8m1mPHexM3th7nf/ou+1taR4oyBh/78pr2T09e0saCwweWEtsCyvsuxtcqrt7udgKuh1/KFh9XPjZKM4PfGw7OY9uqXuabOm6idjbSzz/uSnIyi1+WAma6Y39Xyo32i6pHYxoWQuXiRkpiOh4asmYTVg5WjlpOUmf7Us+/D/cuTvYaOnb28ncCXnaW2pI2rkJa3sf7ixZn5zqbJgY3v/bPQwqish4G/hH7Fs7OopnbCgKSHjIJ4gGe5eLDnm32HfIaLe2BzeIaDf414bX+m0JaChn/PtqrHpJ+ahqKCrsCTg5/RrsKjp46JbpSTZmmf2rCgv4h3j4F4hIarztPp65Xc7rXDtMe7jKGnl7zniJuAgXSmt6x0bI+g7qW2sajEd76+gsXSz5b21ZmEksh/35iqgJ2ch77KsIG1iISMhsFjm4Jkk6uYsKarr6CtrrC2s7prwq/Boa9/lnWBfJW+pJispYeTl6qdm4q2rZ2do7Ksqqikk5iza3G2fG+otV+gy6hmtoSIdaTDtYF6prqHxZreia9weIqSc6SSpnqDs6F4i5OogYfMjn2NiaP30HrPsdjPgMqklImWlYGUkILWlZSep5hycnw+QT1HQYdGPnpNRIinb3J3u7NgUEOLgUhKRj9BRU5KRkxNTk9ZVFZNUlRQWXB5ZGd9eXBGQT9BQ3FCPD9FSk5SX1hZU1VdV1ptZVlbY2BmZ2ZqcHF7hYmBiXVzxIC4knu9352CyajPgn7BVllRgE56m6a6i52gn5WevNWQdfaDso6Xu72bgZ2doKmGRoRCRk9ZoYh3fHdUTo1KRol8dT9FQT+Moa2ekH2Gd3J6ZmV0aWVwbmVTW2VsW0pSUUlVSUM+RUw+Pk1MUENfUlNtcXFjZmheZVNRVUxOhZNvbXNsbW9yhHl7bHVqb25tdXJ2gG+Rqa+R4Y+SiLeK15+bvbWu5qaT6np9wH2TqZjT4drcxNiqh6uw0HZ7pMji0trPtNfPiZnSwob7q4SZvcvT66vShf75gm9uc4Ovx2p2cHF2cnp1ZFdRWbCxsMt+tndig6KRpXB6ip6fduDBrbu5xLCMn7qzwLSmpL+toaarqcupgIC2kJxptaKAlbyBnIC5rrCkpYGiudbk5cjh3MvCztDIv7m2yK/Hnb+538rJx9WyuYC/rdqfp6p6t8ef6H+ivsWOe5GooHi9wLaC2bSmjI6IpcaF55Obiunl95aZjevimN6PtHiTlsKpmfLH3J+Zh6aA7PLwkdWIpeLsqYWLuKDagPLNmH/4jdOYfYOrjYDO6u6GtKHGzZTD3rZkfOTMyLX5tYKOlO2ekvPwuZDDtlZPcsmzyf/qsq6Ro6y+rn+GjNTd9vzAuMjeuuetlv6u4MDxsJ2FcrKemKm1crLT2I3R6OV2sGphZ8PCepZuo6KFinh4gJRXfYF1hI16fIx9gYl4gIV/obNnbKKZaWxmnq2Yl4NtsJRjf3iNdYaNepl6qcdpcW+GsrxrfIx4tK3Fk36a04K94pOYw4ecqaqfnZnFo4DTeo6gnZiZnuvTvOOw2LaRwoyOo72/nbR5fIWThHCXg3uOide/qInEqpW0anDL66W0l3NyX2Gxs4z49OPU4pr7gMm+ybWxoYDooZzGxrrGqqDNupKKq6CsrNCrkZnD6KOSbIXSu7PQqbakmriKu8+bmrvk3O2y57mtjra0g4Wy/+jj/Ku5ya6Up6TS3On+3mDA2Jmclqezj7Kxepuxkq6MlozD2eSfh32L+qCOjpe9hMbQfqjJ5qHx2JuJoeCP26XAgJellun43Jn0w8HJyP6FyquHz+jR7N/o6tzo6O337PiI/+v+2uS6z6y6t8/33Nbk3MLM0ODZ17nz6tLQzebg1tfQwsP6i5LjmYS22YPE+dWC+M7BnN325pqSyN6m8bjzndmPlbS1gamUt4WS1biDnbLCmqn5p5injKj42IPYwPXggNmwqI6sqJaxpo/eo6G5zsmvssJhZV9uZb9qYKluZr/Uh4SM6uOBcWO3qG1zbmZqbXl3cHh5eXmGgIJ2fIF9iKexkpO0tqpmYmNoaKdkXmJqcnd4g4GCe32FgIWXhXuBjIyTlpKboaKpsrKaq4SI24zOqobB9a+L17jpkIPmcXJugGygy6XQrsawtr230POnhPJ/wZmLrrqZiam2oLqyYrhfYWx3zbSgnphxar9mYLmqp11lX2DM2OjRwK+2p6GblZGflo+Wk5F/hoqUgXF5d257b2llbHNkYnNxdWmCdnmKjpGFh4V9hHJzd2tuxtCysLWurLK0vrm9rrytsbaxvLi9gLPH0tug+biViKZ+05CYvbOx8qib9IGDyoCYqpnj6+Tt0OfAoMbQ7YCNpq/Ds7izoMm6doTBs4jskXGFqa+vyJCtdefziHp3e4qw1nKNjJGalZ2bhXdndtTa0vCX1YuFqMezxYaUnqikgP/t3fHs8erE0vLh7+PNxuLPvMTJx+jKgKHQs72Qzbugt9ynupu6tcC/upm61Pf++dv87N3V8eji29DZ3Mzjvd3Z8+Te0d7HzZzSzPjAw7WQz9Cr6o/Cz9KljKnPxJbv2NKh883Fn4yStNeA1JCVfvDo9pJ7fO7qoPme0IKoose1svO7w4GbhpqK4OLmicaFldOpW1RGYpPbgEo+NDd+P2tDSldGNjxmmKVaeHOCjm59oFU7OlhURk5mOigwL0otMUI9Py9RWykiPXpganpoYnVUVEtQUT04OGNmbWZOWEpDPlJVS55pg32JZ2RUSHNnY3aASFlwhkVTWnBSgE1LT5eVV25QeXRaTTc3SEsxTFVIU1lLTldQU2BcgGlkeoVJSGVsTk5IZGRVSTw3UFEvMC47JDEnIzM3MUQ2TltxlZ9bZ3Bhko6ojoqSUThfVklSZUxiZXBrWUVJZGnIdIilqaWrr+XZzeGix6eMsnJRVoO3mppsa3SAc1yFdmVtZ4pvcj+SbmJzTVePYFCCUjw1KTViZUd9fXRtcUh1gGliWVdbVkN9WFZ8c2BnVVBjWkxRWVpcVWZTSklXYEI6LkhWVlRWPFNRPF1eg41qZnSHiKR4jFtfUGhaSUdQiYd+iXNod2xbYGCaqpmml0ChtX93bHdrYXh8Y3d6eJ12dl+Tqctvcldcqn9oW2SNT3t/VW1wamGolWtaVGJDgmyegGpyXW6TkFylZGZpXJFRhGJdsOTa5+To6+Xp6+/x6+589vL66+7i6t3n5fH78vH49ent6vj28sf2/N7UwcPBxMS3jX6DaGCHWFJ/nmyTkbVv3u68eG+HjmlWZZx5rVSQbXZLZ59/Tp9zWlKOqWJGPUpKUV+ARUxMbJnXkSSGeZVzgGqEVUVUZExqhmCjUVJqrsL09v6BhYKBh+aHg9SEhuJ6OkFeysmAio7v05abmpaYm6KfnqKkpqWqqqyoqq+utMfmyb3m+OuFho2YmN6NiZCcqKqtu7a1sra/uLvUraSzwcjJzs/L0tzW3uekc2NsnW6TYGR0f0ZRrojbhmjQgYSIgIjN/3Or1eFxxO/Qp9aRZ45EsYkzV1s7Y4+4WnrvhP2EgIqK8fLhyr6PjO+Egvjn6YGIg4b85t/b08rJxcGnu7m8uLjKysu5q7XFrqKem5icl5SSlpeQkJWTlI+WkZOerZuWjYyKkYaDhICB+v3z9PTw7PDv7fDv8fr09vn3/Pb3gPXRt+dHb71iVlNFaFJBQ0BDWkI8cTk5Uy4+TkpKbmZXUV1TVmuCq3JHaZSnmKCfkcSvZnC/s5nxgGt6naKhtIWaZ9X+n5qIiZa37oO5vL/MzNbavauJpeq6zfmZzICBtcKuvoJbQE1OTq66srOytKicqq+vr7GytsC1sbW0tLupgKW2qaads66hpriepJ67saqdnpWZoa+qq56vpZuVoqGdm5ykoJ2glaOgrKKlo6ObnY6clKeUko1+mpGGnUqLm6JEL0VORzJBODIsRjs2MjIsNTotTTg4LFJWUy08Q2Z3R1kyOTM4Mjc8SIuHhEo4KzU0h5iUTXc6XXuMPj0lOEk+hH0Me3x8fX18fX19fHt7hnwFe3t8fX2EfAV7fX5+fod9BXx8fX5+h3uIfIR7CHx8fH19fHx8hXsKfH19fXx8fH18fYd8B319fn19fHyEfYJ+hX2Mfg1/f39+fn9/fn5/f39+hX2CfIZ9gn6EfYZ+hH+FfgV9fH18e4x8gn2Pfgh9fXx8fH1+foZ/CH5+f39/fn59hX4Gf39+fX5+hX2DfIV7AXyIewF6lnsDfHx9hXuEfIR7Anx7hHoCe3qIe5B6A3t6epd7AXqIewF8insBfJB7A3x7e498AX2jfAR7fHx7hXwEe3t8fYR8DHt7e3x8fHt8fHx7fYd8BH59fX2IfAF7hHwEfXt9fYd8AX2EfAZ9fXx9fX2FfIV9Enx9fXx9fXx8fX19fHx9fX18fJx9hX4BfZ9+Cnx8fXx+fn1+fXyEfQR8fX18hH6PfQR+fX1+iX0Cfn2EfoV9CH5+fX5+fX19hH63fZl8A318fIR9AXyFfQd8fX18fX18hH2LfIN9hn4IfX1+fn19fXyEfYV8BX18e3x8hH0CfH2LfIR6gnuGfIZ903wJfXx8fH19fHx8hX2IfA99fH19fXx8fH19fHt7fHyIfYN8hX0PfHx8fXx9fXx8fX19fHx9AgIEAICBkY3JubuJi/P185TX0oKkofHjobKGzYH/5aCwwJd8yrzL0rG01nizo6+yrtaWtbqXh5iI1r+okb2Y28WK6MtvmKxvdoN1zZV/n5p43OeH4//98Lu+//Xj0NGmwKOO0ZKO1p2i4bevsqq1pITarqKQj/yGjaafjpCXjaewueGix4C97daz/I2fx9XKxL6yi4qQz5Wqt+Gyt/L1yuPJpd+v6JaAjpvKybz13r+yypnf0OWp1rSBgZ17knd8aMN5hq6QqMvuiYN9doyTua6zda6gaIeL0MiN7HyPkJHF1YeemJ6z3LXggOOSlfCo4rXJl4/3ht2Ph4Wk+IGxrbnKtKqtl4CQhKNvfnuwk4Z5oOGqeqJsgndtkpJ/dY6etZqMy3+1kdeXxo7Q3O68fKe7q26Dv5i/0LCUsqhkw794gI5thHLJmqKhq4mPlaergneqnc32lJ3lh665s+fCvKrczIqHdXu+jal5coqdsLrEsH2Hxs2JmJW32Ofkt4SOeoTh1NaIqICXk6R+1ZeSjpGGq2G0jmBqlJOQkIGUtbmOlJSvv6inYrBuZmTBupSbnqqjs6iZk5SotIOMiYN9lpN4bGGIcpLF1c2Gi5V6cL63hcB0ant2wbuAYqCMmmtktpymb5a6ptNwb2Vqk5jKyImbpJWkl62YsrF0b3yPe9TA1b3Vyn+lj4CNieDi4W5+y4/Xedqz45BPvXU+dz9zPzyITECMc6WqqM95ZcZqTEmDgERBSEpQS0dISEhESU1SVldOTk5DTk5aWVBUa15bdH9weGxfbWN8eEZMfYFDWmVocl1TV4aGnFZrcW5pZ2KbZ3KEo6rHkn2kq8iGgJ+ky+K905aFpVFLSIBSg4BoupV9oZ/wsaOMho2yk5q3qsCelaWRyJGNfIF8PouJkZSDnoV7SIpIR31/gnp5f4Kcq6WTnJeNgnB5yGZvcGpwbHdvX2uegEhBS0NBRkRFPj5CQUBURExFVlZTZGJjZVxZVY2JmI2hXYmCbGpxcG1snbSwjWpzcG5ub3Btb4Bsr8p/gNiwhomsioCb0Z+SgOyd89Pc8OObjI2j2tvVrbGMkpmUmInXpcjHvJq0qo3i7o2k7LLixL2DppO0t/TEiaXhutedbYnKhWuzdX5wcmpzc2xjVU2JeqDCubttgpB6yaB0gZChiN6/m56WrJSLcYh+nYaNmpeLiIKkqZ+QfoCFjpS4aZ2zcoWrn6unwMC4uKWr2cLIwqfOsMm0yc2tupuQwMqEz6/Bp82cp8q2ppB3rdTSr3uIhpe03ZHVs47PiX/Cko54t9roynF1kcfjhrzVx7TtzPro4ajYkv/kq4LKpcyOmrCpq6Szg4fkhaHtoPLq2vCYf9fv0Ny9grqTzICIjoy3pKp5gZTr5H7O04Gtm+bhl6d0xnHq2KfQ2ayK2dvd9dPS84ChoK65sN6KVmJaX597yrqphqWX49+X69+Su+2AlZ+I/8PL/+Sc8siL3NDEt7O9xMrJw6eSt5+V2YyCpnp7sIuFhICQfGSifXJfYp1RWGZmYFlfWG11hqZ8mYCOr5uCy2t3jZyPkpOJbGdojWh5fZd9gLPDqMiYhtGVvXJpdH2op5zHspmRo4Pfzdqi176LkqqMooqYgeyTk7GYq8PphImEepKUsrG7gb+xdJeR2MaJ8ICXm5q9yX2Lg4eSqoirYKt1csSOv5CdeYP0edZ7X1tuyKPwytrr4d7z0oC6sdSVnZ/Qt72ftrWvs6SWoJOWt7S3pr3Z57+o4YXChZ2FtpbRz8K/h9fg25Wm0qTY+curycuI6eyboaGJjYXtt8PQxrquubfEnoCuntyedZPCbJmwqvXRwoy0spGWgovdoMKakI1tgoKeyZaatp1neYu91uTnsoaOhJD32sV7k4CSlqqF6aiuscCy6Y3tw4mXzM3IyLnL6vHI0c7k9uXpgeqLhIH69c/U3eXf7N7Nw8ja27XDvLeuxceom4mwnbLq+PSxr8Kbj/H3oeeTgZKT7+azh9rGx4aA5bbCgcHgxvmJjIKItLDcx42rrqq+r8K0ztiShJGok+/E2rfg1YWznYCbkeTy/4OY657tifPI9q9r+a9gumG0YVy+a2PAkNvh0fWQgPuJbWmvpGdlb3J3cW1wc3Juc3l+goN4eHhteXmJiX2AmYqKqLaisaGOoZi1rWlysrZdfYiNnId4dbW1ynOVnZyVlZDMkZ2tydDnqJK5xc6Kfp6w0uzH3KOg2W1nY4Bvu51xzrejrbbuwrqqqa3DqrGxosCclqye05WbnKSoWra4xMSmyqScYrViZKyptK2mr7zc49rGy8m7sJ6c6ZOam5Walp+ZiZS8pW5nb2pmbWpqYWNpZWN4Z29qeHhzgYSEg3x3dM/K2MLNaL7Bq6qxt7KszNXUt6m1sa2wsbOwsICs6OqLierOkImcgHuW1J+Tgfaf/9nq+eqfj42j6OfausGZo6qpsJ7zr62ooYWakXrM1neH1KjRu7lxj4Kgl9CqdYrLrtGgdI7EjHTAip2QkIeWlZCDcmSxnMPj2NWNorWc4biNmp2tjfPcxsrG28K9orirya+7zca4s6TEyLill4CjrbXXj77Gk6LGxsK9y8bMzMPI9Nrn07rlyenL5fDK1Liy4Oeg58jQxt+yvt/KtaaKwfrxy5memay/43vy2pnilo7Pp6uR4fH98ICCnOLzmtDVxLTirvjk3aTPeufEooDjsM+gttC/u62si5Loh4fek+bixdiRgcjmrKmjYoOJzYAsMTRlT2lOPlZkdDp7f1pwc5uLbIBTh0eLekZBTDY2TD5DQkNJUCkwLjpER20zIC0vM1BNaH5fSFRHaGtNdVo+UGk4QDgzYFBec3Ru3nxuo3x9eGh0gYZ/eW9VXlA5SjtMdVhZfGRgXl1qXUdxUUIyO1skKUAxMSkrLUBIWXJadIBqfGtOWzZIZWthYEhENCQzSzk6KzgyMkU8NkM/NjorQ1VXX2WOjYGjj3x1hXjv03NMY1FEUmtSaVBWRnFETn+NrMbyiJiUiaOju8LSjMSzhaNvmoZUqY+nrKq9zX+FeXZ6g2J+RHlQWIZUhW97X02VR6NNMDJAclh/dH+JeHN/bIBmX2dJWVZuZ2NWaWplXVlKU1JPZGRVVFxqaF1UZ0FhOklNb1V7YG5cMjRof1Vff2aClXprgoBNk4lWV1BLUEqCfHuHbnBseW6OjFx6boxpWXmmUmt2apWBd2uKgGpnWWigfpVwZm9KWVlohlZWgmBBSWiGi3SLhmRlVVuEe3dNXYBfZXRiqGhxenl2rGrZlnyaztjW2NHV4+XZ3t3b5+bpeOh8enfw8NbV5ubl5t7X09Dc3snRzsy9v8O+qZ6pnqq+vruNeIhbUHlYest1WWVaxaqlY4Rvd1hNhX+Fep9xjLBUUU1ddGKRqFlhpH8+R01ORWBFQjpIRpm+wZqOkV9YUYBJXbXIdkdRiWOqS2teYpGA6eyA/YD+gYHngYXiYcy1eVREbtZ5jo/qxJGRmZmYl5ebm5yanqKhpKenqKijqaqxtLSzurq8xtjT8ubD1tHq3ZOj7/mBsL7E1r+nkd7i85nGxr/Av8HZydDYwLXalnuLbHlQRFN0eMeVoYSV/YSFhICG/8WDsK7dbL+ybq3Mzs2lyblMVHNtR2dvhXl5yM/hge/1+vbL+re/huOAh+7g6vfm6vzz4tjPz8zGwbmQyrW4tbO0s7m0rKrg2aGZmJaTlpSTj4+SkI2Sjo+NkI6MjpGNiYaFg//8//j+gfPz6Ozu8O3pvJOUrOTv7ezu8PHu7IDrq3FAMmKWVVJLQT1JOjo+OWc6ZGhoaVU/OzlOX3BYS15PVk1LWGOWZI+OiHaFf2aRpmJzw6fLu8FpgHaRhradaHrDp9Kuhpi9nYHdrtLDwrDPzM2/oY30tcHi5Mmgrq2uyqhnPkNBTIGDpKWiqKGakp2dp5ulo6Glqaiysq2qnYCkpaetnbK2l5ymppegvKqknZ+grZqjkouYj5uQmZ2OlIySpKGLnpmkmqKQmKCZlI6Bh5ulmIaBe32ClStIQUWeRjBVOT46Rkk/OyQnOE1RLzYzUkhwYWZUVENTNF5eSTZPKDEuNjUvNURkREBwOzlKTY2QhpI2PW+Gj5aUU2YyPgx9fX18fHx9fX18fH2JfAN9fH2FfAN9fXyKfQx8fHt8fX5+fXx8e3uEfAN7e3yFe4Z8g3uUfAV9fX1+fod9hn4BfYx+B39/f35+fn2Lfod9gnyHfY1+Bn19fHx7e4h8BHt8fHyEfYp+CX19fn18e3t8fIZ+iH8NgH9/f35+fn9/f359foV9gnylew98e3x8fHt7ent7e3x8e3qEe4Z6A3t6eoZ7inqEewV6ent7eoR7AXqKewF8jHsEfH18fIR7AXyMewF8h3sDfHt7kXwFfXx9fX2jfIJ7inwGe3t7fHx7hnwBe4Z8BHt9fn2NfAd7fHx9fHx9hHwKe3x7fHx8fXx9fIR9DXx8fXx9fH19fH19fH2EfAh9fXx9fX18fKd9BH5+fX2IfoN9i34IfXx8fn5+fXyEfQd8fH18fX19hH6efQF+iH0Efn1+fpF9AXynfYV8AX2YfAR9fXx8in0CfH2FfIR9jHwBfYd+BH19fn6EfQF8iH0Bfol9jHwBe4R6AXuGfIV903wKfn19fXx9fXx8fIR9Bnx9fXx7e4Z8AX2FfAZ9fHx8fXyIfYR8gn2GfIJ9hnwDe319AgIEAICOrsqAobyTnovcoIPxsb3H98n025GY7ILstI2Bq9ed2t/nqJaHio+hlP2W3XWM6azGjJroiNDNidD3mJDOsM6pvNHRlfCcznt6sIGldMe159Pa0Jio3dDe5ZOH8JXCodG0iLPWwP7riryZw5zcvJ+RnOmB8Pf0wMHkh5KWyZOJxYC68KWQ3ITnnKuuo+/n+ueC9ODhrpmvjrTI7MjIyd3H+/H8iaa+sbfOuLfb5tnj2pffwqChqdR71rm9dpXarcxhX2pzgHdlgaWgmpN5xp3Vmvvr1qLfuaCrYId9f4Oe7oSJo8Kt2ubg3+mahO+2ufefnPi3x9ijiLNwdY51l6yemoCGmZWGro+euLyrioPSzIhohbGko52Ff5etu7e6e519xriflcXQqMhqdMOig8B0t6mOcWd/jHGynqKLdIR2w+eB9cOvdsmdhIGau3zct4Hsk/W6s/a1l7myubng05iLf7qwi9R+g523q7yllHOhqN3IrLrI1+OixrKwqoOhs6qloYCpqZSacWaMqW6psl9oYXBzjoCMm5aPjJ2enp2Ymquloqerw2ixpYGQn4+MjGd0boWDcW1zXWmDjZaLUk92c3WczreBrmhuwYVpt5J4g4prlrl1g52bppmjs5fRj7iqbY/Fa2mAcnCG3LB6gNF2gqmSb71vd3Ofdnf+moTnrZenfICnsrPWfICO2ch+voe1o5JykYGEeXV5dHNChpuPonOch3RvpUxHT5V1QD88QUJBQkhJRklHR0RKS0pGVVhVU05UVE1KV1dhWGlkdmRYc3Jpc46IdnR3VHCel4ZxgXh1gYNZXVlZWGFkX2+BbH1mdIR/0rGygKDPyYqJfrKHl06Fg4BHQoByrH51rfeYrJDPt33A2qbfz4ulrLCIn6ePgnl/hojQjoB9iMNmgE6MhnuEgn1/dHaOjYaEiYaDh93GZW5tbGRsYWZjWWpuVkVBP0I/Qz5EPDo9Pk1HQFpSW0xNZmNlYmCWl5V4eHhbnX2fkmhrb2xxhItka2xqaWZxbnFwhoC/c3/lf8vthoqmqJ2YqtDl2tKHiryZfough4N8z8rNwbGAjK+Ji5GVmL25tK2ZpuW/wtyIidaFsbdyjJGU/eqExMTHhKh9eKSMc53Fl2VldnF1Z25YVGpxeZt7obeBnXORrNJvjZiRkdHAqa6Yh41jcIWgtIullGljh2WPlX+Yk4CPtpSvj7u2nK6no56Zx8yowLCw0MWjr6+2srO9pYiytbG3nsB+yZTFvamJvsCBfHSJdKuTq8F/brKMpry3iOPLpbGnun96osR/vKXhp+eM3oqei+fVg4PLkc/N2aOf0YKlisJ5kah+kJCIysGCi6zNj4vm4cmWhMrE7uW3g4zyn4CJhKRvj6N7iWHMoYDnp8HP4qDx45OS9Ifzs5eOwe6t8vfKxaCXnoyKkbiM84WjumZgXGPseNrPisDXjpDtu8qluOrfkc2a/7nL87zFgsqXxMrHyKi859DT1Gtu1pa7krOGZ4egkb2tZYpxlHSkhWpfZJFVkpKSg3mRU2BjinBpmYCLqnFpr2GxdHt9dK2wr5tVnaKhe2aQbpe7w7C809nF477Ob4eakpeplZOyubHV3ZbAwKqsy/uN/eLkj5/0wuNwbnuGk4pzkbSspp2C2rHoo/3u7qntvKi+bJOKjI+k4Xh8jJ+Mq6ylp8GRd7yKjM6Eg9aisap3b8KTlqSNsdS/x4C2zMO2yKCWwcS7p6entpCEmtbJzNq7p7jb6uPZiqKShpecqtvZo6qBjfK/nP2CuKyTkIWMooPUs8rDjI2D5v2J/dHIgNzFq6+4zobSqHe2ddyZnOCjlMG0lJCzx6qijsrJnfCNfGmVo7PDt47Afa3Pt7vV2eud3cu0voaOlY6tv4DJyaiyiYGx0off9YuSjKSoxrrE0MfAwNbT29jP1eXc3OPg9YHp1bbBz7i2uZSembCroJmji5WqtMG1gHiYl5XF89uj54eM+KiH/qqgoayFtveXp9XW3NPT6bf2o9rYjLL/hYigjIih57SGjOiLlsCghuyJi4a7j4v6mYPwuZi2jIC9ybvfjpuq+NiO2ZXFtauNxp/BvbW6trJivMvEzYjFnYqL22pnccCWZGFdZGdnaG5ycHNwcm5zdnNtfIJ+fneBgHh2hYSPiZuXpZSEoqOYocS6o6CjcJnVy7uds6ikrq9+h4KFg4yOhJaigZp9iZiN37OvfKfi36WWhbStyGi8uYBiXqx8t6iatOWMxZW+z43F8MflwIOks8GJpLe3rJunoLfpqKKhseKBpWa2q56urZytnKDHxb23vbCcqfrcgZqWlYuYio2Pgo+OfmtlZmdkZ2NoYF1iY3FqYn1zfWxthoWEf37U1NO2t6pnuq/DuaWosq+1up+AjaKopaSuq66vwoDshY75htz/jomdoY6Qr87w4t6Ij8ymgo2djIeF2dLZzL2PnsCioKuZhp+gnZOGj9S0sMl5eMWFqK5zeH+E4cdwoqq3c598e6SNfrHYrIB+mJWbhpN0coaKl8GVxc+dxJmswPmEoJ+hk+TdydXHsbmJlaq70K3Gu5GKsIyxq5qxr4Ckz7LGq9rbudTOxr615eXCzcnH7t66xsnHx9LNvqLNy8bOudig5q7d18Cm1s2Xk46ckM23wt2ggsiZr8zCqv/hwcSoxI2PxOeU2b3qtfWi9ZSmkd7IgoTGjsezuIuHynmtisaJrKSKoJeBxsF8hqjFhHPE58aIgrm2yMWXanbXjYAwQVw8P1xEVDNRVTtmZW1qmWOPhFNqgESCdUMrOkc3STw9OzozMCMzLkg9dDc+SDIqNDR+TY2LTGB2X1qNXG9bV3dnRk03al1hY1mhdpFceG92eVdgh3hvdEZDakZZRlpcRmBvZoR3Q19QZ09wUzgyNkEnUlVPNyw3IzA2U1FLdYBncEQ1SjhmUlVWPFFITk4uSzc2LjMxHzY0ODQzNDFAa5SpWm5+e36Me3WRlJXU7phoZkpXY5FYinh7Tm7ey/qDhZSjr6WMr9TMwrWT9tD7m+rToZjqv7negaabnZ6u3HN1foV1in13d3o6NYZna4ZdZK6Fil0yOHZTVVxUVHNubIBgcWhgZllheHp4YFFfelJKWG1ZanhcUVZiXlldOEI9PFxpU1RwSlgqLUtfWYpNdXJYT0VXaVJ4bXt1UE5LgIdPqYB4V6R1amF3h1CTe1Z6WsF6gaVwXXNtWm6JiIJ6ZJeBba1nWkRdZXN5bk9sTWCMdXeDkZtsnoZ1dlZeZVRweYCPooKYYjpok2jH2nOLfKvC087S2NDOytfV3t7Y3N3Y19fMxGTKy663uq6msbK2tLa5ure/tLa7rKGhl5OdmZ6qvLVxdHx3mGBM2qyjjoVXf55be4uJhHR3fGGRirB/a4KuUjlyVkFN1Io2ZqBBOUJeQXBKTFFPOEDQe064gJVgUIBqh6u7PldorpxWa0FqcFRp13D6/vn99/yC7Ovwp062WkFz6IeIjea5i4yKkZKSkZebmpuZmpuenZ6cpKilqaerr62us7S5tbq6xby+xsK7vMzTvr3PlK7n2+LP4tbV4OOstbS4ube3uMLKbp6IcXVWZFFNSmegvrCFSF3Q7YH/8YCBgOGTpuzZfWJEuW+myYOFr9WSXjp2aXRNUJPk383gqO2wqcfT7PSi0YDv4NDX0bvbw8vc0srHxrt6lq2PjLSwr6yuqainoqS7tqCWkZGOkY6QjIqOjZCMiJKLjoiHjYqIh4X9+vzy9OyC9ez17+Ti7OnryG9gbsrk3+Dk5OTp2YCbPDZtNml5P0dKQEY+Lz9YVlg8OVRSNTxMPS81ZW9PUVlGR0lARldgbYeLiYF6cGtSYHJdbbmNpKmHcHN5zrNmjpuxa52HiqyZjN3817Gmzs3Vucyiorqdt/GcycuIsnywv5hMPEBBRXiCnpmfmqCPkZ2msZ2popSVp56qnZ2lmYCarpebmp2VkZCHjIeKqJ2PmZCNn5OEgoqHioyKh32LkZWXjJmJoo+lnZeNnJiGhoJ/UVNUlJOCc4x4SEU0KGR1Qzg8UTM3Q0QzNjJLQlk/Tik3PXeLRDFZOFFhVERCTCc5K0YrKSorODdHWFY0PDc3OlCQeoNPMWZwrKB4WG1ZMYR9CHx8fX19fHx9hXwBfYV8B318fHx9fXyMfQ98e3x8fH1+fn17fHt7fHyGewd8fHt7fHx8hXsFfH18fX2JfAh9fXx8fH19fYR+Bn19fn19fYZ+An1+hn2EfoR/Bn5+fn1+fYR+hH0Bfod9AXyKfYt+g32Gewl8e3t7fHx8fX2Nfgx9fXx8e3t7fHx9fX2Hfol/hH4Lf39+f39+fn18fX2GfJ97hXyGe4R8BXt6e3t8hHsCenuEegt7e3t6ent6enp7e4V6hHsEent6eo57gnyLewJ9fIZ7AXyMe4R8BXt7fHt7mHwBfZ98B3t8fHt8fHuGfAN7fHyGe4d8AXuGfAN7fn2FfAN9fHuGfAZ7fX19fH2LfId9Anx9hnwBfYR8C318fH19fH19fXx8rX2Cfol9in6CfYR+AXyEfYJ8hn0Ffn19fn6HfQF+in0BfpF9BHx9fX6RfYJ8pn2GfAF9l3wGfX18fXx8iH0HfHx8fX18fIZ9i3wBfYd+hH2CfoR9Bnx9fX18fIR9AX6GfYx8g3uEeoZ8hX3JfIN9hnyEfQd8fH19fXx8hH2EfBZ7e3t9fHx7fH19fH18fHx9fXx9fH18h32CfIZ9BXx8fH19hnwDe3x9AgIEAIC7g7bFyMWEsIuq9vnlismKuJrvvMjem36OiPyixJSq1sewjKe30cPii5jSm793uPORuYmjprm54ZKi5ue7tvjEsbnl2vyHcmeIb53Lkqyc5Jajf2LFuMbx8oWBioOF/IaUuaG0na/i37m8mYvNnfzd4rWz1sfOnICdy4252Zr9sIC33rfU9vKpl5WE1+fwgo/79cyupobdxKDG3sCgufTnipCJkp+zwLakqZWJ27/N7rm9yea6dYOSmKTTgJpnZLtpy3SBnIRnbYOFiHG8qIbLoZuIuJGqo46QqWR2dHmLs8SEiIGLqebU0diZ7pShqpC52M2rvaSG7azCm3jB0oh4kYCRj4+xxISUtLmfma2t6oXAq398vsGTttR7iW/RkOaGheH1lIN23tGy7Mh6s46Xct2CraigmrCpjoqVc6x4dMq0vs18meVpr6yz+IvCmZ2MiYyfq+rDtMG0p9aE46e4f4Cgz93ipMGp4IWpw4/GpLi+s6ichHx4hauZtOjLqrCelYCK0NO6vtWncpCQjYd8sHaEd4NkjHZzfYSRm5Jqtrymf294hYaGdl6BfpyhyZWck4KkioOQWWRjY3OWV0lcW2OKon11tpZqtGtulL+UeKWOlLmFaZ6Zq395sKC1gpaEnXS9w7DGdHHU05q0vdGKpHuzdc7Df359b5je1MWZt9WLfICgv+aOiq92nbLOfrOfiZOSe3lwc3l+dnhBf35vepaMocSkQ0F9fHVHQUZAQEI+QEE/QUU/RkhKRkRDSU1NT1FXTFBKVlNMTFhvbHhhYl9ecnpcU155bHpsbHFqcJBydneCVaRWWU9PXmZ3cnCdznbL1da845W9fXB3c5J/foF/bYB+eINrwaugjqKz3q2Cv32jjYy0pn6djaSYlaCenoeOiLapzaOkc8yIo515kXdwanOFg4eKlYuKhYXFyKeKaGlqcGdnXV1NT2p/UERER0BBST1APjo7OUxBTFhdUlNjYGJjZlJ9h4B0c3+ZgW2IkYZ0i6alt6J+urdqcXFzaGdwtoBz2dSPiOXl7H6WpIejqq2P0YqI2cvb+oj6fJfg5Ny039t4vYSTkbD6y86HsJuO3r/55vOAtcuHtc6XesXurOKHn4D8kvN5mZ6vvZ2umaaFgWZ5b2JdWUNuo3DG18Wwg2heoJ23oZrcge7WxLy6jLjGvKvXqKitoZGLk5aSl6mfqICSrrqbnrK5fYWEcIN5fXyXj8t/kbVwmpGRk5O0bJ6veIJzfoR8o6O9zpxpm4mUdoKleL9+ectwqbiM09LRw4+we7uag6alqdyL6YODpLWnzN+Ql5SjnIzk9Oqcrp6gu4bYxMH7eOytvbja6IGD6Zuk55zYzZe4sYeetp6eqfevpYCQXaCeuK93m3ic4vLKgMaIsXTyvNrRpISOe/mazJy84+Cam6rS4t7yj4vSr9OKw81JXVBqkLnC4omn/NGtpvvBscf13v6XnpishbnVqMCFvXiqpoK/xtb322Nka2VivmRsiXuFc4Kpo4uOcWeTa52LmHdyiHeBcF1tf1p+m3LBh4CKm4OitrV5bG5emqq0XmKtvJB5dmXUqoysxqKlmt/XcmhsdYGQm5SFjIJ9sZ/B4sK9wPXbiaq3vsPzla53dNN35IWSrZNye5GQk3/SuZPbrqWLyqTBuKOnxXCDgYiVssN4eHN6j7WlnamIw3R6gG+KoJuElIZtv66YioDP5aiTo4CxsLvi3Y6u6sGam6Kcpmi6wJKM3e66zO6er4bwkeWIa+L6qJaB9NnZ/8GX35qjgOig/uK0ss+/qrGwgtCcj9S9v9SLo/yC5MSq1nuviJJ3a3aJgsCmq7utbJVfxbe9k4iv5fzXX5a994il2ZShfrPGyK+pmYKForiVkKWpn8Gzq4Cf8PXT7urQkLLHs6CZ9Kq3qbWUuqakqrrG0MSE6ufTq5uptLi7p46wpcfF58XRybjfvbK6g4uNiZe0eWp+gIyywaGW49GJ7oyK0eivk8W6vO6ngdHG26+q3b/cnrOt1573/en1jID98qDD0+aeuIu+hOHvlZSShLDk08yTuN+fkYC1zvKhm8uTvcfzjcCumqits7CrsrnEuLdivLmemcy3vO7aYmGvmKNrZGpkZGZiZmVlZ2tlb3JybmlqcXZ1eHmCdHhyhIB4d4Whm6iMkI6LnqiGe4WjiaeXmaKYm8CfoKGzcNJ5gHBwgIubh4Kx6ofe4ubD0JnCiYWFirSqmrCiioCyrLJ3xNLGpazR2badw4+znqjErI6Wmaqfo6y6yqmgo8vE7rO3i+2syryXsZCMeZexsbjByLy6s63a3bGikIqJmpCRg4d3d46ed2ttbmZlbl9jYl5hXG9jbnd/dHSBfn5/f264w7+xr7DQr6GwxMSyx9vY47uQ1eKmp6eqoKGq3oCD7eOckfb294GVn3+hrrOT3ZGQ5dTh/4n/gZXo9OnD5uOAzouioL7rsa93oYyAw7P65Ox3o7uIr7yedbPSlMFxhG3cheN/m6G1wKS0tMCmp4ijmIN/el2DwI3r8d/Fo4mEwL3grKLrh//w2dresNjay8zGw8TKxbiqsrm0r8a/w4Co0tm1rc7YnqSjjaGYnJyypf+Wq8qOsa2lqbPRiLLDlaCRmZaXvsPM6rKIt5uljZu0m8yYk+mH38if7M/h4p/LjtWqh6uow/mg/I6Nqbqd0OmRio6YjojN07GMmo6NtH7PwsP6iOqwzsfc+ISM7KKP4omssYybqnd+nYJre8WYgoA/KkxZW25DYUFObmd5VHlXakCEeHR5RCk+TGc8MTA6NzExLD1BSkVMMTleSkYqRVwfKSo5WFtbjlRNZHBkZplmO0xXTVI+TEU6JlSPYHVTZkxfWD5lZHKFhEdCQUA9eURJXFJYS1d1b2BiTkNdN0M5QjAvMj0xLSYpODRQZlOPZ4BnYlReTF9PSEo0PUI8JTVRQzQxKyc6Lzc0OjgvMj0/N0RVXWV1gHpqc3Jvj4a849qQY4hzRlRfX2SHb8CHhuuG/penw6WCjaqloo7pw53blpiFz7Pd2MPI7YGWkZujucpvbWhtf5B+dXpcgE9YWU1gcW9jbmFGW1ZaRzlmZVFCV4BeYGNublJtjHFgXF9aYUJ1YD4/a3JbXmVBOytRNVM3MXudUDAxZ2NTXldIe11hUpJhg4V2dY19amZqT3pWVnmChotWb6VIfIN3jU1zWWZVWGV4Zpx3cHNzTGlKfYyIYmN4naecPVx9oVxog2FuT4CKjIB5YFtdY3lgW2h0aX1xb4BpxtCru4eLcYOafWNfnKLAur20xry6u8jM0Mltys7ApJOgn5mYnY+cmp6hsp2moJCYqLG/qaejl5SbjIeTkZekrZZ5e9Jlg1hZ4/myj7SnsbCGYo6Jk1VSfHeKZ46jhou3vXOPXmaKp5eEdWxOSCpXNl2Oamo+PT+etpqAm6U+ToBZfeVxUpVnbYt6YDgzOFJr7e3w9fj/9v2B+/rVmN/caW7rhoXvrtWPioyMjI2MkJKSlJaSl5mbmpiYnJ+hpKWrpqmnsrCura+2ub26ubq4u7yzr7K/icS8u7u8w9PPztDyi+SnqJCWqLi/gl5bWThJZGU+d1yOhIlyiLzrxOKgbID29vKOS9zMm02tioK+jZuioMa3lZU+ZW9Ugna54siUd4OXsYamoffd69jFyqq0jK7Pz9PTzMXCvbObmHKLpaWYqqqoo6KbmqHFrpqTk46MkIqLi4iKh42Hi46NiIaLiIWFh4Dx9Pbs7ej37eLs7ePU18a2kG5cfrzZ1dXZ2NnZs4BAaGA4M213ajU2OzZLNjUwVSkwY1NidjxtLzhsglxPVGUzSC1FVFW/lpVpj390h1R0a2tHc4hvt6/CgqzHh61kdGPIfueRo7C/zbbD7vHf58Hk17e3soqTw6TT2N+7jXVulohrOz5iQ3qKhHalo7Kxqqe0q6OinpqUkqKjkpONfoCBlpGLgoeIfHx9eYB5f3yEeuJ1eot3fX57gIKOdn2Ed31zdX6GlZaZopKBlIaMhIKIeE07T5Z43413Tz1QSEVdMEkxM0pRWVAxSiwsPTQ9WGpIU1xnWUF2Zl5STUpGPTFeR09LJlJGR09hZywnQCg+flZ/d2hMPUFTeWJIV6RdPQd9fn19fHx9inwBfYR8BX1+fX18iH2FfBF9fXx8fH19fH1+fn18fHx7fIV7A3p7fId7Anx9hHyDfYZ8Ant8hX0EfH19fYd+BX19fn5+jH0Mfn5+f35/f35+fX19hH4FfX19fn6IfQF8h32OfgZ9fX17enqHewd8fX5+fX59in6DfYV8hn2Hfol/gn6KfwF+hX2EfI97BXx7e3x8hXsNfHx8e3x8fX17ent8fIR7CHx8e3t7fHt7iXoBe4d6BHt7enuEepB7AXyHewx6ent7e3p7e3p7fH2ZewF8hnuNfAF9p3wQe3t8e3x8e3t8fHt8fHt8fIZ7hXwCe3yEewZ8fHt7fH2EfAV9fX18e4V8BXt8fH19jXyGfYh8AX2JfAV9fXx8fK59AX6LfQF/iX4JfX19fn18fH18sn0BfJJ9hHymfZ18CH18fH19fHx8iH0DfH19hHwEfXx9fYZ8Cn18fXx8fH1+fn6FfYN8hH0CfH2EfAd9fX5+fn1+iH2LfAd6ent6enp7hnwEfX18fal8AXugfAp9fX18fHt8fH19hHyEfYR8AX2GfIJ7hnwCe3yFfQJ8fYR8AX2GfIV9BXx9fHx8hH0HfHx9fXt8fQICBACApYXjz4PVjaPNrZmf54jPlIHV0aCmuLLEsuz2rrj7ksaQ7KSgnZ+hr7mPyHKHt9ixjMjAq+GhmNLOqZd2xrbYn6akg8eQipGE2aah25CA1ojDdWTNvLmmtoSXoZWGhp/FmqvnheK4wIfit9rryYLAvbWku9XCsr69ppvtitL/65eAi76h9dzoopCE7OnStrTw+PjivcivtuWs0pqUoL7biY2Hr7ainri0o7DuiP2it4j1oLZymIB2bpPiqJzJdMJ1cXl4cHSTho2Vk6GBx6eEe7+yuIvglLGRhJS1XqtoynF7i67lg/+Q1s7EwMHEwrarobmejJuhyKfK8fS+6a/DndGA2oiSyNN61paNjrWN2Man5YPb48C1vIDZo4qhgo7L9OW5vMumuqaozXZ8Z692d7HUZsidv8utf33HrF2xqr55k9OHi7vCoJCYiMCNyXjnpYmar/XikbHEk9u7/8qYjOfB397XmrbIlpSsusWjiKV4mryktHK6r6DLv5WzhZSdfpeAWnWIZGK/cHaZWZlhY3R6k3iAfnVxf46OgnpwiGZlUUx6TURKhIFJYXByj5SRlYmjaXCttWBSZG1hhWhES09SXGmmtKSVsKh3v1FQsYKeYmmTp51ivo15gmmEnnlvdnZmvLipk3vHhHZ7sJOMoajdi5KDtse8mLaEhqyf5Kd7kHSAq56XrJ/EsJGnxHm/pI7bjYqyaWxwd3V6e3Vya319fZZ3b3ppaH9ASkRFSkpTST87PD9CP0RBREZJRUFHRE5UU1FTUlJOSkxZW19wdlhbbWpoUU9VZXxpZ2BdWl1jfGlqaFlJS3d3gE5jcKPEn5mrys/ApajS06vKinl0gYZvoJyAeH2IdISgiYqLtZmGhHCfmex+keVvdI2XmoJ92nV4poehpay+no1in6Kke4xwZG13fKOprZCPgn5w06ahfLjdxGtvXVRhVEtHZlJOU09FQkY9PUc9O0RSSlVVXVheZFpfpluVg6OyioFxd3Rtfo3BoYegqaqGym2bg4PL06dtlnSAxtD0nHeQzeB/jsK85oGTip7PvuB+55Gf6NyOvpiwhNDexsrWjMGJiqD3raHe0aDbnZfun+HG24m9gGuciaPzncPYkZnCdLOWkIyqklhVXXJTklWBdJGJg1R+W7zJy42prXmDkYiCzuHf67y5xM6lv97DrsLQy5+Fhreji5nChnqAfZqjmouMoYO2jLl6cXBpnMSCbriTvp/CcX6Num6Tl4aMgaS2gXWEscWTd66ahnPEb4CygdCygauQweG9zZuDoOLFlb/BxdO9lo30p/mSlpTq7o6QjoSPjKvOj8Lov6K6hZyffvarvvaypITEmqeY3NaOnfuPuIaavZePqt3S6tOAi3CvlWmveoWvo5ul4H/Ej4azv7O9vrurrOfzrbr3lMST6r61u8G+zNik3YeO0/XDeX1gZKiSk/LKqKuDxbPNlJqcftelo7aT8ZSu1ZJ51YXGkJT4rc/HvV9xeHBiZXmXdoKyZKuJjWariaCulGF5fXBvdoF2dIN9cWeZWZq5tHSAZodxt6arcWlcq6OejI6orrGcioCBmcqsv4x8kanUiHdoiIx8fJSRg5LaitWEtH7qpbWDrpCXirHyua/egtqJgYmKfYCmmqOqpamM4LqOhs62vpX1pc+rna7TbsJ04H2Jmrjcd+R8p6Sdm5SUkouDe414anZ8nYe23dHI5MHKlOCA9Ki37e6N6qKbmtCY8dqVqWjR5MnY54Lkw3ypiJq51vHZ0+S62MOw1ZCdjOmLg7vvieevxOy3j6Xp3YLp2PKJmdWXnt7jxaqrhM+T1IDyomd4m7u4gn+oe6uIt76qi/bP8e/TYn6zkY+rp459dZWGrPLN4Y6qpJClrarvqL3Jor6AgKCkgYTiiY3Ng8+EjKWpvqWur6airry9rqCYsIyJdW/EdXN529hzjJqYvMPDy7zVl5zX3Yl7i5CCoolna3d7h4rl8t7W+uGX+Xt025vBio3M5tyA+LyYrISjvJOMlpaG9OrZyIvyoZWMvqyarbn9l6GU0u/bsdOblqik4KqAoYqAwaKew7re1qi54YnPwZ/0n6Pqoamxtre9uq+rpbCsuKunq7SChbpkbmprcXJ7bWReXmVnZWtmam1uaWZuand+fHh8e3l3dnSBhoydpIOFmZaSenV6jaOVkYqGh4aLp5GSk3VkZqeqtWiAj8HfrarDvtHHq63l5LzXpZORsJ+Qw76AqK+sgpHBo6OfvY+Sk4Ohs9uMp+J8gKGfo5CHzZCQuZa3rMnSraVxsbjDlJd7d46TpNzf2rq4r62c/LK0luHV7pCThH6FenNtinp2enlrZ2xhYGhgXWR0bHZ1fXd9gHV43nTMw93uyLuusaifs8TuzK3Kwceh9Ya4kJHl7MWhyoiA4uH9pICY1/CEl87G74SZjZ/cy+mF8pag8eOUzKbAj9nk1NLjmMiKho7kp5raxJDLmZHzldC504u0hnCdfIzUhaO3fIjCfLign5W5nWdmd5BouW2nlbqxqG+uc9Db4rzp7puktpaL1e7r/NXT4efEz/TdyNrr6bijoM7Cq7DkqJqAmrq/sZukuJ7pn+qVjYeGuPeej+6p9Lb7i5qnzoajtJ+omrvPnY+kz+CxlNi9monohKDRmfzNlNOc3vHS262Uq/XqltXOu9DFno7vsP6blYzs2X5/ioWKYXOwlZbMqouxf5SQgPWptfTEt5bWqZWQsb14eNObmIietXltfZaasKiAZTZpcEyPXVZfUD1GakaCW0VkaFtRY1tFTUVHNjZ5NT0oTj87OEU9Qk9FTSs1PEtFRDooMmZSTnNxYU82VlxvXzlFNVBDSVUxRjRpkldQeElnOkWDZ19aWzdQVVBGSVZpVFh+SHtfYkh6YW5wVzY4OjAvP0M1NTA1MjZEN2t9hleASlZLY2lkPzArS0E2LjRLQzE+Nj01NTksNyw0LTE0Jz5MZGddX3h2aHvNlKxnvHrzsHBIYVJNQ2m5r8Pxju+glaCej5S/scXMwbKT8saVgayhpJbWtvjNv9T8gt6C/4+arsfecNNwhIJ+dnBubGVdWWdUS1NccmN5YG58iX5oM1aAcFdjfJhVq4aDYIpvpIxaYj93dWNla0BoUTI6NUBKSFlVYnpKWllWcDhIPGlMTWdhTIVocpyAYGqNfUeAbnxaaJNfYomQd2lyW4NiiFGgcU9pjZuUVFt0W4pglHpxaaSQoKqKPVSFZmmBf15QR2RaeJaFjFZ7cWNtXVZ6YGl5V26ATHONVVKJVl+Ee7J4gqavuLK1trGyrrOwnpmXm46OhIL7h4KF/f+Ej5KMkJGRkpefho6iuJyTmJaOk5CFiI6Nf2OPvHmpk41spIKK6Za5mnqa0cFptntSXkNZhWtidmVhubKIYlNyQWBqpUw8SkFuLjE8V6Z2PVdTg3aGvp1qTj6AbJKQg4yCq4SZYERKdkJjTWn05uzy+Pj8+/Pz8ubg+qHe+f6dofiIjYyMj42RjouKjJCRkJWRlJeYlpaamZ+ipqWoqKiqqqirrrG4vbKzuLa1rKqtsru2trW0s7W5xL/Dw5yMiuHn8ICRnLWSWzpCR2RZPjc9e5aRorDA9KxehI+A6/DYmZS9jXZ7bjtjcI5htDyQvYqDd4RsSGVcgrShh4SBUZOWoKGDxMPPwJ6Hlr+sw/bk1qauuraw8omTeLKm5aWkoJybmJeVsaaVk5OMio6IiIqHhYaKiIuJi4eJh4KD/YH47vr97+vo6und2smDfXKBbWxgplR2VFCKgqzOuzuAZWVsMi4zWVkwNFFTZS8yLTdVWlMxYTtIZl83WWdNPldvWk5LW2tQW3fRpZLWtWBhTlaBd5N+o3mrk4Wnb33Ac5SibXnRndTBvq7er4WGob+M+JPnz//+5pL3id3z4Yq3voJwTTY4VWVsg3twia+mqKSen6ipppePiJ2ajYubh3qAfYuKi3x8hH/get56e3Ryh997d9d74IDic3l+kXV6f3iCdYGHeX6Nl5yMgoqFgXmDRD1EOH6MeNJ3f1VHWkw8UotRN01lc4VzNDFYPWU9TDxvf1BgUkVKOEJrOU5TQ0luTlszKFE/SlZORCU1NTk6ZYJRTYtTYzc3UmBHUW+AkY0BfIR9knyGfQR8fX19inyFfQd8fH5+fHx8hHsIfHx8e3t8fHyEew18fH18fHx9fH18fHx7hHyKfQx+f35+fn9+fn19fn6NfYR+Cn9/fn59fX1+fn6VfYt+DH19fX59fn18ent7eoR7BXx9fX59jX6EfYV8hn0Efn1+fYV+An9+kn8Dfn19hHwCfXyHewV9fXt7fIR7AXyFewR8e3x9h3wCe3qFe4N8hnuJegF7hnqCe4Z6BXt7ent6kHuFeod7CXx9fHt7e3p6eo17hXwGe3x8e3x7lXwGe3x8fHt7m3yGew18e3x8e3x7fHx7e3t8hHuIfIR7Anx7hXwKfX18fH19fXx7e4R8BXt8e319jHyEfQN8fX2VfLt9Bn5+fn19fYR+hX2CfIV9AXyGfYJ8uX2HfKB9Anx9k3wFe3x8fX2FfA59fHx8fX19fHx9fXx8fIR9Cnx8fH18fX18fH2LfA19fX59fX18fX59fX18h30KfHx9fXx9fHx9fYZ8AXuGfAJ7fIR7D3p7e3t6enp7e3t8fHx9faJ8A3t8e4V8CHt8fHt8e3x7mHyEfQh8fHx7fHx9fYZ8AX2FfAp9fXx8e3x8fHt7hXyIfQV8fHx9fYZ8hX0GfHx9fXx8iH0DfHt7AgIEAICej/mA8ezykrmZ3JP1wfOsuoe3ocayqsXL4nuwi8Dqt330p8h7xdrC06LYfpCGl5veeZyVo8fEpYOwloeqne++3qOEsdXnxoXQu8HEmYdxcnV8gI+HmXzdqcGZiI7rjK2EhYPH7Nbastm8tJ63vLaU+e2bk7S5stS0t9H7v7rs/4Dz9sWhhZntuq27v8HVxrzR0825gZWCrI+frr28muHhk52qwbieo76rqMWHr5bJv+qXr3rMptaTkbiIu25tcHFpdXNwepiekouHlYrKtJulitOhno6Te6KTk568qpuZl7dzfIuCpsSHj7vErZPZ19TQwbWqmpirvcWWn5SegLrGpIDPnoukr5zRmYbU03zuyZ+rreXyyqC/1nWG6ZGug6K1fda7gc2df87Hx59pc93azL7NhH7Jm52esX28mY+Y8OXYzprJn5easKun+YiNks3Wo6nPlOGMlaeP9K7J6a+37dbHgZOsy4/su4yKkpJ3i+XfsOGpqLycrafciJavsZGZgoC1hmyeaM2OlWVaaX9gV2hleXl3a2NoZYGCe3yFc3JybnF+dXF7enlLW4ukn8FrrZx4cJuiapKeu2hlXlxRVFKnsaybtG1stKu+d2yOd595cq5Sr6abZqSdoXJ4hZyGnL5mq3LIssauy2yGycSGo4XHw3jWeZu2qXmpw5WAsoOymYCg07Z/tJC7h8iyqoqfnsSTloBraWZqaXFza2xrdHNzqXZzZGRzOz1DQEVGSktKUEM8O0BDR0hERkdNUEtLSUVQW1NaV09ZYVheZV9gYmRva2NgWlVYZlVbVlZncXJkbXFhinaQhHVUr5OZkJrBz36bneKTk7C7qtJ/kNqJla+Xg4CBhnN3j5mbf4+Vgpp/btyKhZWWg2qH86iXlNOU1G6bfnN4naDGq+h7ibbIkXChxXKTl5PWcMt+h3V307uNr2pee3FqVn1/aXeCWVVUS0xJSj9BSjhBUUlRWF1pWFWiXG21qIqUsqZ/f2traH+Qp6RlZIW5oH7Dy5WGgM+yjsHX3oCT84jnq8XLtLaWm3h8iJqbzYi/i4LHh3vHxezMj5G6gaapnrHUjrvcnc7I1eSE07ectdWqkY/ApazEhJHj0cbj9fSFivuXq4t7i3HvtnBle11Hf455RU9GaXtOa5GjbXyLm2e8uZGP2NjYtZziyb++yrq9nrqxoo6bscKGnYtxeYCXnbd7lqaghHiYiol6kI+fdqx7oYKIkmttf6iInXR5vnuhfY9kwGqjuHtrbMiZnsu/nnKun47QnayufJHTz97kxYZ+0Nbtv+yshPWHs4SKjJHejqqFe4zAqrGjhY6EmJ2Yg4vi18GzvLmixuK2kLvCvYOviKmvl5XiqouSjMOqnYBwYIhfw7+4fZCA14DjwtWlqYOnq9S9o6q494mrhLXvuITYutyU1fTb+rvnmqiCp6HLhItRXHWWm4W1qJy8ne212ZZ2kNX1p3O/yMzGpaWJioaHjpWVqJPXi45wXGmraoZjYWOTrp+kg5+JfXWCjXVhpaZpYG+Ac310coSkh4ayw4C3uZF1YmqsjYWKh46ej46foJySZnNemIyRqauol8LffHh/j4l7gpqMirWTsYLByuudr4rst/21pcaXzXp7fn53gIB7haewpJ2Xn5Djz7CvkNi0rZmejsGyrbjaxrOsqdGBi5eGn7xydJWejHSmpaSkmZCJenyIl5yBk5+OdImQg4C6pJu1vaCygIT04ITm1q2ijKC6vbjW0oqS44yukIGzh/TKhNiskPTq7smIjff/+eLwgIDxsqiiuYzp2cmz+PXz/7Phuq+twL+k+oucqvj7iHu7c7VrfnpbiX6Z2bu59OXdhF97y3zv04Bea46AgPzpvt+SkJKDn7f1u9f3+ba0loDcpo7ZjfG4ypSJnbSRhZaRp6almoyLisfOxcHKt7i2srXLycLJxsdyf7nUz/OG2caijLfBlLvD4oyJg4VxfXv8/+re7ouQ6uj2mJe6isWVl/V36+vVhdXC0peXp7qkvOOD55L/3O/G/oKR49+Vwpjn4YP7jrXV0JDBzJ2FtYvDrICx8MOJxKbhnO7Rxpq7v+unrJyhoqOmprCxpaipr5ilybOteo20XV9nY2lscXJxeWVeXmRpbm5pa2xydXJwb2t2gnqDf3eCiX6HkIeJi46dlo2LhH6AjX2DfX6QmZqJlJqNu6TFsKVy58LEsb7X4o2dleWen7nTuPOHo/+rtcyqpICtr4eCqMCykZaVf5uRgfKsnKaTl3aN66ugnvKi7Y+rkYuKq7jduviOkLvAkIC33IKnqKPxhuygqJKG5tOo04eFnZiOe6Kji5ikfXt6cXJub2FjbFpic2x0eHqFcXHWdo/23MLL49q4uaOkorjD4seFlLXWu5Xr/7CSi9vGsd3x9ICZ/Y7wt83PwbufpoCCkJ+fyJDLjofWjYHZ0f3anqDIh7e2qr3Yi7rQltTP4uaDwamVrNeqionJsrjQj5jPtK69yslvc9+bvqGFnYH2xYp8nXpdn7qgXGpdkKhogKK6hKK635D3y5OL3OrozLLm4dHW4dDUstDKvam6yNijtKOPmYCrscaTrbazmpGrpZ6OqqSwjLua3ZmdooOHmL6aso+Q+Je1ma2D+IS6xZaBhfa2vv/xv4fWvqr0qrC+iqHf4uPcvYeK3fHyvfy9ie14nnqFh4bPbpSBgHS4m6OniYd+kJKVgozh47m6urWspeascJ2XpG6hdZaQi5jplFZYV3Zsc4BYR11SsrmGb1U6Z0dkWXhdXkFlUkVSWUdGNxkwNl5TOiZbPUo3Tk1DSj1RLjsvNkVwQkomNDtWSzpZSUBDS3lycFFCR1xVPCtMWqGbZllJRDc4TVJJR0NfS2FNP0t2SV9GQkRmeGx0UmJVQ0xRXT01Y2UoKDMqLi43PDdITlOBkoCFhmtVRkdiXUs7OD5BOj9TPTguICsmOSwvKzk2LENAQ1pXXV5ZZ310caupuG++4/WwelSQfZloa8ys5IuNjYuDjo2IkbbDt7Ovr5f437+0jKldg3N9lubY0Nr/4829wvKUnKiNnbhgX3qCcV+Hh4eGeXNtX2RueXpcTUFSP0FHPIBdZnOaq4aRbHCljGS0oW9rV1pzbk5oeUZHXjZHPTpMQXxwQm9UOG1kc0o4SZSXa1qHTUt/cm9wdFiGd3FolpqKkWuRd3JxeHRvn1teZI2jYGSxY5BTTVY+UV95m4uRr5SPVzpCg1Sdj1s5QGBbV6ychptia2teX26HYHSSm2NoXYB+eGV8UotefZuim6Gloaenr62spZOIivj49/f48PPy7vH59fDy8/qAhJGXlJ1QmJyQi5afk6GgoIuOjJGFh4rppHR2l2RWooWGepmpjMiNj8eF4alnXaGFa2aLmoyAjqldsGa5f39zeUKAikQ5N0JCS0aQVmBycUxhjXpgomVkTIBvq61lUkh/ZJuQmESHfoxHL3Xi5unr7PPz6+/z977r0vj0lrb/goSKh4iLjY2PkIqIio6PlJSSlJWYmpmZmpqgo6OmpaSnqaaqraytrbCzsK2wrqutsayurq6xsrSzuLu6383f69yB/ebldzVmWDBGQXI6NDlLX6hgmPupsYaBp4Dg2J+dtcyBW01OOkODh8q4qJ9ZoY14alhMT9x0urNUboJWWJv8vbuwmXBxSIS1ymZzdHHTcrGbmXJrop5+rIKbnpycl52bl5iilJGQjIyLjYWGiYOEiYWIiYiBgYH+gYH69+7u9O3i597f3sinm2pbnaxuZmKjrGA+PWxhjKOic4BSYypaTFFlTUEyMCkrKzM2PjRUOTJaMTFQall7TkFKNUlURVd0V3Gni+Ti+/SDa0xNZ4VwYmB/cMfysLbAn5+msK1hZc2t9teUxqD94buq16mB1v/hg5qHzfCUqrjCcH6Nl0+MXD46douDcXKeoZ+bmJialJ6alY+VmqGMjIiCgYCIjpOCgoyIgnl/gYV9g32LdYR73HV2eXBxdol2fnN233p5dn103HuQlX5MKlFLSElDQChMbkqCdnqCS1KOg3h3d0gyRl2Vg41MMWUtSDtHSUhyOF09Pj9TQk4xKysyNUA9ODZPP0ZKTVk/PkJFPXlscEhnU2RfNzZRWDo6PUdHWAR8fX19hXwDfXx9i3wKfX19fn19fHx9fYp8hX0YfHx8fn59fHx8e3t7fHx7e3t8fHx7e3x9kHwGfX1+fX18hH2LfgV9fX18fIp9in6QfQF8iH2KfgR9fX1+hH0Kent6eXp7e3x9fZB+hX2FfIt9hn6SfwF+h32GfAh+f357e319fIl7BHx8fH2FfBN7e3x7e3x7e3t8fHt6ent7ent7hXoBe4h6AXuIeoh7AXyIe4Z6DXt7e3p8enp7fX17e3uEeo97BXx8e3x7kXyQe4Z8AX2RfIV7BXx8e3t7hHwQe3x8e3x7e3t8e3t7fHx8e4R8B3t8e3t7fHuEfAF9hHwBfYd8C3t8fH19fHx8e3x9h3wHfXx8fH19fZN8wX0BfoV9Bnx8fX19fIV9CHx9fXx9fXx8j30BfIt9A3x9fId9g3yIfYR+A319fIR9hHyffQN8fX2VfAV7e3x9fYh8AX2FfIp9Bnx9fXx9fYd8AX2FfAR9fH19hHyFfQR8fH19hXwCe3yFfQd+fn19fHx9iXwMe3t7fHx8e3t8e3p6hHsFfHt8fX2sfAF7i3wBe4V8AXuEfAJ9fod9A3x8fYR8gn2FfIJ9hXwEfX18fYZ8AX2FfIt9h3yEfQd8fHx9fH18hX0Gfn59fHt7AgIEAIDgiaGMzoCHwuDIkZaPrNfb/ta3juWziaScnuKGy4KwiNvp1J2mppSQnLrourHDlcSc4tTHw8z2kaL+t8CIiqxyj6zPmpWvtZ+3gcx1w8WCwdO1lbHjyKC0s9rS2Pbz84Dzh5GW4sGVso+B5N2Hz8ush62Nnbift7Le5L238MHe2ICFpJzs0JrAv4+rvbfq9dTRrZmD8O6AobuHtc+Ms8D4i7W8g6SIuYXl14p9g9Ddd7uUzLmK1qeX38OLurvMdGdpbWdzf4KZmZKGgH2/r7KxwcvCzIFjg6unko6lsXBgpLLFbHeAdnp4g4a+9+yQus/HvcTIva+qqrHJgpSNn4yLn4Cm+qGE+vuipqDcsZ3rka6heMXNnYmF4sz8n7mhppDHq3KwenOKiIB2vnqqlonQhtSUZnTOra2irKGhk2TTm6TO1NuzrnzkjHKY58qOfZ6ghcLwrpDngJ+R+7jh0oiehbDRl8f0gYS0kcCJ+b/Ci+iEntP5o+2Geql2nY2eppLI4YDlnGhuZGV8cYB9WmabcGxdXmBkT5K7jW5taHFrZGhrZ3KYfY6tcpuKbnOZgqa4xXGKf5J7gZKFkoxYYWBTUUKjpbOdrLiull6xfYOOe3CCp1WVs6adrGlwf6xoa2R6Zmd+iKF8YtG2enizm5up2ZmZrHm+cWuYgIaDjMq0jITPk4CSjsahcdS6pKV+pcGerryunJaGcm1ma3J1aWNndnhwo3JhYGlrcz09PTk/P0FDSkpNSUZCRklMTUtIS0tWTUVKU0tSV19lXl9gYFxhYm1sX2JmbmheXFpQTVBRV2JVYGRma2mDSXyafneB03m5g9G8yKPdnoKZjop/h7rRc517hoCNfICsZKHAdJiXiYaHiZOVv9C6q8WrxZmRlnx/aW5ta7tweIOqtoKQifDou7r0mqWcisCUb2PLvaS2qLB/jnLNxHKFgpF8joZ6dEpbVGBcYG5yV0JXS0RWU3OCgWestGadssGwcIvIhpNpZq2/sn9udKmqgH97bq/LmbaEtHuQeICCfYjgxdOvgbGmgoSXmKXEne2yrqGJhbnR2q2frt/Wi9PGo6HEm5DQu6CGw6aByMyTxtaZlY3dkpCcjmmayqawz7CT/tS7alasp46Iz1+BdUpRXFxMaWh+XmdSVaGOzXJ6qaexv5vwhtO8obP31PqC1rO8l6WphpGZgcOJrJ+OuoCtpLmPebOlqKOvnMzOrKPLtMOkrYGml4Zul4XOcrSQm5SIloK2qoe4gYppdMN5ho23lLGJjcV+wcB6yd57ko3dlbKajdDqvoqUlI+fqd7zgI2jp8XHxvCJlZvO6v3S7OeQ1oKBianp3by+sJODsdiD9cu1jY2swtXJy+3bm86FzICaWFZVj2Zklba2fHBofr3O6dC6le/Fi6KNnsyCv3OmhdzW4qeyqKSlt9f9y8nRiLyg+fGfc2KHdZj8v9yUjr2Aja7ffG29p5G7jdeF0diUzeizgqj16JeZipWQj7KysGC0Y2tupo1tgGVXopxkkYp0YW5ZYHJmd3ORkIF/u5Okn4Bme3eul3aZjXJ9jIWnrp+ZfoNtvsBdhqSBsr6Cwbboa4uKZ3pqqXHHuYqJj83UfcuexrWL2Lui79SZyMvggXR2eHR/iI6mqaWZkY/byczE0t/Z4pZ2nMrErae+zHxuv8nadoSNgoN+iY6417xrkKWkn6Cjmo6Jio6haX1/iHlndYCb/qOD9fGAgJPst6P0k7+xk96qa21017vlocmoe2Ozpo3NgYKil5KC1Jffw738oPOziJP40Ni+w9PWvoLlqL749PrQwpL4rYep//KxqM7FkJXLjHO2Vm1Qt4iW0JedhLrRaYH+iGmQaYVu99XVfcdigZOnfd2TiLKBtbfH5L/CyIDuwpKeiYChpra1ipvXm5CGg4iLddr/0LK0rLKvp6upqLThwrHItOfQlaDIqcrj9Yuvl62UqLKlr699iIh7dWnz6fXY4/T1z4HWoKy2nYacyn3N+PDr74uOmuyHjYSUiYKors2jgfjgnZXLtrDF+7K4x4rYg4SxnqCZnNm8i4PSooCjkdGtgP3bts6bxd+ty9zMsqi3q6SgqLO0pJuftLaOwaVzh6WqtF9eX1pgYmVncXBybWtla25yc3Jrb3KAcmlud255fYeMg4SGh4KIipaWh4qMlJCIg4F2cnZ5fYl5houOkY+zYrHIm6Gp/Ym+geG7t6DjmIKfoJqFdsjqjbiYsYC6o5e6frbAh6SdkpOKjqq51sTGtcSqxJugmoiKfI6LfdWFjJm0xYOdnfbkxsb8r8C9rvvDm4H4w7HLuMWTwZj/54Wqqbmjsqufl21+d4OAhI2ReGJ4a2R1cIqSjoHc6IXX6vPihpnxvMufn+bk25maqdbCmZiMgNv5rbudxIaahICNg47q0eW8iLaxio6goafEovm/u6OOjMni6Luwv+zjjODNr6nHkZPTu6+R0KyAu7mIu8SSj4nkk52snnqjtZGTq5R937W+dGKvvJeE0G2gj19odHRhg4OjdoBqbcCm6omg7uHl3J74i9nGr7Te29RrxL7Lqba6nquultOhwbimy4DGpb6di7q0tbPFrtneuJy9xtK2vpe4ppiCq5j1iOmtuaqgtZzSyKLRma6AiuqRm6e+sc+kqfKd1deV2+aOsKvjl7GUi8fWuImljY+jm9DsfYWRmLjIsvaHipfb/PK97/OX3YCGg7Xs1ayyqZWHmLNkzrKsc26eyOPDkH6PTlU7iIByQDA3dGBLeqGMVEM+R2ZqblRPQl1JRHA0LUAwYEpKMktXXD4/RDkuOD1ROUFKRmtRd3tbPitJQ1ptXVpDPlBEU1paNjU7NjRENoczUVdRhXZpV2iQc1daU1tYVX1/eEKCREZIb1xETzMnPlhBT0A6NCwxKzsvNTo9Pz5EfmdxbYBLXFl/akxxTDo3O0tKRDk/MCImVkAfLjQsMzgrJjddTWZUNU9OmWCqnoubpsvGh/G2iYhqqXtz2t6m19/zi4KGhoKJkJq0ubuxqKH339/U4b1qdneJvfLpzMje64mA3eH4g5GckI2Gl528v5hVeo6Rj4eHgHZycHN+R1VqZkMvN4B9+aCC7+JsYHizg3S2c5VsU39jOUJFdnKBRVBAOi1NTURhQTxTPkAzWC9EVnNoPGJWSleLfIRxeXR9bkiOa3KHi6OJdlWYUFFup45gWltbSnqqe16EPU0zdGx2om1qYH6MRUGnW01lT1xGtJSYW4pEYmlvSoBTTW1Fa2x+dWVtboCJi1loWUJLUXSDgICWn5+cmJWPgff78+zr6e3r5ufm5uz162x16P70iYiViZSZmlKTiY6UkZeQkZCGlJWJgYP1l4uYbYDBeVOSb5OooY6IrJDW5b3Iu4aEZaCMmYeLdWOfpbiOUq1zS1pjbFJkgUpDWShlSjpPUU1qZ6h0Xm+ZVYBohJp9MYdqcmxyyZ1fmahnLlza5+bl6/Ly6OTq+Peq0uGGvPL5/4OCg4CEhoiLjY+OjI2KjY+Rk5OTlpeblpWYnpqgoqGhoaKjpKOlp6yqpaeqrK2tqquop6eoqq6qr7KztrXJgubdidTQtDwtLFc6OkWBNDlCRXpgNnmfa3yV1YDOyLDem61PfVxcXF1cV6nb0liLeYBcWj5tRmJBicW9hmSGk5K/z1KPm59tY0WFZmpoZb+yqY/ze36kgploz5bt1HSdnpyZmJqYl4qPjI6PkZKRjISJhYGFgXdjVXjw/n7s8/bzdlbH5efY2J5uamekwZdnXGVeUpOgWmJRe0w9OoAyMipWT11UMDo9LC8tMD1ENmRPSj0yNUpfZ09ST1JSS0hdSk5bdWaVs8Oo+7p/i2xUg3pcT1Wwf7TCwqDApoCBlYRwzaXijYG576d+3Iffv4OOm56ItLTjoKeTlPmkx3V6qo+ekEFsU3VvZXunwJxLlZmWjpOUjI2PhZmHjI6ImYCTjpGHe5KOi4mNibCykH6Xq6iKj3yFdnBrfHnTctWEh4V9gnuPjYORVT8rLUotOzQ3OkZOaks/hIFJkJtRTkeHT15JPm6BbklJMzMyOmdoMjlNSHBdWUonNThWSUNXUVAzWygqQUJWblZbPjlGZ3xIgXRjUVNRN0BGX05eJiIcWQ58fX19fH19fHt7fH19fYp8hH0HfHx8fXx8e4h8EX19fH18fHt7fH5+fX18e3t7h3wDfX18hH0NfH18fHx7e3x9fHt7fIV9B3x8fH18fX2HfgN9fX6QfQl+fn5/f39+fn6NfQV7fH18fId9hn4CfX6HfQt+fX16enp5enp7fIR9jn6FfQR8e3t8iH0Ffn59fX2Lfo5/g36EfQh8fHx7e35/foR8DH18e3t6e3x8fHt7e4R8CH18fHx7fHx7hHwGfXx8e3t8hHuIegR7ent7hXoHe3p7e3p6e4V8BXt7fHx6hnsKenp6e3p6e3t6e4V8BXp6ent6hXsFent7e3yIe5N8j3sFfHx7e3uHfAF9j3yIe4p8hXsEfHx7e4t8gnuKfAN9fH2IfAJ9foV8gn2EfAl9fHx9fHx8fX2UfL59D359fX59fXx9fX18fX19fId9BHx8fXyFfQF8nH0GfH19fXx8iH2EfoR9iHwDfXx8nH0DfHx9hHyCfZF8gnuEfIZ9hHyKfQZ8fHx9fX2IfAF9hXyCfYR8Ant8iX0IfH18fHx7e3yFfQt8fXx9fX18fX59fYx7BXx8enp6hnsDfXx9h3wBfZ58An1+i3wDe3x7inwEfX1+foZ9Dnx8fH19fHx9fHx9fX18hH2DfIZ9BHx8fX2GfIN9hnwEfXx9fYZ8CX19fXx8fXx8fIh9BXx8fX17AgIEAICF36jC/9D77KL0kqu/4JyMg/fQ96aSe53osaehpe2w3OeJuJ/Aivt224uqlY2u+dKS1qOVyJeF29S8/6XHf4Ga0I+UhaPTrKKEkn+GlZt6opjIuZqtnoylwtWSt56M+/j6k8LE29aXoqjKytmK8qnuzOq5trq90ZbNwLPitsWBgIDR49fewa+Q2KOZz9KGi+XDjqKd5eTym/asxcWWu/qXpPaarfOek8SEhMRueI+opGp34pGI0NbIgsuirqS7yLy8k8F0fnJ8i42RgHxwvbqtm6K4w3eQiJmapI6XuWt61cCwv9VqhpKDdGhphLjkr93Qy763wdDFwLmdpKeE7sfZlYCZ8OPM3Ma174XV0qSA86CVjpGDh/aotJrQirHdi+fojMPPyaZ5uX99s3iDacFuzb+Ng3vOrnKmiYirkaxoipfKjHp+3WVvfnSUvHF0jZelt5+Cgd3z2JG9k7n2kpfOj8WK55LlxcqhzL3CzseQwtb75bTLqsF3jI3hp4uIjqqqoIChZqWunGZbn2J2ZGaCkWxreFSFlIuvdGtqbG9oZGRkY5+auqrkiYaf2HN7smyfwNjGrKqdn3Boe3pXT2tQVp2mkI6Kip6lw3NqaGJ9cKGHakmhelpaVVCRiqNdn1l+u7y0b3l0Zqu7vHXGzpLBr7CL1peysYzKj5nirMXG0fB8ooB+sNuOg+Gk3rSddqtzhZnFn3yxanVqdXZ5fHV1c2lweLRfYWJ0PnB0P3E8PkJBPDtAQEU/RUFBRUZHQkNKTklJTlJPU1BUTVFPVVRYVVtdVFRUbIaIY2diWVhJTWFTVltgX1yEo6B9gY2avneXh/SxgqLIjoaCxqiIqIT1yM2Wh4CBhpOKzpmpl32Ch4e/o6XdiMj1jrmZod67lujLnLm6fXV5v+eQhbygyO7ztem+jpaCzHlzY2Vxt5CzuH+Yu7exwYR8eHVubnBsbFdgWVJRUWBZTUhPTU+Xo42Ve3mEcaSxtK51oYR+mJl1cbq7d2x9gqGLaHGNxKN0cKGYr+CDh4CHgr6MhrF7l47t5NKSqrSzub6UxoulgbKi6bCokMy+k37zw5ScvIGRiGvHZYqZwOu6jKqqgH/b5daqjnV3lYmUi4epluW+o2qfh8GJgWhzZFtYZFqEgJByhFqGV56FsHvnotSGn6qh16Te4uymxda0n7HFfZ2mo3CkmqqlvKKNrICEk5DIk5HU4JHn5JDn58uK18jEgoGOer2kk65pcaeXm4msqK3YrnC4dLJtm62WlrKYfbKK8Nfd3XONw8xvub6gpZt3f4OYmfF5x5+3hfD+lfqg6ZO2iam5h/nE04/ds4nP8pT2i/K9i/KTiPXP8qnEzM3m+7KWlrLMsNP55uGa3IBao2J4moajq3Wwe42fvHFqcOLI6KmdiJfbopCZovSavcmHwKDAi/mA9416n5uqxad/4KCPh2Nak4l/xrDjipCoyoKWeYymr6F+jYqVnWGIronJrHqWi3R8n6NuinhmuLm3c5SQoZtua3OJgJdfpHmSiI12bXeBfGaCf3yngotgYYChrqWokoFqn350kpdcXJ6Nb357tsG6j/amyqGXwPOEfrluk8l+jLuCfcl3hJmxsnWA6pGE9f3eitqru7TK2c3PodR+iXyJmJiejo6B3dbFr7fX6Y2pobKyv6Wy1HR/59fD0+h2kp6TgHV1jba+haynpqCboquhnJN9g4pyz6q8k4Cf+erQ38WozoTf37WD+bCsnZl9fsJ6iYzPj8j1WfL9nvf/3r6V44yK0pCZgPKD+N+flZLhuZLFqLLOsPWOnLHunYeA/4+Qj5GqxoyGmIrZ4qxjb7zfyVFZYI2biY3Pi8ZzhWX0uY54ocTIxbZyiY6bm43fx+GLn6vmt6WdrNvDu4DSjPfn24aS/Z2so5S9xZKTnXrM2szvuqusrq+opqSios+z17f6y9Lj/YiM04PM4v3wxcixypWIm5x7dpJ2f/H01tjMy+3n/ZaTi4ilocqekm7mooF/gHXPtNN72XiP8/7piqCcid3q8JHo5afawMug8qPX0aTmqbTswtrW4vWAtICMud6akPe29N3GjMyMmqnjyI7wpLOjtLW6vLGwrJ+bjNKPmJu0Xq6zYa5cX2RjX19iZGphZ2JjaGpsZGhwc25udHV0eHV4cXNyeXh8en+EfHp4lbKziI2IfnxvcoZ7fX+FhIGx1NCjoLK93pCfg/i1lKXRk46H3cN6o4DjwfC+sICprq9/7aSvsImJl5W7qrDkf67qhLOWnuWylvXirMfHk4GFv/eViLyiz/npwOrMo6iY+qCdi4yR0abS0ZGv3+LJ5aehoJ2VkZSQkXuDe3N1dH56amdta2zP152ihouSh9zl4+GFrI2NyMmqqtrhkoeZq8Ohhoqh1KyCgLSuvfaRj4CRhsSNhreCopj/+OSXsbO4v9Km2JWsisWw+sO8otzHlYPzypmdt32XkXXTb5KeudWwiKGkgoLM3Oa5n4SGiHyBe3SXgsTCq3qsjc2MhHmSfG5uf3KrpLaOqmyxbrqVxov9ruePjaKezpnb3t+olZuJhq/Mia60sYK7tcO3zbehr4CSqZ/OopLV3pvWxHjIw7F1xLevfI2Sgs62rcqCjL+ssKHMys76wozUidWCvsS4wtWxltGY9ub48Y+2yMqB4ebBwbOKjn+LjfKGxpmvhe7ug+qd0oWmf7Ovgu7G55bQnoHE9Yzcf+iyh+KEec+833+1s8DRzIKTqsXXra93XX11r4A6czxMZ1pyd1h8WF1kbD4+PWRJhEdEO2dPODFLU4JTXFU0RzVDPGYyXjoxMTZLZllAWE1UTD4yYltOaTpnQkpfXTowLS1DOTMvKy0rMC1FZ1pyZ1BeWUxTZW1JXFNHgoSEU19da2Y7PEE5LVA4W0VCNEExNzJCLTk/PUFxVVpERoB3gHp7a1tENzhHS0gtMDwyLSUoP1BNMUYsNUEvL0BDXIRGRn1iirWEeNOAlKTAx4aVrWpsk4iiiue1xr3M4+HapduEjoCVpaaroKSW/O/dxaGEzaLEv9PO3cDU8oKI/O/T5fyEpbCoj4WBmq+eaIiLkZCOkZWKgHVkaHFgto+Qj4Cm/vjb58SUsoDJt4VlqW1jZl9UVXJNWFt5S1tjJVFaPXBlbVg4VDcySyUwMHM4YFxSU1GIdERQQVd8a4JKaXaJYExYnE1OT1ZXfkpDQz9UXmlNW5yumjYwRnV2Z1yJa4dUSDqdiWRZcYSHi4JWZ1lnZl2YiIRPXmGSc1xaWoV/c4CDToJ9ckVJflBjXVh8l5OXkIXx8erz6OXl5unk4uLh4Ox5goBt4fHygkpCi0KEnKGcmJiUkImGi4qDiJWFgNKsiop2VIt0iF16bJGim8OcnIf7oX2GmIWoh5qM9Yd9vp6raqmpdXuTiDUydHpeU3ZHWElsXE9hWUxDUX5kkaNIXoBTpNdiRZeBmbbMeIxZVDeXuFPU4urk7vH09u/x7+jMlfXP5un7gPr8gvuCg4WFg4OFhoqHiYiHjI2QjZCUlJOWmZiam5ialpWXm5ycnKCgnZ2cn6OrpKmpp6ehpKyrq6uurazB4OCWjK9rj3dFLV00MDmOSkNHSD46NDeHecrKxYDFyMd053NIkV9FgZmLdXbYcXOUNE9JQ21ATGe1q9O3hkyQauCFbF5oYphxb19KXWRiu62tp6WIno7Ft2Z/treJuJWYmZKMkJKQj4yPjIeJiYqIhIKDgYD39V9KSm5ice3l5e1rXUhj3tzU0ItlVl16m2tXU1poa11NSFVQYHIuNYAvL1E2MTc3OjplWFEsMzNCPFdMVzUwLT9Je0RjR05LUy9lbIeLo26GnoPwgKaqgYFQQUloOTmgs5aWwa6thmx2cWqQdLDVyKPOnumMh5bKqI6Tq5vy5P3B8I74lNtTVUltW6t+cEVOk1JtjoxWY2JjZYeagIePkX2Pj5eNj46HlICGjIefinOjr3qnomWonZhgs6aYcIVsUnNxe4Vyc4iEhICSko2SineLTUMhPkE+P0g2LlAuPjtzfztHe4JJSUo9N0E2MztNVJZBYkdWN3ZxQ2sxUlFbMSs1K2ZZVCpiUlNzcUVqRIRtXpNVRIWEjVuRj4GInls2KS1IQ2A4JE08VAl9e3x8e3x9fH2FfAZ9fX18fHuFfBR9fXx8e3x8fH18fXx8e3x7fH19fYR8EHt8fH19fXx9fXx8fH19fHyNfRV8fH18fX59fX5+fX1+fX19fHx8fX2GfgR9fX1+j30Efn5/f4d+hX2CfoV9BXx8fH18hn0Hfn5+f35+foR9AXyFfQp+fXp7e3p6enx8iX2KfoR9A3x7e4l9gn6FfYp+j38Ffn59fX2FfAd9fX18fHx9hXsOfHx7fHx7ent7e318fHyEewp8fH19fH19fXt8hXsbenp7e3x7enp7fHt7ent7e3p7e3t8e3p8fX19hXwDe3p6hXsNenp6e3p7e3x6e3x8e4R6hnuDeox7B3x7e3t8fHuKfI97hHwIe3t7fH19fH2RfIl7hnwFe3x8fHuFfAp7e3t8e3x8e3t7hHyDe4l8AX2KfIN9hHyCfYV8CH18fX19fHx9jnwBe4R8BX18fH18wH0JfH19fXx9fX18iH2DfIV9gnyLfQx+fX1+fX19fH19fHyHfYJ8iX2DfoZ9inyWfYJ8hn2EfIR9l3yEfQF8hn2DfIV9Bnx8fH19fYh8BH19fHyEfQd8fHx7fHx8in0GfHx8e3t8hH0DfH19hHwFfXx9fXyGe4N6hHsCfHuFfAN7fHyEfZx8hX0Gfn9+fn5/hH6DfZF8FH19fn19fXx8fX18fX19fHx9fXx8i30OfH18fHx9fHx9fH18fXyEfQt8fHx9fHx8e3t8e4R8B3t8fXx7e32FfIZ9Bnx8e3p8fAICBACA6uTr5u6l2+70/+CG6NPF9pLcrJfR6oql5LKjsrPK6dbcgIKU3JHA86fnxYvX4Im0k6ycmr3Jwqv14LWghfzF0ZXQu6rpw/bpoLHppKiipojErqiKltHvwpCmkpWK8vCHl6HJ0dPWiZSn4+WPooef1Nzfr6GFoIm0kqzZkp6rvMeAwYqhtvSJ1dvj99uv9fGTsOOThoOf/bzNw8vh1KX7oKmztPSE87ehfOP65G5sf6FuntGnfXOO0ui6gJijpK6YppPDdHZ32nqFgoR1em3Bs36h2sGLk4SUipqUlZWXo7Cur7KlkqJ9jYJ8gXl9soKwuLCzs4WFrpn++OCTus+44aOA08qimp6cpLyQhLfKxXS3naiV6smwocaglKKv/pfYk+2ijbPOrLF316R4an3TsZ56iod2dcCtt4ayYn9VcJ1zi7zNbaKOlIORc7V3ktfzbXGU7tvX09Ch1eHwjtWakYyFu72nkoPnrK6e0ZX6iPzTjOqx+Xzt09ugnpyiqauahImAgX+PcIeTjaZbWJtrmI2AWEyBa3t/k2FhjGxxYl5jZGCCrtKhgYyHk7GhdpNvo72CerN9etW9qNaNUmRnmVaSjZCFeIeOk7WdVaCeTlNOkMpBRmlRVkWKeI6wtbZTxW6/aIqJeKWMYryRgLux1KV5m2/a1r2Nd7Gup3zyx4OKhoaAhp7ZmK573KbDqHXImriap3OEcHNoZW1tbHdub3VnYqtpamdmbXZtb3Nvb3dDPjt1Pzk9O0JARUJGSUhJT0RPS0lISEhDTVJZSk9NT0dJS0pWS1RYYlRYXFRUSktWWF9uaWlfe6GvbaeLk5luifOGj8h+xoGN7p6TftrB0q+TioCAen14jna5pK+Hh9vle8N0foDYgpjDmo+5rtbtm77z/afP8ar87uebg5i15afBm6/KdHFkY2RqY6Grf51+fXvZispiaWxiSF9ub1hZXMZSSUtNRnuFjpuPw46PiH+SkX7AiXl4g4OjkYyX1bq0l4toanLCenKOfG24k9e8kaqB3NWAxMeIxKK7itzAzu3Gp+SqtKvArp7Jv4e1hbGstLWprZG6xbDlvIDIlcSipaaq1KiUtJ3r3Pjujp7WfnRnfYXFpOerpOnQlXBib7WPY2+nZIeJXmFuSVxzd4Z7kYnY9bCU0pG3+pGNjLPyzLqUgoL0toiqe3aJjo19rLmohY2MjaCAoau9rarC39TO1JKGlY2Ii9SJ1Ibwid20y41zcol/mYqwkIh3poyNiNKco6+NjZNzpZWdhqGmn6GltOCErbSwvKOx3d6phoiSnvGeosiB9efWxKmFi73nhry4e4mh++Szk5+sqJGxsZymyq+h6sbDjvf44MWPjpnIpOa7sbnlnOCAr7u7uLpvfZ+XqaJapKentG+/p4/Z+ZGT4K+Vrqu6y7O3d3iHs5etybTEo4zVxYG9cnd5kJmAeWydhGdjhPfTvIm+qJXlz/Duk7LrnJl0m5PPs5ZtdLHNspCQbW9osK9gbHaWmJqdZG54lpZgZ19wio6Pbm5YaF56X3CWYWx4jJSAkWZ3hLFhoqOisZyBqKtldJluY2Z/uYu8t6qj17Lsgo2eoPtwxKqgf+jz6nl3irF4q9e1i4Sf4/PChqGtrbegsJ/SfYCB7YmUkpGDiX7ezIuo4tagqZeso62sqqitu8jExMSynq+EmJONkIiKqW+NlJCUmHl7k4Dg5dN+lKKUu5yAzsijlpqUm62Ki9rq0oLRrKiV8L7KnodcWIGz2XHvkvuwlKzi4NyD8cCNhpz23cWamKOKiu/f8K/ribuFn7qEq9XqhM7Gzp24l+iSwPDvhYaw9sW6urRNeKChW7WFiYVjbJqJd2TOtrGXuXSUaaaeftal+4P4zOCzrqeqsMfBocGAu7Lelriyu+aKluSR1rqnfXXLq7m+3IuH0621oJ2koJ2Yy/TFlJ3Gtte1hqaCz+iRiNeLh/HWyPqyd4yL5IXf2tXKs9Lc1f3ogOvxd4F3sfRmaI14fmzKssLa6uR24Yv1hqu0oenAgfW2l9XK9bqIs4D59+SkjdLUwJP/1ImSh4iAl5/bna2J5bPnyYftv9ikuouupq6in6mmqLKlpq6ZddOdpqKgqrOpq7SvrrpmYVu4YVpeXGNgZ2JobGtsdGdzb21ta2lmcHd9a29ucmtqbG99cHd8h3h6fnZ2bXF6fIWUjo2CpMjPg8WqtrWKovSIpf2N4JWW9LGogOXLzq21sKSAnaKLgZTGopmOk/bog9mAhXm9c4a2joarq8r7nr3q7qvIz4nv/POgf5WszbPMp7zSlZaJio6UjM7SlqiOiYX0mvGMjpCKb4SSknx7evtyaGttaLvCxdbH7ZyYjYeam4nql4mJj4ypmZmi/+jRr6OIlqvqlYqonofnpebUpLWL7eSA19KHvaK9k+zT4f7Zpt6st7DNvbHZyI7Gl8G9xMS1uJLHy737vIfVl9KztrO016iSrZ3o2v/xi5rgi4R3joWymNGVjcG9lXVtdsKncX3HfKiseHuIXXaTl6ueuqLm+MeO3ZKc0m5zhqTjwraGf2/HooKzjoueo5mQu8K5mJ6am66AsrLGsoeXwrbKqHRsdXJxb9J7rHrjhsSq28aFi52dwaXJoZyWyLGrnfayrsujo7OJxrW0kbCqqa/G2vyV0t3Z4qu0+OajgYWcnPeYl3Z05dDVu4l+iq/lgbuyg4WM18Sae4GWj4aRmIiWoZqN2quPctHO1K5wdZegs+SPW1yfgrCAn6WvqKlYTHNmdIFBcmVlYTxaTk1YcUNKWTdETGh7lHJVNT4vSjpDUD1TUDdVXUFRODc8UVZPSzpeRzc0MWBOYzBHQjxFQ1NOOD9RMDEzQ0VoVVdESmp+aFBXRUtIfXlBSE5nZGZoQUVHVU01PjI/OTU6OUAzMzhBNy0xKzlHYWWAZUlSW30+XFZYa1ZTYWI0PlhENDlLa0VFQVBHUSxCQ0ZZSFRHoaWig+ri8oWEmsyJyMR5WUlZpObEi6Ourbigr6DXgIOC+pahoJ+TnJP+45ypyum3w63LwcfJv7zF2ePZ2dS7qsSRqqmgoZeZpmR1fXuCiHZ5gnHN3c5ud35zlIyAw8ionZqJjqR+bIKQlFqKaHBon3ZrW0wtK0hXbS5WM1hCOFFWSU40U0EmJi9TT19PXFhMTGlUSkdkRFg5SWRWd458SnJga01gTXJETmhrND9jsKqeoI4xR3l7QXRbZGVEPmhlX0mMiX5vjVVqTm9oVJd0t1mifpR0c3BzdHJ1YGaAcF13WGVjcX9IWoVRgIqOgoD14OPl73qA7OPo3dvg3dpuaFxeK0fbdW84OUA5dIBLSI5RU5+Zl6COgIuM/2aPdW15UmuOaYaaadnpi4+LsvKHhZ2Rko3OmJKy6e+NvlrRgZeup7tzX65cSlFzd11DPR1sSF9cQENJTFDDlj1GOj6AXYCxcTNJxLWSkUGlu4c3U13O3t/g4Ofm5+3o6u7ah/bZ6urp9frz9Pz7/P+DgYD+g4CDgYSEh4iKjI6PlI2RlJOTk5GPkpOUkZSVl5SVlpaalpaYnZ2gpKGinqSpq7a/ubmltsS6SnVXPVxSOI47L1g5ezc/eT1EToOppnC8vsCAvbujfalfJyY1Y65gPoRRXWaVYDp/bkBMPGBVXZKfjGR0rXTIxY5HSURTXlduX4aDpaqkpKannNLBeHpgWVenc+mQlI+Gg4mLiYWEge6FgoKCgPj6+/733VhCNzdCNT3MVU1mXkE6P1tdmqVpZndtorFnU1FiYVKWWmpeUmAwU1iAUVU2QDhEOF9aYWxbNEE0OjVOWFVWPzVbQmtXeEY+YmBUaVnwvY3dk93N0MvBtFo+V1GMdmJpWVN9e6mcr4qhkMCEgauspY+Mg9fiiI7+qODtp6a5gqDO1Ovi/o9xa1U7W0xUkUxFS2NoWGZXYVGAeW+5qoZ/iIl9kJWUhH6CgY2AjI6Xk2ZwqZ3IhVpWW1xdWc5vinDaiqqa2MJ5eoJZTlOIgntMS0NHRYc6KzouNEAvOzRINTRHQTtBOXo9UUY/NC00U1A4PD1FO3I0MisrYGVRQkA3Kz1hNVZgS1VZpH1jVVxtcG9nbV1pcXdiiHFqVaSTlI5ORDA9Plk5KjF3W5mFewF8hH0CfH2EfAF9hHwPe3x8fH19fHx8e3x8fX19h3wKfXx8fHt8fX18fIV9C35+fn19fH19fXx8hH0FfHx9fX2EfAN9fn6FfQh+fX18fH19fYd+BX19fn5+jX2JfgJ9foh9gn6GfQF+hH0DfH19hH4JfX9+fX19fHx8hH0Cfn2FewN6e3yJfQR+fn59h34GfX19fHt8kn2Ifop/g36EfwJ+fYp8BHt7fHyEew16e3t7fH5+fHt7fXx9h3wIfXx8fX19fHyHewh8fH18fHt8fIV7CHx7e3t8fHx7hHwQfX18e3t7enp7e3p7fHp6eoV7gnyFegt7e3x7e3t6e3p7epN7A3x8e4Z8hXuCfIh7hHwFfX17fHyEfQd8fH19fH19iHwCe3yKewh8e3t8fHx7e4Z8hnsEfHt8e4R8BXt7fHt7hXwDfXx9hHwBfYR8BXt8fX19hHyDfYR8B318fHx9fX2OfAF7jHwEfX19fLd9FXx9fXx9fXx9fXx9fH19fH19fXx8fId9BXx9fX1+hH0Ifn1+fn59fn6GfYJ8hn0Dfn18kn2HfAN7fHyLfQF8hX2GfId9AXyJfY58AXuFfAF9hHyFfYV8hX2EfIJ9iHwJfXx8fHt8fXx9hnyEfYR8B319fHx8e3uEfIR9CHx8fH18e3x8jnuEfAF9hHyEfYZ8hHuSfAZ+f35+fX6GfxN9fn5+fX5+fn17fHx8fX19fHx8hX0BfIV9BXx9fX18h30BfId9gnyFfQF8hH2EfAZ9fX18fH2FfAR7e3x8hH2HfAR7fH19hHyFfQd8fXx7ent7AgIEAIC0zJeqy9L70qTkjY2Sm5e+tMCisJHGvN+EwI+IrYXIwpSLhZK+hIKZkIiN1535svK6pNeDl5aCnKGRipzBlX+j0M/E3Lrq+ob2/tSTeoyolduann3kiImxlvTF3ev48vntoKPOt6uei5Dj/YfY7fa2qaqIqp6hibGKh4ebwunlr4DMsa+mnOXrirWMx96GjZXJsKmlrqiKg5nBgdK8x+zU6bnM1Z7K1ZSKw/+DeG11fG1nfoLZnXuVtpCzhoXf08+Nirp7d/yBiIeHf8Gyx2jEldK4x5GYcHiYnIuDdtCCjHXdfsmmjNbHcqq62Xd2gLby6YCfiebhwN7Sz+GLpMTenoCA0dztgtCM5dZ1s5WdvsmyobOZkeiHsoKyv9W4mKPtiqmApKyssumwrZSSlox7qqRxlnyhZm9uiWGKWX92iapsanNnyqamd6hwvmjAscLPnuDE38HF1K/0jOyEx3+onLjwhuuXpqbi/J3zhoSZmMS1lYiaho+djqehm42Ls5t0XYBggol/iHeEpl9nYGp9Z3xpgXRpdGtnjJumc2hcXGRhYWOFhnvQmYDl4Hrrw8OvfXOZiaaWiHXSd3R0toOfXqSelY2quJOLf4STlJZERkNKx2ZDTEVHRZujjZKptWOfboGtZ3R2oICQmoSDk4GgdreSgomZlnt9hI6mfbXDub3XrIC0tOe449XSnXm4lI9yiIuvhYVqbWNeZGlncWRrdmddY2VeX2JmbGtua2psb3F1dn1DdkJ4PXpAQEJISEpLSUlCQEA9QFNQU1NXRlRhSkBBRGVXTU9QT1pZZlpJTn6CXFFSUWZxhqKeg3p1btOypHR0poV1ooTkgNHh9Jq2fY+amoCJkZR9y7m4qtCx8oPfcoSFdoR78svYg8nR1dC34+G8tr/2g/O/y56dgKiug/CkpHudZFRUZ2xwcmuzramFgOWprGZrZZyBRWJehJ+jr4qGe3mCdHx4j3nPfcvRfOzEstqJwH2IvKqwnZyRspyyhJxuo7SfcqGPgYV2caCAnHzFzYDngrKJwZiZ6b+elKS987GLwXu9orbp46ieto6zurS4jfHJndB5pLjRwKh3aZiXpYOGm8zSlY7N8oR/ZVeedc/wsLifkqpwjJnVlWhZr2ZVTkyIlldYj4p3g1TG0eeG2H51rJayhc3Qg9fLkdzW9aXztoKMbXeJkne7qLSGi9qsq4DGqv2CqPKE77vPsa3BoouEl5mafYmalrWXWXm8fL+re6aIjsl2gaKafLiPqsPTk2qvi4xug5Khn5mlg5KzvKTCqqi0ucqa3Yyi88LPkoLS4KG2yM6onIaCzOermtOlgYa//uf2rKmTwsCqpLKO96fQt6Pnp4yGhMD73r3Op8j+loByjm5/j5GOhnauXVFXVFyVl6aSoY7gzeKCvnZ0lHm0pHeIeI2ng4Jxf3RpsnvXsvjCr8Z4YIpOXmNhXVeJfYSLyuDIz7ry5nnA5cOMgZCjhPKtpIPnopnGotCXoKexq7KtenmTgnpxZGafrFWbpqOJeXVjdG1yZXllY19shaWjfICVgoB6bqysY31hkqljZmuQfnt2f410dI+kbLWir+7J2rLCunqfvpSPz/mGgXd/iXdwh47dt46YvZO3iYXh3dyemsiEf/x9hIiQh8zB33feqd+82Ka1f4u3t6OXhuWVo4XxiNavkujXfL3P7oSDhKnW2XSJfd/du8u8w9R6iZytgoBsyNTkf86S7daNya/B39TEsLmWmvyav3BpZYRqlrTvh7KPw9TRzuTAyKa0uLSWz9OFr57JgJGTuYXCiJelwtqUk5qF8frkmNKN+YT8uL7iu+moxae2oUqid7RiwYSjkGanaK17oZnL3HanWk+Pob+rl4uRiY+kr9K7raSd0MWehYCIt9G5p5+78Zqqn6i0lb6q0LiosquVydr4s6qYl6Odm5+ln4zoq57574X/4uzMhoKpipiikoH1ioWA36roh+7o28ji/dnRvsja5OFscGpr14dkbWpwa9znzMPj44ffiqDtjpyf4L3J06ObrZG1idelnau7tpeYobC+lLnKwMLes4C5vvHQ+evYuYzap56Fm52+naGeqJuWm5+gp5qeqXp3l52Wl5qipaSqpaWorrG0t71jtWO1XrpgYGVqaWxtampmYWNgYnVzd3Z4ZneFbGJiaYt+cnR1cn17i39scKCgfnFyc4SRo769kI2Shu/YuIOOzJKCrIv1juPb9p+8gqSvuoCss6uDy8K1ruau8IHwgZGTgImB68vIgLTEwdu89M2wtbXlffy+xJGYgKCxf+Kor4y0hXZ2i5aRlIbHurWUkP3U2YSSiuHHbIV+x9fK1srGurzFtrmzybD0h9vigfvVx/WR1oaNva22o6Cey7HVmcCN2dK/lti0oJaCga2RppXX4oD0gLWRx6Ci+9ivpbXQ6rOPwoLNtMP287iww6DDzcnMj/fXqeiAuM3m1LmEc6KYpIWEl9TZlI7S94qEdmiyf7fKlaaIfaFxlZfVqntryXhoYF+oumlpr6yWpGTR3f6R+YWBqYeqf9nMfMfAh8rP9a3voYCihYqgpIi5qcKYof25roDNsPuAg7Jp5LemhYOMhHNtgIKUgoufobyseIzxjOPSlrOWotyAotC9l8SXstPWtoTHja+DlJ+sqbqxna7S2bPdr7G+r7uKyZOa4Z+kd264xJCeqL6aiHBtrNihjLSPdHie5MPLlYl8sKqOi5VosW+ZcGachXRrfK3kxXZgXZykYoBUalVYXmRQZGGSRTE+Nj94aXJVYUtkYl44OzIzXVN4bEEyNUpENjspLjIxUjBgSG9MUGNDL0YoNDc7NCo2KTE9R0w8Qzc7RyNJW0gpLkNOUGg+Sz57SktMS31fbGt1cHd7UVFfUUpEPTtgay03PUcsNj4+Qz5FPURALjEzPExrUYBnWlhUSGpiPUcxV08rOjddVFNMSz85OkBSJkA+QUNKUTlbd12AsZuZ3+2IioOOm4OAiFyrblN2tJK2h3zN1Nmqp9CFgO12foeWjdTS+4ryserA6r/Qj6Lb172qje+qtYv+juCykfrkhdjs/5CQi6XH0W18duLirLytvM1wdH2GaoBau9DaeMqb9spea15ofXhxWoRoW3ZNaUEzLD4vNkdRMT8xRERBS1hEPi8wLS80UVZDYE5cOi4wPz9cP0VEVHFUUlNPh4Z7SGJFcz56X1ptaJCMp4iHfCdfWJZKe05qbTtzUH1Ud3KatF90OzJlZoV5aWFdWWd1YnV4d2dph25fUoBYbXxpalVddU1SRlF5eubd8+Tb39yHf5rg3N3V1N3Y1tVoZD1BOGVYZjVuanB4Nj07S1VUUk+cU05OlIHDV6CsgG14j3NfXnRqv7yEiIeDvpeDjImMiLvKu5rP5pfydI7Am6iIhGpkimJrVkR6Y3dTQ0ZCRkY4T0tLUpeufYCcbYCemci0iI/IlD+PSTpFRzlESGnU2tnY3ODh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i4yiinyJdJN0c2ySf+bU2q2Ntsd26IyjiIqajYeGvsXDp7DBsKCJbniBo369r9ebcX+jmoCYu7KAl8Cji5GcftPUubKlwJ17xoF/yJCVtcyJxJKS4L6csaebpZ2nk43axIfpooF70J+23ea7xN+Wk11gYq2tqpHVqKvU2K+vZFp1W2VoaW5ZXWFwWVpqpayShHF/gHu1idGDas+3xtvM/KWYl2i5tOWIu7l3gZX2nNyOgYXW5ICKiYCFlabztc6XxqLwyae08e5mdYyIqZtnaYu/ibqgeo+psdN8o6qkf+esjYXikZf3m4xw0L6a0KPP2MekkoR7nMOMlMi5lrXy7IunnvilqPfI4sWWp+yjzYqhxOCv35yT8L7H9vP3hcmUo83OjZico5mpruWP8tCyps7J192sjIBkq8NvcZN3TGV3jJFMZnV7uNR1bZujZ4+ggqjCsJuYfm12pYnTgMSh6J7BjqXPdnu23dm6po+bimNn833cuPPb/vjL2OTsw8a7kInW/LOz5MGTd+vI/tCVmoDLuV2ea5uVs6ZlaWtncWurhnJ1eYR4b3KTfnmHh3Jqaoxsc4utfICSnJZ8fKZ2emOpZKaopmGCd36JjX/dlYuIosmVn63GbXiLmX2Hfax/neJ/fXl3kMrskZGJg4Hd2v6Sjuu5sOGettntwKap2X6HftqRnM7ApIR6jKezycXEpaahsrKgfZufvZPKrOaK1LqcurN0h4ya15B9h5SI7ebPu8TagI6YoYCReIuO6pCG5ceLz7K8z6XJnbiCi7H3tqzHqJGGp8vvid3Nr5j3x8iMmMGHn6ebi5bn5oC755Woj+P9sYnB28SN9YyIzoefs66q4sHbvcrC+pySrJXLllOsZ4q1uNKisVtebLDPe4KMd2+o2byIio6Tu4PtgfX7koGD8Ma0rdm/0IC9sb68sJWvgZ+msJWrjMHl+Zzko5+T07qxuKOWr6Kkoq/FjpeQ56K12YmOsoz1npmnuLX195rZjZ2VhsaL4NPvgt7/5+7ApNDx8/fYbmjWvIeRcWVoz9b21sjM1It14eiOpX+A7ubcgYLS0Lfdo5eZnbGQ58j9lau0w/ruubnZ44CLzJDP84fCwNv69JrtlJetn++alpaZnKWXmKGch72RkqCSmpqenpymtq64qaWwsbe+tblerru4XGBxd3R0dm1paG9gdHFgX19lXmZ3bFtaYG2KboN5bouhgI5xdoh6eGl7eqPx6ov5rbj8w8Dn6OzcuISGnOiWp66j453M4pG5gICAmY+a3aKJcXCE04Du0veO/fCRiN7Lro6JuoTB7LGLmoevjYnJ7+DX/IuIoJ+0i5KDjICEj4v68vDXm5Hd2NuAg47PzsHT0PjYwuWfpMjV0MDIrsWsrKHCiPTj67ufzN+C+JWnjpCdkIyQ2Ojsxsbi28Owio2arZjOxeyrg4+zn4CdvraIncKplJqkh+Dlu7WlxqOE14mE2pimwu2c3qir7curv7irt6+7qJ7t1o3yoIOA2qa94u/BzeKWqXJ0bK6Wk4K4npTE27TAdGuJaHN8fYFsb3SGam15n6yDj4KUlY3KmviUgfWmuMi41JiQnXvIpOWLu9KLjZTUksiampjavIB3dXBxeYbVp7l8nILAvY+Uv95vfJSNtq50epHBn8C5lJvC6e+Irb+liuPAmorloK/+prCA7t622L32/vTDpZeGoLyPlLiYeKre1HyOlN2JhdCowKRxjr58rIqbstCTvop+vaS01KzIc7WHj6aUW2NfY2BoaJV20a+ThJCHjqZeSoA/b4RKQ1lEKUxeeVYwOkhdpsVnTWdsQ1RPNT93kWhbRDg4SDxuO0s1ZjdBOUpeMEVjV2BaST1STUIzUzJON0tAUUg4OUA7NDpDOjVZfmFyWj8xO1VEZ246PTl3eTxoPFdccGg8P0A8Q0BnVjArJyQ0PEZVSklSUUY5Ql47NjxjVIBlb2dTUnBMTkBvP2BLYzdRSUlZQC87QjU4PERKOTlnRkhacF5kY554nfKLiIWAoN3/qYGBbV7LweqKhM2krfO40uDfsJGRyXB/dt6YqePRrI2EnL7T6OTkvsW70Ma2h6ulyJnPrvSS3cq108mClpeaw3VndYN75uzJqK3Dc3t7f4B0ZICJ5Yh63KBNbGNwelp/Xn9VaFyfbXOMb0c3OkteO2NMRTdhTk01NT8nMTY9LzdRZDtHUDFAOmJ9YkhbYF9BeU9LaT1SUVdSfmVuWmZtr3l4mYOWcCx3THCOZWZdgzg9TY2iWVRWRkhshohYVFljfFSKT5mhWU9RooNgam9qboBja2JnZ1BVO0RPU0FhZtbn+HHZ1dN3aWxxitTQ2NjW09XbZDUyXU5LPjcrNDdmNz86PVSUmlKMT1VSRmhAamt4RWh5Z3dp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zZCFl4Cfoq6VqcPDx9PVjpSEitpn0WfMtbWgjp535tKzwqqefpmllZSXtJSUqo+Pn+DCfabF2ZNymNCcj767yq+IkrN7hYzpppB+f9dwq6iEi4VqX3PExG63zLTXenyK5aekgOGKh3mqlnyB58XI6ryrt5F73OJ61tCqwrNxgbGXa7d3d4OQhHiNkJN9inyTv9uvkn7LtpGMeIuv3Gtya55nrKmsmNG03cm1vb6IZY6npWxiZYxRV2V43JW5zHvFb3e03qyEzK2JuZHisI7GjJffaFxtl6GVgZu3j/Cb17V33tfsgO6nkOXgi+noh5Lkm8rjm63WkIOK2fnmzIGf4N1erXWkgL2RfOKHh8vSxOGYiIDp0OjRoMKhqIrRy7+pdsatqtyC5vXnjsCWqIPX+ISYo6qfjK21p9XD/r2N3Z6FiK+IlJ7dwueuh+yY3r3M+c3Y7fPYkbSYt5WTt5eBx5CJ6KjKgJVthXeHi4i8rpdleHF0bHZWdKZ0W4F4taqwVnBsnHhuaX+OmoHA3qVzjtmTt4u6mZ2s1nrCmNaoc3R9iPT/wqK83YGUj9KirqOE79+ahtnDrLvUioGGnnzn623Ahm9uf21WgVpbZG9xZ2SrrGC+qWaXnWGDl5yShImdlpV6iF5ogGh3oH6AoaCDvGGWpmRmeI+Lh9W2r7m8o3K14ca44Np9eY+FlaKVx6jMe4aNjqqrwsbbqqeDknvc/d/IkNmjhrDa28bjscCGwLWHhO3d7NSglpKyrqTCvcPLrMjIxMK3p6OGwa2koLW2w7qtvcd1dH6UcnSGkZuZjn3d2cRwgoGKgI2D45DgvYONzru3v7ugpsm8hpGT0oW2nG+DgZaoiqWmnaebo4KA/oOQ+KTorZmKkPiBqduI+nmCjoPVvNeM3LiJk8HMipv2idqplJ3O36arc4O4mm9gk6qRdWB7c26z13x5hXFtlKPqoZOek5iyt/HYrZXm0dODh4m0i9Ouy8OogKbSyKvEotuNnJaM3YigiJ62hbaxqpzIutXlxb+Kk7rBsc6lmr/w3s7jidK9hPbgnKzAl5PojNPm5+rJ3N3D7PHO0fPkvtmt7d+ejYedjIbR3sn0lZKSmZHQzb3KfXHE2YGJcn7fxqzYho+KhM3TsbGO1sCh8aLox8ypoJSnxdyhgJeqv4OF+5vi9NLEj8KhpIyrioyPlZOXn5CVnn6inqOfrJmznaCeq7S0tbWpoauqsqiosrnCX7q1ZG5tYmdsamxwbmpsa2JZX2FcXmZqW19bXoiQfYOQlIOLfHmAjHWBioPss6mAxeuvxemhroargpvz4KzTk53szMyo3KKCnav1gKfGeuGz/Y6JgoyA78jZhZeOjI6ExfuL+PnklomS3pGGkoGvpKiOoby+ydbbkJeNlPmA/4L839a9oaiB/OHO99HLn77CtrfA6snFxKGnw/r3uNPp+cGmyPWklMrM2cOdrs2GjZD1q5KAg+qAxsGan52IgIvf64fF/svvhoGS9bWrgO2QjIOyoISK/NLS8sqvwZmD5+yA6eK90cCDlNyshOyQjpelnI2ipKSNnImeyOeukIDSwJ2Whpa24niHiL91vJ+bg7KhxrenrsWbdqK1tXZwd6liZ3WJ0Y2lxIPggofL/Myc8eO423u+mI24hprkcGl7pZuUjaS1g9ORuLuJ37XCgL19brW0a7q5aXC3h8HNhI6qgHZ80u67rnyQ6OBuuoysi+HGk/KJiNTho+yokI/32ezQw92yyaHn8NbPh+LEs9Z56/HrgZKGnHnG12l6hYiEb4Ogka2v0oZqq3dxcZZqamOEdKB+Yq1omISPml+Bd4yJYHpee29mjWtgiVZUhFOMgGJERkhFRk10gn9UZEg9OEc6UnlTOlVlgWddLj9OUTgyOEFOTEFnVjswOEY6REZQSkVLZTJaP2RDNSgpJUVWOy48RCMrKzkwO04+f4tBMEI2ND1JKiQsMSZPWDh9SUBCQzsvTjc4PkRFQEBvYidASDhSXzhMVVdUUU1hUVZQWz03gEJSb1VUampWgD9ub0JGUl1QK1dUPjs9OD9WQjMnQlNBSmBQb3h4wK3ch5SYnb2/1c32wpB6iG+03+Cvfb+ah7bh5bi1mK9+wLWEiPrx/uihoJ+7w7vf2ePmyu3r6ODWxbuV1760ssjC19XL3OOEhoydZWRweYaFgHvj17JgamlugHBqvYXXqmBLdHBubmpZY3VYO01Qc1pyZUhORUdAMkJUTU1DNys2czg+YUFgQjwxJ085T0osWTMvNzReV1o5XldLUmdrR0l3Q3NeUEtXZE1jY3angVYsSnBqUEtNTkuAZ01cVURHXWp3WGVsYGpseqOcb1uDeX1MVVBwXYNteHZogFl4fWFkTmVBRkVEZEBXVVlqTcXW02hr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x6y2kJ6q4uH+gLOE+46AnYW8t56594OMm6nw2IWCh+V7g5TDe4OcxMfwgaPE5M6H68OcrM3mwLepsarB3bOzg7Cjr5SpsbiUmefMtMLhpMijnJaVrKrC2G63eHWTubu6dnvW0cmifX22kJh7qXZzr76iuImdvpl/e6uAroCXxcSxeX7Fl8CheIGGnpOUp56A1qGFl4rotMLO4N3ZwK2C687Dv+LOp46mr5u/jMWPaWdsfoG9gczUg4SGvOTKn6j137ergHrkeu/DaYZva4iUqs+Bn+SUz9rEvl9ZkIhjg3Zpo1RbftydjbCMma3b0I6MrquohJOZ8J6R36f8mrejmnBZjoXtv2nnj6G56vKTk4yA2eWHt6KD4ZX53dt7jJaAgoqPjM7HxYGGwmCUpmSGfMeJpXbhndeDu9iifpntu7ye1uF6ltSQ3KqbhISkrIDggsOxsvXllK+4wJud/8DPleLTqaeA7unVrabQh5/2oICaoLeU9JvXtvLO/rTvx/X2hJL9jar9pfCErYyOlMqr0K+Axa/Qm3OGrbtjWF1UicGgkn26f2p1onp2Y2Vsb52SsKqATXBruo+Vy5OQcObQmpm51sqDuWp7ftF3qMTo4fD/mNXH9puDo3q1ZJbI57bL36DYi8fSipeNy/Xqy8La12CLkW+LiK+ifW5xYYy7uJClgpupV46ulKJarrSTmFWrq2aAkbBeuLOnqpFriIRqlo2JdnGEpYWrq62/oqOC8aHV5LXEZ3yFjaa41YGCeH+AjbiV+tep/pKSiPqEkMSxkn6u6ICHno6pxMXMuPedmYTNute4j7+hsNniudu7v7i8v7appszdy3Fvd35/iYyMg3153H6l0GxzgZefn47s8HlwvZyAsKq0nJqfi5T7itDTzNHq6LW7rbOyiuOkfnevlfrb7ZG7jpeU3LjAzaOcs92giILmycvIuuOAjoSjpZq+m83gwPSSwdCfiM67raCR07WfruiUmHt0aUjT8Klzan1ik3zCrGeHen2elaasqu306+iCj7GvtqKzyaX7j9voxp2n0rOAqe+mpMOkxIChhL2j9eDH66OEkuKRgYjq7JSJ24aZhuvT996O0NLi+oiJuLH4vbnTsObMzczMpJqus5e58bfW2Li/xObFqLLauMvh95L55KSHpKbR/I2F9P2p/LxvdGnTc4Jucurdzs38gK3o24aT1JSf1M+hg4isu/bHvtz4nJ1Rk6HI5erBqqmzzdW09Juhm4aIiImYj5WckaaZgIain52mpaeeorGqo6ajnZ+WqaKjo6untbu1vK+2wbm4wLdfuWJtbl9nYK63YGJdYmRcZ1xjhGuAf3PQjJB16YPwkuelu7SYkYvdyKLizY6fqKO6ru/Ru8yXn6zHyvt5oYT7kYx2qaWXq/6MkJqu7+SOiYn4jZqZxomQocHH7o2hzOXZj/K8oKHJ37rCsr+z1OfJz43VyNzB1NzYqqf789rg97r0w761tMrH5v+A0YyNrNTd24WF6euA56qIiLWVm4G7iY/J1rrJjZvAmoOFwI/Dj6To59uJitGo4b6FjJGpnJeuoemwkJ6V9MbV4vXs6s2th/jezsfw37icub2v3qPWn4GBhJCZ5Jfz7pKTms3x1J+o+eW+tYyG/IjvyXujjoeip6+0c4rai8TSvdBsZaSab5WEeb5ia4eAz4R6moaUv/bopJ3M2NSsrJ/VkojNmPyaq6ewe26ji/fNce2Zq7Trx3hzcLK9bpmBa756vbXEgI96bXBxj4+8tbZzc7huqb91n47XqMSL35jHfbr2o4ye/dPJnN7HhKfknPm8n5WUrraO3YK8rLHn4ZSwv8SKiN2xrnmgloBuXrsrvat7bJRmgLVsVFVbakeSc5t/pZXIeIl2s8Nve8lWaK10q2J7WlxhemWQoIBub4xsQVBxdT08PTtgfF9ZUGxJOj16VEQ7PUNKgj81UUkqSkJrS05ZYFtTiGtJSWheYjFVMTM1VSk0NjxCRFkxQzpFLSs2JkMqSEpQO0RJM0YoO0IrLzE5XkpGT1diNVFSS1tdd2tKREg+TmZTSk5MV2E0V19XYDRmY1JKM25oNYBde0OCfHJxWkVVWEZiWltKTFVbTjE2Pi88MitYMDY2Nkk0QVVdfJ3ChYqCi4yYx57458Dog3942HeVwquPg7PjgImZipKnucfB9JCRg864yMGbwqy32ePO6tXg09ve1sXE8fvmhoGJkJSfoaSTjov9j7DBVl1qfoiLhfPvc16Se4CRm6mZlI9aUpRjgXhjYY5qSURQYWZdoWdeTmhIclxmSlk/R0Bfa2llQT1JWUI7QFpDU1xYUC8/LjoxOVJAWWF8hUlnX0hEamRcVkpkVU9YhH2Pb1hAI1eKdlJOWDxOQGp+Rk9KVFhaal5PiYSk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2L2/gHPL75rclnvGg8W6h9R5msNxm4qHZ7RnY2ZscHWNaWVpbm9pbGdrZF9gZmtxZWhmZ2t1aWx7gYRxc3+CdoV+hUNAe0NFRkZwdD9FQzo6PEZISFJRRkdMsahwa3lusJTQkXx3mLOC2cmq99/k5cmRkcjpyrq1142cgsK/kqbD4+a7gPK9l5e93vaSqoGg3X58eeGBho37hYeA4Zr/nKzR08vNecz32ILhmsGViX6QoIrUvLK5rqeAqLSXmp+ZhtLPzH62vqqyyNPAnMGfoYN8dIu01X19kqSz2aybusSf6OiDgZSOh7S1oLmJkYF5dsW5uZO6hNh/lLvH56GamIqRtbKOgOm31JbazNaYs3jg67usjbPRssSr2eOUeIV4xHl2bIOCcnJ3zG9trHLYstD13Z+h+uTRkYG7eJOFn2OTdF1ZmMPJg+q1jJmw2m+IdHxfj2lvbF1eZ8Sfqe6N5cjWesOXm4ianrV6ibb0ernioKKFjLNifGXlu+PAiV21ns6imZzfgJaa2/uQmO70kb3KhJS9sHWSgn6bie/i44GxkbCYn56bt/HWlnyriX+msY6AiNe239Lavd+yoo6H7eqnweLppZHE9oKMiPuUvLeilJmX2ai6yeyMzeyZtM+IkcyQ4Nu9ntK7m9mhnae72cGHpuSXuseSn8q7o46khYrejbDgp62fgOCA4qSVo53Df35XpaXgepOlh2tqx7d1TWd0b16V5JC6YEl4Xk9Mg5qFn6iYu4qXg2KvmLKVh4vBnI6spbqDiMiB1p+jvn+JpZuascSnwauM1KuYhfV0la/pltjl5eFvc55itLGmnpuAdbh9YbFyd4CfXmh3a6tdYl1aX26tX6ajgGNwgHKagYucn61dp5iljmWokqXBzGm1yXq9w21tl5ay2rFnX6lpfNCvoPB9436nt9WGvYmBsYzWoqbl376azeJ94/D3vZPkzIThmtR/s3bVr3qqrnR4y7G+sae4urK2p6HAzXh5eXeBlJSWj42IfHp4gJWsZ4F3k5aE6ejazrqWgOZ/uNuRqZ2U9v2/hMiKurvczcKfh87T2MK6tsvEv+DVhpie13jk767b9JHA1qC8sovvpMWz1/X9mqyTvKyh7uaVpai6p5Db3dDQi5qIrrOg9pardUCG4d1za5tjhX+WZZKT8bWlfIlzi4xyfm967sPByoaEw4Lu2YOWmp7qkYOugMaskbTJtq3dk/yF4f3+rLjg59HV6eR8geaK9+fh7e/9yYv0kZH5+YSA/cKj0fjEoZ2Vqo+ukP2JlJT0i7i0wqusmKm9pJrH6sWr196Th6+WpsCfgGuycHbF39bSlnN04W/V1qGxkJ6MxIuI9OaLv/OfyqW3v5eTlZHIgLik9tjdgIHY/aXuvI3jlN7PlOqLqtqGybi0me+Klpilp4bCnZegqKqlp6KqnZaXnaWvoaOjoaOto6e5wL2trri+scK4vmNfu2JkZ2Wqrl1jYllaWWNkZm5wZmZo58SIipmHyZ3tp4WErc+M8u21/enx+O2qpdT02cG/4ZemgLS3jp2z09CpgNWpkIihxvWVo3WO3IaMh/+GjpX9hH5/1Jv+nLjd4tDviMz044XbncWZlIqfs4jy3Mzdz8qoztKqrbKrl/337ZTV4cjV6/DjvOG/tY6NkqvK64WGmau71q6gu8Sf9vWVlaunnMazoriLlIeCgtfK06/SmPSLldTf/amiopSYuLmZgPrJ5pzr3eWoyoHw+MKxkb3fwM655PCnhZaI6oyGgZmViIqN+oWAyIPlw9395aKh9ebWmoy9gpZ+qHSykndqrdG3dtOrhJC153SXh41spXl9eGlpcLmJj82Q+MbZiMuqqpiyueGNhZHif77gr7+UqcVylXzpwuTgpXDLpKt8dHSwgHV1rt5/grvBcJ3Kdn+ck3V5coCAdtfOyH/Fqci+ycOvyvrclImwd4Cvv52LlPbQ+uLize7Nr42C7+Sxvu/6oJnC7XqLf+mJpKOBdHppjXdudZtYlap3e31TUIVolI9jRn1sSntneG2Ko41kgLFtjK9ycnF4fl52b2SWaHKSepGXgJxWmF9bZWt8R0E/gX+BRFtkTj07cWZGLDo+O0F9Yi5xPCVGPDEgPT9DeIRxekhQRC5aW2JIOztIPDc0NUQmLjUgPjI2OigrMjM8NDk2ODwzRTYpL08mKDRYNEdGR1M0SnFHgH50bG1cU3U8Mk4mJzFhPT9HPmU3OzczNEBQMldJgDdAU0loT1NoZnM/cmV1aE6CamZ0XypKPC5OSi0rLSswPUM7K2RPbquMmfuE+Ie4xtmIz5+FqH+5mrPz6cSaw9B34OrmsYPFq3njh6p3qmrTsoW4r2puycbTz8HX2MrUw8Dg84uLj42Yr66tpKKejoyJkaaoUWRh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iJZzfJCKn4WJZWqInYWWaWyOi63KvrbZdK2n4NC44YWcp7l/0X50X2xskppiZ16MkpByZ2hWaWdpb2l9iZWlfaSwfpaYbp2rl5aVXUZIQEhEpdiLjJV4kXKxenGScse6aqvBo2uMnp5tfmfPsHSNwZ1/iLptlICWdIukg9W6c6fYz3jme7+nuqZvqZCQdmRnaWbDbmVlY2BkZ2VsZ2BlYl5haF5gYGZnbGplaWt2a3Fvdnp/fXJ1fm56g3hGcW14gEVydnZFR4ewxq+Tpcqy0XTZzJXgs9R0a92Vr6B/u8i9wZqAjaTD8Iqdx3/F0u+n2enhl5KsoYCti5TO0dKulMa/jMZ0f9WA5fDYid+CwcS6jLC2h7qahfLW0firuL253Y634WyJko+dj6ibgqGPcMPKvqi5s3Gw0de2sr1uxdPJh4KAb2p7odGjfaWksbK9iZqbqqqQi8GXfG92gea3hIWEfsmduKCUhGWrc9TCvYWLhH7En6ii6YCmsozGkICA3trC1s68nKvI0HzxvsWqk5+LynnKbc5yeHd7lmzM1qDh0I/ofcl/+JOI07+QpefhzMXCiHRdonOMkpuNn430otWnp2hijmuZW11ZdvrOuZW+mLrk0eihneKG9YuChr2CpHFuY42PWYNkY1xfjmCznXrV1c3IkpOA1ICM/NGF1YKsz4bDop6ih/J7l9PQ2NLBj5i5Z4mrkI6Cd7DSsYDa37KyzNuBueLiwZvH8ri7opHU06OX75ytloSNj56Au6OEuYWhlaaulKuT54q37vmoutz1hZy6rqXPy/Coqrid9pva3OvLhJ6nz8uF7+eRrbfvubeLhsrnsrCDhYCIdqfVqaijwXx0dGxdr7efZamofXnJ0a15Qn+3iNjkkKW5fJLG0K+xxVyIeaSCi6SnvGV9jG59k6GYsp6tyZaI3cSMkaLLz6WOy33UsICDn5V5h8R2ivb/vo6AjqyTuHyaoqelloeCbLqjpLJkoWGEkWlxeXBdoGF3X1WtX7OOlYCYjnVwZI5ilmJfX2Gdm3yJn6SemZF1iYG7pHHRv3Nkl5CyX2iBmnjQ4cX4lYiYw9fQ3ruvwsqu5LTqzdy6xcThwru5vr5rsZvXwH+UjdLHuavkjcnS6MSusayeqq+vusW0vsTOcXt4dYSNlJGBh31xfIqGipWy23uCi+7JwMnYzoCY6cbRtYmZk6aYk7SwrbCt39ed6e2A2sP7mof+lbPvn3y3w8V+eoDgsovg0uaj9qmL04DH3tbw6OqhhZDKlYuchPKW18+8ioSu4qDzg7TEn6fZtmSFo9mSjWpUZnFvXoXXvnxtsLWLq8+1iYjZ4LGRub7Yl+HWvJCt3ZPUhO+TpoCXts6xkqmOoN7/y9evvM3M6sLBiI+otLfFiYXEqsHazs/zhtnB8+zQ8oqor8iN756WhI6Us7iFiYPOyMeioKSFnpmhqpq80NPds9jXl6+4jrXEs7G5gXFvY21r3PakqqGWzYzPnpKzkfjsheD/xYmpv8KBloX82o6r8MCksNqAt4C0gZ6pkOzXgrjp5IT1hs+z3M+I17m0lZSXm4rZoZqamJSZnp+ln5qbmJSYoJaWlp+eoaGcoKSypayosLa+uKuxuaq1vbVlqaayvWGqsbBhY7/S8evO3vTY/Ir/6Kb9xvyJg/6rt6iN0NbLw5+HlrbG9pCf1YHM7Pepy+3vj46ejICZgo63usGfj7vBfsSCh9l/4freiuSAwL/Bk6OrlNGpiPXmz/mhsL7A55/U+IOirqu8sMq9qraig+Xq5b/q4oDJ7vjVy9eA3uPonpCOgoGXu+qxhaemtrG6jJ+dqq2TjtOykISLh9u1g4iLhdWxyMPBrIjlg+3c2ZGUjYTRpKyp/IC3x5PJk4eE8/PQ6N7Jn6nP3YL6ytO6orGg947sgfiFiYiQs4L3+Ln83Zb9g9aG/ZCG2MaXqvz2ybvUpY93voGUio+FmYPypNOov3xxqoWzZ2llfdOqmH6qncru2+qqqPZ69LKoreiAs4CBb5qtcqV1cm5yuHPVsYzMvbOud3VmpoBsya12u2yKpGScmJ2Fc9N9mMa7vKaif4e2cZ/JraaSh8n0rpTn6Le52e6EzPb2063d9M7OpZbU0pKJ3J6nlYOUjIF0sZ90m2N+b3CEb3pajFhQpbWDfISDR09ud4R9l62io7GMxITG2ubMc4SUsa5x25Zdi3KUd15kbJuheIltf4BVUGx2bm5sfUhGWGJMa2h9WpR0Qjl3f2NKH0KLcHWCeHFnSkhvgG1heztsV2pQO0ReekBDSTtLXUg/OTQ6RDYtRDgpLikwPDIoPCQ8QysxSjwoMk0rMFNpRzQtMTo8aVVobHFyZ1xYR3dbWGI1PiZERkNHRkIyPjVCOSlYL0Y8OoA3NUE/N0IrXENAQUNta1tuWlFKOzE3SEZgPSBiSC0nOEM9NTFDa2ezrK3/o5in2e/i28HE4cOlyZ362N+ssrDCq6+sqaRPe3W2vHl8fsLDtaz1kbO+2M2/wL+xxMvH0+jW2uXxhJCOiZulrqaUmJGGjp2WmZejx251g/LSy8bOy4Ca16+lk26BgHxUUl5LR05NWk5EenJOfW6IWE+PUk5bOEx7e3ZKRS9DRDBKVm1LYEc/ajxQWUZQRl5NJixPOT5LPHdQZUpTRD5ObUN4OlJWU1WMi0NNco5WVVE5OEhNQFRlXkhBa2pHbVdMRlCWindmgYV7TpKei2FcajpiXKVlcoBlfYpvR1E+SF1zVF9ITV1PUlFUOD1HV0xRO0Nmc3l4a2F3RnhgTmJYdTk8N3U/akhJPVpVa3ZdV09cdntaV1FBSEdOUk9fZl1nUXqLdIqDTYKPi4iUh4mJhIyD7f+tpImaplhTUT9TPX1sRXpxUTZnfFo+Ri+FcVlOdVpRVUlBOYBUX05vdMCzTnCXaC58NWxSXbBMwcNGWcXHy6nT1c3Oz83Q1dbX1tXV1dPW3dfY2uDe3+Lh4+bs5+rr8fP48+31+fP5+/qB9fH4/YH6+/uBgP++nu386Mh8jVyce2mQbYVBPIZXcDwvX2RVZ0E3SktWYmFubCxdXHU7MC43ND86K4AxL0A2MDImNS9zJWlNQmQuWmpJNUI4RFAqPWN2U6mTfl9MTWItOGt8oFeGsl5ojo6HoK6pnmdRRoqTjoOZmlR5gI2KfYFFgIN5YF1eWVhsgollOTo0NkNGOjM8OU04OE5EREQ/NkY7ODouOGNIYFJXUkyPSotSTC0xMzJeQUM5Z4BKRDBGNjk8cWtXXmdPPURRUy5ZTF5IQGBSilZeOIdGPTo/R0aVx7rpcTVUK2k1ak82TVRHWX+UpKz45cej8ZqmUVRFTkGOes2t/KmW5brrhYqHnrmVhnScS0pjT1ZIR3FCe2Rkb5t4zZ+jgJ3SmNqQjo6U85D6wKzHq56aZWJUh4BXoZNprGBzgU+Fn6RzZsCJor6uqYWMdXm5hsfyVkJDW2FOPi5SalJIUVIyTmFWVT1RZ2eMQixWSEk8UEVGR0JAPUotVEFHYUFNPkZeR1Y1TzgiaYBkUU5NKixIUl9OTl5hYmtNb06EfYR9Q1RcbXVKnGhCVU9nUTlQYHR6VltITYh8hX0EfHx8fYR8D3t7e31+fXx8e3t8e3x9fIV7BH18e3uFfAN9fXySfQR+fn1+iH0GfH19fHt8hn2JfoV9BHx9fX2FfgF9hH4CfX6FfQZ+fn59fn6Ef4N+iX0FfHx9fHyFfYV+BHx7e3yJfQZ8e3t6enyLfQF+hH2DfoR9AXySfZN+g3+Hfgh9fXx9fn5+fYp8A3t7fIV7CXp7e3t8fHx7e4h8Bnt8e3x8e4d8hn0DfHx7h3wDe3x7hXwEe3p8fIl7hnyCe4Z8h3sBfIZ7BHx7e3qGe4V8AXuPfIJ9h3wBfYZ8BX19fXx9i3yTe498gnuEfAF7hnwFe3t8e3uFfAV9fHx7e4d8A318fIR9CHx8fX18fH18hH0GfH18fH19hHwBe6l8AX2EfAZ9fHx8fX2JfAF9hnwHfX18fHx9fYR8gn2HfAR9fHx8kn0Mfn1+fn1+fX19fn1+hH0FfHx9fX2FfIJ9hHyCe4x8hnuHfAF9jHyNfYV8h32HfAV7fHt8fIR9B3x9fX18fHyFfYZ8BX19fHx9h3wFe3x7fHuGfIR7CXx9fH18fXx9fYR8BXt7fH18hHuCfIV9hHwGe3t7enp6hHsGfX5+fn19hnwCe3yFewF9hHwEe3p7e4R8G3t7enp7fX5+fn9/f35/fn5+fX5+fn9+fX1+foZ9hH4EfX18fI99iXwGfX18fH19h3yCfYR8hH0TfH19fHt9fXx7fH19fX5+fX19e4V8FH18fHt8fHx9fXx8fH18fX18fX19hHsFfHx8e3wCAgQAgJiyu/umr8OQ94KjvpS+uYfm5MHYhcPair+W/seBvpmMgqik9KqnwpmI+ubRs+qDhXiUz7PQurmW4uyoqZSzr+97tq/vj5uxpMaWpujr5fP+pomS5YWxoqeUnH93fJLMidC2wcvAta6Xi4GOjuqFyZvEoJ2T8dC54/vCw7LCx76ZgLSr34vKxYf+q4b89um0keveq62/3r32yJChv6+coLjQ2eTogP+U8fOLn9t9dYjCt5309djlzNWevsDTk6ihpbyunX+Pn9/q8IePuIOA98Wpj9HXrajUxKmMq6yUmJGSp6eiqbiysby9ZWt1fndvvLmoZHRtdIGs6YGLjJGT88z4gJD9wM60/orgmZ9hZ2uOiL6ymqB5h6Nt07mJf5SYkc6DhYTsgaTOkOC9pI98jb5kdmrHhsCps360aIK21oq7u3LPbaWqhYdqY3F4gaXLsKiFoK6UhIiiha2qqsO5royvnLyviOG0dqedr6nY1NC7t4+mm6qvsqOGq6qXf6aXzZq+gKSyoImAmp2YxqOZpW2CgZrNmYJuZ9JyfJpcsoOFinemr9eTwb63vXLizpGH4Y7RZ6yPnqpjb6VpZquigXVTXV1zdXlfgZWTkKqXr553iHxqhpuakpWUjZSAcUlFQ7LFi52igXthZb3HbZujqH94drl1lr+xbG6mqJJ0iqZvksWrgJ1xlIyikMDH3HSGfIWiu6ukqYifgZxncXtlv1xdW1tXWVpkX2hfW1xeZmdjYGdrbmJoZmhkZmtvZWZpbW50aGxyanVwdotydXd2i3xISISEoryft7G/nnWQubDKoMKR08jEjarWeO2Wvqqbf8re4s6AiMKzsKDFdYTLnIeAobK8gOiRhoqBy5mH3LLhpbamyfbmqoDF9qGuz4uToY6Rhob8lNGD1L6ayoWTotGNioCBnKSXop2PoH29rISYj4iOZX2Zv8PQ2cq9m7WFcnuDgrO1x4Gii+rtm4yNiH+VgZWHu4ZydJ7PtfDr74V58d/AxYiCqrl/oNDLfM2Kzamnd9SngJnQpOZ97LOZzrzt84uBnIHdr9HnmoKvt87XmnZy07KzfWmEeXx4jrzlkuDQrMzljYDhspd7rral+rR4V1l8bMC8k/iEz62ynqlmn1+jdJNbtWPog7qp6Oq/ftnl4qujjeqiin90iXpZtI1WdKZWfl1dYWRwd3V1koyC7f2Q+oXUgIfk793ghtTY286Dr4monqjA6efNhMC6p95ojaN9qbeQmN/Il8O5sJWGyM26pbGkuHaWuqqbhu/clZT+6KKa0+L+6/61ucX1jfuzxLfG2bCBs6mM+ZX2iaiSlJfXqJuLp5PJooLfkZXy7+GW/8T5+Iuc7pil36T7kKTu99iBxqm6gI2Zt92osMKC8Hd7fGaQmnrOyZ+ydJ+8eb2F2ZdahGxkeZSRu7CirJeS1KS3r9h+i4SatqzCirp6naiToYy6r/2H07jki6GnrNWZkMq2narLmoKR7YvEvq+DwJCHjI+jZZaFjZaNhH5uZlxkYqVopHWJc3FrqY11m6GJe4+Oh3pngHx+mWCciVq1gWO6ta2Ib7WtioqIm4agl3B/g35xe5CWo52yX8VzweuDnOOFfpbUyaz7/OXyvsmUtcXelqecobivnX+Jia612IaVwHJv18Wrk9XXp5O5xKWWvMKiqaeowL+9wsvQzdXbcnmGkol+2dm+cYJ6gYid0HN5fISE4a3KgH3msdO1/H3EjciDi4qjr/bsrseTqKeD7dCSgo+Rkcl/Y3Xqb5m5ldnHq5mOtO6MoYLjmODH4pXag6Lj+Ibk6o76msrQrLadlaSquNT23byuzM2aT12ZcY+CYGZqYmWAg5N/eOy/gbOYtKzr7du8w5OjpsTQyb6XsLyroseo773rgK7AuajK5OTa++Xp8bu6udTq07iOivOLqeKF8L6fnYe3xuaQ49bM34b/0p2P8p7yh+TK4vOKne6Ghe/owaSHiI2qqLSYvtzK0urc7NCbop6Jo7i7r6y0rLSml3Vwa9vZpri9nZiDg/L+ktfV3ZaZmvmdu9/WhorOvLGGquaQsuLNgLmAqpixm97k9IGZh42rzbi5wJy8nbeDkKyL0n6OjY2IioualJ6UkJGToJ2XlZynpJifnJ+am6SnnJ6gpqawn6WsorKoscartLCxw7BlZry52uq/4uD2zZWfzdPzs9am5+XfpcnxhPqiw8ytgND478qKitayq6TDgJnOppCAlZ6ygMSIg310uZaKv7DMq6ap0fr+sYrC5Zqly4yYoI2PhIv8k9d7xrWSzYeXuPGcnZydv8u+x8Gws5HavJq0p6nGgJu20tnt9t7ErcyXg4ePk8TG24iqkfb0nY6SjISYiJmNy5uGh7TYtfXs94uA+uvL7Kyx3OWJvPLfh+CS48Cxgue2gKfot/+G/sKs3Mv+94+GnoPkv9X0q5K+xvr3sYiD+tvakoCaj4+Im8HrmvHittfsjH/luaGDx9On6r2PbnKVfMu3jfN8zLG0n7Nyt269iKZlwmfBZpONx9C+i+r/+LWoie20kpWVs4pox6hlkspuonl4fH+QmI+NgHRtx9F/2HSqgGu7vrPEca2qsah9qW6Llaa85cijZ6GckNN5pb+b1N2yqvTunsvW1aWb0t3Asc21xYGdwrKEf+i3h4Ll0JaIv9/q1+aiqrLFdsaGi5CFmoxteUpPrXK9bZRrWHOleYGKo5DLpn7mmJLu7t+Q3r328Ht8o4CgpWSiZXe4uZpjn5W5gGZacXNhXnJJl0VaW1J+fmm7tYyeZGh+RXlSlWVFWkxIU1FPeGBkclxSZ3iRdphNRkFZVVh3Wm1FXVo4NTVOT1gvSkFQKy45NEotMkNITFtTLiwuSShEU1E7SzkqNEt2OFlOWWBbVU9GQDU4N1gsSSpFRkA9XjoqT09JKi03NygigCYrPiVlTi5mU0WAfn1kUoZrSDY4RzpRMyouKiw6MzM6NTNGKlQnpOV0kN+KhqPk2bz4+tn9ucGJnr7ikJaRmre8o4CDeIF+tnuNvF1etcOqk9zFkGeTuKOfz9KsvsC93dzb5OHt6O/2gYmap5mO+PzZgZSIk5KYxmxuc35605aqgHDVobuLuWuwdWU/RUJFSXJgPD83Rmk3dXFbWWdYQT8tMUebTGp0Q1BMPT43TGM5QjdqSGVNPSxQOkNIYDZYc0pyQGJWPU5IQUBESV5bXlRHU2hgNDlqTV9XQzxFQ0dWVFtOQGVoOltYZlZzfI2BhmZbaW5ugWpdeYFqUm15iGJ4gHZ+c2VxbWBSZVNZXTtITFxnUk0+PIFBSlI3anFsa2NwaHhFcXZPVytlejI7ekFXQIB1golCUJpaSnRwZVVGP0FOSlhLV2pSU1xcdW5XdFpaV3NycoGFjpiPjo6Nh+rCeVpDVjEvPGJjT2NzcFFFQk9NSnlGNkN3ZWFORnFSd5xdgGRNTEphXoF0n0lSOkA/VT8+SDlKQEtZWMuyy5/FxMXDxcfPzdHMzc7Q1tTV09jd3Nfb2t3a3eLj4OLl6unt5Orv6/bu8//z+PP1/fqAgfz61r5ufJOTk1tfcnGHYW9fc2lwP11pO2orSlVbRmBmS3BBWHFHMmWBODkuJS4rNjM9gCcqSS8WPi49KVQrX05RSmOBUTw5KDZDQCVPcVY3O1t/SlYsSiYqcFMxZZtobnBri6WgoKGahk6DfXB7dHqIU1hadnt7e3ZtY29ZW1xeYHl6fj47MGdjQTo4NDE0MzIyUkVCQlBiOltrbi8zbVpYiHB3g5JOVFVVKlgzSTs2MFFKgFpSRGstX00/Z1dsmkA5PC1HU05TTERoenupTzNDhmFoOzVCQV1papBzMF5QX3qlTzxVVlJFZGR3zs3Fmp/AmMSURnZCaF5ufsOX+JL4u9mA+YCnVH19tL9tLVdXWUdLQ4tMREdfgJyE5daCx/6T3aaopKnHzrW8dGVhr7d4xWaMgFmeoJq2YpGNmJGEsV55k7fH5a+IVo6OhdWc0+5lPUxARU06LkVNRjYuSD5HOz0/QTVLcmdDOHNLNUN/alNRcmmHk41vdXKHVJVeWmBWYFRNUR0telRtO1xCOFNyUVFUZVp2aEiAXlOCiJFXkHKGjFRndExqdkNyR1uVkXNHe2tyh3wCfXyEfRB8fHx7e3x8fHt7fHt8fHx9h3yGewR8e3t7iXyGfQd8fHx9fHx8i30MfH19fXx9fHt7fHx8hH0Dfn19in4IfX18fX1+fn6PfQd+fX1+fX5/hX6UfQR+fX59hHyGfYR8Bnt7e3p7fIx9Bnx9fX1+foR9gnyVfYZ+g32HfoV/DH5+fn9+fn18fH5+foh8AX2FfIZ7hXwEe3x7e4Z8Bnt7fHx8e4R8C318fX18fH18fHx7knwCfXyIe4Z8gnuFfJR7AXyFe5F8BXt8fHx9iHwBfYR8CX18fH19fH18fIR7BXx8e3x8k3uRfAF7iHwKe3t8e3t7fHx8e4l8A318e4V8hX2DfI99A3x8e7F8gn2UfAp9fHx9fH18fHx9hHwHfXx8fX18fI19AX6afQN8fXyEfQV8fX18e4x8h3uTfAV9fX18fIl9hnwJfXx8fH19fHx8hXuEfAd9fH18fH19hnwBfYd8hH2IfAh7e3x8fHt7e4l8AX2FfIJ9hHwFe3t8fHyEewZ8e3x9fH2EfA57e3p7enp6e3p7fX9+foR9hnwPe3x8fHt7fHx7e3x8e3t7hXwRe3t7fX9/fn5+fX5+f35+fn2FfhJ9fH5+fXx8fH1+f35+fn19fHyTfYR8B319fXx8fX2NfAJ9fIR9EHx8fH19fHp7e3x8fH19fH2GfAF9i3wRfX18fHt8fn18e3p6fHx7e3wCAgQAgPe03dWr1Ljaitn8hu/JiKy9gLrov/TVxpmL6Lv/54qG2rjukKCltpCi0JHKvZrJpK/Eisyr2ZqOzIfxipe5k8GF2qa/vKuep8Gkrdf2jqWhqZvaha3KxbG61MqEvb7ntYaCq6Wxq6CHj5+mnIW+q8mHm6Xz2aqjm7+OqZaJ/6CigJ2LxYGN4aX81+aA48mbovWii4+fnZqt+ObTyoHywKuSqc/XlvTpzaWg5eWGgnydhnSfkqhtbKS1mM7Em7Won4SnZnl686Ozv/DuysePkJGOh8fAj4Sa/erbg5uXmpSNoZOPkpOaq7DBaWdncnDJZWdlo5NqaGyB2/fb4IGA8J6egKi8//2yyOx/zYqHc6xjZ8RsjamM0Jfbia2I35WQ4J+qj4/cubK+npqotdtvdIh/hnRyeHiz1YeXroKfsLKPhWpzdWuJn4BubMCyncduq6al5ni3pdG1+ZncupX9k8W6ifyGyZLYuYODpZmjva6tlHz1naWMgaFx1ZOgvKjUqG2VgHfNw31tmniKgpFxh2Vvc5PSjnpjm5ebcrBtXJ5w07+Lu6+uj5Kpzdyato2V2pGIjZx+mZmWX6qqx4iUWl5fmIdwbW5xiZR3l6OSlaxwiW67s3uDx5KBrq97mWtPR0Smu4pxZZ/BuJqIkJ5wwIdxnq23f8XGb57Dg5R6in6MfXeZgIaZxOOj2K3FgLqYjO+MjbWPh4OYdo7DknByfGdoV1pqZ2JsZmJcX2JlZ2JmZWVmaGNhb2JiaWhzaGJlaWpsZ2tzanRucHttdHJvWmSShnp7mZ2rqbCcg3eOnnWXqqd4p7WSdoHgzn/H9smX4obGy67a7viJmYiJifef5o+YxI3PgICk9JDq7dvwiLK0l8y+j+65v62mqcuttty35MvKioV7we+moZ+jus2yhHeMu4THf5GVta2noH3GrpmMkZWJpW2Mk6ivxsByd5iLdXWIj7WVraODjdLyg6iDfOuGx8Lcf+Jw1LWGh6qA5vLS4sjHgnPbwqBkpKOrjb7ol4S6db/WgLXGtr2855qttLvUwPDMn5zRlIjbyoJ9mn96jHPJyMPNznJ+ysyGuIuOlIm8p4y8scaDy62TdnLNyvyHY1ZgWqzQgYnuup3J0omGaFeneY+impyHkKG/rLKXd7XE+OGlebCaf9KZ0mKlcGFddH9eT3t8TlF+W4l48tHq3LuIhor6gMeyo6WducqSpJSGi/TctfmQqJPJyr2ejdx/jXl2tKCYsMTgqMCnkJCYupt8nYyqgLiesIKHoNKUldTYtanCp7aRiYeLl8jLyJ2p3KyvtoPYjpCi9LqQ0Jia3pTnjJ6Nh8bKmZ6euZ6f9e+i+Nq/vuqY1tT1qKKl3oaP75yS9eWdgN2lxcepzazLetTbRrSjeHB0U4Okpb2knYGB1ZzGl15vvZ/TgI+kqZCnz2mWnoG1msHhj9O4s4h8mGb0fofLofKa5668pJSQor2dnczle42FjI/girXg187h9N2Ow76ogF9XfXiAfXRgZnB2bl2Mf5RicXadkGVmb4BhdW9ZqW5wgHJnlFlopXa2nKhfqpZ1eb6FeHt2a3OCr5izpFOhin1reY6neLmxoJOG1+eLh4Wtkn6ro717cJOylMzRpr2wq5O7c4WC742UtOr11siHeoyJgryrd2l84dPbiaeiqqaitaejqKiyxcrdd3R2g4HkdHZ1wLB6eHiCuMm4wXF15KCOgI+m49yn3fmAyJignuCFjvuKi7ik+Zf2kbWV85WR1Zqdb2jAn6iyo6WinveBk6uuqZqSk5vUznmM1KKzuuGvq4qYpo6wyKyPmf/o0/OK2NLF34DEX4ap8m1zZH6zWXuWg/mO46Prx4+Pq66ty7aqmoLzoKuanL2O9Zuly7f72Ia7gIXx6aWqx77QxL+toJimlrrg0KqFu9bnnteKhNuD+dyV0cq3r63C4/m3wJSk7JuZs+PA5urhg/zq/6DTlJOVzLylrKiqycmaytnQ1taMpJD69JaZ/62cxs+auJF3bGfRypWKieH98s61xNSP+qOKvtv0oOvphrvimrGGoqGslZa8gKC12fe2883ijsurmPaVncCgm5Wvi6j3xJ2BnJSchYuZmZaimZSOkpWanpaZmJqdnZeXppaYnp2snZeanKCinaCpoq2mqLOlsKqqeYLRxbGwwr3Tz9K9sJGkt4q8wrWJtMWjhZD244XX+uOk+pHe0rDl5PeDoYmPj/2Z7pehtoXAgHWT4ovW1dPvhJ6lkLq1i/TKt7Spnbylq9i/1NDGh4yB0vO2pKGkuc++lYmg0535n7C42M7Fu4fZwqKTmaKgxoGfrsK639KHkq+cgoCeoMKjvKyLkN3zgaaDhvWO18/mhvKD+MifkaiA7vrc8dXOk4jw17+D18bHnND3oo7DgNbngMTbxsrP+K3DyMvkzv3WoZ3bpYzl2ZWLpZGJnYHo9fj494iW6uqYyI6RmI/Ls5jHvsuFzqKagoDEu/Ceemx5asDVgIbru6XO1YuSd2XCjaCsh4NxeIWnlqmfgL/L+t2hhb2lie6j4W/Ehn13lZh6aJ2iZGShdah8y62/sJ+CfXDDgJ2OhYmFmqF9mHyCdby1suV7h36foqmHfs6JqZKV37a2ztjuuce6pJ+fzKSLpKDCeKWap4h/os2JisO8lpSmlKqFfn1+iLGrqH2RwHlxim64ZkxXxKl7w4uBl4Csa36FhLzFoqmmyqqn+vek5tvDuKdjwMzjmW91j1V1xYR5zNWRgJ1dcGplcWl7TH2DI5WEaUpGPFyGmaGIeWhalF6pZjxNmmF/V1trcVlaaEV1g2F+RF1zTFFmkUVOY0CqRzRKQUswUj5FKikpLUU3PDNHMzo/NjBIL0ddWFhXZ0UsR1liSzw0S0lPTkg8PkFFQDVOR1Y5QURJQiwrQUklKCImPjIwgCwqQSk+Yz51ZXBBeWlVTXdIKyQhNzAyVFg1OihYQzcuISlJOX0vbnN3v96LiYu3oImEsNOSgYiqia7Rrsq6uafXgpCJ6Hl1ntzv1752XIV2cZp3UTtdtbHOj7aqtbOxx7K1vcHL4OT1hYCDk5D+g4aCyreMiYmHn6uiqWNt35+BgHub3M2Ypatemm9TRmg3N3Y4Mz85fVx4TmpQk2JfekJMQEOBdHJvb1RTS2QwMk1FRDw7PT5PVDE7ZExLRkZBRz84PEJGVFVFPVVRS1YwUVlPXjlyO05wmFM/MmSCNUZmVqBYc1J1akM+WU1reXh4al6mc3tqZG1Vq3J4inydbTNOgEaDb0tPXklKTUpHTDU+OVRxTUE3XnFtQFQ5On1iuLdjXmFoV1tTZGFfVzI2cUg3PWdaaoR4T4ODumpoSUtNjVpPT0lEVERDU2lPX4hpdkxxcV1xhWlskpmFjYuHhoPmk19Rdn5jeW1ZZmc/fVlJX11oSVtVLmFjT1NOVUBjVkBTgFtrnJJonZtzPIFdSmkyLU03RjQ7M02YuMCDrcHIvcHJxsjQzMzIys3R0c7R0dPW1tXW39bY29vj3trc4OPm4eTo6fDr6/Hr8e/vgoH8/fbxi4NyZm5iZ2BjY1NebWZWc2lbPTp2ZjlUV21cXCtSXFxrkWgyOl5OKUooWyw4KCQ+gCE0RUMyNC1LOCY6NkFCPXWJNUszODE1K1+TpY5jKzw7Z1pGS1diYWtYTF1sgX2MUGWToZyPWkqNhHJvdXl4hlNeX2Noc29PWGRfWVpmZmNgbmc9NFVrNT02OWo0UkliLF5AglBBOzYze1xaZmVIRUqIin0+TUVFLEZYKyU7LkpWgFxbT09PUEJJZFlfaFxQNDFHRzdaUD1JYFhPRDxzemxzbjc7hrVITjM5NTZQT0dkSFUwc2VVOT+Qp+PXqJWegdy7PTl5W09jcl6SnYf8wNHYfHRgZHCUioVILVVkkYlYQFRKRKKK2IX5qKqn0cikkNviiYXYpOqTs5WfkpN+bV2bgIJ4dHlyhYpxk2yFZ52ivNtvdHCKjap+d9Wl4rJUPDU0OUE8LD9ALTAvRTMsPi09M1hgeFIvNWY+TW14ZmVnYmlMW1xaZHF9dlVfelVMWEt8QCcqcFtPf11WZ1VxSFRUUHFvZGlgbGFmkJJgl3x5a3FGfHKRcltaXjVdpGFbp49nAXuHfAR9fHx+jnwBe4V8BXt7e3x8hXsIfHx7e3t8e3uEfIR9Cnx9fXx8fH18fHyIfQF8hX2CfIZ7AXyFfY1+Bn19fX5+fop9AXyFfQN+fn2EfgF/hH6MfQF+h30BfoV9gnyGfQp8fX1+fXt7e3p8hn0Gfn5+fX5+in0IfHx9fX18fHyPfYV+Bn1+fn59fYh+gn+Ifhl8e319fXx8e3x8fH19fHx7fHt8e3t6e3t7hHyEe4R8AXuLfIJ9lHwBfYR8Bn18fXx7eoV7Cn18e3t6e3t8e3uEfIZ7AXqGewF6hXsGfH18fHt7kXwLe3t7fHx9fXx8e3uLfAZ9fXx9fXyFewV8e3t7fJJ7CHx8fHt7fHx7inwFe3t9fHyHewd8e3x8fHt7iHwBfYp8BH18fHyEfQF8iX20fIJ9lnwFfX18fH2FfAF9hHwCe3yFfQN8fXydfYV8g32OfAF7iHyIe5N8BH19fHyEfQ58fXx8fH18fHt8fH19fYh8g3uEfAN9fHyEfZB8BX19fHx9iXyFewZ8fHt7fHyEfYZ8A318fYZ8hHsFfHt7fX2GfIN7hHoBfYR+hX2JfAR7fHx9h3yDe4R8Ant8hH4DfXx8in4IfX59fn5+fX2Ffgd9fn59fXx8lH0GfHx8fX19knwVfXx8fX18fHt9fnx7fHx7fHx9fHx9knwRfX18fHt8fX18fXt6fHx6e3wCAgQAgIqd2c3Z0tKwkPP0pMCk9KuT3t7az8GzouGertv5hIya/M3Yyfj0n6qImLuYh6LbmYye5595tbm24u3VnbbXs5GW9Jqe35ny4Ki4r7bDhuTnmsuetoazp7ejnaSZzd6Ug5i4vbeao5DB2JqlwL6zmpyhj5a4rYeUvK3305HosIz/gKiN0N3V+tKynr/959upnIrdu5jDn7eim7jNiKny6piQs+D28oWDv8aYiYeZvJKDpLS4c4OPeM+xpoSXt7jAzLqbpNPn+Zmpj42v/6GCgPza26qTs+3dvKu32X+Pm6agrJeQi4OgrqhlzGxscG5pwcpnfJ2UcHnJsaPRmsa9tbiqgJl5hqH4j4OQa3XJc7dvX43AfZHZe4HawrmCgOOvzeCWzoCL0JLGy7rkqYKtZ6OQhZ1kcn6gfeRv2tC8sL+tfoCAZ2OCeH7Il766h9K+v4TN0J+dpe61toPq7L7nqLHfksuQuMjdu495iX6ntpqBmIWCznWca8jBm+OycW1yi3O9gJ2diIp1dGlgWmhjZ8SlsmyEe3LCpKW3gqOlk2DFq8x6pYyCnYeLu7+dftTY2/OCsF2Rp7Zppo5/kseVYmFwgntjhHJyiGutp3+JirB2e3x1maZmp26XgX94kISdiIhcedGddpuKg5minZSbtWlxu3TGg7R1uXiCb2tqkmx7w8mngNGNqICtvn/Sld132YV+lsCdwtSDiZWFeYmDdGZsbXB4gW13cWlmWVxeZ2FnZ2xeaWdka2diamZnbnJ5c2hobWtsaHJqaGxqbm9vmZyAd3WCuYp3gKp+dXeNeo9r3Kt5hKalzKnLsr2cwoufw9yBi+7PyIGFzJOzpLD4rKW4r4nXgJHth83rxKTI4pelrYDQkvvKs8mDwZ+UrtrIm7Wr2bB7sciwi5jk6Ynscc+YlHSAaom4lre6j4LKwsS9rbiQhsx80Xh33NJ5fZiOida1yevOvoeVpn3UuL2Qgs7G0bTegX943m2Ng6CEyr7HubuioriqunuQjYfRnYCjkbKkkYnJgKG0vrnCfZeOm7KByM/Nnp/er/Tuwp17jdN2lYKLg2hqbGa4b9N+tOuNjsulzJmTqKO1n4nannurvI6tbn1manPAgZH9wKmCmMXompqqe3unyO/r1+vhm4/ge9DW4MuvmLHj3tDcyL61iG91cVt5bGtuk1BmbZb91OeF3JHmjdjfgJan0KOPs7WojeOVuMGgxPuApae11czFgnW0dHOunJyThbjbqqe9h4Z5hIHNd4DjmanxhbrW8rKHk77O09jdkJGjk6nAnMeK9reqj5q4hJXusZqSyrS40q/i9PGtnYzWk6mthK6ts66KjuHJmMWwo4vAvaWYqbnEjJCGhsbOgYnRgISYvcDO08OseeHck5Z3tlpLiKG5r5SKdrWEvcirVFd428HHt9/nlbKVl5licIrJiJCk8Y2Enp6swr7mncbgzZaj7JmsxYTGvJGTlpmvc8LCgqSduYWztM28trWYzc18ZG2FioRwdmmYqG11h4V9bnN5bWmEeF1ofnGpimKXjGSugHRpnZmYv5V9cou3p51+dGimm3aLcYF6cYiTcn6gmXtufZq/v2ZemKt/i4iXtpWPtsvVg5akhsiln4SowsTO3sypsub0+Zahjoaa+q6Ad/jHyJCCnMC7tKa224aMrbu1wKajmpa1yMZ153t9gYB53uN1m9exjpjjpHupg62ztL60gKCAip3+o5q9ipnsj9+XjLfwl6fwiorz1ceIfdWjtdWPq05iroG6z73NqoHBgNS/oLqFhpu/iv6C++rU0d7FiZKhj4WopJ/su/vhs9jQs3fb1LaZWJSkdzl/uJGda7TkoNab2en7xJ2BfIzO0bV+lo2N84C/g/Xaq/vWi4aJq4HmgL/Kvrygi6KPhoqCjPrh5oKvsaPZ29vuntj34YLx2u+Lwq+ft56l09qrh+jx5P+Ly4DR5vKM7dnEzf7HmZalw7GSyLGkuJni27u5uO2OjpWY2N6D54qznKKRqaS4pqd+k+uzm9fAutDe4Nfa9IWG6oz5n8eI1oKfiYCGt4mY7ffKgPG0w5LP2pP1qP+D7ZWMocyp1POZm66uo5eaqJWdn5+ms6CrpJqXiI2OmZCZmp6RnpqZoJqYoJqdo6ivqJ2doqKhoKugn6Sfpaap0NW+r6m15aSXm8iWkI+jjKuA+ryHl7S33LrqwMio3pyt1t6BjPDp3oWM66C/m6v3qqy7q4nbgIzjfcPIrprB0JCYn3XQj/LIr796tZaHpOHNnLW57ryDwtnAmZ7o8YrzhPCtq4uVhqjcstjanIvYzMy3ssWkpuyO9IqB9vGLkrKel/nh1PXZzIuaqYDhxcmRhtzU2r7kh4aL/IGjiJ+D0c3Wys63utO386u8p53rpournLurnZPcgLDG0MvTh6ylp72I3OLdoaHmvvz40q2MoOeHp5Kel4GCg4HmgvyRyvqQkNS02aOasK25ppLhqompqYi7hpqBeH7NeIfzv66Mo8r4rbLDjIecp9LJucTUipT2jOjw8Muyssf3/fP91tjMmYmQkHaijoeMuGiDi7Pfrr1tt4LRe7C2gHyIrIN3jpWahLF/j5OArvF9g4STub2kdHvFiIfRpbW2kdX1zcLKlZuBmJLchI7hnanOfKO74ayEkbW2wbiyYoSYjZ6vibN5yZuNZXSObYKiaHB8t6GqvXuW0daHfW6yjai6mre8vr+RjOfCj8qyo1+NsqWQk5ihZVZWfLK3b4DFgE5gc2p4em5vSXKTbnRVizAhUY61pXlvVZhmfo54OThNnl1qcZB+X2xfVXRBXGuqboaNw0BggYWXk4+nNDpHPC8vUTw9NilESkBQMjE7OUhxSEQyOzA+OUxDNTouR005M0RVV1JFR0FodEFEUk5GPERHQD5GOzUxQTFJPiZRPi5XgDgnOEhEhl1NSF59c2xaTj9OJiQ0Ky4lKDQ3EhlbWh0fLi07cS0gRm5ki4ORp5SbyOn5mbHBn8ufnXi10tPf8Naxu/P2/JWfiHd436dwXteIkVBMS4FthXyTw5GIvs7F0bSxo6PK4eOC/4eMkY+H+/uDkZy6gYr+oF+FcJ+suMe8gKqIlqH3g3BXRlSRR2kyLU9iLStCTVF3cmY9Qo9vfnlVby9GjFp3emx1YD1PNFhOR2I2ND1QOWItXldLSmJeRzw9MzdAN0N7VFJLNkpDSjdpZl5kM1BnUB9Bj3NzRGSQZIxfaF16Z0s8P0psgFxVbWVhrF5uOWOKf6JnREZKSjlYgE9AS0xIP0Q0Nz83QXlkbUZIRUZsYW11RFZiY1/Hp7xlTUpAXFJFVFk2MWtyfX0wVD5Zao5OeVdebZVfSlJSXkdCUUU+UDt1TUs/TXtjeXJTan5GckhwgYmDi4eQkJWGedqXkZ5fU1aPdGJWaT9MdD5kV282aRU2PE4uZT1KkG51gIRIYklnYDZLQm0yRD4uPkhBcmgtWly+u6Cey7/HysfN0srQzcjIw8bIzcjOzdDM0tLS2NbT2dbZ3d3a3N3f4OHi4+nk5Ofm5+nr+//09PLnjG1RTHVZVVheT1JNlVpTWF9ieFVeY2ZRWEtVUGQnNlhYWy4zcjxELTZfOCxOPVpygDKbSUQqICc4XikwRyxaP1BMNTQZLkIsRLOteWJSUlYyUUFSU01ZWy9WTpt0blRLRlKRlpZ5S0yChYd+hIl1dZRSmVZPkZNZWF5eYK+hYGZhZDc9ODRgTlAxMFtObU9wKTQ9iD1GNjg2bV9aX1xTWF5UinN0Sj9ZLy02Mi02MjddgFJoXVNPKENBR0szSklGLzhTU1dcT0ZAT71JUkpMRjQ2MzBlTn04S1YuOFNVY0xZU0pSYlp5UEKPk37et8ephIHdREmGU1xLS2qf4+z6u7GQkMGvoqamcVBZMFlVVVJHP1CLi66/0+rwvre9yKbnwrPD/ZK4xPXOkp1fonS+aZOYgGpyim9qe4abgI5yeoB0pviLcXSEtL+adZT/tq2ePjg0KjZENTBGMSQgKSpAJCZHPUxvU2tOWFxPaY97g3h3OFpjaWN4ZnVZh2BiRlJeSVJgO0ZEaWZ1dExlkJVdTUR1WWBpZmZnYmxnUoF0VXRxaURddWZcgImLSzQ1X5CVW12SiHwBfZF8Bnt7fH58fIt7CH18e3t8fHx7iHyGfQd8fXx8fXx8hn0FfHt8fH2GfIV9iX6CfYp+hn0HfHx9fHx9fIZ9in6UfYJ+jH2EfoR7AXyKfYV+hH2MfI19An59hX4FfX1+fXyEfQJ+f4t+AX2HfAF7hHwKfX18fHx7e3t8fIZ7gnyHewN8fH2IfAN9fH2OfAF7h3wBfYR8Dn58e3t8e3p7fHx7enp6hXuEfId7CXp7enx7ent6e4R8AX2NfIN7hHyEe4V8g3uJfIJ9hHwHfXx8e3t7fJF7AXqFe4R8BHt7fHuMfAN7fHyJewp8fHt8e3x8fXx9h3yCe4R8CX18fH18fHx9fIV9BXx8fX59xnwBe5B8CH19fHx8fX18hH0BfIR9BHx8fXyGfQF8hH0BfIV9AX6EfYd8AX2HfAR9fHx7jHyJewZ8e3x8e3uFfIJ7hHyEfQV8fHx9fYV8CX19fHt8fH19fYl8Bnt7e3x8fIh9hnwBfYR8Bn18fHx9fZJ8CHt8e3x8fH19kHyEewV8fHt9fYZ8AXuFegJ8foR9BXx9fXx9h3yEe4p8Dnt7e3x8fHt9fn5/fn59hX4BfYR+gn2Ffg99fH1+fn59fH19fHt8fHyOfQN8fX2EfAF9i3wBfYt8gn2EfAF9hHwHe3x9fXt8fYx8CH18fH18fHx+h3wEfX59fIV7AgIEAICxuo/NoIeTluGjz373rJyFopful5vq0OHIwt++osef7r20qcK1voy98rrDmsS8f9OBgruMtqyboZKcssmrg3Ka8IHAvPrk1q3ppJ7mkaO2wuSDmsXFz8KqssS7k4KGiZ7Cl6ehko6ArOeSt7S9wbSxjKeNsrydrrCMiteApKSitIDKpL/wkuvy4+GMiu7gsIve4ZyrpaiAwb6Co4n/hrSWj4q2x+f74cnPgOySoL2hlLJydHB4kHvmsLl/poqsvMGgjYCVtcDc2f+Bk9fexrCikoLH9ZChuqmGj6O/gJGUmqCGe4F/mq+zZmtqbG3GaW3LpLNzbriPhL+guPGt2pWzxoDSy5aDtJ2QhqrFbaRzb6Njt3R4eILFvJqIlZK7nLrDwqq/74jewKibuYOXlpt+dXBucn+Cpm900HKGfoOWjo912nhodmyqvsKTkG52dqGWpoOC56DcsoaSq8m5jt30y9mFx8KWmrPh0tC5koJ/dLPSf8bqwJzHeKCjnZRlicClkoB6cmp0dHBszpNjp4mwoptpkX1ku7aRj5anlpeRimmiy36JqLiQq9LU5aR8euSAusV0w71jpYBxZmyCfWlxe4aYZYt+lZKdZXKsrZGBi7F/dpWdj4dlkoOBcWxrkYd1ZIN1e5artKHCw7Jlqpa6s5DJt5OM0rSWj56Wh8uDmnyRzoC7gqScxpa6x7fbmId/3YeRmHbdiZJ50ZjGvZBlbmpqc31ycXBmaWN4XF5qa2drXGFwX2Nvfm58kJ+koJ6AYmplZGVxaWZnZm1scoF/rpF7rXl1pKt3f4SNhH58yamqoMuVsbF7443ZvdZ8gX2YkJWb+cjs83/jlp3N3Ox74aWbp4CWuvSj26CNruac8Jvm6YvUwcmrl6OnmMji1cGyib3nzI6ZuJmI5sWBz8GH2G/LgXB+q7itxXuNjPTt7MXEz6ixs5u2r7G1lrig1H+yj5SSk33quaKL08fNo4fp19PzitiGjtW3oXzcj+/asLCKmbSaq+G6xJ7e3YmiraOhfXrp0oCjfp2xz92ap8C+qYrqoYCuhMDyh8KxfXiBsnnbo3t1w73EqHFye32KssSHnczFc4bsnZnQn7V0ndTS+HOPxu/jzZiXjYqpmpOCep6voH+MxpH1ybu6rua+vKSCgoeRgYN8yraqpoandqF/dodUbWSAR4NQVXiC19/31dSzoauUo4Cay8C9kNnXueTU6OSPkp2gnPD99LSrq+1kWaZuqYexnYG4sbN/jnvVs4uW8taEgKSApqGqs8Ca0/3ylMWUwrOzt6a/g6Cxh8atr4DawLbNopCZiqGklIfl2sic2M2bzMzVrYa3q5+skP2D6PbSxLKi1vX2tJziip6a8rDAwLyfyoCluI/ApXl/kNaSwoLzkH5hcnG+aXefgnhsboqPhXRniYeag6+0sXin7ayxfYKMhct5fbGQxaOPm4uRrOXAhYGq+4XGy9bBuq7efYHQd4yJsb5+g7ehxcazt7/MlouPkIyTbnl1aGdpma5pgoGGioCBZ3ZggoBrcmlkYJVXa3FugICOboiuYqyvpaVlYqmZgGitsXl7eIJXgI9jcGLFY4B1cGCKl6CvnI2Va9eKoracoMiAgnuFoYfkpLmCsY6vv8ypm42mytTr4vJ1frnavKCRg3Kw0HyUopuHjJy4fZihqbKXhI6KqcbMc3p5fH3hd33hs+OJhuvAn9OSlsaTzI+sxIDVyp2IxLWmmsT9kdmRlMiC5IiYhqX75qKTopWqe46lmY6RjlWopImLsoChpMComo+RhJWdyoGD7IOVho2ojpeH+oeCjIDP4fa6nJKGhJp4tJCC0GyJeUJakoeDa9fu1vqV2d23v8Xi3t3DqH6FjMvUjO/5ybXygZ7BvL2FqvvZwYCnnpmUg5uW7t2Bw8b12seRxLaC3+DEw8Tm09jUoYO33JqqxdGrw+Lm+6yHhveEy9yH9fOC6b+joqm+taSjq7PHi8GmwcvYiZ7Z27qhqM2jls3Xz8KKsqSji4aLoqWPhKGMi7Tl7dr5/+uK7M3818368a6d9cytqrqrouiduZil6oDdmsW77bfY4871qJGH+JSfpYDok5+P/Kng8MWSnJacorWpo6WVl5CgiYycnJebipKikZagsaa1zt7k49+6lpyYmJqlnpudm6OjrL253ryv356VxMePl5SyoJ2f8MO8q96xzMyM/p732eeJjYmekpml/+P99YL0mpzc8f6C67eksYCbsNuhwZmHrNiT5pLX34PLuriql56ce87R0se8lMLx16Cry6SV99SHwc2U+ob4nYmbyN3R4YeXkfDp28vI2MLKx63MxtPjttq19Yu+lZual4PuuqaP2dbYqY/26NL1jeWUoffgr4Hnkvnsv8CYq8qvv//I1Lv99pOqsbCph4X75oC5krHC4eusu8vIq4/6p4euhsv1jszFjIyZ4Yn4qI2K5+r42oiKj46dwdGUrNrQgJD/o6LqvdWBpMHB9YiZ3Prk0pCOiIiuop+Qh7TJto2WrXzUtqWgp/jRx6yQlZ2VjIqB4tnJu7TphL2YjaFskYeoX61oapN4trzPs6qUh5OCjYB+p6CbeK69mbesysNzdo+Uoc7Gz6OYl+BtZ7yByJ7Os5Dgy9SYnpDsyp6e8M1+gIV6rKuhnaGNut7Wg659ppeSp5O/b5KbcKJ/eV+tqKCMYnuHeZKPbFWUp7OQtJuUt8HJu5nLwKi1m/t7193NupNlo+75tHaPaWxqsHShpqOZwYBibl5uaEBEPnlggUSCXF9HWV6nTFxoSzc7QFVtUUNBS11nSWx3bUJuknSWYVtqlsFwZ5ddnVBHZ1hQRj0wKSQwVytEVWZkV0dSNy9XPERSRGUzNEtNOEI6OTE+MCs0Mz1aQ0lFOztJem8/TU1SVE5NPkE0R0A0OCwoJ1ctLyszIYAzIy1SM3F1cHVIQW9oWEI7Mi44NiokLDAjLBc2JjAfJykcOk9TKTIsSsWDn6qQrdyQkYuXuZ3pnqtpno+tusymm5Cz1t3x6dhjY4yqjWteXEBwdUBgdn5PVnCbd5qqtsGciJeTtNnsg4mGio37iI3qtcVZg86CluqNfKOCyoymyIDbzaeNxKh8SmVnSFU+O1g6XCsmJT5uZlhDPkdsT1Z3aWBlUzh3cVhbaz1FP1dIRkRDQjw9VDIzXzI5OENSTUo2XDMyOzJWcW1NOzEzMj82WFVel0tcXyQ1X2ddTJCZgo1KbmRGVW94eWNkWlRXUJCfYZzHhWJsVHNrR0o1RlZYVIBEQDxCQkJGdlw+aF9+cmI7Q0I7bmdPWFRcYWGYa15zhD9IQ0k8VGhdT0IyNWxBYFxCcn5Ecl1UWFZRSlRNU0VLQlFFWmyXTUNaZVZQZV1QNWtqXVJIWmiDfn+Ai4uJhIyLjJCOaGJ/nmo3WV5qXnGDbltpOT9IL3JTMkkzYT1Ef0J7TWNLcD1VTmJ/QSo0Pic6STVuP05EqLGX2L27wcLFxdHJy8rBwsDIwMPJysjLxcnTzM7Qy9na1tvh29bZ1trZ29yE34Dg5OTq8O7R3fGrX1aFhlRYVlhRT02UXFdlXjxcYlCOTmhYXDUuLmA9SzeIfmhkNF4+QGRXVDVYMjVWYpg9MywnNiVgMEspXoBETFJAPDIuNSCbkVlWSkQ+RUJDRlljP0pIIiFWY6NNkkA/R4iYhoJRW1SPm5qTjpSIg4R9j4eGmoBvd1+eVV43MS0uLWlMQC9WV083Nm9eZV8zXT5Cgm0+Ol44b1pTTlJZUktOgHuES1JQMjA2NzM1NGBaR0dGT2FaRUlWTD84ZzcwQjlbYzVUZUNBanhDfWc+PHJdYnNGPUNIQlJUPURYWUBHcEpehl9dNXGlqf6rcLNyeHtCO0FBV4BVS0VIlvvrucCUa8SokItuZ0lIQTk8O0M8Oz59goZ4e6+J6b63zJfPxt2H7ZGSynOepLSXiX90hHh7aomJhWeTr4ablLixY2iNk8fLqr6ekI7ihIDsodlpRDosNTo6JTctOTotLk1VNSVBN0pdaVtNVoOou3OSXHBzbIBvjVZmbDpQf15SQnd1a1Q7SlFIXF0/OmRxb159aFd8bXVlYm1rXGhdf0iQjHZwYERokopsXF9RR0h9S32KiXSHhXwcfX19fH18fXx8fH19fXx8fHt7fH1+fXx8fn18fIV7AXyEe4R8CXt8fHt7e3x8fIV9B35+fXx9fX2FfAR9fXx9hXwCfXyIfYp+A318fYp+h30BfIl9hX6Cf4R+jH0BfI19AXyGfYZ+hXuNfQN+fn2GfIJ7iHyMfYV+EX1+fn19fHx9fHx9fX5+fX19h36EfQJ8e4R8Cnt8fH19fXx7e3uGfIV7AXyFe4x8A319fIR9hHwBe4R8g3uGfA59fHx8e318e3x8e3t8fIR6jnsGenp7enp6hXuOfAN7e3yFe4R8gnuGfAF7jXwLfX19fH18fHx7e3yXe4V8hHuPfIZ7AXyHe5p8A319fIR9BHx9fX28fIJ7h3wBe4R8BX18fHx7hHwHfX19fH19fYR8Dn18fX18fHx9fH19fHx8hn0GfH18fXx8iH0Dfnx7jnwHfX18fHt8e4p8jnsGfHx8e3x8hX0JfH19fXx8fH19hHwKfXx8fHt7fH18fYl8Bnt7e3x8fId9jHwDfX18hH0DfHx9hXwGe3x7fHx8hHuNfAZ7fHx7e3uEfAd7e3x7fHx8hH2FfAF7hHoFfX59fX2NfIZ7AX2HfAZ7e3t8fHyRfgx9fn5+fX1+fn19fHyFfQZ8fHx7fHyKfQh8fH19fHx9fYh8g3uMfAp9fHx8fXx8fH19hXwIfX59fHt8fHuMfAF9hHwCfX6EfIR9A359fYV7AgIEAICLv5ir6JnByMLGnJh90vDTkuyquPOJ1I2ntNmCwvGGitCniLfry8aSspiz56qUvMaO0YOA0fm6lr3j581z3X+ew8nfvovRkcHchP73hM+u5qqmw4zCw8nErc6Lyfjjg4KyrrOUk+antfOUpaCnpqq/p6Hvs4iZi47ijJejiJmgtYChqr/Wp/2Pk4mD5cTCnqO45cWDk56WloCM94qaubjVu/jEn5i/nrK+rZvAioePpLzCaXV2fYCSvbyM6b2Co8G9nJatwLynnbr056bKtfv47sadt921w/ji9pyeudaCeYunk4Hi4peps8hqbMpnbG/Mta+xbmeAwa22wJiH9NSXqYDc19l/wLXJonqJbp1wd9CsoHCHxYByw9/Bv7XDyqGGrZG63uyfgenXyLN9h4B2Y3iCfa6ptX+IyeHVlK6hicrDyH3egnvPrKmdoJKdg7avnYPDzZylmOTO14iv3rzUpXaLhKaczK+7op2Qls2sx77u4o+Pen2T3HyTiYhsdn97a4BYsa22XH12fp2dmnidon+ojIdqbYqwmJenvKlqwK2FpoKfzbCLzPrk3oTkg53smWaSaJ+aiIV9Ylp5f2xohaSObJ6Ohbe6l3KzcMF8hHClkHmUkpVkiJV5anl9gYNrgpmTco29iGnEdZ3HtYqRjH+eYXeJhZ7RbYrZ1Hq32JR714Cbi8aR0L2Mv5OAtHh5l6GTdaGpe8KXvNV+mX1pg3WSbXNobGxtbXaSa5Rzd8SkdnJ7ZGORprGRpKWhqpaQZ21yanmrkG1ob4CMinZ3p7S3n519cnCFuY5vzI2NxoqTuHmIc4SqdIWZmn6SsZih0GzpyZfSiIWRgO+3ko68mYiZ9YDiyJje0oPOpKWZlsnSiZ2koH3tpfnkhod7xprQy7G2qpOOo8Lh0o3AkYXApNZ1haaKrLWj2K+VgPf7yd7jwKac03rdnKSJqbGiepmZke3NztKAv8OPh72AqIqGjIidh9ji06R6eIPep3/ExKecpJZ5ibGSkbnGdJOYq4yb47S/vIDc3ZSSxK+Uq8yIr+x5l5GfkunAga6VmXZ5wLe5d2q9rattoLrU1tNxgLZ/2cp6goq14smNp67d9cfcpbXCs+r8w+X6koSO98qWu32CmXZ9yJyayM67n47Pxd7wnqWsrLykxK+ZfXR/l4FxaJBfWmZjWGGQX9Lc3croqr2i36jD04CLgNTU7JbsprKMrdLUxr24etKW6KiYr7ZmclyOg5KRvXerrKbYiYXYmZ2i1oLK6/2+pJ2YmNXfzPLUzKbEhar1zvCrn6j5jsS6ic62x76N+eP8mfmLwMqI+OrAzNWyw57Q8a2qv9Sbo/mL9ujbuuGfxZGv9qWkqtXvvJPmp7Whn4CGxZuu6IzExMPKopeC0MuhW56Dnc9muFZHY4lMo55NUIZydKPiwLiKq5660Xh2rch2xoiCtt2insz1+tiC/o60wbLfxovamM7yZ9XKc7qcyJmFlHGgwLbOrcqIyPLleIiSfIJpaqmRmq5pcXJ3dXmLdnOte2RoXWaqYWd2Y3ZugIBvZ4CjdrRpbWReooyMdXSRoYFhbX91Y2hwvWdrh3uRerSbh3yOd4OGfHW9lJCZss/XdX+BiYyfu8Ka/r1+pMDDo564y8CmlKfQwpTKsPrl0a+Wuda2yvHn+J+mweiPhJu7povy7aS/yuF2euZ5fH7qz97bj4Km88jRxoyA8tKRoIDX0cuEy73eu5mqldCGk/XQxIyE6J6M7symu6etsJeIo5PCycJgV6C6tbaGmJSKhJmVlNHCxoaIyOzcnryil9rQ4ITwlJr3zdDEyL23ic/Htn2tsYh7VZ+wnk52vMHVtI2Wjr7J7bW3r6KZmeDO1sH77qOTh5Ke4Ym2rKuPl5+4pYCD/OHwjrSemM7K1avs5bHhx9SglbLi2Nnw/t2b+d6auZbD5cyV0O/5/on4k67+sInLiODhy8a7jZGqr6aXttC+jczDufHsxYzdiuiYpZXiy6jMw8qDqbWZiJiclpyDnbSwhaj3qov+jsn9677CubHOgZWglrjdgab+94XL/qWa+oCpotay9d2d26SQwIiDp62hgay1itanz+eXuZuSr6DFmaGYm5qgmZuulMOfpfvap6GskpTC1ObJ3djW3szMmJ+jnKrVvaKcpLfExK+v0t7zzr2ciIuj9KCJ/qyl55miy4SagZTBjpOnrZSh0K+k8YDr0pXUi4yPjfnipZi4qpCe8IDit43jv3+6lJeLiLPCiZ2loojxpfTikHuAyZzX1ra2rKSgsczp1ZjCmY/gyP2KosSmyNe98sCkh+3uwuHo07Gu6ITysLikyc2yhqGfl/vb3N2CvMGTicaFq42GjoifieHw47WNiZbpqYXQzrevsaWNmtmwq9bfgaCjsJin+sfV0oD08aOk1MCkvdmVuPyDoZmmnO7Oh7yjqIaM69nXh4Dq1dSDx+r39/uGlcGL+uqIjJS299+uws73/rvHo8jEuen4xuPzj4iO+M+h1o6Uq4GDs4iJsLWnj5Pi2+zytLqlpbyw4ce5oqSryJ2Ieah6eoqHbHi0d9W6uam/k5+GtY2ys4ByZquv0n3Fh5N3m7q7p6S0f7t2vJWDlLNxg2imqbWp0IbR2sv5lpflpKGt1H69xeK4l42MeZq5stSeh42qbISwmLh6eXrGeaSnfbWdroVl6NDti+dxd7VnxtizrKChw67S8cK71eCrsf6H8uTbs4ZVwI6s92pjfI6jgmvJjqWcnIBZcGNpgEZYWYN5S0tGdnNhQHBbToxHdC4bOloueGcsLllMQ1+EbmlIRFuJnllgl51dpHRYcGhHQldWTDopTDI8ST1HTE1MMT9OOHBsMzswQyswTkBAMTgyK0I3TUhMLTRSTEw8P2d1fGo8QkVFRERQRkNpSD08NjFNNT0uIiU3JIAmJytDR3hKTkZBbFxeNTkzIx4hJyUaHxQgMSUlODg8IUg8HSQ7MSlUO0yom56mvd/sgYeQmZyzrKZzxrV4mrO+n5y6z7+kiJevoH+9naOHjHBRWHNecrKdnnuLtfSWiqrMsJDz7q/V5PqBhP+Ji43+0LWRdF5mxdjXnnp+98mNmYDVz8GJ2bi5bT9KRlM5PmxcSzgwSEA8fnpZSVRvc2pseWqenJo6PGyBfmg+RktFQUxLPUxMTjg+TFxbOUtCMmBoZj90NjBgX1xcSEpSNEhGTF+cnX1jMV+BbjFUioeUdlVZWWtlanJWaF5aUoSHmY/EpV9xVFZzpFhhWlI5RkNRP4A3bXJ+O0ZATFFXelJjbUhMODxCRExYU09mjHVbvrJpdFIxPTkqZo1HVS5LODSXXUJcO2ldW2BZPz9LWE1CRk5VQ2hMTXCPc0BtRZZTTSltWldqXnBGT2tzV2B1fV1meY2Rg4hxXkt9WVl4b0JXUk1dP0VHWUFTOjxfXzJfRFQ6gIBVZ6s1e2JGaE1CRCspJzs3Jz04OYRlrWwoRny1vLbAvMC/wMHFvMHLvb7EwrLAycnPyMrGu8POysbNy8jR0tTX2djK093a3tza3+LjrJjAl2ZWVFJZoGNPkHZyk1hlcjUxJ1JWLUouKSwyKDJYUjJcckt0KCw+SWRTMCgtJjc0a4BhTDhyJigxJig1LC8yODYuMixhJk5jZEZGTkxJSlZGQUQ6P4tmQUdFQUeEfJhWW3RThIp2fWpaTp2fjKCXjH51jUqNWFReamhfVFIxM09UT1MxRUw3NlozPTg9MzM1L21YVUI6Pk1dOTdldk1dT0lERVFPUk1QKjI5MS8yVFBKRYBWWUhKZ0U7SVEtN2sxOTM3NmZMOUhCVDpSc3NqTTttXV08bXd8d2c8PVA8Z2U8QFtnc3VkaWWYpZCpocVkZWB0WlhiOz1DaWNNem6/3Kiklnd8oqOTdkNOSFBrWltgYW1ienZiW2FtlqOvltClscrEjqj8p+mYn5Gph5B3oICoo4BkWZefznC6eoRul7OynJ3EnsFmrpV+jcmLqIbQVEtYRywxOS0/Ly1NPD86XDhNRVJMSFReUV98kbB5WHmBWmJ4ZnxRU1WDVG9XYnpgcFNAjoScVpM/THdBioxva15kYkRyinFqd3ZkZppUlomCbU8wckZIfEpDWGJuVktyYYRqWYV8HX19fXx8fX19fHx9fn18fHt7e3x9fn5+fH1/fnx8hXsKfHx8e3t8fHt7fIV7AXyFfQp+fX59fH19fXx8hH2CfI19AXyEfYd+BH18fH2JfoZ9AXyLfYJ+hH+Ffop9AXyGfYJ8iH0BfIZ9hX4GfXt7e3p8j32CfIx7hHyGfYJ8hH0Kfn59fn5+fX18e4R8B319fX5+fX2GfoV9hXwYe3t8fX18fHx7e3x8fHt7e3x7fHx7fHx8hHuLfIJ9h3wHe3t7fHt8fId7hHyFewp8e3p7fXx7enp6jHuGeoV7A3p7e4h8g3uEfIZ7jnyCe4Z8AX2EfAl9fH19fHx8e3yXewV8e3x8fIZ7j3wFe3x8e3yIew58fHx9fHx9fHt8fXx8fY18i30FfHx9fX26fAN7fHyEewp8fHx9fX18fH18hn0DfHx9hHyEfYJ8hn0FfHx9fXyOfQd8fXx8fXx9kXyDe4t8iXsCfHuIfIJ9hHyFfQF8iH2IfIJ9jXyGfY18A319fIV9A3x8fYV8CXt7e3x8e3t7fIV7hHyCe4R8h3sEfHx8e4d8CH19fXx8fHt7hHqFfQZ8fX18fHyOe4h8BXt7e3x8iX4MfX1+f35+fX59fn5+hX0EfHx8foR9hXyEfQd+fX19fH19hXwBfYl8hXuLfAF9hnwTfX17e3t8e319fH18e3x8e3x8fYl8AX2EfBJ+fnx9fXx+fn19fX5+fHx7e3wCAgQAgIKA5vCZdofc3ca2r7SwydCHn7CAjKm9xZ7Sh4mQ+Nn19oucn4v64Pyh9oyNg4zU1diPn5fPoL25g+6Rx9Lv7ZG7hoT73q7EgsDPwLR9uaiR4sWVkJS4pqXK87uIhufDlpXE69aSoLqGm7qlj5uk2caei8Sfx6SxmP6RqJLw8Z7AgJ6stfiat7zd0Na/qZ2B1c235KvrkayxmNOjkuC3yKKu25GdnIyNsaamm8X4jJqbo7C51Nlzc5WtpojiipnH5KKFhZCjs7K029i8oqqE4u+go7yZxMOZotuA3KB7epaem66qfeLXe6S9rrbCyWhybmx2s4fXg32IxW/syreTyrH+gJenwaDVkZO9nVmrZl+0a4Owb2/Zn5qDnoDgi6KftIGqr8mR6Of2hKOsoKfIxGt3eK+td6jx0qXOgL6WpqmrktTRi+CDgWbfzqawf4aVxtnr7bKBsvfjuZjpnaHWz/SSqpuXi6OQpZmbrY2AyJe/tXznjZ/Irer2i53Ee5KSnGplgIOOj6GecLOus62Egmyyi7+Vm5CWjr54nMejl46BgGypnJi1o+7N4dnReXd4xql3WoqQf6KGeGtoYHF+gnOGrntnk55ok6qpfYSqgodlqIF5iouHgYmpqb1liY53dnCIiZCOgoirq2eTkpCBg3Swn6hjZXF6foGVi7OLn7PFy3t4gITSubDEzH+SnKF8dtqT6a+VrrZ5zeLG0Lt4d5+ixNNubWNfbsd/fNGMk6G4lL+4wrWdkMPXcb63taWqwauXg7ezyZ3A0ra2ZnG1qJmbhIJ2epeFf26Wo5SOlbvJkZGGfa6ce3F4h4rFmsy8gd24iODvmdPP1oTNpNuvnLHv6/G2gI6X7J+WtKTQkI3JiKnfwcOSwPb4uK+6792vy4LQhcTCxoHqiq7bso+C0sV5eJB5ipermcjXsazYz9zIkJzzmIWFos6xjXeRnJ92tdzR2qyaxYmqjZfxpK6TiIylhIrZ3tSSk3x/1oycgtawpqWlk4N/m4GQknjfceqD5X/kpJbLgLqnnoWcvM7igMCFe6eexYHs4qnIqauSfbGew7KXn6itvb6ssKp/fqmG1bCIvOPb2MvKuI+hrZeUzbCntIeWz/rPsN3XiInPxq7bcYh6XmzU9NChtpF9ea+zuH3WnaCIj52qlpqVl6Nno2R3cGxgaWhZflXUtPTKro3q57KRi5aGgIDbxY/N0dLJ7Y2B34Go1KOEh/+Z9pbI+L+McoqG1Iqwy7ynjmvRtYOyiemttdieuvqa89mJ9tPRbGG8n4vqu6mr1Za5ie6sydKzsaGao/vx++nf6PGFu/C9yragmPyOoH/Xnaip3cp5qo/7wd+9oIuw54PGnbjBvoeKgKvA29j6gH983+mbg5vm8syxqaKFlZVXaaBye5iuwodsSktbxHaam2aNj5Pd1eqX9oKEbHe2v855oZO2lJrLhvapwPDq+qfFk4zlvpTdd760wLyAtpNwuZt0epGnp6nW/MKWjtjamHWXr6J2lbptbIN0ZG1ykYlvZI5yl3J2aL5vdWios3qIgGt1fqVqg4aflpuPe3JgnqF9mILCdH9/Y5RsaLSAgHJznGx2dW5shICAd8H+l6eorsHK6Ot7fKG1tJj2jJ7N3aGMj5+3xbzD5d7FsLaN3tyYnrmbvs2pseCC5amGhqayrsG8iPLkhLbUxc7e4naBfniI2Kn3np6g9Yf92LKV0rD4gJaquZrgn6XmzYP4iYL2hJXQiIP1pqWMm2zFhJSOqXSgorZzwcqqQGqWl67e54KPkNzNiK3ar5jNfr2kurzGrfOocuyrpIb73LXLlJGe2PHq1Y9yla52hmaJcIG9xfuctKagoMWkxLy6tZSG9b3Mt4Tui6X/xer2mrbdiLa/0I6DgM/FyPf+jOvq28StvKDprtrH2svP1vmnxfTWub+lmYG+q7fUvPrW4uXrgYOC37+OgMjPwtPAuZukjKGvr6S916eOudSBruDiuLTamaSE6Li0x8W/oqvo4vuAqKeSk5CoorKrl6Xc5pjTvdK0oIzOyt2Eg4yPjI+tpMmVtczn6JeGgJD+yc3k8ZCpr7KFhPOh+MGhv72G7fvG992LkMfH5/6Xl4uHl/imnP+sts/tru3n+PPTvur9hO3i4NHW9OnPrubr9b3h+en6ipTm08jFo56Zlb2TmI3HyLumr9bqn5yRjtOyiYaHlJ7grNvZh9jNjNr+uejm8ZLuuumypcn39e6pgJWJzpqUsqXBhn+6gprqyMmV0fXxt7S059yw1IPSisHQ04r/jLLjuJCLu+WNjamRpLXNuN3pwLnn2s3Gi53yn46RrtnDoo+qt62Avd3Z37emzoytj5r5pq6Ui5Ckh4/j4N6go46S9pubht3CsrC0opWataiuoIT5gP+N+Yj2uKbegNK7rZavy+H0hcKMgbmy1on89bTYuLqbkNrE4dG5xdPZ3uTh3daOjL6W37+W1vzt49jizK6/yLmmwaShx5Gd2PvOueDYh4XUybf3hJeHZm+41bCNo4mEgbuzxYXTsqiCkam3rbOtzsCO0HOFhY+CjYp0m2TDncenj3TKyZN3dItxgGauoHm2sq+nxn91xHSSvaCAdM2K7JLB58GciaKb+aDT7ejHqYHfvX+riNSjqcKPm8V3zsVx2O30cG7LknbtxKqqso6zfuKkvManpJOFbd/l7uPUrcyKt/GNr6aDh/iVr4fbp7Ox5teAtIvnyd+eWV+33nm6YnCIhmeEdayxy8n1gGZcnZdtMjxxcWdOVkxQZGw8PVg2UmBZV0Y1KSk7okJcZE9fZ1+MgX5IumphUmibnrhilGZhRmhVKkIxPj5NUTtBMjdsZ05MJTdeUEAkNzg3SlY/QC4zLi1Wcz8qLUZUWlBkc2pahLdWQExIPUBGT1BDPFZJZjs4M3IxQSVZOCQtgC0lL046UFVpZGljUUlDU0AsNi4+JjUiGj8lGywrMSAoSCMiKjMuNVZBNZvnoLW0s8nY+PyChrGViWy6jJ7P0Z6SmbLO2MfO8e3Wv5JYbINaamRSgIhRZo5jjYWMj7bHw9TMievfgsHo3uf2+oSPi4Oa44nLhnRevmW2xbae2LH5gJuytZblj3WPXEJ4PTp3N0RVODFSTE5OY0VsYXtlcVt3dYlXmJxtH0hyZWyKgk1QSnFkQFNhVmdkPks7Sj8/PnBeS4NGPDJrc1NTOTs7TW2Rs4Fug3w8ZD9XTWaJg5xdamtdWFBTYVJfclNPjnuMiGyxaHudh5+rY22RUVhiW0A/gFlgXWNcOllwbmZdWEFqUGhAQEBNWV82VnhwYWxzaV13WjpGN3BgikpGKhweU21mPFhSUlhRV0FER01WXUtTSkRBVFA6WF9gUUhicnRDTlJnamJeS0uFeYdFZWldakV5g4t3mHh5gEFkXWNRWUhITmIyMT9FTy1WQjoyOT49djtNgHB/qFyAezpbREo9J1wwZ2YtMTIzVnClhl5JWKmhlqWytbOxtKiyvq9FQ8G1QbnDydHPzLmxW7+0t7+8w9HWvbvDwqy+xMS7WF2/vs63YldYX1pUWFGChoBzfYKRWmpcMi0qLTQwLC4/KFBGKkpZQFlgUmRcgj5SRV8xKTVjYHkxgDBHKygtL0NILTAlMCxDYEQqSUhWSGxlTXBTVClMIUBPNjuERldKSiNBJXZQVmpdZnp8dXBVRWCMi4+PX1eRS0dOVFVOSE1YW2RVW1lWVU9LVjNAOTthRDo8OEI+PDlbblZEQjY8iEMqLW1NR1RWSkFATkdHLixnL2I5aTRbS01OgElKUz5SWFBbKz0xM1VITTVkb0VXSlNNP3lZf2dpXG5gbmFnY2I6O00/XUw8XoaKjnRmbGRjeHtyj3qFtlZlWGNZTF9SOTpUWUpuZMKwhougtZR6lnE7K0RIRzx0YnRfZ25sZmlla3leo4Kfqcq3x8mg0oauh6iMf2m5tIBnZ4VjgFeYjGyxp6OXsHhxvnOHs6yDc7OC55fU7Ma+vM9sVzVBP0MtLCFNOyxHSXNTSlVPUGRLfnVPk5HWhIzrmW7/2ZtzZmF1U5hocXtxZmBRRJOOj5KJanA0Yo5cbGlRZn04Oj16bWdieHVSb054a4tpNzdkbUBrPk1hWjo3OEtTaJnNB3t7enp7fn6JfQR+fXx9hXwJfX9/fnx+fX18hnsCfHuEfAR7e3t8hXsCfH6HfQN8fX2EfBl+fXx9fX59fX59fX18fH19fXx8fX5+fX19hX4DfXx9in4MfX18fX19fH19fXx8hn2KfoV9AXyEfQR8fX18hH0BfIl9gnyIfQh+fn17e3t6fI99gnyLewN8e3yIfYJ8h32FfgN9fHuEfAh9fH1+fn19fYR+D319fXx8fHt8fHt8fHx9fYR8EXt8fH19fHt8e3t7fX19fH18hXuFfAF9jHwHe3t8e3x8fIR7hHwJe3p6e3x7e3x6hHwDe3p6jXuEegJ7eoR7C3p6e3t7fHt7e3x8hXsBfIh7m3yDfYR8k3sBfIZ7g3yGewV8fHt7e4x8h3sFfHx7e3uEfAZ9fXx8fH2FfAR9fHt9h3wFfX18fXyFfYV8gn2NfAV9fXx8fYh8AX2RfIJ9jHyHe4N8iH0IfH18fH18fH2GfAp9fHx8fX19fHx8jn0EfHx8fYp8EH18fXx8fH18fXx8fH18fXuMfIR7A3x8e5N8hH0BfIh9h3wEe3x9fYt8CH19fH18fXx9jHyEfQR8fHx9iHyNe4d8jHsEfHx8e4h8B319fHx8e3uEeoN8hX2EfI57AX2HfAN6e32Ffgt9fX5+fn1+f35+fod9BXx9fX18hH0EfHx7e4R8iX0DfHx9iXwMfXx7fHt7e319fH1+h3wBfYd8gn2Few58e3x8e318fHx7fH19fYZ8EX18fXx8fH1+fXx8fXx+fn19hH4EfXx6egICBACAwLHF28rJbtLPe6OKtJDWiPOKu+LAjaDQxaWw74+ti8mq153FgKzChq234OC/ppnR0Y3WyI/XxNum9rWWvseUgZ6j2bKI3IPE0ous1eh0vMqn2JS+m9GR2HyMcYLmrcWk/pmPh7ra+4Gps5eVlIiPioiA89fBo5+urqWpop2W/JCAn6SbgLb4mqainfnT79+mxtrHx56QwrWmm4DJmavDuaOmwMbC0cOioqTGo5Cks4GVmLXPfYJzlpCUgu6jjblrsp6tsbfJvGnGq4nG68mkx+23uZmOrdiA8t3L6td8goWVp6aWq5+apb6WobS+y27GsbvCd7aUdoyXv9HCoILaz9+AzaH6+2y7t5Deoo1oannFz7iGvOrsitK/orufv4Wef6PHn5mg+IrvrLmsjr656pl3muKKho7x3OiLwJ/Lqc6yg4fWs56bipiP3pvem46NcObcwaTWho6lidjLkZj5vcbJsqi3s76ziuTchdfNbdKjpZmmqaW8fZ6TuLrAlYVsYHuAiIBnfIyThWCPnpOQh4R0u19ngrGQwKWLr3hyp7uOkW96lJTAzMbS4HmJw4vcgZ6jd3CAmKR3VoCPjHydgpG0oXCsqqPTc5KadIO5oI20dImGjLKutpC4nbXBarRqwX56gpDYfXB7j7SUmoiBuIiPfIR5e8OBdY6AmbB40YGv1emAtXJ6x3WNxKfTj3akeot6p7Cbr3h43LyUd29udXN4jZd+W1pupNfAwHOXfHmO4dC7vrzL39LTdKrD1czOxreYw7yulK6uwsC5qLKyypyT17Zlg42fs5iSrZSxwIB+tNGeyX15c4GCg+2E28mTlJClwXalgXucdai+h5nQisGW8cKAzYjCgKGNmvDnupaQj8uerIbCzrGVoH+XhuGy5pSM4/HLs9uE5dW4wdSL3I6MutW31YKuq6SCt8Sds/PRn+i0iO3G77t9dnWbm42H64rnnI+AmP/pgYGPoe2JkvPvx5zGzr+q38iQtJbG3KmQnKKvj5+kg6F3fqzcpcersJe7iZCAiZNzk8GOjqWjuZfZnpugu7Z5sYvTkXrbxYKU2Y2XrpvGb8qyoLi/oJaDsIeGi+zN5L3FuZ6ClMuutou6xqCj3d3X4uDLr7W0gcCffW6ptGql2oarhXTDxL2v68zczc/YlnGkkXqHcJG6YW1qcmOeVIBVy4LTurC9iITqpIPnofCAmZWIhILx8Njh+cCVjM6XrXqU35vWpJXmwHKyZ3SnhI6xhJipq56Mr8SwrvLBgYrGnanA7bu2m2yNfaxoZMCcoJ+2sbbBxrm/9+OyjZGMjISM8ZiPguWogsDdjJSh3pWxzZvYu7qe3Yv/sNuQj/jsrIWMxcrL0Zi5dHKkjpjvqYqA08jE1tTlg/DqiJljgFiCXZp5sdKkkabDvXlqclBjSnJmlX3JfKDOgqCz09C2fXnFynbK0YnNtdup+9Gp0rCqkKGN05N5omu4zoy34/WCxMWQ0J6+gJ+B0YOcgHbutsCLv3Jva5/g8miChGtpaGFlYmFbqZWJdm92e3R4dnBsvWWAcXhwWH+ucHl3c7qbr591k6SUnodvk3xxcFqOeHd7fX1vhYyOkYuFhYW1nZexxIyfocTbgYd7oJeriPerl8hyxrbDxMzf0XPav5jU/dCoweKvv5+UvuB/49q/9OWHjZCkubytwbCotNKns8rT4XzgxtHhl9q2jam50ubdm4jp1uCA1JjX9oTg5LfyzLqJjInq+u6m0vf5i9/SrLeUtG6YhrfGmYF/3nvHYIOcjbexyqiAt+qKg4Hf1taFqp7TtezJjJPCqLylnJWj9JvqqJ2njt7FhoakQlNrTYGseIvrw8fetabGvs/OnsmTfMvWguyanIiXuP35naGdxM3swbSSi6WA0rKRqr3WtpDLzNLGtbeQ7IiSuOjF+uK93pqf7e+kpIOUt67P2d3m9IOJ2KH8mtjmra26yt+xg6O7uqHPtr/n0KLg27z7gszmn6rl18PopcPAveHj383l0ur8hOuI+puUpbD4jIirwPDD0r217MbMo56RkuWVhZ+ZqsKI753R9veAv4CK3oOo68Lnn4S6ipqDq7+ttoOE382ulIWFiIOMob6mf3yJuvvc542yko2l//Xn8+zw//DzhMjn+PX7+OnC4+zZssrP5ezp09XX9s2z/OuAlay92sO4zqnC3ZCNv9+7+JGSiIeXhvmL5t+onpOfuoXAopO4isPPh5nsmMam88yA54jMe5eMi9HhqZWDhtitu5PQzbKlmYSSg+q54ZGQ7PjYwuSH79u+0OyY+6SjzunN8onEubaNws+ru+nKme2+hvDN8MiMj5Gvuaea+IzrpZuCmf/uhIaRovaNl/Xw1qLJ1Mi579egw5XM47OcqbS9o7W3l7SDicf9ueC+x6zOnKiAnaWBo9eTlK2owpnlsLOy0smBv5rwpI3+65Ce/bO92sjrhPPTx9nfsamWwZaTlP/j8dPf0r6gsuizuJLUzKao2uDZ4+HXu8G3itSoiXa4wW+PtIurkoHY1suu1LzJy7PcroHMuqqsmNz8fX+Dj3zEbKlpw2qympSVbGrDhWu/hr+AfXt0b27Px7275LCTfKuIsXuBsZHSnYTHsX3JcofBlarUo6rDwamZtMSvpN6pdYOnlJSn1KvKtX+XjZ53a7uzuKOzqrG7wbq039Sjg2txg3mI7IRrjOChh5fFeXOm5qScsZ/eyMOo75/+seKchfTHtZaOuLmRmW6cgIKznKP7qpGAaGdfb21LJ1tMMEdHYTZNP1E+XGRiQUpUaTw9Ni4+IkBAa1iCR1BuRniGloGAYWaikVq2hENxhGQ7XD8vNj44MEZFX0hEVDU6STcyPUYnQkpBckZeO00zOSUsJCdFQUVjdUVNTYDf41BcWEJCQj04Ojo3ZllRRkJITzA5LR8jUS2ALzI7M0pzTlRUUYVtfG1MNiQoJCEhHiE0ISMuISktKC00LiozRzY3SkqEjJG4zZekps/jgYyGsntsVsmpnN6A39HZ1uP87YHz1qLOnmpccnRndlJLXJleo4hwo92LlZ62y8/AzLSlu+K1w93Y7oXx1erziMqWaX+Odo/gmJT529KAo36+5XGzn2OJcl5BQ0Vsbl9FU1ZtT31dX2hxkVZpTWWUenBfq2SaN1poXHl0eWdNVHRXRV6vnJpmgFBmSElZSk5wWldKN0U4a05hPD5ANoGra2iEIy9FLlV/YWWFZHxzclt9XnRhWnxTUoV6SJVqfGNufHeMWmprgIaVbF5HQFSAZ1A+SFRaVTtfZWBaWk5OfDYtQFZVa2VZcGBrrLVqbV1PQ0REVkFgSCRDVTNncKVsSk9XVmtPPWVfWlVgVUtbXEhaVmdlTV5uP1+fameGVWpqYH2LlmuWeW9wO3k5fnqCgW3JiWNabItSXV5CT0lUUEFARGE0LVA3MzkwM0BCY5SAtzxZXEJgZkBeQz5DLS4qLTI9SixBw3CjlUxFTEE2SqSzqKdTMrK1rzs5UEY+rrKtxcC4qqerWZalq6y6x8qvubCvqK61t7ixrq+xwdOco5hJUFVZm41+kHyOmWZua5RQSyUrKC4oJV41ZlstL0A5SidSMCVZL0tMLCtOPzw5YimAKBkvKyMlIjWKLyIuLj4/SjlPUE50USUwJnVLRyAdTkpFWF0rWkpEdoY/kWFldWhmej5qWkRCdYR1gpZeL2FWLFxaVk5GR0xSWVZUnTVYS0o2OGdWMCw2N100M16DXU1qWVxMSEtIUjRKc2NQTlBSPkZKQT4lLVtbVVFWU1BbQ0aAPE48VEw1Lj08NzFOQ1FJTVA3SUVyTj9/hUZZo19gamNpLGhcV2BkQz5BRDk8VKmGlGl2bV9aXmdNV0afYV1MWlZWXmFZTFBVQX57ZJHw+IxujkZnPTFTTExPd3J+i4aZREFqbWBGRoHXg5Wuw6P+lvKKzVecg3d7W12xdGKveKKAcnFqY2LAuLSm2KqXb5yFx4l/m4jgmXm3rJj+jFw5NTQ3Jy9CQDw5SVdPXJFlS1Z4aXl9lnJwcoS9s5aeg7vx85Rwam1vdXFui3xoYEZPUU9SkU9ESGNNS2OOVjyLcjYzQ0yDbGdBZUWeTlJCUHhvZUxJZ3BbellULi5BNzlyWkeCfIR9I359fX59fX1+fX18fXx8fX19fHx9fn5/fn5+fX18e3x8e3x8hHsOfHx7e3x7e3x7e3x9fHyFfQV8fHt8fIh9B359fX18fXyEfYR+C319fHx9fn5+fXx8i36MfQF8hH2DfoR/hX6afYJ8iH0Mfn5+fXt7e3p7fX1+h30Ffn19fXyLewF8hHsBfJF9AX6FfYd8A31+foR9F35+fX18fHx7e3t8fHx7e3t8fHx7fHt7hHwNfXx8e3t8fn19fnx8fIV7hHwIfX19fHt7fX2HfIJ7hXyDe4R8D3p6e3x8fnx8fXt7fHx7fIp7BXx8e3t8oXsCfHuLfIJ7i3wGfX18fXx8lXsDfHt8lHsEfHt8e4R8A3t8fIp7hHwDe3x9jHwHfXx9fHt8fIx9BHx9fHyGfYR8BX19fHx8hX2JfAF9l3yCe4R8h3sGfHx8e3x8hn0EfH18fIZ9EXx9fXx9fHx9fXx9fX18fX1+hn0BfIR9EXx8fH18fHx9fH19fXx8fH19hXwIfXx8fHt7fHuGfAF9hHyFewV8fXx8fYt8CXt9fHx8fX18fIR9A3x9fYx8AX2MfIJ9j3yGfYZ8Cn18fHt8fHt7fHyGewF8hXuHfIp7BHx8fHuNfAd7e3t6eXl6hn2EfIZ7CXx8e3t7fHx7e4V8Bnt8fHx7f4Z+BH1+fn2HfoR9E3x8fH19fXx8fX18e3x9fX18e3yHfY58DH18e3x7e3x8fH19fY98AX2EfAN7fH2EfAZ9fHx8e3yEfQd8fHx9fX18hX0Be4V8hH2FfgN8e3wCAgQAgJWYkOrlwMnYxaGdzLvs6628zOOojoHdm5qgmez/jby8iLTr1/XczZbn3cvLt9isiqWMgYO79d718N/Wm5+AinqooYDa+LL8lqWVfrWw1IrRkMz/0tGFs9/X49bLjrK0gp+EqtbPuqrAq5PBla3MubaOkZSOgZe97LSZnpuNmaukgL7xyfKI8P+BhpKA17XlwN2uq+fNkJC6oZuSs+vYup2jkZ+gsJi9ucKuwaW5sYWcnrmzvKTnypHOkp+L6W2EpLXAuLqkpci5vrOCldOzl5qle6eblcLoe/P824jEg5N5d32crsi9qaa1k5Wlwb3Cqam2mIq3qqekoLq605qE5tm8gLjolYOVfMB1q52SaLai1sewf3Phw8rViKnIiY62pdPj9eeIi7r3nbutxcrjnvCU+MOavtCHo7qe6YqRlc59yoe+sNb9foZ3z7yUmXV7o26X1Kzr3aeo48eTsrbSvMaz3PfjqrPN4tXBo65lbp+diXSMmcKrkIKXj5nDromBbm2PgJCLhZiyp4p4l52OZm1hgpaXsZV2mJmJiGKWgnKfwKV2jmZsd8WyfJa1yrp90Wyngm5qy37Pkn3Hwm+SnI+kcI6yj7qdsnCTxnSTj46JhX2TbYiwfreDhZ6Do5XEeri+cGyFe852rbiCgIJ7qJ+oaHF+mHl4deSyq+uvpbeSkYm4gJ954LV1tYurzXiBtdLMhXSrxnjV2ZnDq9WTwrHhbquPjsB2eHF8lNenj5CKkqWGodi7t6Omi5CUrbe7xKOekLC0rIicuM3Hz6CtxG54Z3KkwMfb38KPl5uzcrdz4fSp1JmdmJXSdeOV08VyenzYjuCatbOzc87ZsIbpoY61mN/egIHUgYrsm+Op6IiB2P6ElMN+x6yStMvah7zGvPqdldLEgpnIg9WHzpTFsXh/m5zlzdbO64Gz4s/XjZGQjoHY9Yvq+n/wlplzkoSCnb7ye9iWhMnY8on4go6Dw9ba+7PIhdbp2dHisafc4uzIppWnlJ+pf3y9r9HBsL2jsp6EpKKggIGKgnW4lefUx+ud2pLUd352hJWFw27Jk76Kh6aikKm/wbWwrqC5x3GM0XaHgn7XvcOfkI95cX/Bc4zhpYrIns3U8Mfndcvg0ITN5cWUrpa2xL7jn5yysdTh1Mjcza+NnZWSc8x9lo5zXY22Y39QimtMkrvkuYeiw6CI842hpZ2ZgP6PoYyNj4bF35vI8du0loqT2d2y5oW34KW3dHm0mmy7kXVx7tuI7Xyv6Iuk8MWNt9Sjta7HrM2CgHKnoZ2DcmV1sLukn+K6uNzoi7DBzZfjzvCxltrZlaC2hunW5bOspsSRgeGwtHfQznfYef7w1YuOlrKhyZXx6tXYlnu5kbe0gJuBd+n13um74K2bw6y4tXa7wuWrhIfuo4uSlnaAUmxoTYO+yu/ZxYzk0rW2q8KQdaaAgYa359fy7bbNoaeNnYaagoDe4rzojrCjiLu4547gkdfxysGLveXjy+PPnKGmcn1uqMjOv5Khl3SLa4CUg4NlZ2hfWW+IqHxrbmtibX1zgI+pkrFkprNcZGtcoo+mhrKDepiPdGt6bXB1h5+YhnJ4bnF4hXGWjZeKpZOouI+oqcG/yqzpz5zXipuM6nmJrcfSyMq1ttfEzMGNndu+nKCogq+omcjxgPP36JPak6OCgIquxeLWvLvOq6i82dPev7/Nr6jdv8nSvcPO/ayB6+PHgL7jioCqkdeO69qrhd26/eHSloX229TViprFiZS3kczW4dKBhanXiKB4crelkviU/NSTtdB2jKSDwXCEjsqC64LH0dHqhI6H/t+prIKIxYymv464rmyAspJtg3+nj4iBs8WflZGmraibjsmImfHdxpWyvv/Kp4+Ri6P38r+toqqzgK6jtt358s6d3dy+l5SPpr7D4LKIy9rMxoPHlInH6ruKsYWLj9TFhJzJ1dWN5YTowquk+pT7vq/974nGzbzXi7zrtfnJ1orQ/o6+x7/Cw7LHn7Xnsu2/tNG+29L9mvvwjImfkNaD3OzEuLSy2NLki5Gdu5CPhfrIxPnCus2mnpLKgKOD+MWH0JrD8IWR0/bxmYLF5ITs2Jq5ireBt8b7g8Cgo++IjoONpviqm6CapsCav/ja1cXIq6+yxNjb8snAt8vP1Ka82vDg8cLK54GWgYvQ5OL2/9umsLzOgduE9O+t7rq3rMDggtqV4eGEhovjjOqjx87KgfPsuInus5uvn/jugJPxkI3yofek34B3wfiEnN6D3L2Xt9PnisG7wP6Zj9XFjqXQhtuKvJbby4iQra7y2+PZ9YbE9+3cj4+PjIDe84Tu+YH3or+OqqCZrc7+gN6fhdHl+In/hZOHyuDl/7/Uhtjq3+TuwLXn5vTMtKCzo7K+lJDaw+zdzNC1xq2RrrOugJGZk4DImvjh0fWo7aH5hZiQl6WU6oPqttqcmNDAstba5M7Qz8bi7Yaf+IqZj4zx1de9qKuYgI3fgJv2tJPQo9TV8M36hOL4443f9tWnwazGraHhprLIvurh0sjdz6yPmJeuj/KWtbGfgrfKb41ksYtgmqS6nHOHnoJrynSNg4B9gNp3hHh7fHKtzoq64LufhJCYu62m4X+rvJ/MhIbRtoDaoYSB9t1954Kwz2aB0LuHpLuRlaLCwumVlYCvn5+UhHKIvLafouK3vMDSf6CDxZXhtOOIg+PfmZ2mdMG82662kbOVkPi+1YT15YD6if3+96OambSuplyQ4/f+p5DTn8rMgEtVS2BRTD1PR1BeXk9QakRgZk9UPCpYTEZeXjc1Kjg7LV+hjXmHeFObjmpsbZZzX3JPUDhbqa2iUEpRJy4rLSk5QzdNW0VYND08JzE1Qy1QPklXUk80QEM+QkZLN2Z9RlBOnK7EvnV9fVNXP0RbUlI/QEA6OEhSX0ktPzYtJi82gDRNYGgsZ3I8PEc/cWpyVTUnLSEhIiIwLCcrLERANSgoMjQ2RkVDQkRGWFaau5etrcDG1bbk06u6bJKD2oCNuODp1tO+webN0ciGbnFfU1tWRmxhX3ePX6zGgXflmKuHiJnA2/flyMPjwLrX8uf51NTes3Wmj5yGiX6IoZJ78O6tgH2ebGWJa5pajXdfO2Vbb25dOTxwX2dwSlx1VWyMZIKRtbJoYIWzcHxRRHtwXqt4q2xGX1ddeIdunFtmUVgxW0RiYXJ+PzowQ0U4OC40SDZanXyOg0drnWdNXld0Zllch5NmZFpecXZoWHRDSGBqWkxTXYptXmBrZWeEfGlWRkBYgF5ZUmB3blpHWl5eSUVEUFpZXlVESlRMVlOaXVyksmdaQzEqL009KDpLYFMsbWN1VVFFkFCNY11ve01ZbFs/LVpTModveT5ajDJUU011W1lgTFpRYYltXl9oeFV4VHW0fnpySatzZndYU1dUUkZpQkVVWUU2MDB4P2JIVElPQzFPgJJfhVhISURDYyk9RTo2JidKWTeG1Eh4bpdyoWlhOC5HT5JLPi8vTKkoQUpBPEJMlq2pqKWhl5WXqKKnp6arrLKqqaeqs7q2s6Wor1teXmGPn42ZlqB7iYmdebJkllNtZDxHSz1TJkk2T1UqLC1vN09LWU5FQmCCViRRSzEsKlVFgCVENzNCP3Q4aysnI0ogQk4oTj9GfXxILGZZQUwxIUtIOE1ZOlwlJ0Z6d09UWlBxdXF0gjtDgH2HUTIwMSpWWSpRTSpSQG9JTkhGUVVcPFpQN1BVaTFcMTQ6TlFgeEhcRGliUEdQTUZPWlt2S0pSSkFMQztsQ0ZYUVxNV1hFW01NgDpHQ0BFM1VbWVA1XE2BRENBR01GaDp2cYdKWnt0YXRuX2BfXlxnXzdJdTw7QT92c3hsU1JPNDpeOj56ZEdtS11XXVVcL11fXk54gGmI9+f/kXxcR0VJTFJVVVZnW1FYXkhgWJk9RWNkVYDei6qK9cGIso6bhmJwgWlYrWR/cHRxgMZndW5wcWijxX+136ySf6msvJSf9IGin537oZ6mOTdmMSchTF1AZ0NYcUFhnn1Lc5VqZH6Whde2xqPIp6m9tZu5r3BlZnprgHN+VXVWjVZ6c5FTTHmATl5tWnVqmmJHND05NXBdOCNGVy1CMHBXZE5NS2BCYUFgWlFLMChVWG9aA31+fop9CXx8fXx8fH1+foZ9Bn5/fn5+fYV7FHx7e3x8fHt7fHt8fH18e3t7fH18hX2FfIJ9hH4EfX19fo59BXx7fH19hHyDfYx+j32DfoR/hH6ofYR7AXqOfQF8i3sGfHt7e3x8ln2JfAJ9foV9EX5+fXx8fHt7e3x8fHt7e3x8hHsDfHx7hHyEex58fHx9fn18fHt7fHx9fHx8fXx+fn1+fn9+fXx9fHyEewN8fH2IfAh7ent8fH18fJN7iHygewJ8fYV8BXt8fHt7iHwIfX18fHx9fHyFewF8insLfHt7fHt7e3x7e3yTewN8e3uEfAJ7fIl7jnyDfYV8GX18fXx8fX18fHx9fXx8fXx8fX5/fn59fXyEfQF8hX0BfId9nHwEfX19fIp7BHx7fHuIfAp9fH18fH19fXx9iXwgfXx8fX19fHx9fH19fH18fXx9fX18fXx8fXx8fXx8fH2EfIJ9hXwHfXx9fXx7e4l8Bn18e3t7fIR9CXx8fXx8fXx8e4d8DH18fH18fHx9fH19fYZ8AX2TfAF7kXwBfYR8BH18fHuGfAd7fHt7e3x8jHsDfHx7hHyHewZ8fHt8fHuJfAF9hHwJe3t7enl5eXx9jXwHe3x7e3p8fIR7CHx9fX18fH19iH4HfX59fn5+fYZ+Fn18fXx8fX19fHx8fXx7fHx9fXt7fHyGfQl8fH18fXx8fX2JfIJ7hHyCfY98EX17fHx8e318e3t8fHx9e3x8hn0LfHx9fn19fn1+fX2FfAN9fX6EfQZ+fn18e3wCAgQAgLaKjtaP3LfVrL/krqDUn96rsO7Z3I6+6fLVpM+04Ybcw6mA8Jl71+P8lp6Qv+rInMfvhZ3Ozu6Om/fqorl/lYzFz9qdxMbkjauwl8+X0OW6htHLoLOyftnLpazxsH3D0ZC4nIuFgYqJisfcsbLw2ZKkta6qjIjbq5GxupeFhsKagMqXlfvCtd3IgK+ZycfMmIi/z7HF2r7PlqaX4P+vyLiPnY7D2f3cxNHV7NXFtp+utZSciZrZ6c7Ph7iyhsSGnJaooKCfj32GiJB6s8iiy5ujvoB+j6zl48vjurKNeoDSc8pym7xqZMC/qZ+crqK2v52YjrZyjaZ3nXmHgnaR2KWwgKHiyoHPmMh/jsJxtnehdNGDrHeViLmtrNnztsvP2cbZ6pHcg7yqn++Booma2pTfj6jA56uEkJ2r1a/L3LKFhOjXus6Uk+LW7LHJiaTNddqQ+rCz19iLzumfp5V+iofm28OsbISgiYl1c3lwfZqScnyvlKetsYqKp5GJupilmYG0gMm5s1pak1NWfKeBgnOHpKpqa4e0cIugimaxpK3Bfr2PhmyHjqLB6LfXgsSH4mGHgH2Zf2uljpttp3aKjISwpILCnZOMpX2Oum+Ef5Cur7Z9boSAq3B6fneZkaGQsqmozdGJjYNyn7GId7mdr6a3gXyRgMNuh/DSooZ6m8N+dZvEgM33gMZ8vsl70Z7X4raW1q6GxtDHvau/nfKImPKWt6qfyYmisamklZKUuJaroeWkiLDGkomwgWyLlbOqlIl7lqCRq5680dO6pKCuosLJy7aGh9SoqXOipKJyx7XNnKftfn+b33mQtM3ajnJrr4fJ0Hq1mHi0kH/T14Tng4R9qbXHgO6ftKbx4b38xLOuzvaI7ZmltvO3yo/hgO/PkNmeo4qH07TQipGivM6Q3ZHSibSqx+ra4syd2tKMl7ClwZ+t58T0mJqppnJ2hoGBg5iolHzS1/J+84qG9I3On9Kv2qPE5NqAy5qWgYqvzqThuqCelpXIgXm4h9OsiLiFuJuHlnWGgICZiuOSgrqr5tL8gaXEd4DTuI+zdW/WqYqNyqWnlrPSzHWNtr60toPabsDXeHXQ4drCmp6Ipa2nvnZ+w4/EqOj54eNyzamWaovXdHeinKZd5Zl7sKCIodG4yL6uh4iy2urD0Ih6pmm3uau4d66WiZZdlcbcuYDAw7WKxOi+to3YgMyorIOH6b+Cb6qLh6ebjap5kvy66ba97py2l6m+nJ2ig4C33a7ywu2XwePc74+A6puQnqefgsiFmmyL6clrcHSCeJix53vysbbCr/CVy6b+icK7p47VroWsx7PngtT3uriZqublhMOms7W33biI1oOhium4zMPYqMS9wqSt/qiZgKZ/hNeb78q/ytf8yqzJg42ssfTm53/U//m9fa+EuFp3c19fxJSBu8nhnqWTzeatfLjYj5K+o7lzlcGvl7+JoZHA0N6dz87oobPIrdug38nHiLbRoaGshtXQpLnru4fEw4+yn4WCe35/dpWfgYKsnWdzfntzYGCbe2h7g21eX4pxgJhnYs2OfqWSY4dzj4+XdWaYk4GHmZOPbG52qKmHj3Fqd2mOlrOol6KwxL68tae1vpumlKTc8dXgebS0itCNoqGvrqysl4GKjpaAvOKw16uzx5KXl7vt4s7uydSYhYvpgN99rtN6dNzXvra0x7bO2LGnmuWBnOGvt4immZCf8Ki5gJjM3Yrkq9qMrfOU7o28j+uewZGLjbijosPSqr+4wa27woHEf7CWks5sXFCI3pbaip225K14cYSHuIeisKF8ftLNuduXlOj28dPikK3cgfSk6n2Qo5hlm9WhwKeAhYT58b+xgZi/o5qDh6KlwuPVs7PcvtzPvoaDq8LJ8sjCxLrtgO7W7IqI4IKItuSCl5mh4duAkrjlkqrGypDcvMXsk9SlnY2kqq/X8LTnh+CV9YDGvrrXlYDRtdSM2Z6pqKrn3bf/1MuxybjN8Iuyq8fr3t6kpL+j3Y2tspPO09TM8ePk//+ipJmHuuS8rvLZ49jkpJqwmuiAlfDyspSLr8iLgq/XgNX+gdSEyNSM/LHz/dKv9sCZ4drFvbjOgMtzevSkxrW02Zq6v7+zp5qdvJi4uf64msjopZ/JlYmqrdTFs6+gurytz7jb8/fawsHKwOjz69Cbm/S7u4O9vbCF6tjnp6zwhY6284ycxtnlloqCy5vd1YO4nYnCl4H+74Pwk4+CusThgPSfq5bv6MT4v6mkuOaL9aazxfzDxJDpg/nUleGYoJCO4b7Ri5Ccxtmd9J7rl8K61/rk7dut/vOWn7ysw6ez58P0pKOztIOMoJqWl6q2m4LX1vaB9YiM/o7apdi65bDP39h/zqmfj5e70q/mwaanoqrfnJPfnO/KnNKWza6Xp4CVgI6omPmjh8au9tr/hbfnhJj/777ih4P31Kuu69DJu9jt54O34+Pd2pH/hO3/hYHr9u7cwLurxszA2oCD05rPs+/86OuB4cKthqT/hoS9tbxo24OAuLmRquW7xcOthIm2vuHS65mDvYHazfTHfLK3q7trh6i1nW2boZh1qsOjkXWzgLSOiWt30514caZ5daKZgat/id+o76ijy5rBpbbqt7e2gXy636DYzPN+mMPBz3ppwHh+joqSftmesnaFuqt1go6bkaGw8YHztaKxk6WC1K3ubYWQsJHXr4ajr6jYfLrmsKuWq/n5n7XMzcK5/tuI+5uxmvXMo3uBsejZzMa96bGZgGFZUV49UDs8PUxbRD9QOkpXWFxVVSdCW1xSNVUyTypBRzRIplpFjaCeR0ZDYZCFX3+LLTJWb3FDRWBgLjEmKzFHUUgwPjRAMzdAP0wtPERCMT5ENDo8LE5DMy5HQl+ypoKel3VxbWtxXWJhP0JmYEJFT0lJOzhcSzxJUkY9PEs/gEs5MVE1PVRVKUZLUmFsVzQsPiokGhszICguNUwmOTYqNjg6RGNYVDxYnpOlq6euvZupnbTb+ufucbOve9OLoqezsK+vlXyBhY95nHFXg1BZgkA5V12Fq4mkfHp0jZf9hOSIve+LhPXt0c3N38Xk7r+vma1jhI9geGhiamFoq5GcgGd1d1GmhsJybXtNaz5PO2g/RTVHN0ZBX36QcYmCin+KjGKRVX1udKhZNTVSbVJsVGVRVWReX2x1mW2BiHU/Rn2AbHFNR2taUURKOUxcOXdXqWRyfmVPcoFMXmBZST6OiIJ9S1NSVl9RU1NMVltbV0pSTGltelxeamligXByYk9ugItyXjs7YDUxQGhHTVFSYVksLU9tQk9UTVKmbnK2X1tNPSs9NEM6WlRWOVc6cUZhYVZnX0drhWU2akpic1pZXzpiXnZkYVNYdDhYP1RMYmBSUGBUYExUWTxyYmZecXR0zrNmblA/cYJJT2dlWF1bR0w7LXI4NkFZP0JFRG88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eorn6YaI4YvA5JB4oZ91pH7NoN6afPWDlal+kpmFhoriv93F6M638dODgdbH3XSgxqP5uMq5hIevdG6uh39ti7mb0KuOgY7igKR52Nd3nKvge+KP/ryjcc7KloJweHe1g4uhociYh6fOc4ez4X6Nf8rGuLm6u8rYxdN/57yngXVzjYCrupmEr9u42XzbdXmx0L6uuYGWi6bomMePxr2hhaCCsrLPk7TRi8eij4+3jH7NeGCogKNWTeq7uKHWkaG8hvXkqp21mbT3gIWukLT66b2X6IOhosiEvPy0luzR+LyquNyGiIJ90Yz1zYiR1auHhfH6zZiaka2cu9Gggo7O56+KpaawgIe+i4Nvap3O46mhieOivZOPq+CdkInOmYCktb+z5a5/6d/x4tKXxqqpi4yO3IKcqajBkYjBcoJ3nbKUya+8upl/gcbHgMOAgYH7id24v8mOiZGu75qSws6A4NfY6oeVdtnzh45WeUdgk9uCp6/dqN2B4tmdW4OciYm86dJ2kPCShpqWo5C4zYKKqevgjHP7n5OlpZ+GfpuP0e//3/Tb0tXP/bne7pawzMyBfaaocp9zX6xwXXBubWBmaXdgj46fkYullLizgGJsYKWSsnRmk1pgoYeShMCSdpRxfIp9nmVjj5hyhIB7gXyUllqYi6F2iZJtaZ2WipuzucbmjeeKrYfToNbRoYaInZ2FsJqnsc3ovZLFpJ6IsYXguLKjoJ+80e6NiJKKjZGNiLzK2dnRxJyZp7SopZygqei4iLqB+NDn3dS1l9PIgLDdi6jJjZeEk5z8rp7pnYKs1dy5xsqhpZCLqrafj6aD6seznrNr6ru3nlG6j9uPeYqQlbbUsK+Et8OxwHjMsZuOyJS6j7S3gnaYmJubleGftXq0nXCvt7mwzMPPo8TXqoiE4qLwiI2LjqmcnK6XjvqI1rO+l5CHtJ2mvtTb7ej8gNi+ydPI09qWwpTUt9rX+faDwMqXncXDo/L6i7fpkb+slcqkzO3XnLv4ooqK9bjOzsDhi6b+j/373rTTufHRzc2Aq9vPz6eoo9zM0cjIjZOkupHM7dy4gujEsbvY6dbU6+rzlZWJzvP50v/Zu+/6r/qLqICk7fD6lqCrg5+ChMHwgO7IgpuZ78HBoqKy8PK3uYmr2L2mja3Xnrjn7I6QqM6sqqyOgqTh26y4g7+Ls5qto92hh8GooYeHrMXKw6CGsLKz8qrxwcfIt669wOPyxsKhssDPtO//3oGei5ac4pSigZK/s9mxsbHKlNOVg/Wcta6WxN6hobTZmOm7x4HogI65gMftiKurvICIx7bb0Oj4l8q/hZetxt7BsIf57fqLjezDq56o9e2SfPP0hJazm7Tdj/Hf4cTBxvmdhpX69Y2J4IrI+J2AsLOMzpT4r+efgP2FoLOBl5yMi4rsx97Q79jA8M1/ftnQ8oKv27H1ucm+k5i9iYrPoJmEm82q372dkp78gLaJ8++ErcD0guaX+821hfH1xaSAhobfqK3Exu+5pcjqgJTU/pCekNvq297e1eby3+eI/NjDnZSPpoejx52Gt+e+64v3gYfG6t/M4pK0qLvOkL971s2njZd8s6/Jk7XTodOqjILKlYPhmYy6hJlkXtmjnImweoKacMu9k36LeZXOgHCLc53ty6eN4myClNN8qfGZhLmv5qKHmeaZmpaN24/62Xd+uZB1bMfVsH5+h56AjZuBbW6xwL6jvamWbG6yopiFgrTY6baoet+VlmmVueKqnXzLroeiucWk0aiB3crY5Mei2sfCn5qm4oWhvsevtaXmg5aNd3B50tDWpreLjebYgGRQPyxGJUs9NkUvMC85XVtdS0YmOlg5QSpIPmNTLj0tSSI8hroxUlGQRkIoS4NuNjVQKjpbdE0xO1E2KCgnPjZDQigwOktAKCpPNjMsNjAvLjI2QUZOTk5QPDU0cHXG4Imju8dkY4N/TndCLUA5LUVGQjU0PEU4WFheVj1oXXNzgDZENVYwO0o+QyEnO1lqXYhOLSUmICArOykeOT0iLyg1LCc2OTNGOjw5b4BXT46LiJiwusrmjOSTqYjGkcDUn4mHmpuBo4qWoLvQqHKUeVZCaENwYFxeb1tnmLt1jZybn5mXk9Hh9fXk1qurucO2saywtNmXhnBFkoJ0gIRudr2zgJGkUVlqcI2ChWu6dEZqQTVFU2NEQT5SVFJXdn9gX35zz56NgJVVu5qSdC99VF49S11MTnCSiZhpj6aUml+lkYJ8r2+FRFJNMC5JUkY7P3BPlmGOfklhaVpKT1piUF1kVEhTnGJ8S1BGRk1HR1hGPmc6YGdnYF1ib05ebYicgnKKgIxgVlNWXVw2TDxbYW9jZlcrNEtKSFFQWqSxXG60ST03Mzs9QEVYOUtQM1YuuH1uYn5w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+fOeeeKAvZjby9iBgOqvzG6jqIirhaH01nqenvGqq8Z4gICYjY+1d7nDjKCWneHkx5WG0JGbnaKngcSJl8jRhtqf5JKHuKC5q3/V2ImF98CAmOGNgd52pcax2MDijn7SgoSMuO2Kk8PYsK+1e5bU7pZ+pO+ly3qFhZKAy+WFyrOHt4Lo3OyR2e/giMushurhl3ucf3KilJl/p9rjz+etl7SYjoCLyLu/2anAfpCHmtV+h5bEt6yphLWPj563g8Lb2KtywMrKn7zSaoTMmozd2aW/qajCwYGsjnRlw3FxqqqQmJOojMKOn7yolpy6srJohnTWj4jM/dzOkp6gioWVpb3Mt4fK3Kh7uJSbeWmAmXXOe4+3op/GkpSsnIvav6DeufXUn4DNsbK/rJi94c7Cw5OCgIHoupWi3dPR4qXWfaHNxqnlkHuelomg3uGClKvJla6Pgurtz+iml8Owa9J1mOS12HZ8epCIksrK7cCT7fWHtsDCqIuNmquGtcqzyM6bhdTP4bqipLbJgNB2+p+L0YaXqHjUr3WDu4mArcO1v8aNeuCEoYCFjbjs6vq1ps2v2NWF+/WlgLji+LuvtsB+pMfLzq54dEhVY5JVopCe08rQnsuc0pxymMOy8vjTjJ+Cy9vr3br5uLmhr5WtkZRx6vje1eir6IuOsd65usiukeTXz9yZ0ZTafeagkq17upiTdmiPlphqamGem7FzZ2Z2Yoqrd2p2uoB4lY9mXXOkhG+saYSXmndiim6Ee4CFiXF8a5Vxa3R9dXd5mKqPlGRxhKdpormH6s76rcaBhqCDlouTz5KG0qiUio6l/tKm0dK/+cCf7tyogdXrv92GlYqPibzWmXjojZLn1tiBqauyvKuZlp2tt8Csh7rJv4yq7feu0bKTjquAqYD1vJ3Ss9Dy6I27or/L2PG4ob+rseGs8YX2m8qjoMOHupx7hZ+Vmpufibh0kuuT7LLh0strhq6HpnGwYHB5h5eUmat9pH7pyuPGeoKDof2T1dBzgK1nnZecnoqHsNvo7rCmg5C/iIaQ7+6I9oOBkaCE3+qkkJDngICSmbbKhamp5oDVpKX5iZDBh5ie9NTM84Kprcbk2e2MuqXeyKadzYqmy7GUscHwtM3mi46Wmm9nrKSe/dfj6P7s4dHAt8za7vvKoZPdpa6wmbSBt8rT/IeRqLuV7cvQ25W5oKrYs8vI0dT+8/Sfg4LbnY2X7rPOzvrpjI/A8amPhI3M5/rZtITfsICIneGw3JSbh6i8yJ6GodKZ7aaAifCZ6siPqqXVf9S4p5HUyN+e2rqnxbC6pYryk56UqL6FtJTxgJyttrSAnKSru6TPrKajn8j5v93ggNawhZ+C8ceDhoaLmueDiIKs/vWjgf6Mza/k2eGLkP6/6oOzyJ28ibP99Ieiov65sMmEi4CskpXDgsDHja2pqcrkzn6I3ZynrbG4fMWUosnZlNui4ZyRxbHLqIrY5YuJ6rSBmdyRhuuEstS9+szuk4fagoWSxvySm9D62dbZjanc+JmBofiu1ICIhpaF1+6I07WNu4Hj3OaP3Pjnkde2f+/fn4uukoXavs6YxPn24fa9o8OsnoCZ5dbY9a3IlJeMnuKQm6jz5dTWktGxuMLSkeD78MyD5ujpw+L2gJnbq53/+rzYv7rQ0oq+opCC/Z+MvK+Vm5+5nN+csdi5ra7g0/2GoIq/d3zW5dbJjYmVfnSNmrTOt4HV2rOKz6Okm4qmsn+3gpeWhYmmeHqKe3Cym4awmcmrgYCli5Wej4as0rKmqJqUh4fano2RxLmuuIfYjrfa9Mf4k4OwlYmNuLtpeZyoj5t2aLCxoL2Rgre/eNh6lsSbxoGUj6eirNDZ7rKG1cSTwarUpIGRqsKbzuHE2N+ZhcezyrGkrsnplfWN9pyY8Zuqmo750Y2Y4GterNvXy7WdjPqOr4A1PkM9Qk42QEFEVkktaXJaOj43RzlGNTk3QFJUTDo7QycyPWc3a1BUaUxCMkhFiVUvSEAyTUg9LTMlOTdOUldoSDYuMy45KC0pT0xYTlc+USwzNzw0Q0JGNFJPXXd2x5PcgtKPZHBZiHdsSDdWUlpEQDtgTlhFPDpGO1VbRUBHdoBLXFtFN01wW0RTPFhmY0lDX0MsKScoIh0ZFx0qJSwyREAmMzszNz48PWdOgoVt0bztoKh2gY6Coomdu3p4yp6TjYub8seXy7+p5K2SspFkVoFzeHxDWU9YWmqWioHwlZfz2eKMtrjG0rynq7PC0N7Am9Pc0odqhopiaV5PV3lkk4DJjWR5U3rh7Y24jZaBb3BbPVNST1k6a1Czgq6IhJJvtI9ubISAg3l/cJZXW3dGfoq1m59JXoxtjF6UUFtib3t7fJNlgGKCUUlEN09DPmpBRZBeanZAX1BV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xZp03p6ZkY6nhaSAr5SS4IOUc9B4xpiGuKPH5+yteKOSqNHo7bvSsrm58NSojvLQ842JmMX2fbS/35Wne4exhNWoomKAhH1pgJR3gZqekoGSn5i0yL3EqXJstbnS4JadeNHEcn7RyKeFmNm6rr7Khoenm5qR2IB0p/J7oa6owomkrJax43d9ic2Cy7aAkq+f5fO6iZiRkKH0uL23goCu0aiU547i1LC/oKnBg9+mgH2gpqvEvZLrpLrAr93Wrdy0qJ2Fosiwpb/KlqX45dqt/5qDibd/2M17f9F/pJC9wJSPkI2Aj43Rg62sh9e9gfrn+9mS4L2ssNbh8IO87oWSgnWPk4d9dpbUwuy9oIGAd79338bZg8viiYCti3ech3SEeJLIe6B0kde0n62lz62Zn6N7eslzl55/3o5y2tmrpZrJwZttxJK2cLlyc6CUhHKBvHyt3YHEgpWPu8mJiIOFiuLHyuGvoeyJ5uK8ht+KztXhsn/eaXKIhcZ+eq2LqZWkoJufio6/8v3/ub+T0q2ArYWRgMC40+HMh86odaq535SFoO6k2orzrYRwqrSPduTL5aeb2oOexZi7tuHurYCRuqSk2qqyioFgj7SnyJm2r3l4kZOhfN2Zuoq+6tuDgrmk07agyMyptNel75/Sr7KZjJi20oqdtojvfN2PmJS7d5x8bL+jj8i1pqSRgsWkqNSA9pC33cixyLnJ7qfWy9HEq4Hoq5ykroDgwfHb/raP4VuEqaTMyH1vv4WS4M/dw3fDf/DfstDQ742r+5yZ+ITjhM+i35uVupTky4T1seP3etvipcysrKKUv4nx7M600pTQzc3exZDK4ZKWnnJ+f4mQe29raKNbZnVoe4NneZ60oZqAmaKlhXB1f3yAeoWShYJ/a6F2j5eLh2JzhHFvZ3CTZnBlbWuUoKBeaIuPq3mzfpV974nH7dV96cjb3sfCo72giZeWr6Xl3/OAgpD2toTn5JuB8e/9j+n06Yut38LigIeIi+D3qYmYi6a3lZqioZqowpCjmKGbvIb5mYeBj5GUuPiA7vn91rDPkpSymcG2/v+C5Xm5rq+OkITfva2XiIue0Y3Jw627aXrkg9rSvWKSjIx6sMyqtoKBl8OAZnd1fG6em5qNsop5iLl7or6sYl7KkY+Af8JxV7qJ0oDr1qzM09W1kc+JkuLo1qyjwfGPiJajpo+Uv5j6nYuIgqDB5Ze/le+AxqeYlbzLkpiK58bK2cHI/IKsxrDx78jA/cOJxI7imajXqZqd1qfMhKK6qMNsg2qk29O3soCO9bWnpLm7v8SR566qosmuv7e05Lbe++u+q9uT3p3b2sCBj87YzrTCy8WBibmLgpO3gJW3mPjRvY6Em/eEoazE9LeE9qyinpCxiLGAuKKW9o6jguqH5LGg5Lfh9fHDg62bs83o46rHrrW44Nmum/fQ6JiXpb3/h8jG+52pjZO0k/e/uniWmpWDmriZnb+8q56zybvY693mxYaE3+b7+J2lgPHsgI/u4cODotu/t93unp7DqqmX7JmPsP+Cs7q5zJCyuKfO/IeRjc+P5MmAocGr+fG6mJ6lorTyuq+uiIi65qig+Zjp2LbBqb3IguCtiZKwub3R0pn1m7+2t9nLpc/Bt62VsM+qpsrLj6f579Wr+ZmIiMOP/d2DhdyBpZC6vpSTjI+BkJDeiLOujdu7fPfm/diX6s60s93r9I3J+5m+qLLGy6+HgJzkzvzIr5CAg+eF/9/zlu/2joW+nIirlIKViKHumsSTrO3OvM7O78rBztCIjfaGqayQ+qOD+Ou+uKrPz6mB9sTvod6CgLOqk4GUzYy96ZDunLnR4/ySlG98hffWzMCfmuJwyN24iOeEtcLNu4vxg5CondOPfLN2ineEgHyAdHWg0tbTkZ96rZeAg255dK241sO1frW1g77I4YaGicqSsXTNt5mAvNeZhOXL3JuVt26HnH2vt9PUjnF4joSVv5ylfoFsobWHtH2qqomMrKi5j/6Zsmnd/ut7gbyw7cSi0OK8vuy565vQmKqScJbR8IPA4oPqgPKfpZTKibeHgcSaiuDOw6yjhOC/xvqAXjIxPTs2ST8+TEJLS1NQUUJbLy05RShiQkVKYkQtYSo7T1xnXUdBgjMrTT86OUFoK1dJLTY/QSo4Uy4pVTVQLUUpRCkuMyxNRCtbQU1VNF9TMj40NzgyRS9korCdwZLFxK7LwYazzHZ0akVQTlhbTkQ9PmI3P0tAS1JGSV9uY1+AXWRnVk9WWVRZU1liVE81P09HPS8vOScdGx4VGiAzNEAvLigmNUsxMFhXdm6icYFv34ey2tR548zX6buwiLmajqiiu6jn1+2AforopWiRqHNQmoqhUYOGqnN0nL7riIyQl+z4rJGimb3Nqq6ztKi50pipnqGQk1yMVExITktUbYGAlKSiiGlybHmjiqqFt6NAbTVVYVtIQ0OkqqmYgHyTsXS3wZacV3DXZ6umnkJZaG9diKyIfl1rf6RqWGdjZVqFgX9vjmpkX0s9TEJaOjt5OTxba5dNOG9GdkyBZl1VVmNYUm88P2GIiFtOYIxOQj1CSFJSWF2PV1hRVGByckNCQH2AeWtYQktONTgyVEtgZk1QXzE8PzhCSEpYoZZZnIaARUREMTApP0FUMW6jaqaCiYByeKiurF5moZlxinhYYlxOe11iXmlabGZWeVxsb1tMTlVRhUZLdVk9RWmDhmCLVnFKWllOOTE3KjVALGpXRzI4Wns+OkVOR1hIi2RTOiVSNliAT1FNhzpLQWZOaEhKSUFHv5RWPE4ySktWxXmQeWNdpXxaT3WXjkQ2OIV+K0paR0U5Mi82L42WlICJjImIiJGNjZyWkYyThoiIbW9nW0lIjoyaompuXaSdYHehj3owMlpLTkpMLCU/JyEdW0lAU3IuRU9HT0BjVEdRSScqLWkmWkiAKyopeFgzNy4nKCxPSSwnOk8/YUtFQTlHNTdgOzhRKU46VUg6T1pTPCtRKio4KTw8MTBRRExGTlg+L05YNyhIRkM5fTMpKUNChWQ1M04uPDA6NSo4MDoyNS1DKUZsQ0tRMlhPTV8uVURKSFpnaEBQYz11b250c3IqKjFQSWZZUUKATI9Mj3N9SGxTLDhJR0hRRDw7QEZuVGlZYLKDanJnf3RtaXZUR286PT9CiT00Wl9WammEY1RLiH6VX3hDQ1JMQDw/YzdGbztoXVxqfYFJR1t0a15TUm1WZ7Bdrp1SQnlRkpSReVihUlx0hPe6hbNjdmd0cWtwZmWNwcS9gI5sl4WAcWFubp7f8ayrearspfPz9H6QdrSCl2O60suk4KtNb3FeakhQe1FleVtFTHWOe2Vmc3GKp5ObeouKxcR0qXCts7G5r4ixSWpHZDpYUlA9Q0I1PD8wSTs2ODgwWFhoQzQsOzY7QjEtQSdcN3I5KysrJikkIEE4NEk3IiwrM0o8PU4BfIp9h3yFfQF8hn0MfH5+fn19fX5+fH5+hn0BfoZ9gn6EfQZ+fX59fX2EfgN9fX6FfYJ8iH0BfId7hnyDfYl+AX2cfpZ9hn6EfQF8hH0Efn19fIV7hn0JfHx8fX19fHx8hHsMenp6e3p6ent7e3x8hH0DfHt8kX0DfHx7h3yEexV8fHx9fX1+fX18e3x7fHt6e3x8fHqGewJ9foR9FX5+fH18e3t8fH5+fXx9fXt8fX19foV/CH5/f39+fn59hHwRe319e3x8e3t7fX58fHt8e3uGfAN7fHyHe4l8iHuDfId7g3yHe4h8Bnt7fHt7e4l8BH19e3yJe4J8iHsBfJF7Anx7hnyHe4t8CHt7e3x8fHt8hHsEfHx7fIt9CXx8e3x7fHx8fYR8h30Bfoh9AXyGfQV8fX19fIZ9mnyEewx8fHx7e3x8e3t7fX2FfAZ9fXx9fX2FfAF9hHwBfYV8DH19fXx9fHx9fX18fIZ9BXx8fX19jnwBfYl8An18iH2GfBV9fXx8fX18fH19fH19fXx8e3x9fXyMfQJ8fYV8AX2EfAF9i3yGe4N9h3wKe3x7e3t8e3x9fYl8j3sDfHx7hHwDe3x8iXsFenp6e3uHfAV7fHx7fIZ7BXx9fn19hnwOe3x7e3x8e3t7fHt7e3qFewN8fXyJfgR9fHx8hX0Hfn59fX17e4R9B3t8e3t8fXyEfQd+fXx8fHt8iH2EfoR9hX6FfYR8BX59fn19hXwFfXx9fH6QfYN8h30Hfn18fXx9fIZ9gn6JfYR8AgIEAICq0JuG+Xaqvt/U6b2qjrvl24jakr+UxLPid3W8dJSDsZSwiu2lla7llnuK2rHLtOX19fGB4q3F3JC4ocLAco/Xobmvf4iV4Jjcf7m9uJSOgcaCoraohcqW03yHm/qF+rW/jeu1yoCghvjchuuYnr+Jhff3w8DJrai6opj7oYS25YCBzbzLl4eiy5+tpbO1v+fdjs6kurWFqqiymrHf8OaOgN7EjJDi2OKU1efUr5Li+O/V5/PQv9Hy0+nThtHAh6Do3IOAjo5/hZKQfn7K3pqDu4KAfoeBm5KUnbmcvqyc0XhvbaON3JB3h5mamI2Mj5yhmXq8+cWFlmSchJRvaZPMhoDDzHiFt4qSm4WN6bKue8nVd2+btb+IZHh14tyAj5mjzuTr2rLantec4qeqhrD4penfr62dn7DEqPq6q//L4K/msPzU2YeWh6W1ttic5dnT0uignKK2+cXPnbKkirvEcWimhXqHcIqHYnOFeJedV7WXuWWTd9t8h4aSkLnSjq+CY4CNd2KFcGF4j72+Zni2v6m1c2tziqxiyZ6QgKe5WG9vjYCMkNztevinsLC6q3mFhcSGnqOBk5Ppf5/AgKeJdom6mZDDtJmAuo/QgnudeoxhhaOFpayBjqB2dsGko6WTYmrAZ5KBcnDAlW9qb5bQjoi505aql3htop9/vc6MruXMk4CVhsrZxZihfJR5qsZ2e4PNfL50k4KMorabz9fGr8izw52/huyDsa7bv7Pkmpz1nnyjqre45rydvbDCqaGvcGeNg4p4aXafa9GfrKKD17muqqeQhpOVfM+jtMHH0ZSIrr2h5L+ByHa0e8bPh3iFhbiOqZqu45y4oLbS0t6M4ZO/oYCAeMrG4KmftHywdNWSsZfOyqayq7Kjz9eHsqiyqpCZfpF5h4SsjJGbq8HdsJnqqbLj5OSOrLaCsZ20gsvHhKrJr+zrwJWOlsW/juDsiPCMjI2R3/bDlvi9g4bqgIO54MGsgYPa5M7LjZ+pntPemeLqxJ9uf35zfKmW83+Rg9eieYB6bqiqtICJm4WtytS3ctmMn5yeseW24bWhnaynkIualYukp5/H19JyftrOx8d7d93PhtKekMKcrJx4tZx015+LmX95n6ath5uTzc6HeYHd19i5hse4qdTZq6igh4ezy6KR2ZvmxHpsfqLFx3GOrJrHsLacw774jeCmu+fBl7eGnICQu5iWsLHRg7yXt15oZ2e60IKQ+e6NydKYaGVgn33Kn6TO2unCu7iLpqGU4qiulbnj+a+Ks6+J732Uu6/l2KLanV1ghdGdhpPmsre/3nzDoM63jKTGtYiVvZKi55uf14C3k5nExde9yc3Bg4OVoNZvzXGCtpjfjZmxyKiQgr/RtYC754yG/oSisNvj+bjEo9fC/5X/m7Wbyr72hITPgq+YtoSDd/ivlZuekIiV8q7UxdPm8sJs2J/G9pfSqt3ZgYj0oqu8joyE55rlk9W5y6d7e7p5nLusecmg5YZ/n/qG96eveNqVomV6YbWfYKhucoxlYra2jY2RgHqGdXG3eGOJqoBfk42Zcmd6l3qDe4OFi52dbq98iIxjb3qJc4uqrJ5rYbmlZ3ivo6FpmqyoqpTl7erMy+DQxdj11vHMh9zVjajw6IyJl5mDjZ+ahILOyZiIyI+JiI6IqKGgr8eoy7in4od6eLeX7aGDlKmsq5qcoKyxp4bE/MSXx4TNuMWMhaT9r4Do75eOxId+qo+O2qbGkerxkozO6eawhZaY8OqDj5aavNLWzaayk9qbzpqhdmaVfMTTqJt2fYiZerqCe8iqvYehh8evpGeLfqOwsMeVnJyu0M6LeoSW9tbnsejNr/PWqKLPpLK2nK2vi53Jvd/1hOL0/I66of6bp56prdP0tMy0hYC5rY2dhYmewOnuhJzn7s/YjY2YteGK8sSgjrXfe5eGrpmjpPf+hfa2qqHFyImSpues0NCRkpbztNTgrt7Cj6DpwsDu28qr4bb5trbSlLaHscmZvMmTp82Li+7a0tnGgIX1gqeNkon1s4eHhsn5r5Pb87nbr5CHvrGO2tmTwvfQmYCejdPg16W3krWQ1OKNlJPXiNyDmY+QpbSe0eG8qsWdwqfEjO6Ft7zaurbzoan9qIu1s8DH57iy287fxsTXl4uzpqiRhZXDgPu2vrWd9NXayLmelJ2Wh+zJ193a+J6avMmu7NKR3ILHh9zdoIiDh8+fvK2x35vEqbvc3uWZ8qPXqYCIgtXB57GwvIW/htyhvJza1LbHsryz1eWGva7DtpOfgJ2Ak5m/m6Kqs8DRtJjwqaXR2uGQu9iOtKK1hbvJgqTDqvjzypeMlM7Rkev0jPWMjY6S6f28mP7GhIv1gn++6M2mfYPl7NPUma60qNjgoez63uGrurCUrrys/IKYh9+sioCJgcfEy4eVupa80+LJhf6brKinvP/Q98+8uMfKtbTCurPQ08vp+PSFkPvy6/CNg+3flfCsoubK38um1bWO+7+arZmPr7G8k6is9/Kyq5jdu7enhdbIrMy3j4KEdWiSo4BYsn/AuoyHoMXhy4CIuHyjkJKFmpPBarWOpLqef5lxeoB1pIOJmrGmaJx7s213eXjJtnt1zstyqbePdnFvv5nWoqe7u8Cwtr2Jm5eO0pqKiKGz2pFypLF44YunoIfRvIjLompxmPXCqaTqqNHR5ZXBo+zMoLHSqYKirJyn7Jag4Gieiajhv/jb6tzQiZGfruiB8oCZvZT1rK7Ny6qPcNPj04BKUCopTChLRVBCXEtIQ1pngkpXLj8yNjJDJydFMUQ0RDMzLFg/NTJNOSg1Ui9EVVFGUVIlQTFBRC5BOkZJKi5PNTwyKzAuQzlMKUs9QT8vLFQvNTxNMTUxWUVnjuN544qTXsFyd0dSPW9kOWZCRlhCQHd1WlpdVE9XS0p2TkRddIA/Xl5qT0xWa1peV1tcXl1YNkEvLRwkJiEzITJVS0UyNENbLUFqZGxGZnqFr6T75MiwpcXHzOL61fXGhr6yc6v48pWRnZmBjZ+WfXe7nnyAompvaWdmaV1who+aw62f542GgsCZ+LCJn7y4uaWqrbi4q4G78rqRlVd5a3VUR1aYYoB8iV1gkFlEUW91vYWAX6CjYUaClcKBWXN27uaGlJmfuszZ0qumj+aVvpGuakFfbKurjX9aZnCBZZhqaK2Mn3GIcaONgFJlREJLQV44VG56c6RzUFBYg1lzZ4JkZYlpQkBpWFRYSWhoUU9dWGxtQXdmhVNdTYdQXGJobI6EWmBAOIBTSjs/NDMxL15kLTJPUVNlOTk3O0w1bVpfW2megHM+QTkzNVlJKYFVX3droFlcjpiMsLZjbGzJsK2ObmtfJ0eQVHt+f2tXVlqLYVVbPk04SGZYWjtKUUIuKX9dr5lSUEqeOTwvVUZgVDErPF9fTjJxj0hALkQ0OFNJTIEcPkZrRIA+OUZfWk9dMUA8QUEpPEmtNWUrLTA9QWdjeHiIXnZ9eD1fSZE9S1p8dn9yMjB6QCNuc35mj4B6kJWbmpmUiYaTkY6GgoZnPXtdZV5Mj4CNhX9WTF5UYKWKkJKOiiokK11VP0MsTjY4KUBESUUtIEE/SE1NQ0VhTlFRU2U6U0ROMoAnLFNXQSU6KiROLU1DOjx+c0xATmJEVmsbP2I2Ph88H2VKTS40Q0c5W09AKShYQDZJNkk0SnlLKCY0LDVHNSlbP0tyTiEoL0xgN3NgOWIuMiopUU80K1pdNStNKUFOS000KThYVlNLPEJKUWVhRlJDQXJpbm5jZkVAVS83PGNLQYBESHJfaERTZTxGVV5QRXZBSU1PUXtogHducXhxXGVnXFxocm15ZmY8O3x3d31AN2SKWpFZU4p7hoNad2hseWFIU0RARU1SQFxdcntmYkWIk5OKYGhUTFx8dWRxX0txgmZChmaagFpRXZK+uYuJ3WiRfoB4gnqkW6KBm5+NcYdia4BmmXeBkcaWXJBxw5Sio570qntis7llnaeSmo6Lsz9+XEJUXmV8Y0hGSUYyhpJ8iJaYzoJsqMJ14LHTlHDHu3zTt4iNiK5DMzxWUEtJRyhZTFE9KzY8NysxPSwrVVU/ZTtPOjI/QEROQUxWRzIvNUYeOSQrOjhIOjg0PjI5N0JFOwV8fH19fIh9Bnx8fHt8fIZ9DX5+fX18fX1+fn59fX2FfgR9fXx8hH0BfoR9AX6EfYJ+hH0Hfn5+fX19foZ9HHx9fX18fX19fHx7e3p7ent7fHt8fH19fn19fn2FfoJ9iH4BfYR+AX+Qfo99gnyFfYR+gn2EfId9CXx7fHt7e3x8fIp9hHyLe4V8Bn19fXx8fI19DHx8fX18fHt7e3x8fIV7BXx8fX18hH2Ge4J6hXsGenp7e3t8h32FfAp9fHx+fXx9fHx8hH4Nf39+fn5/f39+fX5/fYZ8hHsHent8fX18fIR7hXyNewd8e3t7fHx8iHuEfIR7hHwEe3t8fIR7hXwBfYV8g3uHfAl9fHx9fXx7fHyFe4N8h3uCfI17AXyEe4V8A3t8fIV7A3x8e4V8AXuEfAh7e3x8fHt7e4Z8BXt8fXx8h30CfHuFfAZ9fX18fXyMfQF+i30EfH19fIl9j3wBfYV8hXuFfIZ7g32EfAV9fHx9fYR8gn2NfAp9fHx8fX19fHx8hH0IfH18fHx9fHuHfAF9hHwDfXx9inwEfX19fIR9BXx9fHt8iH0PfH18fHx9fX18fH18fH18hH0RfHx9fXx8fX18fX18fHx9fX2OfIZ7Bnx8fH19fYV8Bnt7e3x8e4Z8AXuFfJN7gnyEewh8fHt7e3p7e4R6hnuIfIZ7gnyEfY18A3t7fId7EHx8fXx+fX5+fX5+fX59fXyEfYN+hH0FfH1+fX6GfAl9fX59fX59fX2EfAJ9fI59FH59fX59fn59fH18fHx9fn19fn19hHyJfQF8jH0GfHx9fH18hH2FfIV9B359fn59fXyHfYN8AgIEAIBzsZS7ge+Ol+b6oJq6fHiEdbF4wcO9hqvK4Ha9e6250eWj9ayGqK7n8+d4qMiM3dvixIji293D/9KgodG45t+wqpOud4SI4tbio4GRqreZ6q/rkI9/noK4vZbxrc2k45LZhcvArNXlzdj49fyAponi06Gm0PHB19710aCY95ye94CAnYGGhqSXtsDLwuTbrq7S7sOYh56KtsTfzouP9ZPlkqaMsMTK0r/XsrertY33+IHehYvQycnBvYSFz32qiKG0sMzP25CmiJOC3+n02KiPep+JmJmyj4mMwn7J04KD6oF+d8Oyx46GgpGJgX943pmLe62NjIqM0H+zia18qXODeICslKW3++Pv+OCloZuu56VxbXVnbdBpXYiHd4OKdeVyfLWcoLy6prbDwcDc2Y6u+d6KwLuKj9fIzoH2lubd+KOVj/uKgPWjur+rwf/crq+twsB+wLyyjc+HkYZvx7GceVyciWt8iYx+c5SUe2Jzc4uKl9CJicGJp66wornJrm1mlICEfXqXl3uirYiqcJiSgXOyacF3h66ms8yJgavWq6Wtv2rLjMLchYiZloOdjYjdnsSB2qGwfticlLejmaOjwc+9eXW4psdwi4qXdXWIgYCnlKxxjMGgbGR4lciRhYG4lrtpeMXGq4+uwHalo4zGsK90wNbKjZyIg7SLu+aeuoqn3IDX17+9h4qevpSuouKAddGYqn+75LrHluStiLSx89uM9NHW05ObkLK3yNeVy5DAkZes6nih1PDEidy1jIurdG5tcJRuv2SFlo5/j3xxtrqksciMjHXi0crXh7fAqq7O7cDfzKWZjbBwjZZ5ln7eipCqopV3fdGJlOjM6peQfJKjcYB9vrSc+bGSmYClvLd22byAo6SWeoKuq5TQp5+n13++kZKGi9SCxO/BoprgtcKDk7qZx8PCfsed8oeC253tvNT9v4D2uIaPxIb21Lh6rsfRvtfs09eln4Pa0Yfr2I2MhpeJjn/FmrLKnIik4OWP6Kd7fZSGeYx9t+KFscro4rifhoBydcp8o8/RpMmae4OtbXG9cnyT6XivypqXlHOMfpDNr5+l37rNrMWtlqGxfIyhcdjKfv2BsH14umvB2MuFqY2oqY93jp6to9LA2alqkJ+UgsKef398w+KP3pvJgpifru+5lsnEz4WYiGtweHnFmJ2Yu9jCm8mFmpianpnhpq+7/IDar5CKzoO0i5+YnJ25kreGuseF/tj07sS8c198s4aZ0P2+mb6e7sDUgZTY2oqRsPrS7aLvmYTDlo1ttLeWspqLXJd4m3CGj4qZmcKSotK73JmqlYusgYmDjJym5J7tvYHdx5GMjKWAcXjJpH2ZttF416FyxL/pyISOnJWLgrV+eICIwI6+hvyJp+PvmqXLmZeOj8uHvNPMj7Wy04TUj8bm6cyQ5ayMpbjj+c+Eudmd5ejszGfn1tTA69q6rvDT8MLCt524go+W0LzVt4WRv7uEyJrQjZqHmG26uonXprmZw3OjbpyLepyjlJyxsLJdeWWkm3Z6mrWOnp6wmHZwtHN0toBfdl9lZHtyh5GWjaGYe3aTtZx+ZXlifoyumGBiqW2mboByhZGamYiag4mKq43y5nfKdX3T09bKyYx5w4KrjaS8ttfb5JeukJuJ6OjlzaWVg7eco5u2m5Kc0IbY6pCS/Y2Mht/F2JyWj6CWjIqC7ambi8KblY6V+KPot92SvoWgm4DTufPy/9bi7NWUk5Cw2K2Om6uGi/uEiaaXm7KTdOR1e6+eoKqqoLjQvL7kynxrhZFxn6FoXp2enGG1cLO3wXlucMVsZtOCiKSWqunVrKKHmMOAsbGslOaQj6uE6+C+sInKsKCpvM2kjMjXrpipn7a/yfiUnO2cydXRx9Lp6ZeQtYCvk5DJqZbW7rnhpN7KpJf2iveTuO3a1fmilcD209rh94b8n9volZGPlHWfmo3gscWH2qzDjfDEyu/Sw9va8/bgoafj0PWDm7HCp6q9ta3TvNmEoeOyg4CKsP2xo6PsyOuFmPX64srn+6Lc1rLPyMOM3fzrqrifjMyexPmrx5at7YDo6s3Mk5y147zJv/+ViNenxI/Y/c7Rn+WtisKt596A5MzXzZ6nmqmyw8GU6Z3PnKC374ar2fG2gvPSqKjRm4+Rk7WF7YKcsKCZp5GByNK7wtaTk4Du2+PbiujpxLnZ97rtzK+dkbqAoK6IoYPzmJ27pauAhNyHiPXW85KOh5+8gICCx7if+segrI3C1ceF8M6Ps6urgoy7tpPkqqeu2YDOmpWRnfCTy/7Lqp/ht8Z/jLiSvsHBi+eq+o6K55PqvM7ut3/1t4eNw4n+18CEvNDfyNvy3uWso4bi2Y75446MiKGLj4DNqMDXppi15+uQ6rSCk8XAs6eP5fGOvNj27sWtkYCAhuuKruDquNynhoa5gIPigo6i9oXL5Kiotpe4prrxycDL/OfwzOjSv8TTobPIgOzUh/WLv4+e5YDk6uedxpm5s56Omq29q9DC5LKQub+ulreql4+BwbtzqYWhcYmHirdvlLrK06aqqZGapZ3okXx7mLikfal0fn6Ae3SwhoaOzYCym3dyr3uXcIp/lavDn79/oKJsyK3HxqyugG6Mz5iq1einf5t8y7bbg4m+un51o9Chy4fQjYDChJJ4mYd+uJWZaK+FrYWWpJmmq+ejs9rG967Gmpi0hoSGmKep6JHZr3np1amVlZ5/gYrptY+nzPSJ/b6B4rHk0ZSSr56UiL6IioA0QS08Kl03MkJUOzRAOT1HQFItPjM3KzQ8RSRCNk1PUEg7TUMxSTJIVEonO0I1TEFJRixeTUc6S0M6MD0+TUs6MiswKC0qSElKNzU1PkFBWkdRLDZKWStUaGSigot/m1FoUm1UTGBjXWJsbGs5S0BpZlNWZnZaYmFtX0xHckhIeIA+UD5DRFVQYGZoX2hhTkZFWVEvMzc2LT9cUDEuVzZePz9HQkxlZ1psXmZwqpT5qzx6W2rI1uLR0Y9tu3CFbpq9ttnV4JuzkJeH2MnBsJWAWWZwiYOPcnB5un3V7ZOP/ZKUj/XK3qeel6udkY+I77WkkcqWjY2Y3X2jaIBbhWlrT4BhWXiW3KulnJF/i4KXw6l6bG5QWrheXIeKgYOTgPmBhLirq6mmnLrhysD8wXZUWnRcf5FQSX+BgFCWXZOVm2RbXqFZT6hjaE9IVYZkW0xge4RTbmdhS3VLVVdEbXRfSDxiU0pUXGpRUWZjUUdXU2FkbItMSYhadn95aIGKdEA5XYBRRUFMPDQ6MStVLjEzNi9dQGpBQ05Yb3hhYGOUfHdnYCtZPk9IKTRaQUkzYltulmZkfXN2SrursMKvimJmZpuSVG1+YV00PVVyYltfRUxWXWhDU29UMiU8P3hjWFp7R14xMFhna2FfYEhOTlYzMT41eGNnU1c1NFZPSUNQajhadYBHW0E+N0dobDFnSzEgMs1eW0lbb21aMzNFQIY+bj1coXJTckNRO29ga4M+STZXKlOHjExifYB7aLOhjI2Yh4aKi5J/9X9sXltPUEpJf4Z9g4tXWVFQk41mQZaOelZZRFR3Tj4zKk8zP01EQDtfQEpaT0I6P1czJ01IVi0vKS5GJ4AmTU4+OygoKCZOUVpEc6VLPk48QElGQkZgHzY+SR9NRn04RnU0PUxUaCZFW1I4LCojLjc5Qn1MUCIpRy82MzdGJCZ/PSkoNyJUX0o4UVpJTEJMV1EwNTBWWylTRzVAMUAvMC5WQ1BQSD1NbFQ5bD0sOnFvbHRmfW9CUmBqa25OPoA/Q4A4U3V9aGxDQy1IOThcMjxCdkJlfFJUVU9hXWVqYVticmtlZWp1bnFrWVtiOm6DVqpRbFNfi1x2jYVkcExWU0g/PkhPTG11fm5UYUZMY5FzUEpQe2pXf1xwSmpxdJZDWIiYi2JiYlh0b2ezkWlqhaiXb5ZjbnJ0a16Wc3B8uICfjWpkqIOOZH5xmdXixt+El5dfsJqyuqaqnY6wu0NRfoVYXHllm2h0RWSBlnhnm76JuXrAjobYfa6elG565aXLivKjkVNFNTQ4Pj4yMExUZT89MzIuLTIqLDA0TlF6aEdjPCQkKy4uKzBXUC8wPEAfOzMfPD5aTCwsNTQ1L04wMQZ8fH19fXyEfQN+fn2FfIh9CH59fXx8fH1+iH0Jfn18fHx9fX1+kH2Dfoh9hHwIfX18fH18fHyFe4R8iX2DfoZ9h34EfX5+fY9+i30Ifn59fn1+fX2Jfgh9fXx8fXx+foZ9Bnx7fHt7e4V8hX2HfIl7DHx8fH19fH19fXx8fIh9AXyIfQh8fHt7e3x8fYR8A3t7fIR9B35+fn19fXyEewF6iHsCenyFfYR8BH19fHuFfAV7fX18fIR+EH9+fn5/f39+fn59fn58fHyHe4V8hnuEfJJ7gnyJe4J8hXuFfAF7hXwDe3x7iXyFewV8e3x8fIR9Bn59fHx8e4Z8kHuCfIp7A3x8e4V8CXt8fHx7e3t8fIp7hHwHe3t7fHx8fYR8B318fH18fHyEfYJ7hHwIfX18fHx9fHyKfQF+jH0DfH18iH2Cfot8AXuIfIV7h3wEfXt7e4d8BX19fH19inwIfX18fX18fHyEfQN8fX2EfIR9kHwFfXx8fH2FfAF7hXwEfXx8fId9B3x7fHx9fXyEfQR8fX18hX0EfHx8fYh8D319fXx8fXx8fX19fH19fYl8BX18fH18hnuLfAN7fHyEexB8fH18fHx7fHx8e3x7e3x8lXsBfIh7AXqGe4l8hnsKfHx8fXx8fH18e4x8insHfX5+fn19foZ9BX59fX5+hH0Ifn19fX59fn2EfAR9fX1+hn2EfAx9fHx9fX5+fn19fHyEfRd+fX1+fX59fX18fXx8fX59fH18fXt7fIl9g3yLfYR8An18h30DfHt8hH0Ifn19fn19fHyGfYN8AgIEAIDeoeH3f+OFmavpnZimj2Rlb5y13eKwhZ++1Ix+jYajyc5+mr2rwfegnuWt16vu76/Gi4L4xtOF+pGGrNDHvuXFsbmlfex0mLm7fq2JrYOhraazvYTtt7/9/JWc78jShZjPt/P3ivyZiNzr+5KA8MC1sLilpseBn+f8gdeelo2iiYCjm8maxrq+ttHV3OXnnI7tyYPfx83egoCWkYKQo63ApZ/xgZyYjIHPvLnNnIGbiqGn6NbT49vQv5WC69fWtI+lusDJw+GB7OK/sJ+8zbu6l76ltM+6kL3Eicl6kJ2ch4zkh3t5coZ6kaeLdcdye4mVhI6gmpOOfKKU0X7at8yklYDLhKSH5oTGnqWYzYSstZlucoFZv8iumHmAZGVvds3K3aKUm7SWpOPg1prEmcPW5euAgenSkZX/2qyV2puFp76v1vbvksDn39XRrv7N6Ju8ntx107mS7HuKfZukxb+AY5iWc2d/j5R7oouFf3x+e46tuL97xKqambZzyLWScoKQioD0hXy2u7ChqnmuiMWfhLZzmp5raY+skLGBm6N1hHVoZ5CLa7p8iY+qj/2zr5fWldXrf+7Rl6+cf2mCgq7Ga4Ztha9unZNwcHlsYHZ/fHGMxZpuqmxwraq/Z8uipIdswGxwcnOnm4mymL6Fl6p+cKRxosqQpIeoraFwrpHJ3onG3oDK56WocKW60ICno6pxd7bWgZyAp+SSg6N/rL6Sm7fQj7m5pYfcwpGbl4af0sKNrniNtub0tsyGnbyhn5CPhpVga3tmsa1teNLctm/bhYPt5L/kmYOUuKTgw9B3xIbXrb6bhJqg+YeYs4p8etCxoaa7jHy9zO7mnPno84GO286RhYCSkeqgpHSOc3WChofblX+TqJuS2Xigg8OsiqvWnsOdmpSFyu+whMOUqK73le6W+4TPwdmP1q3gw66v3YeRhpaFo6X5jJyknZCOgMxzc3+Bq7XEvMO+/oh/2trj3JOC5c3R5NLDlpmNqKChtOvd8nnbk4N4prOwiuLLoorbkK+cmoCGmoCRkorBj7SAx9TJgI6iqZGDgMPLyOuf2rZ/YouxnbuPlrOywHOQhZ2QioqdeM2xnap3h6iwualyy6XMwY+FfHLGyYCson/YqeSGv3K6h5Kctaush/GuqImDjIfDt5Ox2YbBfHiPbHx/mJN39pXi3OKqo9qCz7fs7NWO5tGwi4DEi+PS9fbTqsb6+bmWsaCKzbyy69mu9cGdbmdphZLA+4rj0J2a9tLDqoSRxcmUpIabpNeI/Z7gsrD+lNq2pI+diFKHbdePcnKhs5B1fMu3b6qjhYnwzvnSpat/tLHYhKuVtLaSlMmRwqeoroCjl57Lkcuvu6+52Xbaws6hhYS+eoD6quPzg/OGp7rqqqOzpYKCkKu90fi1fKbS7ZmKnZisvdiHpdG7tv6upsKhyK7t7LG/m4jsy8F44ZiZpbblxdLjwLemi/6Ch6C1gbGbrnigloyst4LysKvk6o+I4sbXf4CTg6usYK5sYJqotWdbrYyFf4Z3eZNhdqe1X510bWh2ZYB3cpFuj4iJgZSXnJ+fcGWzmWWnlJmeWmFwaFpjcnqEb26sW25vZ12SiYqhgXGPeYeGx8Xb7OPWyaR75czcto+vwsvVze+H+O7ItqG40L3Am8irvdrBmM/TktaBm6injpPzk4yJfZSHobycheWFkJuqmaGsp6KZhca8+o3as+zGsoDondGm54jGioiDxHyeqpeClq6G5vHpz5GwkYSMiszG3Kicobyamero0oqph6ukdnRNWoeVflS3ooByq29odoJ4pbrSeKShn6S9p/nM65qvhPeK3MmM44edg6G64NOlhPDhlYWv0cSpoJy2tqOjlrDc6e6J/tS+weuJ6L+lm7nGqoD9maLp29e9yaDQoeTVstOU1deMhcbRpc6etbuMpI6IgKykhtiGkpaekOW3rpXUqtfUgfbPrKiznIeamd7yg52DvuSCvK6Egp2UhK6ypJ639LiHwoGA59nfgv25wKSD9oWJjJHg1rzx0O+gz9aVhq6NxvO5x6rLyL2AvKTj+JTa8oDa/bSzhMjh9JbPv8KFgMD5lKWSuPyYkLCDqq2cp8LUlb68sJH04Jejn46d59eZuYKVt+ftudKDkK6itKmtq7qChJ2E5d+EjPb/0YDyjIXr6Mfqo5CjvaLt182H5ZDkraeggqKc/YW1xoqGhOC4oqy/lo/JzPjslPXo9oWS6+eckICXq/uruoqfhoSHmJXso4Seuqyn6oaokua4m67Up8WsrZyS3P3ImdGhs6/9lfKU9Ibdy+6X4rr43re55YaQg5Z6o6P6jJWloZiVgtmCgZCOtb7MxtHM+4eB4eXu5JmC79Tb6dXMoaaatbGywfDl8IHhqZiT1sjBl/XTtpf0n8GtqICXqJCbnZjWmMmJxN7SkaGvxq+OjOnt4/iu9dGli7bTvt+3ttvV4Yizq8q1q7XOit3Ao66CkrTT+dCByKjk0J6ZioTk7KPDtZPzr/2d44LfutPI6N+9kvimkX2AhoGjlXdhv4/kk4+mjp6auLyC1Xq4s7uEicFzqqzQwq1zxqmQboCec8Wy1d2rl5/F1LmZnZJ/qZ6Zt6+R2K+deG1wkqTJ+XOroHx6x6eok2hznLF0gnKKg65z64zXlqjnhKuOjoannWGZevqphYq8z5eIjda7g8W9kZf81dvPsMGGr6K9cpKnvcGXodSf17etxpK8orzIovOw0Ka254jn1t6okI3Lg4BlO1hWKkwrLS5XOTk+OTI3QD5CRENBMzlCSDMwO05OZkkxN0RNZU0qL0I7V0d8UDU5MitLREwtVDAnLzg+QEdBOTYsJEMhNTg9LVQ1R0lVT0ZBRz9qWUueuVpTrLbSeGldV2hlN2U/OV9mbj44bF1ZVFdNU2Q/SmZvO2JJREFIP4BISFhCWVdXVV9dYmReRUB2ZkRsWVRYKjA7Mi0zPkNPQD9oN0FKSEBkWmJ6a2CBX0hUlKPY7uXXzqlx2r26pYGtvsjQwOR/5Nm0oI2rw7C4j6aOpL+jhsDBhsd+nKiliZDznpuVh5yRrcyijfaTnKq/q7Gtqaaeh5mLhkKphv2vXYBhRVVk74CbbGx2sXeds5xuan1alZmdlXWSbF1zftfT7LakqcmXoPn414Wef6WRT0g3QlNtdT+UgWFYilpSXmZihperY4R5dn10TH1nZUJdT4dJdWVTgEhST2ddc4dWQGVrTUBVaGZXV1dqXExLVGh/gYxKeGtaYm9SnYNrTE9NUoCPR0toXFVVPy9gRlVBMk04ZHVEPlJjWGpiZGJNTEY2NTAyL0srMDVaOoctQkB4Y7iAQo2BaXKeZF1oWmVmQFdWcIpDXUc8M1FFTGFQRkdZZUIraUJLalNvNHNGWUs2XSQyMjFoWl1cVk4wUmE8K0NJW3FOPEJCOzFKZ0VcWztMhoBXUUItLVhtkj46TEAgYIxtSl5QaHFEOlxBOoQsICU4RG5MOiliZlA4OjczXGQ6PD1pfbO2qppvhJmIjY6Qj5OCgY2A9PF+ZpaVfEiHVFuonoyhZVRUVC5aU2xfkk11VVhVJD4kWTRCRDElIUtGSm5dPkFjVGZVO2hYbissR0xFNIA0OFJAKB4mJSxHKDx2gFpVVTs4ZDY+MWU6REVVQkpIQnc8fYlnOzJBVSNmLUMkViI7Q1ssS0uCeDhCVTEzKiUOJiVYIy4tKBwiMVM8PTo4TFBNRUY/ZDA0YF1OUTQ+VE9VUUhLRk1FTE9GRIh6eypWSEZCipuVV2lgVlWOUlZPToBHUENCUUWBVGlQeE9NNENEWVc6NFholKV7bl9YUmhrXVZcZGdxcjRbVmlgWFdaPWFvZmlMYnZ3nIpJiXGDgEpIQ0dtcUVCQj1pWYBMcDptaXVxb21XSr50VEpKU16Hfl0xYj5wXVdWT1VXY3NgvWyfnalzfbNqm526rJJmrJOAY4CNa7mbzNyhl5Gzxtm1lZWCnZSTn5qE0bCxl4ODrLCrwFp8fWZmrZB8e1lji7RndmhsbJVt64fzj6TZc5B4gH3Q34eagLxWJysuOyogI1RSNT07Ly1WTW9nNi0tU1VoSk5HPzEnKTsrQ0dKUTI+LjE9LkQ2Q09DVSZEPU86KidDNAZ7fHx8fXyEfQN+fn2FfIh9DX5+fXx8fH1+fn18fHyEfQR8fHt8h30Bfox9CX59fn59fX18fYh8DHt8fHt7fHx7e3t8fIR9CX59fn59fX1+foh9hH4Bf5V+A31+foR9iX4Df39+hX+Gfox9AXyFe4Z8AX2KfIh7gnyGfQF8in0BfIt9A3x8e4t8Bn19fn5+fYR+BHx7e3uEeoZ7A3p6e4V8En18fHx9fX18e3t8fXx9fHx8fYR+hX8Vfn59fn1+fn58fHt7e3x7e3t8e3t8iHuCfJN7AXyFewF8h3sBeoV7BHx8fHuGfIJ7knyJfQV8fHt8fYR8AXuEfAd7e3x8fHt7hXyJewp8fHt8fHt7e3x7hHwBe4R8hnsDfHt7hHyDe498Bn19fXx7e4R8DX19fHt8fX18fH19fX6LfYJ8hX2CfIl9BH5+fn2JfAt7e3x8e3t7fHt8fIR7hHwBfYR8AXuFfAp9fH18fXx8fX19i3wOfXx8fH19fHx8fX18fHyFfQR8fX17hnwFe3x8fHuKfIN7hHwSfXx9fH18fXx8fH18fHt7fHx8hH0Efn19fId9jHyCfYR8gn2QfAF9hHyDe4V8AXuKfAN7fHuHfAR7e3x8hHsBfI17AXyHewF8iHsHenp8fHx7e4R8gnuEfAZ7e3t8e3yGewR8fHt7hXyEfQJ7fIl7Cnx9fn19fX5+fX2EfAN9fXyFfQR8fXx8hX2CfIl9inyFfoR9BH5+fn2HfgZ8fXx9fHyFfQl8fHx7fHx9fn6FfYJ8hX2EfAZ9fX18fHyJfYR8hn0BfIR9Cnx9fHx8fX19fHwCAgQAgIOOo4ze7fiVv7zMqKPdt3ax3LTqcq+DfK6Ex8iVl9+X2vuLyb2q3avgfqGmpbDf48WovNS2m9rfld+ny8LO2863rbXV7uHrvdK+gbTBm5iS7evZrOuVkPKDhPXt95emvqCamZKJi4iJj5uSkY3l8aacqa+gpcWLuMbW5P/O7/aBgJi90ca6us/S8MbGoLyl1PCW5IKsr4alpJqlzsfI+LK0uKzgpce+tuTg8eSki8qIvfyHtNT6gs7NnomD9uDVp4zedn7Efn3csarMw8fh5cSmhf7S28bG5+qm1oGEfYfyy+XX2nHZfIiCkJaVlI6dnJydr8vAx72Eaoya85/Kf8BygKqekX3UqtGZzN6OhcaonHmyo1lYpWqyvadZY2Bgd36HvIWPc8dztI51uPWRhrXc5dvz2uDioajIgtuSrrDohO647/X698KKit2qp86Uh+XHsaaMroXpionsko2OqWh3ZnCyh5Gfl4Fz1IeJhYySt7jn4NVpoYWYc4rHrZmGkseFgKSLfrxtz47TeHyRmY16iIB8q5q3f5B+p4SDmpFmgnR3rqK16dnphpykwMCvqsCZ0cPW6MW+tZComXuabXZ8eG7EjsWkoXqfsYhbbnlgo5TGnr2ipbdv0NmCeJeFasCbtrKvjXiOenKZv8W/kJahypmXs4SIw73aeq+Xmb/fkMC8gNCVkrO9oJxrwoGGdoWV3ZaGqM/KgtWUzYGPnuqM5I24zpyc2MZ3hqSzq7q7mNOSeJie3Kis7paRjZuxc3V7abK3dWe0schnt8OisuSLd42CkfvlqvKe5cK3sLuAi5aJ/aqR7oWxedfIla7ihL7hxe+atvOEp6K6gqDVwpeAjYCUgH/ekpjIjuSVfaHvhtLtqbXhv8S1ypKShpuStIK+rs+0pb+Ji45+ko3CpKDowqWVuaPA35/WhL+LpIWMio7K4Pno9I3O336c8H3Z2nrMs6zetLfQvMOFsLPP7szZ28XDtLzhz7ywjY6LgnWPnsKJ4od3uHWUh6jGknqpcXN9q7CsgJmihfOgve2Fe+ynheCG5YDkeZTZ0MaRq5yJu491fpuypo51h4Oomnt9jXmOkqSiz9rNsOmsp6h9wHywy+XAnYKjpIh0rruJdrajhn5/k22gxWlsi3FylPKF9YvGhciUl6DFnpzeyb+cqY2vmZWZmMmdys7m76G6spCKsvb3qM62gOaOivuHjsikluHioZTM5Xuc0t7wzoqgo7yac2JgbpewwfWMvYLRmaOOqMm8ndyF0brtie146Hj/4sbEgrjWkIp4jnuNrvl515qwnpJ8yJuUooyefLaiq9mKmdia8OCtqZ7XqI+goZF31vWugoKvy8qZqbrCm+ezprHZ2ch96rPBgIaYrZXv9vabqb3ZvcD/34G54rXzgr99hruR0Nmcn9iN2/ia3dK315SqhJaNhI/U0NrB06utmOHlmuyy2tDd2MC6tMbj4uDHq7PCd67TrJuUzMfGotSCd992hfjz/qKminNvbGdgYF5eY2loZmOfrHhxe3xxd49mhY6bprqUrbVegG6Gl42Eg5GSpIiNcIV7mLFuplx3e2F2cnFyj4uPp3V3fHihdIuGgqeouLKDcqh0odx9sdTweL7QrYN89u/YqZTvf4LKhoTjuLPYzM7n6c2xiPrc5M3K9Pmj2oWGgY730/Db6HrohJiPnquqqaKysay0yOTZ3NabhK2q/KnUl+yQgMXAnpv00Pmt0cqPdqyemoX424aA75jw//yIhoaBg4KEvI+ffNZ6vZR+qtp3cq/DgGSGfMO/dmeaaaxtg4yuYcaexMnTzJt0eb+VoNejg+bXwbOOsHDBm5v+np2QvYuUk5zem7ngy7eJ/6mrobCt1Mzy4/qW07C+mKjXtqSgvfSwgLaxq9yJ7Z7dhZK4xLacpKOo5cnnsLmOtZ6dtq6Gn4yUx7zM/fP/jpylqsW1tcOmxbfV1sLOrZW+sZKwhI+Uj4X7x/jCu5G1z7OPq7SNzsX1vebQw+GK/fKbkrKjg/bL6d/hpo6oppu68ejssLDA8cC70o2l3Nf/lNWkr9b5otPFgOaknsLPvraE25eohpWk96uauurhieel3YiZovCS8JPF3KGc5NOChK63rbrSoeqmh6qp27Kx85SIgJTAg4qTg97ckoft5/mA2d66xvqTgZWIl/3+vvKT3c/N2d6PmqKL9KCN6nyjgPrYqLjwhcXw0vKitvCArrjCi6TLt5B4kIikgIjwpqPmovqihqL9kebvu8/80NDG2Zqckqqdv33EsNbFs9aanZqOpJ7DoaHnyKWau63K8bTvj9aWm36Mi4/C3vXx84fQ4Yei84Xw14frxbjswMPaxs+Jur3d+Njk6c/Rvsbk18a2nZ6XkoigqMuN7ZeP7o3CvMHTmIG8hYWJt7+5gKivkP2fvf+Lg/m0je6O94D4lK757umowLeo3LWZpLvPxq6UsaXLxZ6cqqGuuM7Q7e3Zt/mun8im94Cq3+vTtZS0tJeVztiUgNu5moSXqYPW/oOFtq+gwPiF54zQgaWDfl6no5je19q3zq+8xp95d7KHrKXG4ZGTl3p0kNLXjrqfgNSHc813daaZicXQoorF1oGVytLLqXmRo8yuhW5ygqfCqLNtomWdeoJvfJOQiqxls8Dog9mE04Hryc7IbpDAk3B/noqYx+2P88HQt6yG2qevvKOpg7eLhsWRktiJ+eywiqTgn4ursJmE6PbAmZuyz9aSvr/ho/7XqLTx5sqC8r/LgDc7SkNPTksvOD9HQUdoYzxMWTY/GTQ4MUc1TU1HVHRJUVItQ1ZSVDVDNU9NSlBSSkA/P0FCOj5FMkQ3QEc9PEM6MTk+PDtNQVJtMzJRTz46XF9wY2I/Prlaedrh9aqiXUVERkM9Ojc3Ojs9PDtjbFJRV1NKUV9CUldfZndecXI6gERRXFROT1haZFNYRVNVY3JGaDhFRzhERENEWFdXaEdGS0plRlhYWG9tgIVkUXVcWpBllL3SZ6LHs3t627HJnJ3+h37FhoLWrqfHusfh48uveMy/wrWq2+OGxnp2d4LautnM8YP2jKWYsb+/vLrGxLzI4/rx+fOrVVhZuarLhshNgFBIPVPPkIVspL15bKOipYKvoF9PlWmwyLtda2ZWa2Z3tpe2kfCM1aiHtt9ubpOeXkVVSo6dW0yDU4RbcHWWU6yEopqmo4BdYY9kYH1QRnWEdGxNXkt9VlKbYl1ZclBXS0lsT2h/bWFGgVJYWFlfhoyuj4dBdVheNEmHe2VWW2pEgF9TRGw6WUhoQkBTSEA7Ojo3dWN0TF1QXlRWW04+QjIrMixQbE1lNUFHcUg4SHFgjXiKkoB9cGRpY19fPkFTTEqUd4xdXURFd2BTU1Y+XVFvSFdQbmdRWHtYQU43M1tKQE9KOzc/RERKZUZRUWFccVVehV4vclNuMVxrVk9tPWhqgHhCUzsaUoM8Yzo8JD1cWklWT4GEQ1c/dThGY2UzTzBTYio1glxCSS04M0BcXF9XKCE1iWR4/Jl6e4SqgIWFfe7uh4T18vh8p5R7fpJVTldaWqSlT1QqVEeDj49hMCk8VzMpUi87J29HJChFNUZEUmlNXV8xMi8xLDQpJCYxQC08gCE+LyxCO0lNO0xeSqy1XUlOSk44UTpOTDc7RCVEP0M6d35BUEc9O0UwNz1MQyMhODw9UjlEOnhKKiMvLBsvQUE5YzBVRSkgRSA9P0RwSEJKREpKSEAmTGFMb1BJUmFBP1NUU0pNQ0g6Nzc5UmE5VEI9eDd+eZR9Pj5SRU49TGtdgEVYRoFZZp1QT5BwQW9MhzRiU1t3bFtqpI1VYmFRYneDfHJgb2VnYVtXVlFgVWJucX17Z593Zmliq1tvhJZ/aEtQSTw7QkhBQENDP0k8RD1ofjg1YGZmgZdHb0BuXoVuZTZ1UVJ6fGJZYWJrcXdnZpd1lo6x5qGDiW5mfL26eaaQgLh7ZLNqZ5ynjLW+q4jT1J6jxty9jGyRv/vUr4qSpcbcl4ZXhVOGanNnZn17hp1VlVpuRJub1YXNrNvXaX6ywGSz0qiBiGQwSy80MSYtX1BMPjQ2KUtIRFoyNVo6X2RRREhLNi44OSkqV2JXLSgzPUAxNDtCQVRCRUI+R0wpUUNEh3yFfQl8e3t8fHx9fX6FfYV8C319fX59fX18fX19iXyGfQF8jn0IfHx9fXt7fHyFewt8fHt8fHt7e3x8fY1+iX2HfoJ9kX4Df35/i36EfwF+hH+GfgR9fX18hH0Gfn19fXx8hHsHfHx9fXx9fYt8h3uCfIR9hXwCfXySfYR8BH18fHuFfAF7hHyCfYR+Cn16ent7ent6enqIewZ8fH18fXyEfQ9+fnt6e3x9fXt7e3x8fn2EfhB/fX19fH19fn5+fX17e3x8hnsFfXx7e3qEe4R8h3sBeop7Bnx7e3t8fIt7BHx7fHuJfIN7knyHfZN8g3uEfIl7AXyEewN8e3uFfIV7g3yEewF8iHuHfAF9h3yEfYZ8g32GfAp9fH18fX19fH18hX2CfIZ9A3x9fId9BXx9fn5+hXwIe3t8fHt7e3yFe4V8G3t7fHx9fHx7e3t8fX19fH19fH19fXt8fX18fYd8jn0DfH19hHwGfXx8fXx7jXwBfYV8AXuGfAV9fX18fIR9hXwCe3yGfYR8C318fH19fH18fHx7iHwBfZd8DH18fHx7fHt7e3x9fYp8DXt8fHt8fHt7fHt8e32jewh6e3x7e3p8fIR7kHwEe3t8fIV7BXx7fHt8hH0De3x8iHsDfH5+hH0LfHt7fHx9fX18fH2EfIV9hXwBfYd8BX19fHt7h3wFfX5+fH6EfQt+fn59fX59fX1+fYR8D318e319fHt9e3t7fHx9foV9A3x7fIV9C3x9fXx9fXx9fHx8iX2CfId9AXyEfYZ8BH18fHwCAgQAgKPljs+k1bS8x6KpsX900JiXkIOftN6DlMykp4GtlNCxgOWFe5HL2/qf0MHr9ZPS+4+xhJaW9OzNmJqzx77as7ukctWJ+ZK6mbfPxMr/eab2y/qv2b66rqW2f4yKtqCa76+gpLuxoZOWn76zq7Cgi4j4g+XMv+elmo+Us76xg/qCgJaeydCmhpat2dzW4oyttKKXhIPK4sa3zs/rhZaGoK2F8/+AksOHm5OD46Xgs579gYaNv8fu+e3GmYKAy46jr8HKdeGuxt/Tx7Clq6i7ydjFqoqDhfaLo4LKh46J64qF5sG2rrK/e36BhIekppyEfXF6ipi3traX14CBxKy2mXCjgLmuc35+cW+uf8ze1dnzsZ5pbaOPhbGYeXXSgnPhk5mEepC9oX2VjXOlj3CBmYzF25nclumnzILn/qLc1qjB1KzDv6W+5tyPjYaGyNTNpZiAloqy7NnigIKOin6o43Cyech8z26EjYyCeKd0mF17a7fpprNzhYZ8l5mQ26DIm3p4gI6YxNGxwX/A4ORve37e1JjEtIWntZpyn3enoHrAdHWalJ+jxsl9noaD2X6UtZOYmJul3taohX2Zt4Sed5CKg55oi7ifh7eExb6JZpF7mJbEjcyXvH6ipK50cKy3nKKknqtkx7exbIRwoKHCqqm4lHylorWihpzHrZyfmZum38J9gLF0iovCpaasyrepeo6NrpCwmdnez9TBtpmFkoaRyrSvuJGVxcvGfop+hqq9l7amt5uXnLbfjtLo24Ks1M3DtJ3HgIWxwstvdHe7s9DWx3V31OZ2zsGr2anamZWmuNWCm6GIsM+YwGnIcYauddZz2Yqnv5/ei9nTwp+WloqL54WygJCjjdKPi8/Dknaln76SpbDZmt+CvuLCvoB0qY6s75ShttSU25jUfYHh58us+YqA0NJ7enua16mCmf6fsZKnkNr4sZT/z822hMKF2Huio/HUtdd72Hr4epeLjOHBxOS7tX+L6b6ipK57yK+equrgtK1ke32Wb4mw1Ipsdd25f4CXgKZye3/go4Cm39mG5bnnfrF4v6TbmYF0uoJqlHBikq50omp3bnl1dG9xhX6KeZGTn6O83pXR9ISBfuXh7bfth4N1f4mbg4Xnf6fxzKTNd6OgZ2xteFpQYIapuN3cyZCnhaLCubqZgH7nkZiBdq7HnpTY/ILJ5qPC5oGImJKqndT9gM3ug+/HhYH0cO6EvMJ/rllt1OyrsoOXos7pZ2FjY26WuNvon7jbtd6s+/qttZuhuYKbuq+BsdiC98jAZKGBxpLyko6O5eTZmpJ+jnqshJecs4BzyK7Jw+SC+fDd48uer5y5vK6OltKPcseXyIij1tOnuazE09bK5+KggqOF78HmgKf2itmw0Zykuqqz1qCK2Z+MgpCt0PaDi9/Ds4WbeaKVj8qRi6Tf0emgt6rX2Ye865Otk5iM9Obep6jD49jxxb65guxw3mrFprrlyrr/hKPvpsuZx7Conqm0gI6TuaSPt390dYaCdWlpcISAen9yZGKwXaSSiKh1bmJog4qAYLRdgGtxkJZ1Xmp6mJuao2d+gnhtYF2MnIqCk5GlXGdfcnldsLxca4xkcW9msYnAno3lgISJu8Ll7d7LpoJ8zqC7ucnYgfG80+7d0bipsKi7w9nQqYJ/ifOHqIjPjJeW/JGM88q2sbnHg4WKk5W0uK6QhnuFnrLT0M+x/pSS4cLSvYm8gMu5hIyFk47rlMzfw8fkvM2Rg97n0+yzlYjwj4Hrq6qJi57RtoehlHmkknWAmYOqwXWUS5V5tF6lzXywrZauwKbDuImQy6ZrgGhtqry5o5iAnJ666rmxkZOao5Wv/Yfrm/aO2o23wbmXhamBuIOnhLfnudCFsKmfzMqu573pvqamgLKs3urQ4Yzc5uqCnZX996nm3qvU+saEr4rAuJb0j4i1r7m+3eCFmpGJu4OcwJubnZ+p09izmpGpzJWxiaObjK2DxeKvnt6V8vC4gLmdu8LupPy/36bOysyIhd3e0tnY09qA8O3ZgK2f09j53NnavKzJwNGzlqbozq20sb648tyLgM+BmJziy8HQ5tjLjaam0qXJre7q4u3RyKGNopKawrq2zJme1M/aiZmMmLTLqsC62K6cobfakePv3oii2eXu88b9mqDb3+6IkZTr1efn3oiG6/mB6dKv5bHpw7i/wtmDlpyMrsuc2YHlh5bGh/qB64irsaTZj9jd0ZmdnIWO7onPgLC7luCimdPSlYG7rcKcu8Hwo++WuubAx5GAsZGz9JmuxPCh5KvwjYTT9cuu+oiH5N6BhIWd4LWAm/ebtZaolOD1spj929y8idCP94asrfvavtyA34D9hqGPj+bP0vPGvIWJ7cCqsrOL4s+wteTsxcKAk5LEjKDA5p2AhPzIi4qmgLeDh4XwpX+p6MqI8sj5ia2G1sD3uqCT0KCKsZCGrMqSxoyZlpyWkpCUqKOwm7S8x8jN2YPN35akofjp6bv0kJKDjay7mY/ul7f52qn0i8/SjZSQoIKBiZe/tvT814itgY7RwbSei5PsubukoayYfHetxmmyzJibvmxwe3SDeLzcgLfPctOra2jtcthzpbGEmmN62Ni1jHCXrtDpcHB0dn2mqKO6iY+4ma2Q0MuXnpGpooujwsGJscd34KnNZ4tzx3PSmIqGxr/6rJiKko/AmJWvyoKA37W+q6xr1N7l7eKvn5y0prqbp8KPgNasuZWz5OSuqrrl5Pvu/PmyiKiG57bmgEJfNks9S0M/QTg7SU09hldGMiwyK0EwQGdPUT5XSm1QMkkrKjlfYV8zTW2Nk01YTyo3NDgvTkQ+MjAxPDw/NUEzJ0coPCQ+MzZYRz5UNj1YcWJJT2qFYpmdcIKNraB+fktHS1FRSkNAQE9TUVFKPT9yO2hfWG1JRD0+UFNPPHI6gEBCWFxHO0JMX2JkakVWVlFIPjtVYFVQXFxoOkI8Sko0bXYvRFtDS0hHdmGAXVa+QT5nm6PFy7rKpXZ4qFaCosXghvep0/DZz7Kfo6K3t87KlmVhbMxwmHq4hI+J1H1906+fobLDgYmToKbHycKcjICQu9n99vTF6oR4s2vGsVx2gGpSOVxtUUl4Xq/OuMLnwqJeXaOViKKMcmKsdGGujpx+e57ay4SzoYawqod+jnOPmllpJ2pXkEaMtV+bnoiox62+s29vpH1UY1BZfG5lU0dFZmNuhXNnUFVgWk1kmVWLUYJakFJkZFxPRltNXjY/Toqhb3I9SEA/RUdWi2NzVURIgFZngIFgZ0dvcGwyP0Z3YUdZZURSTVhMWk5aWUVwQj1ELy9FTVYqPzI+hiotRUFiaWhoh4dxYlpca15aOlRcXWZLbHdbV4w1dolePk5IWFpuW2VOcFR0bGg3PFRzT0dMTT0aWFtbNUdAVWFzQ1R5dFBvdXVqV1uGZWFPT0xZiFk9gEowTjVFUnYxSDdKJyMeXkx8Tn15ZGhbXVcxUyswLzM1Rxkdd3U9HyQlJEV4RWFHNThFNVlfZr7x6IuNx+71+t/5hYLh5+2EhmKLiouMi01TlatSmWVKR01PfHN1T0gpRSsrRz4uUjhIHiJFK0QqWTlJXDNSLEhKSzcwNS9BXi4igCItNkI0PFVmOCxcgZlRVEtjIUIzRUtYQjEsOCNBM0I+goNJUzxjNiowRVFCWB8rRUMpHh8fSEIjHEZSQicgGlJFKiJsUEdBHDI5Z0FGQ09IRmMuWyxNPF84MmZQUIVHQCg3Y1VPS1M+dWVIXZhYT1pAOT9oYW5ZVlNMSZR1RVdSgF1HS0mEX01shXtRdmWOTkI9bWSBbFpUmF5SbFBLYHhzc1RYUFxbVVdVW1FbUWhkbmZhgWGRkV9hbqmbm32jYlBFQ0lJO0GEPUFwcWZ1OWduU1NTXFNTZHONZnNnimZkVVJOSkdEOj9/bHBjYo99ZmeZrlyjyJuHplxhbGhyaavQgLbTb72RXV39lNdrlq2bloOd59bYdWSTwuH3jI6VlJi/nHqedHWahpiItKqLkWhBbUQ9OTQ1UIhEpqLSholn/H3Sv5B4oldRNygmKStFQEpGQislRk9WW2UzYnJfTUc8RDM+TT0rLEAsKVQ6Pi0qMkAwNj0+TkpKYl9CN1I4a2VaAnx7hHyFfQV8fHx7fId9h3wSe3x9fX5+fn18fH18fHt7fHx8hX0BfIt9Dn59fn1+fX19fH19fHx8insHfHx8e3x9fZB+An1+hH2IfgF9jX6Hf4d+hn8Dfn1+hn8Gfn59fX18in2CfIV7Anx9knwBe4R8Bn19fXx9fYZ8kn0DfH19jXwEe3x8fIR9g3uEegd7e3t6e3t6hnuCfIZ9EXx8e3p6fHx+fHx7fHt7fXx8hH0LfHx9fn1+f31/f32FfIR7gnyHewZ8e3x7e3qJe4N8hHuHfIx7CXx7e3t8fHx7e418AXuIfIl9k3wGe3t8fHt8iXsBfId7gnyHewV8e3t7fIt7Anx7inwHe3x9fH19fYd8g32LfAJ9fIV9Bnx9fXx8fIV9hXyGfQZ8fHx9fnyFewh8fHt7e3x8fIV7Bnx8e3t8e4V8BXt7e3x8hH0WfH19fHx8fX18fXx9fH18fH18fXx8fIV9AXyFfYV8BX19fXx7hHwBfYl8AX2FfBB7fHx8e3x9fXx9fHx9fXx8hH0OfHx9fXx8fH19fXx8fX2EfAR9fHx7h3wIfXx9fHx8fX2GfIJ9hnyCe4l8g3uFfIJ7h3wNe3x8e3t8fHt7e3x8fKJ7A3x7fIh7iHwDe3x8hHsBfI97inyFewx8fn5+fX1+fHt7fHyFfRJ+fHt7e3x8fX5+e3t7fH19fH2FfAV+fXx7e4d8Bn1+fX1+fYR8A318fIp9A359fYR8AXqGfId9g3yEfYV8A318fJt9A3x7e4R8A3t8fAICBACA3I3Zgpia56bOsX+ak36Z7bvU2qzRdqWoiZfGhribhumKoYWN3MLSxursq5uTlsLSo+Lb5qS75bCcgL+IgaKmktLfyqjL7o7Kk4HFhKfQ0frKtai6jYW31on38o/y24DHup6dpKysmJajnJ2bobSgn5SpoaSWnZSTg6Ogyaakur2AoIivqqedkpe0w67I9ZSnoJSB8vTy0OHj9Pvvm+vZmZL394vXzsWOspnup92k9bLv3pWtwrXp/tG245DymK/Wr2yHjIeKfMHXrqvEsbvOy9fm7dyTmoO3komlkb2r2OHs5/T5rZvG2bawz36AfHmFfHx6ho6IlHuVqozFnZKylnyAdXuWesrHkHOrcszxuHXFfHTuj3Fq4el3pcvJmc5y6ddswdF00pGKqPBxosCGxtrxkd6/itSHzeuagMiWqZCZcbLzsfOm+NPeks+8meXGpIqIl+/kg4P8jLeog4XLmnuZhX3HcXWRjYys6sFvfJqPhtG+anuhm4TFsn6Pqvtxd3yAm2nB2LxpfWd/isF8faGjhn6Qeb2vuICRjKBprXXKnIWUiZfOzsSTg6PC54R+rbmDjLWqoop5d52CjaeDq5HimJ66y5CKmMyG2ox9cWGbf3GCdoebap22tYBqub6Wl5Whn3qhtXelnLBqfYtxpqGXeMp7z8q8nXCPdY9+p3aRgH2AeXDA0LxzmJbHq3l0bnnScHzQ03mlu6/Oxb2l8o59yKR/pYe27Xi1wIX2poCcyLDZ1cLhf8G8z5Wxc/O6kr2epsmCkHHCf7a0d4Oh0a28o5SA6I7JuaWA1OSakqHDkMTelIjb9NKSe3yLsLmIjYp70OydkKHX55DFo6h8i3uMl6+Ah4Zyz9p+v4KTkHqDzNmvk4zRrXSroYS71qGpgtv5pJycw3ulioLKpvmYjO3dmJLNf9STgYu+ht2+mI2qloir0vGC9eDCj7nTzaR/dIaf8eTJ28KnqqDrrYCR3t3BxbWPm7rG6aK0oY2mv6zazr91gYOTmn+kmIuLeqifo9h91N2Af8C6o4O1lep+nZJ+hLSlst6107CIeHKYdWeEYqZmgIqWnXVlaWxkdnCOlXx9fY+Ni52At9TSqXuCoZ+Reu7uuJONfZab5cySoum/oJuRenF0d41atFtcs4rqgmWFsMvl2peDjpi/gcGNc355zpKMy66VhojKdsCdqZqsw9XLz76AgOzJu9SxuqF3x+e0rIx5XVfTzpm50I6m6/hyq2t2yqG1xYSKnNy1iaCuj7fZtNmUtd+CfYfKuIjQ6+XImoXTk67F58nLnZSml+ObjNGywKivo9jTqbGL9qOIqNCXpdHXp57ZmoePmXyQeH2gsHuU05nOoLPAkayvlO7Qxoj50nyA1InFg46D4KzQs4Koro2W7Lzq76rkhLK2sb3tn7GNf/KVppSW+tnqzvnLoYaIlLy9p/br7aOy5KWihNN5dLq8oPH+77LBwpC1k4C3dZPT2+LBlqWkfn6sz4f9+Zb1wWGTiXBxdXt8bGt0b25tdX1vcmp3c3hrcGptXXh1knZ2g4eAbmF8eXRyaGt+iXqOsm58d21frKqolKSirrSrbq2veW/Cv2yeoa91jnvBltSM7Kjy4pKpu7De7tnD6YnrlLTis3eVmpOWg8TbtLLOtb/Q0Obi4tKUkYLAnIusmc643+j67fv8tKHO5sK9446RjY2ajo2LlKCZo4imwZ3vzLDWvZSAipW3ld3zv5nsitX295bom4P4qpSE9vyF2ebdz+WE/fOD5/+E5ZmWreV4tMh8rcHYeqZaUJNenoxhZLKNjoWMc6bajsOBt5DAdpqMicm6nX+Ai9rcfXLvg8PUspXmsoyxj4fYiKC9x5a2+fibsdi/mO7Yg5ve0Z/U3ZGdsPGDmqKA0IDp+OuHloaboPeUh7W4mpiqk9rp7oqerMuM1Ibxs5qtprDh2NSZj7um94yOv8+EkraurpSKh6mZlr6SuqX+otfl9KGivOWN9MGkkYa9l4Gbi6THgcXU15mC4+XHyMPX0ZbN9ZHWyt6HlcKR18y9ofGK8ePVq4KmhrOjwoqkk4uAj4LR8NqPtK70xYqHgYnsgonm6YO70cHh4ti5/5iK2aqFr5PH+YHOypj/ooiw3cPx7djwj77D05e1ee+jmt7L0f+fq4flluTalqfC9M3FtqmA+JPrwLZ8xN2sorXLksfgjoDV8diZipCk0eCuqo+BzPuimavd34vCm7eDoYqXo8OAl5uD0+mQ14GOmo2V1+jBm5LguoGvqIDH7quwi9j3tqyp2o60nY/oqP+XkPTioZvOg+OUh5DEjdK/nI+wmY2w1/WG8u3Lnbvg3KyNgI2j8ujN2sWxsan+u4ac6u3L0L+eq7/P8qu+sJ+y17rhz8+LkJSnr5C/q5eUjNDEtOuH4eyAiePQoIu4nPGBmI+EjsbF0frO/tWmk4y0loekhO+On6u7w5uOjIuFlpevtJaeobS1tLGBrtfEpIeSsrasgtf31KCPnLax/OWfqP3OqMixm5majayG+4aCw5TnsoOt19f10aeRoqnOiuCtk6Gas3N/rJaBdXm7c6F+hYGKm6ektayAa8qmjqWOmah4oMCapZZ5Z2jNxaGUs3yj2eZ+vnuH3KqSkmhrebeScYiHd6W+sdCLwet+hpLJroHd8ufblXbDgHSovK2/nLOwq/GipuzEu7TCrubSsbiM8ppuo+SKxPj6vZjHoJKcsImghpK0o4uo7IS2t8urr8bDm/PLuon1uoKAUzhgOEJCTzc9NzJCTFdsekNQUTQzJjNMOExpSFtPPmwsNS0qS1dgWGhZZmdaPUhTOFxRSTk7RTctKTQlIjI3Mkk+SDM8STFNLCw5MUNkY3+DZExaVVlspXvl5I/dnUBaUUVERktLRUVGQkRCS0pETEdJSUxDR0VEO0tKXkxKUlSARDtLSkZJRENOVktbckxWUEc9bmxpWmVmbnFnRmx4SDSCez9kbXZUVVBrXnpWdIyvfFhckIqtzeDDtnjOc5TMqoSko5eZfbPJq6i/qLnGz+nKurCNfna6kYWomLGZyNbh1uHsrJbB5cPE9J2dm5yqn5uXpbewrJG435yLX2usaV2AS1JwVZSndFaEW5KxpHHOcF62a1xXwblfmq20m65fy7pbv9CK/a6tt+mI0sRxk5utXXksNXVHdGlMS6eQd3OFgKfWeZFei22aX3xxYXZuWEhicJ+CRz+YXoVpWUeidGFsXVSTUk9aVVpwnHpAQ05VS4d0PENKPkNZT0lVboNGRkiAYTl9jnBARjI4QkwyP0ZGPzdEO05NZE1UVFYvX0p4RDc/Pj9iaE04NlF1YDMyRVpAXnhpZ2BYVGFbXWRbZlyxYXeBglVQY4Q3j1xaTkFkVD9APUVJNnR0ZzIrX2VIO0xLVStWTS1KUFQ3U2EzYnqAWZxYhWNoazo2QEkxXVhGMFGAOz55gyo8NjQtOigeGSFBND96dElmclJgfVBJWCkm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iqa60eS7x8F+3dDs29CjrLWct5XHtJyGi/aB+qyKmZWnoKuyzN3t2qXr3NDbqKbCv6bZx7eVq5mjgZGhkMiBzKe3xNvJv3KLybfdxsqAi33InquayJyTzLWAxujLpa22mtro6+HQwc2dl2ukmYZ6dnV/dJaEi4J9loWEeXVnZWllXVyAgWVmg2qGosK9hsuF6rx/pq5ndp7RoJCSt5CCiImKn43g7NOSY66mW1WOfpmgiYh0dGhpjMSKyZmM0nCKwb/mopb12pZ1iaWPtrLM9NX5k5CWn4CP26KAz+HGxIuBm/mrjJGO5K9sXWJh3cT87MaclvZvjWBrdHmdwZ6nlZKbleiEx5PprOW1yOB81I6GkaPKudRomeKBssLHg6zas8WZmLPatozPsHrWx7W8w+Wsq86ohK3F4r3ZfYCSms2tmp+r2JSNn4OIs4i5nJ68lHGi6cyF2ICAlcSAnsdykMmSlLe+oOXgzpmAeJK7+8P2nIbj7rKR+7Hfza2Cn4KCgf/qkYO2ddKd1d/E4oS4mJNu3aWjn8Tblomdk8tskoqOk5m3pPeRtZ2hlpae1I/RirJw0deotHR9k42bjoB1gnuHen1+e3JvdHF5aXN8e5earpJ9bYqDj36PjqqAoblqaXBssaOynmKyp6RkZKOwY7Ofhn2QYp6Ng6zItJmijqV9dpOrsMeSloNvhoXSvvmJlIeW1eSpgeCiz+u0kaiIlZ2un6SS7P+EjebVu9LSz8Ckh4Gg0ouj/8DTk9nL7JeZhfPijpWVeJeXlJS8rJPtjqCI6JrKmJXq9fq+uJmAkIaE+9SE4JSu0ub1ityShY+RtJaL+IaNxOjR0faS79DN9vCDe6e0o8+J2IzWv8uXwpSFf254X6VlkXt/nJOKksDudWdhamWMqKR0p3qiftyBhNS4gWybkeDopum3j4SPtJH/iJ3RxOi1xpCjtNzXsqeTnLjH7rm5v4Z7fZbf6eyA4d/v3tXbu4KyuJ6R07+fjLbBrcmC7JmZwOKJ6KOCn73BlKbwxeeh7rGo7fPylYLKip6tn52HkI7+h62trvzonoOE8o2VufSworDap5G/+9SOuI+JhZvpj+D9gom5x8Cy4fqA0eHmucXstYmD88ictr/Xku3O2prC/KSKpe6Q/OmAlOLcnqip3oWIlPuhnI+Ht5Sxv5+NnIes3ZecupiYlo3RzrWRvvil7dCXlpCZmJHP/8Scm8WhsoLb+ffY8Lyx2PKEl6uUm5ftr5+qt6PC7MOkxsa1iumKqqituOCkqX+N1YvS08HprqChsKSBwIe3gamN/vqog4Og2sOTkeL20NGA+t2K5+7g8daLqMeEt86ijdSdurbBhay2gIqfhP2M3sCq8YOPma6zkaK7xunL1M+G5Nz56eKztr6hspjMrJqGi/iA+bKVq6myrrPC5ev74Krt4tPbsK7My7fjz8ekvKeuj56ulsuC1LfBzuLPyICg2cXu2OektI7qqs232K+g1bqA0/7dp628oPD67+7q09++uIHKx6+kmpaalquoopqgtqisnZmMhYqJhoOjpYaQqJCnw9nUitBr4cOMwMCDhrLXtp+S3aydpZ2apYjn/uqvgfPog4LcvtDZm7CrsJeRuOWc1qqe74ah3NfpnJTjvZt3fox+qJm/3MfYfXN5gWl1yZOArb6lq3pxlOyTaXh/0bB3Z3Fs2MrMu76fhO13mnF9hHx5lHZ9cXtycsBkoIa/k9Soz/WC24t+gpS/tMNyj8Rrm6Svi6nvxsmZmcL136f4uoLnzMC+vsGXnLacjMe38tb/ko2cmsy8r6u256OesY6JqHS6rLWsrIS026ZsxXd2iLaASG1IUXFSPT9LPmBOXGJhUTpAbkZHOVxnbUovVT9TT0UyPikkJFFLNjpMRKFjaE1ESCUwIS0mRDEvLzZMKiExMzknLSw4MC89L1k9X2dcYGhhcklxY3M9h7ORlmBkZFdcVVBJT0hOSk5OSkZGSEdLQ01QUGNkd2JRRVZVXU9ZXnGAbH5HR0xMenB+bUR4cWxCQWp0QXRjU01YP2NKT0yJa0hsbWRUWGeSjZNgXVJPWlx9YptEZllbpdGXaMOUpsR/c7KRn6OznJ+O6P6ChdrNuNPYya+UcnSdxHyW5qbCjs/Q75uehtfjnKakgqKmqKjSuZ7+laWL0XG5pJ3DloxhVVOAXlFNiYVTg0tcb4qlY9qgiYRhallZvlNCcb6cn71uwqKhvrZkhb3DosiQ2oGtnJp5l29dWEJJNnxHdIV9l4+Gmb/5bU5FS01sh4pfhEpZUZZsb6x/V0RVXYh2YZOCYl9ldV6uVltzXpJqZUJMRkhQREI/OEVOY0dVST5OUl97cm6AaWB9j29tUy4xRjsxQEA5PkRKN0QtUVJFSVwzY0o8Oj9VRjx4gGE7aVhqYmA9LyxrY2ViX2ZaU1yoWWNjYqCeXkVAh1BQdmBDUWBnTEd7n48xRTw8Q1yVRE1MKTNOQ1JVWFosUV5hVFFtWDk5f2lpgWGhaYZrYFVdhks1MqQ1PoyAZmWMTVU8UTcxHXc/JyM/SCs3U1BKdWtOPk9LSjNMRjBdRlJSSVBghmAzLCklKjdFY0s3KVEoKBzn7svd3dLO4viCiIqAiITfaGpvb2mBk4B1hoF7Iz0cIDtzdk4vLDMyWyBhQ1NIQkFCRTw4Ti1UK1pFSk9ZPUdLZ1g9JU1aR1OAfFU1TkpOVUc2VlgxMT04MkI+RDpPND06LE5GJUkfQW9Nk0JHPT9KKCMpJj5AX0ghVD42Njk6NEI8dz9EIB4eMmE/a0Q3PT40MUBFfYiWUU5VUlBYRUROT0xZU1ZPVkJBOD8+THItXFZKTEtYeDdFa1BEPmxgbEiDcW9twHpLbl+AUY2FbG9dU3WXkW9vZINsaD1rcWJbVV1rX2NkaVxdfIhtUFJRV1tYVFFSU0hPWEtPUVNaQYRKj2RBZHNPXHOZmXRue0U8OTk6R0x+fWpqUamZU06MhJOfg3ZwaFxYank8Tz8+cjM/Y22WXVvIuK6Dfn9ynYCox667bWVtcFttvYKAm6mSlGlmlPWIW3B5ycGXgY2I19W0pLunee6OwY+en4VidF5kXGdcY6xUjHahgnpNYk8wVTYxQEp8dKqHhatVgoKdvqWqTEMwKkNIPzJHQytSOE1SWFtZbHpyREtHTkJQKiQxPmYyKzFHZU00LycoMyY1Myw5NypCYGBBiltWWnOFfIV9Enx8fH1+fn18fH19fXx7e3x9fIZ9Cn5+fn19fn59fXuEfAF9hX6LfQF+h32CfId7BXx7e3t8hHsDfHx9pH6Ef4R+CX9+fn5/f35+f4V+B39+fn59fHyEfYJ+h30Gfn59fHx8iH2CfIR7AXyHfQR8fH19jHwOfX18fHx9fHx8fX19fHyLfQx8fX19fHx8fX18e3uGfAN7e3yGewV8fH19fIR7BHp7fHuEegF7hXoBe4R8D3t8e3t6ent8ent7e3x9fod8EXt8fHx9fn9/f35+fn9+fXx8hHsDfH19jHsBeoR7A3p7e5B8jXuNfAF9hXwBfYt8CX18fH18fHx9fYl8AXuEfAt7e3x8fHt8fHt7fIh7hnyEe4J8hnsBfId7gnyEe4Z8B318e3x8fHuKfAR9fX18h30DfH19h3wEfXx8fYZ8iX0OfHt8fX18fX19ent8fHyEe4Z8Ant8i3sIfXx9fXx7e3yEfQJ8fYt8A318fYV8B319fXx8fX2EfAN7fH2FfAR9fHx9j3wHfXx9fHx8e4V8hH2EfAF9jHyEfQJ8fYl8g3uXfAF9jXwEe3t7fIZ7hHyCe4R8iXsBfKJ7Bnx7fnx8fIp7h3yFewR6ent7hHqIe4R8A3t8fIV7DXx9fX18fHx7fHt7fHyFfQJ8e4R8CH19fXx8fX59iXwMfX18fH18fHt8fHx9hX4FfX59fH6GfQR8fH18hH2GfAd9fHx8e3t8i30CfH2IfBF9fX18fHx9fX18fH19fXx8fIV9AX6HfQh8fH18fHx9fAICBACAyNmO9Jb6/6Cfk5Hn1siIqu/b6pCtpIzZa3CskXnVo4K5od6J1dXWp4GgmKykn+m9x+KIgOLQ4oTejZqbfnug7+K3toyeoZv95tmKopmvx6D/f7WNoaW5jb68oOO1g7WwxunSq83DvrDRx8q7pbCzqp+9xbitmaqtqqrE6vn4iJqAnNu03rHS7dbXzOKfzdzy1sr+gYO6qbTGnrzTiZPqzKeSkIP8mNB88ajAobqf/pyRpMTPuK7hmqjdkpDp4tuKsomDmpCQl56I3M3CwLu5pqaut727lXyht+99lO+Wt4t8eX2Yn5C9ssbh0n+Lj4SMpKGAdniBc5F2vYa8f2x9hZqAYJWMhYyNoIlvaZqQimJsgJp3f3J5eG/KvZK+7Kjo2m+jm7OzcLWnnGiEpejjsIT5/onYsZKn867Vrbfbedbkks7B6P7ZtZPO9bOgkITAkaX8itPE7cKEt5ux4oqdpp+vx/q+p6ewkKjc4Hlxh7jjcG1fcYWPrKh/sZ+kr5KovZ6AqcKhj42tvne3s8WktrCKbXvml5elmoFulcKjX5B6gouehLSp5Ph+xb6ouYKEeebOlJadtpSBjYrK23B3fcqh1bHEw4fXeYmElqHmoHyptKp2cs52momWe5N4fqaukamkoaK8jGaptrnMyGyViniVknKsnX2WhWmNm5R5b5GYd3eAzs7QlXCxo5iUd75xet57g8nap5eQ6bernoe2iJXjjHyZu4DVsJudp4B4y+mbpYvotpp6kou9irKc1pCygJ2MoavD1Xp+d3zDecSYlrK8356Wobetr/T2qq3akJ3CtrK21fnAirWJgZOKd8HZk5/Q3Ynfnb7Gv42A+IaAvqbF1MeAga7AjYmVuM/eo8qD46+0gXidoH6NcYORgtCPgoGpmaWv1NLJkLyjvO3HsKF/1rj85Me+uqunkcCDk4f34ICHxL2WgILEqqrGsKmdxbpydru3zvbonZOzxc+8zem4lpiHg5apxcf2tq+7puDCrZukerKvw3Sn6XXk9Ke734LbvNSA5JqR7LnBovGIu6Op0LyaoKq3x36Qp5iKd9C/hXaJnGRkYFu2uVxirmd1uptlbIeOqpOl2YjY6YiAg7O0gtb1fIeydMqGqaa3u8KHxdGtdZthrY6QfIiPyJJyYGZxd3aV3vOK06SGi4bDgpSrjbyQ5rGK7pao4uDex6b6/9KO5bSArJHcitCxzuWappe1saJscXZtpIDPpY6r6KeowF1lerDilaq2ucHux9nyq8yY6samh9GEseuawrOEgLyLmPeFqoyCxWToe6rXhqpqxKLUs9K38o6klau0pLixkImWf+S95Yex3u67crialIKTvbiSpMfAi5LQxZCklumrnYSz7o+Asr5inHLS85uXlZTvzatsg8vW7JS6sYbrgo2/t5DhvY2/qeWH3vDhp5WteZOKd6qi0vB6kva4zInolKuhkoae5MC2tpikipr/7eZ6fpKZ3JvzjsKHf4SYb5qsiti1W398kKqXe5OIhXqQiIyCdHx+d3CGiIF4anl8e3mOqLe1Y3CAc6CBmXqWrpybk59ulJ+xnpS6XV+GeIWNcYeUZXbJvpmJjX71lN6C9aHDlrGOwZiUqsbOxLLrnKnnkpHu2M+PtY6Op5iSmp2C2s7JwruzpKi6wsG5moSku/mEmfmnx5uOiYyqr5zIudPy4YaTm5GYsLGQgICKg62O3ZPaoY+rj/WAiti8tKrN+dahiNXeyoCNjbeUmoqTiozXx5bN8K/754jMy+jQfb/Iw3eSrtvQlnDp03C6pGdZfV+QYZ7XeN3llMy7wrGYh2mUsXx0X1qaiJXfdLibv7mZ1LfX/pqisqGr0v7Asba9mKbX/JGUn9XwoZWEnbC73NaCoK29rpO/1b6A0/LNu7rV34rQ0OvA3cmogYz9rrC/tICBm8TUgrCTlZOxkryz6veH19iowoaNhenXkYOjyZ+Ul5Xq+YiLjPS/9Ozv8pbsh5eSvMXtuJazxMGDgfOHrJ+qia6Ikc7YvdzKyNfswp3V7O/7+YXLxJGOp4G9s4ycnIOjvqKJjqu2h4mA6tzjrYbMwbe1i+WAhfqFjtzww6yd/8i8sZXQlKT5oYSqzovrx7m7uIeC2/eirJP5y6aBlZG+irmd4JW8ica0zt7p946Sipjtlui0r8PL7bi1s8Syr/vwlp3UjJ62sKi61Oq5hrmlnqCil+T4sLbd0H7Em7bIwot//pSR6cjz39eAjsDdrKSp1Of5pdaS+cnRmoGlrYiggISYieaYhYK7orK/2ePcnNi6vfXLqKKA4MP+7tbHwrO5os6Dkof5036Iw76SdoLKsrXKtaSr4dmAg8W+z/XmpKK/09rL1vPHqaSSkqS2zc/5wLrGsenLu6yxicO50IC554D+7sHT+5rYwNuA7KiZ/r2+o/+NxK2639i6ws7i8qyxxLeemd7RnIequZCShYD1/YKC9oeZ+NWHkKu3xKS92ICr1I+KjMu+e9L7i5XKjfmdx8POxMV9ze/Xpt2D99TZvdLL1ryunZmuu6jJ1+KV77uWoZavc4mlhsGVz55+2IOSz9DDqpLb0ax1wpiAjH20d6mVvbl4iIeanKt8f4R7pnimjX+oxpaa02tzjJGucn2Gjqm9pb7KnrWI7NW0kNV+nMKJq450eqF+i81vmo+Az2/yhLPfksuA88Lrwdi//Iegi4SimLGlkoSUj/TP+py+5u/Mhtiai5Gk1MabncjOl6CppaGafMKTjHikzoWAX2s7U0WDYCsvND1penpOXIFwZ0FDQUdtPERUPS1EODJZQUIjOUdGOTFTSWZSP1NSRUUsJVdHSSpBJywvJiZFTj01Ky4tKSFOPTgpOz4+Rl6IMz8wRklTTXB/R31pNUpIV29iSFVOUUtWU1hUSExRTkhZUk5IP0VQUE9ZbHp3QUqAS2FCWz5acmRmYGZGYmt7a2GBQEBYTVdZSVI/JydZb0pRe1mXbIdfrYaKUGpbf1BNUXRxZmOTfZGpfY3sxbmHoJGYr5qOlZV1ysC+ubGqnKOzuLeyeV2YrOp7jOWy3KOWk5i5t5i7s9X134WRnJCYuryWg3qHfI5n05bahllcTYaAUIFvZm55h3ddVX6GgF5zlbVmY1lhYFF+f3qXtX69vWSlo5+jgtbEroWlrrqyelbSs1t4c08zRTZiRZ3fgPDsns7DqYFyZ1Bx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f4CViIyPcZ1zcoeQrZfi3o+R16KH2ILdupl6rLuBkreCn6ivhMZzzrGK1Il+2ICadraZhn6Rd6jt69a8m9T4qJOSorHMfoRyZ6OurYGapazCin99qMGgtIWwiomGxviVqf3O2NuKzJO0vdrVyduItqjy2MCI2a7YwIx5upx+oc617YCaoLmBpdi+nYN+x7mm5452cYXfrY+lgvWor8OPhr6BoI/FyMPTm+3szaWkirjAucGzvLeRm6mRf8K6mYF7g36qoI2llYL7tb3xj6bKzLOA6NeWi/KtlpbDwZ+vorfIlIeGg5mkw52jk32t48d/1HyW2amfon3RttbZjnfDiYDJ0YDlqXyTjM+OlIaR55uzvcycycqyknyhhZ5tcHbJfHyrtW9frrFwa2yrkF+nmWFieqq1hL2UgsSLmp6G86G5rnx01YKFtch4udXUcN5xa7VsqcHDt41go4qYdmpYvHWlaqClm+mNmrqB9pnNgb6Fd4abu5KGq7vHnb39goXOvZiYy4DL0N7xw7byl4Slw8LvjY+epIeF3LTUw4KVoZ+wmV9+wu6OrcaC0JzdguHxn8mI/5fjkL7BgK6N6J237MLV06d5qHKGbsXEosKLmrCHmNiCl32N6uPB9qj5oYKh+JeRhNGt5eDaksfimoyGrb28dt7DoNeWjbmRw5C16J2ZibKdkYCh2I9aeKG3haCYpn2Rd4++gcLDtNKnlPiBsaWc2MC8uejM03zGxdH5vMzTnH2eZXbIrsC7kYySiYqEoImWkqOVn5f1+YS3666R8rjIlouFwZKXooee16dssZDE6raOmrvoo4N9iIqBfId9fId+fY1/eoZmcWJddnR0kYyTnJmqoICPnpxdXZKCoo2KgYeUnadgYWllena2q26Dn2iMeZKOkon4zsHNx9HA0IeSmdSu14eNsrSUmL746szO49qRgqyE7IOHgoeaws+copuP/9nhyNHW1pzg1aLRe5SKq761uaOK5uuJiMujptGDgI+MkJGWjJK0s4ekk+ijoePDu6iDzoDS2bWMtImDzsqY47Ktw8jcz+P/v5mZp5PBh+qVm8W404jm0trh5sTlkunMkoaKzbu81dNy2G9VaFlXYpHeyqSKvZeyc4GGmlxbXq1iYnN5gZyXrZ7Pz6aWzOCcy8yOibCcgc6fna2CfF6z3aGtyOTV5YLGxrurtJS4vuLEsbT7u4CYsaqYnuLzkZyz2eLIkZvUk7O0v9HJo4mqyOngxp68iZORgt7mkJL6we3sgqiSz6uo1qTVl8vt4ITv2vTfz77z9uy47MWtseas/YP3gd6Tv4SCha6gu7b7uIOnq+3Fx9u5v7POw77D5MyE1cLRkbDKm5qHmJL9uoiTuqO9462zjYCplqCjhbWShqetxq758ZOm2rOa35L3vrKKw9GVo9SRsMHIiN6E7cKJ4ZaA5Iifgr2dlYWYiKv++OTLrfP1x8PBx8rskaOSgcXh2qW1vL3XnZCPuNKkrn6oe4ODuPSXoffW2+CN4arE0ezn3PeUwa3k1qiG2qHVyoqO5b6auOrM9oCgqtCPqefOp4mI2s2y/qmQgo3qvJS2ifakws2Zjrh3ppXX2djvrf/32qCki8jMwMS6y7ebpb2chcCxk32KhYGsm5Cejof7u8Lzl7Xo5c6F+uyVi/GzoKDT0Ke8qcDMoJaXkKe0zKeuo46579CM7oeq+7KovYna2/bxqoXfjn/P04DttIOZks6Wn4yT+a3M2Oq95uTLvZm9pbqVjpHlkKPT3JeB6+6Uj4/2s4Hu4I6RpMnOnNSgfrWJnp6H+J+xuI+D65OZ4uiE0v35g/+EgNKQ6v/94seO98TilJiB76vjmc2hbP6bn9OE6Y/KhMCCeY+ivpF3laGrkqbWaWunmXt6o4Cnt7HUoq3fdmiZn57Ejpuot4+G4r7XtniFipHFtnOQnb18jKNfo4WydbXJjNuY/pXjlruTZ5+A0Yiq06i5zJp9tHeMfuPIqseTuNKuuvR9qIaQ1cirzpv3pX6bzpegmfe43ubXsdb+tpuFxN7XkP/YptaTkLWXu36q2ZCGgJyRm4BTaF44XIdmMjszUEZqVmWKUmViTltPTIlJTEZFRDMuPWdGQCg2NklVRmOUbE1MLy07PkQ/MzY/OzUwLygvMDw5QTdhUihAOzEmOCxEPjIqXksxOCZFalRHd1RMb2NZW1pZYU9LTEtQUVlST1RLTlNNSk43PC8sPUVFXF1eYV1oYoBRSzQnNGVfbFtZU1pjaXNDQkhGVlF3aUhTZz1QSFlUWUaygnN2eLR+nl1TVJaHoUZCZWlER3a9w5eTrcmHe7J+5YSLfoGLqKeIko+K88rfvNTP0YqFhpPVgZiKr765xrGV+/WOhruep9GEdISDiYqSkp7EuXx3f6Wc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yNOeqenoqImBka3bwuh13e+dh6aij4eMe9Ogg5uRjbd1paiufsJtl9LCn+aWk3J0gnmDko+NtYC52LKGkKulhpKveKO3qX+VlZfMjcHq3ZusmcLBoNWHkZmRsbakm4+ujnWCipy8g+CE14KA27WNvraNlMBrpId/jKJ8dXq2z6OSqXB2aZ6+3JeXnrSvuNyEkLXL48y5lZOCnYTX0JCpnLWci43R8suzvYepm4f1i4R5e9m8jo68koDrusSNrKzIr8rL4LS+loSBeoirmqStk7mNu9PTzJPHkPx0u6OZ4pOHfpl/4J6oj4Xg0qWRjerl7571jJLwitvjz76ilYTQ7u6ukoymxfG7trnLhp+S8qqbq6+xgJa+5LZ/p57EopqktoSNjoit3c3TeIaRuYCGccLIzMaG+bShuIDFnoWf7LyAocuQiIS9quOtvL2mgoGmprdta2+8kaJ7cXNh0XZ4ZWyuZJads2ViXrOOnrTdnur8hbjcvfnhe67FfI2AxoybfpZ0p4Z3la7Dvm+wrdOVfVldwJF0gsG4e3Rq6+aL64l9er+xuIO83NOBxsSJid+B/eyGgZTDkZGk8YDU2O2/gfzg/KLVs7uHfnqlanCDkdfBfIDGs7OUj6R6qo/Cn6uG/siIoJu0gIiEu3/b5JXkvqix+Y6GuNPeiH+gkYByfqqxpKmGuqejr9jQj6CNp8W+vbePvq+xq7LHl6vaupq1kIyJecrckNWJnZ/NhaLeupGPnZeln6qO8ZKHh4CBvmZia6l/54mZhJF3dO3LqYV3aazfx9jenKSBio6s+rvg2+HGsq+G8qezmKC2tti3ppx/ebOT3rzNjc7U34TUqJzPmpF8saqxt9Ckn5DvvbLIv5yCpnqDhYmFxrmnwqfqroSNiYuDhnqBcnaCiGZybmSvlW+0c3V7g5ShqWW7q4CtinGJqK2lmYiVs7SzYGV7i32RsZiWhaN2dYGJqLKXz6m1opCMtof+h4WEiLa+9dPdj5eEgom724e1utems6yUhfaOj5GeoKGfi5izlZN9++DFr4vBzYe14ZqXqLWpopLx3Oru27u6tYurqJaKi6eso5SemI68tr7+m4vQlqyK3oDnv8uW5PfWubaVvIG4nNHO6szu+M+os6mcwrn2u9Xr1KX64cqnxtjVzMnY242wj9SSlYuLh6TFnHhQk4yOrqWFgXhmk1tcqpZrXp+W2r/IorODhZyB6sHzr8WLoLjP6sqn4OGumG6feO6yiomCw+O0kJn9zMKKi6aK6HzPw5nmwYDQv6mSjevPvL3n/YPYgJ7iq92v3vbHjZTYhqqSusTZuqi3nLDP+un75M6AiZGS4YWslrHPvu2Iq498po19dHmY7Lehjp+Ec5HBzcOMo9bopoR/nL3rw96E5PyqlMO9tK25pvjSy+PYuOWV0NLfm+2ErPzWt/6bqouOm5Gfqqixz4Da+secq83GoabQhqvJrougoafiisr2+6u4qM/HqeGYpqymzdS6q6XFmYKNk6DHj/mV7o2I9M+i0smfpdyBz7isu7+Xkpfi9cS71ImNgLfU9KqjqLivr9h/jri51s3DkIyKrYTb2JO2p8agkpTT/8q4yIKmloPdh4aJj/rYn53BmoD6u9Sdtqa+weXe9MfEppeXk6K+rqq6mbWMu9nWyaDPmP+B0bOv/aSMgpmC6qqxlIPp4ayYn+fq8ZrriIb2it3m0cablIXS8O+yl4+z2/Wvr7bNi56R6bSis7rAiZ/G6sSMsqzSrqqywo+ZlZG88evyh46Y2YyVgufi5MqQ7qaltIDGp5Cn9ryFpNCYkJDdxfnM6ODDrKrJv9GJh47ewMKfmaCF/ZWdjYz4heDp/ZKSkfatus/3rOv/f7rcwvvyltXkjJyS46GxjaWAuamNt9f+4Inf3/jMsYKJ76yIj9fWmpKFru17wIeUiZ+yx4PA4uKI2L91hNZ/9eFvcHiceXaDuoCltcaxcPG7yY66nqN5ho2+eH+QnufGgH/Jqa2mrb6EkX2ghIdm56R3moyNaIqJxIzn34TDnpGY0XdvoqzkkpK5npWEjsrLv7uX3L2tv/bGhZ+Tn6mqr7SIuaakp6LTpZ/SxKXEqKSKjez1p9mYtKvUjZ67s4mLjIiRh5yB+ZZzn4BCeEtCS3pHbDw+SXVaSoZ7Yko5KVBgbHyHS0I5NiczWUE5OEY8OjQsVmBmQ1ZQPz4yOC4sL0pYa09SLzc3TChJQkJfNUkmTjUxPy80Qi1HQ0JFRDM7aEladWA6UF5/lU1PWU1UUVFNUUlSS0xUVTdEODE8My9HKzU9TmFubkOBdIBvVDdUeYN9bmJmgYOCRUhTXFJfdmVjWGdQTlNWbYx7kTpUT0hMa2GMSVlMVoGTkE9cTFA2NktvpVB6dL2Qp6yVf+uO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iZGfl6S2eHuzjdyQtavLw4iiiKqL+r/Hut6dqrmqyKWqqOOU5dqrirmXl9345IPDrOXXqsHg3sisqMbIu4yx2J/9ubGrr6u1sIXDnrzeh4fklJ6igbHCm6SGeHNygomOhMaor5qtb7uVba14ibXPfZTFdHx4p7TcgOiLfX97xXOQtr56gam0nJOkppGL75Cxi4SpouPosX+JtsB+fMGLfqass+KMzoKDlpqA0XiMsbt/s86jqrmSj396ppeAztF6nYXKyIGGdXpwgH6H0rOKj36NlaeC53algtqJj+W+noHsfd7TorjTxcCl8dDjh5jk87rZjZSXn/zJgLigqq+zy4TE6XzS4pSgqbawdKuaqrmtxobB0p72qraG09/UdeOuwOzo2ceolMur6ZTAwbvbvYXo7YO9pYWDltLFvNKIrYOXxvjf0Oazt4HGipDY8drwxqHEtsmMp87YsMOTg5qdfbSkk8p54Juaz9mS3ox+oHG/tHqy75yj7t/cgMyheYPGzq/N6JSOmba6iaXRooJ8dqbh0Y6WemOOh22/vW6LdmiwZl9ko6KiWGBydW2KhZrAsLnAoruLwY+imrF4e6eAkofSvHnevY3WxHmtfsGcsLWBfJKQbXSDvp56s37hmubmlqWyz/WRrdeW1fPFp5W3uMHIv4DauL2Wj9TQgOGltb61xt3nl5mOlpKjY2mHanu+75TehNPCx6lleavD8NLp8PfoyNut8JCV3MC2lMqMy5nDuvSyxoX70paNncm/1aGxv8l6spvGybuGfniWe4PBoJTqkM3btYierpSTn7CfyvSjhXPOdIalhXjDpLXUgZechJWEm7zv26a7nufAgHpfoKKHubm9+XvKyqC8ka9/sYRopYvy89GHgZWAhKiLk5ynn6ajj6Gv9YOF0NCRkpXKs6eFl4/msYna1MvosrOygsS/5duPj8xqspSps/XRtNvVxb7C6o6clNrywd3m78/ylnqJdZ2BiHlpb29oqbCkYKifgZOVZWNzkJyVY4KOgIqAmbGqr6qPlHqlrai2aIaik5Csm32RiJmSfohcZsyewYqZ4+2ggJGSgvmC/4m+4fuN64yKjuHDk6KpvbaYq8LegI+IhZCC3YKDf423/uvSzsCm2tbZ+pu5r+OWvZ6rkX2Aj4+KlJSXoKu0r5+ajaGP+PX98dnnsYvA9oKE9beggIzXzYPIt8Oss7zHvufDibHr8OjL892xf52VnoSPgcGO8enUvsHL2tN/03HMpt2v277PevnLxNKaZ3t8UIWfn4mpp3hmdXSQe4h8i8bAuIqkgNGY4c7ghYG8u43BwaG72oDDnL1zjKd5iYuv7vfhxo2FnozdxNaApaektNaF2MPJgJSrs7apoaO3o7bVyeXpmo3FlvGSn6C5rHSRhJuD8LOyv+Gvvs242b+ttvWb7/Guia2ZjNjn2Xiol8G3laa9va+cmL28oH2VsYf4sqeRlJKZpXi9obzVfordlpujldXftsGqnJWerK/FvPPL2MzjjOqrga+ClLbjip3oiZKRytn8gP+YiZOV5oSu1uWGirG5r52ko5qT+5/Gm5ezqfL5wI2bzM+WltickbvJyPiY5JCRoqiI4YCWztuNyeeyrcypvqam2q+X+vmSwqr47paYgoiCjYyP4cCPjoKPlqiL+oClhuGKhu+6qZP9jufJo7/hysKw1NDmhZbc+df1kp6iof3JgMG6ysTJ1X7O9IDa6524tMu/j7yst8e0xYjFz6L2qsSS3ObdgOu5zvPm4dG5n9aw9pbHx83hvYPr3Hu3nIKEktrJudmWr4CZyfzY1PmtsovRh47Z7en0z6rLwNmYtNXduMybkamti8SxneuJ76Wo7PSe25WPsIDf0YjB/Zmi8ePZgNSohYi9xqzK5Z2WqMHWosX0yqekm83/5qWnm4SoqJb59oKcjYz1kIWI7u35iI6mqpOzq7TWtsLAm7mDsp3AstOJjNecrKPvzoD23LD92ozSl/m/3+ClkrnBhpyg1Lia2Jqzg8r2m7uaq+ORr82T3v/Or5PAvbzRs2vFqKB6dKKrgMaNlZuat7PCfXd3eoq1cnqefo3S75DFc8HHxq5xhrG366m8sL2xk72h4YeT1KWwms2IrH+rpMiMnGzPvZGftfvX/MjN7/OUxqfS8MyOgYuUgYO5jXq/dcK3nXyMqZumpcO13fq3h4Llg5PFnY3escXSfm55aG+BkZy9zaK6r/CigE1DdG5YZlxtdEN6r3t+S25NWjw5VEmPloVLNzc4OUU/My8xPD4tKzVAjVlKZ141MzdMNjc/PUxVUScuNzI4Okw+GjJGNDkwKDQtMCtORFRHQWJjYGhvkmJYXYVrRJvAnUpZSUxSSWVJUktCRUc+WElMMEtMQjM3MS9AU2JPQVFLgEhIYnZ3f31pZ012d3F6RVVoXVpwaFNjXWhiUVg4RZNUaTZAdn9TTVZTTX9ZhVlvgIhDZEJHQpKVXmFxpbWZss3SdYR9fIB91Hd2cXaM6MW+wK+NlpSTy4KkodyYxJuvmYmPo6OYnp2fo62ysKCZip+N9vLz28TQlXS9/IaG6YtzgGiKhm+heH5vhZ6mncnBlIl7foRsfXuEV2ttcWNpY5xyq6ejmaiuurBhomKnfrGNoYugXLejiLF0Rk9OM3ShjXGGflpMU1RqV2FabJqMi1SEbraCv5J8VEFueFd2emBZUT5hU6NdWnhhcW9wcZZ1Zj9BUkuEhI5GUVtYYYxNiXF3gFJhdH9qYWJnX2RnXXF4VFR+badohpaffVtvYXZs0JqNc11KSUVWbE9TSmFOVWl+g5yZfczT0XGTiKOcg5GjopyPiZycjG6CkXCzdoN9goCCgmKjpp24cEOZYX5rQlFeY2dRSzs+VVRHUoVxjFtlPFFYNlYsUZpyS1NzNTU0Uj1WgG15bzw6hkUwTlQkJh4XQRgmNCUmTUpaPFI8N2s+LyoxQkYrPjk7RWZsSDcfNy8uLiAhTCEdWF47QFE/SmVsycXJ2mVXo5pQgHSGgU9CRUpJUEVGhT81Oh4lKx4hRiQnJEIoI0lNPiBiJkdVSUlYZGleilF0TFdjUUF3RUZCSFpOgFQ/PTtITSJCQCA4Q0dYQUNCLE9CNjkyPyA0VE6nciw4MUQ8PINUW2lKUD04Lms/RSxJUUtdgEdkaj9OIR8kM0dFQS8uQyYjOpRbVoFHOh1GMiw6Oz9MUFFZQEk+U1t2dUg7Njw0OUdCTHdDSUpadG83TkBAQzZnakRejVplgGRpgEtPPUJdYVBeYztHRFFzZHOMcmBjVXiHjWloaFVwZVekomVuZmSiZmBen5OcUlFeXlhtaGR9kpWUbYVgh26ZZ29DRXJEQzltbkVyYFWhlVmIWKiRyNuPd7umZm17uJxjem1oU5GaVF9bYpFhnr6Gb3lybkRXX2tziFyni4BkYoeJgK93fomIrpOmbWZoaJDlmZ/Mp7X72X6ZVo+uibKJm8Gh4ZKgjZiPdnlRcEJGw45kO19bXFN1aolwaUiBs1g9OWfEjExLSEEsTkVTQkIuJCc5KDhWW05/R4iDeFZqaUhLTTcwRUw4KCBLKjIyKi1CRE5fNkA0KTo/TV9sXzc1M2tggn2HfAd9fHx9fXx8hH0FfHx7e3uGfIh9A3x8e4R8hX2GfIZ9A3x8fod9A359fYV8hnuFfAZ9fHx8fX2MfgR9fX1+hX2GfgF/kH6Pfwh+fHx7fHx7e4V8CXt8e3x7e3t8e418AXuGfQF8hX2GfIR7hHyWfYp8gn2EfAN7e3yJewN8fXyHewF8iHuIegt7ent7e3p6ent6e4R6BXt8e3x9hnwBfYR+E39/fn59fHx8e3t6e3t8fH18e3uHfAx7e3t8e3t8fHx7e3uGfIN7hXwCe3yRewV8fHt8fIV9hX6DfY98B319fX59fX2MfoJ9hX4DfH19hH4CfH6EfQF+hX0BfJF7DHx7fHx9fXx8fH18e4d8CX19fHx8fXx8fIp9l3wCfXyFfQN8fX2JfIR7BXx8e3t8hHuIfAR7fHx8hX0NfH19fXx9fXx8fH18fYh8CXt8fH19fHx8e4x8BH18fH2EfAF9iXwFfXx8fHuHfAF7iHwEe3x8fYV8BX18fH18hH2GfA19fXx7fHx7fX19fH19l3wBe4R8gnuGfAR7e3x8hHuPfJJ7gnqEewd6e3t7enp6jHsZfHt8fHt6e3t8fHt8fHx7e3x7e3t6ent6e4V6A3t6eop7gnqEewJ6e4d8AX2FfAF9hnwJfXx9fHx8e319hH4CfXuJfAx9fHt7e3x8fH18fX2Efgp9fXx9fXt8fX18iX0IfHt9fX18e3yEfQF+jn0CfH2GfIV9Bnx8fX19fIV9hHwFfX5+fn2FfAV9fX18fAICBACA6IS/rJLG+MW5xIOHiLmyjKOS8+7OnI6SleaAn+KZvp7UpuGr1tiFpYeYgoOUl8HApOWGuvnXpc2a4OHTq5jdfrb9hPbzltWs2eTp7NejrbGCzILP4d+AppPlmpnztZqB+/q3tbKw0q2jsLD49dXa6en4g+WFnczhyMOlkpnHk4OAkrXShpL8zMG6tMPpgoyttMSgxbepgbG2uZHewajzjrmchJKRmqy1qomXuMnKx5nbzHzj2trugbTh7KqrwqaSyO2Bwaeop4zf5YiC4PrpvLWpmbnny8PN1O+RzLifrouNgpKbjpCUhH+IgoKNhejO19+4qL/FqayIf6zLx9CQanCAs5ujemKwiXffnaHUjq+zbnFvy4aThZHh27yTifffkJp6pNG3pp+Yo9zCxO7s3JCc37KBybmG2qOFlcCWstKevZzcycfbgKnul6Gsv7qrpqiW6pvss8vNxp64/7mDoq3QmOuRyeODu5DNn5itxtaPiL2wybLEl7r4h4aP0aWB17yAqaSigJehn4+Vb66zePm4m4rjms2Am6atrreksMiXko/T6KeeuILJ1JeX2MGOxbezenWf9Xyvg+Tboq7h6/qIkIn7vN7v58+BsKLdjpb5jY7Z/66Bt9mQld6FpMmEsnbXipOJi7pwcI6HosB3k296fKPMubx/z8CDl4VxZXKt3NiApMbGf4CeyGeZxOKge4HUiKrPkYDYo3uEnqySy6m1x8WIkZrGfdOnn7fjkM+QgJV8kLvDep543t6qsKfYf6CPgafCbXnLu6aEf6anpM7fdM2KgM+Dw4rG3cb9iqWL65OtkoCB1p+Pr4Dug/2+zsHGuqPpsLuIgnnHht26h57O08KA4YOajKyClpaE97C3jNLAhYR6q4y1qn+kjMqk7uuOhqG1tMHit3XHf9/pxY7Q5J+ontnX3pPalq+dqbCEpZ/m3eK9roTay9rczIaOxIDZuKbiqae7nsnPoqao0aKOn7iWqJeSfoJ1pJaJhL2kkpB5lueFs6Cq67mzpNbGfMaQ07aAwpCQt8Gcjsv4nOWQiYOljax4vpd1kZzOg6Fgb1puenpou76mXLKdV15pVZd/WGttcXB1h6uw45LMwPvW1r+eooGNdY+woJeCvJPSsp1pqMnCe6XWzqjbo5GZjcDWvZW4z5nGhXLRprfRiO2LtfOf3tGN6vaDjOGw3LDbnYu3/bSAhayEmMq9rfLh1OWeko2+m5uAvdy3+8Kd+6eXloa+59XHitqp4tiaobOPmYKumbaWoqOigMmop6yzt7O105qFcnaIpaXJa7GrbNBoz5aKt5vtp9SNqIGujZa8ht61ktihubKav8OIxYmHnbeMvbbdlaqWm5vGlcXR/ZPzj5uPfMaAwW+mlnqa3bu4unV1b6SRc4VsxLSuhmCHj/WDmM51oXycl8OSq7CVx6aMhYapu+fCmcuNv9zZnrGD3NnVnZ3slLDohuG/c9esysTL3rygxMmO3Yq+yslxiG29eqPswJRs0PSemaidj3hye37Bv6Wkv93BYZ1hbYmfj4huanCUcV6AZ4SXY2u8mpOLhI2pYGeAhpN1kod9X4SGiXCfjHyzd7Och5mPlLK7rYqjs8zg3qju6ov67N7sgaHC3aumyZ+NzOh8sqGim43j43lzy+DcsrWso63jx8rY6PKc2cWos5mil6Kuop+fi4KPh4ePiO/W4+jArMPPtrqcksHm3u+wh4yA287JkXjhqoXQipK2fqvVioWH/pGWgYfetq2QkvrEmaCLpfDCr6KXqc+usNXUuXiNx5dakJFmr5t9iHpObpBofmSWnqi0ZIfFeZiam5ycoKOKyIXNo9HA2a28/59si6PJkO17m7hymHGjl4SUxNmqpNa33c3NmqLtlY6Y7MGn5deAurOtiampq7DGi77Ggv++oX29f7VvgoqPj5mNl6mEf33I9rmwypnY5ZyTzMeR27vFhHuh7IuxedjVkpq/x9NxeHXWpL3Hwq9nlZC9c3jMcXG065p2tLh1d7Nzl8J3toX6rLu4vvmjo7u42umTwoiQjc/oz9WNzsuYm5eChonP9+iAueLemJ6+5oS63f6zhJHtj6Lem4rss5KYqbWT17C519acrrrnke63rdDxmOmThpmFmcvUgLaI/ffAwrvqjK+wp9XvhJH76tarqtPV1Oj4gu2djdeK05bL7sP4jaSN7Jm3o4GC2ambuYj2jPbD3NHCy7zusb2Kjozel/DAlq7k2dCA8Juvl7uFkY987rHAm/Hdl5CIsKDRtoSyk8ym9fKRkqixyc7xv4Hjh+rv1Zro7aeup+Ta5JfYj6yPoqR8mprm3t2/r4nazdnUy4aOv4flwq3tsbO+q9DZrbGw3qydqsKktaOikJGDsqOVk8qxoZ2DofGGuaSy883OwfDgiNWT18SAzJmZsbqfjb34nd2Zh5C7scGF4MCYsbTdnruHnoSaopSF2O7xh+/igISJgOnKjJicqKCer8W54YnJw/HP5d69zLi9rs7bxbih057syrqN7/ruisb+983ryb+/ntfr3K7D547kmIPevZfWqu6Urfeb7uyT7vV/ft6nw6LflHySw42AbIxld6+whL++t8KLk5fQsLWXwbub0aiI8Kqlq5PE67+qdq6CrbV+fJ2EmX2njLWoqqOOarGVipOYnZO60ryfjo2dzcz5guHKgPmB+7KhwaDWotGJiXCViYqmd8ezlvGmysiqvNiX3J6fttqo283jfpiJmo+zgLK+0Gb1kY2hgcaAk1R8XlZhdmhxc01YWWBQQ0Mtc21dRzRjZ5pOUF46WDJALTguNzQpPDdJUk1IR1lUPUInQINmSVM1OzIyNitcOz0zHjc/Ljo0LFA8PWFFRk1DXDdqfl9TVzlhSD9RWWJBV1VGR0dOVEdHTk1mZ1dCUlhBKFU/NUpTYFU7MTRQNiSAMz9eQkiBbWleVl9oP0ZSVV1IW1RTPldXX0tRT0JtU1pmSUBCXkpsaVdGYHltilKCcEBxaG1zT2N1oHyGv5qR2t1rkIaLgoDSy2dfp7GqhW2KdJSej4KMhraE08Gtq5yspKy5q6Kjh3uHfn2EetXEzNKumrO9m51zcKjY3f+xbG6Ao5KWhIKub26qanWLXI6mYVhXiVliVFuVhHdfZcCVjoVjcKarl4p8hKySja+znF5mo2w2WmVDfGVdZ1IvTnBMYEpqjJ+lUWehYHh/hJGTjpuar3ayeo2eh22OxIFcdISLTnJcd4lgeE5xa2BueoVbTmZ8i3J4Xm+aTk9OjmtWjYCAdGpmVmVqb1hoZaKfcOSHiHObZZxgbXR5dXp0e4xyamans05CVEZcbE5PZlE7ZZbVkYCi2p+1ccrPiY2osLZgaWjAkKaxrZpXe3eeYGWzX1+VxY5yuaFjX4Vie3NVZixWVE5XU19DS0FOZ3pAVkRCSEpXNVw1nX81UzwVL0BSRWeAaYuCNT9sYTE9TUZNKRQwGhhPJiJKUEpETDlGNzlZUlAzRyh+NmQwQGc2IjEcLiMrJDpSNT40fXVFSERJMWq7vMfUWFaRj4dxcH2Ben2CQ4FLRoJIeGM8TkNRJiMmQCUjHy0sRjsyPiBaMVtOY1BWQkh9b2FDRSpEOnRcRVFTVz+AQEY/KzE0KC8nRUxcJWFPO0AzNjNWPUM3NGk9YqBDSU9FN0B1bkxwOkhLPDNgc0RSLkZVakJxNzg9J044MyswOjo5NDIxOj0zYiotVClCOVBcNTM1NkZMSEVnTUdGS1JzQE42OTYyUUFBTklERkc9QkgoRUZIim9qZYZ7P2JPW0OAUkxCWmFBQ11sR2c/QU11amxHd2RSZGSNaXBXXlVZZFRIn6ayX7enVHJvVJWEWWJjZlheZHR9pF+Dhbahr5d0bW1vYWpuaFpdblBtZmVTnaCYW5HG2q7azJfAk9vY3aOdekJgOzZqY2KJeJp7o6NMd1Baamk+QGuHspbuj2p0m2yAWXRRYpawZJygl6aGp7b/0uHA1qWIr5B587jE0KnV+66YaY9pjZpgXmU7OzFwZD0qLjtLUXhfSHZ9cFjUgj0wND9SSDlLJDg6KE0lUDE2PTleO0dFUElWTGF5X5FkQWFNQzEtLjIpQSQqMywvOkNkR0c1ODJRRUZWbTNdKzM2MWoGfHx7fH19hHwEfX19fIR9hHwJfXx8e3x8fH18iH2JfAh9fX18e3t8fIZ9CHx8fH1+fX1+hn2FfAl7fHt7e3x8fXyFfQN+fX2Jfod9AX6GfYp+gn+Hfo5/BX5+fn19i3yHewF8hHuKfAF7hn0EfHx9fYh8hnuDfJF9k3wIe3t7fH17e3yHewR8fHx7hHyFewF6hXuHeg17e3t6enp7ent9fHx8hXsGfHx8fX19hHwGfX59fnx8hnsGent7fHx+hHsNfn9+fXx8e3x8e3x8fIZ7gnyIe4N8jnsLfHx8fXx8fX5+fn2MfgF9i3wGfXx7e3x8hH0Dfn19hX6Df4Z+GH9+fn5/f35/f358fn59fn9/fn59fH58fIx7EHx7fHx8e3t8fHx7fHx9fH2LfAF7hHwEfX19fIV9hnwDfXx9hnwDe3x7hHwCfXyFfQd8fH18fHt7hHwCfXyEe4J8insIfHt8fHt8e3uEfAR9fX18hX2EfAN9fH2HfAl7fHx9fX18fHuJfIZ9BHx8fH2HfAF7hHwFe3x8fH2FfAR7fHx7hXwIe3t8fH18fHyGfQR8fX19i3wEfX18faR8BH18fHyGewJ8e498Bn18e3t7fI97Bnp6ent6eoR7gnqKewF8hHuCeot7AXyEewR6enp7iHqHew58e3x8e3t7enp6e3x8fYV8gn2EfAF7hHyFfQN8e36FfQN8fHuEfIV9B3x8e3t8fHyEfQV+fn1+foR9gnyFfQF+h30Ce3yIfQx+fX1+fX59fX18fHyFfYV8BHt8fXyHfQF8hX2DfIV9hXwCfXyEfQF8AgIEAICBvse28pjdy5GbiMySra2P9PnwiN/F1rSX5Zbm8b7I0tmoxqmwunh00ICBhKWkdemY1sx0jKjDu6rEw6yluMPLrKrX0/WM98G1kJaQtM3Hd6Z56+e2xofKy5fbmdeGk7L70puXq6mwpKKojY374NOEp/DH0KWfotbEhPCK3fr224CUrLD/qIHq0qGb0tqVjoOAjPfj2Lq2x6m4rP6xkviJ27yUgKKnlJqOiny6l6KIbr+9q8jL3dbnrrS/zbjEo5y2u8qQjq6ikvrE9+vL6LeC+YTr/u/au6ix+Xiv1peioqWcf4V45XyT8s7Ww+bnwNLOz8zAttjawsyedWSLuKWUmICtsaF+lISCj7zA0byXrcqZeo+HeeWRjMObi37IusfS9r+c95OG08e/tJmO3snIgKXiv8LWwrDCj8XXvrXD64WbxL+Vg5mIyKafrZXVq6qavNz9ne3WhL3P4cegpIyTs5fg056WvMevpKecoN7Vv8Obpaar6ePKqbyviqann56UrICgocy+pY20nqOZi7WOtrHO8YOCu6mxysjX3bbL5enthJXxuOa4hqXo7dGq5NPd58C6nrO434aXv9ju1/Tp4vH9+Pmsj6DehebgwdKRiaCYlKO5jru1gbjGwaL6hM/g15WAjoh6gHeUiJfEkbSl0ZyxxIXa3JKivpeeiJBxkouSj4B1hqt0lrB3cYy81nPhd8G0mbF944q/dniZjYGc6Z91ppp4rpKF1LOgm4+xkKqZj5Geo6TksIfTq8eHhZeJ6dqRkarHcMKrf3d+i7CObrnB3OCHc7mQ18eFtYnAqaC8jIC14ajg3IPClPSbmai8z7exopzfquzot+F6peCmw9DMroCxweiTfI7alsC/9PHPnJGloZOtnIeHi6CNpMqngr+tiaqKl4vby/DG3eyFo71/pJ+Tp7amiqD0k/v9i5iBqNm0tZCgjeC71Ya0z5TwybuPgrCT6KnyfYybh9Sti6bXea2mnqN7fdvX5YqjeYKIo4rFh+K2o87tpqiYpsuBjae1mICQmbmJ06S4+eLh15nRwnPLrnnBkXelg593YWdxYWlqcHC1npamk6BbmK1bkJlfWFxpcnB1vpLXqKbpg32zjI2RdG1xbmxoht2YfJnXhMG9yIeArK2aloCCmZV4c5empaTJ7MGx2qHXlofJ25DVk9vBqpPXh9yB5r6h/eJ7qbvBw4Cty/y6goOYxZH36sj+2YvIsL65gae3gHqrtol4VXyn2pjb/Irlk5+v9fCt58ikw6GRh9en7LyRi6PLt3Oho8a1j3Z6v66yqKuOxbeAeniKz/CQqq6Eh5PzpcPLlKDFgtzesbClkJF/dnvH0L/GdoSBl5aOpoqiv7HzkdmCnO7RioB9p7amwIDIs4iXbq10n56BxLC4daqUwsOd5pff0YSym7eLrZWYrYeG8n6Lm8aZhPeUrtqHkaOuo5ixvKiatsjXvKjBwth319Cnd4GLqcTPhL+E6+yqsm6YqIKwj+KNho7G15KgtKd+dHB5e4vpuaKGp/CWh35qeZqOWZ9epa+kloBmene0e16rmntxlqJsZ19cZ6+hm4mDknqJgb6Pdtx5yrqchaComJ6PjYO/m7WegtDTsuTz8uDmk5m3way9nZCnusGIjqmdkfzH7uLBx6yE94D0+uvWybzH/4S656Sxs7SxiZCB8YGa/NPaxuTlwtjW1NTIvuHlzte4koS24sPHzYDg18eSq6aty+jY6MaWqvCSgaumgvKMhbiCj4HSt6fI5syR/5iI3MaynYqAw6GoX2mKZGR3Y158XqGfo4mPn1JYb2xYZFtOh4WBfWKMenx4m7DdiceraZbPz7uRj3p+p4fDuYhvl4p0boJ7h97k2t2yw7207/TcqrXGr7PRu9Cwx4DFv9bhyqrXtMK8nsWNo56xyGlomoyTp6ayuJqswcXIbXbYsO7KnLj+88qe4ef99tPVub653H+LqsDPu9HIws3U0NGYfo2/bL+9pbN1boB6doCafaCfapCXk3zDes7g2oSKt8a+tqG2uMDpweDJ7rXR5Zn7+6SqwK2yoayDrqyzq4CHncuCss2MiqLh8oL4hNrLmMOG/IXFiYikmYSg9rCBuLOVy6ab8cq1saDHqcammJ6dsbbzwZvovuOXmaiR+emhpcbtie7Xr56owui7gtfU/v6Uhumv/c6FpYCvmYq1kI/K4aLw4obUkeiglrLJ7My3r6rerfDzzOOItOm509PVsYC2yNyKg5HakcbK9P3pr6K8tqS9sJ2LkqGGn8eshb60lLaVspjw3urY6O2MrtSIqaOPtMyri5rxk/rvhI19pdmuupWnm+XA1oKowZHqv8mRiLKS6KLygI2elOC8nrbthbi0qLSGifn0/5ivhYyRrprRjObBq9z9sru0weOPmazBpYCXo794vJ218eHd2qPbzIXeyIHguJrJp8KeiYqaio2OiIXf0t7t4POG6POGz+OLhY6cmpya0Y+6lqvwipDHq67Yubuxm6OYqva2jbfrgbri549/u+DMxa6Fu6qAfbe/toJ4m824+LPffqLYxYXfm+PPvp7jhsV87cCi/eaAsq+emYCPnsaIZnBsmoPp0sb33JbYwsyZZpOWcnynuI2OZYau24arwGu3comP3Naf0MucyZyHgtCLyqV3aICvnXuquO/SrJCV8dfcwdWr6+WilpKX1u6Pl41niI7smqWlka3kkvf9p76zlJWPgZTJ0uHlgIl7nZ+XonN9qqfUftyBke/chYBKdF9XgFpzYlZiT3pYZlNQcmdMQGNXaGliwGhre1JnV3Y1MSwrMSozcURYQUI3Kmc7PkMmN0plTEtHPS5GREhETCw6Ly0lNjUvJyEmVlFXNUc9bX1XYkdXYlVhO0opPERMTDE2PkBFRT9JNjhfSS0mNFI9PkNDNE1SLkgwRUZNSYA9OzxqTTxyZ0YvWWpDQTw4QG1kYFhWYElFM0Y6RIxEZVxHNTxXOz1ORThiYEpHNl1hUV1wfHJ7Ylx8kX+vjIiksqt6hJOJhufI4MyyqnxRikiNppqZdWRtuVud3Ke2vLi3iop653mU7sHNt9bRr7u6vsS4r93gy9Kec2KHxceYmoCz2LuEpIuImOHg0L6Fi5VeXFpOT5NbWYBeY1yakoOerZ5xsoFwuaGWhm5qkHeOQ0BSNDRFPDZQRIh+kXBxeDk3R089UEY0Z3FvXkRjXGBce5bBfrOFT3mhqqqJfm5simuVg3FSe2VXTlNOUqOhbXJhWW90epSKbX1xV29xbW9lfYB+gqesinGif3CMmMJ/ioidp1VSfXZ+j4+an4eVpquoV1e7mIFTP0thZ1RcV2WC5eX53c+83HuGoLG9qLiyrre7treMdYGpXaupjphjX21nY2yDbZGTXHh6d2WcT3KQg2tlYFVaV0FXTlZuSnxygmNxnEc2gGZ2mjNVLEYtRj9FR4A7PU83Q1hJNjhLPTBqHilLI0ApODReOkdAMD5IkGctNy9Ablg4aTY2UUtFP0goMzM1TzpXPER7Q3ZGSD8mV2hlanCSUYuKcmptcYVzPnx/iH9KRn5rdTocIiI1MyJFIiIuQCVJOjtEJUw4K01BRzheTj5RT0RQQlg7QlNKUFNMP4BMVFo6LC9VLERIW1FMUFh6QjosMis8OEJDPVlbQVJRSD5CNjl3Y0xFQFgvN2BGTVAsQjxCNzhgO1JYMyUjKU1LPyMzMUUwPiApISA2QEM7MjxMpWVsP1NYQltQND9sQm9DTE9BPmp9cEVeQUFQWT1XKlY/QV14bWxqcGo7QVFGP4BNRkhMc1lndm5qY0x+ZEOOd0dvWlFzW3VgU1NaUFdcWVGlvrSjm6tYqr5aiI5QVFVaUFdek2KIZ3OjZFVmWmt7amhjV1pZXKlhSl95SHeTlV5di6Ghr5hqrb6CgLLK4nJIU2eJyKWyVHOXkmvYaVlfV2JdMYU1d3mb7+GCwLKJgIB0g61wWWFTemzAr8X/9q326uKHVIGDbY+ux5u3gJ7C4oOVpFicX1xfcJJZTEtcPz5LLlpigmJfV2majphkOk5QODQsTDk8Mzg4Si8sLDAySlUxPEg4Vk6NaX10WUVCKUpGMiwtKismJipDRlFCJC8tLyonNTRNZlZdMkgrN0lRQwZ8e3x8fH2EfAN+fX2MfAh7fHx8fXx9fIZ9Anx7hHwHfX18fX18fYV8hH2EfIR9DX59fX1+fn58fHx9fXyEe4V8B319fn5+fX2KfgV9fX1+foh9A359foR9hH6Cf4Z+hX+JfgV9fX18fYt8hHsBfIh7AX2KfIV9iHwCe3yIe4N8iH0DfH19lHwGe3t8e3t7iXyFe4V8A3t8fIR7HXp6e3p6ent6enp5enp6e3x7e3t8fX1+fn19fXx8hnuHfAZ9fHt7fX6EfRV7enp7e3x9f3t6e3x+fn59fX18fHylewN8fX2FfoJ/jH4Ef399fYp8CHt6e3t7fH19kX4Bf4R+hn8Efn1+foV/B359fHx8fnyNewh8e3t8fHt7e418AX2HfAp9fX18fH18fXx9hXwFfXx8fX2GfAF7h3yEfYV8AXuFfAF9hXwCe3yIewF8hHsGfHx7e3t8hn0GfH19fHx9hHwEfXx9fZh8BX19fXx9hXwBfZZ8gnuEfBB9fHt8fH19fHx9fX18fXx8hH0CfH2HfIR9iHwEfXx9fYZ8AXuHfIN7iHwBfYR8hnuIfAF9i3wDe3t8j3uGegZ7enp7enqIe4N8j3sLent8e3t8e3p6e3uFehZ7enp8fHt7e3x9fHt7ent6e3p6ent7hnwUfXx9fHx8e3t8e3t8fX19fH19fX6EfQN8e3uEfAV9fn19fYR8AXuEfAh9fX1+fX5+fot9EH59fX5+fn19fHx9fHx9fn6MfYJ8hH0DfHx7hHwDfX1+jH2CfIp9CXx8fXx9fXx8fAICBACAhc7oocbGsJ7s5rPFz+XAtPmrnY66t5HU3IKekPSn8++r8t2Gqc+PxNd6lo+5j5mE5KLDj9F6q6HTgdHWn7Da14ONobu6ks3C1dPl+qekpLrPwpbzvumEwMKAkYJ+k7W04rGEjZOSp66eoISYmPyMlJLb0Mq+v7HgttfW+svIyOSAnv+Yy43fvr7lk7rc/sXCwrTI4NOmr7aS8quRwJGQrbinqu/b25Dv4fvM7qyjucq6v4OLl5Gq5/qLhMCclYiTxOHP85uLxaPkjpPyjJaMloH73Me2pbqmi6/Fk5KJ6X2D6d7gvbfL1Le5wM7A5bfCwtXVc3uAhYBww414sXl7sW+Ac32Rb9RsonKKo5LFtr/chHpxhdDQi5DmkrXI1cy80bn58Z2Qotf+ksGHlJKd34LuuM7QpePpho2cvKnOwbO0raWHic+GpL2jmbuT18a40pnC6qOEnubiheyg7qOA3r/62ubG7vy2so2Im6R+y4+MhJDHs+nAyZKrwJGSm4CirtWA4cp7co2ToW6vo9Cri4eaio6VnZL+hIaKj5KfmJqGlI743Mm6rdJ/yLfg8oSYqYSNX66Ue+nPraHU683liPeZnYfozN7k5YfhyeGP86fWgP72hK6tio/bnMbS0vWKuquogNtsqmd4c5JnrXjJzdJ/obTalaKousSvhJdwcHitc56AebN3eoTChXikzdTMdsqJyOfi5bah6o2/uJ/N7uC0uZVkjbOWsq2Cx8KMotCVk7qdgMTb0ue/xI+pfY15j9CEcL2AxZl+k3V+Z36Nstq4v3Jz0rqWo26tjI+UtrWbqpKInZqQot+Rh+fOx5GZnruqd7PMu7KD56K2u9abxP6IgOKAxs6+p+OeweCBz9vcjneco36ukKvd5n+snbHojcTomY+Zzdnq7fmdnMmSsYvslZzynsbT/ImHpZb2gvL1oO6Az4TDpMzvwKy1uP/q+a7yt5W/ta3Wm4ChhtfIj6l8gHicj4WShZd408h8tYvps4qlxdWHmMG/kerc4YmAfLGOm/GA2XbDrJzBotTMsqKSh3vKm5GK45JmjI2PlZ+tpYdmdGfPmcKpmKCWnI6HamBoYVxsXl62r5ij1LeVqZeXupSAkGpcX11VpMCokKKYtrS8haGdq6CSza/D357l6a62wvTmocvvzbjR1MygpaKaoZXKtPPrf7zIh+2U8Y+doc31oeeArtmRiu31iLack7OLuW+Ata/rwuWwjox/wPiPapqtyPbvwrf2moWes56ygofNiKa845XwtaOA6IbL287HmquBdLSuyJ6Id4+AaJLYosuvocGZjL2YoKXK796TttWrd3uDcZOkqb7Nxa3MeXltdZJ/xnWdoLTZqoaAo5jlna6v1aaAisXVl7OqpZnm/LPHt7qmks+LgW2ZmKfr+X+gi96J3aFuva59ksiRw+yNppjTlZd926C9k+aBmKfaZqvAmrDd132Ck62ucdLHvbmm6Z24vdj62o34wsVxrM+EfX2AmcGkyqx5lJ+hpJqMinuHnOSDmpPZpZCHhHyDfYOUt5CPjqSAaLBliWWfhoWkaIait46KjYORoZ15en9lqHZgjHKFnaioq/HV3YfP09vM/rGly/jHvISSoJGp2+uAcbOalYORveG+45R0rJzKjYreio2Fkn/z4NTAqMWxosHVoJ6Q84OK9/Hux77R17q7xNLF377KyuPmfYiRlpGC5rCe7ZaU5I+AjZqpf/CI3qy6z7blyMnzho6LmNjhhoLIe5nT2dK8wqXz5I+CibTHbotgVE5biUR8X2uEdrGyXl5ncHeWjYyckYNwfs1VVWR6e5RkkY2LrYyww5BweKHEcNGS3IhpwqHdxax6o86StJqfqriN5qaqlqrgu/LU0YuszqGgx6bZxNCA7tSLirjN2pXiyPCxf4KOdHd8gXjYb29zeHuDfn5weHLHtaecmtOIzsHl64et1ZOhb8qhf+S7o5e9z7jKdNWAg3PIr7u/vm6+rb10ypGxZ8vFapKiiYG3fpeendJ0nKWZiviU85Onp8qQ4aPv3uyJudXxpbjExce6l6yFiY3KlMGAlfGOk578nI/C7vPlh+mZ4ff29smz/JzVyq/T+fbCzKqDrdWx1sKR1dmkt+SqrtSkhNDu5/LGzaO+jpmGo+KaitqS37yg1Jeji62r2fzf5YqK//i5yoy5io6JuqyJrIWEoJ6Rq9afmOfW36yxqsGxidnxxKt47bjLzPCqy/6Jf+aAy9W7n9aQxOt+2Ojvo4ynspC9n7vs9oSvpLXqmM/opZKl19317+6ZpsiKu5X5pqH5pNHU74OHp5TxfO3jmOV804nMp8zyyrSwqPLd5abswp+3nZu4i3aVgszSm7uLjYWsn5OfkKCC7uCMvZP7vpS00dyKn8PAjuPs7pWOibmVpP6A3YLGqaLEqNbUwK2gnZDywaiT8bKEqZ+tvcnb2rmTlYD7vPr73vre58vFjYSKiIOYiIP846KTt8CNrJqy4si55bGcnZKC3+3Iuse81rewgJqgqYyb6Nnc4bTp68TKprybdZO27OT27cLAyMi+ppjXsfb5hcHKh9+S64eao9n1jryAlMJ3abrGY5R8fppxsXWLrpjZoLqQd3x/t+WPe7aiob+7mo+7fmaCsJuke37Vh5+kxYjdoZhnuGmhvb/jtMuSgODi7rGklpCbiKf1wPXQr8SHiqSGk5K5w7Vfn9nCiI6Xhq68xLHR3L/bhYyDi6eO2oGikZ+rkXFmj3rXh6S8x6uARYRnU2F2XlSijnBth41lW31XVEZLVk1WfWFvMWtdnFgzRT4oN005XWNMVEVRNDMwUjk/LD4iNj5yNlVUST1BSCsjLzcmJC0rNzpBWUc4Mz9SVUh3YGZDX1A2UjkmLUFBUz0oLS00OTk0PS8uLEYjMy1VRUJBOEE9OzxEWUcuOzSALkExSz9kVlVoQUVjbFhVVFNeZ2ZOUFQ4NCgsOjM6Sjg7N0pMXD9aYVlFflxWYGZwa0U/Q1ZafXFDSnpfXHWJu+K32otaj4uZf3jGgH9dZGGdjnlya3NpTWt8f6SN5oWG8+nZta7I0a2xucm8y7bEvuLthpejp56J5o1soYCKtXuAgJaihO59rWmOwJ/LwLbTdnhGUYl6UFeSWnGYqL6znXS4r3ZkbJKfW2tHNjQ/XidJNz5gWZOMRkpPUl54cXqLfHJdZKo8M0BkbH5JZGVshmORroZiVXO1aaKD03xepoCxpItYcX9ZaVhYa2hnm2RfT1qLe6B5iF5xhFtsakhbeXGAp4VbUGRsf2WAcH1taWd9ZmprbmbCYmFmam1ybGxgYlqYkIl+ZlsxVFpdZDRFZYm/g+6ziOWtnpOwwKy3Zb1ub2SznKOnpFyonKViroOXVamnWnuOjXmfbH6Bf55cgG9rW4M3akBCSV9DbVSmgXdZc29yVUeRkptNMkBMLzxHLVqAKk45PDdqQTBMODIxHUs8XT47SzYyaThvW0BVSHlfODMtN0ZUYEZKZUBBTFI7RWYzJTxPQ01JSz1FQ0tKVV9OX7dkinpuiGlrXGZpgoqBfkBIi5F6gDw6HyghKSQoOiMmNiErHj8jJkNVQTxKQFtfI0NHQkUuVWlgYFpMUVUlI1SAV2RLO1s9RkohU05aRjVqcTk1Jy4whzQ6P0k4PlJAOkM8an6KhG8qRUIlRDZ4SiRCLTdHYT06QUZeMV1OSEUpUzQ1QEA4NFE/Ey9PQTh1TS2IjZCYbVx7XqeBXWU7OjxOWVVEQUI9hXg/dkGGgEBAQUpAT0s+Q4KTolU6MGU/PXuAfDVRWEtXUWdrWGJUU0FzaV5LfW5TXVt3eoWOfmZSX1WgfZumo6impayoW1ZUT0lUT0eTioJye39idHN0aGBgfGFWXlVNkJWGXl9eYWtrX25jaGJ0s6umtpnN6ODEnp93W2aOx83v6bWnm4yYp3RSXb5pMF9YN5RSyoCXrfP9iKeAgb5sWKW2T4VxbndXoIWfsIzTkKSBbHWFst2doOemiZ+fiHida1VaYElSPzNHMEBdcklvWU9VnlmJq8OnUkQ3KEZARjc0KCwsJTpLPkxCPUQ8T15KWVlwioQ4bIJPIyMcIzYxOj8/OzJJLSonLSopPyg0OVNmZEEzZT1UMS40T1MCfHuGfIJ7hnwBe4d8CXt8fH18fHt9foR9BHx8e3uEfA99fX18fHx9fX59fHt9fXyEfQZ+fn19fX6FfYJ8hH0LfHx7e3t8fH19fH2EfoJ9i34EfX5+fo99BX59fn5/k34DfX5+hX0GfHx7e3t8hHsBeo17B3x9fHx8fX2EfAJ9foV9hnyKewZ8fX18fX2SfIZ9B3x8fHt8fHuEfAN9fH2FfIR7hHwPe3t8fHt7e3p6e3x7e3p6hXuCfIR9CXx9fHx8e3t6eox7A3x8e4V8hH4TfX18ent8fX19e3p7e35/fXx8fIp7AXyWew18fHt7e3x7e3t8fn1+hX8Bfot/hH4DfXx9hHwKfXx7e3x9fHx9fYd+BX9+f39/hX4Rf35+fn9+fn5/fn5/fnx9fn6Efwl9fn59fXx7e3qKewh8e3t7fHx7e4t8BXt8fHx7hnwDfXx9l3wBfYh8gn2PfAJ7fI17gnyEe4J8hn0KfH19fH19fXx9fYh8AX2EfAt9fHx8e3t8fHx9fYR8Bn18fXx8fYV8AX2GfAF7i3yEew98fXx8fXx8e3x9fH18fHyEfQd8fXx8fXx9iHwKfX18fHx9fHt8fYd+AX2NfAZ7e3x8fHuKfAt7e3t8fHx7fHx7e418BHt7e3yOe4p6iHsHenp7fHx7fIx7g3qMe4Z6iHuKegx7fHx8e3x9fHx9fH2EfBB7e3x8fHt8fXx8fnx8fH1+hX0BfIV9hHwDe3t8h30Hfn59fX1+fol9B359fn18fHyOfY98BH18fH2EfoV9g3yGfQF8iH0IfH18fX19fHwCAgQAgIPk0+zF1ZzfrueTibuLq435iaqrx5l1jcybyc3WxNmL6M3lxbWVyK+LeZSx2IG5s7+Ltd6b7rT4q43hsfSAkKWAi4H8h/XTkoH69u/BddD5pZ3C/saWs4SOwJrXgISomIS50un72n2eoZuOio+KmZCOoX60nr7G26bKxrG43LHla4/0ibKF0qS2xauVs7uKiJfQ3oSNzfOqjuumw7WunZua5cX6n/Wa1viBuazR4sWQupeV1PrmuMTJua6mr6j4tof7kre4koXm8InaqrvCju+9wq2froaminqMptCZgKCnxrixyc3j6+/W53yMhIiAjo6TkIp6fXitzGuuoX5rhJKpktuagbiKb2todnOJb2rDdYPAcJCwh52YlZzog8LVlIT456iV3u3aoYeJt43C4Iuxm/mtjsuAo5yA3eTig6W2rJ6sspewu/OZxva7w8KProH0z+qNzKOr64fe842gmPHYk7DBi8XMsZW7032P0rKAd7GpfruR3sng7HqonrW11q7qhHx0iIJmeo5mgZHPp9OlqZ+hoKOnpauwtb/Bur3Bq46WoJSI0LPazrKQtHmsrHCffpzFe6KYl76pseaC7K/v3tPt/4eA8fjk3oSI5NrwhP/29Kb5ydr1tPGu3szH6H6U0F5cg5uakpm3r8uxrLuAf8S44MHbubygwqifcnKKfryQycLCgHiYr41/v3SFloK6rN2cjJq3jqtznqnZvJqZoXXEb5fFjcqsmqDDe9+KtXms2N2yfKyhnbPqhHiehI++c3ymi5Z6jINnfZCivqFru6SQtdfbqMbv7JnR363uyZDD1LPkh4HYm7exiXuOf+aAtHGQqfDiuZV863eh19bescOckpq4wMrgreSvr5mFknt0dn6IrbKomKznsbqyl7iSsMuP0NF0wKTsnZvQoZ2QpuSu0Ma2nYWXgfnX7KeipK+d44LI9svrlIiyn/GUp7rZoZvA0LzAjq7UwZx6ood6ial003iB1sKhqoJ91Z6voouAiKK6hJuTqr6PsLN/nJSkmneTh7OCr5G/0YerhMxyysqqysnTcnafqX+NqJuhhmhgpVymk6yhkpykeZhep6ZcXGdjoqTAft/pwZmNjneeaZNnVlpYn7LAnK+AdnCMzMGOla3jr/Pe643Ii++pqZe15pFn2LnDtpmmqn+Du4SwhN6AhKS7m5XnwvzYqOhsxZm/nNOj1bGj14Wp+6il6b2a/7vI5uezvanAtpfqiZZ7iV6wxtOb786toIKhxtmIspj9wNmmsLm5nv+yz66SiXaKnI2ruKfAjc+0na6guKm4rnV1gom2gbzopNf+tLS9zYK02IOimHKKqKtyz8nEeo+V2dIRmpmu9pO1l+7C7e+Hyq3Fpr+AheLG1rnAlcSy+p6TuXqRcd5vlp2rlIOhzp3Gxb+fp3DKuejAlHq8soaBqL7ed5aCo4Wq24Trufqvit676XOFm3l6b9J3vuSVddv14ceFy/q+r7y0iHODanrIlb2DiayljsW/9eTlhaSrlpSOhZKYgpKohoZ2ipSSfIWLb2yifKqAY6JkdWCYcXmFdGmBh2tqfZiiYGWKq3ZjpHKPipeFh5DOotSK6pnO2Xair9nozZ7NnJzR/+640tLLoqCrpN6nfOt8hoVzedjfecOhr72M78TGsaG6nLKWi5m76KeJqKrQwbnU1+z1++LvhZaSjpeXn5+npp+Pj4ze9oTt3a6Ema2A4Kz5oIvitJuUkJ6Wl4eC+pGg14Gawo2QhG9wvVx7im9zw6d3W5uqmYBqWWtlmMyGqpzWrozHdp+GesvKs2WHk4aLj5GBin+UXH6Zi56uiqt6wbe5W4GBe8d4y9x0cmigh2KdwobH0LegyeGMnNXGhMKwgLGQ47zS/4Wyqczc5L2A9pmHjanGja3lhpmav5W+io2HiYiJioiOkZWdnpiZl4Z0eoB3baeh2t6/ksqLxL95sIms1oixrabEnKHie9+dzsG6zNlxasvSwrpsbbmywWnOyMeM5MLC1pa9gqykoeuIhvGThK3Wy7275uP228fYiNrU8tjuzcypzr+5g4usoNmApevx+peWt8OolteDlpuLvK/xrZqvv5W/gaG88M6ppqyV/Iax4ZjawrW12oj1j76Cwe3mwIi7o7TF946HqpOn5YyTzMG/pMSxlLbCy+7ZifvLw+/99OnU5eWj0d+P5dCQx9Kq5IGD7azGz6OamYbsyYSur+zp2KeC8IWk1NLTtMmAm5qduLbE4K7cuMeplqaKh4mSmby9rJmx1a+7vJ63mbTfnNzmgMmb9qGd1q+tmJ3rvNvEspeEl3vv0/WfmZqunOF+w/fK8JeCqZPvkpyu3aKOpLOkqoObvbCYgbKXi5a6iPGGjevausWWiuypvrCYkKe7jJWJp7+cvsCNrJmup4CAnIWxjsWYv9GTw5j2hfL2zd3P24Obt8imseDRwq6Rge6C2cTn5s3d767Wi+/li4aSjebY74zb5siKhJ6f2IjcsZKgl+/98rjLkIiHlL20iZiv0I3Y0NV805Hzr5V6idmaeL/M+u3J09a6uO13soPfgqzHm5H2xezVrOxz1qO3irOAlc2ki61mhceQd6CCb8eVosfQkZyOoaaY1nucjqhsjJynf7qquYRnotLgfqKi6Z6tjZaSpJjfkKWie4eFqKemyNvFzaHo3sjEyO/Sv8SMjJaOunWo4ZK1yn+Mr8OQz/F4wLOBqK+3g97R0oKnqcXSp6C3/H6LdbyV0Mx6pneieKuAN3FWX2V+bGtgelJBZGhnT35McXCAVkk9RVlpb2ZdYDaGWlc5ODhFQj5ATGBnNkU9WjtBNyRFNGFLPFRDcBogKh4aIkYmRTYsHWJqYTMgOEI7PVtYUj1AMy5AP1QnKDM3KTlAT0lLKjMuMzAtKS8tKjE8LzMxOzxFMjg2MCsxNzaAKFIoOj5eSU5XTUVTVDAsKFxpPkBYdEoqPjNHUElMOyUyQWNRf0FYkEJgZXiFV0JkW1SCoY90aWdaZGuBecSfc95vd3Zsds3HZquXlbVtmHeEbGVxUl9cSE5jjohmip3JuK/Lz+fx+9rth5yVjZ2jsrfFwbuoqJnX9nece2FripmAnaL3l4e5eWJfU21qnF9TjlVkqYZ3nXR2clJRl0pcZlRmnn9aP3uGdGBOQUlPbKtzp6Gwlnq5Z3ZlVZ+uj1Z2eWh0eH1xeGtmPF9rbHWRhJBgp56VPVxrZZ9qvc5kWkx3XUaGlG2GknRoipVMd6mFToF9VYVnnZKmlElwbXpYjFmAgkxFRFVbSVhoTmF3pomre395fHt5d3V5fH6FhX98dGpiYmVcVH5vak9ZWmg+V8uKxZrF8Z3Kyr3Vk5XgdNSMsqelsLxfWq62qpxZWpqYoliyrq58z7GnwYKbY3yEfnBFYHtTO1FJWzNLZHxgaWWUY4J/tp7xiVZOfHV0KylGL2CAOVlefT9OS0Y9MDoiHiJATy4uExo4SCc9Li5XRoZmT0g9Zzo3QEtkO0NUSiU4IzYpTl1mbTlPRzdMWjQncVdYqlFkgXx8b4BrYXFyeImERIGAepSelIs/PD46SVInW0skS0khSSMnWD0+PkM/Q0xCTzxHR1FBRURBdDpHTlNdU16AUmFCSlZfU0dFPTgyKV9FRDEtKjgwcTo2WkVMOj0yOj8wO3SJOEojODBCTEhCPDdCT0hOUzlFPDddVm4sNzQ1O0osRzY0LzcpOTozHSA7QVZ5lqOXj3CTq6WVYVtIQUg7U3NRRHxuZV09Wn5SeU48OUxkV0BETllGTU1AZD1EOTaASENLQGpJVWdETFKCSG+AZ352bUVeXGpscYN8e2FXWJ9UgniRla2Hl4aTV5yiVVVYU46Or2+smIliW29kYDVuYlVaVZmonYCSUk9PWX95X5eao2yprMNT0oLToJJrYdC8k5GOwb2UmqOGhZ5kpHa+aWFybnNrVHGEdfWE+b7Ag6KAiM2pg55adbV1V3VlVqV8kbO/gIiAjaagzXSlu9uGeoWQcpmASV5NS0A/JzMnbWZqUmlyZDOIb3hWbItRRzo2RTw1PStNODxGNkU8RE02MDBDbFWEqll8k1RRdIVHS0YvNDQqLzc3MUpSVi0sLEVBODs/VlFWUINqrqFPTCQ+O2YBfYl8gn2EfAV7fHt7e4p8B318fHx9fX2HfAx9fX18fHx9fn19fHyEfYZ+C31+fXx9fn18fH1+hH0BfIR9BX5+fX19hX6FfY1+jX0Ffn1+fn+NfoJ/hH4EfX5+foR9CXx8e3t7fHt7fIl7gnqFe4V8A319fIV9A3x8fYV8jXuOfI59A3x8fYZ8BXt8fH19inwNe3x8fH18fHx7e3x8e4V8EXt7fHx7e3t8fHx7e3p6e3t8hXsGenp7enp6i3uJfBZ6e3x+fXt6ent7e3x8fHt7fHx8fXx8hHsGfHx8e3t7hHwFe3x8e3yHe4N8hXsGfHx9fn5+ln8Kfn18fHx7e3x7e4V8hX0Ffn59fn2GfoJ/hH4Gf39+fn5/hH4NfHt8fX5+f35+fnx8fY57DHx7e3t8e3t7fHt7e4Z8g3uHfIZ9CXx9fXx8fXx9fYd8BXt8fHx9hXwJfXx9fX18fHx7hXwJe3x9fHx8e3x8jHsBfId7hnwKfXx8fXx8fXx9fZJ8AXuSfIJ9iHwBe4Z8AX2FfA17e3x8fXx9fXx9fHx9hXyEfYN8hX0CfH2EfIR9Bnx9fX18fIp+AX2GfAN7fHyEewN8fHuHfAF7iHwBe4h8AXuGfAJ7fIZ7AXyLewJ6e4l6A3t6eoR7g3qEewZ8fHt7e3yFe4V6h3sPenp6e3p6ent6enp7e3t8hHuJegR7e3x7inwQe3x7e3t8fHx7e3x8fX17fYR/BX5+fXx8hH0IfHx8fXx7e3yIfQh+fX19fn19fId9AXyEfQF8iX2PfA17e3x8fH18fHx9fX1+h32DfIR9hXwNfX18fHx7fH19fn19fAICBACAd4GLkcToz4fAjpl8f63/1+Xvpt/FubiL74elg56Y0/f98IWL6Pnlq5C4uZORz4Cg+ILbg6Tb1YnG05KmopbTjcHD4KOkjZp4t5R2ory9rsuztcrzpZPIsZiX04GkmoyGr8PWxLvRhYF+iIvX8ezigN+J+5P09Ke8tK+5i5zUz+KA+Pbuo9Ht9Kek6f+b3870moKAhovqzobl2ZaJ4d+UqtuEopKzyJLu1Y/Ex4HYh7fXm5mt19y+uuPsfp7H3YDonoeOhZy+2v7k7fh38Luqi8rozLeyhph9opKMs9B+8ZxygIWMjpiijoKepJ2nm5yNi5yUlZOBb7Vvf6Ghknxbb7yAsdbA3b6Sdmewq7a8gW2cnbV2vLyizK2O+tWUo/uypoD+qLChurW71J2zzKqnic25m4mAiPe5l4C6utyv7fO0m5rMsoGYopbxntyXqoqj3ZC08NKFo4yn46a5zs278vSIuI6S4KmI5sWzpMvjgOC5id/2vomfkaKR4MV3lKG538GAotx4dXOGaoJhl6KptZuRg4DH8eK6yZvp2fz2nKibmZueqre9r5+Qu4GT0aaqzZeoZ32eaJ2/p318tJWjpph+j6J2xd+Au4zb64DNi7HF9JWil4z/9bDosNqIhoeli6POvoagcp2onZCIfsRzrpilZcN4v61+0sB8uNrFxcl9h7iAu7++rKO3pJNznZd9iJ2iqZPC3eTL3ICSmoKDyKi7lZWIpcN1mH/Nn6ijj47j2OPUx3mKudunuOLdnpnWx4eIb4CJpqx4fmZhbHF8kJ6Oh4GWiZaKlICS86Ozt7qA1qi/lMv6soahi8q6loZu4nqptZeIjaG1e5aUt4+Z1uXJ05KAhrefidHmutrs7LecoJWT15e4zICV+uzyoeOFj+/lwJ2f64mMhNWT5vPd36iFmre7hbOngIqkku39iPGLiNrVl4OHybndrYOWv5uZn5qphpjmmJmsneGToYO+tbzfeI2Oc9e2fHp1lKR8cbroeXSAzNjlhaj6rZuApYh6hox8en+AraCzuI1/6OiDn5GhrJeMst6428qoh7mxnHZ3gH5krWJaZHulnKWfjY2QloKZo1uOiZ6JvpPYi5ymyHOJoZKQY1FYaJVQkZ/ewdXBk7yX3+/GkJWPrMrKzaNwdbmO2Y2Tu5WFsKWrpJF7o6HEzIzs+X725aaT6OK8gL16cYWd/7SAr9aq/Zi6jubP28OsgImSzdzv4+nMwJz/hsd2rYOhhK/F4+nDjo/HlcKw/Zaf5vW6tKeuxK2hzbj+hX/QlJmOoLh9nJu8bWiu061tzJl+csuIkcCtw8uwzrfnouiEep2ncsnDp56XvMf4ytCLosl+6K3hhYXDsYiRicHemo2ksbaAgpGOl73WsXPJh42EgI/mx9Xdn/vN4MKO0Gl4YXGGlrzo1YKJwsrEk3i8uYSCsV9twnjLdXnUto3Cx3uWjorMcbu9y4aEhpyDtIGJoryjndPRtojPd3SgrpF/uXShopyXu7y1tMPPk4uJmpLizNnXeeqM9Hm5tXKDc3GEYWybnKKAuq+udJGqsndwpbNwqaXIdl9aXVuVjGGvoGZnpLFvgKF0dnyil3PBroS8zoblgcb8uKS04u/Hoeb8hJq9ymzDkYGCdYO2qsnD1fB76b6liMjz2sLDkKqMs5eXx+KB+qF8jZSanqiynJCvs6u6rbGjn7eqqaeSfdqPpNrPx7aFj+KAzf3q8c6/p4Dp6/Htm4jUzOqU1sum576S5LyFjLpwd2r+raGSp6aty5OitZech8usmmqFiPu6lIGuqNug2amYjIm8q2ZggXfWlshub2FzvpDKwrBpd2aisoaJh4OHm59bn2iM7rKQ8c6/nsXtie/LleT0uX+ckpaA58GFkqnF6NSAw/uMhZi9lK6I0sS6oYF9cW6szMCkrYrFuNTPgYqAgICEjJWYi35xmm+J26/A1am7dI20c7THuZCLtJmgoquMmax+y+B3p47U5Hu2eJWmzHqDeXDRyp/fqMRza2qGd5bIpJXOo9jY1cG0tvaNzaa8cs2C27yH1seCvvfh8v+Rm86A2Or418rOuKaBurKOkpqqrpnW8vPW8IaSoImP5bXJpKmiy/eRt43dusezoqXt7fLq4oGPv+Kvv/TopKLl1padgJSjz8OUoIeBmZmkqLextajPtrmtwaeY6KS2trV+0KnWncrtv4q5nsvVvqyD+4CxxKaTkqLLkKOavZeY3djHz5uAibeeiNHovNLo9sCtvKKn/KjO246W/9Lmo/iMmfD3yqil/5OXkNmR7fnc6LeTpbzJhMCwf4WhlO74h++GgtnZloWKxMHdpX+YsIyNkZeriJraiIiaj9WJlXy+vsXrhJqdg+7TiImDq7mJgNf5h4CN4O3zlZ7lr6WHt5mKmpyLiImAuqGyyJSG9vuRtKHF28Kw2PPM8uvHp9TO1qiirqSA+IaAhpPf0d7iz8zB1Lvb84XTx9qz76PYfY2RwoG32L7TpI+Or/6Dwa31xdjGe657rsOEaG54xObJ18iFgsWb1WV88JSl7NPX3LO96M7Kzofc9oLz1qCI3uO7isl9eZGi7qCAmcmi6oqdd66QlIl8X219ssDOs7enqJ3zd7Z2wJ2/coydu8+/momzn9q2+pOVusSbmomSn5qJopbfeoPUsLmnwsadxsXhgIDi7dOF97aQhd+OlLShsrOUi3nflddyh7q8gvLtzYyv18z+yeSbt+OM8qG9Y2lyk2lodIa8eWdyjLiAK0I2PGF0cUFXR0IxPGzOoqyiZ3yOcE4rWTxBOzlUUn6beikiQWBPMzBJWVVuZzg4aUlZICxKOCk5SDNAR0A3KzUsRT44OS4mPEYwKTIyLjY/REBQMDQ/QzU1UikxLCwuNjhGQkVEKionLS5LT09NKk8sVy5XTDA4LjYzKi4hJi+AMjtBLElwbkI5ZW9FaUE4Kjc4OzpkVSoxKyUlSkFBX1EdMj9ha0tsc1x6dVOARW6FXVdsbW1QTWZwUHSxtl6ogHRzaHOqoL+9y+uC6r2ffZG7kYl6VVZSaWZUcZNivZGBl52mq7fEqZrBycTXx9DGv97Jw72iidVveqSZeGhOa5aAdenCwauKY06ak5G0i15ncn1ptM2d+cyf0qFkco9TWFfHgHRwjIqOnnKPp356ZJeJjFV9e9q2h29/gqWJu4eCemiOilpOc2itertjVUpYsYbHqppXXlSjj3Fza2Jqc3ZBjlN4wpxq03p0gqKJbKBrZLq3lGh2ZndqgU9Va3mBn4KAXoJVSzhfR1M5cHeIiGxuZmCZr6WSlXqmm7OvbHNqampvdnt7bmNWeVJet6mMjsPaiafUg9XY166is52enb+kprOM0dlqiojI2nWeZ4CTs2dtZmC1qo7PkKxdU1FwVk9+iZN8RGtTVD9LWHo5fo3dhcVckHVYp309mJxxbmIzOnWAVzZfYGdtPTsdKj4zIyIpHB8yOkE/WRYtTDo4Z1xiRDE3Y1o/RzY4Q2JLQDNaO0VjYiMvUXE+PT5SXDVmYFlcWFRHkHRmbF1bZWFqbHJ4cnKAc351f2s5PkE9NzYdO0dJOUdHQDdJQk5JQUA4cUNIRGVRT1VBP1tkb3NXcVFSi2WAXl5JSE5LO09JXEtFTVc8UTVGST4bkGhZN2s+M0A3OT9AQD09NlIuOzEtQ0QxOT47N11KKTVFNGJlR2EhHz47HRoeQS80GSI/Yj4lIS1FR0qFe3uQa5aFj33Jys7GSURFTJtsUT89UGc6UmiXXDI2Y2VwWHmMT0c+SUo/SUY7NkSAQ0hXZ0NAfHxORkRiamxkenxwfYd4VHl/fWdnamdQoFVRVlmPhoqcj52QlpKnqlSIjZKFrXmbVl9iiFxqZVlmX09TYZZRi36kmZOOUnNVeIpOR151k6KZrpVfWbaz4kVgxGl6r6+em4KDupSby3zKvGi6v4FAcG9yVc2BgqO58ZaAjMuw64mccZJtcGxlTmR5paq+mZ6VlqPvbq2C9cr0a3iFmIBfLT9oQTspPDA3eqCCcF94c0tZdHSLZpiuQTQtNzooMypDMCtMW0wtTD89O2VFWIl2jIRjUEWEaoRSNzk2KEJNOzU2TkxmVVYuKzsnSkptP1BFWj9OW1+QQzU4R0IOfn19fXx8fH19fn5+fXyIewN8fXyEfQx8fHx7fH1+fXx8fX2FfAd+fXx8fH5+hX2Efgd9fn19fX5+hH0Bfoh9CX59fn59fX5+fYV+hn2FfoR9B359fn19fHyNfYh+BX9+fX1+hH8Yfn5+fX1+fn19fXx8fX18e3x9fHx8e3t8jXuEfAJ9fIV9hnwBfYR8jXsDfHt8l32SfIR7BXx8e3t7hnwCfXyEe4N8h3oCe3yHegp7fHx7ent7e3p7hHqJexF6e3t8fH19fHx7ent9fX18eod7hHwYe3x8fHt7fX17fHt7e3x8fH18fH1+fHx8h3sLfHx8e3t7fHt7fH6Ef4p+jH8Dfn59hXsFfH19fX6JfYV8CXt7fX18e3t9fYR+hH8Pfn59e3t8fX5/fn59fH59iXsNfHt7e3x7fHt7fHt7fIV7g3yEe4R8A318fIZ9hXwGfX19fHx7hnwEe3x8fYt8BH19fHuEfAF7iHyUe4Z8AX2PfAF7onwBe4R8Bn17fHx8e4x8AX2JfAN9fHyEfQ58fH18fX18fH19fXx8fIx9hH4HfX5+fn19fYV8Dnt7fHx8e3t8fHt7fHx8hnuOfAh7fHx7e3x8fJN7AXqEe4t6AXuFegV7e3x8fIp7Anp7hHoJfHt8e3x8e3t7h3oJe3t6enp9fHp7inoJfHx7e3x7e3x9hHwLe3x8e3t7fHx7e3uEfIV/BX59fX18hH0IfHx9fHx7e3uafQR8fXx8iH0GfHx8e3t7hXwDe3x8hHsGfH19e3x8hX0FfHx8fX2FfIR9EXx8fH5+fXx9fXx9fH1+fn19AgIEAIByi4Vzh9KVkq6WkYq6taqXuJm7vquGgoqssKDzrKGjtsuApamqh7yjjPW9oaHkvIaIg7+2gNnR9encto2EtuD3pLSvzomBuJWu0qLbq7CqtLSrg9d876WKg4ytlKWKjod59aazvq+B18X749LUxdnZ3YyMk7D8t7qfopqdxbi5o4De18+HtJWjtcvvhoSKlanZhsTCwLGKwMbV7PiHrvDNq+GUicT978vs59W74NG4dG/fdbzhkdDekam4rYPx0bTQw8SNpo+GjYyZjpKFxq+h38DCrX6ZkpqTuIqYt3x2pXKCjoekq6CTnKORkoOLhYCEgoGCesW4bWGMc5Z4WVZgcIB1s3pkgWhfXHKOa99/bHKoxZvBr+GWbYPGzfmr57ip7dasr5DajMHctqjQnLSwibOTneuayurXos7g4sucjpq37rTYdaR+/Z6Q2YiRzoHf1aSfvZvJnvftvrPr74e9huXFytSsq5/2r+2dvpjmpaP1qazFgImJsKKVln72z6h7y4B0sr5vc7enpYGZu4PQh5eIgt+FxKqHipKKq9/1oP7lrO6w/IuPpbKzo4nM6HN4psDOw9W2lF+et6J5m4jr2tGswcTfgqyOmIGlupKVppiVn7bW0vyKkremiPXj8Kq2gvGbn5WSxruraLnUosq3vtJxh8V9l/eFsPmLvalomYBtiYCehdS2k3fnodylgYN50Zp6fYTlf5zDiX934rx/i4R703CSmbR9cIuFe5qOi7zRmLGW5YiUh5ryiaywqca2lJCehqSBvapvdW5sb8ivvYmTiH2EioaBe5CAirrfkbnXicbRxP2LhaWIjK6Ad3Pku8TDxnp/nIjkmKKRkYWA2a+ziYB/qr24zMXWhsnns790e4bHiM6ofYT0tZJ/lcGpk5/n0pqVjoeCqoOCkfuYfoF/lMjvjJOXlpeAkIePiYeX7qSk8X+Cgdeak+/ypZfbjcm5/uvynrWH2e2Uwp/ki7q1h5Z3dLi23IHWnYiH1cG753qtlLDDwp3loop/eXJsxmx4t4CGi5/yf5p8maapsLCaoYLArKLUpa2OrbeuioJsdWxTr2CjamWzpVqkgY2De5yYW451eI63faC79Labvmx5gWlcU5SuhnqLibSot4e0n66W1OqivMyjxLP8qNeQwnyEn5edgZ6eeHW2oIygz5nRkJD8h4XIyn+qs46a4JJ6ocmIloD7kt7ojnm8w6m6z6ufkIXzvJ3nuqW2mYeWtXyOm5vf0IyMxquBh43ivKOxgquGn4qN/riMvb3PzZP0ptjQocKA+c90mKWlqJWOwaLPrJqXgerH5tbA272Lm7+0vbPfkpaMdpnzr9Ce3H6c5Y6x16Spme2n1rqmn4PNmtDugJ3a0YCDnpSGltZ+kL6XjJnHnZGMq5K42L+Gd3uWlZDYloCKlKd3qbqhYYV6dvCtf22vsV5pZJmaZ76l58G3rpORvNnOmZ6svXR9n3uDwKDDqaOlvdCwhfyN6nJ4iJukjKqNh5mA5KussLBv4tz3+cHS2urg1YiQbYiteoBma3F0h3Z/foCclphZeWJsg42pXlxmhJS6aH+Fi3pigIiYmJ1Tg7GXfbpyZq22mYKl1cjG68fBgID9g8/3l8rIjamzlGq5tKC7q7CAl4SGl5GEiZZ+zLKl687avI2enKaWt5OhvouBqnqPope8w7OlsragqZSgkoyPi4qLhNvgloy1o9mhiYCDjICZ96CEs5KLgJ2yg/qZhZa9+cfmwPCufI3VxLd80cas9Oq3oYPKhLDEppK2k62we65rjvSnzuXiqL7O48WSfoCb17/pfKZ9zYR/3ZWYjkyMk3Fnnoage76gcXe502R7atXJzZWlt535svijuqLjq6f6sqPFg42Rr6Odp4/70baL/YCJs8KCh9/X0qG3043Rgo18dNB7tZVziouFm8bJgtK9luSc03N2ho6MgW6k1XuFt8rUzN+7pW2wx6uAoozx4dawxMjhhLGWpIiop32Ai4J/h5uzsc1uc6eTeNW1u5GNeeKVt8vD9O7Lgtr0sPvh3+SAlOeLlvGMru+R0NGFsJiImICzn+7eqIr6tO69jI6J5K2BhJP+iqfDjISA+tuPopiY+4i/tuSbhaeelLaposzcocOq9pScjp/4lLm8tczFmKKxmraS286YkZibl/jJ0KKyw6yyt6GmmKOAi7rnnMPSisHPxvWZjsmbksqcjIr2vdbN1J+TpY75oaiZk4KAzrC5k4CFr7u4xcLTfM70vdeDhJn0muK7jZX/vZmJm827oa7r2Z+VlYiQsIeCmvyiiY2Nm8jxg5aWkJF9kYWLhISV7q6t+YB9f9KRjOvtnI/ajMW59d7ljqF+0+CLvaXkisXBiqGFhdXO+pLstJaa+Nvd/4W/mLHNz53ruJuVjYOA9oKK2ICOho30hJ2Fo6+2wtzExrDnqKnyx8+yzODgtrGamJCB94PgjIbY6IX4yMnHuvPni9SjqbvYj6m+6Lmb+K6svamLgffszrq9orq0y5WfhoZ2mItmhJmUxcX0z/SVzpKXso67b7/KiovVyLfT+422h43pgILHwoKss3+Z6pmAqM6FhoDfgtPhiXarjneDnpOHfH/TsIm4l4aqlnqDpoOgurfKpmxxzLqHgYfkqqGvdpd2hmtuzKN4n5qgnXfWpvD2xOWf/f+Uo8XKuqq378L1xqeph+HA1cW0zZ9gj7yqr6vnpK2dhrD+rd2w7oij+5PF9LqpiLdsnod9fV+iZbHPT2++1oAlNyosPltGQEQ+NzFPa3drh2aIdn1pNDFXVVFyZ05ZYGZAKyUyLjU1L1ZSR0R5YjA5MDg3K01MU1dlQjAsNVhJMkY8VEYjPjhEYzAwKzUuNVFBL1YxWDQrJzNDNDMsLDEsSjU/OTgmSj9GTUdLSVBFQyowK0dWOjYgMC82P0M8K4AvMDQZNjxLQktjNjM9MyMuIEtNQj0pNjE3RkArQEc6MkQ1NGR3U1V0gW9Ue5FfQEOURmFhTFlKNEt6elSWnpmvm6d6kX6QqZ+AkqV506+gp4qCf1hnaWNkiVdZc29ho4Wjv6/T3ci5ytS4xq+4o5aYk46PhtrWdmibb4pjRkZFS4BAiVVFc1JFS3CWY818ZV+Wqm9tjdm+j5TlqIBesrqT7LuGgmuhcZKdjoWhfYuFXY9OeeecrrzBm6GfurB2bGeDwLr9maiIpmltzaWlcDFkdlVGinaJYaqIV1ykvFBXWcrXwGaPnmC9dJtzhWuaYVC4hI6ZW2VnfGE/Pki+kWdThIBGcHtKO3F+dWSMx4nQf4VyZ8RwqYNajYJ+jq6iZquaht+K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ur6v0dOdq9F91tmOhbd4gL+BtrKNxNLXgZqBcb7Hur/Hg5aamMiLjamduYHu9uuph96Ap3bf04+zZHtpaGWroKuKd4B2dIF6j56R0YLe7+ahv8rl5+zfqraEjnl1dYyhv5d8a82K9oPIo8qtfp+8uIG/noDMwPzhma2JhO+ceXG9kXzSqJuvebW/oX13gsWfeorP0Iiwun+drve8ubmUh7N1grOqwuyElYrfmejV566Cy8LwxMa899Cx2cGTjZjQlvKi9qCgrJ2ihIKY9IOBrMGBjaiIhNXAtaGEjomSdXG6rcDV3/XuvnutfJKyy86gmKeutoDGgpq82teFgJ2lkG67u5Kk5KuuvpaOdKCZjmpoaHBdW2SsoZfDwWKYfYuOr6mcXlxuibOudIZ3gJGIaW5YYGJNVpOJhJWLmrive7a4t6DEtMaAl4azxd/+habMoGJoYYbzrK1gr65pvsxvzrXB8ZaUkezl6L6C3LzRzo12q2/fsoCTpoWc3sy+6rfQ4sjW5dGf0IXO3s7D0LiD13p/XKeriebTzo+I463i9sKttuSV9Y+uwMqEwMfjzaqTgOev1tOimYu7orCRkMeUdnn2huaB25jtqPH6gfC5xp+BkIOsgqadhvTlj6CWi9bziay3/rTO5vOeod7boq2WwLPX766LgIDry5qBoI6/18rUca2LzKTNvMPJgMSajmOluo13jY6X1H/I5KbYlL12ma1/kneJomKGY4eys7BkqJh9yuOmxtt8zXectZ6vgWygjc9lvL7QnZjRk6OR0KbY7peXkYznnqqcr5GKprOfp563y5WCosG4x5yv2oSHemZft5mKlYuAaYCBoZSYdGCldpmKi4NkwGhms3GfaIVqUFakmWJdXI1mgYRoVbF1doBddqOFpKjU8MfCveXokHPAf4Smsrhyn4zZ3n11yYLWfaXBspDifbWaicWqhZSL/pDOs5qZrMH2dpOcvqC2tp+bjvHl7/b9/obw44Ccs6rA0f/GqtKH5eDOjoCVwMyy35+WmMzm35Xj4p7ih7fTrruuhnSAWXnlw/+UgN/T1qeZ5qPCnrixnqeFk5qjubWy26mjs5uBuc+CnZZ7z4yFmtbE0X6geqmpprGkiHmjiNawc27Atoh0g9CXf9eo+IGiyZCBw6t7xrmlp4et66e9+pmajJy2k9jK9uKGgICN9KSZ49LB29admOTH3Mm835zIoYp21KGve4nEnXOfjcfIs4Nyo7d0hpWJj8qdsZaZqOGnq5uQc+XVzeizwby/2M++4cinnuyBgoKFmZSGkpugmp1ugIJ3f4C7g52BicyAgMLG2ILj/e/O4oCp57m8kvnmk/vPhO6C/t6UlPuA5YDGv57KrYXQw7qu1qGVwsut3+i0v++I3uOZks+Bj8yU5eWy8/n7mbmTheXw5tzKiqGrqdqZjKyhxHnz/fyykveNwIb+9a75gKmUiIHTzMiom7CooKiSssaq2o/o9fqgysvv4+j+vciPooeChZeoyriOhPCl/4XRq8q6hpu4xpPOsYDSzf3gpaqSh+2mg4DbnIv8xaLCidfTqouBjuexi4/W2429yoimsvTFw82dkbeCibe1yeeBjoDbmu3L4baF2M36x8vA776hx66NgonSnO2m7qmUnI+VfHqM6X5+ssaFh7KXmPLc1L2KmJagh4Pewtfo3PP3z4KylqLF8/zHu8nK2IDkh4+k19uMjLCwoIDa4L/I8qzV8LCsgNbKtZCVkJWAi4bu6d3/+4rbqtPR/f3uh4SKveXbi5OJlpylnqWKn5yAg9m9ssSpuLTAisqiqYaKgIlVX2mdoMDfdZvbt3F6b4PlkNGA3+mA6f6X9Na+65GAf9jW5cSG3LO7u417rXjarICPnIOc3Mq5soGbubS6yc+XuG+ns6q1uZd50YaUbcm8ctqnypyb6qDD6rCan715x3KKnZ9nkZqvo5J8ct7N7/zDuZzjv8Gvte24hoP0ivqP4ojgltvidLyWvKOCioq+fbqggd/Ai6qgkdjtkcLM8sm10tKEhcG+eodzipGbtnl1goA5QCoqPz1TOzlHLy4+f4KgVmh3Vo1zWjx4YkZGW0xhh0lHRzRNP105VmFGUD1TekFGMy01RFM3Z11ET0E3OGE1UyxIWldBODRMITgjSTo8NTc/ODs2SDI+PiwpKihJMzY1PzYrLjoyMTY5QzUuNkNFRTU+Szk5MSg0WTw9OTpHJIAtPj0rQDNaSFxUVVA3TxwpS0lFM0k9Jy47QjMlL0kzLzI9LmpJQUJDTVtBVV9qXkxTT1xVRTdSJj1nfJ9fiIPm44GEyIXokLXXvp/3iryHanRjUWpZq1SgeVRLY363hKqu0aq/upmTkPbm8fD99YTr5IisxreqmMW2ho9VhoR4SIBDTkxEdE9C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jpe1eWtv2ci8wL7GzsXyxMXw7JC81aLu89Z/heuxdculos6Nm6TZwZFljYmT2XKb1MVzjaiifI5qlYzY4qrM879wdLzYhob8gYuFrsbG5YGGgaH0pZl9zHptm3bOYn6tbIdwgmfAjJ56yr+nmqON0MWw+pysfM3Uu6eAqdvof3h1ds+UoqGXksLMmqDtls2tfKSIm32Rm524u526hJzNcnXMinuLt6aFpLjNm7GorHqJjZW24Nujjbqd1aTWt9Suf4OAa22AkXucmXlwZWts0oeSfsKFgHW50biQlaR8wHqRoryUxq27k5SrfYjHe4bJua7rzqx3t5B/xsGA3YSIpLG+64PW6ZR7gt+AgtHfem61zLF9jXyD0tyhoOl14rKog7WBoJ+dy5OEzJ+ot66p393v1cHAwtHLsJiH6dSdo7WRha25xaHOzPn0jZn/m67sus3M+q7OgZOujnt/cdDJ18m9fsKlgnOovHa90KSorKKa5MiYm3jHpIuP2cGAdnPc1vPf261ziHt1brx2iqrKkJKVfIVygsdpYnJsZW16u6uiZ6mPj3CFXGC5WVtgt4ikumukpldaXlZUaK9bqqKhtPt1fI6CcIS2cKXt38ioirTXnZPLiN+IenNebZSOmeiRuby7rJ22ZGKDy+mGg96U9ZiLwMV7g6i9i9Du0/eAudyjtNOmncnI78GNm5qo7Y20486XiY7t9YJ9ill2r5CRuYTdnbS+4aSjxsrz1KityY/Q/L/a09G6ofZ/rNW5jZKctnmNrWmua9GOiXnWoeeN16qHhK2vyeOyoPV2g8HV33bgk43W49Ts5fj0mbmA/ajoioOzzOn3k42VjZfU+/GA5OS8kIak1La/oIiirZCJptSjsoaQkbbhnLpny7zluWmq0+O6kqxZg4F4qqynfZyNfYqNWJltrMe6bH6DkKF9kL7PsnzgjI+ZwMileaWFkIf23r7rmuLq1tHDd43j3IyE+4qkkYSdzu2TjN/O4vyG4/mrzZ3Dh4vI1fzdeoOPkYOAilZ4fGxku4Wep7JfkFadU4OikV+Tj3JYXmNeZFmde3Rxc41xf2l6dpDcv8XW28Gfi5O24JxxhNGB+5/NkKito5x91sipn6TGgJvFidPBptas9IK65KW+vpSMoqnWm+ifpJiep7fEsbGto5CKeYeSlJmmpqeYeXyPmpfXkueHsI2AkJy+vKmgmNH8nZqYwoz0/YmwusNofp/JsZ+stLSN1PF/uvisgHy+dbawoZ2ifuF3qtqC1OS6kY+ns6fmzqGRkIWFW2u0jpK3tpVpfHnhutbRRIjZjXjWrrx9a23U372R1KmZlYHS6qLn54F9pcKHrrju6MPemtjJvpG5+ZPX9oqAhemWkY2MpaHqn5CZ/uTGv7S+y8juuMbcx3mgrYO/3dGBguSwe8qfh6dwe4O4uaZzn5eb4nmj4M95lre2h515rJPR1a3J6L98e8bOeHnldXt4k6amvGlsaX+/hIqB5YqBwIz2j6XZhrubt4Lko7GV7+TItbyc1NG396a4jd3kw7GAsufujISGg/icrbOao9fZnaX5qNnFg8GXroaXq6jZ68vmstD5iIXsn5Gj0L+Tsb/KsMCsuYKSj6TB7+mtjMKt8b7u0fLFna61jJK2uZa9sJ2JgIaK5Z6wmNaOjoLH48CQlJqAy4KPqsyn0bjBoqG4iZTijpLG0sf+4a6Ap5qGzdCA6ouIr8DI74PY/KCKlP6RmOz4jIXO27ONmoeY8Petq/2A/sy6gqqEpqGo05GH4qqlt7iz3tbz1r69x9PVpJuW9tqiqaqKeqWxu5680eXjlpvzj6rgusfG7q3NfpSjjoSMg/Lt7+bXhtGxjojM14LO3pqbtaye9dOkqIbjw6qu9N6AgoTf1PDk2biEk4yEgN+gp7/ctr/Ano6HpeOQh5SKgo+a8eTpjPnKxKG7j4r8hoWD/LXV9o3c6YqQkIyBivuG4NTQxvKFh5F/kZvjgajTpYt2X3afjYmwbb+JiYtzhLOvnOuf7/n67cTtgoCf0Nh8c7uO6o6NycWEgpy0jeDs0umAtNemt9SgmbSVt595hX6f0nmUt6aBeH3C44aJomqSyJeWrXLsm7C546qjsqS/pYqVp3GcvJWkqKKSgeSHwvzqt7695ZOvqobgg/WYkYXdnvqHupuAeo6Ys92vpPSIisTs/IC+eYDE3cDi1+Lroqt59K/5f4Glz+fag21baXep3f+AOlAzKi8+TTQxLDEoOjk+V0pAS0dMSmidd4Q5elpgTDc/OTg5NUEnPERIb2lUS2NqVk5HL1AxVIZ5QDUqJy8xMWNjNkZeQkBSQkI0OjApLCpTVVBcOU1INzM4IilJSSkxWjA5Mi05R080MVNQQkosT1E7SjhLLThDR05ULD1OQzqANCwzQDo0UVVqb3k/VSZFLkdWQDNTWjsuICs2NzBZQj8tPEo3SSRATF+RgIGViW9GLzpHSTY4TU0ygWWrj7vCtLKJ5d+qnJ7GiK3Ck+HMfIdbn050nFd3flREV2CTk/Wio5ibqcPezszIuZ2QgJKjpKu1sbKogoagrqO4ZpRXaUGAPUFDR0hHSFxlM0BJZkGwejxPZX1AU22gnIOHiI9ysN1rxP+EbmKcZ6SbhYOIZb9Ph8B4tcace3iFiYW6rn5zb2lkPUmCaXGGjWlKbmrEkdXzMnfIi2nf05RgW2LJ1bWIt4RmWWKgsnymp11bbY9fg4K5noR8T3aHWztggUt3bjqAO2VdQT05R0ZnSEZRqqSSpaOzxsPjo8nIn2WCh2OHtsOBe+C4hMqabH5SXmadu9GRxbe19oOr692CpMi/lreQz57Sz7TI3sOOgde+aWrJZWttfpGRn1VZWWebbmpicj85TFBeM0NfOFo9WS5qUK1teYtuhGRYn3R9rYx1OmSPg5mAhpmgRTgwOnIwQ0EzO0M1NyE8PEg/MS9SVDZaPFxXWFlVQm5yOTNySEdMYFoyQEo1OEJ6UyAjKH5qYaxsQXJmu6mgg5F7bHN1ZGRweGV5c25gYGBmtWxxZ2I7MzlpY1o/Q0IqVEFCXl1FUUZYPkNZQkt+QD16UTdndXc3XTE1XmiAez4dQUJaOzI6XDIrLWc3LV5oNTVjgHAxNDU8b4JgWXo8b2tkIyEoQkc8OjUxX0BNPUM9SVBYWVRSNDhIXFIjKSQrM3Y2Nkhqf0iWiL26WH3ohK7YxMvL7bTXfJ+YjnNSR5+kr4RxRGo9PVNofUBlmHN/uqeTxIJITThvaWFZe2iAODV0ZWxdYEw4STo/QHROW314aG9nVFBBY4tPS05HPkpamJSlWKaLh3ulZmGsUVNVnqHKwWiyslhYWVFKUZ9UmZWaoKptbXRfcI2nTmuDZlxRPkRZY2ylWbqVnbSVq8qZdbeK5d2wnoihWXqY1c5sSodjbG2CxIWQg5Cne63a3dyAv9W4yeqsm69+opBudnWjw22GoJh4cHKq3aGq14lWTE09blpsNj41RDg2Q3uChm15iGOEn4CNkI+Ddc5UWFRCMDk6Oic2NCU+L2I3OTdDNF5NdVRWXXFvX29kcJpsVVdgTipaPkJHUVyKdGNTRUQraTZaOTtWXXqMQzk0O0FSSUKWfQp8e3x8fXx9fX1+h30DfHx9hHwLfXx8fH1+fX18fHyFfQp+fXx8fX58fX1+iH2EfIZ9Bn5+fX1+fop9Dnx8fX1+fX1+fn58fX18iX0Gfn19fn59hH4If35+fX59fX2Kfod9BXx9fX18h3sMfHx7e3x8e3t8e3x8hn2GfIR9Bnx8fHt7eot7gnybfQV8fHt8fIZ9hHyFfQJ8e4R8A318e4Z6C3t6ent7enp7fHt7h3oEfHp6e4l6AXuFfIJ9h3wEe3t6eoV7hHwJe3x8fHt8fH18h3uCeod7inwHe3x7e3x8e4R8Bnt7e3x8fIl7g3yGfRJ7e3x7ent8fH1+fn9/f359fHyEewR8e3p6hnuCfIl9BXx9fn59h36Efwl+fnx7e3x8e3yEewh8e3t7fHt8eop7BHx7e3yHe4R8Cnt8fHx9fHx8fX2EfAh9fHt7fHt8fId7CHx8e3x8e3t7hnwFe3x9fX2EewR8fXx8lXsBeoR7Cnx8fHt7e3x8fH2OfBJ7fHx7fHx7e3t8fH19fHx7fH2KfAp7fHx7e3x8e3t7hHwMe3t8fHt8e3t7fX19hnwBe5V8hn0DfH18hX0Bfoh9B359fn59fHyFe4V8A3t7fIR7CHp6e3t7fHx8hnuNfIl7gnyJewR6enp7hXoGe3t6e3t7hHoDe3p6hnsCenuKehB7ent7e3x8fH18e3t7ent6iHuIegd7e3t8e3x9jHyKewN9fX6FfYJ8iH0FfHx8e3yGfQF8ln0BfIx9A3x8e4R8AX2MfIJ7hHwBfYp8D319fXx9fH19fXx8fH5+foV9AgIEAIClrJnHg7rJnKWJrY+Tdry2e+6jo5V4e9fHv4CBgdO3n7jQuYig8f3g7o3q2s+m4YuKnJW0s4vh6LydgLu0qp/V5LDSi77tkfG2naKd0/7ojpiQj8u4sK+b2Z2He3l+/dKXzoSG29/j2qzU1r17/nmR+oagf7Ky+tDyi8+Yj6GSgYDdjdDWxteDkqDN9ITlycWqnI+Qh6mgs6aRrq+ZpOW54Zqhp4Wjxr/ZkI/5j/eI/cLqtMeWtoXvud+Ege1/6rPbyIvqiK2tpY2B6d7MrqOZsJCgq7LFs6OztniSxpnN7Jh3iKGNkpaPkI+YiZeai4l/dnt/i5KKin9xYHJyfHShZ4CA5JTOnIV8oZ+co5WOhrmEhbzHg9GYi31wdWR1p7SbxIPVrLvQ04KRz7PM9r7A0c3/ipOlw7B7sP+ulvGs6IOxp8mMqK6zvbPX4/v8gb2KzLW3ms2mk4rgh7C029bGl/G+1ovPqobVoKTl44am2pS+mZCpmpqx2b+Rd8bQyn18goB/yn+vfn2wqsSVamioj3qzv62Do6Sxx9X8jZC2o5KHgaengOh8z7zDubTE/aOKi6x7kIFz5LK2vtGgg6Wdq2iB4p6B5vJmnYeIyoO3gKyB+IG5hL7boc+n67i3wKSeoI9+onNfdoKde3Sfdtvgd7iTsK+Of36ww76bfMZsn7J5loDj2Y6Gu9uElHu104Difp57e7Klg3rWvrmugIvn26fBqqR/z7qHnXHLfq21qbKW2IOniMK/nbug1HaoevSD5O2l28l4rpeMg4uMkYh3f56bgYhwqIiRmXGG0de45LTK0qrSj/a7nX+Xz4vmqaOezc61keOOxJCpy5OAo67c5IPR3ICcxYmmjJ2ifYmwjX6zlXyDyYuieNOPtISKco3cb5KCt6uziIblt/2MwtCY8p+LgqW/lnyfz6+evrS+yobq3nKRibj1r5OExrXEjuWBreXBloyYldji79vlrrXimK17bq16s8PMuMF4knl+dXbSrYC5aXlvwpWnxpF529uflp2ez4B3qrXiso25nn3elZvE05yMgX96g6mKp9aY0mjCfLl7uXmvpKKomYSajZZWpqtZrKu/oqu4vYWKm1JUU5qZasjrtMbnn214Z2Jkormn6Za2vZ3c247u6drGzI2EnVq9dHh/nZirkpeqt7pusqF67/ObzrrfkajFscbSkMx614O5kYCcqJbRmceBg/biwNywwZvnu4LHv6zx1f/FgZVnnrSP0cuVl8SimqW38XuInYSGs7itzsTfs627y46X6smLq3djbI14hbJ1er2ZmHO8gYKHlcGK3bKUlfj56vCPtMTPgHTBoIqqnoX7tN+MgKnzy6ynwsO1ld+heZy70c6jktC5g4CpxLHwg9jdo6WVt6qqh9jTiPW5rqWIiOavol1sh+PImKvJsYaM9P26qmqylJJ+kVVWYG2Eh2/D07CEY4yQko6+spOvepu0cNuzl4eZ+fnunLGps9ysuMqt3IqLi4WJ4umZl2Vru9T16r7m4MSB64SV/oGdh3d93sLihcdgbXdrWICnZJOSiZtbanKSrl+dgXhobmlpZH96inJueWxXX5qEm2Z0emeVmX+Tamnxf+GA5LHdpa+Es4D1p9SNivmF8rTiwoXleKCei3lv0sbNsaigu5SnrrjEs6mrn4Cd16Li/KV9mLumqa6qq6ixobGynZqQgYeKn6yjopmLfZqfo6nXg4Cc66PsuZ+hzsLEwqy0m++truLNieHk1LSUnYqRw7i51orgssHMzoORybfU9ri3tav6k5+8zbmPr/upisWP64eujrGJsa2wn5CnrqWqY4FooquEebKSfnezU46Xw8rUnfnB8JbYsn6ci4LI5pW065vGnpmzrLCpzcOYhej04peVnICW64jNh5vWw/+/kIeolpjwz6J7l5uhucjafJCgiYWRirWnceCC3LGfmJOgyoBveMeNoo577Lq+yNmxl8O0xXSL7LeN4eh3uJaZ3ZLBfad23nytda6+hKSEupeWs6i7vK6myIiGpbDOnJe7gvT8ktSrzsugkJW418+bhOqAwNeMr4Do2ZWU0/GRoYS43YbokLeMiMa9kILk08mzj5r4+9Hy2Mad/N6brYn4kMnRqsGc5pG2jM3Sr8il1IKohvuE7fej59SK0bm0tMa7zrWfm8a0n6CLu5ugqoSM2dO98bzO9rHgnPW8poWj65fot6+q2dS6l7Wc25/C5puJtLHf9ojr64Cuy5bCkqSsiJK0nIbFqJCf/5y4je+dtJWZhaX1gJ+SvbHDl5f4uPuDwNGY+6KQkrLKn4Wn0Laiv7m+0JL96YChjcHwp4F3s6ezg9N7ou7PppGdndDZ49PfsLfckKd+gMOM1OPmzd+JnYuOhIbowofCgp2K1ZavzJuE9fnGsay57YCHt8Dls5G+pY77pafm6bWqpaCepsuovO/B6IL8l+WN0I7f3N3rz73YwNqF/PaF/+3/1OPr+rq65IaLifHTiu7vvsLysZGalJeAp9DP8YOcmoGnmG662Lq4yY6Gq236kZWBjLrwys7Z3NeG37N/9d2Ks5vXhaTUw9fjjMGB4YG0kYCer5XRlMaGhNW2oLWKpJK+oGilnpvIstuwgZB1vL6R4N2ZntCwo7XJ/IKEjmxqk5GFoZivj4yZmXCA0uCpupODjqWaj9SQk+q5qYHRjZmRlrGFw5OAfL7N19eUvOLchoDRpYGXkoHmntGLdqflt5uLuNHAmN+rg5+92L6LiZ2mdoA6Qj1KNENPLyssRzIzJ0dEL0tBcUQpMF51dDs/QEpFPj08NisyW3NVVS5vW086TTA0NjZPTUF7lW5jNkM9PjNIaUNvOVtXO0xIQTwwQVNTPEBHRFE6OkIyOSsnJiQnTUk+RycnSEVLUj9dT0AlSCcvVysxLysmVEpIKEEgJDg1KIA+LENVNEMtOUFadD1dS0I3MzI1K0E/MzslMkIwLlNJTTEwJyVCPD1cQ0psU6VTXE1cPEUxNjduVGBKUPaG/rn4yHzqbpiWeW1fxMLcwbKXclxrYFdsbV11Zz5anJnm/KSErN7MztrQ1s/Yw9fVt66eiZGXu8q9vLaegnZ5emNxQYBFbUdcS0FEUERDRT1DP3VMRFNgYd2tk4NxgnB8lZOLt3OujJymqnGNupS35KCehXvko7e+u6dyisGNcIxy9468fZlqr7jBhXOKh292SmJcn61zaaONcnKfPXyKsb7Ied6VrXSzkFtqaGKirmN1unSUZWFvWlVVZXJVM3SEaz08PIBGY1BcOTxXVG5JPUd0YFuQnZFvgouOo7qxZI6DYW6YlsGgYtiM6aV7d298lmFZavyzxqiI98TP3O3Ls+jW7oWV/dmc2dWH1qOp86XFeKNrx3ClaaChZ39qj3h+hXNuaEs+UTk3RVVhRD5ZRZKAX1Vgko5mXVqNmlVsYYRKW3JCdYC4oWJUeIk/SDpnXkJ6QD0sGTpKKhpDZjBmNUaLj1RxXFdSknFDOEBiM29qmWA7NkAuJUdSR1E8tCmjZnc+cnBFa2lLeHJ4dIB9hXRlaH9+cW5hgGttb11laT9GcmpqnjRpG0M3PltifkRdS01YbVhHUX1OXT5HQ0ZFS0FJRiZqdIBlXTY6MTw2QjpdNSw0Pz0pUTU3LnVjYzgrN0WZP0tJc2JlXVpLLDgfTj1JazUwQz8/PjNARUhLP0gwQzRrfi4oLkePal9fg3GHZL5tfZ/OpY+sr8vX3tPdvL7djKWFmL1yfrm3d246XTpMQV+DWkV8U2dls39gjlI4cW9kX25qeoAzQ1RpVT9DSzx3SU1vd1xZWV1eX19ZYWtomFGTUoFJZVOFm6mZkIuZhZpRn6JQpJK5pL7OuaCpo1RRUZWMUaGsk5Cpi3Vzc3NjhKOZqktYVEleYD9zk4uRppKWzIX5jHlvY5TBpKOfrbqG5K+K/9B3gIBofJvf4/r8ia4+mnS3ooCrvqvcpM6UlLqljah2lI2qjlmVjYquobyghpaW9qNVa0ZNT146RjxGSy4yTFZVfHxzi4KWfXyChGVstpNQRy4jKCwsLkMnJDxDPChQOzE2YXNbdmNhU4iHeIJaeYVcMDFGNSo1MTJvYn4yK1ZfSDhATEtJOl8+NTtDT049N1EyJwR9fX18hn0QfHx8fX19fn19fH1+fn18fIt9Bnx7fHx9fIR9hH4HfX19fHt7fIR9BH59fHyEfQF+hX2IfIV9hX6EfYJ+hX0LfHx9fn1+fn1+fn6FfQF+hX0Dfn1+hH2FfgF/kX6HfYJ8hH0He3x7fHt7e4V8B3t7e3x8fH2GfIZ9hnyNe4N8m32FfAN9fXyMfYZ8AXuIegd7enp7enp6hHuGegZ7e3p8fHuEegd5ent8fHt8i3sPfHx8e3t6enp7e3x8fHt8iHsBeod7gnqGe4l8g3uEfA57fHt8fHt7e3x8fH19fIl7Bnx9fH1+fYR8BX18fHx9hX4If39+fHx7e3uFegF7hHwEfX18fIR9D3x8fHt8fH19fn19fX59fYZ+An18hXsBfId7AXyKeyd8fHt8fHt8e3t8e3p6fHx7e3x8fX18fXx8fH19fHx9fXx8fH18fHyIewl8fHx7fHt7enuEfAF9hXwMenx6fHx9fHx9fHx8lnsPfHx7e3t6fHt9fHx8e3t7iXwDe3x7iXwDfXx7kHwHe3x8fHt7e4R8BHt8fHyFewh8fXx9fHx8e4x8Bn18fHx7e4V8A31+fod9g3yLfQZ+fn59fHyFe4Z8A3t7fIR7Bnp7fHt8fId7iXwDe3x8j3sGent6e3t7iXoEe3p6e4p6Bnt7e3p6e4t6BHt6enqHfAR7enx7hHoCe3qEe4d6Bnt6e317e4Z8hHsFfHx9fHyHewh8fX19fH19foR9AX6JfQR8e3x9hXyEfQZ8fX19fn6MfYJ8iH0LfH19fHx8fXx9fX2EfAF9h3wGe3t8fX18hX0NfH18fX19fH19fXx8fIx9AX4CAgQAgJKffKGV0duyfu2TZoqLxct01oO+lqh2gpHRw6m136+WlJifkoGoooOuf7Ga96WfkveMsLW1sLyZ9KuVmYPH4p/flMuvu52miZXmk8/7i43awOCx2eyZqobcoJPc+vzP59LLztvD69bMd9nTe5DhyPnkhJLkzZy194ifvZ+OmIvtgNLDlrTE1/TdiJOz0unfpImo/4LG+4WAkJmR8ePlmfqF19vSrpXb5JHIjbKgxpWowom20saE8r2Jlb2tjpeN2arDwJ+SuLCS8NW5jffzldbmqdzi08Gvz56yp9OjvOeBe3+Ok3SHlaSXjH18gIV7eoKCcICam5yUgYN0hYqdoYCbgIGrfoW2faaqj4WDeG/xuZN2fI6CwKeFe4F8dbuQt5KKu5KUs4Hdx8N52cXpne+cxqGYwoWVysLf84iGy5asxI3/stKmfHev1eLLjt3s6JTd25Kqgt+gk+j1prPbvZ3igeSDn+SViZnL137cnaeZoNK8q7R1nPSckoK3fXuEqqqcgKiVlNSaldSGpItpg/ODrW9iooPm6oGbzZbSirPxkoLZl9nx0N3Yu5HkpLmrzYnxpJW4abKiyXm3lWFwbbSkjnOFuK3IZ5FqmIN/qGmNsnm5yazKtdS6l4L3xJKVvahsbW+V3muoen1loKXZ476sdaOb1bqgkn3Op6uFup+SmrO8gK6Um36av+Ge0obHwqK53r55s4msuNKrkJ7Xqbqfe7ZqlIWuqNOfjJ65lnyq4pOEvJiquIWf2aq1j8befO7az9DkxaPZhJ14eXlxgG53zKB6gHeRknybhYWk3Zzm16yGjrpygLXcz8K8iKCm9PfZncvK4Zi/v/WtmJj1l9S24XKugL/Eg7W31s6KmrqQq4uLcp9ruMWqq6fGrIiup5nViaDChISOfZ7xfJSujKyBv57b0b61zOnm2YWHzqachajisJ3w582QmdvjlpDF4MvQ2aOpsr2Bg8Ggp4bbgI7vp5thYpHLx76Ku7LDu5/Oi9e866uPtrx+yeneqraqpsGSnZamgLaYj36Rg5KssXJzuLKfo51qqoGgvoahn5qYYrG9dd2SzdZ0ooidtKR4rmxhnaujoV9+crifk21+naCZmI+ir5SdhoB1eYCCd3ylfsWD3oKqyYecyr/v6szaj8l4j5G2bKzRm4yPi4y3hWfA3oJzgoCKt9LiqLK1xNvysb3Uiv66gMS5maLDp7eOks2KtuvM6ZHtv7LR+NyN+Y/f8KaSaceO+MTU/6rZpKmSz8/Vg+2w3dvGpcvGocrFkICsz36jjtN+cG+LeH2dbHG6mJyXuI2Rv5LSu5a1nsebi8KS4Ozkx7y31K6qnqaIhNmViY2Bt5SJ7r+8gb51jMjMmqezwrfggKC4jbqj6/fEjPefgaOl6+mG+ozArseGkpenpKu+xZeXmZ6fl36urYGtgqF3om9oW61PZXKGmK2T1ZmalnS1y4mrZ5mAlXOMg5j1hd7afX/tuPHA7MmnuIjjiJTu+fjU6eTS3e3UzszlgOrUhZvj1N3udIC0tn6s82qOoV5ja2ipgJCUa3eQnayxW2d8kqWfc2F4rFyct2RpbWxsn6GoYq1gmKGTgG6kiU6FUn17n3mJo3eZvLp/+8p8jb24lKCV1KCppX90n4RyxrGkiu/xltHvr9rnyrOZwpe6o9aty/2Lh5KlroSXqLuvoI+MlZmNipSbhJSvrLWvm7yjsbvY1q7FgJnVh5qlk867uaaLh4vj17qZssGt0uvQrKuWhbiGo5yj0aahsXrQv8GA39Luo+d1r6eo2pSZyLfR5XhirJeyxYa9n9Kqgn+x0NC6iqe2ona3vHiMcrOEetHDkIy4n4/GgPyJpPOdipmgwoT8pK2dpNTDs8uFsf2XjYPAk5SXysuugLifm+2ro+qStJyFmf2L1JGFtYjk5oKdz5PUhLLofnPOmubXqcjgvoK9haCKpG3EkJLLdMWq14PQrnOIhNTAp4ic1L/lea99q5KTwXKrzoe0taO3or6piG7WqXqEpqiLipa//4rMraSOzbXo8t7Uibi5/+myppHRubmK3bq5v9PGgKuNooeuyfqv247Uy7zQ8taI0Ke1t9+6oavqtdqxjd+Dp6bV0fynocPTrIKw/6KOwqi5xZSv6am0jM7ngfLi19vv0rf/n8KYpaqZtpOP7baVnI2koomrj5Gn5Kbk36yUm8eEidHt2svFl77A//7bodTOy7DLyvuwnaTwldbB6YPCgNrWkcbD6NeTqMOaxZufiL+Az/jIyLzc0ZrTubP4nb3XkYSbj675iJetj7yPyZ7n1cq10+nu6IqJy6qjibXrvZ/Z6tGOh8HIfoG50MLZ8a64xM6Ohb+qrIDbfojtt7N3ebLn6c+R09fv28Lum+3W/L6c3uGR4Pjss8rFx+Ckq7K/gNGjmYWbj56vtICIvs+8ubSR97XI16O8rbu5heLfivel//yL1rvf8+WW9ZCB5ur05oGdjO/ZyZqx3u397dHUqo2qoaOanpiYkZWwg89wr3aOu3OAmo7Crba/hcp5obXihuv4ysXOu8LVqHbd74N3eXl+mbnSorrF1v/wt8LSgO+0gMG+nJ66nrKGdqdqlLerxnO+oJewybZ3z4LU5LSmb8Ge8a/C1YrOqKOQt7uyaryQtK+bg56XhJ6Tc26nyJTHn/WfiImiipiugovgprip1aSRvZC2rY2xkq97abKS7P3oz8ivwZObk5t8ebeHbm5nqYiB6rqfg9CEk8fOoZyapJ21gDs+Mzs5UlQ7K1NNLzosMj4qTzpqNC8kOU96dEpMRTg4Ly08MSZDRS5CMklKWDItKFArN0RYSHFigXJHUT0+SjlrRGBMT0EyLzxhOktRMTVaQ0IxR0Q0QSY0Jis/QUtARlAxP0RFQ0VOJkU8KDJHQkhPLCs6RCw3VCcuPSwnLShLgDUvJzszOUZCKzZHV2RiQzNFZixAYTUiLy0gUzU5O1UrSUVDOTBRZzlJQ0dAZkg9PTI0XU4vaV1BU4ywpraf3qOZj21jlm9ksJ+Yi/D/n8fAdp2JZF9di1ZibrGozfySma3K0Je1xNvLu6qir7Ojoa24nbDJyNfSqZWEkX53aVhagEFjPT9CN0JFNjs0MTVoZmFBRFNmx8uXen53dYhie3p6pYFlhmy5r7h38Nnbn8xKgpywxoN7pJe2v2JGjp/Lznysl7eSi46fqK2XhoGNb2CUnlt7ZZxyZreadnSjiHuPVbxOesOHcnhyh2K6gHl6gqqEZ2tDYpZiXFBdRENAUl5OgFxYV2NUT3RLWk42VptGV0hRjHXQ1nua0IWsbYepaGjJof3AgbXjs2mNYolqfVSagJv3huO37Jb81I2ln/7nyaC299n/h8ePwaas5oDS+p+zoZelkJSEdlmtXE5jhHVQPDxKikV6VlhEUWuQkXZHMIR9sHhqbVaqiI5iU09kaYqsgJFldVglcFtWUURPR043PTMbUC8YLlhWMD1ePF45PFE2SWFxcXoyT1ZrVmSsXkk9QzY+RUM2RzqmjrVyO25xbWlva1mJZ4BpdnZteGNgin1nal9xc1txaGh0eleVazlNVjUdGTZEf4yJUkhGUHRhXVlRg1FMQYVKTT9dLFBTSSg8gG0/QTMzbWNEWjswSz1BRTUqW3FmdHyXVzNXcmF2PU13WlhcU144Mjw8HEcvMUJpQDszOEBGT0M5SC84RyxyMkCWkXBRbLOxbGxZs7bSg7fZ6vepj8GWm33je4Ht0OGZl8u+qa1MZ2NwbGFmfJROi05Xo6Bog317T19ZXW9eWWV0gGBBPzxKRERMT0A+TWVjY2JSnm90dVdfYWtySpuPcbpOip1RhISWp5panFdPlI+ihVyGici4poSTmZqTkoiPc2mKgYODlHl3d3mFVXdKa0FIZEhIWWOJe5Gdgc6Enafzaa6znKW2uq670oTk4ZCEdHd4hpTFnMra1LH3emuBdd+1gMrGsbG+nLWPa5Bci6ukumuxl42it6Zqun/e4NLXg5lVgnyAm2VvRFc2fW1pV6F/mZeGcomHeId6YF2RmlVLM0MvJSkzLSwsIzY4LURFPTVgaEhedFp0bHBXSG1Pi2VaVFFXZTQ7UF01LV9WQDtBSTQsVUpWNUssMjxMOk1CQzROBH19fXyFfYR8Dn19fX59fXx9fX5+fXx8in0RfHx9fX18fH1+fn59fn5+fXyEe4R8FH19fH59fX1+fX19fH18fH19e3x8h32Cfo19BX59fX5+hH2CfoV9gn6OfYl+BH1+fX2FfgZ9fX1+fX6FfQd8fX59fn19hnwDe3t8hXsEfH19fYR8BX19fX5+hH0EfHt8fIx7g3yafYh8An18i32HfAF7h3oFe3t6enqEew16enp7e3t6e3p8e3t7h3oCfH2FewZ6e3p6e3uEegl7ent8fHt7fHuEfAJ7eod7C3p7e3p7e3p6ent6iHsDfHx7jXwEe3x8e4Z8L318fHx7e3p6e3t7fHx9fHx+fn19fH1+fXx8fX1+fX5+f35+fXt7enp6e3t8fX19iHwLfXx8e3x8fH18e3yGfQl8fX58fH19fXyLewF8hHsFfHt7enqEewN8e3yHe4R8BXt7fHx9hnwFfXx8fX2EfAd7fHt8fHt8hXsIfHt7e3x7enuKfAV6enp8fYd8kXsBfIV7Dnx7e3x7e3x9fXx8e3t7iXwFe3x8fHuEfAV9fHx8fYZ8gnuEfAF7hXyHewd8fHt7e3x8hnuEfAF9k3wLe3x8fXx8fX59fX6EfQF8hXsBfIR9Dn59fn59fXx9fXx7e3t8hnsBfIV7gnqEewF8iXuLfIV7AXqJe4R6BHt6enuFegR7ent7hHqDe4t6gnuKeoJ7hHwBe4R8BXt8e3t7hXoBe4h6BXt7ent9iHyFe4R8h3sGfXx9fn1+hH0BfoZ9D359fXx8fHt8fH18fHx9fod9AX6NfQZ8fH19fXyIfYJ8hX0OfHx9fXx8e3x8fX18fHuGfIZ9DHx9fX1+fX19fH19fot9AgIEAICvf67Oodt5sqfAmLV3rtCP1KCplsS74oyt0syIo56HgsiGtu+X1o2jvuihpY2vxuSGgZKak7OYkZLliZKqnJy2ucncw8uzwPHYic6Gu4S4t9v6koO73IHR7nfe5reB37evgtl3gLS+xIzxuuj2vs3C7b/n2vyhjN7ZluqHoc+yvYDKqaC0voDQ7uKBgJyHgIXM+un14qLj3+b4/dKhmb3K9pbKhcHH+vnD79fd+bv+4IXCoYGCnuyKoKbGicqudYH1wMvIrcKN/qygfWip0rTPfpiogMSkwMeNl5x+tXqhoXZqjIuHlqGvm3puc39/ioyIi32Bg4GJf3KJs2BykYyBb4CAr9/H03DPp35/5Gnhp5y3tnSacd2ygIF/f27MmYSTt9uKgNXj6YSym6yUh3yNv6Oy4+zVvNSHt4OAwYrFk5udyqrd0rO6xM6G+eH1+eaFo7ac1ITPi9Daq5yoyJ/6uKeByLGm6I7br8HGxMmbg8CWv6K9cYKq17KZhpO4qpDDqoB8e6nfeqHrkq+CqJuwhcaclK1zgLB/hO6Ti8TlgLOdyOyizsXZpofqn6n779a0pNmN+HRqpHCaWW1tb2afgXWGtp+DhJqLZmWMaldiYmBkp+jnromsrsenhcPjr83DlZqLtKe+cMdok5yRxJ/bfqagkM9xwO6NqJ69/MqDo5J0gIDCiIy9ktqyiHzLrZC4lampxubDs3b4ldiFyX/Dm8bG09iwpdBx1nq7r6F1loC7q4Tt0+KbtdD8qpGI6qTMraKOpbqVo3eGcm5ty3RwgtjQlICdiZKSlrSDu8qhxs6gl+Xr07x5rpKOwLWaiJ9y467eu+Z9m6fT6L+uecqvvqeprICmjnGLotKoe6Ome9OAeL28rK+ZyqLDj5p8jneSeYZvkoJ9gtV/lbOVr5ukyuHn7tZ9wbqW7euI2Mypg9Opjp3Ah4u8l/z+xtXL8b6yhnO2WmKAbW9lqGtrY2Z8r3tWUaGK6YrbieXC0ZGLxNDOe+J0qMyp46H15XuJdMGun3d1e4CMktCcdnyHoX3Sm6l5p6fUcWl1b2ZlhIV5eHjbvXqRqXHcfL6vpGNtu6ljqq1js6Wjkq+JsYZoZX6PbnR0deq9hHpze3d1kLSWjJaHdIe0pKWPj5+Q9MLBoJ3jwYFqdYmPg4mUnI6ghphgi3unjujck5Pplf+UvdXSyqKM6Yzu8ICChPSniMqngLaDyOqagZCQjZ6Aj7+Qw4Lyl9q3coaTgYSjv6uohbGRgpiVif/k3IvyvqfWs66olNufsYtxoIyVxcXFcoC5nqqiouuR0OeN0/Og4MKCr4qqw8a5tZ+Z3pHZ9sfGu/zslJi/pMLe3Lq4hJzl9tG9l5q77r2Z98K38oDCi8HXsfmJy8LlrNGKz+qB+by+suep7JywsMWLkI+AfL6DoOOSu3ip0PmriWyMlLtvUWl9gaR7nI7PhHmPiZCQhZm/mZWFm9zfgdqVuILFm8P+oIjD9Yjk4YL2/LllyLW6geuCfLXD0pj5qdH+xsS307vWtuamh9rBg8lYeceRlYB4b2FuhlGRqaRWX25hWFmispuwqnyru8LDz6B5do+PonCXVH+Uxo14lYmerIfSwW2blHV8k+KHtLXEh9C2dm/UrbKvp7956LClfm2j063OgJusa6ibrbx6dpKBvoKlrYV3o6CgsLu9rYp/h5mXoaaho5WXkZCYjoS0+Yiby9WUhYCjzfza5YP8nI+G+YD2x8Pl55q1lfnwsLXAvJrPk3+0z/aijdLb6Y29nrWWiYJvoJWr5PXUtsl/rHhep4fPj5qVpZnU0LS0usmF8tXU8tx7mZdtq2usY5Gjcmh4lXu6l4eD17+v5o3YqsPG09m3mMyTxavbhIyU4MObf57ZybXbyoCKi7j6gKztmL6OtbrWib+3u/+eodiQoOibp9LqeaCLw/GYt6fcpoDelZTQvrKSiLFx64B0voW3aX+DhXy8mYue1rmambqqfHeegmh3dnV4vPP2u46glrCdd67Ens/as6io2dDnhvOBusic57X0jb7CptKH8P2fsKm/9NWkz8GGl4DTnJbEmuzMlofYvKLKrryz3e/XyoDwqe2P2I7Uq+36+f3I0fqA84vY17yJqIi+vI/84umrv+D3pZCR9LLaubOass+mwI6ik4yL+o+En/njppGqnaegnL59wt6rvs2Iltr/572Jy5yg39S9nbWB6rvyvc+GpqvX3se0gcq0wLa6z4DPrICbteOxgrWqhO6OjdLWx7y26cHfsb6NoIeqkZ6GpZCJgu2GkMGgtqOz49rn+NaGxMed8/aR5dKzj9e3m6vBeZjBkubnuMvH8MbCm4XFa3WfgnxvxIB9dHmSv5JoZMio5p/zi/Tc8rCv4+zghOKKutmy47D794iNgNrMr4WYlICnrOWzhYuTp4bnq7SDyL3mmYqbj4KJnZ2Wk5P/2oeWu4X+lOjk6YSV+OCH7/eG/u3ksNGv5K2QmLncrKaBj+7Qo5WQramRp8uyrKSMgH+9qaF8eIGCw5GQfYXMxY6DlLjXvdLn4svnxdiBto6qmeDch4jSividyef11rSU5H/i4YB8f+qcdLCWd5tvpr1/b3N3dohyd6Fxm3LWhs+6fZiheGmAlYCHdaJ3a3Z2aca1uXK7kX+hiIaDe72Ot5qGxaml3/ftjJrgvNDHr/KyzfWsz/2w7cx8tIOesK6LfY+p64LN45SWj93fe3CLcoahvJiceYvY3tfVpaq4176W2K+e/n9HNDtNNU0vSUdESFsnMT0wQEFHPkk7RzNRhJJITkEyNE4rQ1Y0TDk3P1JAVD9BNzYZHTI1NlJFO1KERDRZKy9RTmCMZVRLTGtENEw+MCc3Szw7ICU4RihDPiFQSDgqREE4IDspLDc+PzFENkFQQlFJW0BCN0Q5MU9GK0IpOU46hSqAOCtBUEorKDozNzM/VFNIQCo9MjE9MUo1OEtEYzVIL01DWGZFWVZPaEhONSI7PD8kN1tGVluMi97NhFuxoamnpdJ99cO9koKpx6vHcGpqQ3NteYlVVXhtuYOiro+KwMO/ztfSw5qQm7W1vsbBxbaxo6GsnYuUqVtfbmFLP0ljeWuAXitfPDk0XDZofZSMf0loZ+zthX+FeGqOZFt7jrthTJ/G2Ie7nLiUiX9QcXmWx9ywlq1tl15Ah4HJh5uGi5C+wpyhoqh469WrvbBpiHdQh2CTVnSOVFJef2KPcWhnoYeFrnCjfpGLhY1OTqJ6qXFuQltogVhRPkZPSUZbXEhAYYmATHOsUW5TWGRpQ1hJS4VSToxwbc1yaZauaYl1uPCJln/KmGy/iHufiItwb41U7ZOF5qfigpmeoZjiuaq9/Ne3sNbBjYu5poGUkJCTz+7yro6Gd4+QaZSefJJxSFRGUVN2ObZkaFhdhmaLRndgXLJHhcFse3ORqphfdFhbUoRTVHCAQntJQDBMWjFaQ0VZO2Y/PEJuRldMZENbMmprW5xvWopBcFRcgINeZWeuXBlIM1I5MUFXoJJka2dwY2FTXFxKb2JtYmNlumtfbI+HbWh1bXJrbYpgjXxnholbU1dTSVM5P05KRkM9QkpEX1BJapRJR09uc1dJM2dNTkhQ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dYC0tIqhwMuTjLZ8i5uU5LuHpqKRbqd2wGfEeJKCiZjheJR0eHFowYeIpWRbmIGaabueZLm6bGuRh3NwdrpvgXmRdY6Pi3XGYnWKhqDbns7P3dXIgM3nle/Ig+3An3LIiH+DcoWVjJFYh3t8gofNhLvVu6js/NSxmtOzvsx7yMTNxIDh7par56b77fyM56CXxf7S+5jlvvf0wJ6VjtR/eYuj+uqd05ajnZqeoKyQjoiJ6f7VvqzwzuWF+n2lr4OGoJSPfdZ0mIx+e6t6kMrleYZ12sZ8gdbOh87f0/XE/LDcpY/u25ejwZqap6Chhd2NrO7Cj8mO6pOdiHzrrMy80oKFr4DMivjRvdLuo8qJpfr0o9/WyYOI5KaLycFnbrB1bpdxyH+pt7SPjIqtyMPBqZp2a6eSaY39iZDKhYW1U3hrkllprYp2bnS3joKIhIKQgHrbs4eDd/CO1H2Sj4j1l8StxKbsvqzxteGiqZaNzLzbzaut63vO2Ky1y+rmd7rAr5KBsYCBdJxkjIySlJykoaiii5+NoqCYpau2mWS0pqNfu6OCxLNlVJmRf7mInI2GYJR/lc3gcniC0bWaooHZ8s3PbKCcioV9qJzf0Kudg5XLwZfco8WJpXF5hJKzzsm59Zaam53hm6WtqKKYoJyWmpeeqJiWjYyMkoOG4PXRqrT57LOO34DK+q2ZpPP66Yfn+eXRo62Nk72rmYDwoK2GkvyCpc3g5eqRjcClk9KphH3wtKB1utS0yYWQrJqY277QmZC4uorvkIHx9e3Wqbagxq7DsKG0saWYqXGJgpV5p2ufe5jliJS6mOCyzI6a48SHk6/pi+G63srY/pOdnZmRysunj7fY34DWu7TP+Yyhud2O3arGm5y0oNfylLLsz5bw+cGaodt+fd/gtsTEgp7AyLZun4Oi1aa5gpCBm42Gz8K6tIeyb8txsZyNdHrRnLeFeXnNr76g6avShI6fncTa2oSGr4f9mfqXjoWe4sqp28H61+6bvr/kkei2j8/x08TJrLvz0LODhYCDnMn4nZXssLTKqM2do4fix9nqgvTasda5tcX84c+z3M3I4f70+LiV1+Xq29ajqMO718yT0ouKo5CNt5Kdtq7OooSFx5+nhITu24Sftu291cK6j+ybrZGoq+avyqX5oJOC7LPpkoWswKKAtqXrh6zI4fWTs7nLsvLM1qTCos7quYDBzayivcKqhY2l5YDs5f64htn/xvvDrbrlytaS/O2ppbWRkaOXlrS0o6z+8+G14O+wkKfRhcu5qcuP4eLGzfXypMrpm4uBkdiN0eKznY9nZ2iUg3K6tJzAqYO5e3lnupCIuYjei56rjM6pp+zX5K+Ou7vEvMiOkoLv3LHXvZurmIDUw5620uS2p8uGmp+d+s2hxsCwht6R8oH0lK2doKT2h62MjoiA8aKx7IyE88LnkffWhfrziobGyK2yvPKApK3BisvP0Kv5iJKtsLnhx9Pd3srCcafOc8u1c8GwpoH6xLW3j7PV0tuE5LSvrabbhrfTqqTg5su7r+XD0diE0r/Ew4Dk75KkuYnoy9Jvun52p82wz33OlsTHoouCfsqEgYWa28aAonaAfYF+gY10cGpouMeijYTLssh18Ia60aGgtaunmOuIurCblMuRhdT5k5KO+OSEj+XcjbrJzOLE03mcqZntyoWNjnl7fYF7Z6Rtir6MWJOD2nqWkYa2oLeWmmVzi4BHLldGOFFHPEsmNFRLM01EPS43WkM4Q0xFRYFRQkUyXTpDPE9KRjAzRj5Lemo3PlIxJDBDKjZcKzVYMEU4Pi49SlBEOUNnTkNEQz9EKCM4NR8cHz4rPicoLClHLUQ2NjRMPjVVQkwwMysuQUBFRz5HSis9QTYwOUlhKzxJOjAuLYA5MUEnOjpCQ0xRWFdNQkkzSFlHOTg+Lhk7OVAtRz0mOU01MllUPVdHY1BZRWE7VGJkRzJAVmBGXkub08XTXHt3dnp1ranz88u6k6fFnZbqm6tbc1RmbHGYq7Sv+pqcoLH9s77Kx8C1vLmzurrCzLm2pKKlqpOU6/22kpOmhFVGaIBce1VLT2RcVjdYZGdhaI53dZiBjZDOfXtdZq1ifYyTjItVW6KcktK6fYHxjYNYpLGQt3iAf3uGuIe0iIuiq5HTfH3i0dK2lLKJr4bgu5nBsaGGk2R0WWuBfF2Sd4HEdnqLgLKPm3J2roRFRk9SNn6LuIh+kF9cTDM+b21AM01eV4BPRFxon1F2f3tFfVZfU05aS2tuP1STd228q3eOmc2FhfHutaWncomlqJVUc2B/qHiGaLCjw7Ch9ujd1p/Oh/iJ1cS1kpTepNGnmpj3zea24aLdjp2lkp3Q2Ip8iF6eRnxIS0lWlnphjGCQdW5Ya1h/bsuqY4egjaSm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3bz2vMOvsNR2m7dwtcmAjIzV3ph3zq24tLiCd43DfsSLe5mmxICsc4OezpO2xNWaiajboOXiiZXJgsajqJqFmJ3Bop+oknR1fozuqdq7tbmGx3R2spfbc9SZvJ6lo9jI1nJ+e4lrnHRzZm2kXmNYbn+Nq85/ucetseC6oauMnr2hhu+Dkch0cojFtpyemZSA1IV9jdN0kZCk6XWamK/1nbSxh3Wqf3KJwK3Na4TXeNy7ynJ2yGp0Z71tn12TmmVpoq2wrKFroadzfWplgnF1d3V8epuBhoLEz5rYjYaXk4FyhrWAg+jQ2On7tI6BqXtyfGhyg5WBdX54d3l12Mn2fr6EoeWeuJ/Mqslsz8vgfH+A14uVo+2V34eBgKqRroOW4LbApOjPzZv7yY/Zsrv99b2BuseE/97P1vCMoo6bgeG+xvKHnpmtsaiupbfIkYWOsqWVn8m5erjCqouK7nKD9bOZl72sipvM8+B1ubqnno623dHS2oWa6PubgZ3frcS0rYuitrmBqoLqn+T30/6J15OAycvWibyjoubi7ryDt5ffjOqH4I/VwsKNsNWq1W3Bq7twj7a/hoGqp62TsbTmg7ekk4S8vsbA0IKKY2pydlxbjHRrmFVwsqCfrml/ybrVxbPNzNvKoJW2i4uBhoLqod6fsZjs0359jYHvyM68ddi4wfGE4I+Nlum+c26Ee4iCgXCAbLOBv5dvh3mQZpeKc5KKgoeplXqgp4GOdIqiqGW6qae6vHCLbpB9oZhSdVRQhJW7in+pk7yzy/mLiprY1Ht/k5Otk6+SqbuNcqJ/gZyOrciIhJ6nwL3K4NvQyOSdnpOJ34GLip19n7axsZyZoJuGdnuGeIabpaKgnJOat4eth+KAwtz/t6Xb7YLT3uXrs8S/03RwzZq427Sshu7x2vySxfnXr7yVkL6LsKOg0b/RdfXO03ub1rJ984e4qsxtwp+VkYeehuPalsWz0p59ka6mhoTmrqueaoh2zXCsjczjjYHRfP27n9Lu4ne2l8ewo5bPoL681/6FkKGMntGSqK/CheCA4ruw2fu0gu3c+oOGle+k56+V4q24op/UpoaX4+eQoMZ6jXqReo+3x5TLcI2SrpbMs5O1qm+PmqfPo4mEh5fIc6ybkom01Xd9e8uX6LOlmeb84sbhyfOwvLff6o3Jjqa/ou21/LblzLrH54H92tG67p2Cx6Lbn83NkeWyor6hhKyAheiEiYqX8Y2JzdTRg73bqvypj7eC+Kn1qvjqqo/l0N/qivKv1funm5aLpJzjt7PD7bial56O5ZCT/Y+prJyVzKvTlaWc+Yibk4rnm7SNpqCejOeMjc/wsd3C4fp4+NeB0My0v/yM6cSp+oK2z/nhu5mj4rr0xNe1t9iAqb6Az92Ap6fq7aGD0brPwL+ShKPkks+Viaiz3prZhJXC9a/S7vLNqL/ws/ztlqXXjuWxtKaKqqnUqa6zo4iFkYnRtOLIs6V/3oCIzKrlgPCnvaKsq97U4nmXr6SHwYKKfYXFbHlwhY+dvumIzObJzPfVsauhnr6glPWCmNyDgZLk2Kakr66A5puYrO6Asa3G+YOcn6r5tM/RqJTnlIad7d7YiKLzhvfM9YiW9oKKhveN7IPU5IeK2/T5zL6C09+ms6yOuJCXj5anp8CvqqTz77v6n6utm4+AlLNwfamYtdbJln14ro6aq4CHtM+qo7WVmaWP5MT2gL6OodaQvrPgvN5439nrgX+A15Kgi7uCznZoZ4x5lWt4wJGZibWrroXmtobSqa/W0KdtmJtpyLq8tMpyf3N9aLiepb1+qpyil6HIxsvnp42ky768vfDknerXzaSY/YaK6djBqtDBn6PD6d2GyLq4mmGSqHt9hmBou7R2ZGucfoF0bWd3nb9zjXzzkMbvw9h/wH6ASEFHKzg2NU1VTTMpNi45MF9Ed157SUo5a5Z2eT5WYHZMTlBgSEA5LTosRF1nQWJnTTI3Mj0wPCcrOE5ERDIwR0A/XTZIeXA7NzRKcVNHNC01OjI7MCo1KCclJCRHND0vNjNQRS0uLCRIREg9KERDQkclOyUpLUQ4KyIzODQ4NzGALU8xSjMhMyQ2N1I0MTwwQUBbTCU7LycsLT5nUS9XMjlQTDdDNE9Dblg9WTM8RGhiSUlTW2ZNU3tEVXXEwG11gnybi8CXy+KqhrN/d5CGssR7boqWu7bC2tPNu+aep6OY64mSmLqbv9HIzbWxurOWgoyYh5a1xb+2tKmvmlNoSHKAVVZtXE1bXjmUi22Ri5TO5IeG9bfBupB9X6ynmLNjgZiEeZWCisN+fY+g1rieX9Owy4SWrpxqxWiWru6MsZOMf3uXgdK/jNDCsX5djLevj4bnnY6PVGNa22KQfrzFc2WlZZFvb6m0qVRjRV5a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jZWb1ove2ryx256hj77NoICReoiIkIfg7LCspZSVjH63w8zAuX+sv5K0l4WemKyb53jP24ijz9ODg3OaorbDq36dhIDmh+Wll5GpmHyBhZuVjoehptCMa3PQ1I6Mo5CfgPGBiY+4ga265au6ipeossyRqc9w0sPBcKCVubXEpbHDusiJzLCR3IC+w6fG4byj0oB7wu2pxcN2jb2lhHTWrX6kxJJt3XiHtrDDxKmepp7UmJjCjbic0JqjotrDnnetoMOEkqKXoO2Lc3bQlv2NlpGproqM6bqdbs/FmYR2dqyMsaV1rmWuutJqdm6bXllhbJOHaFxnxZKuvt92im541XHk2bCMoarJ5a/QxKO1wZuOtIClo4fjsX6DuYnJr//S4M6st7KakGV+j57HhHRmc9W+m353g2ltb25vdH9viGR1jHKLpY+tvXNrf3R4bWZwp2FydnVqdoCPYoexiL+shGXIdct03HWApKGQ3pWWy6Z/n4h8iX6HlnFwbWxvkm11vNmWfo+s4LKFxGfBx3Zzen+XmICntZD149aT9PDn+4WazPGw4sDMq5G4lpnt6rCqxuPtx6HQ08D93c/kuMH+h5KK2bzRqd6tvOCxnfDguHmVm4XGsJuryJhvaZqWgYKCpI12y6yVrXd6s9vi7dPlfYOnuI2rmpyXqcmFuNmnxpqHu7SLha2Jn6+0m4yBtJ+a15K8goB2fKbErqyrjqPVhsKarvrkp4aFn7+chOngq8yvpI3ziK2Mm6Bnga2fi82eu7LZz5WUZJ3MuMTI056Mo6B/YoeFa1pfVnh8kmtvarjQyIFks7/k59DphI/kz/6go9Oyibib8++5YLaqpq+m5+Kh877cicq23IOTzsHT5Ha3fuxocoB3b4mHjmtweotujnBvk3hogZiKeXywh394kYWXsKN/bW9vlW1kZIu1n4VsppdfmrjUrqh7gHih5cuFmbzG1NK1o5OI026Cd26SkJ3N1qOzx7Hjh6ve2sCChJi1s9CP2ImM14B7enWTnsHYua+ZjoqdoaWrrLCxtbWyn56orfyliYCB5o681Ziel5Hx28XAu8dvn5Bdx7f5mK2S9JiF4YyhqqWakIWSn+mLtMPYodOOwMehrPGzkoiVl4Kecb5qoe7suKmFibKWjKndzYDgw7KOd22qta1klGrGZZ+Ug+Dv58vp7tWA0qDJtaehhqjYkY+vkeL/84zzo4ORgKO69+HuloCCsa/Hx9usjI6u0IuImJiu2cOyhLqSosy19M68vsjn8ensh42al5aXj8HfaMGYd4igrs6RkK+zun+bgpLLr6GrsqWPjoh6g2ltt7vD/tGU+s2Ep7Cd4IOLjpj/2c2QpIaDsMy1u6qXoNT+2oHTsY+KlKav+5f39NG34bW7qc7ZtYCego6Smo/i+r6ztqGhmoW+0uvMzZPS16jHqpWzttOq75DX6ajI/vWNkIGgqr3JsYWokYjij9+fk5TAqIySmq6mmJO2v+ugi4357JKNlIiZg+F3gJPJibfC2am7j5irweWTte6C7uXYgqmhz7XTr626s6GG07WO4HezyKW/5tDB6ICR5v+z1uaCl9K1jofvyI2/z6OD9oiCutHm5ePPwr73rLHjn9O66qfBt/XZr4K6q82XpLansPubiIf3pf+PpKWvo3iT6dOwgfPlpZqAgbOTvLV+yZHw8PyIiXyubWZ3h7aje2x71I7C3/mDmICAzYX226+Yrq7L8s/v4MPN2qap1IC+t6P3yIib1afiyfnH8NHG3tnBsYGPqLHompCFi+nXtZCRm4WGh4mMkZuQoIaTpZW+4MHh4YuDrqyopZqU3IKVmq2jnqWwkcX0qerOoIHyg+yA8oSLh318xYGCwJSD08C+y7jP76SVlZ6pvZR/qdmghJq13p+B03PW3Yd+goafpoC8xYrDs7mC39nE0G5+qMSat5idiXehfY/SzKOgtMXIsXTczb3K0M++lp7HaXVxuKayldrFzti9pdjxxIexsZnZzb7S17uGgcOmjJCRvaiE3LOpwoyI0efc5dXlh4yxmFxpTURegIRbfot1gXBhjIdpVpGCnKKomYZunZOAwpG0cIA+L0I7NzY3LjNUMUI6PlpdV1dYeIxKRG6NYmZORUKFWYFFN1QxNkAwLlM+PTxGVl1SNzc5KzU1STZQcGdWPU5TQjg7NlZSVysgITQ7SyogRkE0OUVDKDFIPUcrMkU2KTI0VllEJEY8NkM0QD41Wj5GKD80QSMvR0hISzNTM1QoKYA3MDE4LCcnJTMwQSswQjYoPkI3NTY2LCsmWE9VTFk5Ky5AUDAzMURsY0I9ZF05aGKGa3JfWU1RX21TgLe5vcWxsaig8oChjYCbkqTX35yy0a7ljazf1MR7cYeyr8SN25eW0YaFhImntMzdybWfoaPBx8fR09fa4d3Wvb7MmqRdU4BRgEJUiHp/h5TsiZrCy+aCwtWB5rvZdImL0mxgm1xlgImDh3aAi85gdpXDiK6ixMaVuMKHemtyg3Cphc2ErejVrKqAgZ5/fpfFuGusrqmKdWGdnaBPcFWnWoaBecTBuYeVbWFcjneZdkg3N0uCZ2uMb42VnU55RTIyMV5seV1JP4AzSEtgS1hHTERGYD5CQDxTXFJMN0VEXX+P6MSxtr/Z3dzjhImXl5CPiLK5T4hoVGZ4haKtqsTHzI/Ana/42b/Q3syvq6eYqIKAsrC++8iI7eSNm6CN24mPl3B3bH1eVUY3Yn9WVllWVmaMhUBnZWBba2NaiHHy5IWUrmNIaGBzRYA6PFJCJyFjnlo1Wzc4NSRHT1ZaPDxifVyDO1JpcFA3l1quumdkaW95W1+ttNLbtFtcWlyzHFGWkJ2FWVlbXVRLUlFvd41sYWW4s2didW52abRdX21+TmNdal9bLxsqMVw8Rl0jPS9BPDdEY0ROTU5RS3pfb19adjJUUFtYW1NFVYAhTlsrWFMsNFNAICdWSjNotlEgYyA2RkVTWlhoXF5iMy1hPTs5OTU+Oz42Q0NDPDU3TV5GT3szMDNCV5JMJCZGgGJv0YVuRGpnbUx5l8Oj0NaI6mprkKtvhprSiYWguOzPhoCPzFpqcHQ/UHBPkkenpaKisndti3h2aWJvf1ljZYBaZlqDZUdQcVh3ZJNraVZVdHZpZEliYWOcbEpLVq2hiFBEUElYXEhNVmhOT0lQUlOMppvC3JB9jYaLhX5+2XN7dX13gH6Nbn6WiZK6XFGmUZhRp15kXFdnrGtvuX55nYqFloecooiBhYaKk4SPodusirDK65J764Dh75mNjo2nwIDk7oinl6h419nBxWh1mbCPpYaLe3GidpPJxaWrtr27oV1jc3mZWV+aho2rXGZlqZ2ggnlHToRsdZpoQiUvNzpIP0hFUTYpIDM6NTo0QjksTks3TDQ8Wn9thWpWLTtDUjtEKB08W1ZCYGZVW1JIfGVMOVdIQzg4NCosPzsyZ0JMMol9Dnx8fH19fHx8fX18fH19h3wGe3x7fHx8jX0Bfod9BHx8fX2Hfgt9fX1+fn59fX1+foZ9EH5+fX19fn59fX5+fn19fX6HfQp+fX19fn19fX5+hn0Cfn2GfqB9BHx9fXyFfQV+fXx8fId7hnyEfQF8hH2KfAF9hHyHfQR8fX18m32EfAF7jXwGfXx7fHt7hHoEeXp6eYp6hnsBfIR7Enp6e3t7fHt7fHt8e3p6ent7e4Z6AXuIeg17fX19enp6e3x7enp7hHyEewR8fX18iHsGfHt8fX19hXyCfZV8g3uJeoh7AXyHfgF9hXuRfIZ6A3l6e4R6hHsIenp6e3t8fHyJewx8e3t7fHx7e3p7enqKe4V8gnuGfAF9hnyEewp8fHx7e3x6e3p6h3uFeoR7B3p9e3p6enuIfIZ7gnqGewF6hHuGfAl9fX18e3x8e32NfAF7hXwBfYh8Bn18e3x7e4R8Dn19fHx9fHt8fXt9fX18h3sDfHx7inwBfYh8FHt8fHx7fHx9fHx8fX58fHt7fHt7iHwKfXx8e3t7fHx8e4d8B319fHx7e3uFfAF7hXoCe3yPewF8hnsEfHt8fIh7AXqEe4N6kHuFeoJ7hnoBeY56Ent7ent6e3p7e3x8e3p7e3p7e416D3t9fXx9fHt7e3x8e3x7e4R8CXt6enp8fX18fIR7hnyEfQJ8fYl8i32Dfo19AX6LfYR8hH2MfIR9hH4EfX19foZ9gnyNfQR8fHx9AgIEAID1gKHEepu+vKvUh7u6o5Gz7p3t+e276L2XgoWJb2qGhJ344bCekpGFuua17KV6v93WgoPfiaLU2LWdqo/EkbG1lc3oqKDH66Wpgo6Bge2xh8bd0LWG89nU9Yl9eN7Ge7eT2u/FpsWNqKbB0eOKhdH+nIvMr7jn+PfngMqyxN3d0oDelYaG2I2xwM6SsMm9nMSGxLCsvt/htuz54cfA8umXkKSQi4ikhs6524CGlsTYv+virqXF1rLvs8CHqMOPycSumJKSZ7Zsno6yys2Kd3Lf35R/h7zUroe02p+worD6sLHo1pBwbm15hJz2zqmgraGWnICFioqNmJ2qrJuPhXx+24B32nV7za2gnpm3wby3tKymoqmSip2Si2m4rmmHdG+Vz8ahdoZysoig07ibl4WJxprnw7Z5lbCbu/qkpJaOtZXPqJL6tdrLg4u9qbSnnLyuzcq1+6rY0IqIjM+djaLr0eqPcbXl05GI4Xvb3aF4u9W0m6Sa49aKoax0zJyWoa3fZYCkiICOjL2phoGmoqiEeYuRypV5b7iAdoO7i5ft3NXQ1djR5P2H+YHy6fiO7IXBzKr6j9F0pKWkpJ+qtq1jpHd2gY2Hf3txUWOBfmuSv3FpeGmJ1rDMiOSIo7CGta2olseFoKVzgnyZd6GNc56mkbLvkJGZhKG/0qrdqfjekZVxooDRqJOGpcGJwH7W4+KCeni5i8WX1K3HvbW6qrCrucXj49+g2YSrgNKFw7GjmKOws7aSwMSj44vLpoyPj4aDdoJ94MncesOjgr2L9+nN3bGI26etrruBi6Xa7crTgZuWtZaijajfyXjohp3NqJK7z6+5wMmayqK1eL+Wh8D21Z14fYCGeaiiycu2nnyGkHfY5X5yj3Ku4+CUvNGGer6il5umy5x3gZ3b15mT5sa50ZGisrKbyHhqeX6sn26f3NZ8bpec2IvBctytvaOJ2ZyoZ6y6mGx8bWeDerBzlIR2dIeYnKGUgHRnpJZ4sqqjloeH1qF7x3qSltPv28Cw0p+lw9nNfoC+h8jdrnrZmpallIOfesSYeMGgjKevsIOmen98eHXgt9d7vsVrbXh3ymzJcHlpdGp0tIzDgcCvc8RnZcnAt7ZpaLe3dGa/sXyKqomqbGy5icXM4tbIuuWng4iSsZK9sIVtb5SOlHVxfJWQq4SduOOgo9aTfpagmnV9w2p/iJuiiICar/yEltiIpqe9nL7M1KWhnaD1kIasnKDXhsH//93tp9Ovo6/ulqr118iAgPnWlJT6ire+moaAecfJncedmJm6noqGt5nFg3mmy7S/0KiIo+uU8uiNjprOyYeMoKfGzZ+L3oqHgO2cyKGCkbPE08mGx6Oqo6OQjrWtkNWBubLjl4DhbZfKhp+jxbfelMrMt5ma03en1trF4qmioamolIKOgoLNqohvc4qItNyp6JaGvtWlYmPFjpvG3qtiWlJ4VWRsZ4aWd3d/kmR7b4J4f+SSfq7Vx61s5NnP8oiThfPLhKii386mo7uPnJqqv8iChM/umoGul67rzr6xcK+itMquroC7d3VqoVlld4dhdX2AZn9ei4p9h5OtfLfQoZKGnKNbXXdjWWGEaol8jldkcYqcf5eef4OSrIfAqMmKm8CSvcO4op2fbsV4oo+50teWgnnv8paDi8bMnX2QlnySjJK2k7DUuYZ5d3uKmKjkz7GqvLWsr5OVnp+kr7TAvrGjnJKO8ICI+IWF5sS5tq3K4NrTzL29u9S7r8W6moT35JzPpYmezcmigo+A15m36LmbjoqW1qjyzMWBlquJr/qmpqCatpXaoo/xsdjLfYK4oqyakLaqusGh0ounk2hycp+Aeonr1fOMgdTx8Z6U9Yvb78aJy+y/qquf39iUq8mF47CuxczvgYDZoZ2wpdC/l57I1OKsjbaq36OZhuC5lKHgoaHu2s/Gz83F2PuG9Xri1uWF3WyaoYjLb516vMK/uq7F08d1yI+RobOqop6TaHmPinmk2H98knua6sLlkvig1veyz+Kxj550usaXoZWxmMu0ncLFoL7mmJyfkLjV4r7ntvztoqmCrYDnvZWSqsmRsovj9e+VkIHFoN2q8c3qzdbIvMSkvMr79OOl65HImPKTyrqqn6u3uceRwcCg74bKp5Gho5aVio+I9d/thdy9mdKY/de7vbF+waWttMiJkqnc58TOgqCawqa6qbv93YH+jqXftZ3C1qu0yJSbz6GwgLB/e7nhxKOAioCVjamt5u7Qq4WQpYzu9pKBo4fG+eyk0fqfmOG4rKnB6KmHmLf28Kmp/tnN4Z+xucat6JGEkZC3sYGu9P6NhKSr3YrXge7ByKmc4cLAeLDEq4CPg4KkouuTuqGNjqW4wcatlIl3sqKDy8G+rZSQ37WH0IKfpdrw5d7L5ri30efni4DakdbtvILryrbBpnufguG1iefFqbu6vn69h5iNjof7yvaP7fmEhY2N+4L/i5aIiYGP6rDrmOzajvqAetvZ7eaKjfzynYr//7HE8L7Gionlnunu8fDnsc6gipKYtojNw6uZltjG4sKvwubC4KWvtdWrsdmNgJacm4GL2neMkaWpjICeptBhe7h+lJqyhqOzq4WIe32/fXaRhJDBebfp4snZoZq4sr7voqPQs6JkZ8eue4Lfe6HXspeakuv2yOG/tZ3VrKamubDam5DK4srW68aateuh//yXnJvIwYeRi5R+clNUpGFkWqxrfGpkcImZoqVur4uqpKSPkLGOaal0u6/mmIBjMTRDJy1IQjpSPFJFOD5cmFV1o5B0dmZTT0pFOjtFSF+OWEU4LzMyQ01FQi8sR25XMDQ9KzRBSDYkLCw9LjpARlheUlhTVjcqHh0bIEA7Kzs5Nj0lRkw7RicqKVQ8JDk3UlY8MkEuNjE7Pj8oKkZXMzRRSENgYWdTMls5Oj9FXoBJKCsrKyYqOjwtPkg5OD4lQTM5PVI1PkhUXVJJY1M7LzYyNTFDMU49OiQtMEdfTmhiTE5xa1RSYnBwlciZuMnUuby5gOqPvJnE3uimj4P9/5OFkcPPkHV5bmB2eHmPgqq4j3eDgIidrLva1be52dnS0Kusu8TL2uHu6NzNtHdMqYB+p0U4t9zXzsPLz/T37NXe3cSCeIaAaGS6uXqJal1vlJx/bHtamYx6n4qEepe43Zi9m3xbe4Nwf7+Lmo+Oo43to5Psosu1aW6egoJzan15h5mWtX6Hc1NdY451bnW3pJtJM1puYFtRhEBiUkFDeH13ZHpJh4NLSkEwVURIUUZcJ4BOPTtJSFVJQj9JS1VDNkZNYUNAOVVUbIqMaoze0sW7wcG9zvaF7XPWyNF9xlR1d2OVTWmI4ujr4sfq/emJ86+vw9vRx8a8hJeYkYq9+o2GpoWRzMX5nuhoeWVTlmOBX19IZZRTaVNaS1ZVU1OHc5ajhX9uYmjN5piqrsiXZU0qe4BwSVtWI0UuLT1SeHM/OiRJM2A6Wn2EenOCcoByqZ9unbCIlVlnKnZu1MKwqbnEulqPxb+dalC/rJ55YFxZVklKhIOEUYt6Z4BouKKdn4Jso3iBhoZJR1hVXl1aLT1IQy80LD9EVTtzSE+RbDhVTUJQVnBvUltYSW47MFpTSU04Q4BKOy8nTEthPCgiKS1Kay4+YTU+RHA9VEglJj9PSzleMTEcKSk0OzQ1R1k5Ojo2MS4zZzkvLCtCSDpTkHwyJ1lkoXauVrCHq2FRpHnWl73Q0KG0olNgbbye69m7v9vw+//aqqKKuY0/bWdmWWppklZSl3+oqpBZUHdsf15VeIB/PoBoSW1uakd6ZnN3aktZQkZFNWtjVlhzcU18RkpMVFG4ko1Mjn9VVl1WjlWdTFhSR0pgjZvwpvPbmPyOi+jd5uiAbtbfgIDh03eUtI2iTVCUWZKYqa6sfqGaoa2vyXOyo4F1doqTm4mRj5+VnJzJv9XCzuyMhZKYlomR7oudn7y2m4CxoqpNa6FuoqS2dY2bmXuBbnCxdW2Gfo25b6vd2sK+XVFKQGhzL0yunI5VV6ydbXzRbHJRKjE3L1NdPEo3ODRERU86Oi85LC5HSEVLQz8sO2JHd3JLT1ZmcUk1M1RHQi44hEtRRXpOXks9TGV1h4VFYko8KS0uL0RDLkc0UlBOQgF8iH2DfIR9A3x9fY18BHt7fHyIfQd+fn18fH1+iH0Dfn1+iX2Gfod9AX6EfQh+fn59fX5+fot9Bn5+fX1+fod9AX6HfYN+k32CfIV9B35+fX1+fXyNfQF8hnuDfIh9Anx9hXwKfX19fHx8fX18fIR9hH6ifQV8fXx9fY18h3qCeYp6Ant6hnsMfHx7e3p6ent7e3x7iXoBe5F6D3t8fX18enp7fHx6ent9fYV8AXuFfIV7B3x7e3x8fH2GfAF9kHwBe4l8AXuJegh7ent6enp7e4R+BX1+fnt6hnsCfH2LfAF7hHqEewZ6eXl5enmEegZ5enp7fX2OewZ8enp7e3uHegZ7e3x6enuIfAV7e3x8fYR8h3sFfHt6enuEegV7e3x7e4d6AXuEegZ7e3p6enuGfAR7e3t8hXuEegN7e3qEe4d8AX2KfAF7inwBe4Z8gn2KfAR7e3t8hH0OfHx9fHt8fHx7fHx8fX2EfAR7fHx9mHyCe4V8BX17fHt7hHyCe4h8g3uLfAV9fXx8fIR7BXx8e3t7hHoDe3x8iHsHfHt8e3t7fIV7hnyGewJ8eoV7Bnp6ent6eoR7A3p7eoZ7Cnp6ent6ent6e3qEeQh6enl5enp5eYR6BXt7e3p7hXoBe4Z6AXuOegd7fHx9fHt7h3wEe3x8fIR7CXx9fn18fHt7e4Z8gn2HfAF9hXyLfQd+fn19fn18ln0EfHt7fIR9BXx8fHt7hXyEfYR+hH0HfH18fHx9fYV8hn0FfH1+fX2EfAICBACA2d7hsaWGqdDlmpLfeOW0wvDQ8sTGtsjCiHdrgYyfjYG8qsuX7I3T7L74wrPo43jdifuIk7l8pr3IlIKb06Syx5zFkYHuy4KMl5ftvrel1cqR+NK65vvV4d7xgM3a6YSMzdypsbzmy/L++b+b89q51+XBza3Hncj1lpfu9oOe9NSAlOD4hOnBo7SSive7mpyGna+w19Pag4KQoM+0obmBjI/Yn6C045uXgJe2n4v0sM6trs6vlNqpkYbSg6D0krnNq5yVfMZyqahxdIihooWVoKuqsqt4p4L0p56TjIuJ0srhlvSG2WdqdXF9ka367r6ZmYyZk5WQlJCQkZCDc2eEgXKAd4+Wc3RnoXiLm7RftI6qnYuSoZJ4a3XNtKhuhoPIiW6GstaTo3GIdM7u75GbhvGKfKCDjOmgoPWEvZ6ElX7fe6f5jI2fuqjBwr3Er6fR1vnXw+rBnfubkqetqKaloJKg5obPpsGXqZGKkKGtxr3Ocoy5ruq+oafRsJSHfqKeqWOAa2m5csSPgMbYqKekebp4aYLor6Zpna2ptJtztpKFhpD/5IT73sXrzr6zwL7b88a/xZqWu3KEqZWLq3ubm4Ktd1ZdbW1kum9ifmRrgL55e22Ty8q1yrLrb6ijko6bxovr0pFk0ZBse4ZqZmSOhIybiIB44OjagXyNtcGOvoh2vZuAwqyqdb+mjKfEv6qweYSZmarUw3/Lk7vAuInRscTU1c2oi5WxzMOZvr+ukYaJoKSiirCwnqC4+LKQlnWNh3OCeM2/jIaOxaicnKLKkIb2i4/24/CtrZmqur7ol+K/gpaB0YGJtol0t9J/vI5zr9qzsKHCq4bFi+WlgK7fwNLJeqeAwcefpoC1hb2hyrpryZCaoZqB/8PWioWXnJeApoKZpH7jmKaKh66juqSRxo2sqrakn4J1p8J5k4F5l3am47zk3Pd7l36+tdyNrdzQbr/at5J1erqRhZBncqiAg1mKuKWSqONybOjUlKSMxI6twMuZurqWlaSt+7LHqJp+gJeIjqqAlcGS5IKJiJOTl4/efHeMlG+XjLeCpa//5oOlh6mWkLDXeHpucNRvysGKf3DFureqtWNyo2eCem1pr87ovVyrn6m6ZGylr7B7enJ7hJmkurlvpp6nkIDPgrK+y4uzyaegf4R6epp8gYKBjIaemnayasd4emdy1KqTfKyfcJqBiOWAzt6B3c3349Gwha3fz5SZp7+c6Lmx8YKX+9a6sLa9fsDhytK1m4e+hdyxn8bV0uWW14fNvoybfpPL0rKQqrKleYuLlMG4n6Oqi8myiLGJlLy3o4yPg+Do9ouB1Y3poKHFxrDm44DMo5TJ4Y+y9qjSuIi51I7qtZGioNKM5dXi7++Auq7RuK2Ol9DbjZPyhPWsncibopCjl6fCjoqLlaS1lIailZd1wXmjyaHgy7bo9ITsjf2Hh7qDsNHYkm+JvYNxeG98XlmnlVpia3bNs6qXk5Jnxru36NaxztHwgezj7nKK3bBzm5vDvMTf17mW3bmXr+zAp4mfgZCWaHK3wGJvz6d2Yb+3WqB2a31eWruBcWpgbIGAo4eHUlJpg5R+eINLUFaGc2B6vGVmVmp9emufeoJ5coyCYIpscHrAd5rtnMLZuqiig9B7s614fZaztJSms8C7wr6AqHzdiXJxcnV0vb7Jfs945HR8hn+No7fz8s2wsKOxq6mmqoSlgJeEdI6MgIeaqIR9d7+MoK/MbMyhwbSfttKwkoCA79/Qlq2l+5OHnenuqL6Hmort/fqHoov+lIayjoz0hHn1iMCjgY2A3YGs74uPrcKswsKu08Gl0eL60LDLoHyucHONiYqLio+NofV517rct8qymJmyxOPR7IKhsa7ksYad9M+6gJqRwrnUhYqF44ziqZzy9sbPypfZmoeY+tzVgdLiy9DCgsSWiImQ/+WB9NzG6Me4sLmuxdGnlJhwccOAncmun8eLra+Ux4dmcoeHeN2Jepx7hJ3bjI6Ap+HkzOXH95Hf0cWgxNSY5+asif2qmaOqgIqHsZ6fpoOGg/P6+IuDlbjMgJLTmIHGoMq4t4HMo5Gd2N66u4SapKW35+SO57Ha7NGQ8bXC0tTJp4qYyvjdpsbGtpaKi6WosIyyrJiZtv+4maqGnZmEh4Haz5mZntqyq66qyI+E33173tHrtbKjsMHB4JbXuniOj+iYlciYgczegM2ZgKvYq6efj6CLwpXxtIOrgNa519CUrszvv7iSzZLLst3Pg/adtbKli/PQ5qGVqLemnriSqLiS9K64lZPEuMq4peKbvbrEuLOPhr7hjpqPjKeJwv/j8uj7i6iQyMPkkrTk9oPK3sOsopnVwaPRkpTQkptsl8CxoLHrhHnj1Y+bgLeJsdTdrdOxmaO2sf23zamhgIWDnZKVrKfXo++Gn6y2sMCV6oyImaOHsJjMnaOu3vGUspWzoqnF94yOi4f+gvzvn5eL8Pfr4eSAmeSVrJWGhtnf98p0z8zs7YOH5ujwpq+krJzI0urngaefxqxsu3K4xtCbtefTsouhspvNpqu+lcvG6LKDvnXVf4Nzeue5nIu+gLR/oIWM6cm5Zaelx77MnHCStbKAfpCgg7qansNohNm7qKKltpXH6+PguqaAqmjaoZjJwbO5mOF/u9ils5er9fbSocDWuI2ikp7SpLzDxp/YzajGoqbJv6uUmIrz3+R9d8Zwl1hzn6mUubxvroNypaNtjrKDnamCosqW/7qWmW6WBm3HsdPj5IBWYlE5LiszPE81R1k1YFlolm1pZG9hZWZLRDpHRUQ/Rm12XUFmNUtTR0pCOUtLJlExTDEvSCYtOUQ5MitAMEBHTk0+PnBnPEM+N0EvMzdWUTBLPThIREc9PkMlR1BQKS9VTS0yNE1ETlNUOTBLQ0BEV1NXTVc3QEdAPWFqNT9AQoAgV1guQ0QxLyMqWDoxMiAtKTlQVE4tKTA+S0w6TzY1OV9IP0FEIycgHykmMl5HXFBUTzkyUjs/YbFylPG13vzYw8Cc75TJuIKJq9LUqb/P3tfg2I6xfdR9XltgaGqyuLtusGr1h5KbjqPA0fv/7tnVwtnVzc3Vz9HMzbqiipFmdICRiJFmgY/apL7O8oXzvOLVva10aVZMULCpp3Rxb652dJG+uXFxVnhYlrnDamx2yHxxcVxqomJRrWSjjG55esqHpuyOos61kKmafZOCcZOgsJigvYdng1hjf3l2dnV0c2WDPF1IUElDVUtHUU9tbGtBUHeOx4JaTk5IVkY+S0o9JYAuMlI5XkQ+bWxGRkY2YTw3P31OVDJQfbh5Y3nIkIGDifTdfO7cyeXCtbK0o7aqhGdoRk7Smb/y1L/4qMrPquudgIujoIr+q5W4jZu+8Z6eh5zL0Mno0Jg+XmpofVOucIuAYUaLaklaWUhHQ1VdKzlHRFilTXmHfoyOnXqjVyecmoCWaU4+Y0A1VnNTU1cvOkE1QT5fL45chW6EW5ePsb65p5J+jGlUZGDKzrubipOsoVyPt6+XlK71vKGSVWFaTE9Ne3hTUWWRdWJkZnpraLJiWr2tvHd0aXRSVW1Hc2RFRBlAMThFPDRigkFFODVMWlROT25iTIBUhWFOX2FRXEc7UIBZYV2DP1s3Tk1hRB1GPDg/NR49ZWAnHicwMSFAPkAzMS0tRjMdOTAyQEZgRT8xNTRAPDI7ODhSQTM/TGSZSimLumt7XMmpymBse4KT1+TYzZym7Ip6hnZ45rjMkLHUxbm9/5mL49NudHKhdY2aZUuOjo+mYz1ISUlLRz5DQz5SW4BmfVx1QmJtbnJtS4JJTDxBOT9GVU5pfo6uUVhKYV1yeoRLU0pQoU2UlGJdVJiUhn6SRHbKepCah3nt9/HUhPDLzP6HeNjn136BfJmbhICQn1FmZpOGS5tY0+Lyw7i1rZKDhYCOl1eOiH+dmqvao9yF6IqQgYPzxaGNvNOPsIqR7YDBoVGGkayq0J9lgZ2YdHKEj3meiI2wXYDDrKWmpJ9MXV5pclQ0OFNQc350ZICOmm6eXFZGL0I4O0tWQTU5ODcuPEFLWjgsNjpOVlMzQTIySURFRkRGm6KwW1ZzPmo5WYeAamtxQGRmbIdkTW1+Zn1jRUQ9JTlJRUI2TzZkal5iWoN8h30HfHx9fH19fIZ9iXwFe3t8fHuJfQd+fX18fX18i30GfH1+fn19hH6GfQF+iX0Jfn19fX5+fX1+lX0Mfn59fX5+fX1+fX1+hn0BfId9B3x9fX5+fXyEfQh+fn59fX59fIR9gnyJfYR8BHt8fHyHfQR8fXx8jX0FfH18fX2Efgd9fX1+fX18on2FfAF9hXwBe4V6DXl5eXp6enl6enp5eXqEexF6enp7e3t6e3t6e3t6fHx6e4R6CHt6e3p6e3t7jnoPe3x9fXx6ent8fHt7fHx9inwKe3t7fHx7fHx8fYl8Cn19fXx9fHx8e3uEfAF7hnwBfYZ8hXsDenp7inoCfH2EfgJ7eoV7hHyCe4V8A3t8fIR7BXp7e3t6hnkIe3p6enl6eXqEewF6hHsBfIR7HXx8fXx7ent7enp6e3t6ent8e3t6e3x9e3t8fHt7iHwCe3yHe4h6hHuIegF7iXoBe4Z8BHt7fHyJewZ6e3t6enqEe4R8BXt7fHx9hnyCe4l8AXuEfAF7inwFe3t8fHuFfAF9hXwEfXx8fId9h3yCfZZ8g3uGfAd7e3t8fHx7h3yEe4V8hn0TfH19fH19fX59fXx7e3t6e3p6e4x8hHsBfIV7Anx7h3wGe3t8e3x6hXuDeoR7B3p7enp7e3uFegh7enl6ent7eoR5AXqEeQV6enl5eYR6AXuEegt7e3t6enx6e3l5eYp6AXuGegV7e3t9fIR9hHwQe3t8e3x8e3x9fn18fHx7e418AX2HfAV9fXx8fIR9AX6IfQF8jn0Bfoh9A3x7fIR9hnwKe3t7fHx8fX1+fYV8B318fXx7fH2GfIN9hHwDfn1+hXwCAgQAgJ+FtNXKkaKupoebzdzJzNiXgNT9lpfazrfIl56ei9fBgsyN/Mmm8/+48ZzB1MaAy7+qxHC5mezf28GtnN6O0Z66w9GIg9eVvIKOl7HlqJeq6uvI4Juj2/H7iuC4poL1fYWvy7DGlKLr3vbJ5oPr2rzKs67Oh4b/goqun5y4hMTTgOvCw+CXkYzNlpXTr5Lb+oLDoLuZi4eJwKGfk8jXhfOh5snjyIS8ieL/hMWV5pHVjJSp5c+r9ryqo53W8aOyq724jc9unrCLmqKhp7O1rLC4o7zBodqEyYijnKi3qbarvZikkYifi+SEf4mHrILLlIx7hoPJd358d29tZ7xlwpV3gImZtGVpo4N5qYKlp5qHpIR0gouD49ecz59/Z6RieJaLhMuEl523q3yNgtT36OTce8Gxjd9994C23IbEme/Tfa3Z5JqwnpmapbmkoI6fnbq7m6TcxIqA37vLpYTEhZzIwKzwtbOkq9GorIeXpcCGjJWm3qXBtcP/vnbJ0tF4bcWrgGaJZWSkgcfOk4aema+pjXd9fI6KxZahj6edfbfEl4aEnquE09bKxuvqg9+M8vPjw9i/xN6wql6Zl2d3lXykf5B8yb+71KrMrHasc5y4u5nUwK2IzafbhZ3Dna6pfoJzgmi0XqCCgJWNfpfUq4W6oYuvdsrEj55zs4ahyLKL98OFgODrsoHJr8SpgnrLt66NhsTS7Hm4mbqHerHEgKfev76FqaR2oLhwjru2noKCi56YiZa8pr3Dwaqfjr94jYmNe3vknYLg17Bzn7rTnp+PnZ2Z9eeOzo7Uz9fX+4OOmMvNn8WlgnvWwYvXh5eajczmqpSFweHKeIl/2cnhg4rIw5KXgIGtcoDj4ZV7rpChnrPJoobdiInvs9OClIXIeHKB8teUqYO4haN2xJ7JlLyvc3LRwYFsgHlptNG3nKm+ioGpeHuuw7GCYoefva2XlYXJgo53YWeMoZKirZ7klKz54+3PnIyL8qbe67XDv82dm8nTnMW07beqhK29zcOoltbihJWNgOXhuMOwi5+jdoiS1oib18ico7HPq6jBqdOQkK6Dh3DEgW7BsG7ZetTHqZN4Z5GRlq6vgGVkXWF0r2p4doOFtZafYGJepLzMc3theMtsloSp4+WDyourn46ZuXKKcIHhf5yQhXGcg86ApbRpnFppc3NptZi1ZGZfX72PysvQhMeegOLPgeXVsoqQ8ruGjqef3tTK64yxyuDYgImC9bOTfJ1y0Z7XnZ2pz5qCsLiSwMR/pMO+yq+bo6DEp6jEtr6fw23DjrCQc7y7u5Ganm96bn7a9L7egq+8iLbSopaMrfGnwtrm7oeqwsyNl4KVnffIlaexzo3JjqfquPmN1KvKgLChgIyAqdbEnpulpXqIsdG/vKp/cozBeoO/rqDGqa2sn+XKgLdtz8Gd8Niu8pa83deL4tHL8YnHlNO/8MKXfKFonmp2cY5VWp5vj1pkfaG5g3qTzsmxtHR3qsLUce2+nY39hIGbs5ukiI2+rcasvWe5qJOagHOWXVeiUlCKkoePXrCpgL6pnapzX12MZGaYeGGPrV+NfJ9qVVlfjXh+c5CHTpBYkIaai2Z/ZqapUJRpmXCfaHd+no1rro6Wl5PU7qy+vM/Km9d3oryVpLGzucXLwcLJss3NrOSDwHeZk6K2p7CjtJmjj4OVetyTkZyar3LCpaCMm5Pgho+QiXx8dNh05rCKgJOpzHJ0zKeUwZS7wLCevZeInLek/9yo77SVhd6MnbCikOaNqs3UyZKmmuP47ePogdnLl+SAxHzE4oTFnfXhhbnf4Zuyn5uaqrium5SWlr/PlpbEq29apJS9f22hd3yRw7XnrLrBw9jArIKewt2XoK236qXAtLL3xoHs+f+TjO3QgIOzhYDTmvb3tKqzxc7NtIybi5+q2sDEt77dnMfbnYibwcKH0dC/utbTcsOG89/On56Qmra/yHO3snqFoYu/kqOK3c/C2LfgwozPhK7Nzqnm1MKX5rz4krXawOTPjY+AnonygbSencG6na7lvJzSrZ23kfDju7iP3Y+v9NuK+MyLgPT6w4fTsMyukIvSwr+akdbe+oLSsd+XjLzMjrjhwcCCqqWArNqGncG+oYaGj6GZipe7obO8wK6nltKFnZmYhYT7qZP+8sOBss3fpaqZppeQ5p+N2Zfg0bO+/3+LkL++p82siorv1Jrkm62ilbnZqJKEl8jVhJiJ7MruiJDWwZyegJbJgYvy8pyDvJO0u8jXs5fbkIz0xPKLpZfhh4SV+umhvpa+jLKA47bgpMa7gIDt2pCBlouAze7hwcval4fPj43X67iQbYygybOdopfKjZeQgouuyLTK79TxhpfSydC7hnt73ZzC1p+7s7+Ukcrdp+anzN+xgqi/ysOqmOXzjZ2PgPH5ztHApLnDinmp/5+t7MqfxsXjyL7IteCcnbWSlYDXkYPq44z/kPnyt6iXhcS5wN7booaNhIqZxHWEiZGb3LnAgIeB4vXtm62Dp/OOwLbT+teJ2KyhhoWTynmQgY/sipiYqYXSnvyh1/OGwG50fXx0z6nRdXhxcN6m4+Pii8eWgMWhYr6+mH2I0pNwcoqHu66rwm+QqrSzam5r4qCPhMCG8KjcpKmh1KGHptey29qIrces3dKpxMHZy8Lm3N/C1IDqnbifgdjZ2bGsqoiJgZH58MDuf7DIhbbCgG1ljcuErMS8xHuirJlve2BsesOUXYWkwnW6kbHlpdOGuKnTaJOSgEgyPD48MDxESElTdnuDiXVjY16CWl2QeGxqWFdRRHh+YY5GZD0vSHpBTzc6Oz8gQU1CSDRKLz1LR01QO0Q0YkNJQls0PHBGTDIuNDliQT44PD8yOB8dREVEJ0c9OC5aNDE2PjpHPkZFSUc9TTFUSkpZWEZGMzNlMSYuJictIiI6gDcmMkgoMCIzKjA5MykxOh87JzMxMCYmQkAtNEdXL15EWFNTUTcyHz88JUM2RjxrTDc0XkBDgnWOlpDS/LrY3/jxu/qMudCludHX5PH05unx0PLqu+6GwGaOkpazo56Smpefg3mLZ8+qsL28yW/HxcWrvK3+nquvqJSUifWH0oRfgJm+8oOF1oyN1q7b5s6+4q+af2Jcn6Nnr3ZtV5BbdKN2YaJ5foSKfFdpYJmzmJ6sYY2EbJVWkVl3mGSgdcXPntvm3KKmlIZ9kpNzeG5rb4SSeo65kVlGfnmeaVqIW2d1hmp5WllHTVZLU0ZSVmc9OkJRiXmYhnmLUyxXXG41OGBBgDBFLzVjO2xzPzw+Q01PQjk3OkFGVUZLUk1LYLCxlXllcZSBzcy2ssrGaLaF79GocWdmeZXc943g3Zqgt6blqcGa8tO8zMH72p7ik8bd3a3dxrOb5rutiVyfYWuUh4RfQUZ9RWpbWVFKW1+EbWRzZ1KKSYddUG9efnCAZHBYx66CgK6KfUpvc2tcTC9bJzIzQWNFcEtnXH9PS4mNXXvNt7Zro5x8kV0tZMnCqYiJlaGajZi7n6y2uKmspbNSWVpSS02UV1SUjHlBanOFTlVxeGhpsHVcckaGf3R0jkJIT2BLMEdEODdkU0xtQFVQQ0hhT1NQeYqZMD0+X4V/O0VwVkZNgEFqT2GRZz1Oj2pAOzU0PTE8ICdEN04mKSRDNyYpiV4xKSwsHTojNCc6N2o3PT97YjYrLS8xV1NmUmBXRExXLTxXk5B0gpqie4mJaYHMmaeWV3KumX6FrJvNd4aytLipdG5wzJSqnmGKhKOOjdHSdp58lqdgKVJWUk9MOHJrP0lWgJiWdWtwaXRoV01Cg0hISFVOXmh3XG+QbZlRTmJSWUWHTkyTi1KmT5qcbFtWTXt7g4N4fHl7cXaM5omaoqWr2MPFen923e/ph5p4gepzgnyMonpXnolyZ3qH5YecoV/Cj5mhlIygfO+QprBYqIWJko+M+tD5j5SNhv6w++vnkb2OgKuBT5qdgm14uX5lZ3h5o5yTql6El6OjYWVj65qDWUk5X1h0Q0BPVEg5aVVATFRHUFluSjI1Qj1YPDk+P0w5QypNRUM7LkI8OjxNRigoKTRyiW11SHdtQFV/Wk8/VZBWamVdckRdZXxpTUlJXIxtSFxhWjFKNUJVRVItRzhNOERLAXyHfQN8fX2EfId9iHwIe3t7enx8fX2EfIR9B359fHx8fXyFfRZ8fX19fH19fXx+fn19fX5+fXx8fX18hH0Mfn59fX1+fX19fn1+jH0Bfod9BX5+fX5+hH0Bfox9DXx9fXx8fX19fH1+fn6GfQN+fX6HfYR8BH19fXyGfYd8hn0EfH18fI59BHx9fX6NfQF+hn0BfoZ9AXyHfQJ8fYZ8Bn19fHx8e4h8C3t6enl5enl6enp5hXoBeYV6g3uFehR7enp7ent8e3p6e3p6ent8e3p6e5B6DXt8fn18enp7e3t6enuMfAF7hHwPe3t8fH18fH18fHx9fXx8hH0EfHx7e5N8hHsEfHx7e4Z6EHt6e3p6e3x9fn59enp8e3uEfIR7hHqEe4Z6iHkLenl6enl5eXp7e3qNexl8fHt6e3t6enp7fHp6e3p6e3p7fHx6ent7iXyIew56e3t6enp7enp7e3t8e5J6AXuGfAx7fHx7e3t8e3t7fHyEewp6ent7fHt7fHx7hXwBfYR8BHt8fHuJfAF7hXwGe3t7fHx7hHwFe3x8e3uLfAx9fXx8fH19fXx8fX2GfAN9fH2IfAF7hnyGew18fXt8fHt7fHx8e3t7i3yFewF8hn4Gf39/fn5+hX0Lfn59fHt6e3t6e32GfAV7e3x8fIl7A3x8e4V8h3sBeoZ7Cnp7e3p6e3p7enqEe4x6Dnt7e3p6eXl5enp6eXl5inoNe3t6ent7enp5enp6e4h6Dnl6enp7ent7fH19fHx8hH0LfHx7e3t8fH19fn6PfAF9hHwMfX19e3x8fX19fHx8nH0Bfol9gnyEfQt7fHt7fHt7fXx8e4R8AX2EfBB9fHx9fHx9fXx8fH18fH1+hHyFfQR8fX18AgIEAIDDrczB2ZPU1YSL/O+9zaKA0MGOtvqIldCw3KCRy8zI27zBk9C0n4bs/67F4tjp24a0stzO0oGqrJHW4baYz8DGpJKkooPwjPedvoHgs7jC6fnap9e4v87PvdevuMqGgarZ4uy71eLRmIGDhtjwwdu2xO6g7832yfO90ZG21PTOzoDb27LVr46YsYyUqqaRjKGrs6j6vev2iMGTj4XDsYnyhqS2uPiUzvfknaScyabQhI/u29uC7+Xk372ovOiJ166tpXx5qMSCqHfbtrq+uLpnaGpsbceSkauYoqGRva2eq66Ppq3qtrnPma51YLhqamtoY2xsb3FrZbGhem1wbHOLc4CQlrRvgIZytoCXtW+VkYOAc3qBb/O0qdakkXGktYGPfoqifNGanZu7e5TS4sD12/XK3dyggOG4pJSA1dCNfZOWx7aos5aPramlzpexr7SosJmT4aWBydKk+L7Qy8jhkP2YtLnL0IN+p4Lrcah9h6ypkbiy2/z9wKmHnrTFerRnsYB2gGSmpazBb7q6oZOkn9Z9dmq1rJF6esGWs7KquM+xs7eGje2Jg4KZrLmzzKm4kvaxntyBhGeah3dshXqtkYh9bZKQqc3Z2pG1kpODoKKOeYGM0qV9jHeDn7GEf9x4j4uBg3V5ZM2Bc3e5uV+8Y3eM7ZiPmW3AqXeupKF64fuohYCdtaWSxMqOvZzfhsi1e9mvtXS2idaBinjxyXqjosLZsbjn196xdc6Hq42OjImYmYuktLvoy7WYlI6eiKOkj+HMzM58gZuDdM/Z8aihxaGY+J6lytjZypfEnKXV8qKvxdvPmZ7H1IzUsqzOgM+G7ql7rL/yf9x9wr65roTd1n5/nIB6muzmh5CSj56XlZLVmoGKwoOBurnO7oXnhoPQjaulwH6tpd2yj7GTwn1yloTbzZ2Gh3zIf3fSdOW8tNG/jXexh3R5lnWDXnarpY+DkpGQmca0q5ep+ZOgjeLH3ryPnYPOyZWBh77+1qyG26Hcx7jnz4Sxr4mstpCQj+34heaN7IB3znp5lZKZur3CoG58vriG5aKSzfSz2ofbvOeTc3XQh7SFy4ZscoBzjamOemxfisKHqYJ+gm+7jHWqZZdyycKxsLytq7FthWpmgnewnYh1jJWdwOyAqra55XFtaI+Ggo3jroZsZnxmh4RyYex9qMdsu52rkKhkXKWcno2rcn62vYCW1ICKsv/7g4SfvLmBorHNx+HB5oCe3suV6JbjzYig1NCHpvqmqbSSseSziJBv0LO9tKF2fKKxrnCp1bSbnY+lg4VxfX+ZucGCscLD18DIs9HDgaHTmYW5u/n7y8nRtZ6HvvHOkrKw3uT7sffxm8LxguqMru2Cq83dq4aD6s689IDCtbO+u5fYuGhmxbSamYNknp5zn/iUlrOYuZOSxcvW3auzgry9rJPp5Za01cvd1ZK/z+X02X21sZbDuZ2MfomOeVt0aU+mY8+KuGSTcJWossGnkKSQoKG2vs23t9dyfL3Dst2iqbWndWtoZLamjqqDfphmoIGfg6OGnm6SsqeLnYCml4aacmBsfFdjgGprXGJygXnGkJ2nWYluamOMglaZT158g6VpfreaUnVmi2x/ZXPOsq5hrqWvw62Wve2L0bW5s4KAqtiOsXjexMrOxclucXNxctidf5t3foVylYl6hYR5bYrHmI6gh7aHcNRzd3p0bXp7fXx3b8Kzhnl/doWkgoCmrsV/o6SB5JSs0oCrp5WSiJedkP/AseO3qoG7/LKooZitiPbd6sTkiKzo5cP24v3T4uqkeM68q5R/3dqciKGf16untJuPrKWZz46wpamltKCI0pJqjqCD5qy2yMa5fdmSusbu8JiTp3jqisiYn9PAn6qszPn4ubudvNf3leiA44CWooba7OPzjvPrxrvDvv2ZjoPQvK2Nl/6m2t/a6PXG3+WWmtp+en6YrLutwqC0esaLgLptl3e8qZV+mIO5oqSSeJiNpsjc3JfDpKiTs7Wcho6d87iOnISQuciejPODq7usnJCTgfmlm5Lv64bzhZGe5LSpqpn3w53HusCK0f6ui4ClxKmSutWOz6P3nOTOg+TAxIW4l/6XqobtzIOzuMrgrr3y3uW6hOGPr4+TkYibnoymsbbiybGZmpWombS2nvXh5ueLkK+Vhuny/rGkzqmg5nia097e0ISifYmpyIObttnbpaja6KHwwcvlic+I7K6Bs53ri/iJ19XJtIvq8IuTsYCGpvb9kZShna+poqHsn5WOyJqRy9nf8432jojlmLOq1oWvnui0mMel1I2BmZb24a+NmIzum4Xugfvc1/TevY3cmISMqoaSaYCosJeipZybpODe4bSs9rCug7OYvKmDjG+5ypx9fangvZqA1ZXZys/385TrvIitsY+Qjvz9h/WT/ICE8IeClqDB1NPMuYeR1dGH+rij3v2215fu1f+fgIHqjsWV8Y6DiZqJp8utnI2CvP670KGemY3jooPAdLGH/eXP0fnn5emLn4mEt57QzLuvt7Gf1O6amIqp5oB6dqqXh6bLs4x3cpeFtqadgeidtNJ2yLbJq8Vzar6ws6HBfoaupoB3nGNxkNDLa2yCoaFrgpKrp7qjvWmEv6x9w4/IzJal7duJmvS3lr+gsvvUq6eG3qSzxcSLkMXcsofN/dC1xqy3qaKKm5m7ysqgx9DW4dDjtsuyi4njlnSyq6CrvLq3npOBqeXRkJSNqZ26fbK1eXazbuFvh+6Opcbgt5F4+r2o3YBpRz01REKDdEM5cH1ya2VGb3NcX4hQUHt0gF1Vh36Bjo2RSEguKiRWbUdTRj1HSzVXTGRbRDBAR0BvYT5IOlJXRC1JRDFzP2cyMzFMOTc8VExHKTgwS1JFQD8xOkorLk9JPkdLWlhiNyYsNUZMR0dHQ19EYz5VS0owMCQnM0Q9IoAtLiw/KCwhKh8rPSIhMy8tMzJMLjE3LEIoJCtFQTJQMERQRmI4N0gwITI0PThdPUFzW1gyZn2Vvq+Tz/WV4sza1ZaVvfSq0oP45vP36/GEiIWChP+6eqBta25Vb2ZdZmBhUG6afGVubLOfhPyDjpKHgI2Tk46Lgd7QloOIgW5iTYCTn8+DlZdjwYe9u4LJyJyYk3dcSKNlcnRdY06Ar3NpY2N5ZaeNkX+OVmmWoYy7obSbqp9nY7F9a2lit6ZqXIWlv6Wom4J5l4V6nHGJgYp9lpd9w3pYb35jrXSXcm6DYalUXFpaaD0wU0FkMEpARkhOSHOIh5mrelE5SFBdMVc2S4BEPjJcXlRnNE1XRDxCSVs4MS5fXkE0N1k4TVRcb7KJZWpScMVycHmWsMGxvZGrZJdraKBbqZDr2sGeuZnMvMyxhJiFocTg25y4pLamv8SvlJic7bmMk4aFXJdUi/t7U0FBQk9WP5hmXF+HeD17Sldln1RLVkODhUt9dWZRjMeUd4CCgpSBo0A2VDtQOl9AH1hKS0aBSqBNY1a3r1h/Yr7KorrbydJXS6Jlt5WSko2ZopGqrbDYv6abn6GbZmxsXY13eH9CSFNLRX+JmlJFfXJspVJWeXx4fm5oVGV5ckUeID9nOkBpaj5uaHVyN1M/dVlEgYTATYk7ZVhZTkZoZDwzNoA9g+B0RD5wWkI8LjFfLDg9RSAoVDE9UyVOSjNLOTcbLhYeHy0iJTIwLy4pNT5oem0/LDZsNC9NLp5pXXRdWClILztsiKq1gYt/cE1RZKSclqSkoYB4xXuLdJFvnpt8fV6s1Kx7eI/KrIl214ra0Ofak2CRZktQX1NYSGt8PnVKg4A6bzxGVGJjeHJpQUMzRklFgGBYaoNwj2CSeZ9bTk+LW2ZQjFdGUFFMVWdiY09JlKV9bYqXpIjsw5zljc6R8ejd6vnUz9mLn31xl4rPh4WAg4JllquAbVeJ6I2KkKRac7e7vqONhMiXn4ySZOKgwvGJ4t321/WLgujW2MfkjI+on4Ble1Fde7y+YmZ2jIxkdYOblqWSo116pZ5rsJW4pldRbWdWXXs/Sz03RVE8Qi4qd2ZGPTMlLTg/RS07Pj48Qzk3KiorNTc8PT00SU1QT0xXU4KHXFdlVEN1hmFmXn1/eVw6WnBMUWt2mHGCU4KHU1uCQmUnPUgoQEVANCcrTWaKmAJ7fIR9BHx8fn6FfQF+hH0DfH19hXyGe4V9A3x7fIZ9hXyEfYR8C319fHx9fH1+fX58jX0BfId9BH5+fXyGfYR+h30Bfod9AX6PfQF8h30FfH19fX6GfQR+fX5+hX2CfIh9BHx8fH2IfId9BXx8fX1+hn2FfoR9jH4JfX1+fn59fX18i32JfIN7hHyEe4Z8BHt6enmGeoJ5hnoBeYR6gnuKeg97e3p6ent6enp7e3t6enuQeg17fH19fHp6ent7e3x7hXwGfX18fXx9hnyFe4Z8C318fXx9fX18fHx7i3wBe4R8AXuFfAd7e3x8fHt6insJfX1+fn1+fHp7hXyFe4Z6AXuFeot5Bnp5enl4eYd7DHp7e3t6ent6e3t7fIR7Bnp6e3p7e4R6D3t7e3x8eXt8e3x7fHt8fYR8A3t7eoR7BHp7e3uHegR7e3p7kXoBe4R8hHuFfAl7e3t8fHt7e3qLewR8fX19hXwCe3yEewN8fH2EfAx7fHx7fHt7e3x8e3uFfIJ7iHwBe4R8gn2EfAF9hHwKfX19fH19fXx9fYd8gnuEfAV7fHx7fIZ7Anx7jXyIewZ6e3x+fX2EfgR/fn19h34KfX59fXx7ent6e4Z8C3t7fHt8e3x7fHx8hHuHfIh7C3p6ent7e3p7e3t6i3uIegd5ent7fHt6iHmMegh7enp6e3x6eYR6gnuGegF5hXoFeXp7fH2FfIJ9hXyEfQd+fn59fHt7jXwFfXx8fH2EfIJ9hXyKfQF8mn2HfAp7fXx8fH1+fXx9hnwBfYV8D317fHx9fHx8fXx9fX59fId9BHx8e3sCAgQAgOmBuYfe+PmPrLSUt+nM1Ienl9l9iau/8J6UlISWvZiU14J8uOHdkLSPrIOIsKa2xuPFidyP46aip/ahksKTn4/5gZ2iqc25st2yzuCJjp74zc2rlajumozfza263by8l5PVuMauqsGN6fmPhN6J7r245uzwy9K6rLCG79PW0LDOgPG/5OKhp8qXxIDcl5KG5sKu5L3v6oywyoyJjP6bw7KDic/H67WcgsvGkLPO+OK4zYaarrzGjtKs9oXVzpSKgohzdtfP0sPRiae6s7pxd3V5n7junKLpns6akfCWisXG4pSrqP3B9YGD6ZqLkpK2xb6kr5uRkXjQu2nJupve8aqDgF1bmKWqsoeTnZt6fHaQioGmvJWwgYryhLKBmpaVs5acp4C8rmGpjZGT0ry3vdGJ1MWkn6bm0qrHvLDxfqiZmKWUmYCalISBp5e9vaWVr8C9uZL7leKF6pmdoHOJipSttobrpKqAhZSGuG+Je5qKudN4f86+qtqr0nqUpM2IaWuNgHR2hp2drIOmu62WeqKhho2SiMR5ecnVeHuUnoyNdX2hmHba4+B3eHuJkoRyo4TtttfEp62xjX+UdJ6LsI6Oa4BtssNsb6aie8Kij6mahol8em6Cc3h3cXOAgnl/tXjJkJ6DnryHuWihpZmovs2o0Hytm3erz3SWy3+6hdWWvJrqgM+AibfWcHLLlqtzwaqXdHmVsMansHfch5Lgg5DkseLWmXy7m5uNkMCli4WJlJCMm6ut38SYnYqBfL+IjYC+nYCku5KIgKKFdqDhvYusoKbIlpyB99ithYTRy4CIg/CQ0rSVf4HZg5SSnaiFtqHO+dnNvJ6Hvrnj3aGRkX2JsdPKgOB+fN6DlIvSfH+Gn9Hh3ZKp28zaourxuLa/zteivdu9hrb0kZO9k5KflpGVh3HX2Yh8tbSl5OSYg3mmgm/GpaecdsLgi8i108+9gH7FdHjKhJ9+mtGajP2/kJ3kxIPqsIC82qeC+e2l2ODti4+Bx+WemJm8msTb3aTa4Ku/w8TTgLeCxcLQoJvKrMWllaybcHeLppvV16LTqMnMd53bqqfGgodyiI+VknqPiXN5cIHOdWSRdnF8cm+/mKvEkbZYXXNjkWxmeIGCn5iSjcGQjnmolMG3+3em4pC5gKZhwLZ9j93tom6JZIKIdntsmtqFbbKbl4KEg4rG6eXP18K/h5fqgIeBu9fEraiSmq+/kv/Jk//m1eSA/4T5/ZD1wcPI9O31gbv6i8nNkJeduaOAc+HTv7O7gbaqfpqynp20qnqSdpeqeqm7wryHjsG/sr3Gt8eLnMjW5tS2j7/twYHu+rnmh6WJzp3Aks2hvaXux8Pi0JvnwaeklrGWqI2o5rmv7d/tgNiDyZLv5M+Lmn1qgrSeqGKJl8WFkLfJ7o50hXWOv6CgwXeGwdbFmK6AoIGIuLPAnMTUlfSS156Zm+mjmbaAb12oZntwfIpmcaGFo7pfYm7Lr4p7coXOdGS9ura+1rixgm+YlaCPmad2zMBrZa5ksoNvppeahJWHgH5tq66tm3+fgKaZrK54fpZdcV2QX2JhlHl/kIaogVFjjF9pY5Fvi31NU4GHi2dbUHZqZHictqyJknmMn6WmYYJxwnXAwYeAh5V7d9jb0b7Sj6/Bvr5zd3V4kaHikprXl7V5bq9ya6KpvXWCgdLF63d35rOnr67R29K7xrSpoILu2HXn58j2+MGbgIiExe/m4rW+u6yRkIennI3A5bXFhJv6jbmSt6qx7LO1wpDt14LcsqSc9Mu4wNSJ1MastrHe0qrCs7PzhLWpo6uSlH6ZjHKAr5W6taeVpL27vI/xg8hp4YqsuIOSjoijwonwssiYobWVw4Gdk7WZyfmHh9bGw/7J4oSituCfjIuwgJeUh+bl6qm93+bDm8jJp6m5k9qMjen3j4CsxLKmkZe7qJ3l6Ot9gImZpZF5pX/Rl6ybm8jWqJq5jL2fxKCddZOAzNx2ebWyiNi4pLymlZqNiXmOfYSCe32KjYSLzIPqub+g2/vL/ZTm5trd+OnP75SppJO6+Ia09JTSj9uVx6v0gOWVkrnZgYLat8eA372jioahusaxwY7/mJr2jaD4tuzjqYPBm5yPk8WlkIqLlZSRoair372QmYaCf8qUnpDUspfA1KmZjbWYi7rvxZO3qqi7eKOC68qUb37axHN5deGIy7qVj43+lKGiqr2Ktqrc/+zRkYSQ1svv8Z6WmI2awOjggO+HhfCHnJDdi5GVpunz9Zux8d70s/Piw7zD3uKjwOfQg7b9l5fLpKmsn5uinYDy8ZaR1si39/KqlIy9kYPxxMSohuPdf66ivrrBkJLhh4bmlayPs9KOhOGne4rFrnPOnni6x5Vu19Gb2+Tpg4N4xOKspKKZkrzH4azi4cTO3tvngM2M19LiurbZydu4o7e3hJKmwLLj4KjRrtvng6j90tHxlZ+JnaeytJiyqpilnKP+lIHFnIebjY/bqcLtvv+Egot7sYV7mK2t0dHb0PHEuqjPsdTK+Iassm+5ga1z48qCqdTypHWxiby2maGIpeGMcryztJ6fmZrG49zIyqqnc3u/gGlkl6uuh4d2fZObdc+tecrCtbpi0m/GzXjIq6mr7fPzg6POjNa7mq6427yXgeLMrLOzksLLj7LLnLzWyYyblrPGmc3e8OyeiuzevMzYwtiLl7bFzracgqmaflvR3K3YgaFywpW8f7KAkXSpjpa2nXmztqKViJ2bqHyb7r+w6cragJBARDZZgpZ/f0NBT35uekNrVV8zN0VbjHBJX1hoc1hFXjgyPz1CNEVdVicmMDI4Q3ZlOGhSdE1LR1s0MEdPPzBaRVBGTl41RGtVWmM5MjBMRUw5OjNqOTRSQTc/TEhSPTRCOU0sKkIqSUY0ME0zS0o2V1pdUlI4KSUqVi8jOy0sgC4wKCkkJjksPhpDMywqSj0vPDk4QCQ8OR4eLGMuKjooNE1CSzAdITgtJik7blhBVEFXY2pxQlNQq264uIGClq+Ph+T47tPvr9To5uGEhoOIlJz0pZzUnrhtX4hWVYmZq2FiY7XW+3179NfM1tPy//vi3sW/rX/u9IXvypLX7b90gFdWjpyVmnWAtrV0V5HIpYCxum94Rj98PmJZfXx7m2thgVaNiFCIc290pZKFkqZtnZRxZ2vKn3aPiYK2YYB1coJ5jH+FbVt+p5Gnmop2jJ6Zk3nicaJSfFBTRDw+O05XVTtwS005NjY2Uzc+OVBJWXJsTIloWl1mbD5NWF85KTI/gD01PFtdRUBFS0lDPERROjhDOlkyOXKBOjNASUJJSEdLSUa94OiAiZert56Dqny8fIp3kOj9y8LtsOzA6sC3g66R2/eEicjQqO3Ft9S5m5uUmYeWipWQhYOIioOElYGXQUdOcIhjaDtxbH9siaB9jlZ2ZUx0llJiZVV3bcdVXnPagHk1WJKQITNwTVhIZy0vNy9NVV5JX1GIMlWJWly8uMzXmH25mpuSlMinlY6RmJuUpKeq3buNloaJi8hlXVtvXUxpckpFR1NDQXGIWEh0a2p9T0s9g4V7WUt1aDY4GCofODM4KjuGTTo3PysyNlOAjWJifVFHdHqSdlVBQUBKinYzgIJNOWs3W1d0Ozk2P2p4eUxGSEhjNkBNQ1lRUU8yPy0wJR4xIypELDY1PD49NDVshC8sY32BYmNfLy1ZTDFJQVk+U4a7bZqTr527XEGNQlOPWHtnd5t0dMOUbXmyo2u7jXTBvoZfvr2a6ezsfnp2zN+hdXNrSlZmn3N2a2hlfnV2gGtEcHdla2t6Wj8+QEI/NDg7QEh7aF+DbJiSVV6ahWiVVlpMV1dYYFRjWFRbXFjFfWmomImilIj6xOb5tNxrc5OCxJCRqZ2oyrukmvGPiICTg5aOs3eSdkSLXaGKq5FThMn2v43CfpKGf3tpqPubgd3b4cfJvrHO4NfFyZ2cZ2uogFhQf4uXdHRqbX1/abeVbq2onaVYu2Kxu2qyp6eesZuGQFdnPVRLJzc4TzowLFmFb005MktENz49OTc1PzE5Ljg2LEpQWE8sL05TVFNWU1tLY3J3kXZaT2NdSDyVoX91MzZAVURYWKhkZEx7XW56j2t5Vj0yKjRCPC41STxDg5u4BHp8fH2FfAd9fn59fX1+h30LfHx9fHx7e3t8fHyFfQV8fH1+foR9Bnx8fXx8e4R8Bn19fH19fYV8A31+foR9g36FfQR8e31+j30Hfn19fn59fpx9AXyKfYJ+iH2CfoZ9A3x8fYR8gn2FfAR9fX18iX2FfIV9hn4WfX18fH19fn59fn59fX1+fn59fX1+fo59A3x8fYl8inuEfAp7enp6e3t6e3p6hHkHenp5enp6e4l6AXuFegF7hnoBe4Z6BXt7e3x7jHoFe3t9fH2JfAN7fHyEfQR8fX19hHwIfXx7e3x8fHuEfId9j3wFe3x8e3uLfIN7iHwOfX1+fn59fHx6ent8fHyGewR6ent7hnqUeYN7hHoBe4h6Bnt8fHt7eoV7Enx7e3x8ent8fHx6fHx8e3t8e4Z8Cnt8fHx7fHx8e3uEeoJ7mHqGfIJ7hnwEe3t8fIV7gnyEewh8e3t8fH18fYV8AXuJfIR7gnyEe4V8C3t7fHt8fHt8fHx7hHyDe4R8AXuIfAl9fHx8fX18fX2JfBZ7fHx8e3x8e3t8fHx7fHx7e3t8fHt8hX0PfHx8e3x8e3x8fHt7fH19hn4VfX5+fX1+f35+fn19fX5+fn19fHt7hHyKewF8h3uKfIV7BHp6e3uEeo57A3p7e4d6BXt7enp5mXoEe3x6e4R6AXuNegN5fX2MfAl9fX5+fX5+fX2IfAF7hnwGfXx9fHx9h3wDfXx8in2CfIR9gnyNfYR8gn2MfBZ9fX18fHx9e3t8fH19fXx8fH18fHx9h3yHfQh+fXx8fHt6egICBACA1c2Ckufquq+54ozQm4Dij8h9rKOnk3us3KGIsOXbgZfXr5/UlMq0hJaF4Ne3rJGq69O2hdzo/JCE+tO8yozBnOPUmOKdy++Gg4SIzK2Gh5iIt+i+45Xjmbji7sq75ofM6f/NpMzGw6Doru7+y7zCvre52OHblMia7NODleKsyauAssfYxKij/YbLtO7NmZ+7s+b725z014S89ovHhu3FtpqC6oaV8aS18tm7scq2jpqe9P+ThYaYtoKIl6a3oPus3uPG5vS5v9TTcIacpLHJ2vuS/d3D++qG2paFpbDbwZynu+TOnqCqpKyopaKsuMHFxcKow6C60/nmnpRkon6D/oGAkoxpVlmfhIR3xruDbHS8wI62q7Xfj4ijrbR4wpmjlZxzkqeunLC9tHuyptZzdt+8rqHD5Yi7xsCgp8LDo2twhJek1JnBx7iYlY6bk4apmbW1mcqE3/yevYmImH3Un3uApfaYrXGwjIjYi42AzLzV033NyLFygabWjbHLZW6z1G+AZ4bMomCpl3uGqoecvJ/B0M26b3Rqi3yH4Zt3kbe5dp6Qo52coqiil6SBm82apsrNkPppmpGDX2OEhWqhiIeIkn18wXB6bGdlcM2spZyNn4yAenmCgn+EgoKA54R7uo+3emJ7oF5nmXqMq6yhq6+8fHvPjoV/lLN7ocTs2KyLguyA6di15rV9jNOxtXzikJHRtpbEi4KO3XyT3tmFdKDIxIu/ybe2h4KUua2DipiKjYuWq7+3oJ2ZmIfqeoOOi8mIkpKnfouEpbWTxY6wjoOVoq6xgtHgmJy/+8vir5OTveGjgdm0hXvb0HGCfOTtrrqHm6ij+ay3vHzlt3uNwX+5z4OAxseztt2Kj5/Z43SF3r+TjuPhxaqEt4bu2ae0jMby8belnpuPz47Jg7S6gKyVuHyjv93Mq+yK4Ll/tY6ukqWAqtPekXqCu7vGzJ1vd4XBeNLf/pV9qYCYyrDJpcq8qYGOzoWX5cq78ohahapx5bqzsqvli+TQj4GwxIuTj6DDs5aAe3ehjoB8jd+mnNGGsnzXjKzOwrWmqbqygruDeHOpyG59bGJ4a3SHjH1xYFp+jMdve7NtYWu4vGJiXGizn46CpmJsf2GtiH6OlYx7fGt0YnF1l7aluMCylrqLp4R6erOlu+Spb5SAeWx2t4WR8X62o4F8ho2Ek7XyiZ7DvsXY7bOA5YOJ6L/h2+vX5tnB4OSkyoqWpob92cPziqS80duH9ZW1xaOvrpzEeXKEfcnAu/q4kp6U5fCxr8W7hY2VcINwZ4Xhjox+scuLzcLDi73OpKKyzsrjzafns8aHyNG6mdCYwYzsjZqQvfS6h52WiYSJ9qH8k63DxZWam8KY/dzSgqCAx8iKmPDAlqKy1oCfbGCnY52Br6ayp4SQvYp/pPD1kKbUn6HUnMiYbpyA4sqvqqGdur+zgMW0yHJu5a+8t2yKgrq3d6Rjg5lgXV9goIpQY3NigLGXuXObgKzAytizt1SItqOUir2enXm1iqani5WFfnqCppqSZZVomoNba6eXjJqAko2Oi3t3plh4gsKWbGx8fpidlVx5mFhwsGiGUIuMfF9SkktPimBofo1zbqCDcnV1usR0Z2ZsgVdUX2p2asCP1OG53uKos8rUdZCqtLzDydp3166T7uiBzYlqeZO0o4mTpMfHtrm/tcC8vre+x83P0syTppCfrsS9jaiEyYt07IyAw6aUhYrkrKqZ4daTfILO1p/dv8n2l5mgpb6G4rLIu66Owenp1PnRt4G2r+WCg+rdr6LN5H7ZvLGUqMrRtICEjqWszJm8xL2ilIunqpGtl7a4mr1y3vun1aWisYbQqIqXr/az0IXMqp//q6mf77/g9I/x7dWFosz8msfwgJPm8ouAiJHR3oPew56txsC+7snb+fXWh5eKoYic+b2MrdDhkJWXwbelrLWxprh/j9+tss63dtp6uLCedXmbn3/Cn5qhpJGV5YCLgHlweNq4r6uWqJOIhH+MjouPi42M+ZqS05zql4nF8YyJ3rbQ6/Pu59ztpZbfp5aZstKKt9zs3ryZiPSA+fu95cyJou7M04/2oZvtvJ3PnY2a/Yqk9OmXgbLUz5XF0726iYaau6+Hj5uNk5KYqcC0nJeXm4rugIybmdmWpKS5jJ2Rucqh25O4koeZoZaYfcbFe4i6/8/ppoeNw+exivjIjYnu3YGQiNPxt8yNq6ae08La14v9yYGTzYG+45GA4t3FwfWUlK7y+4WX+92tnvLpybiRuoz43rnNntn798iioJiT5p/bicnLgrqe0Ym10P7ttv+U8tSPzrbanMiU0fv5ooKBrK2wu6iAi5vcg+Pm/qGEqnKGv5+xkbCnm3eDxnmHxrOm7JNolsZ74Kajop3VkOSoinWsw4myrrbZzLCAlIO2kYeFk/W6rdeOvYvcl73y3M24tqihjMCTiITE74qZioaTgo6psp6Sg4Gfpf6RnfeLe4Paz21waXrwycuvwHB/kHXerZ7C2MyxmZ+pkqKbs7GMsrGvj7GozKuSiePQ0eeueLKou5+izJWU6oXCupmSmKKaqrXee4yopLG9ypqAsGh4w5m4u7mvwbKsvMOLsm99h27XuKjCcIqmtbtv3qGsiIW2tKbikYOfjNvXxuG3nJif8PnLzN2bpKu3iJuLhYT1pbCTyuuO4t3RjNvUpq6s0NPZq5Dvmqt3s9a2kNKUx3/XgIh1nMZ4WnNkZV5lw37XjbGxup2vpbB+9t6+dJSAh3ZLUntza4Cok2ZrSDlrPFwxMTw6MTBThGBpcZBULzM/ODFFLDZINTA2Q0YxLDI5VWpGO3Jqb0VCYj01Tjw9R4KFSF9HSWUzPT43VD4kKToxR1M+STFQOD9MR0M+TCdHYEtAQTszRDFUMz5SSD9HTUxIT2VZPjM+PzwrMzMgKCCAIjQ9LTU3ZicuLjY/KSw7MD82Mi05MyYsSyk0LF5FNSosTDc/TCYjQ09GNDQ6Kik7b3Q5ND5PZj43QU5SSJR94fO77uKetMn0kLbZ4Ofg1dx22ZBs7/yS5pBja4iZiX6GlLvX5urp1+fp7ODo8/Tx8umLjnyToKqkg6FSpY100HaAhnR0S0h8cYJ+3s+QkIemvX2VZmyBVFVbZnJXo4B9dHVae5SZhJ2TiWWMhaFcX6aDd3R+oGNzb3Z/d398cE9NZoGhwJSlrqyHgX+CiXCEf4aIeKtiqJVOWzs5Sj14YzY0R4ZUZDpVOTlSTz81WWlpY0p2aVw8K150Q1NkLDNQUy6AMUFaUC9APDM7RjdAT0hXX2BRKTMzO0FAY1k6SXRyQ0dEZZeruszIusp+iP/JxNijX72L2M+4kZ7BxJ73xLrFxaSs/JChloyDiuvExselsaOXloyWm5mXkpSR/F4wYoZaOTRRbEA+alZseoR3hISBTkuqfG1dWmM7T4ayjmY8aeOAooCTuHxIUmdfVUueP0VuTUNTIztLhjJabIVgT222sYW6z8DBjIqewrGHjqCWmJWcp8Czl5GXmo/+fmlgYHJMY15tREZLTVdIdU9SRkNFS2hiUpGeXlZolnF/UjElNCo5MVdTMTRiKicxOXp2ZaRDQEKWj2ZgcE19ekBQfEeCeTGAc313cnlMRz5hZzQ8dV4+LnVNRz04VCdmWj9RKzA4PSgdKiU0NDQmIiVENEMZLS5uZ3J/r5FAo3A5KjxXdnNAZFRiZUhonp+hqYJXPkuBaqehvX5fhGZ0oI2ghqKblHN+xW96rqSX7KWArfCM45mamZHEcoNqYlOAjVRkbG95fGaAREVpSUVOSnpTQU09QDZEPTtBYmpYX2pnXX1IR0F0m1VWWE9OR01aWV9aSUhWUrWCjb2EkpXv5YGJgIbhyLqv4YOYsIPnpKartqOLqnqBbX13jYtll3eZZneHl4VyfZ2WvurIkcWOj36Dm4Oa6I3i38C2tcS/zsbYdX2Ul56sso2AlVVkp3OXmpiQnJOJlZ13lVhlZ1munI6hXXmiqaxhr1FYTD9HS0JALCovM0tCSmlFQzg0X2NfR0Q3LzAyKzQqJTFaOEE4R1AzU1ZUPUtRTVJjaVJkalFSN1hLiHJvUmU0QjhePVhbmZtJPVVBSkdQoFmRPjlPS0NGMDkrXGhwWHABeoR7C319fHt7fH1+fn1+hn0Ifn18fHt7e3yLfQF+hn0KfHx9fXx8fH19fIR9Bnx8e3t8fIR9BX5+fn19hH6EfQN+fXyGfQF+hX0EfH19fpJ9gn6KfQZ8fX19fHyHfR9+fX1+fXx9fX59fH1+fn1+fn19fXx8fXx8fH19fXx8hX2GfoJ9iXyIfQh+fX19fHx9fJl9iH4HfX18fX59fYV8hHsIenp7fHx7e3uKeoV5jHqCe4Z6AXyOegF7j3oDe3t8hH0KfHx7fH19fHt8fIR9BHx9fX2EfBV9fHx8fX18e3x8fH19fHx9fX18fH2JfIR7hnwGe3t8fHt7i3yCfYR8DH1+fX18fHt6e3x8fId7AXqFewF6kXkMeHp8enl6e3t6ent7iXqIewF8hXsHfHx6e3t8fIZ7Fnx7fHx7fHx7fHx8e3x8e3x7fHt6enuYegJ5e4V8g3uGfAF7hnwDe3x8iHsDfH19hHwFe3t8fHuEfIN7hHyFewp8e3t8fHt8e3t8hXuEfAh7fHx7e3x8e4V8AX2EfAF9hHyEfRl8fHx9fHx9fH18fHx7e3t8fHx7e3x8e3t8hXuDfIR9hHwDe3x7hXwDfn59iH4BfYV+hH0DfH19hH4JfXx7fHx8e3t8hnsDfHx7hHyCe4l8hHuCfIV7gnqPew16e3t6e3t6eXl7fHx7hXkEenp6e4d6AXuHegZ7ent6e3uTegJ5fYp8iX0Efn18fYt8hH2EfAd9fXx8fH18h30BfIR9hHyEfYJ8jH2GfAV9fHx8fYt8g32FfAl9fX18fX19fHuHfQN8fXyJfQV8fHt7egICBACAt6C6mL2wmoShh6i+2ZOUrOXQ4JuWe87zspfCccqix9fL1Kuuo7CU7KTM98yo68eFhrDbfMP3xLSxoa/x/pP53eypgILigNONp6PY34qovcCi1fCnuIC31oyBuIa+056B98WVvM7qjIzP+P/Chaaox9qQ5oLK7dm+lKabjam5mdWAu6DQnKTHxpHB14OC0pit2YPv0JLNhfiXpYbl8IKA4ZD//+GRgeXh1buhvva7qL+SmdPO1MjGpb2Q0aG6yrWFkcbBqr2/rq+SmbVphY6x4eG8iJ6gsXp+w85ru6DO2tiCnq24amtsbMO8s5yQjpSepKC3zKXt/uGXhKC9e3Cae4CAjrGcgpqUeH19gMKzd6mD2Mm8rtR9goSMoZWQgManc5tua3+GuJCq1rfWvsnKiNvErJDj5NC/rLWSjYl+fX+dhIWShqvynHmcpYmqm6mm74iYmNrTiXZ5kX2JwKXIuI2BrZKVc5uyeHZ1iZfCvsC1qn9uwcl8k4Z8ob+Wj4TIwq2AvIS7ome4rHVth62VnpbTs4l6hISPfIPjfXB31Xy/r3mXua63YmSwoIGTueKMjJrs+5ailmabp22dqIqJg4x9jG5uuGFkm8zCgMq9tKehrJuRipCdopd+ioV45uWmwIJysnemomumW5mMqm+fZ33IYGhv3niFbKzsmeHegXHM0ZuA1YCsi5S0ssGPdcy/qaF2i7GElL2Jj3mko790eoB+gbyukqOmgOmtvKaAk5V+kIqgoqidp7WolJLRfeV1eJaFk67QgIOJinuRo5mMgaWp4uXiubiE9X2M5bvchtr9ual9doWEgIqbhsdyi6O/f7b5jJGaoeuv3MK3oJaI/pSapHWAenTl0H2N3Hx1hnasjcOgiHqFlraIm4d9wX+mo6/agXmC3dLoxIiKsarP0vB+rXJ6p4LEj9TNwNbNoIurrNqcpnxv2ru87cqd1bG8x4jhis2h7trGs8KTb9v5wq62pp+Z6v6IprKKnJmNinBthHqpqJOU9Y/kmKH0qNCHd4K0r5iAqoqVsIu3pX2DjXuRt62oiYKgccKjlKDbfX6yh8PAlYTDX15gasRqfGpgXaNocHeCgbdfZXB5kYRfZoXOsseolnB9bIOdf3+EhIioZGdfWWZpe8KGq5vHjaqii4J6eLSkweeadImJeHJze4aSad3Bo5lmmIuFqK/K/5+i+fqG8uGAkpSE0oWOtq/G6IK3tb2v5IqDk5+uy72W8L7Ol/6G7KiglJadq3m8pZfIjZuxk6XDnpuTe7t1w7Z9tcXHrmV8eH21oZyWmILQ7KyH9Hqug5jPj/3Z4Y+z64uCgJql0I/tup+p3r3+sZbehc26hp6Xv9PJm4T63Luu8ejLuJHFrbWArJi4m72RiX6VcoGPn4JreMCwqpGjjeLJn5G2ium24OXK2LKvnqWEwZy+2caY9vGbisfyh7nFlo2ShI/FuGzZ1/KLX2KyTJB5hYugpltkbm5vxLhvwX92j210r4StdlBcwKl9ioulaWyJqLiNXoZ3fIZdmlSOk4N0ZHpsY3+ghLyAn4SohnOIn2mAmV9cgGp/mFCpglZ5VJ5gdUuZg0RhqGKbrI5WU3xucGhic5iBdotdZoiMgHqDd5FfkGd8h3VafLSumaedmaKMlbVwhZCr0MaSY3h+oHqDrtFvt5a+xuCJpcPPcnJxc9HLxKykp6u0ubTG07Pd6dF8c6bso5TJhomAsM/Sudbap7KnrOvJgreO79fLvOmNlo6SoJWinOW1hraYjbiy9KbH8L7ZyNDrkPHOrpXn38fAo66KhpqQlY+6kJKdeqbymYCorI20wre09aqomtXqmICIlJWO37LE06CMw5uui7rQkI6JnJ/07tnSwpeF+f6SqqyVuuK3s6n+/+CA9IPv4o/l0KKHpty9vcvqupCitay4gIr6oZGA8JD+3oiy5MLTcXLIrXqMpeicnarh863Ctnu5xYKywJ2fmaOQnn5+23Fyq+LTiNnKvrCotqOclZqpsKSKlZGC+Pe4zpeTypvu3Zfrgd3S5pXOhKTzgYiB+5uii770qP/YkYXi2aOA4YyuhKXCx82thdzWua+LmbeVodKZmoSposqBkoeHi8m2l6mshvSzv6iFmJeDl5Gin6qbpbmsmZjVgvKCgKSXpbvkjJSYlIWisKGWhq+x5t3FpqKJ/oWV6sDjh87vqKqHg5yVi6GvmeGJoq22iMr5mZqOnv627NnRu62L4ZWev4OAiIL444WP5YmDk4a8n+bBlYCQnL2Sn5yM3I+9uMXqiYSG7tn6ypucva7j2v6IwYOMvJjgoO/j2fvit6HT0e22vIaC+OLE5seT0sHQ4ZTVc7CZ3NK2rraZguTiq5ujlpKM2ud7lrCRvbyvqYOBlnubmoiI7I+veYHUouemlZrDxqaA0Z2vwI7Kwpmdp4msxr+snJu9jPPLnZXFjY2+keDPraP+gIWDivuCkYuFg+yPk5ijpPx9gIuQlYxrc5L/8/XEp4SVgKLWvay6wsffgJmPg5WNm8x/noDBvdHZxauLkN7W3uufe6e4qrGkpJeNg+nZuLN3opCLtLLA74qM6el718eAfX1+zG5yj4CLp1uGho6Lvm5rdX+Fn5p0vp7Cg9R3872viJCZsI3UxL3poqy8laTYsJqdkNmBy8OT1O323YCMiYuspbCrsZjg7r+S94G1iZHSjNu3vYOy7I18hKqfz4mzrp2Sl3m7knKGYox3Wm1qmKaodWO/y7qv78OvmYi0ep2Ae11jT2hiYF57TlBhXTc+RltCQi8pJmGMY1WEMlUxOj5AQjM9Sj9FZilRTGA1SVMqMkNLL1l5WUxRU0ZUZDdKO2JKMz1zMm9NTDpRXjQ2Qk0+QElMRyhWUTEsRjJQPiQrXUc5REdMKDU/UkxDNTg/QUw2UC1QQkhELzk2LiQgHiuAKx8yISw2MCImRiAlRC8wMTM6QDJCJkImNjQwRyktOiVUWEw4LD0yNzE4R2c9LzgvMT88NkFeZX1Fa0lWYVZBbqykj5yRlKKMkcOKm6zC1cyEU2hslYSVsPeAyp2/zvWStuv3hYSCgfPy6tHP09Pg5N3PlWzEzK5mWWlvVXrAdGeAb5GAbHd9b2x0fdHIiaB2r6yHfoRSUldVW1xmVoWATIViW312pGBlm4Ocm5yla6CJeGSSs4hpYWhjZE9IRkxbV1p1a6Phi3CCiHl/hn2G1HBweK6TUEVAOzE1WFyKWzA1SEdaQldZMS4uNEFGQ11gUTUrSF80Ozw2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14XLyoOYkeiEiap/z8nAm4VwfqSNkMGCrabvgLGykIKHiX6GjZyas5++xI6Sz3jk7nh7f3yzjpTldJOwkOC/3r7gq767komz37zWlLCEy8yc9If7fojPqZ2ttpyUkryE18+Sj/m1eqXymaR61sGVjcjThrx/44Ca94WVm+V/zeeCoZ/Cc5V5jNTp1PTntJjmkLKBiYXPm+fe3L/LxZ6JiqDP0pjbyMB/2c6HpbrCr6KAqYOYi6O96dF2gYCOd3CCn6J4uITN1cm2ksjRhtTIis3g1Lbaz73b46yKaXJRkX1manWffOWqrrnEkZDFvqCDsqmBlsaQiYCclo2klKGmupiQhIq2hrF2n8uQpHzV5dS/1baj7vGYmnRvYLhtbWtnerdbaoB2bG6HjHZ+o3SziaJnmd2xgH6bf2h1gXZxdoimg41ybWpxjYGTk7vRhLCWgIF+iMaLu8p+gop5dbTFnHZqiqtxqJxwaoKRh4yzttCYooe1vL+uyICs8ZB0rPLiq/fg+83LjY2lpa6D95KLpKX/tf+bq5uGjqB+vOPMq5t4b4Z35OShipDVs6uTspSHqNOyuHDNhp+xfXOJg+C2ydS/1aePgZ6Ig/Xzt7n5xMHTyLrVj9yC07e2guWSlOrll/6HuvWw65Wo2LKrzIDpmYGsyd721snZxYC/rdLOjbJwstKil7Z/dsdtbWVlqpPMj62k3+Xu55T16OXk5bWIkcKZkbOQtt2Snuep44WE29psem+OsYSRf7fJn5luvoJdW4C+pXqGiJ13QmVvZ5ykvm2dgbqjkXp7jpyQc792bFSCXpebsKB/snNweZSZq3GcmYeYb56UiLyTu4CDoJCohZStpZC/dlqPdIKPhYJVnlSYV1F/e01IWZpUUamYUFSGS1dIU1iGVYWCenCWVW5sZGFWkJ93XWlmcGxXdo5+x8LA2NvS4YaOf9LP5mljZJKDwLLBvta4itOXtMxvdHV1enx9h37d2dDFubKtoY2fhf/Tt7SKwqqil5SumIDuv97yx+yFjvzU5qKPlLq/tdupxs+Xm6u0gu7Wq8eLkoaJktzd5eOFu+DE9Y/b083mtICbtcu0w6CInrOw+qizpo2A2rPIj5m/h9WonO6Wwb6Fpq3HhNiPsPvaq9GQ9MvGsL/5iPKAif347MzL2JSi9oDc9ZqalKWGgaayhtTAv4DJ8Yj9o/mynpGek6C6+7ySgJ740p+a2IiHqvKbwqyPma7B+bLSgsrx47CmkLqX5r+zu77Q2pFsdbiin6i2nKPkwLSVlYl8zrPIvrS6u8jNsa23r6eekomikoKHrsOyqfmOvojij4CGsumLn5/l39TXs4+ngtuNs/Tm1dnWnIiyi4C93Nraqdqvk4P3/pzf2Iyso/yTmriP5czErJeAjrOaqOWYuK74h7m3kYiLi4OOkp+as57CzJGV13/v9oKFkIrDk576gZ24l/XP8tT3s8vJmo+39tLnm7uL0c2V7YbuhYrnuaOqu6ienNmS6NqOmubKgobeoKuH6uKyp+DbkMmM84Ck+Yqcn/OH3PiKrKfVhKODl9v25u3xy679o9SRlpTZk/Di69Le1amOjJ/l1ann9N+U/+yZxszPwbGKxZO9nMvj9uiBlYqRenGEmqeAvnirwsGnjb/KjOjIfbPEu6W+ubDe1KyOeoRltZt9hpXFkuGdnqWqiH6WlYV4xsydrNKqlICttLHFqba9y6yRgpe+jLCB0PKj0pT637bg9ci3+vysuJWUgPudopWOl/6DjKSdlI+rs5mev4zBj7RxrOy+hH+plICTqaaircHkuMaYn4+StKS2qcfaeLC7qLi8wv+z4+6MfpCDlOPq1Kqco9uXu7V+fZehlpzHvMiEkn6/xL2nwYCj3YVwlci+hrCftJKTZ2aDg4pmzndte4HTntV+i6OapamKxezl17OQjo+C+fOpf4DAssa03rOovunIv4H5pdHUlYOMf9XA5eTH5JNmZayGfsHPmI/Ts7/MxcPqjNx0yrCgd9dydbC3c7pjj6yDm2iLqo9vbnDRj3ulrcGbk5yhnICNZWpiRXVOh6BlVmhJLmctLSglLytISmlvdJBRPzFFNkM4STImRHdgKlcrY0U2QEsrOykmV2cyOTtSdlRbPUVAO0M8Y0s8QUl1NyctO0ViQ1g3SUtaX0JLJkBFRi49RTo4LlY1KiJAKzE7U045TjQ2P11LSUJKWFM0ISkrMUwvL4AmIy8rKUM1RiY3PS1WMSgrNz8mSDNULCw5OjAeMUkpFE0+Ly49KC4sLERaN1EzMTdSLEA8PUE0ZXZkT19YVUxAapOFz8G+4djS9JGeheXc2mBUXZGBw7/Q1f/QjuG13/SAhIeEh4aChn3k5enl2dnTvJl+T92fbnNrb1JQUFCGe4Cfe46og657X6aGmouKi7Wwm4FuentaVVxoXa5zV1tNVFVbX5aTkIdXi6qOqGaik5WdeF5+UHBeZ11gV1lUg1NmXmBdwaO6eXaceYaNeqV5jItzdmFXPGs6QlpDVmExTkk+Qml2OXAtLU9WZUhJRD9Eazg9Ty8uLjEpKSkwMlJGTIBPYzdePGROMCw2Ni8zVkE3NS1MTFpPcj45YXxVXUpTb4GK86zTitHx6LevnNCq+si6xcrl86SEk97Bv87kvMP8ybuVmI+F27rd3NLW2ejtz8vPxL61o5ivm4KAMjU4NFAvRkJpNzU6PmpBTTl2bHl+V0I2O4xKXG1sbn52MDCEYYCAmKaVQrpPWlJ1X0h2flhUU3U+Rl9MfpWcTmhAVI9gXXFStrH6jcW9kYiMkoaOlJ6YrZrAxpWS2Ibtv1NRR0JwTEyEQVJeT4x5hXiHbXRwZmR7d3yWSlE9dnhDNxsxHSlOO0ZCQUFAPV4vKjlJS6aFQHu+hY5XeFZoV0lRM09NdoAwcUxFUJRVeoo9OUVAKlFLTkGRf1FYVU5wOkA6My1NIjEwLCYqQzs0KzlTQzlBUE8mY247WXE5LCowZSpkdoB8xJiAOliMg4OZe2lPhFqEiZSMbpacbbmqbJ6wqpeoqabmwqyVk5uA4sGdsMX/sueVlZWWgHJqX2FHdG5KY3ZkRoA5RGl2WlphcWE1OD08Lz86XVw2WVqae29/h1I9b3NRYl5gUZNVUk1TV51LTVRVVF2joaS+3aS5jsiByPjckIi/sYaTm4aIkaDAio+TdHd8jYySkqSyUXiGgI6Fkfqakplpfq2gvfehkIJ8gOqd4Nyanbi8sLvk0M17ioDe2sanwoCy6IyAlLapc42Cj3Z3VVVwcHVcs2VbaG2yi8F0e2dIN0U/YXtaR0A6LzYzUmhnU0t6YUc6PDk1N1NLTydUPkhKLSsuLXFja2hKXlNCQDszO3WHXFmNUUtmZlBbQXc+UD03LWQyR5iTRXlLaH9ZaFOIhWJHQTZgSCk9QkNMT25ucw96e3t7fH1+fHx9fX1+fn2EfoJ9hHwEe3t7fI99hHwGfX1+fn18i30JfHx7fH5+fXx8hH0Ffn9+fn6EfQN8fXyJfYN+oX0EfH18fId9E359fn1+fn19fn59fX5+fX1+fn2FfgJ9foV9hn6CfYd+g32HfAt9fX18fHx9fn59fYh8g32Jfot9hHwBfYd8hnuCfIl7iXoBeYx6AXuEegF7hXoDe3x7iHoBeYZ6AXuNegd7fHx9fH19hHwBfYZ8BH18fX2JfAN9fHyJfYV8A318fZF8BXt8fHx7h3yDe4l8iHuDeoZ7h3qVeQl7e3x8e3x7fHqEewF6hHuDeoR7AXqGe4N8hXsIfHt5e3x8e3uEfAN7fHuEfAd7enp8e3x8hXsDenp5k3oDe3p7hHwEe3x8e4R8jnsMfHx8e3t8fH18fXx7h3wBe4Z8B3t8e3t8e3yGew18fHx7fHt8fHx7fHt7hHwBfYR8gnuEfAF7hnwBfYd8gn2FfAh7e3x7e3x7e4R8Ant8hnuHfAZ9fHx8fn6FfQR8fHt8iH6HfYZ8gn2FfgF9hHwJe3t8e3t7fHx8h3uHfAx7e3x7e3p7fHp6e3yHewF6hXsBeox7C3p7e3x7eXl6enl5inoBe4l6Anx7hXoGeXp6ent7iXoCeXqLfIN9h3wFfXx9fX2IfoR9AXyEfYN8h32JfAd7e3x9fXx8hn0EfHx8fYR8hH2Eewh8fH1+fn19fYR8AXuGfAJ9fIV9CHx9fXx8fXx9hnwHe3x+fn18fIZ9A3t8ewICBACAoqmKeNTwhqu+uqXhiMKy0N3ZgePPkIOk4Jqg7P6CvL2rs/OfqZ6lw6C+tvLD6cav0d/vwn3R45WC0NCbwcvOzM+ItsiPgoHJnZK1g4yG2sG906ad4oqnp/fmj8W1x9eq2uuS+/yT2+TCv8/v/sH3oO/StYCl29ya8NOQou6z3N+Ay7uA0o+T6YXCofTpw9DSgZ2f8cqZ4/yZ7dfZh7Tr3tfApO2KnaGxrsCjiKvw3u6Gtay4t6Wep6fNqKvaoeCM55Tz+YN72uJxfIB05XZ8ioV9jJ7Gn4eCh8fBgqXDrLa1tri0r7nK55KimobZp5CTgMaGe52kfs68iXLZumd8x7uAcHxnb4G/e3aLmoGEgId2p4xyysZ8fH70h5WSobmtgmdsdnh/s5GPgYqZjdKnid/Vxf6B2YrBl7ano6qp5nmMo5SXsYmW0uTMn4iei5Lfypzkj5ar6dLK0sSkoKW54L+amrSTnaWW0ZHdlqqj36SodZ+wzmicdHOYtaGsequhoIOAr2p5dm1zpJeOjdSHjrmUbLisZZKPpq+4mrqK5JqAl5OyioL3jdi/s8TIzsyykPeHiYyYhYFsqqGZfnCBiL9wjXCLfnR3zamqrbawqrJqy7G5pI6JgoJ/eZiqlqFxpmlxo6qIdZOcdGOqfpVtc9KdqXp2aZZz257EbKyGg5eq0ZKAgojSwJGRgYSW0Yl1poqbw3LoeLaf2aepo3SdtG65y35vhIOti62gi3p/fXt5gqqdma2pjbGcgZd7g4ywm5+tjIWL3nWKgtzcfKWF4d2gm826p42ZfOvuuYeU5bK+h7nlmsWGu5mB1oPDotzQrOC65+2YmXmdj5ipm6fHqcONiXyAje3V3cjJsOe0en2jc3V7e3lu0YCRh3rdxdKEhMR2y5OM1XjVjJOgwrWElZarmLW1kKnfmoaRkdm4h8WtdW9/o7ewisC3zoKWzdyuoNeEgYnYpofvqZiH1M3Qp/PyntuiZNWbh4yXlGxeYnOATW1vtKGVouLXosfDgJ97iYTDlnqAmnF+ln6ig3qxrIzn27XWwLSzwomwuJqhdMylm6WYr6ichbdmhXlnpq6lx3Zva3lufXaDebK1y3xwuWt3nHuMfG2DfmpkeXmNl4KJe4h4bKNlkcaHv6Z/fXNxdYKGisO2geaQeXN/0XKGjNhud7aEaWl1lYtwlqit3oTVmqOpiK2Ai6611of97M/HyYWMis/i4cPXtLjMk66whcmVmJyQeYqdicLEwKV1lqx8nouWcp+wwpmSjZ6evYZ9d8lvupuLkZGUi7HQ0divibTQmqiM15PK2M7blZG8jNqU3KWatKyjkoH1uZ3NrbWA7KuhoPCGsuqgrbW0x6aH+ZPA1anZgLuAl6KYis7Md6m9wajLco+jrMaoXrumfoaq2pOt996AyNKzvf2ktq60pqnCp9zH1tSoueLe3I7s9IxprqWAqq/EydeKicdrVW2yi4Wyf4CIs2xqdnKI011oZLvPf7SghaCWtMt309aBoZ2PjIafv5bDicaaf111gItmnJd3iayOl6OAmJFhp3JlsGuNcbaTi6yvb3p2n4ptjJhWnIaIVXCnnYyCiJlEU1dcXmVkYGuMeYBSa2JzbGZeX2OCc323iLBssXbZ74aA2uVzgoV25XyCiYJ9kpSuhYCDhNDPlbvVxM3HxcfCv8LJ2oKLh3vataOjlPOroMe8k/j4s5T25YeR8+2AjauNl7Hpk5nBx6aajZWGwamE5duJh4X5nrisvNTRnICLhZCUuaOdmpydk82nf9rTu/90vnm0nL+ip6+u74Wbs5eftoKGu9u/mISTiIrDv5HhjarV+/vu8ObBq6u63r6ko8OXrsOt853vuL208brQjavL6IXBmoPG78fTnuHPwLKA942gl5eWoY+LlPOdsc7GiOvnhM3G1MTMtNWr3tWxsrGtfXXghNK8rcTR2da3kfWKlJirlpJ8xcGniniNmdF6mHWXi4KE5Ly6wc3DvMJy3MHKtJ6VkZKPkcDNtLuKx4KKzNWplczVkIrror+MhPfMxY+SicSM/LX0gK+SiJ+50aOAj5vZwoyNk56o7pqFu52eyYP+hcSt+cjFuYyz4Yru+Z6Im5XKlbuqkIKIgH5/h6+emq2tkLijiqGEjYu0qqO+lZKS8oKRh+zpgqKK6OWnl9rGs6axgv79vYyP4Li7l7PbmseNv5uN7pLate/ntNa+6P6OkYCro67GuL/Src2WlIKAk/rd5MXQuO+/g425houCkIyC35Cmlov/7PCVltaC3JuX64jpnZift7SPo7C/rNLFpMb+q5Clm+PLmOLNkIWVwNHPldLP6YaIqrelldKCcnvKonzqrKGTvq22leTgkdepcOWupY2ht4h4f5SmY4uMv5SHlODcmqWld6+Rso7XtY2AqYORrpy7nZHHwpv107nNr7DB5r359aSQhvu9scqrycOxpfyMva2Z4ung9o2Kj6OIm5irmMnY8ZKJ9IGEooGXiHmZlH2Qq6jE0sPJssepmOmEpf6hyb2iqJylr7vH2enRgeOYhJGo/I2ups2dk8uZfH2GpZuDq7Wx2H/Tp6msjaqAkaen2XfL0L2xqWZlYqCkoZWcjI6ceoqQbLF/fIKRkpu5o9vSz6+JudGItqKwha2isKi0qL7B1qCMg9CB3qiutrqyjoe20+7DlqXPkXlh1pOWrbHCi3udfuKf746MmZSQiHPspomijZ1lq4SEaaxtgZ9ylX6v3KaS/YCKf2qYWpCAX2FSR3mGQYBiTUVgNkFEU0FEHz09OTdBcnJgZFYnMzM1NlgxMCk+XjhMRHhHST8yND9COixTUjY1ZWtQUks6Oz8qQTxCOSdFOzQ5LjMmSllMXU5NUz1AOFpSL0FIRlI2VWI1VlU5aFE4MUldWkJXTlxFOiQ3QjwnQDcWJ1A8VUiASTsgMSI0RiU1L2ZERTFIIiUyPTU6RWM6RjUqKDs7LSRCLUQuNEdCPU4pKDhCQzkkQz1OR0Q1OzpaVmureZNYfWPP74yJ6f+Ak5eF/pSalY2Hmoybd4OOj/L9s9v88fz07erk4uHa34KHgHfs18XDquqLaIuSXZOMbVOPfT9LuKaAaWxhaW6fimZwcGx/lq2Qr5FjmZFVUk+nZmRkbH5pVkdJY2ZnfGlnZGFbX3ZjWI2Pg7hllEVvXnhrY2JaikZUXGJscG12nbqYgXaJg3l5dnKkcmxydFlcXlNVNlVRQz07P1FSXWJQZzpZTk1IWExHPU9PVClLNzc9Rz1JTmBaVUCATys8PCU4V006Nlc0NEZBM1lNL0Y4VIK3f4pMZ0Q8TWCSambJe9W7pr7X4+K5j+mKlpyznZqI7PHFoYmmtuWGs4OfjoaL88zHz9/Z1t6C+9vmyrevpaebWXdIXpdYWS4qQmVNMm1eMzN5NktAQYBsfUdXP3k1nGOCQmhNSUhRjVeARkm1eWtxUE5iilpAVk5adkqEOFw4bGJzclF6i0uOjFFFZ3mbYqKrlIKKgoOBhLKemaiuk7ihiKmIh2ViS01PUkZMgUpPR4SNS1lOgoZkZ31/eWxtWX94SkhYYCpJLD9ZKygwS0M5YjVcXltTSVJprqyEhXWOb112XGVxSGBkd2OAXrmeo4RrfpCKXDxVHRwfGxkeSSlMTDlkXnJJJzkkNxUTKCcmIyIbMiItQzU9MGhEJ0NhPkRnaFgiPet8RWuEe5BsnqBil5aEj5mBcKVXWGW1lGvEin+EppKhit3VhNa1hOGz1n6u5rCdrcfmh7Gw1Y2AjOTiiH1sRGI9Oz1aUz6ANj5IYlhjVFNyaDh2OjdIW0Q/XFagjWRYTX46Pmpcb2RtYJpMYVJNf5OMjk9UVWBFcKO/t9LY4pNzzYWIvoyoooe2qIF1foeQi4eIhpN+c8NzjeCGqZ+Ed3d+hIiTmJ2Na+u3pZm20n2Tj4qAjei/mpekxrOj1NLB5IPmycbJp8KArbqp9nO+w8GzmVVSUYeKiICEeH2HbHV6YJ1sa3NkPSw3MVNkaEMzTUM8QjM3LlZmbks8LjI7TTA0MVwvSz86PTc8Oz5RVlZAQVRPM0A9a0llZWKBRENMOGE+Y0ZEV0VBMy5nTWtCSlBLeGdfQ2xLbHVBRElBQDMuXi5CTkxkQmKEewl8fX58fH19fX6FfQF+hX0FfHt7e3yFfQF8iX2DfIV9AX6EfYJ8h30GfHx9fX18h32Efgd9fH5+fn18h30HfH59fX18fIZ9Cnx8fH19fn19fX6KfQR+fX1+hH0FfH19fXyIfQV+fX19fod9iX6DfYt+DX18fX1+fX18fH19fHyEfQF8jH2CfI19hH6FfYZ8Bnt7fHx7e4V8hXuJfIN7hXoBeYt6BHt6enqHe4R6A3x7e4d6AXmHeoJ7jHoBe5R8AX2LfIR9hHwBfYV8hX2EfAF7hHwEfXx8fY18BHt7e3qKewF6h3sDeXl6hHsCenuGeoh5AXqJeQl6ent6eXp6fHyEewt6ent7ent7e3x7eoZ7F3p7e3x7e3x9e3p8fHx7fHp6e3t8e3t7hXwEe3x8fIR7CHx7e3x7e3x8hHuReoR7iHwJe3x8fHt7fHx8iXsDfHt7j3wCe3yEe4R8BHt7e3yHe4Z8iHsDfH18hn2FfAp7e3t8fHx9fH19hHyEfYh8CXt7fHx7e3t8fIx7DXx9fn59fXx9fn59fH2EfA99fn5+fX1+fX19fHx8fX2GfIR9BX5+fn19hHwGe3x8fHt7hHyHewJ8e4Z8Cnt7enp7fHt6fHyGewF6hHuEeol7DHp6ent7ent6eXp6eY96BHl6enmNegF7hXoBeYV6AXuMfAF9iXwBe4Z9g36MfQF8iH2LfAJ9fIt9Anx9h3wBfYV8En18fX5+fHx9fHx7fH19fXx9fId9B3x9fHx9fX2HfAR9fn1+hH0BfIR9g3wCAgQAgIHkqLKaquaflXuuiYaMnKXLrfWRy9a/sJPzzIeI67iC3JmbiqOtnLrm7O/gi8Sv1I3RutredYHI6Iyfu43NytrY1JGdnK7jjLvgwcfjvLO7zqWjjIOwlJq03ca6w5yrhJ676eORipv/rqOOv8zQy/a6rYrzgP7D/pruuPfD5/HbgL6eorGtztCYnYGD+L/fqYzZxeWhz6Tdie3Zw4GFiJ7evN75wfOrhZGF9I6SiIOMu7WUr5SvmKKxirbgoJPGk81+29PP3XzZeoaGfYB8gZLB27uz2ODHoXx/oWdwdcewqKCalJuSioaRk5aUiYuKhXxrqX6waXfFlKCdj3Rpc8C9gKR7d92TgsKDoY59iHKWeM+ipYG8eW7h3m+Al5WpubV3l5GT3oCFpoihuIbF27StuIXDkr2e2cR1xqSkiJWssIjZ39awsK/vlNmb1ciapd7qn51/lcatlnmXdouatMqD28HMg4OqmpyC3Mjz4et8qIOMhKaMmquxanWFjGlks4OSgKN9moSBZXN4vOjfvIqdhLKLtbWenrS1pbl2h4qBd6LP/cXcjq6biYiOk4uF4sbc3cjseYeFcHuSiXdudsu6mnxwtMx2c8mcrbGam6i1v6uftLaUm4V2gpe6e35vfYRuXKx0cci0kXKhYK9hrH6TuXJ5h3GVdmeN1o6l0avUd3fVgH6DipSDhI+PtnyerKqChnR3l5Pde8KJk7rIspmOhJVwy3hvd4u0dLbo7n3qfY6wvazDm5q6naV53IjNiZCgkX7Fq66enYxywKuC+HrCorunpY2hkNDaq7Xp84uJ976HlNPkirSIlaLWuHaUwaPXmdjXx73dv4iPdnqc1ovu9NXMgOzjsajfvsB5hbKBrNSEmNGmdJfHo5mpzdlvwIKHecTp9KaW1I7Phryl9bWwjnDKfKmJudR/wLqYj4CXx4C1r4Clr8OuyIGVw7mnhb74sPTts6axpN3MvpadlJOU/HeLi17BsdqsT11gcYdSW2RxcIqQ98eLZoW8p7inoYrEgoOpgJ1wpHV2gaSRb2biwKWmw+ewoI+AiWqmuJPRpYeTpKmYoo6Sg2Vzc66TXXGrZXCNbmpoe5iYfmx9bmhkYpjNu4OmvHy9YWRtv3d1ZWZ9gnG3XmK2cWW4fWBjbmJwhHB7qLTIloWNXqJvaXGEhGuUdb1nkq2+q4d4cajMlHOMg71wgGh7xqjIz9eKeaKDv8jnwIXtvKuWobWilpC1oK+ehryIooah5K2XcGyBn4mnvdLQkrK2la6ebcjeqoDXtqWPhIG9v2/WmrWntYTSg4bF3N20iIeMorqsvp/DzqW6tomEstnugvvMkbORuICXjLyO87ens8SYjLCBfLCX7r6ltpXGgIboo7ehuv60j4i2gX1tgom5ntJ1tcW/sJHSuYuJ0LuI8aCXjrbBrrXV4tnlkdjC5Z/CzPn/h5HUxXmHmIS8zObm24yEfqXqk8LSo5vXxpVmeWxlW2mLW1yJ7NWlvXpoVGqXr62CdnjGkX9diJGSlsKQi22xWr+Zsmeaf7+IqpejgI10kHpwio9xallelHuVenaFkKFzh2qOWa2bh1VhWmG3gpWffZVbU1ZRuWdbX1JQd3xbaFlnXGV4W5K2em6ZgrWH5dLR1X7jgoqNhoyDh5Owy7+rvcq6rYuRuG5yeNbDvrayqbWroZukpaenn6Kfl4+BxpPhiZjpwtTStpCEnuXhgMGhi/azpuqlvaaZrYqxmPWyt4nUhYjV3oOWq6W759OGtqal7oSAspyjsZPM1amop4TJg6uT2daJy5mghqC4rIbR08WxoJDKjcmQ0L6Pk8/UlJmCqNbFtJGokIqJoLx308HglZjBtriQ59Ly8/uJz5+gnsuuy+DRiZmmroWE3HvFgN6YwaecgoaM2Ojz567BntOtz8DU1/Pjt86ApZu9lM/x+LrNh6WRfn2FjoeB3MLW3cz2g5mZgIyploJ4gdfKpYuHy+eKg+Owwsarq7nHz7uvw8mlrJWEkqz1kZWGm56VhruajPbywZTbg+aH7qKx34+bsZKzmYCz96Op2MLjhoT2gJSUlI59fYqgwYisx9ebnICGpqDuiMSRot7r1sG+scCM946NkqrJgsb3/IHxg5a3wbHKn56/qLCB6pDZh5ikkYHUytC8vKOL0b2A/YDOrcqxtJ2xnt7ksrrj9oGD786Lk8fbjsmNk6zuzoah1azIm8rfuKjszZeZhIiq8pHq8tO7gOXhq7Ls2diBjbSKyeyYpuy9h6zlyqzD6/mD2ZeYhM/7/K6k3KLji7un+MfNnoDujMOY4PCR49SqoY+q5aTWvo29xsS7yYSEopyQdKrxr9PXo46aouzouIeIkq60/4CqqW7Yv9axZHZ8lLNteIGRjKup8ceYd5SlkJ6yxJnqlYWygI6C0JWNmMC0j4LmxJyWuOK2pZOjq4jbwajrtJyyu8KuurGyrpSxoN7ZhqHag5CwiYqJoMG3nI2hkYWQl6rYzJK81JPogoKR/a6pm5S2waf8gIf4jIDYkoqWoJWfxa+pyMLOn4+pg9iLj5h0pIKohtZ0n7a+r5OGfa/Po4GTh8t1gG1/zK/HtMSJeZBml57Mo2i4ioF1fomAeXOOirOQdt2muJ3F7MCeh4ahtaTQ5O/jqMy/rsaWhMTwuY/90r6roJzd44LLirShrH3Yim2zxtC8fnSCjaSatpDM4q6ajnR1ldHhgPG/jIx2lWh3bYZktn9yma6EgsONirR+vY1qcoLCgDZYSlc9QE1DMSs2LTBDRjo7QGg1ZVg1MUWGYEBEWC0zTiotJSwqLkFSS3VJJkExPSg8Nk1OJjBMS0BFXTlDOTU8Pzo9SFpGJSk2NjlDO0RUZU08MCpBGjJKVFpCV0BWQFVLZls5PUd0VzU2Rj4zNmM1LS89L08zTTRZKEo6PVxBgDYoGSkgPzomKRwwUVFWSCtALDgtRD1aLj5IPCUcJTE8KjBMTFdHLDQuMyIwHy01REo8Pjg+MTNYRIecXkqDdp2d/ePP4or9nqSinaKYnqi0y862wcu9xquv4YGDhvjs5N3g1OTYzMLO09TSxMe/tqaKuH2dX2uSaF5ncFRGUruPgIFQWsKQeMV7cWBUYWeLdMSXjGyIVEuUm1NbXV10nZNXfHJxtlNSdmRdZVuAb2pud1h6dW5NiIZRiVxfU0pkZEuBhYVydnWifbN3qa93gZeBdodqXWxSSD1HQUBKUFo6a1FbQE1aWlg/YGpsU2g5UkZDQE01QFhWLjM6OD5GZz5CgEw2QzMrMTgtTWRZWEFAO1VCR0xKTVNyeVw5QDwxNFSFxqvBg6SMd3N8iIR+1LnN2sX1g6ChiqzRspaJlefcsLiv7vWUjfHBz+e8u9Di7NXH2+K7waiSoJxgRDEnNy84OEg0Li9eQz1kPmw8a01ShU5NXDxmKkBHg1xlhV52STtjgDo3VG5zdHxGe09cTGM+SENQYFKLR1hXX3SAfm9XUnBgiFlEYVh8Yp/2+4L1hZW6w7DKnp28pbKF74qJUkxVUlCBeXJsbmNZdWZFjkKEaXZzdmJyY35/ZGN8fyobJ0QkQTg2H0IqKC4xMjE6XGNZTZl/i5HYoYljZ3CEjWCcvJVAgDdvPTNMV2c0Oj4vRE86Q09LNzhKS1tiX4gzaD8tGjspLTM4NCMjFSAcaThFKSJjPFA4fGEpWk8sIjavZkpXeZBwcbJncV5yjYRvXIC4h6e8mXuCf5mnonV3mt7l/47VzoTHpKnChJqlyvKToa25r8/J8NCujpxzWF1pYTtpOjc5gEA6Qjw5VD9gWVBePjpGSF1ARDdQUkiAdjhkNzxka3FqbmNvY1ZbUoeDU1iFT09eU2hvpefTo3Sre2l1dsP06KvX9K72dXZ5rH2EcHaLjoHaanbaenzhfWlyfnN5hoaHiq7iwLGmc691eHBMeX3Ho/uJtsvBtqmlmMrmxKGxnfWHgIOU9c3eqL2ajpRVd4SzjFuldG9mbHVsZ2J5cVJXXEs0QC9BVU0wKiwpQTc6OEFqQEtXPz4wKnVhOyROR0E8MTRLRCNKPUIzRzhbNihLbXBUTkQ9SE5LUT5HPklMVEpDSVFULWNmNTQ+gFJcRlA6dFhXP0Q7LTcqK0M6Y2JFTF50BH18fHuHfYJ+hX0DfH18hH2FfAJ9fot9AXyJfQN+fn2EfIZ9BXx9fXt8iH2Ffg19fX5+fXx8fX19fn5+hn2CfIV9gnyEfQh+fX19fn19fIt9g36NfQR+fX19hH4BfIV9hH4BfY9+BHx8fX6EfYR8An18k32DfpR9Bnx8e3x8e4x8hHuIfIR7BXp6enl5j3qHewp6ent7fHt7enp7h3oBe4V6g3uGegV5enp6e4t8AX2IfAF9hXwBfY18Bn19fH18fId9AXyFe4p8AXuGfAR7enp6iXuGeoR7D3p5ent7e3p6ent7eXl6epN5BHp7fHyIewt6e3t6e3p7ent7eol7A3x7eoV7hHwFenp6e3yEewN8fH2EfAR9fH18h3sCfHuEfAd7e3p5eXp5iXoGe3t7ent7hXyJewN8e3yOewR9fXx7hHwBfYh8BXt8fHx9hXuHfA97e3t8fHt8fHt7e3x8fH2IfIZ7BXx7fHx9iHwRfX19e3x7fHx7fHt8e3t8e3uEfId7BHp7fH2Ffhd9fHx9fX1+fn18e31+fn18fHx9fHx8e4h8i32EfAR7e3x7iHwCe3yEe4h8CXt7e3p7fHt8fIt7BXp6e3t6jnuCeoZ5Anp5i3oHeXp6eXp6eZB6Cnl6enp7ent8fHuOfAd7fHx8e3t8hX0Hfn19e3x9fJJ9gnyGfQR8fHx7h30EfHx9fYh8An18hX0EfH1+fYp8iX0PfHx9fHx9fX18fXx8fH18hH0Nfn59fX18fXx8fX18ewICBACAyrnwuL69vq+Y3a3Yo7KD6/mKjYjfrMi/sZCcqY3mpcNypo14itO6q/rzvJiHvc3A77Lc6+CShKbgnJPS38mD1e3fpoHdgbid7tn25tWAo+ug7saezMiQs/7L7puM9r6GhPKAo5Cgg+vM246r5b6SwJeLss2t1+HOgKXSjsnIg4mAl7f2n7SB76vJxYb/nOj+sJj2h+GdhKvpyN/ri4HT/bign9/N3tyHlNvlk/iA0omiloHN1KmSuOXuppaF+N3W7uKNcs/4lrTo/PK0jZWbrbfMu5l8jIqUl7G2saysp56ZlJKYk42OjY6NiIyPjYODfYWly6+hjm+j0ciVardwjnqAvpGYyeCuk2WDjW+kqoJ2yo6evJ+Ni4VxcqyDj3iKo37Gm7ysld+plHR8iJ7I/JTohYaviOqTzrSZqPbX/Z/39oXtg8C4y6Xal6LZu5brxuvyjNJ1yOqbgcbJgrmLsqqcjImAibyy3Yqi1ILEvt3AkpJ8zGaLfa6TuM69nWeVomuAfLVuhF5mcY23zJ5pinKQhJZ8d5ywmLqNvJuem4uRifXp3Yj27oLsys/o7ty1laiivc2/vbq3oKpzcXNuwraJplSEtc2iopeqt7KanKK9uYmUr8eVdYaHmpqljJTPr4rEv2hht5rLnGO3mnRjjXJsZGrHkohwlqSZgbm+ip2UuseArLDPuOHui8+P4p+ebm2IlKnDzoTXmM3DwIW7pqFvj27EcXpubn56v5qUwpKFmMKxp46Jvoqmw7CGu7/imHWK9b+Sy3jMm6J/goe3iI18k5WEt32j9ILNjKmVxe+VgZKN64qJrsPI0/rs/OXd6bSX1IWTvoSBw4KHt8LgrrHrwpCA/5ziy4KoqavIlIyblYVxuoXLdc9tkdhwgbyh7o7YjJB425fBsZazpHyck3NwkNe4eZFyhLbcg818mn5304KCaJHG6rCOka30mtD0w5mt+d7KrMC5kHWVpauOh3mfbnVYcm6cxVdWbkpWXV5cZnSZv9vSsaaJYZVk/rqZkaercJOAeXyLcoeOt4h+yPm0m6Xap6eKhnSMX5216+h3qsivdnqLo3mFiXFscXRxYmhrbG17q2lmda2dkoOYrGrMk6aiksG+bXS5v2t6gXpwtmhcYmGqoZlfW2abtV5XnmJ7f4W8oMujhmm0uIGMfb6lmnN5aoiogX+ke3tndZN4WGG2eIKAdYOOlLyhsODqi/qCgqGqhIb4mpLEibHMp/vnp9CTqoyFk728l6nUnrnVrr7Dy9Cfn7jOtamVzNmHesFzknTDrYiXwpeLhJm0+rK+gH+8dtnsuau9p5ikr+KUiquuo6zS6t7wlsSgp/Kg6anJ5/LkmoLiqo2Hk+XTvIuK3ILxodeAxrX3w8/U0Mef2ZfBnZt03+t8d3LdrMXCp5yjqYbVrdaAvpqDiLTNqsjQ05WS1e3i9JrM2sh7lbGwenqqxL510evZgGTie8uQytDBxbl6ZpJcn29jbI9maL+8vY+JwZBgX71cin6IcLOnn2Vvm3xsj4B1jJyDq6qXXX+LaJuOTFWAd4HPgZhgqHiVgFalX4+bsYaUUJR2anWsjZmnV1mXuX10fZWKlZRVVZScZKRepWRzbFyMim1ieJyyenJmvbGmtcePdM3Kgpm609O4lKCmr7bKu55+i4enrsnQycPAv7azra6xrqeopaOjnqKkoZWTkJey69rJpIjM/uy5i+uUvpyA+szL7/vLu4yvq4jR2qWZ6qS7v6+dmJKNkdiLi4a8vovqp8Keg82cnIGGmJa59o7Qhn6hiOSX1rqRmtu45IS/uGmtWJCKkoTHiJHDoniqg6K6ge6K6ciYf+Liia9/oJitpaSRoNvH4YqL0X/V2PbbvreU+oK1pfDT9fDhwIC8yIuAn/qRsIKLmr7g4qiBrYSmlZuMjMDovuqg0q6lsr+oq+jg0IHn2nfcvL7T4NGukZ2avc7Dx8nLuMF+eX930MWTsGSayea2t62/y8Str7TRzJejwN2mg5WYyNbxqafj2Lju4o+E5Lz8vYDj1pSGwIiGhoDtoZiLwcqnisvGnMKj0eGAwMn0zNPghs+a8avGhoSam6/e45fto9/N4JbPw8eIrIn0jpOHjp2S3bKhypiKnMezrJGMyJG11cGPwsXenYCG79Cr9on2q6uIj5PKj5SFlqGTxYul8orniaSWyvuZj1l/9YCExN7N2vLj9OXt8LaX2IqWrYaJx4ygxcz5uqrbvouA56Tow4+wsa/KmpKwqZiAy5fphvCJn/6Aj8mx+p/tlJOC8qrRwarBr4SfqIWAn+3ViqSCksX4lOGJqoqD85OWdJrAzpiAfpLalcrpr4Wd3cm6mLXCoIqkn6SpqZi2jJVtjIS14G9vkGJye3x6hZKlw9javcqob6h0/bGmuc3PhayAh5SolKCp16ya4+2+p6PSq7OQnJWwgNfO+v2HyeDLk5OmtZSpraqdo6SijoGIiZOT4YWGk8m1s6q71I3forK7pNXdfZDy+JWkrqKb85CKkpD99d6KgYPD/oeE7Ze3ucTlyc6sj4Ti4pm0m8i9tIOLe569koythIl2gpmEZm7Mg42AfImRmcCYpuPper9gbYeLb27Hf3abbIuhhNDFqq+IuqCeq/XyrcH9t8/+0N7C5OC1r8TKzcOS1NSUjeeFqIfov56w36OMgo6Y7ZqzcYLDhOnekIGGd3JynMagj595i6PA3cbWf7iJdKx5wYagtKqqg2y5l3hsidPXtmxWnVTTjNiATVFXPTc7PDU0VjBAOm5ejWpJQDZEKy4zQDM4OjdZOj8gNSYpK0FCNmVhPz8lNzZDYj5JQUIsMD9OQD1OWzsmP0NAR0d2ODg5SStKNkM6UEJAVmA+MTcvT1RTbDg/aE44OF80OTUyMXBcbS82Njk2RyYZLzYsLjg1KC9GMTM4JB6AM0dGJikqSStBMiZTP2lvLjJIHUImOTYqNEpLMiJDQEMpJ0tXWUsvP0k6KDsfKyc/MSxkYk0xUnSWYU9AjoJtibGUhN2tdoabp8C6rr/GxMPUw6uRnpbR2Pb89O3t6+Lg3N3f3tXT0czKwsbKwq+sr7rP6J+NjFpncGlPP2ZcdVyAlGdymKuHfkxjWkNtcUxPnIyOnnprZGpfUn9aYFxygWiQdI13V31eZFJWV152omOYVmV/UGZKg4BzbYt+iFR7dkpzNltWYWqpcnKMhV15V2qWeZpPdmxWRG5wRXhTWmFlT01ITWRYcElIazlWVFtYRks0VCxJRltNVFZXXD9ZWSqANUokMyQkKihKXEM5TTA9PD45Mz5dRF1NYVxOPztHU8bGwnvez2/RtLPG2cqqkZmWuMS3wcvT4+2XipWJ3tue1Im02vzOyMDM49i6vczr5q+60/G1k6OlTk5ySThObj9CTTUvNztTQjJoak5AZT43Q0FmM1VMO1leSV11UmVfbVaAUk1qicDSepdTlWZoTTs3TGR+eEVnTlJbWVmbbnZbcVmbXmNfR05QdHNWuJqImsOyrJKOyIa018CTubCeXkNOlYdwrlypdWhGRUt4W1pPZGRkaCM5hDg9O09EPk4iLDAmOR4qRUVCUEdBQ0N+fExOqUhUhHxutWJDTj9NT0ZcQ1CAOTZZWih3PkVBRTc9QUY5OS5cOVgiMlMyPXJtjjMwFR4QJC0xPCgtKR4xJicrQWxXNDM1VGpnHl0io49IiTOijquttX1man27d5C6kW2HvbejhJJvY1WAiJXU2sTZtr+Lrp+61JCUwYScpKajrLa5y+Dmy/vQgLWE5JI9ODo5KjCANDMzLTc2OTs6d4pEPkhdOD44NDQ8NGY9QUomRXdqWVJsd1NfYVtZY1xhUktSVFJal1tyj6yNnJnb6nfjtsjQwPP1lZfl5nV4eXt21nVudnfXy8Z1e37G33Bqy22BfYeToOfOrnnCvXB8c4R8upyklMHcr6fEnZ6NlKeWgIvymqWAjZekuuikqvDwfKdQX3h1Z2KlcG6MW3WEcLKnSUdJOzI3OkFDMThRQUtEQkxNPVhANEJgSEQ0T241KkcjNCxDSzs2QDk4Pj9LZVNhOi08JE9eWFNeVVZMSEQ0NUY3WE1YY11pRl45RH9YtGRsdW9qTk1rSTUtM0xTUzkyYzOFXneDfIZ9DHx9fX18fHt8fX19fIh9BHx9fX6JfQF8hX0BfIR9Cn5+fXx8fHt8fX6FfQN8fXyHfRV+fX59fn19fX5+fXx8fX18fX5+fX6EfYN8jn0BfoV9FX5+fX18fX1+fX59fX59fn19fHx9foh9gn6JfQh+fn19fn1+fYl+BX19fn5+h32CfK19A3x7e4V8gn2EfId7hHwIe3t8fHt7enuEeoJ7hnoHe3p7e3p6eod7BXp7ent8hHuFegh7e3x8fH18fYR8hXsIfHx9fXx7e32EfAR7e3x7i3wEfX18fYd8BHt8fHyFewF8hX0BfIZ9AXyEe4t8AXuGfAd6enp7enp7kXoFeXp7e3uEegJ8epV5B3p6ent8e3qKewV6ent7eoV7B3x8e3t7fHyLewh5eXp6e3t8e4V8gnuFfAJ7fId7hnyDe4p6hXsRenp7fHx8e3t7ent6e3t8fHyIewN9fHuHfAd9fHt8fH19jXwGfXx7fHx7jHwEe3t8e4t8EHt8e3x8e3x8e3t7fHx9fX2HfAF9hXyCe4R8D3t7fHp8e3x8e3x8fHt8fYR+Bn19fHx9foR9An59hHyCfYd8hHuDfIx9hHwBfZF8gnuLfAZ7fHx8fXyUewF6iHuCeod5BHp6eXmFegF5hHoLeXl5enp6eXl6enmKeoJ5hXoBe5B8AXuHfAp9fXx8fX1+fX19hnyEfYJ8h32FfIR9hHyHfQp8fH19fH19fXx8iH0JfHx8fX18fXx8jH2IfIJ9h3wSfX19fH1+fn18fHx9fnx9e3x7AgIEAIDWiaH5yLPzoffJ+qupiuXTmoO717CivnS7n8ygg7uewcXFk+mS3afglbS4tp3NgqaX78vP0NO24darlobOlNbTq9nAiMSb7ci7vLywh7qDuJ6PqMzujcqSmvbV1eS8ka6sx5PV/7Kek4Pe6JXQ7NHVl+fBoKDVwcvRyZWJ7c/484Dxi/iV8evimJGIgbeGiMi0wO7065bY8KeD7uruk9nO66r6jNvFn/frgriEvdvD9oSQnr7HuqGkm7n/+8a4tJPHx7ONpqjBrsDz9fH3nq2uxeTRpYqFj6Ctucm5npWTlJWXkJSWkIuLh4uLh4aJi4aOnJmhd3V0n2toc6iGr7vHuYCWi6usi5GHd8mTvJuIYrSSgMzorePn6ZeDq4l9sX2PtL7DiuS6os+nntOWtdne8+Oz1KLYteDgp7Lc086xk+Ccwa+K5ov+0t+4pYG/mZ2AtOa0jn+T6pDB4Zrd5+/+45N+3pSRx5SG6oOfnpHK0q1xtqVzdGySyJHBuJ+7sICUdoCwiYeogqi6hWqPtpi8huF+h9Nuwo6UwviNlr+OspuL3ZaQ+86448Swq7vMu5F6gISbl5ums8R4YnFybsq1mnXXkFLJzbe0qq2tuquinbOmhpevt51+mnd1dm6XmayOweNua2psrqm2uZWjiX2WkmphvINvnZmbqXr149+HsMbKuoCha66+5oSlnHTC25urxn9yiY94cImOkqHccqyRfI2Ueqp5tpfGcXGVhn2Mio3h4KGVseSdvMDPzH56tsqSfuzyk7uf9vujm7DRk4TJodndtNC7zI2khoqIe4XX/6n8qKbfkIKNyb6+4+3bwcS42/TphOytjYysyHXU3LbY+PGwnYC3i42IjqfQ5Yi0j5+f0HKfc7fUb8qGjnZxgJl1cad7mc26nqS+ho1xwXvFtquHdJvnmK2cjJi/gZ7Nd8bMta7lt929neqeovPIfeSXkKn6nu7Ud9fDhqjCe290eGtflX5LUllueWe7W268tpaBfKGZi25WWpFUiFl5un+UhZV4j4CVbr+6wL6R1omYqrbXzNvCtcWR8MCK1sDLr8ONi5J5l26Fd5J+cmlha2BkcGq1ZX1qcYzDq7adjZOVXWuipJB+uKljfnG5pWB4d7GkZliooJmXnqitoa1eVpCTkMWagomSyJ2HX4Kxa2t2lnmqh3uLqpZ5XbjCuGFsd2iTeX5lyICkd+eIpKHzi8CzxLKi4ezRpILFquaYoI+NsrSKkYCPl46ad3l8hMWCqcGNiW6gbaCxxbrFoKOpiYesy3WMwHnQu43ajIWB7oLalL2lf9qJ4ImBguy88JahtfzW2oKpsL2IlrG254Hj3d/grtr6ibOvf4+b+rK3p73HspmmjP2pgYDMbqLwzsTfrv/B0pqGe8/Eh26hk4Wg0oHUsva7j66n19Tbqv2f8p6oZI+Wo6vCesKq/cDB1d7G08OTkXW3k9bGqcOacr+Px6GtuK6lk8NwdmtVXpKSWnpVVrvBybineoqPlnzF3o11bFaqrFmImp2uhc2Sg4GZmZ+XlV5VpIKBfYCGYsVvzLakY15SUYVbVpR6gZefpG+lm25kk5mnVqGUiHKcVpmehLeUUIZWiq2TvWdkdYaIfGJocY+8uJKGeWiFgoVxhoiYdoavs7rkn6mlvuXWsJeSnrjHztnMta2rrK+vqKmtq6OjnqKinZyhm5ejq6exiICCw4yFjMem4OLz9YDhxcrMsq2nnPq36cy6gf65ntvgsubx+J6K1KuSzICZxcnHisuxprOVj7d9jqOjqaGSpW2ig6qcioq0jYhvX45qkn5YlFWbgpODcWqKfXZnldKmkY2h8Jex45/G3dvm9aOM96+n3J6H7Hi2s6ja8Nac/uqUpJ/G58rzzrTn1Zekj4DuwLXGvdzmlY/C5dbelv6Qk/6D+qy47fyPsLrA4qGP2ZKN8setzbKiobLDto57gIOXlp6rv9aKcHl6ddO9o33io2bV2MLEvr+/ybmzrMa5lafFzbKNqoiHiJG6u9CL2f+OkpGaydD6/NLlyrnNuomJ+a2Ao6upxI//8uyVx9HhyYC2g8DD24KmrobR+r/S8ZOCmJ6EgI+anrL/gNOsn7Wzl9mN4a38iIu3nJqlm5Dp46WZuO+pzNPl3IaAu8mPiO/3kbqk6/mfk6PSnYXPneHpyPrZ3ZSqgoqHgofn/bb9drjqmoKj6NHc6ejcxdK2zefjguutlaC31oDg6rfb9uammIDCnJKQkrPR55O/nKyt7YWzheH3gOSdnIaDkq2GgbWBm9rAqqrGl6CA0IDaxr6Zgqn9p9HFnqLTi67/ht7s0rLKm7ueitWHmN/DgeOCfJvtl+bYgO/ewOjXnJOXm418waVianSOnHXQa4PCuqeUiKGakn9scbFpqG6RyoS5obWOoYClhd3u1Myh8qe6pMTv6sDJu7qN/uu288a7q+S/u72UupWqmMKym5yPnpWOjovxiJeIk6fbwdG4rr69dYXMv6+N3MJunJbt1YCnnu/UjID98u7i5/D46/iDgN7Tw/7SydG60aOPd6Phh46UgIzFnoqcu6aNbdLaznJ+iHesjYtw14CreNyIoZrmhbego4+QyLKoi2qlisJ4iHx+l5eUoYuiqJewioCTouOSyM2upoSpgsPF5NHZvcfIoo7D8ZSs35L596fOnYp+8n3ehJuKifKM531iW6uftXCFqv3X0XunsLFve5GOt1+pkqXDna65cJitgYST57a1op2kgVp9ceCOboBpNTZGNjBFMWNHXEBMW6l+XFF9TjIyPSRDOlE6L049RTo7MUwxUD5NNFBGNixBKjo8ZEhHSkhHUFBFMjZTL0NONUdPToVAV1JFOj8zJTY1REY9QT1UM2IwNGZgVWxZQToiUUBMXywpNDJ3cDhLUEJDHykoGSg9MTJLMDgzODtPQIBfN2omLkxGKygfIz4nMjZAOCc5NiA1OigdXUA6NUIsUTRMK0cuJkZWMjQmMDsxQyosQlxeVT1CWHmZknVnVUpYW2VabG17VGaMkpXfr7qsx/PjxK6pu+f5/P/x3tbV1dbWzc/W1MzOxcjKxLm9r7HDy8zKjYaBkkA3NEk9aYiTfYBwZoOIcHNsV4FdcGdbPYRpY5q1fbWstnFUhnFqcD9cc42GZIh7Y2xvZYBfcXl6fnJxiEx+X4FrdWuJWldHPl1GbmA9YjRdVWRfUlVtbV5PeLKRYVdejl1ufk1ri5qksGJIaEtMc1RSkkZDPURocFRDblY1SEFMcE1dUktrY0VKM4BKOTtDL0RIOS9BT0hdMlg1NWYtWD07W41TUk86YpWF2oqI68Cmwquio7LCt4+AhoiWk5ekv96ni46MhOXHqoH02oje59XZzczW59LJwt3NprnX2b2auZeGh15KTlsvSUwzNjtAZkVwcmlnZ1dgWTlHeTw2XmNbZFGNfY5YYGdlZ4BRQIiP0XqJREGBhGlHXkUtQ2JMPkdRUVF7U3VnY1xtS1dgrXR9Nj9iXDJHWoro4aiaue2ry9bt3oF7kYVbQ4+QVHpnjqVqUl6DZUh3UoKDeZ9uUiMgJB4sIyI/USBEOT1CJhs3PERIRkNWZ2FZRXWPZcahfHOawVZVTVZDd1s3RYBFNyorKGtBTzdGQEhVj0A+MklKLVsyQDYdLzozLScYKTk2MDwyKCUiOBcnISZIKDFqNHl7LntfMWFdPGRZW7O3hp6JbbF0fLKFXLJraHq7fODdV5h/aZqvcKPGzLum+eCEjJm2zYzxgqHNy8CrnaylopmLjdaG24qs3XsyMCwpM4A3KVlaPDgwXjE8PTg+O0xNS0U5Yl9VYD04QFZUVGVPZVhfVW5mVVpZVlVQTUuMTFFNWHCFfpGLjdTljnm+w6ao9tyDqIzjy215c8TCcmXE0MDMytPh1N12aLrIgJ2KipWc7MOwhai4cm50T3vfwZq72ciqhPj9+YyWmYfVrrKL/4DFg9+WtKz5i7qVkoGBspKSe1aId7RpdGxndXlDMjQ6NDc9JCY0MT0zQUkxKitBNDs9QkZGRjs3LzQ/TS0oMidRXzpIND8vUixFPltJLEYsUEI7MWtffUlHP1ZEZ0FPVGJKTmFqezeAYnGYjW18TVJCO2I/aUpIPj5NQzdST4NeWgF7h30LfHx8fX18e3t8fXyEfQd+fX18fX18hX0GfHx8fX1+hX0Efn19fIV9CXx8fH19fH19fIR9AXyMfQR+fn19hH6DfId9gnyEfYJ8hn0BfIh9gn6GfQF8hH2EfgN9fn6HfYJ8hX0BfoV9AX6FfQN+fX6EfZx+q30BfIV9AXyMewp8fHt7fHt7e3p7hHqCe4R6A3x6eoR7AXqFe4h8AX2HfAt9fX5+fX18fH19foZ9hHwLe3p6e3x8e3x8e3yFe4J8hHsDfHx7iHwFe3t8fHyHewR8fX19h3wNfX18e3t7fHt8fHt8e4t8g3uXeoJ7hHoDeXt8l3kFent7e3yIe4h6DXt7ent8fHt8e3x7e3qJewV5enp7fIV7BHx8fHuGfAJ7fIt7hnwBe4d6iXsFfHx7e3yEew58fHx7e3x7fHt7e3p7fId9CXx8fXx7fHx9fYh8AXuFfAZ7e3x8e3uOfAR7fHx9hHwNe3x8fHt7fHt8fHx9fYR8gn2JfAF9hnwQe3x7e3x7e3x7e3x7e3t8fYR+D31+fX18fHx+fn18fXx8fIR7h3yCe4V8An18jX2DfIR9h3wGe3t8fHx7i3yEe4N8k3sBeo17AXqGeQx6enp5eXp6enl5enqJeQR6enl5iXoTe3p5enp6e3p7e3x7e3x8fHt7e4R8Bnt7e3x7e4Z8gn2EfAh7fHx8fXx8e4Z8iX2DfIZ9AXyLfYJ8hH2CfIV9A3x9fIR9HHx9fH19fXx8fH19fXx8fH18fHx9fXx8fH18fXuEfIR9AXyIfQZ+fHx7e3wCAgQAgO39uduxnpSL9OPPjouX+OCCi+qNoXu6wdu3u3aItZKO/o7K1b3on8y4x5GZwKa7xobEiajWqqrCs6rTvr3ygNLr7unQ69OjgNm9m7TEzcSg8+vvkZvE2qrcptOwk7bcnv+U2/6D9J37qYSXqr2klqaFiZqktazkzuiGlaCk8ZiAgMiImd3p1Pmm+onYkbjLoPeE27SGxKHf67nMwf+mwYHvy5CohLuwwo3Tu6rC3Mzq65mZtrXMwK6+gdvaycu3ydHM1/rlzM3o8e71+sOCuKqgp7nGtqayr6uhm5iWlpiYlJKMlJKChXt8goeMjYePpr+euvHWv4yKn5WWsZ6Vb4JygLa5bNSNlculZ4ple8KJkqp9o5J+gK3jedyzs57Ck9DFhq+Et/nKvK60qM+CvMiSpPqwzo/Zoc/88ve/t/WvrbqepryDyq/F5dGOlKzBmJ6EzIl/0M6LvNmBtre78Y/vlKmXeLu4uKGG4bt0c4XBu7iFf2hejJGotXbSkonKgI13gLKRbX+TxNBvt7+kgLqOsdvfcctwf5Wis+3BqZOrvL285JX8ubHKy9O9rb2ro4yC9vXhhZWluYmKeHDLuqOI1LqTZGG+vMa8saykqKiqp5yUrMOUh36AkXiFmp24gcHcbmVwlWV7kIhklpCbjKyPsZFjmNO0n7R+xcTI97JyoLGNgJ2nltTmkMiKmpiomNzQo8vCpMSGp6DAwcWuyo++fnGgunSTbYDKt22nhIGIy32focnSoKvAnqK8lvDYls+WxdOPi5zalLDdj6a1rduRhsyjwNSd9ZeMj5jZmaLPh4aRvcmX8LCkmrTuoqKojJKFzte4sKl/jMO8i46Xut+m0a2hgLe2lKS7iOvFdb6ju4PneoW1bMh8p5xxw4KDhHh4i6Sq18e4q7nvgcnDq7ic2uXhg52ioY7M5sPRYY+smbP02Pbx8dytxbycloC7x7fAmpSOwvX1v7uviIySVlJTaHByc2xtcYRMiYVubX52coB33neYU2CcooBSWHN4Wr6Kf4OKgKKQd4Oap6C86tOXoKGO6KDDopDJoJKFjP2K/JFqu7eOiX2JbrRmWrhXmlp2eoBsy3Rngol7oqCIenRkWpqofn+Pi8KscmumbHd5rG1uZpeBjVOkW1xdXFeljaeabICngIfOpYl2nXCxcXDFc6ese6Gkf3LCvJyLql93ZZVtc4yWgHfJk5jvy7yYk8b7hoOEi9zawLOkscukt/TMpq6CvZh/9aGbfcfOfdSHord7couup6eZhbSjnbmRdsCmrX6mjbbEv9/VrKWQgqR615uln8iSibHMmrzAlsqJrozOxo2u9Pj9lvK6x9m77ISEkrmZwc77rdSI0KTO0Mzj3rO0m5rRgLzYn8OepJeK68fEe3iH7NN5geGDmIPL0/rK0ZKYp4OX0X3Wy7Ttm7GEnGZ5uqnL0InIiqrmmZ6tn63Vw7bsitK5tcaqwbB3ZrW9oaS8taVwtbipZlqFk4GwlKqGZKmmheKAvL9933S0dWlweoRsXm9heXyLglitpLFcZm1ZpXlKgItVbZypkahfn1ePbKCZg7dQd3dSgHmyqHOBaY12j1OJjk9XUoiSjFeRkH2RmJmtp2Njb3yBiX6JXpSbmYd1iZGVo76sj4yfqquus6B+tqKntcHLxr3KyMa9t7KvsbOzra2or66WnpCRl5mdn5mltsOrwOnWwZumv7q6zbOzhbGegP/dgfe0qdW7gbOBlealssyImJKNib3qgO3Jy87mlNHPh66Ambumlot2aJ9nlJ12itOHqW2QgarPwc2gmMaIla+QiZxqk4qaxrOAiJ2xjJR6vnuG6+GVqq90ra+i1X77orGpjtfPzLih+tqFh6T2/+e5rJOH2tTm94/pi4njmaeVgOi4jJq0xuSO7+ziwd2k2uH3jP6OoMTFt+PeucrOwcPC7pf8ta3Cv8WypbennYmA7+/dhJusx5ibfnnYwquP4cWVe2/OxtXLwb2zt7e7t6qh0fTAmKOVooeazbv6ndvtioSY1oqaxs6F2sblzOfC68+Gw/bJvsyd09XQ+MKArcipgL68udvfktmbpaPArPr5utzfu9qUs6nTztHH6KD6q4rEwo60jJ725YPAm5yd5IGiptTbrbrRrLHKofa/lMaaw8aRgJXAiZ/KjompmdKKhdq13eql+JqKg4fckJTBkpOm4NqR9La7t7XtnZiqlo6AxMS0rq+LntHJkZufw9Whx5ahgMvJoa7KjO3SgMGqypD6iJnTg+2IurSH3JSWnI6NnLe76tW9q8P4h9TPudCs/fbsi7Gyx67v8Nbrcqe+rrjTscbDxbWQtKqRmYGpvq64qKCTxuffsMfNpZ/IgW1tiZSYmZORlq1ksZ93d4Z7eIR76H2cZnbByadrcJGXcOKTkp2hgLedm6WftJq+9/W5sLKj6putpJHerMGQhfqC9qSM+uGyp5q1m/2JhP6E2oGPkZmB7YqBnaKPuLijmJuEcaKwhpOuoubklITSjaCf4oCIh+W51YD2ho+QgYb8zPLqpLTToaHYrJSVuIbwk4WukcTBibm3jX/TzrGhx22Hc6t+g5qigIHQi43PsqR/f7zgbGtnaausnZOIk72Pmd7WqrCC0qmJ+LCzkeDoluugssGTiJO/xLeemc/Dvtyzhs+92Y6orODu7+Lhx8Krma2J0J2llsiWc5SlhsGhfM2JlYHPyZe/57TTdayFi6GEsXR0bYKEwLr8o75nt5WboJCVo5ufcoO0gH5sPT46Mi8nVFNnTU5efIZZb8xrZDA4Mz1ESSQpV0AzTS1LTUxUM0xIUi05Ny42QCtDLkFKPUFITTQ6PT9BIU5mZGNZZGM+Kz8/NDBBS0tBj4A7KkZJSSxKRU9AR05dLEYrYZMxOCNmMzVYQkVANComFRokLRs6K0YwMjklSS8zgD41Pkc7MD8eRy1CKiMzLUooQSopPTRiTS80NTErNiZHJzE7Ly0qTTZHMy82S0lJUj4+P0leb2VsTHF5eGRWaW95hJyNdnJ7hYeNkYZ1uanC3eHm7Oj19/Lr5d7Y2N3d2dbN1da1wLe2vb2+vbjK2uLR2ejcx5lhT0xGST5LT1xCgGZsT6Zpd5+ISVoyRW1ibHNOZ0hESGumZZ2HfXuFR3B+TWpjd5KBdW1URW5KaXRRV5xfck1eWHmjhYxoZoRcWFtYaGtIdGp3qa5+gJGge3lvqGpViIRPa31KgnZunmWvaF5JNldvbFtTkVgyPEJpcIRbWkU3ZmFWXjxlS0VyQT4zgE5ENT5BT1MvWmNgSGJHYmBeNGA3PEdRYoBVRkSPz9XZ/Jf4r6fDwMq2qLapnY6F/Pzrg5iqy7C4k4rtzrKW7tizqoLR0+7c08/H08/Uz7qzYoFjdWqAq4+FYVl8Y2h5PDcrXT1OXVdAbGt0XnJihGg2XHNnWFlJaHV1h1s7XGRXgEtDeLLSgn1FXGFrY1x1U4h5b25CXUBkcZBSZW6VW1NLpGFKUVRvh0syQVlamoKkqNTZscPft77Um8+KdJVgjIdZSlt6W3V/XVhvW3tOUHxtYXdDXikgJiFVJykkIyc7Q0kjR0JBQkJhT0xFYVs0aG5tTWZUUL2udlhKSDBoST9DgEVLS2ltQ1dTMFFOVk9xOTFVK1EgMis7Nx8vOTAyMjg6NioyPCckGzJWOCksaXVkNCpKaWZGgKP7g0hGRVmulKOgqJp9m5B8Z1iHqJaSVmpplszDkpCMf31+X42St8fN0M3EzeeH7cmLipeMiJOJ/42og5Xx+eSQkrG5itxHLTE8gDk4LCk4NC9ZXGdRMjM1aUVXOj5hVFo3Pmk6aUtRm5RgX1JgWItUUJJJhUlNUVFAh1JMWVdXhINqcJynj8DJma3DvfbamI7HbHByyHx1ZrWeunPUcXR4cG3NydbIe3mLhpPy0byoqWnLbmyGed7bn8/MqJbz7dLE74Whh9Cfnr7FgKDskY/Dq5x2eLXWXVxYV5WRhIF3c4VzfZdbWVU6RDcycDszKkRCI1NBQT0zNjhCPDQuMEA4NzMvK0M7PyozKDY/R01OPDo+LkUva0hORUM5QFBWR0ZXQ2E4Qi9XXy9DfHV5U3hXWlRVclBhQldCU0FhYFI7bUhCR0lUVFdvQkCNgnyGfQ18fHx9fXx7e3x8e3x8hX0JfH19fH19fX59hXwDfX1+hn0BfIx9A358e4R8A31+foh9BXx8fX5+h30Pfn19fXx9fHx9fH18fX18in0Efn19fYR+BX19fn1+hX0Dfn1+hn0Ifn19fn19e3yGfQp+fX1+fn59fX1+iH2IfgF/lH6vfYR8A3t7fIV7BHx8fXyEe4V8A3t6e4V6A3x7e4p8BHt8e3uEfAV7e3t8e4V6AXuGegF8hXqCe4R6Bnt6ent7e4R8Bnt7fHt7e4R8hXsFent8fHyEe4N8hHsIfHt8fHx9fX2HfAJ9fIh7Anx7jXyCe416g3mHegF7hHoFeXl6fHuNeYZ6BXl5eXp7hHoJe3t7ent7enp7iHqJewR8e3t8h3sDeXp6jHuEfIV7Enp7e3t6e3t8fHt7fHx8fXx7e4R6iHsGfHt7fHt7hHwFfXx7fHuFfIR7gnyEfQF8hX0EfHx8fYp8gn2EfAV7fHx7e4x8Bnt7fHx8fYR8Bnt8fHt8e4V8gn2MfAF9hXyCe4R8hnuFfAF9hn4MfX19fHx9fHx9fHx8hH0FfHt8fHuLfAN9fHyHfQF8hH0DfHt8hX2MfIR7BHx8fHuEfAx7e3t8fHt8e3t7enqFewZ6e3t6e3qFewF6jHuIeQ96enl6enp5enp6eXl5enmFeoR5i3oBeYR6A3t8fYR8hXuDfId7hXwEfX18fIR9inyHfQh8fX19fHx9fJF9Bnx8fH19fYp8AX2FfAR9fXx8hH0IfH19fXx8fX2FfIV9AXyGfQR8fHx+h30FfHt8fHoCAgQAgKiGtLqmqKKbwsaTi5vLm/jjnba+/n+8kqWBqtnsv5WOw7bHpbLZqJvt1Z/kwLP+gIyp5O7FgKb66dDPw4jg5cbLgJi1rJ2Bh6rTn8+px6XFprib7++cqsiVg83o2uGN1rqtwMKWm56Nqqqyvcv+w6qVqpSW3Zn1ntDg9/Oeh5aNgKjlupb59ILU18DEodvK4diu8pG3msf8pfXxw4Oj3IHX74ri06Hy1e2tipiH4vmysYedpaW1zviE/9nDtsjby8vThoGos4abnJKU+drstvq7lKScoq2rqqainaKhmpyXkYyIi4qIhIF+gYiLg3qAiJSMgL6ruH2QmtvCdIiN0KSFgIa6dp90t83Se8XwwcqImMXApovL/6Lf39XO9XyLiJGUraybqL7ch7uyjp7l/pHRieyHk9PTps2fkYyMspTEuMOFqrvewdfwmpnu+IWSjoecnK2p1b21p8zRtoyGqP+JnYinoIS3j5eDipWsvq+yk4uIdWWEqbJ+c4xzucLXc4XHgJzIkG2ghsRoqb6vq4d/pWZrbYd/oKyP1bx9iLPoc2/QgM3MqMC9utG/wcG7q6KQjIHx5fCevJ+/oNHIisVwyL16jFx30resn5mgpaWyl5mTs5hsZmCvvaprcYNmkYBwqLCcd45ar5OVoYaQt19lsWetcpTdq4pumKHwb3OHpdOHgJ+SoH7F6YCZi6ielpKPkqzKotmkrtCe1bW2xKuxZ3p4iLp0cseWinGXgrGY4aScyoLC0rqhioCVo4zSkZuOrdvY6Nrm/5mn18mAjn62kbuofILbs8+XsZiKg+2uh5m5stOF772bndv6gKd+4/XDoLuFxcZ6iK+o5JSh1LDQ797sgKaewsCj1J2ts7HAp6zGeMCus4bZm4OMk+fIe3uNsKzFjYmft+Cdn7nKnI2y49+Ph43dpKKPg6OTrXz0xrikt+PUso+GuoWvtY3DkoSAoYCP0bWx6rfUl4yVnYCEW295a4FLTFSPhYFupIWkq4SwhcmdzKR3VmlQWmRWUVRud5F/gJCbwMONmKiDiLm/gO2Bl5zjrJ6C4eFxvp6b7KR3kpd4cHmJaqieXbRudGimg5KBba20cIB3u2pxvLNaaJqWbYeHj7GhW3+3scN2b4l8cJ2SgJSjoKRhX1dYj6tfYmqskZPKk4VjY6G1vKuLyKJjlZx5o4upl5CBmb52Z7WNnrWIgHSN7YLFgpPj/4rXhryUmKyX38u/kaenn9bFtsCvdtKkv76sr7eTnJaclK+o3K3Pt3fseJ6XiKGeo8uImnSHqWyLk4/Kua171pmaoqTSh8qqjY/Uj87XyJSpjIaHqJay+sC7iJusu7iMprm5jcKTprSRgomj2N/I5fCi5aDzsp/XgKBYnqeSl5WQpZ6JkaC+l+3AiJWx54e6d7aQwefvsG6Ixrm2gX+ignuypX3EuqHHd3+a4dC3d43J+NfDuYDA7LCJXn+OhHRZXpK0j6GbpXOQf5pwqrx/oLZtZKuel6xd0YR8rKh8g4NeaXCJe4ifhGFmf3t0pV2maZioqKlhX2RhgHqcgWWgnFOQmYWHdKCMrX6QynuAa4fPe7Wgbklom0+Kl1CLnH6mmKeJZmhqm6F9glZlaHJ0lKxcsJyCdoifhpWgaGSChmFxc25vs5OtldzBoruyucbFw8G8uMDAubmzq6efoZuenJaTlpiclIuQmKSfdpmNrYiqv8izjqGb7bifgJvhj7yKyNzylPPq0tORoM/MoJjg+7nUzvXb+4edkIuLm4dze4zEgKuggpra9YO2esJtb6zBm7GAfHx8lIKjoax2jpOrkaGpennR3neDgXyNj6m54b+sjaXBs39xm+Z5mXmyuaLZoqqNlrbY+Ojaz8rErY+U9fiMmq+CpcXmhJ7wgMn+tInCpvqG0d3Q4Kao14qLiKym3OCv99CIeuX+iIXlhtDMp7+5tMq3ur61pZuKiH7t5fWix7DIs97WkM510Md6lW6C5MS4raetsrTApaqjzreknJzr69aWlbeHuaSP+fHjsc6D6MrX3K3F9YiT847jlLD51LCFs7n9gYiZu9+ZgLmtrIbO+IygkqmtsqmcpcvqseuzvOGw4LC3y6++g5KPlN6LjfHCooetmMup4aWg14rR48iumIugrZHLe5qSs+nl4eLl6Zikscl+koC+j8y4hYjjq86SlYSGed+2kKzBy/eM5rKfqNf6fbCB4fLMn8mU3dqGlcWu8qCk16zPzsD1gLCbzt2o26W9sb/Hsdbfi+3N16TstZidpvndjoqXwLvQlZeju+mrqr7apJ7N/v2dmZ/8uLmhj7mpw4v/zKOPm7qxlnl0qYKhrn+npoh+o4qa5r6+9MPxsq7G3KqqdpKfjalkZG+8q6Z6u4qkq4qqiMCUzLOGaYlqdIJvaGmFgaOPgJyz69GOqaiHmejajOqHi5HHppuK7fGAzqWX7MqYvsibkJiyhtzghvaYjYDXm6WUgN33i5uM44OK8fB5iL+geZiendfVe5zz6vqcjaikmO/Nwebx8veSh4KH0f2bnqLRwLLQmox8gdv87dOE+rhur7eIu5y5qqOUrtyGdM2isMWRgHqM5HyzeofL6XvSe6Z/gpGHs6SXn7Kunt3YztrDjOOvwtnEydimmom4srii7MHd1Yz8k7G0oq62wu6TpIijzIWSjaHPyb+R66O0ma/yl8WHeXXDh83X2aiqj5KTt6bN/rC2fHF8kLSGl6CWXJB6rKyGdnqQw6+hzMVp0Y3nh4HFgFkzTj4zNj80NTIpNT9gMHlvYmSUgSwyMC4pPD1KQzMzPkNXRT5ZRTxiUTpcTDhSJzZGSWY5Nz5bPz1APjI7ODVNPDFXQTQtOUhDMUVDT0BlY3lIZVE3O003M0tNW0dJVEhceGBCRj0uNj5BSVNqRTEmGhklMh84MDZFNEUnJCc2gDBGSi5DSCAqNzwwOjQsGRofOSEwKEdsO2I5Qi40OipAMSgvMzJNS1olJzUjS1I7NS1ARFVTdYFGin9lWGd8ZniFWlVyZ0daXFhajnCPgs/Ds+Hc5PX28fHq6Pb26+/k1c7CysPFxr26ube2saWvwMrLfYp3kGxYTlRCMzo2cFg+gERiPVE+b3pgPHlnWVtBSVxjWkBaZFimsq+ctU5jVWJ4gmhfWF+HX31fU1xshGCAVolMS4acYHVkWVVUYlNlXWNJWWxtcHx9YG7F12hscnR+gnliaXeJbnuNdlJLbbVjbUdYSzlWR1VcYVteaXNnWmZjYEdTcHZCNEY4VVhqPUFigFhjSjhVQFwwUWpkV0VGUCsmLjw7SVNFX0w6M2LPW1/ffM3Ho7u6ts25ureypZ2Nj4b78vqgy8fq3fzqnOWB7diDvJCJ6M/Eta+6xs/dvb27zms3Oz52hHxEYm5ASj5AbWJRUmw7gGJddlpieThKgkJ9PlWHWkxCS2aOPiBFbapSgFlgfmadq1VgU11oUlJbXnyDcoVgTVZNhpysuK63T1slVYlPP3pyXy8/MVM/dqSj14jc69C3n5GnpYakW4loeYqHkI+Pk19mbXtNUDxOUlNNKydQVVowNjo0PmUkHTpER0QvUE1EPl5MPGxCgIBmXVAjUIJX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f8d7cmttcqGywHh9yLxoe2J+Y2J0eHuZlZh+k3RopqWndGttnY6KjIGbVW1naa1dfI5aY2Z8bZnYnpJ7X4+ktMOApK9ztJaGtGlvgXl2h4y3ftaJVZiviIKj7Lf2fOn4oK3Exr2xu8C+//qNou92eJCrmXHPuH/Wu4+buo/Vr+2gs4ma+I7Fj8eWh3q21YOxdrOMuXuJmm+51Xyu1+bVx7GfhsV5zIyk/veLlevfdKy1i9yCi5XNmqG28InHhKWWzYgW9+/UxZOEuoTJ/su/ydLR+8n6kI6Zw4Djq7mVfn21epidlqeg+OiOaph/m5ufyv/itc2Xz29xiJZ8pKKZXouSj7V/yIyBg721l6jE46PJwcK2haBtweG6m2OrpK6dW7Bfqbdbf4Gigl2ToXGnfaCClq6TmqCondWJj3WGho6LlYpOcHl/kGZNtIhhoYRdnmGNbouQoI5je4CHXoRgW4ytg1OU2oiRhHVdenhzXpV7aJ5qsEx5VpGGVHeQt7e+kZmNZ2ZunXqJgImSlFlqaF5+h4ZmpoOar7BouGSdt295cH55amtqxcnMu6yNc9jS08i8sbi5uLa2trGura2gnKOYmJqVlaCah42Sj42lo9DT0/aK/bm3squjwoCmweXf28Oaua+3rvayt6Px0rKs14V0f9J4hICApK+QpIao3LPi763jhIPBg7rJ24d1poFtdG9al4mGkpu90KOwwYmXlrV3mXZ+l6yruo3BeJT9mZD61qKPopbBoqSIq4iXmpX7yJqurqbQvdL868Oq4paciZiNwrq7joiquJn9ooDI6ZOanrj6lpTc88LtspvEkIqsmODZv8To6XKpyqPIyKL7gsyzr8bMvcOpzsfHx7OkkoDuqNe5e4TLln7T09zE54xmvsnGzs2wpaqupLWvpMHIv6yZ+ejQgZbQyqD8mJKT27HT3NDbw+n6yu3r/ejP25v+rf/ohqvbhf+D1biP6oCl+b/lnLz+jbvq/by13NmVg7Kyk8jEp9aDt6KSpdaOptWLmfPKsYfmm+WG3vit05/nennaq76s8rvS6brkxNHt48/3796Pn+jUmdzC99PS8OiAf8uAd86MeHXmkuC9rdPItr+yo5rg2IGC06z18ti669GG7Nui4ouryLK3sMWV0YCf0aG3y6+3g6OarKSdvr/BusSNsvW2hPDlr+qTlMys1dSQltPXxZ62goPzjbvOk4Ct3bGmgdqlu8m2m46ekIuOrtGOd6ucha+ni6CYx6H4/6CA0ZGRg+XQ5dZkcr+srcKZZWtowqqlpoG1ptKDsaaovnl5fJaNi3iCeH2ZeJSf/YCEjeaTgZiTh52Tt9rS5Ia5z8aymoGQva+7hJTl8o6TgvWbpJT6gIGIjZnvjIeAhITQ3/aOk//ugJaBo4J/jYuGqam2oMiVjcPDzJGOjNfLzNnI8IOmmZn+ibXVkpuZpJGw4qKYm3vA6Oz6kMt9xrGd0n6El42Fm5/OiOaeZKO0hYB+ldus6IDh5pOauLSvnJ6jpdDTcrL7gIuvxbOG89qG6MekudK09rn6sb2ZhuKQ0YzgtJ+Nx/Cax4fXlsGFpa+Dx9aCwuL05NjBlIbSi+WUmOPek5LS9YK/zaH6lKOk5q2xu/eHyomoncx41c2xooZ6tnagwLCXutymy7PGhX+NzIBhXFxKMTRpM0QwLTQ1a0xDMmVUY2E4N0pONjtESSo0ODkzQks6EychOFEwVjdER0VAMytHZ2hpVks4MDUzS0lOUjlcdGFRLlI3Sj8vPE9pTlVwTC5QPldCMVMvI0lAWmZkU0hGLy43SVVBO0FKS0EiPTIkPUAZRDM1KyY+Tkg0M4A+L0wpNEE+MSJGRlQ0HyweMCkqIDxHOFMuWDQzOCE1MBghRTQgHDggKS4mMitBPTFOQyoxPDRZZ2tQkGZ4i5BXnliDjVdjXGlkWVlZqKyyqZ+OgPz8+/Dn2eTp6+jj5+Tg3+HOydHDw8W8vczFq6y0uba6m6eEbHA+akVFPDw6TIBASVdQTEMyPzZPUGxGQDRgUlBXYT5AXKtnb3Bnfn5sflhhi3R7jHemV1NuSXeAjVtVc1FNYkM6e3NlZmRsdm1wcF5yaZVfeFljiqydmnijYnOVRj6soXZqfHePWl5ffGJbTUFpRzdRX2BmVGSEaVpMX1BcTlNEW0VeVj9CU0NrRYBdY0BCSEpwOz91XkNVR0ZJKDFDM1NXSkNlbDJieU55dYn4gMexsMjPvcCjysPCxbirmon5rNzJkqjjoI3w8PvW/6CI89PW6OLFsrjGvNDGtdNjMTw0XWlyRI2mfmFkOzo7U1Jham5vcmJ/fGJkfHpnZUVhXY6IS1GFRJ09hnlrr4BcpHWfWG6iSFptW2JYpXlzXHBrWmR3Uk1OoZyRp7lMaaJM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c3GDhY7CqP3wkJOu67m3v6yq5eOevLOJr8yGr3+mnYjl3Z2De42tjIZtVFNMkZtYY25mkF7GnWutr4qtYbTe5eiZUUt0WWNub1Rnc8eA7qSj1uiC56Ho0byTeXHK+OOx1LKOi+iLlo3Bhp7JYGlqWFacnqmdX5rMmJK3p6Tac821ca+ewcSNg3hZkXOIcaaafYqpZ2CGgbO8c6xio1qSlp9bWGGmV1qWaIdgYmRhie6ziJJvqaenypq/mI10XZpZZ2Vjb2Zznmmiep2mboOAzJmuerRxp5K5oKjugJmXhJagpcuI34x/o4/rpWeWonJ45oSdida6hKe2e5rcm5CB5darrNTPftPNooFymMmb3IqXj9zWvMjv7oLl15iBoqGQgoqVxXrjmMe38LrFyIjKjZ7XpZKq/K2OoMqBlp6g7q6R/aiz38DVjpGXn/mzvqSAvauOs29wdc2gj3Wcg71qaHB7o7J/n8WGw5t9hnJvp4ypt6q5mV2LibKNkHqLd6x9osjX7qB6lH52e7Rsh6vFtLG7YHWGvampYpeqjpxua4xhfY5bW2XDjKKWh3WKgXPI5b++2MaRyIB3nXZXkGF4Y9Rrk3Kboo5smpNlhJR2qIaAmmdYZJ5ec5uRcI5YjX9nnW1plFiVk1WZnIhLeJqMWZ2Wa4teoKeUg2lsi4l/X4pjanmFlVhhZWJNb7NrkqS7lp2nb312eGtnYLVvdHG5ZG5zareIzMK2sa2wq6qnrraso5iWlqmlp5meoKCkopyXkYF5c8KvqqyHj+Sqkurbp6eAoJW26tjCq/SP3LCUy8Ty4YWmiYPzboeVe3eQ06HDhNex84aFpuiQx+R4c5a9wn+IpXx5yL55tKKfmrStx+HIxLW7XqCMfnqAioaCnL+knba5uoPYntiLhM6FwL7Hqt7PbpXn0rCLh4jc0ta+9pDjg6KCs4Cwz7X1gsyeoKean66AivWpwI70z9yY1fyegcPBoZn1i8/Rx5e3y9ncno3iiKeHt5TA0a6xyMC8v9S/w8W82sadq3t9vauxz455dnqAe3rFw3BxyLrNs6uv17i1pqi97Y3FuaWd6unOlPiBgImE9NnR0b78zMG/4vC78P/7gN6K8qmd1K+NxKzHzpyEtLGAopvGy92Jqse0usPI1eXWnKTzmtCmnNyG5LSmk5+UtauS1pCD9prK2P7W9rDY45WSqN7lzpSTn5W3mICagqz+us+Xi9ChnKrR0ebNqLvskPSynoivk42hiLG8p+ybq9jp1K3vxsHNo4Hwlvu9y6nYn5Oq9O7U7Jmk0qXTrp236d2AgJLJi6KZoaeV6p+b99emw6igno7ohoT4icyBjNiV1pyXwrGa0pO6hc2Swp7q0YCsv5GMiYKQnKPWtvnrlaC20qedrKex5NuSuMaayfWXv5S1qpLp7LmemazPsq6TcnFmushzgZOGvHrys3OsrozJdbbI2ueqaWOXeIWSkW2CieSA96+22v2V+6fr4LyfmYS4486uzbiVhfKXlZPakrjog42MgYHq6OHagK/XoqPV3en/hPzuid3J7u6tp5tywZCmjsG5n6LYlICul9bejNWA8oPU3vuNi5L2hYrdkc2PjoWCoOyxj6yU29fW7JzPqqeHbLhue3p2gnaHt3W5ir/CeYiAxJemeb90ooupiZnadZCOe5CSlq6B4Y6Ot5/zwIGuuYGA+5qwmfPFdKbPjZnri5aD2dqyrODtkevuvpyKr+q25pSZeODQxM3T2n7x6KmMqa2AbXSV0YT9q+Pf6N/m+KPooqbkoJqv7r2GoLd8kY+ExZh9x4uExMC/h4V/ifehqq2AQ01YhUw9TGBILiw6MFU5PElNanVXZ0wpSTEnQBcXLSxPLyc5UB8aFz9ISEA9M2A0NTo8S0NKXEY1Pmg4OUA3NEd3OURSYzxILU5SPT0zQlxCPkg1Tj9WP0NRISJDTi9mXE1ZekkwRDEtZl49VTdMSWkwUDhHJzMqOkA5T0AiSyuALjg3KTUjLjdYSFc3HBgeQzkeOS83SCVvT2ZBRDs0PDg0KickKSAgHik1OyY6OUMtLyo0LCEmLzwxXI1XdYWffIaKWWZfYFpZTpNeYmGcWF9jXKiO7ejj3dfh3dbS3+vi0cK7vdrV1cTO1dLX0s7FvqSZjcOFb15ARW0+PWVSQUCAPjZJUVk/MVQyT0UuSUFOVCo+P09+RWl1Y1FneURJMWBMfDlJWoktaI5SVGh1e1ZcdVhVe2xAdGt5ZntybGt7g39/Q3VubGdibG1tkKmIf3qKbD1neIxSUnxagHdnYIGCR1NkS0Q1LjNuaGdVejhbOEQ3a0NpfWh4SnVYSD0vOTaAN3RISkBvZ2xJa2Q2LlFTSDlmNkdPU0o8T2xtV0poQlh6j5vMya+xx8K8vdK+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9OeTgtSM5aOYkIWKr77UubuleOKTodyL3562vMLmf9HLxKj+h8uK5oCJqtjdzNWpe86fvJ2SwHB1j8zGvH+AiJvflHfHgMqd45HZv4Ol13epj36Ff6ij59fqvn7fr8vad4OjgZKuvrOIwpHKnbCcpsZ40tt+xYKCqnmkoHF7t5vixJr/obLpgqDzpMXP1W+Le7mWuc2HsKDosYCScabPrICZeGhnUU5PaY5wbpxtlIdtZl9HhJKbvo+iqIlLhnKIU4NRkqWigIaxipmFipaM3JZ9sqp7kOCnvM3Cmoa7hYB16Y7Xkq+SpK9dfoyDiWZ1iYtxvbSkZ7zKdnWembizV1xxUFBfp2qWm5eUq7GpnI2FlGBZaptbWapfU1mOW2hhXJ9/kGmur5rqoH9iW5xrzoCRl19zeadsUZtcZ1VihY1klnxafmtmgG2agmt+iO2HiuCG0fHhl4Z9vpXTjIChjueFo4ypoJ2essaIfoHJ9HylqnKll8/GpYyYkqnen72gunhvqWqre3eslYea25+Zu9d2rYfXjajCtvTZ7bTVmteasI1tyXZvpryIpqymlcGgp/S05Yyg8Kai4vTtu66or6mOz8vF66aygKCViYzSpK+cqMyGkoTEmXqGj7+Fl6OFfYaXbWlud2aZa3x9t36Ea3WPkJmOc4Gig8e9mMu+eWirZ2KNZ3WG226YXFmqp4+PnraNZ42gg12YXmBrnJOPgoiDgZR6crSUioLp3ILFb8JlcIpPlYpto2NzjItvY4JvS3+YXYWFsqeUgJh7WYuEaGSPrZVTXYOvgliPvYmOjpV7ha2So6FzeYZ6kpNyipuLp46fXl+CsWSibFlmbYaKpWpqm2CAoVNRl6piYGd4fn56Za63bHt5anBsc3JwyKh6w7iosaioo6qxoJOZpaarrqywta2jn52PkZCJfW/HurSegtWPg8earIfugNjQn7extYb+kuOWorKwqZ2Crqv0ocrGh8SEm5mpq+eK7ozuh++92cTJoJZtdItpk3VlhdOucJKUrqbDvLXWwbKnuXJ3qoNnraWpeXKNdch81aespsbw5sPDzO3wuarJrb7gu6aAioyJheDEybWI8MyI3OzI2Ly4ca+u4IK9moeogOqg4dnZ1PfRqr+Iltivr+m54pCO1Na3s9LCtKWYdYCp9IG+pNm/tsLNvsO/0c3m1M7X55aWfbqxqquWj4eAfoCHd+SLesDieOTStbGmsKCjy6f62IyE9IHDkdHNiJGD9+zegcDlgOLniYXZsoq+/uiGiJP8nceT+4P14eeqn8eXgJaUqLui/t6/84KBh5Os9MaU5ra/9tmjq4/OzqCrlI2ZrJKaydSOoNTsyuDLjKeol4GSqL6Ph4ivtnvT9+2biNuR/bytoo+Murzpxs6xgOeVlNx+15+ytr/ahtG/vbP7ktV/3nuMq9bk08q+iduMyq2iwoOWq+7n0IKPl6LMj4LZgNei6ZTqzo24443Gq6CnlM62/d/1xZD6v+X5hJS5i6G9wLmU16TZpcKls9KF5euO4ZKOvYu5r4OJxZbouY3zrcHegZLyr7e/14CZj9664PabxbTqt4aUfL7Iqoe4oIyJbWlsibmSksaFua6Ke3VesLSer5Gmw69jsJe3cK5oucq6gIi6laaEnZyT/7WLxcqAfMegrcS6moiojIqH+ZL/t+XK5eqOwMm0wIeGmJ+A5+jlgO7niYfFxuvhcHaSbGl21Iq20Mm2zvbrs5yVuXN1jeaEgv6Rg4vWiJOLjvixzZ3k163po4h9fNGE+4+erG2Ikb+Cab9xfmpzm6dyqpJwk311gHeghHCCf+J/gsp7q8DCj4Z+ya3PbG6Yi+eDwKq4sJWmt9idn4Xn+Ia7w4KvjZqlnIeVipLTwNK8uImE2oPIl5HJoXSS1Z+IqNCCvJPriavPrN6w3MjFrPiuw6eJ5YmDwtyPpKSmnsmfmOqoz3+E456V2b3CoLKxp5J/xLax0Jq/gDtKZliDS2xoZl4yQDpnV01XWlBEYWQtOUBFLjIlKStJLBwsRkhRIx1BQzlBPENSL00+MkBiUEdwRDtKQkRASS5DMjdgRC0bI0hCIR8fJi1cMDEjO2tLSCg2IzY6P2JBSkB1bD5VN2giNmREZzM7bkJTT0BFLyk0HEQ+G0w9Si08gDhHLDdDJyUyT280J1Y3QzhIRSIsQi8uKShIUzscICw4RzAeKS4mKjV0PioxOixWLSYwLi83OTdMhE1dbjYzcYNNTVZkampnWKStYGpnW19dZGRgsaCD5eXS3dPTztrrzbi7zdHb2djf5eDU0dG+vryumoTBnXdkSHRHOlhHSzpygGRXQ0NAOC1VM1Q1MDs2LCwqOEWcbZqXbIdce1xWSV8sUC5qVIRnUVZgPFBGQ15JaVJKTZBxSHBvg2iMb1xmbH1lakNIfGpQeHWAYFeFa55Tk2RhaYKRiXV7hJ2OZ15xZHZ+ZFs4PzY6QGtiYU85YnVEX3B5gnWAQVtQdkBIOTk7gGFGYlRrYVRPS080PVxJT31TWDw9cXBhVV1XXU1GSVCKdEqrjdK/r8DJvsW7z87o29be7p2cgcLAvLicn5qSkZKYg/avn+P8hfvmx8G0w7Ox2WZaWTA3hFVcVFldODg4cXNuRmZrN2N/Qjhzbjpzd18yVDdyUV1UVjBqZ41DSYZxgFtPZ0xYl19VlkFDXl2D5JNQtZ21oG1ddD9lr56wlY2XsZaHS3plXl1fS1pVTampmYWdt8qSh2xycl+v1shsTYxYiGlrbGFldXd8fH5mRJFLU1sybV1yfYtNITpAeIphIEFGsltGPn2LZzY/NWg7oZJwgjo7PXKCh0Y7PVCAYj5OgF1nj22QgmR+lzJmV0ZSOnliW0BbYj5vcXBfKilAKycuLyAkPzNFJiYuOW1Tj1QlTykgJyZSVC82V2h0fXG7X3fIf4CRVI+TkjxPTo5udXNNka/Cj3CVht62ppHl1rmzkYqPqui7v9VZfLm0n5WB9OOJjYGi1uGE8dP8meyI6fHHgFE6NDlDLyoyXUI3YV4wQWxJTlg+NjtIOT41YC1dWaGGlKlce3xsdUlOUkxLmYyMUaOdRkeCnOz5gom2jYeU8o7Kz8O+4uvjv7aosIOIiK1nZs5pYmisZWhnbtaouHPN26H0w6qUpf9j0XC23Iqts+eghfiRl4WMuMyAxa2OspyMgI6qj4KZet53ecF1laSzm5aOo0ePVUhGNFQ0UUVCPTtdWls5MixHUSpMQSg9QVFkX0E5PkxUP1I6SSwpQCEvIiY+OTIuVEVKU0EdNCZDIjFMXXlqaD8/L0s6S0A6bDotNkJGYVdTRE1ITGlhezc2c0UyWnWWX0Y7NC4vRU1TTy80hH0CfH2EfIN9hXyFfQN+fXyFfQV8fX19fIR9h3yFfQF8in0BfpB9g36KfYR8Ent7fHx9fH19fX59fX18fXx8fIR9BH59fX6HfQ9+fX1+fn18fX5+fXx9fn2EfAd9fX18fX18kX0Bfoh9Cn5+fX5+fn9/fn6If4J+iX+Dfp19hXwKe3x9fHx8fXx8fIV9AXyLfSN7e3p6e3p7e3t8fHx9fHx6ent8fHx7e3t8fHx9e3t8e3t6e4x6gnuJegR7e3x6iHuCeoV7iXyEewV8e3t8e4R6BXt8e3t7hXyKe4J8hHuEfAF7iHwHfn18fH18e496g3uMegZ5e3x6eXqJeQV6enp7e4Z6HHt7e3p6ent6ent6ent7enp7enp6e3p7ent7e3qHe4J8insPfHt6eXp7ent6ent7e3x7iXqJewF8iXuEfAd7enp7fHt8jHsNfHt8fHx9fHx7e3t8fYV8D318fHt8fHx7e3t8fHx7fIR7Bnx8fHt7e4x8hXsBfIR7BHx7e3uEfIR7A3x8e4Z8g3uHfAN7fHuEfAl7e3x8fH18fX2IfIJ9hHyEe4V8B319fXx9fX2HfAZ7e3x8fH2GfId7CHx9fHx7fHx9i3wFe3x8e3uNfAR7fHt7hHoBe4R6hXsIenp6e3p6e3uEeoR7gnqNeQt6enl5enp5enp6eYR6Bnl5eXp5eYZ6DXl6eXp7e3x8fHt7e3qGewF8i3sIfHt8fHx9fX2FfAJ9fIR9AXyGfRF8fHx9fX18fH19fX59fX18fIt9AXyIfYV8BH19fXyEfQZ8fHx9fX2FfAV7fH19fYh8DHt8fH19fH19fHx7fIV9hHyCfQICBACApvrr3q7nrNTWtuf575yHwtPegrHLyumapau7+LX8/uaSl5/zptWJ8IGb8Law5J7xu82sp72Bi5XlscmugYjY8LnNtNPmzdyUkJbQu8OoiaaLvoOM4OfC186bnYaAncnYsKLj8oCH9L+whI6op7yL6ozgmdiPrp/CssLUyM712LSAt9TGyumJ893G5YKGtcG2w/bjp5Skp5nmgdbFs9qB8p7t4a2mrc/Q0+KVvNTfh8yan/2Au57Hm6Suyd+Cio+Dn5KNho6Kk47in5uUsOSWguH+k46OhYLLer6WlpmPi4eCgoKFi42CgIusr5mJgXxxbnNwaa1bq6KccaenqKSYe6yAoqRrgZWHobmYn3yajIaei3OVjOmxs9a9iPukzdHO7+7uhb6fg7GpnJSktc+Mk9640piqt9ys5uHXt8TQqaHDxr3A6bOk3rjM+824jZCiio6Fh9H1lMPkvYSAhq6tg5GzlniwalzMiHZvteyVjZ+42HZ7dIjf3ZKioZDsoKjFjYSA06SHsId4hp9/unW3n4p5yt2kubh+eXiMy7jaoKN4zqzB34yuztOwu62JeoeXkoGOmauvrJTVoJmXkZKLhHp+h4GB6YefYZeBccO6x6uxp5GimJ2VrZJwg3ahgbmZolmJlYaBhKJqgZl7vbmDgY2jXHOupaKexn/XxZqdxbF9iZiAk+F9uKF7w6qptMPFouL18O7Fl6zApcmxurWMpLC6sZ+ikvKXeoO5v8HSw3F2tt13eKzIcs7f8bW0jYSth8iQ2MibhoB9p8fGvM17z4O1s5n3ls6Lst/SgLqui7K20szAjqd/27aMj7DBwo+2x7Vy3KSLoahtxczS68G7t+7DpX6AkH3QvLW8znyOgaDRor/QvZbf+suEkp6MmYXOn3yoqaejc5/U4aPkvdDA3q2ggId41XmQtrfA25WB+N3YrMTetcyx3JaCt+7GuN31h+KKeaSY3P+DiOSYm6/CmphkZllrfE2ScoCInqd1a5BHfnd5e21jYl2UYn2DaHySUU5ncqGAYMujkY2/fdC2hJd2iMinpYey2bu7qqqAd4qh3I6UgZWqo52Wr4eNx8GhtLtwwnHMwmpxdICuxFm4Y4FTgWBtdmWcq6Khl6qloIeedlF7mV2Ajn1fWWN8hn9kV5JTXr63s5quhVhfWGh5pF+UT1qLm4uPkVJamnRyWmWrr3abfWaAjVtgbY3W+Mb3r+fgiKjMnYGKko6fk9W6m42BmamNgsm32IiEwKCk2Mh8+uqG1vCZh4+E+Y+Km45retG3r+ptaYOsz4SDp/nCpI2nnHaAo7HqvceP44994OGvfcWyc9PhorudlMN8g+yVhqXEyoODmqWRx7bOgNG5gIPgjIT1qt6AqvW9q5XSo7i1nsXCwntzoKO5bouYpNBpdoGJwYexvaRebHe6cJlmwWuAxqGOt4P2s9CzsZxgY3e3l6OFaGyuvoKBdpiymZdyfniUk453XX+Dj1ddnLZ8pIl6gllhicXXspa0wWxyw35xTlpnZIdVjHTAg5NXdoCRjoOUoKOpooeAh5mfna9kv5GDj1VfiXyNkZmcfXyAhHivUnt/gJNkwWuPkn1/j5qUgZVmgpidU3pdXY0/ZGySYmd2iZNTX2RZbWlnYWpmbWq1kJGLkrVzZ7bOc25vamuzfMyorLCppKCZnJuco6mbl6W+wa6lnJOHgYmEeMttzsO6kNnc2di7luCAsqGDlZGYvuC1tJCwpqO0nYOGh9aSg6WKZ8VxhqXR+/jhapiBdpyjkHZ6cIxndquZmHZ3fsWPxsC/m7bQqaSxrKet2JB0pI+UtZyScnSQdWJiedThmNf204eGm8/Nh5qlkILMkYD9oJ2XzeuSkKPH7YGQhGrP3ZCKkIj4ob7Eo6WA66+XuZmDkbKi2pDyv7ad4cqpycyNk42r2a/ZpLOA39Xo97/N19u3wbKLe4ucmYmXp7rAu6HfoZ2WnZ2Qh3yCi4WE7YitcqOFdczB0ba9sp+xprOl5seGnYmpq/7p+YXa6b29u9eOo9SX8/ueqqfthovAwda41ITx8Lur4M6WoaKApvKU1L+c6M2zwc3QotDr9PXFlKvCpcavwNOUoa6+tKKlk/OYh4m/ysTp1YKBu+Z+grnZet3u+6GTj36jeLKN2tGumJCStNvYxOKI64nDvqP5jMeJrNfJere5iKiw19vQmJ6A37CFlLXOwJ3J3r6D56qCpc2C2dbb/uXguenGsYWAoYXd1cfP3oahl7v9xtn64bL2/dSQqr6yrpTqtYmzubCugrDs+rTyuN/Q2rKjipOF4YaiycvU8qCL+t3aqMD23P3M8JuJvO7Mv+38jfyemcSp0eyGiuuZnazRtLiIkHmVn2jFkK2xzc6bkL1gp6Ghn4qDgnq8f6SsiKG9a2eDjMCAc82vpIvThOHTmJqCmc6XmomzzbG6q6OAgY+d+Ky3qczj4OHR5K+1+e7F2fGH94jp8YaGiYrK8HPvgqpvqnqNnYHE1M/j4/S8spK3jmqm3oGqwa6Igo6hr6WOhOWFjvv9zZSwkG6DfpGauG+xYmukvK23uWdquYmHanO5vIq0kHeAoWxrdZHT8MT0p9bZgo+5lYSSm453b6bHoIB9rbaPi9Gu3JqO2IyM5eyM+v2M0+Fzf6KI8J+brqKGj+HOy+6LhJ3AyIN6n9y2rIu3s4iLsrHUs6135ZeD3eXBj+DXjf3TuNSjkLyJieeVhaPCwW97k4d1sZyscdKZbmzKg3Hlp8iAOGaHgWN/YoOSeG16eUk6Ok5UJ0BdUnI3Qk9FeDpfQ0EhMy87RWI1XyonPjdNRkpIP0o5PF05ODdeQkNHREBZWlVOPEJHPDw0HyFIKSIqJkRBXD5HXGZmUEtFRjg8TGZvW1tcZy43V0g5NzBCVFJEd0OEQVs1OicuL09fVU9aXUaALFBLQFotPz9PWCsjJ0ItLENKMB82ICM9FyQjLlAsTjc9NzMmIjY2TFA6O0EyJzctK0MVJCZDPUZUYms8S05GU1RUUllWXVulkZeRlK9lXqvBZmFhX1+ngt/F09vTz8e+xMPI0dzJxdXw6tzUzMOwqbKrmvqB2cyaZ4B1aWZTR2yAVks2Oy8tSFs5PDk4MTEyMSw3PW9OUU1JNH0/Rk9palZXNmtNRUdFT0lDTFU+TnRjZ1NQXIhknJOAbmBiV1NzemVmbUtKeWxxg3d1XmSJaUA9TImpbI2fg1ZMV2pcWGJsYE5nRj1+VEVLaYJDTmZ8dURBPj55hGRXYVmKZFVJNjGAaVJUU01ARFA/XDVzaF1Uf3pWbG9KUUxXb1yCVU04ZXtslHmc6e/Bzr2SgJCmnoyarcPIxqbjqKScq6malouPnpWP+5fbkbyUgOLY587Ux6u0qZ6eX2xmZ2mobnJiVjpuZFpdYXs2UmpGd45pYmltNjpsZHFTeVFvclNqdF5MWnSAXY9LbHJQfHl6T5CridHb1dKlkbHDYcatoWdXoa7Fva2tmPeSW2usrbOAkUdryPWAgb3rgePv7XBkdl+BV3VXiH9pXltgcHR6eHdHYSdUXDpCIkNER3R7SW1+VkpcUT5WRE1amE9ARUpCQTg7RGhPvp56endJj5yghV1qfbOCXj6AaGCHioOCplopHiE+UWI4SF52V1A6TU5FViVTSyQkISYnHjg4Qj1ZeYlveC1SLTcyLS0uJFFfW0pEhGh/iJC4p6iTfklRhpGKconAaaFhYG5yqb99g/KXl53d1OCdm5aAkojEeoZ3W1tioP2E5NbbzLWwrKLvqN7sutPxj4mmreOAh302PENULFg3NUg2N2BnTjxDUkxFREMzNjY5X0t4fJCOjIt8gXB4g4KDj5RPjE2YplBJTlqr44DlmNyP3Zmvl4fR4NLMwevVzKvNooCpum2pvJ1oYGx1d3FvcbpocN7QvJHKuI2vjXd8lIrRgo/a/O329YWG77CsgYXU2arYsZSA2YKFkKvd4sj9pdLahIKynJR9PkpcVWk9Mzs/SUQtNF1ebD4uQzMsUFcwWVgyV25BRzc2cEErQ0MpKE1TOUwmGyhGaj4xSnNGPC4qKi8yRVaKWmNPbjAqVVVMOWxpNUtBMFFlWGJCPmpERG1eXy85Ojs4aXuESl1BLCpSMSRJLz6FfYd8hH0JfHx+fn18fH59h3wKfX19fH19fXx9fYZ8hH0BfJ19BX5+fX1+hH0Dfn58hnsFfHx8fX2Efgd9fn18e3x8kX0BfoR9gn6IfQR8fX18hn0BfI59CX59fX18fn19fYV+jH+GfgR/f35+hX+Cfpt9Anx9hHyFe4R8hH2CfIt9hnwBe4d8Bn18fH18fIV7Bnx9fHt7fIR7jXqCe4l6Bnt9fHt6eoR7AXyHexB8fXx8fHt8fHx7ent7enp6hHsIenp7e3x8enuEfIp7AXyFe4J8hHuHfAF9hXySe416B3l6e3x6enqLeYV6AXmEegF7hnoEe3t6e4Z6DXt7enp6e3x8enp7e3qMexN6e3p6enl5ent7enp6e3p6ent7h3oEeXp7e4V6FHt7enp7e3p6e3p6enx8e3x7fHx8i3sNfHx9fHx9fH18fHx7e4x8AXuJfAN7e3qEewF8inuDfIR7D3p7fH19fHt7fHx7e3x8fIR7A3x7e4Z8hXsGfHx7e3x9h3yDe4d8hXuGfAN7e3yEewF8hH0EfH19fYl8AXuHfAJ7fIl7hHyCe4V8AX2EfAN7fHuFfIJ7jHyCe496BXt6e3p6hHsKenp7ent6enl6eox5BHp6eXmMegd5enp5eXp7iHoBfIR7hHoHe3t6e3t8fIZ7AXqIewV8fHx9fYR8jX0QfHx8fX18fX18fH18fH18fIR9AXyGfYR8hH0DfH19hHyEfYh8gn2EfAZ7e3x8fX2GfAF7hXyFfQ58e3x9fH19fXx9fXx9fQICBACA+J2ejrbqnK/H1o2O2svgz+LaotqIscC78cLfxvHqldSPwYzY69eA38Kn5oqShtXhjPb2kpahwKnSvtGxs5m749vEx/SG7oHassqJufGutvPam9C93eS5qpy0hd6opsva74rPwNX+8dv5h8389ueA8fKJloqnmL+pvK+T3+Lbxo6A2qnT/JzoscPIy6OX3q+crZCAu4r8lNqdifCryKy0t8HzjOz1/oTvkZjf5d/N2KKIzbSFlOH8wNytvtTWw9aBkvWMi5SNkZiByKCAspp1rrBucJGpudPOsPXDs7Gzq62bj32HkZiZlpyUl5GIhX99e3hwYmBgrqucdqOhiHjMb2yAyI1we3eEgNOh0ZG3q4WE1+6LprWWyvighIGU27jz5Ozdjfa1z4+Ctsi7maKSwOWYhNuo+NyIhczn1pCpn6fD0M2Ai/mWgczq4c3BsomhqMT03oG676H/i3ydoLe4koCgsPmQn8fEeXduhorH/tqQu8nHute1ic3MzefCu+jkt6yAnKmgiINpmb6fraKchmZevp+SoXjefp3gs+mhla+8pqzEtWjAfHh4b4B+d3Zx1sS2uL6sh9S8f6ChnK+0jXxzcnh1ddOdqbOPycC/tKKdlY6Wm5nHoKu4r7CDg5GIh5KOgY6UoJmOqqB8tnmjkYGCoq2YjbqWis+1qn2s0mWQp86AnnLUnYhy0nPP6efj1IbRod6bjpGco622trO2vrOvqJ2bipOTudGaqYDk94CHjZuoor57faOkqqSYuo+U+vqawci5baeIwvW3dHyLeabGm5uA5abygoTmiKmWlcWJpIiOvYGKtvOErJGUzqPpcXtlq/TprayToNDKc6vFicfE3cSAoJurhJKZjbXTo3uMgsaYhtKGyMOVp5KRvI3Hn3eFp4DigYCIen63hqzq1o7Lzay0qMG3gMeefYGTfIiegX2OxnSIeLCuinywi/WWxqq9xpmyiLm6g3SMbWpqq2hTWF2OpHORZKC3qpCNbXRPiWxwdl1XWmJoRoJyWGddh2ORvnaAmpqAk4DilpavkX25k3bUxHmx1PGklJmIhZuHdZJrwrl2m8Wi0bK1p8qWmMfBpHC1ubVmZJvD1qWwel5SUlpelIOBlK+fj5iYk3+ggpWIjLycsc6Qm5BzZWCkmZRimLa5stSah3GUnnV2sqB6fZGFkX1/d69iopR4bpJ3cGtzmFSAo11ib4ut35Kk2KKGyZe8nH2jkIST2tCWqNPNkpyW4Me1yb3Ze9GOo7HQ8+i7hbmt8ICprOOrqNiNo4B73ZSyrKaA672WrITTmcmTq4Kx4KGFxsGsiZSnh7TDkdKefW2srITOuZyNrqWesKqplrz5t5uM9ZDAvM7Q9a3rzaWgjrGA0pOBZJDNlq6wtmlooazSx8Wofa5ohJh7qoyloL/HgZ9zhmiiqaNjta2RxmdyZau8f9y+fHh2i4m4vM+Wkmx/m4iBjqRQrFiff49agquEhsjJiJ6LmKtsbF17dbmkm8nW3n2+l73KpKqZVZGzqZFSnbRzdWBpaoB5fHlnk6Wch3CAlX2ov3Cgh4COlHBjoYFudlRalm7EeHxvXZZ1knSKhoGeV5KYklKTXl+LgnqBf1xVf3BUWpCabYJsepKOfopWZKtlZWxsanJnqpF/vZ50n6d0cICOjqqrnfLKwcHGwca1qZahrbSsrbKtrqWgnJeUkI6EcHBwz9DLndzQt6X+ioyA9J+DhYORk+GSwqy/qJ2L7O58en6Hr7ttVlp0tZbW7PjSbqpvkHhak42Be3pnmahuWaiNybV+d8LT0Iuhn6bAzcN2fsJtaZ2xpp2WjGyIk56rtnSF3KPykYejvNnPm32gtfySt/vpnpyLl3ai7cOS1ej1v76ehceysse1v+nzys2Aucu9mKKKodjMyL3Mu5SB2IeLu4Lyjp3WqvSZgsHcyLPW44fQgn5+dYeEe3x35M7ByNO7kd3BhKmnn77OnYV6dn15dteeus6W0MbIva+on5qkqani4tvu7dSsturMzs6+r7zO9+/M48uf5KjEu5ez1eKrtNCrmvrX55m5/oCnv/6AvofusaCS/obi/fPcw4HuqdyZj5Cdoq22trW4vbOwqZ+biZKTt9WZqoLo/oSNk6Oyrs6Eh6+qsaqatpCGy+KGydTLgMuit/nAgIiehaSti41yy5jzgH7XibeRl7GIq5CNvnl1qeeCsJCb4Lj/gJqA4PzitsGqsOTYgbbHjdXY4b2AqavBo621nsvwt5GkleOun/mT0dqovK2n0ZbRooOKrofyjoqVh4vEirLv35fl3sXHttbOjN2wh3+UgYeggoWe5YSnja+ukorCh+CFwq3R7sPNjq7BmZKign2G7pOGkpHJ35vEgMbd36G1kJtpt42XoIB3fICJXauVcoVurYC21YGAmruKlZX1n6vEqJjQqoO8roOq4PyWgop/iZSBgKKG+u2Nw/u1+NTV1PK9wvPt0oXa6OuEibnZ/MzdoH1tbHh+sJubvtjEvcm4q5O8nMGzo9CbrMSOpbGbiIbv4+GGz+L4y9yjlJHA256u4r+OmbanrJidlMltu7OZg6uHfXiFtGSAx21wfZWv2YOYx5WArICul36jkpR5o8KbnbLKhZyU2M2+tLPUgLlzocHu+ePClLev7Yissvq2sOqbuZ2R/rPdob6N4auDkHLFntmFrY/J7ZeLzbyUbImfkJ++idGwkoGdvpK8oZWFnXp2mpWegKHfn3h0yYCrkaG03Jbstp16h6GASj1PRVV+Vm6FjURBaV1GOFVMLlM1S2hRaWBsY3ZoMjkoUi9EVmwxTC8hOjMtJ0ZFL2VwRTM2Qy5CN0RNZjtRV1RVXmgpSSw/QSkhLUQ5S3x7SF5aa2tdUUBeP21JSXNzmVhpTGJtR0RaLjJIUG8wgIFCPjE7MCk/UUs/VlhVSjmAQj9VSixePVZSNSorMykpMjMiISxuIx4oNWQuNj47PEJKKzpQSCVMOTtKSEI6QzkuT08kNl1aPU5KV29sXWRBUY9SUlhZWWBanY2D1cKNrqiHh4qOg52dlfnh3+fo5uXZz7fK2OPS0dvd39LRzcO/u7iskI6M9NStb4xmT0Z2QESAfU03NS0uNFs8SUVFPDg1QlQ6QVE9RUssKy4+QzhtZFJMMWBAVU0xSFlZYF9IZ2dLPn9rmHxTTX18b01bU1tfaHJFO3RFQ3aCe3F5blRxin1rdlVwrne1Zk5WYm5iVWFoaplZY4Z8UUdEWk5dj5RlcHJyfYNRPox5e455eYJoTEOARVtqYFQ+VFlAU1ZiW01Eek9UakyQS115Wo1gUE5USVBrkE7GjYyNg5mWjIyG/eHJ1efImObLlr61rNrwsJKDiI6IgeWt7f6m4tnc18rAtaCmqqbZeXJqaoZeamZVZmVfZF1uZGZkb3tTWWN6fWJkZnVUX3k+RJh5dEdubDpaa3KAWT+QZE1CXlPPYtTPwnN1dryKi5ieoau5tLPAxLu9tqelj5KRssSYp4Dj/oqTnK66uc2JjK6mrqh9lH9fhaRVfYJvPm9pfYh/TkVIMCYvIzg7UUqOWlymcp1zR1FURzpBRiQvcJZIZUhMfV5/P1tOi+zZrZSBZG58TG1/PYqOpXOAiWlvalphUDgnQCAdNi4+QIJLQUE9WlBRbT5wNCcnMyhMQCMtHyNFWnO3ZStOW1tVMllNJ15qPURPNj9iSDdbjWZdQ2VtYktZU61snnd0kG9xa5bDsKq5n5Ol24JRUGdniJxvP12JZ3K8u8yS97rL3bCmsJyxgOHHmrKD1Zvk5oqAnOZqQTNjNTQ0PTU/NjpqXDxQdH5VPT0/PUQ+MEtKrKJRhpFqjX2BfpJ9gI2HgUuQk5xQTW5olaydoqOKi5ifx6ap1PPJvtzSsajbuOC3otiQn62AlYlsaWW+t7Vht83ItvLIwaS92XyE5um6ve7Y0rzOxPaB6enXq9KjlZiq8YKA+IuQmq3K3nySwZWEonakl42dSzdNbkouNkZZSEE6XkdXX3BlLz8kQVFYUlJMO1paaDZNVGhENkgmMC0nSzE4QDs4blVJSzpfRUwvNTpNbltRbVh3Rj01KDNaS2xQOCc2P0JuZFdNW05TeIFpXGZhOD8ydl1sSmZlckpNLjEvKzQFfX5+fn2FfAN9fXyFfQZ+fX18e32FfBd7fHx9fX18fH19fHx9fH19fXx8fXx8fIh9AXyHfQd+fX59fX1+hH2CfIV9E35+fn19fHx8e3p6e3t8e3t8fHyFfQV+fHt8fJF9AX6FfYJ+hH0Ffn59fXuMfQh+fX19fn1+fol9BH5+fX2IfgN/f36HfwV+fn59fYt+nX2EfAl7e3x8e3x8e3yFfQF8h30DfHx9hXwGfX19fHx9hHwGfXx9fHx8hXsHfH18fHx7fIh7hnoFe3t6e3uJegJ7fIR6BHt7fHyJewx8e3t7fHx8e3p6enmGeoV7AXyEe4R8jnsFfXx7fHuFfIJ9h3wBe4l8h3sDenp7jHoFeXp7e3qMeaB6D3t7enp6e3t6e3t7enp7eoR7CXx6e3p5eXp7fJl6gnmNegt7e3t8fHt9e3t7fIR7hHyGfQl8fHt8fHt8fHuHfAR9fXx7hHwJe3t7fHt7enp6hnsHfHt7fHt6eoh7BXx8fH19hHwBe4R8hHuHfAF7hXwGe3t8e3t8hHsHfHt7fHt7fIR9BXx9fXx7iHwLfXx9fHx7e3t8fX2GfIJ7iHwBfYh8iXsKfHt7fHt7ent7e4Z8AXuIfAZ7fHx8e3uIfAh7e3p6e3p6e4p6BHt6enqEe4l6jHkFenl5enuEfAF7hHoHeXl5enl5eYR6CXl5eXp6ent7e4d6BHt6enqGewN6e3qGe4R8g32EfIh9BHx9fX2GfAN9fX6KfAd9fHx8fX18hH0TfHx8fX19fHx9fX18fHx9fX17e4V8hX0FfHx7e3yEfYV8gn2GfAx9fX18e3t9fXx7fHyFfQICBACA7JGCgOGj572thK7NkIWPqOvGoMDFufLA97SMwr+Eus7a2qDYoMK7t5KVmranp43b75uc1I2Kkauwy++2nK+Dyp7Vj4+GhOCQytaC2eP2uIPmu9m8gpiKrvmdg470r6bC8vDI7NnuuPnS75LF+YfCvs2q2eunjrqyxNCLxuG0ho+AuNzgj+++0Y2/9J2lxqm3jO7kyI/4+OCJpczIs8W9uLPw046Qsb/hyLickqap34+KiOqI54P2i5y7oajshZCO4/2fn6Cfm6OchuLGiq+ztbxqx7q4t9LkzMvFraKXlZapr72RlJ2aq6aprpiQiYODeXN0al2xqq2b1aXFaZJlxsSAdnrDcYi2iM3bhX2Jn6z+jp2e2u3orKTd0evXuMXS2ILgx5W4tpygs7WCyM/DgcGE+YHt5M278arW8+vb3unS7tKow+rPtIeKhrzZ1IeFiazKnYiYy4rMm/WGr42YgaiMsWuW+pGtqIHiuZiPmYeIpG3CyHuzmZqopp78poKdf4KAwGmLjZSNh7zLhK53c3B5eoigk9CDjn+5lZGfpOnAra2rqeWdl4isjYKHh4aGh4eEdsC4mZfAo5aLhM6kaGSMgId9c9x5tWeKvMXIycm6lZCdoaCaXl2lllOIa393coqAiKCUm5azyZmiwn6rhqivdnWHqnnExL2JaqP5lWTbjtOA6sCIwZuThKirqoqNsquA4oD68JOco6quprizqpWPkoWT/IWVrK+Xi9yEi4qNjo2J4Xe9vLzJyJSqxuji8eeRu7HnvpnAtqTlyJd+l87U2fL4ha+vmq2y5OCChbbBv4Hn7ti6v5OxlLCDqoy0oq2BhpXe9XHGj9qF2I6rf5vwsXiAdGVmbGt5i46UgL7Ws6KwwImqf3yevIiPvsSceH2nmJi6fIGfeNqMqI+swN3N09iip5qPx4OP7JnPjqrakrvems+qjJzJj6R9gf+E16iHiInEwGq8oZixj6+tmoFyWYZ5fJWolImOhbKUSkVEToBITXVf0sy/XVZnV3ZbjXS4l2iAiYqUprKFlaisk7eMmq2G8uqKlYKY4fK/wueViWqjdHB3fqi0rJVtlZ3Zjoppp4ypr3Z3ZamXfHvMbmhWWXFlrKqbiqy0k7S1mYF7gq25dbp9o/nH362iwKODiZ+cha2hlbSgi6SWXqxZsaxdjFBYVlCas9m/lYKGZKNkoXt2dliAdnRxVlhmjbrn4s3Ejfz9qpaX05DmxcSSlLe0r7rU85fRwd6U0IH808+77MStcNPKgq2UsKTpwt3Nw9+td6+SkYWBoKK3ptXUi+jegvzyjeaH0Yb4ysH2f42P3by41Iye0+LB85j9vcm1y6Twqbe6j9iyvP67/7KExd6QyIuI6qaA4I1wXraH57WscpPCbGiJn9ajhpailb6AzZp1qaZpo8LItYOrcYqZlHV9fpCNiWeinXFzmW5zdZKktt6acnZSl3KVYFpRVZVpjqFboqyuk3bgnKCNUXpcbKdzboTqgX2m1Nu+2tHGir2etGSMwWBzeJl6ua5qanNqaXVUjJ+CaGSAhn6VXKeJo2+duGhnhod7UZGkj2m0wKhNW36AeW6BlXiPjFllbHqMe3ZgWGBkiWFOTH5Ne0uXUE9fXW6dXGJjmatzdXV0cXZzZ7Wxibu8xchuzcbOydXi0c3LvbSqqKm1uMWjrbSyubW8va6koJeZjoaFfW3LxdjB/crvib+H+vKAgILQgZe0mNXmg4SYqaz9hn+Ir666g3ygm8Dgx6uf54LrtXOBf4aYoYhpqbqrapVdpVm+y8ij7KTa8uvEx+fK5MKZo8CijmV2Z4CXoGhucpKXc3R2rX2zlP2Bu6yujbGj0IaZ0ouip373sJeOl4CLwoPb14K/oJWdmY38q4mrlJqA4YGusce7mOfqksmMhYuTmIOUmOyetIKcjZCYndS9tMvO0fy/rprcn4qQj46OkJKNf8zGo6PPsqqfk9iud3KbjJKDeOd+uG5tpMzS1tnGoJqpsbPaiojv44Pgmc+yr763xtDE1uj8/8nd7ZnVorXDl56lypnx7N6ngLn/rID4qOKA9s+g1LCnqbyuq42SvayJ+4X08JWepquwprq1q5aRk4aT+YiXq6uWjeWKkZCTlpWQ8H/Kzc7W0Zerx+y+yKhuoKvuzaXEsqnt16KHotO/0ebrj6eqiZy657+LhKnCs4Ta2da4uJCoj72GtI+uuceSoJ3G7H3VoP2S8pOqgJ/4uoKAhIKLiICTmZmekc/mwbPL0Je1ipOzzZiZw9KqhIivopzFioqlge6XrZm0zOnZ2uqxs7Sbwo+X4pTUjqPgmsTttvW1kpbUk6GBf/Nx1bCRhZjx54fr4t7+wfvn99Whj8isqr7Otp6nne/LZF5eabFjaaR98OTpd3WPdJdzuojXqHeAobC2teGgobS5oMGas7GL+fJ/jH2Iz+S/s++WkILEjYuKodv546aFv8X3traBy7PX3IOKg+imj47rj4t0epyPzre4q/Dinc/Ns6OVoM3JgNCCodKozLvC/tmytODhrtfRorupl9TTjfiC29FzsWdvbGW8yuXOpZeedb57v5eJjmqAiYWCYmRvlKe/taqwfNzdoI2PwI7fx8KNjJORh5a63IrDrsSD04bi18296J6ygd6yc72nvqT1z+rb4eOyitCsj5aBln+RhLvCb+PofN73jeiGw370sa74gG6Aybm72Z+18dO28ZHAgYR7h3i8maCocol9l82j03tcrdmWo4Nr1KKAQy9BSXZOZlRZTlNQPDYqPWBXREZRZodXkWlGS0g+cGlkaUpLLk04KScfKjk2MiRASUtNay8iJik3RE5MQkMuXU5qQTk3PGNCTSoYKTlSQTg4UGlqOUJAUGVXPjx7X2BupIhYXmd2Sl10jkEvLCdbYGZBQS0rMjwoIisoV1IzNT6AQkFJH09CNys2OSw1Oy8nKD0tLiRmWEU0R09FNhwfIzlkSSwqSVNcUFNEPDpCXjwsLUgqSC9qMig1PVF2RktNcoJcYGFfXGBgWaOki9Hl9/2C8en59ff87ujn4dnOycrOz9HG5Onf5OHk4trQyL/Fua2pm4T599adrHRwPlNDdnmAPz5lNjU+OFtiNDU2Oj5IKEI+bIFjMC9HOVxoT09Ray1RcFNeVEFCQ0A2foh2THBIdTuBgoJ7jmF1gG53aXdqcmE/SFRYTkFEP1NgfFddbIZnTFproXmebaBSaltVS3JVajlVcEBWX0R7WldSUl5XZztva0VlSFJQVWGmTj5INjeATS5VYGZoWGdtQV1MSk1PVFJcX3tMVkpbV1xkaW1SSE5de5dhlo9xnp+mpqWlqKqlkOfhubn22NDFtPnDjIOnlJyPgO2ByIVak93h6efZsaattLBjRjheWTFgTGNqYl1gVnZlcnGHkGdWfF51baOeUWJfdDyAdYtXPl+FUEacWpqAvplMimJmWmGGhYaNr5JOj2Hz75yiqLC0rMPAt56cm4iY/o2ZrauZjvCPmpecn6CY+YXh5+Tt5JKluNCGhmZFY3h/cWd7cHeOdGdQWU5JUXh1KFFAdX6cxsA+G0xZSEJFSz9UXkZBOFI4eEpAV2NBgo2r1YalaGxhmH6FT4booGyAY05PU0xUTkM6RUdaTUVTU0QxGx5JbSxESy8rMDc9KSsnKCkwJDs8XFtYa4l3ZGpXL2AwNyxfmEtbQ22HWHC8isRjT2NiZ3RXWLZbmoBhX1aNh1r5qqjR0s3DhnVfVGxOVn2CS1FWVrv0ioOEj/mKlumh36ffkaDNocqH54rPsZKAwN3SO1IxNTMsNzgyVzs8dnpPR0FSaHZwWWtSR0qJXlFUeYSZhk9GgHeQe3hLfXmIllxpUJRfaWy5p7eYmcGx6LGyntjrru/ovraqxunSh+uHnql0pZF9zKyUnb7Erbq7p93Xv8nEc8ts6PiM7YKQjYPu7vPiy8HIldyV/MqutIOApaKcgYCJraCjlJGpd8rInYiKikJoPDsvLVJdWmNoaEReVXM5VS5JRDM7WE9GLFFYNUhBRkJXOkZFSD43IjgyMzk9VEpXTltYRmVdNnRzP3hGalN6YFdVKSxBgGxiVDE8RmJhbWWKWlZUXVOLb29OM1RUbIJ1ZUM6WmMuQjUyWDkJfX5+fn19fHx8i30GfHt7fXt7hHwGe3t7fH18iH0DfHx9hXyKfQF+i30BfoV9IHx9fX1+fX5+fX19fHt9fXt7e3x8e3t8fHt7fX19fn59hHyGfQF+iH0BfoZ9Bn5+fX19foR9BXt7fH5+iX2Lfgl9fn5+fX59fn2GfgV/f39+foh/g36EfQF+o32EfAt7e3x9fHx7e3x8fIR9gnyFfQd8fX18e3t7inwBfYp8CHt7fH17fHt8hHsBeoR7hnqKe4V6C3x8enp6e3t8e3t6hnsDfHx6hHuIegV7enp7e4R8gnuGfAJ9fIZ7AXyGewZ8fHx7fHyGfYZ8AXuOfIl7BHp6e3uFegZ5enp8fXqKeQZ6e3t6enuUeoJ5hHoFe3p6e3qFewV6e3p5eYZ7hnoFe3t7eXmOegF5hnoBeYd6Anl6hXmEegV8fH1+fIZ7A3x7e4h8Cn18fHt7fHt6fH2OfAt7fHx7e3x7e3p6fIR7B3p7e3x7enqIe4t8BH19fHuPfAR7e3t8h3sUfHt8fHx7fH18fXx7fHx7e3t8fH2EfAt9fH58e3x9fHt7fIx7iHyCe4R8Ent8fHt7enp6e3t7fHt7enp6e4V8AXuHfAV7fHx7e4R8BHt7e3yEewR6e3t7hHqCe4V6AXuEegd7e3t6e3t7h3qMeQx6enp7e3x8fH18e3qJeYR6CXl5enl6ent7eoR7h3qDe4R6iHuFfAF9hnwCfXyLfRF8fHx9fX59fH19fHx8fXx8fYV8h30kfHx9fX18fX19fHx9fHx9fHt8e3x8fXt7fHx9fX18fHt8fX19hXyFfYR8C319fXx7e3x9fnx8hH0CfH0CAgQAgKPwtoKKk7f67IXB5IKkg+3rtcHkub/SsayByfTooZ2D0Iatw7DMrsrt5Y75jN3FkJKy0ryLnpqrtdvKmLns++atuKL7xdGg0dfXguSb7rqtjIHvmZTy/IXv0Im1puuGyIf1/ZKyrNCYiqWWyI31mofAycD7u73jp+eQqJa0td2AgP6AsbfUz4O3+/mTjsCQ19ji2IuMo7XM7+njhMet3oSBxcSqs9PC3oHVzuLc8ZGIm5mhlpqH1oOJmKvO842XkIL/lpWTmYiVn5qqjpaNdsSwrquiq7CwrKeblY+Uj5OUkpOgh4uOkImfqauojY+Nh36UmodlX12yoIdfh7GPf5OVgNjY1umhkHnbuNzY5OGuz8Cj9ZiAkOfd/4OXlfTE0tKD9o2AxLevl/Ttipqkz9TBqZem+M7BuoaRoJucqYuQiIzalo/p0OvE68D8mtKXhvSMhd/Wl7OYxrfn8Y6Jm8SQz4iwocirvrKVspmTn/l8iMiGmKyHt4WKl5fWrY+C381ygJ/GhY+AanKCjc18eoWZiG+OlNmtjIqrx6Ktv9rc4YLKx7q0oJyvlZ+YrpaTk5KQj42KioJ0cWWRiaaXi7N0fHuCdm3O0HCLvqe1i3rMsqKXmaNuY1yjnmyOhJmWmXB8aZ6MhI+NzbjPnITFnX2yeqCoobTFr6uPy4DRwf3Ccr+hgM2borfWo4Hhwta0iMrDjZeIhISXm5ukqaicn5mZhYWLh4OEnqGO+3t9g5ecoZaQhn962cbB3N6FpabN286fmPfRx4Po79qJnIZ9g8OL2+W62qyH+rWhoerWtJu3voOpfrS+s7/0m6h974Pw1Zq1frGMhJZ+jduifsHlqJSkm6+JgMurwW+TwLqIttmXf7qB1dK50a+3hc20jb54uI6A5bXcnbrS+Ni3g6Cbnu6Sm3XMoZuRtKfh85p+lL6Cu9Wjq7GYtquigc+IwpGdg+j0tq6pc7+bxp50jJO0mqdefHmif4Nuk6eQrZ1aVUZTaFRcX4dlYKuobH9SSYuEYW6kiIhngJGLbo2cd6mIpMe6kXO8pIaMjobpzKWSz6uAvaeQq6qdhcSpbHtvtsDZ02yYkqxzn5TIabRvmnauhmZUV1RubnTJnpzgaJ2Wur2Nall6en+WdXNznrDEgIPfwZRzq4iSrJrDn5KopVmqWl50cnRjYWJllFdoh4ZzX3qyf6lkoLZygIqEoYCQqpfLmICDko3Bo5mu6umpiq+7g4/q97fH3n3A0Yft9eqh4LLfuq3izZaFw/OHhc2KmN7exMbkmrx7iq2YjpSErIb6h9LmhLKyj+eApPSm5JOC442qiaKRhsCEv8h636yq7azJqo/xmLni3rid3q3L6OKin/550rGLlIOJgJq9eWFlbaTl0m6gwFhyYbzCl6WwiJ6mjI9spdC7iYxzpmd7kYulp6fOuWfMdaWHanqGlYdpcHmBn86tYnSpubJ/e3S6ko9fkZCcW652u4+DYVikW2CmnlapkGKSeqV1n3PC8n2Yi6RgY39ziE+1aGCDnpvSh4+PdZBtfGyEhI9bgLZSb4FxmmN9tq9jX35lf4WHjWBHVHp+joucSnNvkl1fgX1nc46FnVqOjJybpWJaaF1gVVRJekhMVFtzjmBpZVmtam1obWBqdHaah4mGd8/Awb+4wsbGv7iwqqWqpaiopaWumJ+ko5qrs7GxnZyem5OlqJV0bmzPxq2BreKok5+jgN7Vy+SyiYPepJSn0NKCn5BpoXNqdbugnVJ0lc6mmamAz11NfYyaiOHUe3t+paSRiXVzp767rnyImI2QkG98cITUhYCkrreMvI+vZpp0b8F5Zp6ncouJo6Ti8ZWWoc6a65Wtq8SamZBzgnGLoPuEkOqYnKuKvpaepaDMpJOL9e2EgLXxoZ2bhoqzt+GLjbDJnIGZnN+ztLLMxJOvttHO2YPc6unZucW1tLylzKagn6CfnpyZmZCBe3GblbylmcGAiYqThHrj5nuQqXm2mYfdwq+kq7eIhZD//qvZv/fh9Z2rjdnAvdLC/Nbzy6Hlx5S6k7bl0+P/6NCx84/12P/aidmzgN2ksc7yvZX10968i8TBjJaEgoOXm56orKqeoJydh4eMiISFnp+M/oCFiZ6krKCYjIeB5tXP5+iIpqXM06V3eMXezY/7+tqMqJGEhNOO3uXF3rSJ+bqqmta7vqStuoCtg7/Js7LjpqeF9on+6rHQjsmRfpqKj9G1jePurqGqormWgPjh+YSj4emjze6ojcqY7vjH2c7dmufUns6HzY6A5sfiq8nV9O3Ji6CgpPiorIHgt66tx63u/52Cn8Z7tu2xxNSsxa+igdyEvJ2ngeHvurKxgNzK+eWSu8Pz6+mFo5/YmKCQq7Kn3NqDfGByj3J/g7aJesTFja1vYrqpgZG1m6CAgLSti6u9iqCAoruljoOumYmIhH3mxJR+uZ2Czrqhvr+7s/3ShpmF6ez98oO0vNGbyMH3g/WHqYjSrYZyd3Ocm5vkrKj8eL+px86tfW6Vi5GniIZ9iJy9iX7YxZyD5KikvKPNqprV5YT0i42KiYl5dnp9uWhxjIt8bIjBkcNyuc9/gJaNqYigu6TTjGVif3qli4ug2f2uga29eX24wJu81onVx4Pe29efxZa0uaTb5qGY0/Z+htuPnvHr19Pym8aJoL6kiItoh2q/ZpiiYIeefNxqkeGm6Z2M5YuafnZyds+WweaC3Luhs296dnTUh5bDrI5zlIy4w6GAjtyC4bp9fH+AgEVxUUhEQFdvYzRbZDA+OmRoY3p3TmF+a2BCcX9lXWBCSTA7RjVCKjQ+Mig4KT88ODxdX185KS4rMlRJP0REU39aUVOPcmU9TjcpGSY/eGVWOj56UkJ6fkJsX0NYUYdYfE9bWDBLVFs/Q2NNPylQP0FeflY8QiktKCsoNiYzI0ctgFgtQ0VHQzA4SzclMTokVTtLISQiLT5QXUZGOVU5KCIkRk5ETGNfdUNoZ3V5fEw1OUBANDIrTSwxMzRFXEpST0WGVllVWU5YYWOUlpOOhffr8u/m+f757OLZ1M/Ty83Lx8zIucjO0cXU0s3Tx8PHxb7DwauOh4Pzu4ROWW5VSEJKgF9URGFENTRUPzpBR1RANUA5W0FDO1ZFRy46P1ZMR040YDIrTlpQTpmRT2FlanxyblxWcXZ5cFdTVlFVUkA5PzpbNDVKRVhLeGN/RnVbW6t0SWVvZIGDj4G0sVBJYYZieEVMUGFcZEtOWEVJS4NGQGtISERHWD03Ojp7TEkyZmI3gEhWO1ZMUlJbYGQ9PFZyWUpoZIRmWUddaGFldYd+cUFfbmtTO1aBX6e6sLu8vL+8vby5ua+dlYyzrN7BsdOTn6Gqk4P09YajrFqvm4jlyrmwsLJcMjlwaVFhaWdjYlljVV1iWGNmg2l1YnOjcFOfVplxaYNskHRjkVVxaqB6UJZ2gJZ3dWqZTkqMocqpfLzFkZmFhYaco6KtsrWqrKSki4mMi4uLoqOL/YWLk6mws6qelIiF7+Ti8uiHoJq/qHdKUXeFfUqilIJISkhGRF8qU0FFVj9AqVyGkNLChV1ZhGxmTkxYQT9OOz82ey1zZnNdYop1dI10f5FvapfGgYqSpquFgLeOlEpfkJBdcms7S0kjQFBVQTE/SXVSLCwwUUJDb0lVPWpbVE5EQnEoPGpnZC5wY19keltnf0s+Rl9VcHdds5lIWGJ5WG1PfVxWVai9jXFlVIeo3HFYvLucbHVPaF+FQz9PZFpsnqJbiIOcxqG2ufq5kdvgtfGZiP/fqb2skq+hgNvasWpFMDouL0I6NTA1NzpPSlGPe3ZWamU+UUZOaHtmZKeVT1ZIhYOIlktpdoVph4ezXp5HTmrO0K6VmpXAv8H0qqrsh7Ow4t/DoIGtnKS8n6CIan2shWq+u5yDzsPJz6r02cXfw23GbnmkqaOTlJiZ84OGkZqRg5rHmNqN3vWUgKidu5u/3sfwi1VPbGuQfXyQz3c7SklFNT5cSkNmbTBQajhdanlFRzQ1QD5IRikuRmwyKk4tP044WUtLN0wuMDxBRExEYkmBQmpjO0U6PkcyUX5icDYsYj5ANURXR1YuOjknU0JYgj1ATFenbm9sbWdWXWZ6j1s6Nl4gPzw/UkY+Anx9hH4HfXx8fX19foV9iHwHe3t7fHt8fId9BXx8fXx9h3yHfQt+fX19fH19fXx8fIR9Kn59fXx9fX5+fX5+fX1+fX19fH19fHt8fHx9fHx8fn18fX1+fX5+fXt8fIt9A359foh9gn6GfQx+fn18fHx9fX59fX2JfgF/jX4BfYZ+hH8Bfoh/hX6ofY58g32GfIR9Anx9hXyDfYR8BH18fX2EfAZ7e3x8fH2TewF6hnsSenp6e3p6enl6fHx7enp7e3x7hXoGe3t8fHx7iHoJeXp6eXp6ent7hHwGe3t8fHt7hHyHe4J8h3uFfAF9hXwBfZh8hXsBeoZ7CXp6e3t8fXp6eoZ5A3p7e5V6Bnl6enl6eYZ6D3t6e3p7e3p7ent6eXt7eoR7BXp6enl5mHoBeYt6hXmEegt7fH19fHt7fHt7e4Z8AX2GfAl7fHx7enp7fHyGe4Z8Ant8hHsBfIV7Bnx8e3t6eoZ7Dnp6ent7enp7e3t8fHx9h3wMe3t8fHx7fHx7fHt8h3sGfHx7e3t8iHsKfX18fH18e3x7e4R8CX18fXx8fH18e4R8hHsBfIV7BHx7e3uGfIJ7iHwJe3t7enp7e3x8hHsDenp7hXwBe458g3uEfId7BXp6e3t7hHqCe4Z6BXt6e3t7iXqEeQF6hnmFe4Z8gnuEeoR5hHoGeXl6eXp6h3sBeol7hHqJewF8hH2EfAJ7fIt9B359fX18fHyGfQl8fH19fHx9fXyIfYd8B319fXx9fHyEfQl8fXx8fXx9fXyFfYJ8hH2EfAV9fX18e4R8EX19fXx7e3x9fX1+fX19fHx8AgIEAICDnJqpqpSesYKDr4WqptmWfOiu2f/644KUtaCkhtDI2dSgrMGsl5iQw+bYkb6/r8jsjZCisrO70LDYsoCC6tykro2Sx/u9z6L1tfHUxbCw38eS+4qihrr50Yyg0KDBkpmrnqOluY6MxvSmt6KA1dOjnP3TjPiQtIeRsp6hh7mF8ID/9dqBvtO3gdbouKfe2N/e4PKt2KiUqOzSraj1q7OZ2trR/tPAyuOSlJSRh42Xi4+Q7LWlpYL++oaWkZeuztqCjYz84t7v8Yia+auIbnNvfH6Dmoi/m5WSiomIj5OXmJu6vbOfo8jgy8joldnPss6Yq7nGmm5jobKZj3qjucHIp4DJ1eWysZKk0L2iptuVhKjTwca+zLt/oIH2gMm8+5qyj46wlZ/A7Pe7zq7S8cetvqGcj+73pKKxxZCB39bb6LWWjqDviKrb47eKpuqS2+qKlODMxc25+brri5r62Inrf4TUlZ/f99mTuObO7ti9v7jomqCwzMOEnXjH8NydrJN4jYCtsoF0xW7LeonNtpS4lbR6noeTkLyJvZicsNXd5s3R1OZzi4VxsbZ5t8apop+fm5aZk3COnrd9wcCkuMbMbJWhn5uLe3d6epDZ7Hhux514uZ+JalubWqOpaHlxepdmdqGufn2IvJa0kIOYc3zEbopyiGCWjahxi66yyuPev7WzqYCM3raMko6+oJyY57mv3Yj6goWDoZmfrKaPhe/q73+LmYeBipOXmaXducG3oLizmYmGgoOJlI6giYm4nJSOwtSK3O7jyHyy7JuTn5mbpKq+8aCI97Xd/cr9j8Lol73K1NnAwJWt3vi+yZOjrXp+fXW/evKUiImVpIqpgsB7k63fk4B5hHaY0WiDdprCcomcpKfYxHpyts6+3tWsnLB+gaTBos2KqrzJuX6J58uAmXe+n4uRcnukfN+FtpHx7ObGvKeqmYu9uLDwvvWsf66z/Ol84o/JsI+KuKy2mLai1ryBrpnblpblgGJhp4xUWlliVkVIT1pSg0NGSlhhiGF3fppksoBvd1fF44W1x4WKn4Xal318ivjEvPOIq6uTg3vNv3quj6lx1KOQi268neC+nImagWy0q5WdhrmB1X1kR1hNiGt3fJxlu3iik1ytpYqoaH+dpYShue+ZgJOmqp66ua66ydN8Y5x9bl+ahK+Da61+YYpuWVR0yIZ1oZLx9pWvV8vthYDMbov0hY/bw6fUrfa1jra58dmDhfDC5Jytsd6Pw8jZqevXt5SphLuJv7KbjoGWkoR8yqHBnq7H2K2xi3i1m4bsiuTYtuy2k5CHyZyqsOm+07aF+dnJh5J/x6Wctanz37yc0cy1k/3P5Ivr+NSAuomEzOmU//SIhsfOf9Dak8in3IBzdmx3c2+So3tupn6RiM6TgfCbqtDBn2pzjHx6Z6ytwq9zeZqfiIRvqbS8eZaNf5i6dHKAioB/fnica1VVu651eWx0kqNsgnWnep+hlYR/lopjtFhbVIixgFmFl4Oedn6Jen55gm1xlZ59h3VZpKZre+CvccVWdHJvh3uBbYpgqYCunZ1ZfJGBXIqPhIOfhpaMj5Rehk5HaaqNjnW7f4RjjYR8oYh8jKNoa2lqYGZuZWppqXpvbVCgkFBWU1dmhIxXYWK0pKi6vWVzyZyGcXNzfoKJmIjZr6yooJ+gpqiqq6q4xcKsrNHiysvfgdjewteqr77LqXpvr8e6mYvH3My0sIDG1NmenoisvaeBls55ZXSLbHh4o7aAhHO/ab+nyWp8Z2iBZHp6urSNjICFn4h8mIJ+erncm4iesHJjucLBwYmHjI7fe4adsYtidapopKVtetSkqaaL2qXOd5Dzy4PYhJHljofMwrJulbeb59K3xLjvoKDJ37mLq5He/OanzbWOrYDF7q6b7Yv5l7DisJ/kvtmW0Jytr+WCx72NoL2/zcavqdiMn7KEzcmL4OTNsrG1vK+ronmXrMmI0M+rwdb0k7S3tLGdiYeHhpK9tYV85bWH0LGagoLohf/wmqq4xPCSuOfzv7PA887js6Wilp33kbOPtILCzeONvNfk9PLj2MjDwICh9L6hnavVqKSZ97it24n3gYWEo5yjsqiRhvHq74CNm4iCipGXm67pxc7DrMfAopGNhoqTnJaqko67n5V8kp9xw+jd2oWe5qKSkpWXoqrH87CN5Krh9bbnlsTsmbXFy7yyzJSj4f652KPAvoKOiIHdgPCZnpuZwJ7TitOElrfqoYCVoo62+IOejrHggqi8vrf+6IyO2unS/e3ErLWMibDKp9WTrb/U0YSc98uMrIDTrpuigoOpgN6OwZr95NjR377Ms56+tbPpueuwlLu09eiH/pzq7crF6dDaxPnJ/dGW0KrroqD/moGG7L9zenqEd15ga3xwsV5eY3KAr3yfpsN904COlXDp/ZTO2YKAg3rklI6Me+S+tvh6mZWPhobq4IPcueCE+7Wgl4Dpx/7ctqC5qpLb0sXNlciV+Z2EY3ppuZGinLp75JjNtnLQu6XSiKbJyZ/G0O2Ve5ijqZ27vbXHztuBaqiGgYPSsOiuf9CWc6iGbWiJ14l5sZ7u7pW8ZNPqhYDTdZD6go3dxqnGkMmac5mg3s1+hfHF+pWWm5x1wuLowfLcwXyQbJ56t7GZlI2fmoCM4q+9mbLTz53DlYTNrorqgdG9hJd8ZmZhf2iLn8uwn4hWzOXKiJ2JzKWWr6bt9qGj2Meqiuu/rXfW4bRrl3VwtKWB19Jvi9nfiOfzep+JwYBHVUxRSUVCRzk6TkRcSFM8M2NlhI9ob0Q/VEY/NGQ+RVhJRDoqJSwwOjM/KkVZVmCMP0JKVUwsLS5SOhsoK0Y8T05TZHA3SUZSQzspP0VaYWFMjENQPkxQcEtOeGFWVmFpS0I+T0JKWXtWSjYhNERQVoE3GCMdMhQTFSEeJSUncIBrbWo6PU9IPExJNy1PTk84TE0iPh4iOVE3Iz9nNT47UlBZd15XZ3xPVFJTTFNaUlZUh15VUDlwXzQ3OD5NZWtBS1CbkJSkqFljrY+JhIaCh4iMlIfs2dfUy8nM0s3GzMvK3OHJyt7o0NvbdN3n1tvDwMrMtJWJ2dqRWkhZZFlMR4BMSVY0PjlHSE06Q14/KCxFO0JQYVI1NDRjNU4+Yzs7LzA4MTc9ZVtUWktXaFlXdmhoYJCPZFBfck9EcWhmdkgzLztdMD5KSlBAVHpIeHhcaaB+fYuCzJqmYXR3eFqmXkxuQUZ6iYBCSIBzbm5wYGNuR09faGdGQC5slm5EMzM0TYBVZ1xQlEuYWlZlWEl+dLBefmNWVndDVVNVa3qDh29ydYk/MzpKiNlQl3Gr0dLNxcTNwImkxO+i6uGvyuLVacDc1ta6nJeXlKS6lI2F8rmH08WkVThWK2GnW2VcTVZUZnJsVmdlb09kalVvXFugVmhlYDhjbnpDV3iGd4GsopaQYoBNlpZzbmB8fXZ75ryx4pD8g4mIrqGtwbOZkP3o9ISWo5GKjpKWnbbwycW8qr+9p5iPiIiQmZmnkIu1lYtaXGNJgZiDiUlofFFMUlFJQ0tGdUBBiFtKaqDhS8r+iXxHvZZ+kGFHdn9Tgnh/lnJ/emSFcN+IYWGJg2qOYI52jbjojYBqc0MsUi4uL399SDo3Qkt1VzRKZ2pVU2BOZF0uNUBaTlgkKiZdcj4udSwqYVV2bltaTm+RaIU2X0iBoJFzc5hzRkB4g4iigahtQGmJ1Ntts2qinG9vuu3sqp17l2lOpFd3V2WmbWBg8uicp6m3qYSGl66c+YiEiZuv6ZHP3/Sb/IC4vI+/WDBXYzY0QDNnOy47Wq19drtdamhyPDFdZDZnYWE4cmZVUEuAgbCDaWKOcGmMmZGHV19ksLOnhqGJ8KrNucyL/q/n2Yjg0c72pMn08L3p9++NcqqnqqXH087e5vWKgdmxjmGypMqajP69is2ljIKm8Y6Bzbbs2Z/sgOjwi4D0hZbwe47l2sDMg62FYoWH0sFhQHddWlJTQz5EZVtRN1ZbSUhjUXdTPy80KiYuOC0wTDdiV0FLQztLOi5DOzBwQG9fV2pQP0ZMXUpAN3E+SFs0b1dBKTMxSk0+VlJyXEA1U1dQQXB4ZUqrrYdIXFtemm1jmJg0Kjo9IElfSoRolgJ8fYR+hn0BfIR9CHx8e3t8fX19iHyHfQR8fHx9hHwBe4R8hn2CfoZ9gnyNfQh8fn5+fX1+fod8i30Jfn19fn17fH18iX0BfoR9AX6IfQF8hX0Mfn1+fn18fX19fH19iX6Kf4V+gn2HfoN/hX6Cf4t+ln0Bfot9lnyHfQp8fH19fXx9fHx8iH2HfAJ9fIR7gnqGe4R6hHsBeoZ7A3p6e4V6F3t7enp6e3t8e3l5enl7fHx9fXt5eXp6iHmEegd7fHx8e3p7hnwLe3t7ent6e3t7fHyHewV8fH18fIZ9gn6HfAF9i3yEe4Z6i3sQfHx7e3p6enl5eXp7ent6eZR6AXmEegV7enp6e4R6CXt7enp6e3t5eoZ7AXqEeQJ6eYp6g3mfegt8fX19fHt7e3x7e4h8Cnt8fHt8fHx7enyEewF8hHoFe3x7e3yEe4R8Cnt7ent7e3x7e3qJewh8fHt8fHx7e4V8BHt7fHyIewZ8fHx7e3uEfAZ7e3x7fHyKe4R8A3t8fIR7jHwFe3t8e3yLewN8fHuEfIZ7inwBe4V8hHsLent7fHx8e3t8e3uEfAF7hHwEe3t7eoZ8B3t7fHt7e3yFe4R6gnuHeoN7hXoBe4V6Ant6hHsEeXl5eoV7BXp6ent7inqCe4R6CHl5eXp8ent8hnuCfIV7C3p7e3t8e3x8e3x8hHsLfHx9fXx8e3t8fXyLfQd8fHx9fX18jH0BfIh9B3x8fHt8e3yKfQd8fHx9fXx8h32EfIJ9iHwMe3t8fX18fHt9fHt7hH0Hfn18fXt7egICBACAiJjdrq2Sx9yu5/m0g/jNusejhNvkkpWVoOS/ibKInpaT+IS7uqWK0MSE4o7egbOX9Z6PzoiTwvrDybfnjaqnmp7rm4SciLnhm8W+jLzOiYb1jZ/vka+j+arWzr6Z+Y7Cx4G9+uSduIalwZLMyK3wyJz6+pPLtPWx6KOsw7bhx+GA/P+Zyd3p0sSsrtPN0J+XgsTt2pjD38PJ+MTUzpr7ze/iuoKfjfH6g5KirpHzlKahkIbf38jNusOikY2RmayjvZ/bnJOZp66v04KOs6C74dzX7IDpiPvGjq+Qi5KkrMCdzNi5wOjMgIevkLLCusXX1e+ah5LaoHyl2L2jm8SUlq6A1K6Dzojj5oirw7O0j6fFuZSkuYnp3rywgLfb35m7t53VqObK2viSwMTGmfDKjsePwZbm5P2Nhd2h1Nzm4ITqyIP/sZjT3MDm9t6ljLf3sJnxroG6nMSqn9OpmLCR38qSwL/Tl+r25vvTi9bd7s3dhI6tq3qJe7iOhInflGaUc4yA2G1wcrS/bpaWgcaSjIyshpeSrqyktr+Ep4qIqayqsfWlnbiwvbvGp7fFuLGyo3OBbn60rLTFtMe8qMu9g56PmVtZopqMiYuKmnq3c8StlHyth3SfnGeHpqidtn6Aq6d3m3GwkKqWeMF0woWissp1aGR0uI15iKCIcYuFkKC3mNeA0rF9zreR34Cm1tCxvM3qgYF/4YaBhYDmxs3D5uiBiYny63yNj4+jscFxk56bzabIx8XGxs21kIWQjq7amruKstqPmdm+1KGWmq+ZsNPrqJj+g6TjormRrrmDdrDM84ql9cC2iqp9iazEfcSLj6OkwJLqlsybn561l43jkX7B2q6AbGesoby8fdF3vIizh7F3eKTN2MeyetfLwYx5b5qajbd126Gjeumay7mLlo+JiY/if5B7ja+snoWRzLfihOesp4Xf/sqJw56CbdmD24TrmsfMeoN3kaNim6yGiqSZkpqalH27w2d1UVtOV1RUhE9xeWhnZWlmV1NLj4CCT1FoZEyAWml7luuCh7jGmpbw2/S60cKuvNiBkI7Spb6JsqbDlaewy6emf8eVbMSZpJx4fpNqZJDErtmQgK9khlWHV3FvgY2gUWBdfHBobXhokmReXo1fs667anlyYaSCr6Wsk5rWgqh/iHBlrpNfdYakineMglZZjWF2hIqhxZ+RhHHh36KAse/gidHWsKOqcIel0L2l++nz8KeFuqKO55u5p7TTtrGMfdqU4aqLg6Gqw5mFx763vJfki5ORg5mW2efpp4yXh4ecwKGvksmF9e3fzo27o+rIgqjYl42Rh87dha+E03+I4frQ1JKLnom3jLKKy/u5lIfC8oLT3oaoodCApMnn1OaAe4imfHdysceoyO6lcfnTxsWMZqChZ2RudZyNaYdwmI2GyGeXsJ53l6V6vG24aJJyxXtxsm1Zd6SBgXaNgIidj26scWBqYo25c4GOaIaMXFymU2CdY2dikV2ClZh4tGG7uGaOtZdyg2d3kGqLnqDHm5TeznSHfKyCpXd7gYmrpJmAtLpnkZSnlnF3d5OOillcS4qho32QdWeKm4qTlGi2lKeUc1t0ZaOtXWp1fmiqa3l4a2WmnpKaiIhrVE9UXGpccnO5m5eis7a1w3B3lpupwb22wmi/btuzk8+rpKm7tsSlx9rCweDLdXWQiLjHvsrY1+qPfYPVpoiq5cytquemiLOA8KCJsG/P0XqSqaGPeX12fVd4fm/EvpqYeLLLrGFsb2WEd8K7raBZcXBxXaZ/V3pmpoDFy+2Fc7aFwsjAwGzSuHXnloaxwI2qnJVsYo6tiHzDlm6ZdZ+SkMKYf5N2xLeLw5etery+qcKrfczF5bvPfpy+u4WSidW2kpP/r4LHhaKA9YqUlNLtgLG9jK6PnrHiuc230tnK5uWhsI2QjY2hs8GJxODP0tDiutPk0cPEvp2re4O5r7nRtdLMtff3teLOr2lovbKhmpaZnHTCfdjCq5DKlpDtzIrJ5vvJ8LbA7eWq3aXutuDQmuGf9aPQ7P2fg4Gh/8aiusqghZWTjrLMm+yA88iE2MGh8Yq+/PfRw8nngYF+3oeChoLox8/E5+yDiYnz7n2QkZWsvM15nqyn3bPW0snN1NvEmY2XlLfgm6BvlbN7oei80p+RlZ6SvMnyn4T8fZvImquPoLaPdazF8IuDu7asga6FirLdi9mUlbKmzJPnmemvsa7Nrp31oIzS6suAgoDYw+jskfuF36zjp9CMjcT/+um+hu/p1JWHiq2glryA762thfWk2sqfmZ6enaH0gZCAja2xpYeT27vPeOzEupD168+SyqmUgvmO1nzrlMjbnL200NN6vdeiobuzuLmun5P0+IaebntrdHNytGyYpIuHh42Idm5kuaepbW+MhWWAdIabq/aLjr/JmZX11fPS076Wt+KGenm4pb2AwrTbsM7b8c3SjtymgujH3tCNk8GYjbLh0++Zksp/sm+4dZeMnbbOaXx4l4+DiJaDuYJ6erR617rQc4OCcryKsKWqkZjYhrOMl3+A7cqBmZ+9o5Gommxvpm16gY2qyJSGkX7GwZWAqtrRhcXWsqOxc4KNsKmX5tnj36SczL+JunWHhZHbw66Tgema2px7iqSjzpaGysO8vJjTjY+Hdo+B0MjMm496dXWIg4Kkjb9xqq2RmFaUg7CVYpHdmYiVlNXejL+H2oWAz/7JxpqJqIukgKdwyPKuhYOoz3a+0omvp6eQqp7Fm8OAUXF8VUtLUUdDhot6Vm1DRlhSRW1YPkFBQ1RWQj0nKS8weSsvKysoUUkwPi1uNk4/dUUwYk4zQFE7T0lFKS4/NkNuRElPO1STREc7RlVgOiprNVNgO15QXE5ua29ri090dSMvOj9JWEQ+R0AvKDpbY0NBPiklNE4wOCUaKiROPjmAYEIyTFBYQjRFSU9GWD41HThJLSkiLDIwJjNMOTx7Y3FiUD9XS3eBRlJbY1ODVWJjWVSLfnd+bGhONjE2P0lBW2a9uLXI3OHi4HZzjpigsK+qsVypXrqijuTU0NTbz9bA0t/a2ebYd3B+f8bQ1tvd1Np4aWzApI+dt49xWFxDPlSAbUs/XTdcXzNGV0JVLDA7OzE4Ujp8ZUlNOEhRUiw2OTNFPVhXVmM0Qz1BOXdUNUpLeWeLiX5CRHpadWZzaTxtWTZlOztjZ0lgWlhHRnGCammog1mCcJiFhLqAO0xIjp5eaFJdSYiShpJ7Q26EkYOPSk9TXz5BOFhKVlR2PyBDNVKAe05KUImGRmFmT0s7UWCWYXl8bVFidWRFX05BX1tPWoVdgrGv3+fZgW+Q3ufqz3eLg4S4usrmucfPvti7fHqey4KB6Ni/taSwsYHQgebCponQpVZTbE9blaSXpVljZnpkZk15XF9iWaFbqGtsWa1oVDQ6ZHE3OU9GSllZcXWIk6yAhXxovJlpn0Vtpp+gwc/xhYSB446H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dXeVqZydh9ivjIuvkYPGh5J7wMCWx9D4t4x5meaL/vXmiPr07eHF0p2Ht4SfdaWUppyP1s2srImzdqybh6R+vbLEhnuLq45wq2J0cXpiTV5fYXqGfFtJgWBYUktISFlqSk9HgGVjgElTXlTNocWD0ojM0sPClYWxhaeBiI3jvYy55L6seeV6pIhmhoG1eKKjsKPBvXChj3eyhM7Ch6tteoF+l1xzgp+hk4WUU2NubWxjaGmSUpSpeH+sf4x+cnV3b4GHlYut/eyXhJGHsZGtxW13WmGuVIWTo5Z6jJvCjKCug3x+mKWYgIO5poSzfnC+mnB9h7OE2bvPjpqP4JSeq4qj5sbMsZHejZ7Tj4iO5IukvJOtj9fG29Wq2sDi7PaggLiMiajbhKPtzIL5jKS6pqjw4pnn96yWi8KfrdKGqJqB13+ym6OLhn2enIm9yrqN38nrynqv4Mqp5Iao6ICjpufRkM2V/7eCgGx5m2aSu66sg8nbnpDbnteyvIeuaqChr2N+YlxtfJSofaugfoqcuXOXmsZ4229uopbDsXyXYn1bipB7houuv5iNeaSnbJqtnJyToMu4n52XnmV3Yq2jh1JYcmSxiHGKonZmgKClomyZsdHPbomdgHx0bXl3hKSKfHhjh5CAkpurgJlRh3Jda5eCXH1mg191kkl3bZygoZR+ebJRWp5sqlxgc35/bHJzcmxld3trbHCFfX5pp2a+Zm1yfH1us3mlvrTF0XZ1eIJ3borLf5+uucjIwse6usvKboONdLmB69bFy7bqitm+19mxqb2otLS0srW/fKWlm3l0e8e1tb6gxKmdgPvM/oRrlXmu3dx7erF9arxqbWubqbh9lGJut7hRW1h2b252X2RgYHF+c3RNZI5pY550t4bx08B736yha2a+b8nKd3J+i213emCAe2e7kLGGgHmgs3myg5PCvH59dmuXiHV3lneBvqxixqdz6+t1n/mnzazB86rS/oGY+MmRuKWmgKWgqaHptoGtnNS7sOa1nLOVx7+etJ3TveXVgp6EhLvBv4KUloyG6Kqz067P1reUid2ywJbFvJHMp92ltrrZy56on6ORk46JiIWEpeeBvqSOv7OpreC86aiXq5zW4Lbay9GMwrHGu5qylrq7x5HKsM+K34rgiO/0iauIiMvqm53WgKe3jKGPlam8moz//f58g4qDf87d1djaz8jV8YCJge3f1d6Fgn+KhMK/x66Uv8vEj4G3qMDzwJehsMnC4P+Pq3rBkKLP+8+zm56uguya6re+p629kam3wpeskcfAys/SkaSU/7KOt5Tfl6L+kJavqbOCuYem1erk47n7oJOAtd/FgK+QptyUqrmu2rewyMDyoIzxs7+cvMjRtMP2hYibtKafkO+9lZGikYvakqKO2dOn1db/vqaCnuWC4vX5oPTr+vPe9p+WxIOukPLU6b+g5dC50Jrii9C0tuObzsLXmI6kz62M2IOcmKCCZ3yAgqWzpXthqoB4cGZgYXWJYGpiq4yKgGJreWvnqbl1zIrJz7u+e2mnd6eHioLisIW53dnihfuMy7aMpLXsi7zP2NDv14TEu6LcmOrUjLyAlZ6iyXqRpczOva3Aa32PjIt9f3+/ZrzLh4rBlpqNgoSHgot2in6m+e2gjpyVx8Dx9IqKa3DPZ6W0yr6aqrDOkaayjZKJfYaJgHeiloGtfXK1m3eDia6F1b7Pg4iD/KWmv3JrsqTBwqnvlI7VmJSd34KlvmuofuHQ3++7vZ7P08+ObJNvcpfNanrNn2Hrip+/e2mUonaS05R8eJSFpMmMsqJwxorQuMGknYqjnIrLys+a58PUsoat0bmW74eVy2+vuv3alb6Gx4VugE1dc0RkhGlaTIyYjzR7PFphbVNtRVNtWypHPi01MDA9MmNRJy80Ui0yQFUpbTM+VVRyZVRYM00rQE4/Ois4Oys5Q05NQHZ1cWdzepGDemZPU01mOiBHRi4/TUagd2J6RlA9JR8ucVZjdnNoKyxCXEQ2GhcbNT05MiAqFTggMzJBgGQuRzAwMk5LKzoyXTUpNSIqJCw0PiYjLCkuKUc9az9DVF5hUlhZWVVMXWFVWFptZ2dYg1SeVVhdZGJWi2ORubna8o2PlKKUhqTbg5egp6+spq2kpLOzW2pxY6aC+ufc0MjmhOTS5uvEu9DCzsnIxcLIdYN+dWFZXJ+NeV5AVVZggHZji1FEYk9cfFUrUmo9N2AxLUFZSlIyRDM+Ul8nNDE/PTpEMDI4QUNLRUgtQ2E9O09QclJ9dXpNjm1aPDNSM2VfOzY2RzM0PjpMTUCJboRta2R+g3Opg461mU5TVFp6ZllSYU5OlIBJiGBIfIxUZX9VelpfcUtfcD9SeFA6PzxNgFJXYlGPb1NTTl9KQ3NaQk9KcVpE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obW9xoO03IKIhMHYpqG4tO2L76TSnq7XsoKQgcJ90snK0sqD9N3x3uDnsoKbiOinxsd5lJmPh4C1zb6gvriEkp6Zgnl+gMyRibOnmc51tOWpique+JCDh3hzenfXm4rWvJDL49nGgMngxd6X6d1/iHmKfYuCeo6Jh6HIwdix8cKZzIiYerfb5JCLiKCSkWV8kIHcynaZd4xziXOWjad9vamGzYeSnY6FkX1+fGZZZniLSX2Af09dWlGMe0lJSYVnVWt5R29IgGSLVlNe0NX0u9+dn5W389mZvvPEp9zTZceOdG2DhafBe6CLqJbPv9OvzLCTss2Kkn+Rvo/XkKB0rH+Pi4OjXmBWYGd0cW99S1CHkFtVT5ltra+snKGyrGl4jMG0doaHwKtqanJreryhqXZxZoKVr2+Xi4Zyf4+hrn2owox/sKP7gMi7rpfMua9+oZ6XnL6irqGQvpLbj4G25bSrrqiln5SGtXrk5XOQs3aUj6/o89iGwPiT7ZGR45CcsKjB+qHs8djY04j48Mmqjs+S4qjsm9+yva3fpaDYo5eIhOigi3nO0NCQwn2Ww4/kiZvMftLsoZaGkcWPqe2p23PEp4bJlfXCgJDDk5DLsqO/xXmmeH2zrYCOr4ZvY3dpZI6TrpeVw7f4weKdoNm1rYegte+Wb4jKyrKTgpBtt2mnlLFykpKFmJ/3iqS1pIhubH1pi6W/i39sZqVqZI10iY5eTktiWWy/iq1mfoJTUHeUdnxgoYhYp3ObeIaFdGl+ZZCUe4R9coBtgJZ+X5NaZJWkoHJDZl94hZx6bJpdj6SEW2FcgpeLbI1ka4B6dnR9eWp3dWt3fHVxaca/wsCzw25zgIh9eW24pbi/tbWemJamrsBsbWzGxMLIzM3BzWtzf4F6gHtrvcJra6ytu6+ukNqt4ZWlnIjj3c3Nvrfl3XjeyXeEfXvKp4KIgMCbjLxujX3Kf27bhKB5Y17LeWeo1efZhmRcWWfhZFdzUWFjVFt0e25ubW1sdnZmUJF9bZ2Dgtajh4qMf4GUp62ZqbrQdoPGs8aqobyZf3iFooJlwHClfojHgKdxasN4jGh2d6eot7Wok5i2jZh/0OKi5LfThr2Fj4+Vv5GDtIOxgKa3iJqK3fest7iFkuek79Stso23s7GOlsvW4svb7bmuruuF+ID198qxwsS2sZPJ2crRqXV4vbng7r+crKrRzMHCtJqKk4x5fIGGiYbQf7HQwcOVkIuW5fGKv5HQsNji48W/8sulmI+yhob+rpeT0pL6zOeVmKTRsLua0K7r+cKWgPuahc/YvZKJrNfhkMbi1tLVyeTe2OXo3eXRfnvt4NXN53+NfnyMfuSI0o21yr3kmJWXloTC3NTLvbWlpri8wHicw2mJi7nFpaGwtuyF4abNoJjBpXGGd9GT88LEzdJ94bTS3tD5u4iWg/u929GGqLKVeoTQ49W51seUqbWvj4GLgOapms29n+6H0PzDm7+Ru5eHlYGIjIb5u6Lp4KLo9NfMjNj81eeZ6uqLmYScjJeKg5mNkavPuNKs6bCc346iiLvZ/pWRl7OkuZW1v6Du2YDLtMqEl4KzxfCfw6iK86u3v6eiu6Wjool5iaG3Yaerpmd+eGy3pmJiYbWKb42kYJdggIW1b2l31cHhxd2gpZe9tbyStPy+meP3g/jIioaqjL7YkdK11MHz3PXU79SruuGpuKm646vukqiA2Jyvr6rIcnpwfoSUkpGiY2mtuXhvZ7R+x8TOvL7Kx3qJl7m2eImGtLp2dXt3iczQ5pGAd5iwzYS8r6qVoa64xYuwzqCJpJ35gMi7tKHLvrV/nZyapMenv62bvZLrppG//8GNm42os6SRvIL35IGawICgkpSqpcKP0ueb74SW34RyfIOZvnrNt5qWiGDp75yec4pnrZnOgrifm4evkJDKpqOUie2ukofw5O2P0YaoroPujarUgtXXpJtzidqPouiv84HjtYamg8e1gDdjT0uGVkpNbEl2ZVNySTY8QD9GOTc/QEFld2BaSzhPREg9NEs9NSk9QFk2Qk5ifGRQTmdKh0pLLkspSS0oPDVeTXZ6ZGQ5VGtVaYmmbGBRQGZaTycoSGNSNT1KQlF8OmYxISI5PE5XRCQvV0A4hDRuNh4iKSUXIzA+ITIzMCYugD0sMzgvMDIuOBwZOCY1MUgoHTwbRigyKC8yUGZhOVxITmJbXFtjYVRfW1FaW1paWauko6ifp1pcZmxmZl+kkZ6fk5CEhYOSnaZZWFutrqytrbWprVldZmdjaGhfrK1cXp6cppyaiePG5YmSj4Pn29LRyMLQxGjGs2FmW0NpUU5bgH5YQl5JWzZlR0hpS0NLKyRXPSpVSFx3Oys0MjZjOS46LzlINztLSUVHPUI8TUA0NF1ZS2RQ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XpxTi5aNiJiYoZGHlXifhJt1cHybo6apXXF8tG18Zpe7lm+Ta3W4npKO8t6Af6Wvy5eajOnHmoW8r+DUyNLZ5+x/59TL1d3Z5NPDu8jZfYNwbn2HoKnZj6KZ0OLMvbirpa2+d7+vmZCOjZ1/6pfyipt/prbx5fGKhPez+diympSHyZK9i9Ov0Lz6roiaq/iViKbowsG90buBirO5oImipriorad+n4OHlnd6nZSArZ+IkbjZn7zNlZ6t8Jmc3eDZgH3N1JFxpJfXoLyhkYKo193Vm4nzs6bcgoXUn818f5PfuLaL8ZellYfqjXzigIjkksnhrpiCbZp2t4iEmptxdo+ucbuxsbiKttGsmbeFpKutmnxzUV9UT2pgYk9jWkVfektJVVduUUhMYnZGSGCAaVJUgIS3sK2GxISZrKmVxvT88ZP4rdTEeml4koam18yHfq60a52okK26rZmxhbKmh5Onqcd7hWyPdoapYFi4zYVxn59WWWxof1eRhFhUZmaepKSMfK3gj5CdtKSLZIjjuaRrbFxkdLSeuXdhkmt7X25clYaMV5eZdVtli3r1jqCAp4hsbWVnc5SDtszurHN6eZx7i4yPdpOPfn7glsd6otnZio7HiNn++9Ham6iHgoGCn9XB4ILjnqOM/Kyz66S8qOLmxp6estaOz4DS+pG078CahcD7vreowamputXClZSQie+g2bOBh/+8v5Lj1YnTia2EjtKVzqe9knCjgYGL6O2AqbfCgJfNvdOBosLTzMGUlrO3l2lbWaKDrqaPopNsfY/syICO5sWivp2Xr55/07d2i49TiqyRbKuGfW1zkZCEp4ePaJmipmyP2rp3ds2ddWN0f3xTU4+alahVaGN+iJNyjq6FZ4lTj3OCjqyuXYJ+wF9sgXBikoGtjnd7a46AeamAqZlzXFRemVVMiHxATJNZW1ROk1hXV3iZnlpyc2htdnGCj5OFmY6EhIKLiX51gIZ5tMpvbclvd3lvd25rc3l0b8vBwrO+ysbNbWrDws9vzcrOcGxseH6Dgn99wa1veHt4d3RvybeztavUvbTDdKKqwa6Tl4Z4d3R9bNN+2cu9pMaAp5BzsmuBbpN/gGt7sozDg4Cpv5jEa27KvXyAt6imZ29mb2ZmYotIWV9paG1kf0VzjYNee3O386/tppeX2KSZpqK/qYRVp4ONYHSzg4xwmoB1jodxZYvbi6/Xb59hrX5ubnB/arWLpJfUs8Wu0Kr0nsDOvpvU/cW82ISUz9Wg1YWAu8aWi+zh/9j4jrq3roy/nLyOgoewuJWXsZaXzYuAjOytq8nS0dXa7uPNhpLWlvTwqMt4/oiB2rXDsMTQwLC1yK+psqmdlZCVjox8nJDhgfPA5nvBi/aB0Nfgx9rd6uPD0p7KutOgl7S06vDni5yj6YaYhcTivIzOhYTKtJKV/u6Ah7C216Cci+fIsJu6rOLXx9HY6PKC69nR2+Xg7trLxtHlhYt2dYWSqrXonLGn4PXdyca4tbbXgtO+pZmTjpt944rQapqDm53k4NV8ePG3/+GYh4Z/uoW0ifDU3rD+uYaCiPWfi7DwzLq439KKkdXevo2HqsrCxcWUqJGYrpOVr66Ay7ycqczssOHpl7W794FlxeHfkI3i7KSExrH1xsqrloa57e/dpZHztLPsi4zaoMaFiZj7v6qA+qOkoZf+kYf4lJ/8ksnz1c+wi7ONvI2YrLqZpKzWgc3R4N2HudnFr9mm0dDHwKGVa3twaYyBgGmCd11/pGVkdHKTcGFkgqNfYIGAk29uo6nYtqSOx4iYpatXo9z475DsvdrclYSYvY+n7++nmdXLh77OqtXRzqWykNnLr8fLz/CQmIS6j6HSfHDZ9KyQx8htcYiGom/Ar3JwgHK7zMWkkLjjoaK2z7WVa4nkyrB4dGdzh8jG1IVvq3qNcIR0u6eyabK2hmd0o4rddo6AoIhweW9veJWHs8ntsYSMjrmNp6SwjK6Zj4f8jLqFv/79oJzanvv7+uakjK+Ki5ORouLAy37QiXJtrnR9mG93d6GFkYWak6hzll2s+IiXwaR9Y5bXrZKEr6+by8zFqp+Vi/ui4MGTifbAsJ7axoX3kLp5mvGizrTbfYG5gXBw3N6APUJbODU0OEFCebC4aWo1QVdVSDUsLV5fZWFQX2c4ISpJPyYrQkVGUk8uNz1HkH5OXVUsRVJeNXBPQDFBLCUtLy9KSlCBa05ytZBZY7mFW0tJL0IyO1ZseWdGVTFFUVA9VW9EO2ZKbl5NKU1lSUIyVB0tNDYvOyo6Ny0yL0UxJD2AVldHKyUqRSMnRD8hI0ouLyskTS0qLElVZjxRUkhLV1VgcHJpenJsaGtxcGRfbXRpnKhdXa5cYGJcZV9dZGlkX6+nqqCptKutXV2pqLFfsrCvYV5bY2ZpaGdpsqFfZGZjYmFdqZydop+7p6OpYJOSmo9+fW9ob2ZnVKpgmYRzb3eAbFJKf1Q2NjQ7Wj9OfVJfPj5AZ1xhOzZva1NLX1ZVMTk5OygvNjsjNDI5QUlIQyRDWVc/SUZyjmqlclhJWktbUV9tUDkmTz47JTp5anJPcWZWbnVkX4bVf6K/V4JQjGhNUUtUTpJvhWyiXm5dcWhzP11oW0ZrfWhcWT5BTlI9gVyAcGJjaLGjvY6VRmBeRzpeSF84OThBSjo7STcqOzYsMFlDPEpDhktAW1t0ZkSIaY6MoN+I8mpgwIWLhavP1b7R9tbL39TFurCyp5x2l5L2hNyy5IDEXZlUc2FdV2tZenttcGmAXlJWYWJMpKCTUVFbcjxbOkVYRz5oTVGCcniE5taAeY+WrZmlj/rTZmC6rOXcydHb8v2J+OLY5e/r/Ojd1uL2kpuCgY2Wp7TvqsGy5vju3dvRoKO4dcWwnJONh5CCwWSQR04/aG+Ei4hVOXxEZElpT05pgIC0jbOdsr7hgU9EQYp2Tn2SejlMcIxnal9wcnx1pLZ0k4herY+NQiAaWTuAQEJIP0BUUHCDUUJWWyg7REhTIhw3T0ArU0twRpZ+XCw9TFNxO0t6aF+bWliTXHtSV1ygkH5YczlhWTl9X0qTS1qFY4mScW5pWnpioIZlanJaWl94U6GjhYxSWGdPTFtFRlZ5psa+jaSVjbirq4+vpIGu4ouOo5vLnYqIrueGhK6A0p2U19n7al9PZVpgblw9eKzf4ICqaGJmSkhMWjRFcGE7TVtiS3h9f4+aiJeZfIC2epzF3vyWfJDnnKrplYXn8c+w5e2Eh6anzY7845KRpYnb9fC8osHUvb3g/9KsgZXd+dSdi4KPsuG40JiEy42jg5+M7Nflg+PwpYOL16vOYX6ApZeKmIyJjquaudn2xVhnQ2liZEY/Qkk0LzpiVGQvNE1UPEFhOVFybU8wLSwkLjg0OVVXai9QMkpRfk5ZbUxRVXRcbjstQVxVdUp+wG1vj3lSSGKbfFtIWFM+TlhKOj87QX9MXj4wMFNNUz94Y0yTSUwuMUlBUjo5LSNCODYqS1ODfIZ9Bnx8fH19foV9BH5+fX2FfAN9fn6EfYR8EH19fXx8e3t8fHx+fXx8fXyEfYV+DX19fHx8fXx7e3x8e3yFfQp+fn19fXx+fn19hHwFe3x9fX6GfQR+fX18h30BfIt9C35+fn1+fn19fn59hH4BfYZ+l38Ffn5/f36Lf4h+CX9/fn5+f35+fol/gn6Hf4l+AX+MfgJ9foh9AXyEfQJ8e4p8BXt8fHt7hXyIfQF+h30Cfn2FfIN7i3oOe3x7e3t8e3p6ent6enuGeoR7Dnl6eXp8fH19enl6eXp5inqCe4R6hHsDfHt8hHuFegh7e3x8fHt7e4t8g32NfIZ7BHx7fHyUewx6ent7e3l5eXp5enmTeoN5hHqHewd6e3t6ent7hXkIent6enl5enuJeQF6jHmJegR7e3t6hXkEenp6e4l6BXx8fXx8hXsFfHx7fHuEfIV7hXoBe4R8C318e3t7fHx7e3x8jHsFfHx8fX2JfIJ7hHwHfX18fHx9fYR8hHuEfIR7IHx8e3t7ent7ent6e3t7enp8fHt8e3x8e3x8e3x8e3x8kXsEenp7e5h8gnuEfAx7fHx8e3t8fHt7fHyOe4J6iXsFfHx7e3yEe5B6CXt7enl5enp7e4Z6hXsJfHt7fHx7ent7hHqGe4R6gnmFegV5eXp9fYR8EHt7enp6e3p6e3t7ent8fXyNewZ8fH18fHyHfQt8fX1+fXx8fX18fYR8iH0MfHx8fXx9fX18fXx8jH0MfHt6e3x8e3x9fHt7hX2HfAZ7fHx9fX2EfA97fHx7fX1+fn19fH19fn6EfYJ8AgIEAIDTkLTLv6L/y6HQuJXVlHvCruyPkZuTjeitgfnFu4jTiOKa5Mf6oJTMqP2R/oazn53uoY6qhovZkaONl56Md6He1LOezsLh1YuHrtzbrc6upKGa34TUuJzekKOgjo3XnODg//eM0q3eyvSL5aCcsOyR4KqrpaWlycGepbK0mLOzj4C+0tCM/POWlb+oqIugn8bNtKuquNf4l7u8wq6SrLGvs7+/x77JzdbGuLyys5aSjP/zgomClJ+dmoyHg4KB/e3e4PLy84GLi4qB6/ju7OPg+YeBgouenZ6Rg9LokZidm5+ajImYj/T694SDgYOGhuvfjIjv98aaiaGxk6Kn/8isjYCeqO/Xtv+BhZfh76fkq+b33pWIwomPgonWk5y8lrjOtMOkhtnHor78tsP1kuXAzsGY6p+2t6+3h9H6z7LOn4PSodTx3JCGkpfj8ryPh/u4z+be3ZzbooS7q8XLlsT6/5yk8PeRkcGIkdOWr6ucisOUhdDGh4aihI2CbY+Oc4SlmYCg0Y3Sw3evtcuHh8R7msN/lLasYmKok4h6cad5w8Bft4yNhqGij6G91HOGn6WolaGJdG/Bs8Z2dWtsY2NkZ2tmtFpZraSVjo2bgr+Wk9u1hLjr4tCkm3aPkoSeWI2BZK54jop8gIhua2aYpYiKoZ61e5yid7qrfrrKqYBwkKTzj4CLv4CEp9LjuKrDes281tfl4Hh1zcXQzNPc5nff2c3Tb9WFrdbXv96FndfNgISWwbfQxrxzwN7irKeIf4OhtqOs4IbDrNq2zN2dysugivbZgv+H+Nj9/rz7iql/64zHsOV+yqXA3NzzxPqq58bserPNfYWQqqqOn5Ckm6nKd6d2cYC4r5i72oGSxdi127Club6au7Ccs6evgLXCd3C545Dr4cPlmpWrjYvk6Mq7mHp809q7qMORttqahIGWtZq8wHJktbSLjJSZoL6Sm4Cq9I2nraW/rI7Zcsh4mJ6kpr+RZoF1aGRmn4+FTIBPhUmAgVFRVlJ1hUhJSVZOb3RkX217fYBUaUp6mW3ft5qb5oKpjYnTq/CXoJaImJh/e5SJmKG7pc+ueKOWmbCox8C5itv7l4tne4u+yqx7U3hspMNrXXWlqbSSlZ6pbHN2hmhVZIB0kYGSmaeejYG7iGBwcZh7trmstMHWf5uuatWRYnpflZlntHtjhpdXoVRtUqSkn5HQ0oC/8r2ItI6Lf33Mpm+GxImciMKRwNfBmpD8qISYcqjGsKJ5e3za15SEe4WJitnPe4+l1bmz/punktv/mPOzyYfSuZu56O/+wKWG+JGBuanqhdKX14L+4ZTogK3Vk7eFwfWYgbuegJvd8rPMz6Gl7oaqv9ruuJKEwXSCoHqEjb+W34DQj8bbzaz7zKDPwqPYmonPqrpldoBzbqV8X72eiXvSb8mf6LzumIKgjvmX9m6ge4XIh3iUd3+zanJfZm11gnz434hzlMThs29Wd7u0dpJ7c3J0ll98eF6CWl1cXmObf4SWqY9PiluGkZtUlmRilqlcjW9baX13mZhmaoF+c3tyVICCe3JJqahmW3VeXkpaXXmAaVxeaXebaoeIiXtpf4GAhpOTmpGanqWZjJGJjHh3ctHJanFreH98fHFua2tq0se7vcjFx2lycW9qv8zDwry5zW1oam99enpza7jMdnp/f4B9c3F7dNTW1G9ubG9wcc27b2zGxaaLe4qagY2N56+ZfICJidW7m7tjbXOQvn2zi6bjuG5ZlHqHa3ezh663hZ6yaG5pcMW+inqQdnCRWrZ0fXdgqI6Wsb/Sm+TkxrfHg27Fhb3gwmlUaWWvq4V5cNymttS5qXykf3Oah6GkaJ/F2Xx7pLBrc6Zuir6ZuLWjlsuhgNrXioWchZWdgbiZhYuXi4Cly5Xox4G+w+mbqcSJxtagst3dhILZy6qQgrGS5tqA9MG3nb+wmaDV/Iik0OTnztujfHnc1OuIh4B/cXBwcnp2y2dnw7mroaCyjpiLn8y3jbby6dS0y6rf7M3fhcjVgeikyLWpsq2flY/O8sPB18zildPnmtzPl+TzvJGDka37m4COy4eMs8rlt6nHgtC61Njp4np50MnW093l8H7q5tvheOSQuufn0fSSqufdjI2g0MHd0sl8z/D2ubORhoaju6at4HWereerpc+YtrKkiPnWddx/+c/q87P3osSU9Jznw+mLyaHCxdLpvv63/sr0itLsg3qVvsOpu6W6rLroh72CiYD43rvV/Y+g5fzQ8Lywtbebx8ClvLLEldfnnIXl+Z/y+OP5lZ+2kpT8+93WrZCA9PDHrM2Wr+SWhomhzLrI0JGF/duKho63wOidmnqb4JC4yNPnwpDXgvCJp66vsMqggaCLg4J+zL6yZKppr2Grqmlsc2+btWJiYXRplZeCgZOhqIByjGCdwYjVuJeX/HqeiFOrmeqVsKudoqGTnb+Un6bcuu3Omua+x9jL4trcm9Tsp6ODlaTv9dWXapiAu+GEeIfL0OS1ur/RhpaaqIZxg6WWsaC5wMusk5HPmnqKg51+vtC/vtHgl6fHfOyhbodurbN52JN3qbprxGaBZcK8q5O7uYCn3LiNvJaWh4bRpnGX5KS4n/296+/luav1vqGpiany1cyRl5Tz4It7g1dXkOzshpSm57+m5H+XcajHebyUmmyyk3maw7+yin1ntnJmo4eoXY9tj2jIqGeNWX2shNCOzvSXhcWqY4fT6rnDuJihyX6w2fP81KeKy4NvpY6OcJeG14BWOEVFRS9NX1h/e0JWOStRRVgzLjI3N3NOO1tLTjg/KUQuTD5OMipGPmc5T0h/S0yFWllZOz18SEs9PjcyICxETlFMYlpja0wzXp6VUm1bWFVYRy5kQEVhM1NMMiNxT3duOlpIdFFzblMtPD1FPkk0Wk00Li0oMjczJ0JCMz0zJoAwOz4nOlAtLEs5NCgxNkpPPzA2PkJjSl9jYllPX19gZ3N1e3d9f4Z+c3VxeGhqZLmwXWFdZGpka2JfXl5fvLSop6yrq1piYl5bpbSvr6umsF1ZV1toZGViXaSrYWZqamhoY19nYrK2tV9cW1tcXqWZVFGTjnttZ3N4ZW9wsX13Z4BlWaCWdIE3IDBHe156S1FVPDBBX0Y5OFJtS09cSlZTMzkzMFVONjM3MjVWMoRCRkA3Y01eX11iU32hhW1ROzlJR1ViZDcoLC1NYE5DSJJfgZyMhWKYeGuLd4V/T4akn2FXbXZSXIRbXY1BV1deQmZDTXNTMDhSQ1hKQVhBJS8/TIBeZFB7kleHhJJQWl0vTW5KS05MKSlIQT45KzAvUUQrWEg9NFt9Szo1WD1ZT1ZLSluCiYC5k62HnIyRg4eMjpmT+4OE9e7ay8XSoI18psrGlazv7tSoj1xbY1xmOlVaPXphYGRbWWtgUUyMn3p9WGJoPWtnPlZTSGh/bFc8eI/clYBvlW59sNDzxK+2bci91tzs6IGC2dHb2uvy/4j4+PP9hPeXwfDy2PqUqfnykJWh3d/15N+AxuDos6mMgH6buJ2epVxyT25yeINugn4/NnNPMGo7Z5Df5KbLcaFvxXatmb1yuX1PXkZQRWVOZIKjR1NRYHGTmXVXi32Dd7B/NkgkIYA4OD5LTEdjZmVwdVdVVGVBQDU5QjU4Hk58QU6Av16baVdvQUlTOzptenJzaV5RnpyLdohUaXRQRzs6TmB6bzs6fIFiXmNtepBob1Fxr3quq5GLgXytTH9MR1dIU15QN0M8S2SA+Pvrg+WM64Ho5Y6SoZ3U/YuJhaKU0MyutMvc6ICdwoTU/K20VlhXmlxzVz1+fd1+dGFRY1hMUlxBR0pMPkJGSoJzcn9/jaTBm7Cyen5rk6X6/eKkg8CLtNaUjGPE3PnQ1tfzob3E0rGXqtDG2svr9fe+naHsvKCyo72d2/zn4f73s8jylPmqgZmAyduN+7GP1euF+4Ogg/3vzaWxpICO1sCizKqrnJ7TqIB7fExJO2VYXlJsRC5YTjpDMUVLRD80Nipmd1hLLyAdKz9BJjBATEdPjVQ9Sn6ZW5J1ZVBUX1h5bVN1bmFTkE1HcVlqOldLW0iOdUZcO0tuRGQnSVM6SWw/KjVGTD1LV0RXel9dT1VFNzwuTygtOCsuNkU8YwF8hX2FfAd9fX5+fX19hX4OfX19fHx8fX1+fX18fHyEfQd8fXx8e3x9h3yFfYN+hX0IfHx8fX59fHyHfR9+fn1+fX1+fn19fHx9fHx9fn1+fXx8fX1+fn18fXx8jX0Hfn19fX59fZB+mX+Cfox/h36Ff4d+iX+Cfop/g36GfwR+fn9/in6GfYR8BX19fXx7hHwEe3t8fYV8B3t8fHt8fHyEfYJ8h30BfIR9h3wBe4R6C3t7ent6enp7fHx8hXsCenuFeg95ent7e3x7enl5ent8fHyFegF5h3oDe3p6iXuHfAx6ent6enp7e3x9fHuEfIJ9hnwEfXx8fZR8g3uKfAN7fHyHe4R6gnuGeYV6BHt6enuKeoR5Bnp6ent6eoR7Dnp6e3t7ent6e3t6ent7hXkBeoZ5gnqHeQF6hHkCenmGegd7enl5enp6hXmNegR7fHx8h3sYfHx7fH18fXx7enp7ent7e3p7enp7fXt7hXwEe3t7fI97BXx9fH19hnyFe4t8DH18fHt7enp7ent7e4V8h3uFegN8fHuEfIR7EHx8e3t8fHx7e3t8fHx9fHyHewJ8e418Cnt7e3x7fHt8e3uEfIJ7hXyRewF6hnsBeol7h3wBe5V6B3l6enp7e3uHeot7h3qEe4t5Fnp5e319fXx8fHt7e3p6e3p7e3t6enuEfIx7BHx9fX2FfIJ9hHwVfX18fHx9fX18fH19fX5+fXx8fX19hHwHfX19fHx9fIZ9gnyFfRV7fHx7fX1+fX18fHx9fX5+fXx9e32FfAN9fn2KfIZ9A3x9foZ9AXwCAgQAgLO9vpnWjqWn96qftMbYrcCl2fGA1N6KzeauvMvMhpu127rgr5WFz9TmyKbeoKma4t2+ktnPruqetr2/gfjXdbW+uJKZnYqs783ugIyMiPirmLrPgZPyifb4x9Tc4LC5oOm9ofvPkoblgLLPzaLwu8S7x7rBooaTwPDYo72F2ci4gPe3jtuF1v+OkpiaoKylyMS8qanXw/68s4Oxqqexh6D+tcDLtcXPw7m+vbKTn5D38ISKg4GOoJiO8fmCgvzY8PqCgYCAioSA6OTl4ePvgIaKiJGWkpWSjf+Jj4uDkpOWko+XmoyCh4aMiYSKjoOF/oGD/PL328Goxr7Ky8PEhbuhgJeBrdmGguWhwZmHv4Kl24Htlda7qaSJirOQgYGft7a2+YrYnNmmlrfswKSM+ZLMs7nJv45yfqOF2LKh2OuKponUxH+0xZjKz5Kcw7D2yKzp2duD9eyP8Jbpz47llNSDlPOAhoCr7YGMvMX75LWV37TWv3qBvry10X3G04yUjpXhgOWtrZTFl4iIptTI1aLLtaSMsm3OuI+Sl3ecrt+qpXPVksuZl32//rB9hqiSrJuHk7eTaW1qbIeEgH19e3t3bXBtZF1brbCcnqOUuZCXgr2tffCE/py9r5p4Z4CwnKRzY5+cfHOFlGlkqJKUi5GAbcSIoXiwg86JlIKBeciD7pWugO+OkoO76nbZsaOarMXP4NTEybvH1Hh3f4x8d3eGkdZ9uMh6po9/lJyPeL26vcbD0s7EvszhhpaN48zM6pmnpJOX38ryi7rGg77IrIq4vIGYhIHdrqaGl4721KPNgdyyv+bK2tPblav8uMvi0a/JkMeA6uSTqcnXfK2mvdV8rM2dgJF5ibfCp6K7w6Oe26aDgn/6xJGWqq95d4+QoH17nozo4HuwftJ+mdybs4uCeYjbmn6jpqLpeu/gj7G4guCIcnWjzJKO6JrNgKqV1tWI1drF8+L7mqWDtc6VvJ7EjHNuxahomqBmYmKKTU1TSIRxZItQXGVibW17bE2IeVBVc2V5gG+PfnFyc57svOSpm62o+cXc8JiRh46Ck5G/cNGovHe+/rWEzXaag46VgnyPmsnern/ThamgtKWlzpvVv7VqdsDUaHBktquXhHd0h1Zrhkh6ZYhcgpKBaHOOtGh5fmNzeHhpkJ6LrciYjrR7imO2s5exlXx0n2ttUlNfXV1kwpP+gMKj/36Ld7GPmKqvvKuibuiynb9/msBwd36bz3bKxtR6vX+TcsWNp6CWvZJ8fJqSj+aCy4COh4WJ08KS3tnMr563/bXegIjmg7qanurVxbWU052JlYuSlJeM2JjE3bawi/+ohYytpoyM3vOIloeu+7q/xuyZg82pwvKbofbqr9uCgL7W3bT0mbSz8qyiwc7BtNCx39F53+J3lryVpKOiZY6nt63YrnyS1dnz16nGgpiHqJ6se7O8lrl2g4GbbNXngNHCrXtxq5W49IysYWllYqd4b4aMVVyFTqKhi5WLomyCYJKAV5eCUlSgT2d4lobAfoN2fnVyZFRtfZuVa4FajoqCgLNuUXlWfZdUVFRdWV9je2xmYWh+dKmFflZ/enmEYHa1ipKajJmhmY6UlI93gHXLxmxwaWhxf3p1ycppac+1x8xpaWhocG1owL/BvMHGaW1wbnN3dHd3ctFwdHBsd3d6d3Z7e3Frbm9ycmxzdG5s1m1pxsG/q5+NmpSbnp6YbqOMgIZqisF3eMt6l3Fmk26QunPIZ4uJjXZxgq6bjoWDpJqPp166lsV0XGeYg3hmqVd0cWp6oZSQi7WW2J2Mz+6HjZH13oCiqomjgk9sjHu4n5fO1rpt3KxfzH+wmnOndrBre6pXX2eLy2yFrr329LuU6sLau4CGx8jE+YnM4ZyinJvrgPaut5i/lpefuvDz4pLWzcKi14Lz37rKwYicyvS7yYPgz/KptYC03sGcrujA5bygxue6g4SDgpeUkI2Ni42HfoF+cWtoxcixqLulpoSgiLqsgfGA85zFxsCVnrvy5e6qldXUopS2yp2W4qywm6mtiO+kzJ7TpPeitKSfh9qF5JS4gPeUnIrC7HbZs6OXqsTP59rJz7/N3Xx9h5WDfn6QnOiLydeCsZ+LoqeZgMvGzdXM3tjZ1dvyj6GW7djY96CuqJWU2b72i6mfh7atjYWpu3CRc3XaqqKBkJH/4LLXhuzJzuvE4NzafZr4w9n31Lncn9uA6POVstLri8q21+qKyue5gLKYnNLmxKzD1q2s462NhoL+tZOdrMCFj6azxYaKsJ7/74C3hNuFofCpt5OJh5bxsYi5sp77ie/fmcHfmvmVh4HI24mHy5XZgKSS4dd2w866/un7mqWR2++j07D0n4eB7syDycJ/f4CzZ2ZvYLOWf7BmeIeBk5KljmSwm2Z0mYShgJe5p5SRkKvYu9mgi52Oop/D6pugnKinrLPhgee035DU/siV7Yq6sbG7m5Sgq8/qu4/qm8/C4c7U+7Xm5dCAi/D/gox93s+4pJiTrW2Ms2GcfK51pbGReYKXxXWVhmt3iIlwnaqoz+Oqn8yLmG/Mya7Kq5WLxoCFZmd1bm1tzZf3gKON84GOe7qWnrC20bvAhPrXyu+jt9GGjYao64Dx39SQ356iju2Mrp6alnKPjrKko/eHyGxxcGpurJhupby9k4aTxpGzXWvPbY12eqiblXx5qnFlaWtvWmdRoIeWzKivfuDMjYyeqoiJ4ep2l3KlzZnN5Mmqn/rE3/2Qpf64fuuGgEc/PTZKOU5QhFhYQ0NWPkM2U10sSlI0ZmNtdWRfNTc2Qz04PDUxREZQVT9VSWpidGFpX3t7c4hTSklYLVk0IDtFPz5FPTM9XF1+TFROS3RYU2RiMTFLH25fQUYzL0lbUGIZT2teS0dlLC45PzhpW01RWEQ+OS01MzEzLC4jQDo7gFxHNEUjOFYzNTA3MzQ7TD04OkFMR3NeXDpgWltkSFqHbHV8cn+Ff3V8f31pbWSsp1xfWVhfZ2pota1ZXLmlrbBZWVtZYGFesKytrKuuWltfW1xeXWNjYrRfY19eZWdoZGRkaGJbXVxfX1pdXVxZqFFPl42IfHZrdXBucHNrS3lpgGJNUoVnYJdSZTZEYy0xVidiTn5RRD81QVlPQj47XVFJZDRZRF46NzxTSEI6cDk3ODk9WVRDSFVPgm5jmKZMTjpjaj1WXExlRCU2VFCAZ2CVe4NXsJRVuXmUeFpqXIRMXXM5P1lsllNSdG9zZ2JATFN+aUJCX2ptfEpeZEQyJjhpgGNCTFqNbV9lcY6SZ0xoWFFAZThdRDtDRTVCR1dGRjFVRUc8RT1UUU1GRkQ/RkpHVW2EcXp5fq6zsK+vrK+pn6OejoeE+v3fvuTBqHelham6g/J65Zqzl3F2WmdzbVNTRWpuWlhqeltfnoOLiYdZNGs9WllqR2RlaT5YVJB/vIGfgM1ugnun/oHrwa+cr8rY8+XU0cfY6oGFlKeRj4ydrvqJyOeSxaiWq7ejiOfj5OPg7+vX093wjJmN5Nzf+5qln46Mt6WKRXpySHx7ZEBFST1GKS9HSoFzm33KtpG1driyu7t/p5NCJzhpO3+CbneIPktf4PJ2orm8cIGLq9ZfW1tJgFNEPjk+SmpCS0lBc0lNSztrOTg9THdBIDY9UTI/PD6Ci0NHNW8yOHtlX1VST1aUS0lTUF96PYiANlRdNnc/QFGDlV9onWqjZ35qdXBSlqqk8c26a1x2t6tbbkZ5QjlFg2A7T2+Ro6Tpi4iWg/fLpOeJo7ywzs3jvoXoyoah0bPcgM/y6Mu+uaaLUHNfZ2ZlfXGR2VxcVV1RWD5IM1dIRSxDPkA0Wy9Sd2yChpKgp6WunXPnmtfF8Of9zbSOsqlkXs/gfp6Q/ejRwLiy1Iq98YLSotmW1tenkpaj1YzLoImPrLOStryVxuKPh8KhrYDu5crszLKm+puggoyWjoyF7qD5gIt974ShjcynssHH+7ByQGlOTlpDTVI0My1DaDZfQk80XDE6LVZGTUMrPTIvKTIqLlImQixBNzdMkX9RbWk7TEFVc11yNU3CXGdfWnhsXUUxaEhIQ0hLPksqXlBoeWJkRXGMSU1BPzQrSkgwODNeflRPO0E1Jkg+S0szMWlpOEQnhH0CfH2FfIh9BX59fX59hXyIfQN+fX2IfAd9fHx7e3x8h30BfoR9gn6EfQF8hH0BfIR9BH5+fX6HfQp8fXx9fn19fn58hX0FfH18fHyKfQF+h30Dfn19j36JfwF+jn+Cfoh/BH5+f3+Efod/hn6KfwF+ln8Dfn9/jX6FfRF8fHx7fHx9fXx9fHt8e319fY18BH18fHyHfQF8hX2GfAV7e3t6eoZ7hHoDe318hXsUenp6e3p5enp7e3x8fHp6e3t8fXyFeoV5hXqCe4R6g3uEfAd7e3x8fHt7hXoBe4Z8AX2LfAF9pXyGe4V6BHt7eXqGeY96hXkaent6e3p6e3t6enp7e3t6enp8e3p6ent7eXqOeYl6BXl6enp7h3qLeYN6hHmHegt7fHt7fHt7e3x8fIR9Bnx8e3t7fIR7F3x7fHx6enp7fH18e3x7e3x8e3x8e3p6hHsBfIR7inwBe4R8AXuEfAF7hXwFfX19fHuEfAh7e3x8fHt8fId7AXqEew98e3x7e3x7e3x7fHx8e3uEfB57fHx7e3x9fHx8e3t7fHx8e3t8fHx7fHx8e3t8fHyEe4R8BHt7e3qJe4J6hnsBeox7BHp7e3qGewd8fH18fHx9hHwDe3x7i3oBeYV6DXl5ent6ent7enp7e3uHegR7e3t8hHuHegF7iHqEeQl6enp9fX18fHyEewF6iXsIfHt8fHt8fHyFewR6e3x9h3wFfX19fHuGfAR9fX18i30DfH18hX2CfIp9A359fIl9DHx9fH19fX5+fnt8fYR8BHt6fHyEfQd8fH18fXx8hn2EfAd9fXx8fXx9AgIEAIC0s8B+fKKH1e+zvoC7rMaNms2jmPrqjYKF9e+boeTmxae4vuq3hKySkKOv56+0hdi4g5v6hs+Kq/yToZ+slvx2yPDRe9uEgbi0/a/HqOTDibuT4anh07KAm92dpO+DhM+Mkt+O7qaS+8zujtq81fCAkJqjwtiSwJOU2PHckNPfk4DejoyDrseOjZmdwMGsr9LT+te21IOispqdmKSKipiShqSjuKrDyau+tJ6OhJabi4uXn5uXmJKFgYyQkYj+hImEhIaLkISB/fmAgoODiYmOlpeXoKWclpCPlImCjI2HhYmNkYuLkZqjnZuZlJSPj4uB+fXz7eb46+Le5fbzwKqvhoDymIX0sp/Y24GBtJy5gMSHz8rMpsn/kcqN16Hv0vam0MaU17LirKe/2qedgO7xl5yYl9qCwbHg8/uy0rLEcHJ+mZa+/tXL4OeSg/OzyaCWnpCjmMim7ajqrcrwg62J05iHobexg4yapYnZ5b5/m4/Buqmo0d680IiGsaK8sL3T0oDVopOWgX68xMS/xsZ5mcKToH2tt+a+nYOKjYeVnoPFoLCmfa96taKPfXSUdmOIwn2CeWhvhI2Mjo2Gh4WCenp2c3VybmprZWeykuKUsqzFrI6LkOO/rcu9oZlnnGB7cXaEf3mPspxsoYV2k6KyhpKXjXbOd8SjzoKzoX7fppyfkIDYu6S/6Il2yJ6epbK9uNDkdOLWc399enRzb72Ywm13wox3h3R7fH+TkJZ853nf5Xh2wrGurNHY4MO7u+Lg6+vqyO2+ivCyxn7eo7PY4v3V7cLSx5untO2cj6mFxd6spHHB3Lyn/fKx3tiUjb69l+PTdoLcvpuVzON3ksaAtJuefoCGxNqQeMDCg7eI0dSpx8Pqia58sYy7n5PAo5x90Jeod8ucpn6Be4+UuduIkXSXhZ6olZm2hcjq9oWgvY+Fg9u67q+YrICRgYjQfq2C5LzXh4XvraSHrYF9ipmBc3NsgJLGn6OYpqluVkyUg4qDgmVFSn+OT4VpX3h1f4KFV2lvXoBkUl9vcFR4f4ysztCd0MrZx/Kz7KeUf26tko7Ja4B438/R1qt+pKCcmJZspJt6dXt8p56Q4drQiqR3r3OI0bS1frjSYnSGd2BQUpmUk1VdZ4aBg3eYiIBjd9yUoY6iaHptWo/Xd9PKgLd/mJmihGNdhGedblp2dVN5f2+qa3xzx4Cs17L5oYW1d4p8a7Nqg4uM69WKf4Jxc63QyrV1iL3Urb9q0+e/x57Kl5LbjpDggNLLxLPF8IqTsJaaobPNtaKym9XZq7WbmJtyqpu54JOB3Z//lLep+K+konm1hpOqy4Okk/qcldDJz4iw9IW4mtqdxqmVl9fMq5rUidGirq3MroDJzcuNkr2TzOOwwn+kqKqKq+aliN7sdVpuyNWMfaWpqZ2osvbDl8OuoLvA1KepfMqTbITpeKZmhu6EmaWape6E2erDhu9+jcWSn4mchaKFXologm2RjINRXIluW5NMWnxcao1XnVtVsYWLW4yUj6RZVV5jh6BijltVjpp5W4eGcoCkXUpOdY1iUVdac21ia4WLpoZ0glpzfXJzbnhiYW1qYnx7j4WZnIaWkoBuaHp/c3B7gHx5enduanB0dW/Oa3Bsa2xwdWxr08xpbGtrcG5yeXh5gIV+enR0eHBqcXJubnB0dnJyd36DgH57d3lzcW5nysO5t7K/trSussLAnY+gd4C1h3XaqpPAuHBjloujdLRvmKSbc6fbb6aK9aznweaYmXdjppGubGqFgWtqT5CkZGpyccCg0c/69umjq5fUhoqWwrLT27epvM2HXYiMlpB9dYKUhayQuYa6e5SxXYJytnBfa4V9cHSAkHq/4J6AmpDS0Kis4erM3Z2SwaPCzL+5x4DQpZyijoy6wMjY7fKNms2vnIrOu/PZx5uTkZuvs43d1N+4mdGTw52dlJm1lYSr6aSrsZyctKSaoZ2WmZaSioyHhYeEgXl7dHbHpMqDvr3OoYWQle+yrsmzrdmf7pSypqu4tLvB5uGSv66KoLPWs7a4spXzi9Gs/7Hox5L3qpyllYDkxK7H6ox3yZ2doqvAudPreuzeeIaEg3x6edGm0HeE15uClX6FhYWcm5+C837o7n17zb24t9Ta5MzJyvLp8uvkweTAifaapITajp7R6+zB4bKrwpeXsPKIdpiD1vzCqIC31s6q7PGm4ManmMu/mePthKH64K+k4veBoeCN1L67jICV3PqzmNzsksOT/dup18vzj7OOyJvQt63pxcKQ6au6gtalsIaCgJSWzNiRn4Cij7PDpaS2ic3s6oSe0ZeKhe/P8aR+lGuBiJPfiMCM17nUiIz009Kf056fqLSZkIuFlqnmubfJztSQb2TBpKqam35dZKK4Z6mHfZmXpKerdIyTeoCFcYGQjmmMgH6vta+Ww3KzpNuw7K6plYXOp6n0h6CR9tjg7cCHxc/RubqEya+LiYyLu7Oe+PzunsCHwoWZ9+Dek+H9eZKnmnxubsO9vW99i7CnpZu/qZl2htqRrJ62cYaCapflg+zsjM6KqKWsjW9ql3a2g2yNi2iQlX/FfYh4x4Cdrp3jno+4fJKDdMRxkqGl++etoaGLgLnhz7mBj9vyxNmA6/HX4KXDjp7pnpv/fuvUyayxx3Jxkn18ia25oX6EbauihJB/gn9rk36jw3Fox5DIeo+PpnV2f4C2d4qawX+hn+ebhp+cp3uZqXOfoeWGycathvfww6rWiaWQpavhxIA7OkE1M1RJVnxcXTI/OzwrKTwwMUlOMzo/VW9gVV9aPTE5MEQ9MT8yMj5Ja253SnxTSWXAY4BHTXQ3RT1MMUcnOz9QKUUsKkdhenCFb3tnRGZbakZhNCg3SnEuS1k7QnA2Glw2WEpBWEY8MUo5cn1JMz47VlYwKysjOVA/KS8xLIBYOCUjQzw2MDQ0Qjo5QlVfblRKUz5SWlVVU1tKRlJRS2JjdWx9gHB6fW5eWmpuZmFpbGpnZ2hjXWBjZGC0XGFdW1leZV9euLBcXFpaXVtfZGVkaW5pZ2BhZ2FaXmFfX2BgYF9fYWVmZGNiYV5aV1ZSnpCFgXyHiYeGiZWSdG+BZICKXkSXd3KphEw+TzFXOUhKVmRkUkdpOmVCcVlrY3VXUEdEZlpsP0VWUUk+MFtxLzc7O19Nb3GPk5V4e2l4QEBDSkZralZXXnI+NEZIWFg/SlJnaJxyo3uVY3B/PFBNg1BCRFxeYltnU02MgXJGU0J0YV1Sd4VraT1MXURSNT5UV4BTRUpgUlaHk5WDjIJORmdSRUFqWWlJQj1JQDlFQTdaQkVAOTs6TzhFTjw9PjJHbUtBRUlukLe4w762u7m1rK+ppaunpJqckpX0xMt4xMqjnYiVlfejnruglJg5XDpVT0pXWlVeeIZej2xkkqGhYl9UVl2kP1Q9jmuCclykbJiUfYC5q5zK35qD2qimq7HHwtzygPTjgpCPk5CQjP+/+JOR3JeGnoePkJKjo6iH+YH4/4SA3M/LydjZ49jJzO/l6+beyeKjWIt5eUSCa158h5VifWNbWkZLk91+cIF2ucSnnV6Po5mUmW89Nj1QNFRtUHenREOFhIZ9ftmAd6mEmE4/QYBbeFMwM3c0GkEjN1FcbH+hV0U4bWxPOy8tQz8vZigvOHJWW0E2NUJPeIRVTTpXSVtfYVhpRG+JlklmdEJASouGtYdhblJiS1SuXnNdpoOoUzmsj5WDnnlRTEtAQTtHYFV7WWi97v62i4H3zc2xs6CBitn4jOCzpsnE2d3mnsHHo4C2la/DvIZ5M0BTd39faUt5erdednBTSzdBPTtLJCUnUlRLQzgkTIV7fUpTzqhbQkdMs7Wb9v/xbn5cb2BWmpWsa765gq3CvZyPjOzj746mvejb2cn82cSRmcOBxMDtkayphqftb8LMb8l8t7i+oIOAsoXTnYmsqoayup/8pKCE1oCZlIzSq6nIk6WVheuFjmtTclpFPUA6QFllTUkxO1VRQlExSVFEUk1jPC5mOi1SKVdZUUpabEpVdHJjU0lJOzVPTXhjSE1eYHOIgll0azQrUU13XWVoeEY7QilcQktldlBQNntLTF1PTUA6VC0sJ0tAST8rMklHQURJMkk8UjYtJoV9hnyLfQZ+fn18e3yJfQF+hX2FfBp9fXx7fHx9fX1+fn59fX1+fX19fn1+fn18fYR8iX0Hfn59fX59foV9B359fn58fHyEfQt8fH19fXx8fX19foh9BX5+fn19jn6ofwF+iX+Cfqh/jn6FfQd8fHx7e3x9hHwLe3x7fHx9fHt8fHyFewd8fH19fHx8h32CfIR9gnyJe4V8AXuFegN7fHyJew96eXp7fHx8fXx7enx9fXuGeoN5jHqCe4l8hnsDenp7mXwBe6J8gnuEegV5ent7eod5A3t6e4p6Bnl6enl5eYV6BHl7e3uEeg17ent6ent6eXp7e3p6iXkDenl5h3oBeYV6AXuKegZ5enl5enqReQZ6fHt7e3yGe4d8iHsDfHt7hXoFe3x8fHuEfAR7e3x8hnsDfHx7hnwTe3t8fHt8fXx9fHx8e3t7fHx8e4h8B3t8fHx7e3uFfAJ7eol7GHx8e3t7fHt7fHx8e3t7fH18fXx8fHt7e4R8BX19fHt7jHwJe3x8e3p6e3t7inoBe4h6i3uCfIZ7A3x7eoV7hXyDfYV8FX18enp6fHt6ent8fHx6enp5eXl6eoR7Bnp6ent6eod7g3qFe4h6BHt6enqEewl6eXp5eXp5enyFfYJ8iXsIent8fHt8fHyIewN6e3uNfIJ9hHwBfYZ8B319fH19fH2GfAV9fXx8fIZ9AX6HfQd8fH18fH19hHwLfXx9fn59fXx9fX2EfAF7i30BfIV9hXwHfX19fH19fQICBACAkJrNmeCJ0vGE+pqhwtXkpYPervfPkoDSs4n90pC5nsawpMTS47vFpJC83KWLg9jcoY+Rr7T7ht6Gs7+Z2s2jp8D1fuSTg+G7s4jUvPW33/Pkp86p7sei7IuW44/JkuOx7+fo6pHZ0c+q9Z/Ei4C4xsTeorqVkYeMstP7zNj25dCA/f+mv4fljZSpvLzQ6fzJz+Pg1YKN6pCYnpecobq+v9TZz6KkoKGkkJyus6uzpZyZlZGSi4uVlpCNkJ6kgPyBhoKGjoeJjonxgoaFipiVlqKYoKeqn5qLh46Ki4zy+YaRl5OUmJagoJydmJGZj+3k3tfa3vf989Tk2eHw4sygmfGAktzU3aKAnt3tzcrqh+rejdODs6eire6co7DOvIh80q3gocfPhPzA1e3Yxp+X+o6ip9zHo+3R6Yu98ca8wau88Z+mcqaE2ueru5am+PaI24T4rJaJ0NWG8dao0OS028KhjLiV9ovTo4rez+O7vMbeipGQiLfPzMSfnr/TtazJxtSAmpR6e8N5gvGJ28Dmn8GEqcaHvfHFspOBhYN6dJeYvM7OiJF9hrKrlqiCYIOCuGyEv5bFhHqXm5mUk5GNiIKEgH11enZ2d3Rxabn7ltd7vpKq65eZ18LIZ2FlVoCpdmuAjYSChYqThaqQkbC2uppsrWl14qHZjLx9nsaNipOOmaKAu9Sgop59zKynn7W3xHt4fXV2c3Z6emWxvqmjtruFn7l5t719g4GpnXeQk5yfln+RierW0t3a8NPAusHKwb7GyrvE44edo7zw4cnM/6vupcmEgcTAlbTNrrmugdOIh8CY84K4qryMjp+xvn/gmYGDxYx6y3DYg76fwcuxzpp8ipKAhqHazMFstLLedKaUxMTV5niEg7qtonfJbrOigHDY4dR5qabz2uSEot3Tl/TtfnzNq5u54IDm7JXq1pBx8NK7yciavd/ljdjymp+fmL+ptuS4+trkmp98iptaVrZ0eI+CeoNtZlaDeG1ZYVlKYndPWm+IgHdaX01HZYZ+cllaWFiAbFBPYH9iuIvbgZrX3IP8rsPIpsWWj4WYur+6z223nsbKZnLDjXGasXyxzb+Knc+extNyb4OStM++xK59urGKmr6FsKeisVBPgoOGiJRPWFN/e09/h5ONdKbAxbJkpm97cmGryYftfNZ+v5COd4zG37+DuHRkdol/dG5UoWZccW6Aarj8jciHn5CnsJ+WqKOAo8B9eJ6TedR9m5KCkJuwraKb8MR918S90uGfh5uMsdDP5tGm1+b72df6nM6ygu2Vw7OB5L2lhPyPlrWmwbqTvciLutitn+vS9raKh5egeaB+zO74zLvz36je2oC6yr/rzsLPu8F/57K1m4uQlZOknneAn47Ks/t9u9966IR5ipazm2vquO2ucVuehWvdtXmPfJiNi7vY0s/GuaLZ9LSKd8PNkX58nZi+ZNKBoryYveCjuc7vivd3ePaalV+nhLOBl6iqgaOAsYh2lFdtr1p1Vpt2mp+WqV2QhYd2pIF8Z2mfhoKKdpBzbGJldIuObI6jk5yAubFndE2aVVpmcG99mJ96hpKOj1tfm2ZscmxyeouPkZ+jnXt6en6Dcn+OkIqRiH97d3V1cHF7fHZzc4GIatBqbWptc25xdXHKa21scHp4eYN5f4WGgXxxbXNvcHPK0W93fHd5fHqAgH19eHR6cL25trGztMHDvqm0q7G6sa6GgNOAiNbE05ZyjL7Purbld8rUfMN7k412crZ9kaTCoH6A6J+8cZOoYqp3fIt6c2JerIKNlcbPu/3g94iNybWs08bZ+qavg4xttsWIkYuMrKdkp3zPn4uDv8Bmt559mKWFsJp5ZIiCvnK0kn/Su9+1y9D0oZaMmcPk0MmusdXgya7Vrb+Ah5KKjeKFivWS17fnuN+KrsWa1enb1puKkJWDh6641fXrnKCOpM+0p9Cyg7Wh4ISr9s3znZ20sKympqKemJOWlI+GjYeHiIGDeNHjh+WEy5in15mez/PohJGXgMH7tqG0u8eyt8LDrr+yt8/c6cyS2pWX/ML6nu+4y/mqm6eQqKaAv+WqqqZ9zKuqn7a5x4F9hXt9e3+Fg264xsC90NCXs8uFy8uCiIaypHyUmaKkmIKWj/Lb1+Ld99vMys3VxsTJyLrE43qakpPTu66w+6zZmLh2cq2whrK8haSkfd2Whcyj/4HEtsCYmJ+o0o3xp5SU2qCP34L4htKwz9q93K6QoKeAkrb15+OB28r+iMKh0NPZ84qekc6rqoXsgsm1jID+9eOAtrf15OqJnObdmf39gIHlwajH6n3e5ozY2paA+t3Kz7iDlb7BjOX9jaOeoMq5uum58OPwt7qXxdqDgf6Qh6SajJyWjnWxnpV2fHRrg51ueo+ro5ZzeWNhhrCil3Z4dHaAkW1sfqN9z4fZdJG8yXafkKenq9GmqqG91dTc743jxOnygYPlm4rB65jT99+ovP2dw+yBhpSpz+TP3MaO29Glt9+T1MzH3Whmq6qzr8Vnb2ycnWafq7aqjLnL1MhrsnmWj3nF1oz5heKE2pmTepDP58eS1oh1i6GYiYFjunhnfXeAbrn2hsiNpZStt6mitK+KrdOTia6sjfqMpJB3k53DtqiV9uuO4c27xdyni6aOsrzJ1sOSzM7QqaS/cqyqetiBqpRcraWXfN6HiqmdvrOTqbV8lpmReqGs2rmUl5msh6+M3vjwuZOxxILIs0+Roa7o0MTOz7+F8MOygH91ep6xrYSALDVPRWpFbn1Aaz5CRjs3ODBBOVVSNSpgSiZNUjleSExEPjwyQDM3LTI5VVlEVYl0XVxgiH+ORFsyQUE1TVo8NTk6J0QpKkBMQUaGbJFmc42Rf4dgfkZGekEsRkNiT3xJcmlIOSVGPEA9VjxZQC1AXkd5MTgrKCgsQ0RKOExePjGAW147Ty9ZMzo4Q0FLYWVKVl9bX0BAa0pQWE9XYGlxdHuBe2NiY2lvY258fXh9d3BpZGRjX2Fsb2djYnF5XbddXltcY2BiZ2W1X2BeYWlmZG5mbXFwbGlgXGFdXGG0t11hZWFiY2JmZ2VjXlxfVZKVlZSTj4+Nin6HhImSkI1xZ6KAdbu3toVld5CNWGlXQWJjTmcrRVc7OGg5OV1cTkVGZlNuPU5TM2BGQko9Qzo5bVhRVWtfR3p0hkxThXtzeGx0glJXTEUuUVk9UE9CYFA6akuQYldYeJhamHpfdHJVcWFVRF5UiWCVblt7hYhvbmxjPUc6OmRiXmtSUFZfUzY1NUKATT1FOnFRWsBtoYKabIBETlM9aHRYTENFNjs8OUc/TWJgPUU7Sk1MQk48Kzw/SSg+Q1mnj4HG1dDJycbCu7W7ubOosqipq6Cll//kfO+AopCq3J6gyL66Xl9iPU1fXEhbZmNoXHBmYaBybKefgV5fqF5s5XhpQ3Zug4ZWUmKKi5WAscucq5qJ37u4rcLD0YqGkIWHho2Wl4HL1unm/v2iu9qSzNiOl4+1rImVnqinoImckvnj3ejk/djHxczPxr7NxMnJ32JpeXycioCAkUuESVNHT1FUT6vIfI6Ra7yBXaiAqVyMl6dUQD0+Xl3JfFBLuVVLk0uEQISMyMiXv3BHQDaASVFdYoc+SkQ9G1FQdXaFkkE5RYtISD1uN1NNQzJTXXY5WliGdmwtR2tTQIZ5TUiXY2JwbkmIjmigf1wzd29kj5hrdJGGVn2MWm9jZXZcaHljrYqXhklHX2M0NYJMSWBmbmBsn5joy8iao5iasNKcp8Lg1byWnYaKtuzWzJ6jnKKAx5aVrtem1kZyQ2qJdTNdZnh1X1ZWSUk8SVVHSDNHOUhLKSdEKylHgTZGeHl5P0gxadd1P1xgcV1LTFZZiId0eqFSl6LH/4GA5Nzn3f+HkZDD0IrO3+/cqtnX4/WAx4vKwZzr4HLGZMl32J2VgZrg/dSz+Z2QrMGtqp2C7JaFmpSAh9D4fsGeuqG4uruxwcWXlGw6M0VHQG9IRz8yQzo1MjlIbEgrT0tbXFU1Pz42TFxddF04W1FCYoadVFo4I1M6YE82cl9YXI1IbYxriWxJUFI9VWNtW4FPQyw2KTs0KS4mXn6Fb2Z5i1qfcSdJOUQ8RDQ+MD8oTkdAOS44Ny4rIRyEfQZ8fXx8fXyGfQx+fX18fX5+fX19fHyRfQt8e3t8fHx7fHx9fYR+An18hH0Nfn1+fn18fHx7fHx8fYZ8C319fX59fH59fnx9hHyFfQd8fH19fXx8kn0Efn5+fY1+A39/fqd/AX6JfwF+lH+Cfo9/kn6CfYV8hnsFfHt7fHuIfA17e3x8fHt8fH18fH18h32HfAV7e3t8fId7B3x8fHt7enqGewt8e3t6e3t7enl6eoV8C3t7fH18e3p6eXp6h3mIeoR7hnwHe3t7ent7eoZ7kXyCe4l8CX18fHx9fHx8e5Z8AXuEeg15enp6e3p5eXl6enp7jHoPeXp6eXl6enp5enp5enp7hHqDe4R6BXl6e3t6h3mKeoZ5BHp6enuQepJ5Ant8h3sCfHuHfIV7EXx8fHt6e3p7enp6e3x8fHt8hXsGfHx7fHt8hHuHfIR7hHwDfXx8hHsIfHx8e3x8fHuFfAR7e3t8hXsKfHx7e3t6ent7eoR7AXyGewF8hHsKfH19fHx8e3t8e418BXt7fHx7iXyEe5N6iXsLenp8e3x7e3t8e3yHe4p8E319fH19fHp8fHt7e3x8fXx6e3yEewR8fHx7hXoBe4R6gnuFeoZ7iHoTeXp7fHt7e3p5enl6eXp5e319fYR8iXsCenuEfAN7e3yMewp8fX18fHx7fHx8h30DfHx9hXyEfYV8AX2GfIR9BXx9fX1+hH0GfH18fHx7hHwEfXx9fIx9C3t7e3x8fHt9e3x+in2DfIh9AgIEAIDJyILQl4aDjaK6+aSNzbbQ0fzZr8q6n4Pale+D2M7T25DFvauPtqSHwup+57qhvpL5wMS13p+SnN/Jw3jRitKassDhjsfw6fO+poSx/LSEs5aiydu+97bvwqrXoObSmturmpTLurbcrc3bsuqu1oXvr5m0uMuwrr7onNjx3NnSmIDxiJKulaqgkaG81Yrv5d7n4e7mx9yZq62gvsu00NvZvKGjo52Qppeqt7nAva2uoaCMm5yQkJCYko+NkI2FjY+RjI+OivbS6fLv8ICKjIuWlpmkpqOjoJ2inpiPhYKJlpeXoKScmJmemJOQkIiB28HUvsLh6/Hk3r7Qy9DSrqSgvIDQgP7UwobX5tid4Pzpna/DxKKlvae2pI+Ez5jJioWFvv7am3+HpIqbwJ7uwbOnzYmD47jF8v7nqJ3wwr5ybXV9zOKLi6SFrdLyr5Kf0JP3wcCckJyh5o2r0o7olP/xxZHd9MOQzpLJ/dS3xrvArta2orXB83t87fW+v5+e2ZTZmYCLpoqCleyur9HHq7aQlcCkun+pzJvSh4ar09Xrk7XOpJiR1G91pYmPo4OZaoaNzpOSwp6InaSjop6akI+Pj4uFhYCAf3J4enVuaP+Vya/1j6ao5X2mcHVwb4SPeJBsdX2Ko4KmbYaNtY+iaHyJh3t2bXLEboVrwK2XaI7Yl46AjoC9xsepoti8nqSsr8J2d3VvdNTSa3LGr8axprmLdJiwqqRwlJyNkISaequkoKejjZaNj4Llgnl/587AubO2wtDN1NPchcyw1+nenuWvv42MgbWjq7217LigxuDOzbqdfeeWuMucxn25zoHkhYHXeXHQeOfbbGx3h8x2lnnMq9p/g4B1dbGyrbyCfIKMl6mpm4OCwdx+ip2Hx7t0bL+hjaqZgbSsfbfpoYG2j8Hi0Yy1vIKwqrCp3pa+go+htb7DsK6hjJWXuOfbk7SN+YithLezipWu17upd4XSfbR6jdCEmG1osHWbiW+Gfkhwa1JLT1ZISluLfk9MWFFxd1JTUFdRXYBTU1VjSVqc1enute2fvLrI2KyywZqLdrtv1dW1imZpv6CXsJF8qYOHj23Pto+HmYahyIHNg5iGdnt707rVwIKUmaPJvqWvhY6AdXyEeH1OYHZ2cIN4V6Jye4mgeKftn3JlZlZ4hsKYlcOH25vkzpCjttasd2ufXH18glxihb6eoICFjaKSh3Zuk5zKnKSup3aoyXiW3Zt9eJ7XnqGUx7+llp183Hzi49SZveiR1q2LgKybg9HGg4KahfjSrrXZ07C9xPvsurHujOyP1vuAgoL5jZGv55jT7q7Fk4S5gcTQtsTR546T8P6A6+Ch8bmpnab33v7F34SQi5yi55vJvLOZ4IDE2ZDfinB2eniMtnqAqqW2utOmma+HcmKxlOiC0KeSmW+Zp6xywreWyNqH/8WOmH/ksq2QqW1cZsmnmYbmk+KZosrpdtTmvb+JeVphoopTin14m6mTro6ph3qIXpONYKJwZ1uDe2yDcoqEb7BznWCdhHeRlY+Ij4ikYn+KeoiMYICbXV1hUmFfYWNsg1yinZ6cl6SegZNxgIZ+kZB/mqali32BgXpreHaKk5OZmY+Og4Nyf391dXV8eHZ0dHRudHZ1c3Vzcc6zwsfExWlucW96eHqDhIODgoCDgHpzbm1weXl5gIN8eXp/eXd1c2tntqSxoaK1ub22sZ+nn6OjjYeElYC6g/nGtW+sr6SKxuXbj6G2o4+ImouYknlyo36rfI1/odO8gYCOiF5elZWwd29pl2NftLe+waasq5LmxM2NhoqE3v+Lj5JrkIqNg29+k2zMpZ2YgZKa6mt+tW2+dNfPpG+eu7t7rX7B8ryszLWhotmtl7bH+oCE+/C82aSi4Y6pioB0n4uIieK7v/332c+QlaqqvIqTppndjIqkzc3rrt7+xrKY64OGxrXAyY27jq656byz+r21wLu4uLOtn6CgopyWmJOSkX6Ii4Z9eO+J0rb8lKao1X6qm56Ih7jQo8udm6TA2cLQh8S81qm5iqSrwK2og6Pml6mB9tnSg6DxqJGGlIDFz9Syp9u8nqevtMd7fHt1feHmdn/ZwtrLwNObgKnCurJ6naKUlomgfrCno6uijJiMj4LtiICI+9zMwr3AytbR1tPYgbmasdbOqdm2xZSGdrWknLWv6aiDs/jq0b2hi/up1t611ojP44PvkI39koXlgOvvgZOFk+GCo4TjtfuqqoCJhL3GwtyXkJKVsK+4soGL1v+FkbGU2daNgNSwor6lh8K4hMD3pIXAlMfn35avrYq5tLiv24SdcoWhtMbNvrWkipGRqMnXlK6G+IWynujDj5m24su1ipf4m+Koyv+hxoWG4p3ft5Wvp2KXj2thZW5gYnWuoWNjdm6YnW9wanVsfIBucXWEXnas1NnSpeubnYXJ47zCw5aZi+WE8/bHpouI8MO51aWOx5mnp4H53K+js5Oy8Zz2oq6eg4mC79zz3piutcbq3sPQpKujnZqfl59ne5CSj5yMZ8OMj5iqh7fwmXdzemiGh82Wj7iQ3qbgypagsdS7jYC7bJKWm294mtGssICQk6qWiXh2nqLLn6+9sn2u0IiaqpqLhazrqZOd1dSzm56K/Yf09s+bzM51uZ5yaI2BcMPIaGd1aNGiiaO4lnuHhcTWr6ruiOaP1/5xc3bNfXF/roigxpunnZG+i97qtd3V+nBuxa+Q1cSJlYOSg3K5ttTO74qOjaKb453U08WZ5IBOVDVcUlUzLkVLa0pBVEtNSF1MQU1MQj5dL0owO2lZWz1URjEsMzMrN00rYFVbbFGwlY94fkc5OWJEOiZCN1o2LjVGIEZRZ0k1XipLkl84d1lrYHVdhV5jNyZQWHluNi9AQTlWOkA3IzgwP3JFNCNfLyQmIS0pITRBN0BDR1NJLoBOOTE2LTg2MTdAUD1wbXBraXBxVmVVY2lhcGxfdoKBbGhsa2ZVXmV3f36EhH18dXRlcG5lZWVsaWhnZmhhZ2ZlY2ViY7mkq6urqFleYmJpaWpvcG9wbm1vbGdkYmBhZmRjaGtmY2VmZWFdXFpWloaSh4iTkpOOhXqCd3ZvamVjY4CUeeq7rGCKg4ZYiKJpSFlQZElZYkc3Tk5FeEtTRklHXFpARj9CSzA1VEZgQD07VDQ2aF1ZWlRYVUyIdXJDPkZKepFdSkEkM0FIRjVSWFWbfFhYVVhgfVxqg1qlVaigdVF0fU9BdWR4pol1dWpNU2dcWFRUczY4ZmpSWT0+TzY/Q4BGXlVCV42Cg42JgHhdWFNFUjZGXUlXMjhDZHJlOkVSOVRRbjs+Qkc6OTdDMzk1Uj48jsWcy97e4dvTwMHFxsC5vbq4t5mpr6eel/R/2q/xkqWx24SodGxlY2lmVnNZW1ZaW3Z6Rmpno2KdU1hYY2N7bGvFc4hehnhyQlZnYZOBkIDBxMu7lPHTsbS9wdSCh4iBivj/hor03fXy5vKkirLLs7mEp6mbnpGqisGxqLOpkJmMjIP0inp14NDGvba8xtLMz87XeYx4kJyOWXhFVUlAR0xCUFxizJt6lca7toNyZch4h6SCoEyXZDq3glqZQUeza97tQj5FXcZznGqEepdBNIA9QWtkdWU+STtGTWhWUkg6doFIQTNIf3NDP3NkVl9XT2dVOF9mPT1KS3B4fVmBhlxfXW1rbFloVWZcZ3BvY2hyaISDkIp8U1o+t1x5YXGAXlZbXmd0Qk6Ya4ldcI9AT1l7Wk3a7MDb2oTKu4yAgo6CgZzhz4GIo57Q1J2ZkJ6UqYCVm6K2gJ2qdHV0gINXX0NRZkdBYjgwM0AjS1BGOTAzQUVARTsnPzw+PiRPTDgvNzBDgzxNMTo0KyktcHyQiXaFm6KVma7KusbQzLzBuL6HpLa+vsqzgvGtqbC/qt72hYmQnYiWfMNycYR64bHby56hp9PUsp3lg7m5uISYwPrHxYCnqr2rmYqKr7HOs87gwoOxujg1WD9AOkZZUDtIQDsuOT4zUC5UTlE9PGBPaV1ROUtZR1lnPjVTXsiEWkRpZEdKTol7PjR3QVpNdIE3SEd8OUpUeGd+hDM0NDQ1LE5HNU12e0JKmXBtrqBaY18+Qy1JSUc8TyonLTE0YDk5OzEqTgR8fH18hn0BfI19Bnx9fH18fIZ9AX6FfQt+fX18fHx7e3t8fIR9Bn5+fn19fIR9An59hXwFfX58fH6JfAR9fX1+h32CfIZ9BXx9fX58j30Cfn2KfgF/iX6vf4Z+o3+TfoJ9hHyKe5Z8C319fHx8fX19fH19iHyDe4R8CXt7e3p6e3t8fIR7AXyFexF6enl6ent8e3x6ent8fHt7e4R6h3mFeoZ7h3wFe3t7fHuGeol8B3t8fHx7e3uGfAF7p3wFenp6eXmEegF7kHoGe3p6eXp5iHoBeYZ6hHuEegR5ent7h3mFegR5eXp6hnmGegF7kXoEeXp6eox5CHp8fHt7e3x7inyEewh8fHt7fHt6e4R6CHt6e3x7fHt6hHsCenuEfAV7fHx8e4Z8hHuFfAd7e3t8fHt7hHwEe3t8fIh7DXx7e3x8fHt6enp7enqGe4N8jnsFfHx8enyEe4h8Bnt7ent7e4Z8hXsBfIV7jnqJe4J6h3sGfHx7fHx7hHwBfYt8AX2EfAt9fHx8fX19fHt8fIZ9AXuTeoh7iHqFewN6enmEegF7h3yEewF8l3sGfHt7fX19hnyIfRJ8fXx8fH19fX59fX1+fn59fHyEfQV8fH19fIR9Dnx8fX18fX19fHx9fX18hH0DfH18hn0TfHx9fHt7fX17fHt7e3x8fX19foR9AXyFfQF8hX0BfAICBACA1Jv747CWyZKeo86h99TF9IPv3oKrwNnbto2Z5rbrhuWnjIKCl6iTlNTZ0+DC8qyvhbqX8JGxzot89aLY1YGby5XK2cyLgdu29bWxvNzjrd/5tt++tLC50v7jpfju3YeAobipqszCgo+HnPSZ3bykg5WysKWNna6dtbu58oiNv7+AkeelqJ2ctdbVybev2eXpztP3gJS9w6uLocm7m6CUmqCkvrOjt66zvMK3u7SdoaGYh4KLlqGko6aloZ6akJaRjv3u8/OCi4yBgPP+g4iMlZacnqOZl4mZnJqSko+AiZWOh5n9jo6UkJCVkIXo8vDIi6jL2unt3v7w9O/t3sjN4/WAuMiL1+bAnYHk1tyggI/plKiViuWcwJ6Aicup5YqVnrHYlr+YgbyRxvzo3omj7fa5n6HLiquRkpSEzpTHiZCA47a0mPqKgryR77+cirao2cDrvKnGg7GwxPfB8eqAnPSMqtiyw/7amp++gbS1ssrjg67DrZGYjqSOkY7bjp6u0ZSAoYqCn/S1yqaws9bLzq65sJz/gpOG3sqxy77ftsy60rWGqLGYkHWOgYOO2MzRw2uWr6JucYKqraiioJ2amJONjomGhoWAf3t5dmZ9lOnAlK+RmKC7375oZHJ3ZVxmp2ezZb6FxXltnaemrcRotHVsrp1qc3F+gXtxd5u3uHrR4aOAwHroeJDowLalsszbddLBucdoZauaqqOOvK6Eop2s2XTY0Xq9pqeUlZaPnZ6ZlY+LkqGF5tLnh3rewrnCxtjK09fF2vaGueSJ5v23tq+kt4nliJvag4mC3HzvkeGMvY6EyMzUtXGGcpGdfqOdcGzCuZPc0Hdlz7XJ0JqApHKNlIyAh5DRzJKWmJzQ0I/RoqndzXKPitl1kJO/f5CsfJyPnYGa6taNvoKN+oTA19zhq6SN2OqzpNmXvZuLo5aMqnyOku7FsrDCmJLwxuCZpISApHeLnNPQhop5vrSOqpy9gm+FkX9ecGRrX4CXooWOooWKlZFab5qASFhtaV+IWVBPSFGAXF1RfGBLrLW6vuHSza7SztLP1py3ooK1xMtwvqiA121cipu8q8aQtXd8dmq8d3d1j6a9e29xf3uTicuyvq3Wpsu20cjTwW95fmW+rph8gU5TW1pspFeXe42JqLXWi8+Uv6R9e3TWpdO0pa2SlKrY0JnQqHlol4hYhFVtfI9qa6WAhdGu29vpmIZ/kIGKmM6vgorLi73brreAgYS0pc+XgnR7gYyRgOOFr6uP0KDeidjNlOaMpNinj7H2nqud4JuO/oL4+5OrlJrb7OLD2IjjkOCGyvT74LSoho7GgdK5yIG0mZCf6s78r+mu1qvz17KLjo+x0NiPwOKnkc1/so+dxriA7K/30JR5sGxzeZiG7Me2zl6rlGeSmKaXlZWW5rTObMGNd3KFoLScgr/i5u7T24eOZoRxxXB4iXyC/n3x9ZGoxJOp4uGPWZiIunN7YpyYW5/Mial6hY2WpsKPdKKfi1JVXnRra4V6Y2hgaKJxmYp7ZnKGioR2hIZ7iHNkj01RdHuAWo5qYlpYZX6AfnNtj5ynjI6yW2yMlIJrfZiOb3lvdXx/lY6Ak4qOlZ2Tjop8goN9cGtzfIOGhoeHhIJ/d3x4dtXLzsxsc3NqaMnQa25yd3l9f4R7em98fXl1eXVrcXpzbXfKc3R5dHR5cmq7xMOqgpGnsbq8s8W6vrm3rJ2fq7uAk7aHw8OlemWwm7OIbXrBgHx9cMGDmYN6eKGN0YyVjJumZIeXeZRVbrn0/ZivzrN2foanbXFadqqV5Jrep6WVxY6Ld9J9Z55wxHlPWHqRtq3Ao4+sdbShntanxLZ1j85zhrKktfTUmpq5caynlancgrPJoYmjmJ2QlpLZfZ+uqXCAn5x/i+3D1rbNy/3b8rKinJfudHR+z8Spqb7gxs/W782rtq+cm466nJas6+P374DD4ceYlLHHw763tLGtq6ScoJqWmJeRkIqJhnd7hezEkrGRm6O449yHgYygmYGAyYnnhe+96pGMwNq8weud6a2hyLGFioaurbeak77tz4fl66yAy4D3fJjtw7upuNTkfN7OxNZ0csKwwbqo1cqXt6++7YDk44TGq6uYmZuSn5+XkYuLlKSI8N71kYPszsTLzt/S19bE2fOAqsuC0vmwwcGbpYHQfZXVeH5604DsnuuItY6P3OjvyISXgJ6cj7SkgoDjzJ7f4piJ/cjf4KyPvIOiu7uAq63i56KtqqXh3Zfir7rx7oe2pPOJoKXgk6PCiLGirIao996WxYaN+orP19zaqIVvvOyyn7J2r4h4nZ2NrIKepPW0loCZeIzGtrKWp3yHoYCYpN/djJ2K4sqi1sfyppWtu5WAmIKKeZ+8y6SwyKaotrJrh8CrYnONiX+0c2xpX2yAe39vonxizLq1sNXs2sXY2/ft+qfOspfY6PSA1L+T+IOBnbfcyOyo5IaKi4HdhYqIq9TgkIOGloevjM7J2cD6wujV7uDt34qQmH3U0sOhr2ZudHSEvGizkp2WsJvEj9KMtqWHlHzdpsm1o66Mi6bay4vNsYt6rqFrnWWGlaR1dLOAidm59t7vn5GKmoiRndW0g4raiKDGwdKMjpCwsNeejYmJiaStkPWPvcCHmnmqbq+7i9xxdZ+DdIjDf4uLw2xhpFnk2pKciJTD7uXI0o7oieZoks3WwZWOd57mhdbJ24LCknZ21+rLtdqNsI26mHyEjnePz+CGxPW/qOiMyKa34s2AVk16j2FajjdLT2hWUEFJUitiXTRMTFJQSisyTzorGDpCUDArKS0qK0RLRU9CgWJJPk5UmVBVWkYvSCxAPigxSjM8PDoyLjI+hWJWY29mWXiPZ2tlW11iWVlWLmhgb0Y6TUsoR1ZZMSUeL1g9KikuIzwfIyEbIS8lJzU5VzAxS0uANl08NjQzOUlNT0pIYG95YmOEQVFqc2ZKW3hzV2JdX2hqfntufnd6gIeAd3VqcHVxZF5nbHRzdnV2dHNyam5qa8O+urdeZWNdV6+wW15iZ2hrbHFta2NtbmllaGZgZ2pgXF+rYGFkYWBiXFacoZ6PdXuIjYyOhoqDh4F7eG5xeIqAcJV3rKaPX0uCanZSSCxhOFZKR3ZHPm9HSmRmazxTWlNWQk1MQk8tOmJ7d01aa2Q7QEpdPUI1P05Kg116TFBKgF5lWaNUL05HcUEjMURifXltW1RaSWhrdql7ko5QXppTYm5MZ3iBS1txT2twZ3FtPEtkS0FFMDc8QzxqM0U/RTiAPzA1TFBsknaCiZ2CiHR3S1GcQkI9amhCSVZkVFZJX0BHYF9DRjVISDdBdm5wXixNpsx+b5zj7efc29fT0Me/w7y3vby1tKyrq5aFf96+jrKSpKq98cxhW2BiVVlVjlGOV4FcaE9gnKqipqRfU1peqZ9jdGpza2JZa25uYliy6aqAzH76jIz929K+yuX3i/bg1++Fh+jN39vL9eikw7zN94To/o3YtrehoqWap6ebkYqMlaSH6dbdenbYw7vI09/Iz9DP2+Vwi49ajYRvRUFRT0ZUJllZQ2txu3zXe55BQWFslYWpikdTVTo+i4VASkqVuXvAwTk2fpmjtnlVRSQ+RzmAMkRugmZQUkRQZElcTlRzXjRPXXY+QDl6WVtrQVdMZk9FhHFQcD43i0pbgoOQgmlbfGA7VWY/SmJZgnNga1ZdWcCScnJ3YFKBaJdhVlZYhlVRUIy/Zl1YpJuEdWdqRUpddTxCf6Wuk8Hm/sbZ+9fX5OGFp/ryjZm8uq/2mY6Pg5OAprCZ2qmH5m1gfY9BZzZARD9BPUZFSzk6Oz4qREU2bTczODVFQz84RTcmKCZBKig0P0RCJiwmKS0tLFdkenmTkKGUlJWbmpyruJzr/v/T8YmTmpqw84PVl5WkyIS6n9R8n5Sbs4/dgIKGgbKJhJ7lyX3KtZ+W08WJ0IKpvc2QitKAZMbN3s23sa2isJ6nr/DCgoZ3MUtaREsqLTdqUUEyKSY1LzMoK0o0QTs7a1SHVHdLOWlET3JPXm24bmdXjVA0bTx2ZzMwMztId2ZpR0WNV4BJaJWYbE0tMjpLNEtIPS9OVDZLkMyJgrheXWB9UEY6PztCRkYzO0gwKkQmOzAyQkYHfHx7fH19fIl9AX6KfQd8fHx9fHx8i32KfAl9fn1+fX1+fXyIfQx8fX1+fHx+fHt8fH2FfIV9CX5+fn19fXx8fIl9AXyLfYV+AX2Qfq5/hH6Ff4J+l38Bfoh/ln6CfYV8DHt7e3x9fHt8fXx8e4d8AXuFfAF9hHwFfX18e3uEfAR9fXx8hH0IfHx7e3t8fHyEewl6ent7fHt8fXyHewJ6e4R6hnsLfHx7e3p6ent7enqFeYV6AXuFfAF7hHwBfYR8AXuIegp7fHx8e3x8fHt7inyCe4d8hHucfAR7enl5j3oDeXp5hHoCe3qFeYR6gnmKegR7e3p5hHoCfHuHeQF6hHmCeod5hXoEe3p6e5B6BXl5eXp6jHkHe3x7fHt7e4Z8D318fH18fHt8e3t7fHx8e4R6EXt7e3x8fHt8e3t6e3t6e3x8hHsEfHx8fYV8jnsHfHt7e3x8fIR7AXyJewV8fHt8e4R6B3t8e3t8fHuEfIJ6hXsCenuQfAV7e3x8fIZ7hnyEe4V6hXkEenp5eYZ6iHuEeoR7Anx7jXwFfXx8fHuKfAp9fX18fX19fHx8h30CfHuTeoZ7Anx7hHoEfHx7eoR7A3p6eYR6CXx9fX18fH18fIV7AXqEewR8fHt8jnsMfHx8fX18fHx9fX18in0BfIR9GX5+fX5+fX18fX59fX18e3x8fHt9fn19fHyFfYV8B3t8e319fHyFfQ98fXx8fH18fH19e3p8e3uEfAh9fX18fX18fIV9AXyGfQICBACAvIrd0uHE45OOr8CAgdid7rvdx4jG7tu83qK6qvuBto3u+r3I+LqyrLmHtcm606Kp37L106buneHi5v7k73aAmqTAvJqTkoHSrailjvbunrehtp2x8ZWBmLKex7WC46+Gg9Km25yA7oDQwL2V0M/cl8KYs+WpoLyS78CCi5m1uraAp+Ccpr6osLmUlKnM8uqC/IKHnKuajZSTpru/m7OqqranqKahlJaarKuhqJCNjJGSkZ+hm6exrZuhlI+SkJWL7vv2g4WIhoWHhoaCgomTmJyYm5CIkZGajqGcmYiHkZqblp6XmJmTk5SIhfm7qLGivNbw943x7djExsXOudbIxbKAopOi1JWHu5D46bGskOSHgo6EgZWzqrezxt6MtOTe57S0gZ+MhY696Mm31Xt7iKyknLW7uMiwh6birOqDnZ98352DuK2Wo8mawdqj6drSpbDr3+Dqkuico6qw9NPVysPoyKXEhtmIlJrNxLvG3pOZvMad+YjLoI6X0/q64rOkqKWA0Lylh+KAguF1kWzScIKQnaK4wbSMk6u/nbnmvsyirqWlfYx5cWuel716faWva4W7dlKeqXOUrq+qoqKgn5uXko6LiYeHhIR+c2nZmMyJi6eviOqOleHDh3CqsGy4r5ufbox1d5dmq7Kzv823kYlnq2Frf35vdIx5pIZyuIKiio6Ae9nOu6yDxrS2x8XMzL3Fs6aRjJtidGl0am6GhH9/rsK4iZqfg5mIjIuFiJCYkoqNl46N9NbI5+rnyNLk1dDBvsnP9IaH+cfr2ufou36JkK78ypCql+js74aZjIyDrXvSe2xpbNR6nYmxh6y2is+P6Jq3l3ClaXW8e5GFj4STiWqAcqGheW7PwaaxwZvlcXJ1q6CVr9p643HXfIyrv5yhr6SFqKvV6eKxx+azvMupgo2LncbX6PzUnvyojeLez5y+j4eCnrrettbakuHR3OiP/ZTvipXTouXFqph7namIumS9k761aYxUpYKPm6mzjYmTlH+HhVdhfHJpdYWHfHWOT1OAWVdQgm5+ZJKfmaa0mYOdsYOAgXp5pZGf0dfC1qrJjcm0ebCvf4SsrcHSc7GDh9qWuZfOznjAsMfe0rHIg3R0tbWCsX+Dd4lviqKsprucgXaAVFRRfKeY1NSNoIWGj8iI3qDpoI6Fy9qM73bA2NLh67C/zYp3gWypanaDjHt5kKCA2Pt5oNidhpdypIqduOGRqeCByOWq4rzVnZh5oYDYz3GRuayjbuV1gtzR9qvmpoOixbTjibKxoo7Dq6iti4HLhpuSsoa6moz9jsSmxYCVqIyKuov/vorWuKOzs7PGqp/4xI6avYXukPeh2c2e0fqJpt3sq8r553yylXt1xH+KzNaAyordnaaYqHlwiJJkb7ucv5SjjXnT69eytJKZn9RpgG+uvLPN8rq8sMCJr6/GzYSEnnjGrYKyftLu7tnU3ISMjG6fmG56XlKLg4hmUsKzV3ppb3J0oXZwg35qf3lSkW1YWY9wonFgsWCJjYRsprO7f5d3e76Agp16oH9LTVdtc3SAZYtoZnBjaG9dXG2Isalds2BidoFwanRzhJSXfI2Fg4yBh4aEeHh4hYmFgXJ0cnd4eIGEfomPi3yBeHV4dXxyx9HNa2xubW1vbW1pam92en15fXVwd3l+dH5/fnFvd31/fIJ8enx3dnhvbMqek5uVobK+yXC7uayenZ2jkaeel5WAiIKVv4dtmXW9nI2TgcuEd2dqZn+mqKSmudOCrdPf25eUc31zb2yDnJql76KVl6Gnvq51bndxacDfq9yGs7aApXVpjZJ5kcSNpqxsh56fmp64vLHBeeKSh4mVzrK+uLTQsZW5fsuKiJK9oZmotHaRysiO63rUm3yPtuix7LWXn6OAzMWmcOp2d/mFqoXjjI2JfYqno5aYo7mzlMLawee40sfEg5mIgIK8quSElfL4lKzur4HP/KjGxcW/t7S0s62ppJ+cmpialJeQgnfJg82LhqW1je+Lm+LOkYHJ16b/zLLRoLKZmNiFz9/f5/zotLGSv4CIqKuXocuZyqWW4JPQlZmAh+vdxLWIy7q80MzV2MjVwriknbBxgnWCd3yXj4yLvtLHkqSphp6MjouFh46Xj4qOmpGQ+t3S9fj1z9jo39nGxMzR8n6B86zcw9zYx4VzfKrnsoidjczh+3R7ipCIsoaqio6HgO2EppDFldHVpd+Z9aK+qIPUgYfajLSjnZKmvYiAlrm1i4T32MTG1KX8goKGxb6twOWK+4X9ip24za+3vLCMsK7i7uW9zuu8uaaVenN0nM3byMqvh9l8fs/ZwZrMnYJ7hJ+xq77Ehr62veCJ9pj6kJvmsv3gxKyNtMey/IPvs+fTgqxtz6KxwsfQoaWsqZamqG9/n5KIma+yoZq7aG2AdXRqppCffKKfl6+1tZWsw5agppeIx73F6uvIzq/QlfXymMnRo6rV2fj9htSZmfC45b336ZDhyPX55MnlmIuKys2WzpubjKeEobvDt9bEq5yoaG9ri7+n8+R9mWhsldODwJf6uaKIz+KR/Xq2ysnf7qmw0ZiGkn3Kf5CcpJCLo7CA0f1+rNCXip95s5Omu9eDkdV8yN6v9srioaOHsY/s7IKv1c/FhPmKmtzJzpTKfVuTpqmsWnd6cHDDiXpwXU+BU2yKkYWfeW/jerOUtX+KjIh0mm/uw4zTwKG5zL3Ztab4mHiXuHzSgcd4o72Bh6hth9G9rcbx643MrZCO1oKj5OiAT0BvZ3NsdEpDVmA5LkEwUkFdWDVLWVxJWTY7M0QmLiNkjj46RjIzMTIpMjI/YWVAVkyZimyQUmdGSElASyErPEczMkcyPyQuSU9QP3FZU2RfalZpf0s+MyImWVJCdlw6NDIiQUonWxs8LjdAPSstESwlMjAwKiQgNT0rLTZJQEyARGI1NkM7P0M8PkhehX5GiEpLX2ZWVF9fb31+aXdvbHVrdXV1amllcHd2bWNnZGlranBzbXh8d2puaWhqZ2xms7ayXFxeXl9fXFtYWl1jZmlnbGhlaGhtY2hubmJjaG1ta25lZGZhZGReXa2Nho2HjJCWn1aNjIN3dHRzandsb3SAbmRvoWtOeWOZd2BcP2MwOFQ7Vl9bU4VeXXlbWHh2imddQ1JIR0RTW1ZWgFZJTlhVXFo5Oj82MlVoWYdGWVlMa1VOY3VcX29XYFI2RFZhWmFkYW9tR4dcWGtcfnZ8hGqCdVhYOllDP1d9emtrgE5ISV1Sdz5bODQ2VmRTaEQ6QVeATzo2KVsxQYRHTUWHRlhhVl1ZYlBBRVBRSzNIVVZAPD9EPUI5OjVYTF87NmNzPUBfVkl9lmyl5evp3drc29TOycS/wL7Aur62pZjad8KOhaK+jvN7kvTTg2yYn1yqlYKRXVBWVXRZnbe6ubFZK1lVsVRpbGphX2Vnek8/XVxRepaAg+Pb1qGX6NDR5t/s7+Hx3dnJu8+FloeLhYKdmZiX0OfYoLGskqiVlZKJipKZkYyQmo2N9M+9zd/dyM/dysi+xM3W5XpyznuPf4qSSTBVQU+hY0lYXavA2Hx6cnlSZldVVFVbTJxba2eqk46YTW4wb4t7VTxsREx4Pzs9SD1HSUGAO2Z2XDFXWUpicFltN0lMcmtfaXo/hTiCYmt4cVlab1xVW0lrZHJeVHhBeXdqW0xKVl9dgYdDOZVLY6exkYWiWk5WaVR1bYBsao90cZ5fwGKxWl/hq+G+oYOBdGhdbTuSfGJ6gsmF9cLT7K/bwdHWz73W45So0sG3zu7v2M7/jpKAnZ+O5MPUmaBhTlk/NjA0PS0tLz49QTYyTT5RX1NWSmlhOjxBODc9PkRJKDoqJVI/QjpKRCM9Oj5DSExENzpSg31pi3F0g72bwt7ezfv+5dHciJKTtfbI3MZujEtVt/98jF68zbJ4zLFo14CvvsHj/Kim4LOjspbzoLjDxq6uxtOAg+WTfW9fna6Ryqi7wMl0dLVcY2E/Wk5SNzI6PS9TWSo6OzknIU0rLExakWGPXD9IRFVYLUJgW2iiZ2VUQzBYOUpRRDA/N0GUQ2dUQ0dLUE1UY1CLOyhMTlZRUFFHQkVQTkFZfViVVXtIZIZcWmxLWm9nb09mSStBNysuQjIqREYDfHx7iH2Cfo99CXx9fX18e3x8fIh9hXwGe3x7e3x8hX0Xfn19fn19fn19fn18fH1+fHx+fXx9fX2FfA59fX1+fX1+fn19fHt8e4V9CHx8fH18fX18hn2HfgF9jH4Cf36vf4N+qH+JfgF/j34FfX19fHyEewd8e3x8fX18h3sBfIR7i3wBe4d8hX0EfHx8e4R8hnsHenp7e3t8fIl7hHqLewV6e3t7eoR5hXoDeXp7hHyDe4h8CHt8fHp7e3t6h3sEfHx8e5F8BXt8fHt7hXyCe5Z8A3p6eYV6AXmGegN5eXqEeYZ6hXkFent6enmJeoV7CHp6enl6e3t6jnmfepB5g3qFewV8fX5+fYV8A3t7fIR7BHx7e3yEewF6hXsOenp7e3x7e3t8fHt8fHuKfAN7e3yHe4N8hXsDfHt8i3sBfId7CXp7e3t8fHt7e4R8CXt8e3p6e3p6e4V8hHsKfHx8e3x7fHt8fIt7AXyFewJ6e4V6iHmLeoV7A3p7eoV7lHyCe4l8BH18fX2GfAF9iXwBe5J6hnsLeXl7e319e3p7e3uEeg15eXp5fH19fXx8fX18hHsBeoh7Anx7hHyIewp8fHt8fHx9fHx8hX2CfIZ9Cnx9fXx8fX18fn+EfQt+fX18e3t8fH19fod9Bn5+fH19fYV8Bn19fXx9fYp8BH19fHuEfBR9fHt8fX19fHt9e3x9fX59fXx8fIR9AgIEAICexc/5t7Sho9igxvvq7dOijp7oqcHwhMm6qqmd44uknoPAn5GSgoTPvI3ihICNsLSCnaanrfyajIuH7eK6lNLQg82OlOrN+bypkITFg8Cylu+2vtOLrsmls4m+s5+jmp3igqWd5/nCz9WIvPr+6M+Nt6vVpMHF+7uy1Yqcprq5oYCTovW7wLKws+Pyrt6Slf6FiITrlqi1vbTTwsTO27/EtKiejYmDh46NhYn6+4GFj6CmmomF9YaTnpCLh4uFhdbO9oCFiIr/hIqSkouNjo6WlJSTj52fsKqno5qcpZicpKSdq6SPjJKOioPlqZ+5vsrd3vmRje75xc28wOfR5NOvqoChubTFrIPs6dO/jOOwl7OskaihvKOR3KKjt6ilrOPf6YXa4tqDgd20z+35dm++jYqbm6Xe47/AtcyTn8em7rTm1aKhromIhNmpn7fijfen5sTrwbTowtOI2oicxKeSotHJwoOXhIvP64GVlPnz7LOXtJO9kb+RhvrfhOzhv/uzfoCduY7F4eT/zZCa7ezCyvrI9Mvaiof3nqTW1b2WkLXKwauFidt+nYR+xLu1ZFhesWW5qYxZbIWprbGnpqeioZqVk5ONjYmFgoBlmOCb9q2IoZGby7++6L7anta0Y5qppK7GeJusg6yVoW6Edp+teYLDy2twc3hwkGJmhaJ8maiOvoCCfYng1nK9s73YyczGtZ2Vfohidnm1tq+xgY2dgH+Ci4SIfnCKkpeNkoeMlZeToJOShv6K+eLZ2tHI4OLQz8K2ws+HpfqntMjOxsWqn5Omh5vdi6aj6ZaN1NWQqrjdlp+/cstmZnuRsJ/ey46qdaTm5LTzcXl3kG+Gimzdm4FxsYCfqs6Hc33hyIGAj8HJjeayw4mStraNlJrXZ5F2vr25r7WHwcePnIfRhoPeocmI5aPnt4r/xp6e8qygi6bvp5fIsLyJr9nd1oqtqLeD8I+D8aeqpb/Ku7W9r6qpjIKuiGlvWn68l7+lYnS9p43DkldVVJZgUpBUdF1+cnaBTIB6d4Boj25LV42hjKfMxeCwtI+wvY7QmHiqfqXW4aSDz8HYc2e1aXSxuM/Ma8bVud51jpDCsZGVz6q9wnjOlZuhb725fJG5p4KTvIN7we54pGGmgqKVUIFPlITz5cnxopuBxdf/t5iZnoDgg62OrarjsJBlrLdpmrRjcHmTfneKkYV5mICrrYr7jM3cs5ebirys49ejmHOCjPeAseOTrMWUqsG9eZ+LgZeLp3TQuZzKu6DAlJGRif3nz/vchcnYjaf2mNe707i21qOm59KkqYaCt6TXsJCBm4q57JV8sLexlYuCv+e4ooPVpsulo6CyjafL2KmX74ueyMZ354u0ynCdq759jICPr761gol/f6J9mLKwuLiBcXy8sNH1kt2lioN7sGh0cWuOfHmEh4vVwpXQdoeRsLNwk5KDb6NlZHR/1cKrpL+pVZhmXZiFmGNlWVF3WoOEapF7eYJghJV+i1d3g1p0cXyOSG17k6B0kZhejZ6pu6lzk4SZg5CO04p0n1FcaHRza4Bmcqx/fXd4dKWtb55wcr5kamavc4OQlYqjnJ2nrZickImBcnNrbnJya27Q0GltdISJgXJuy215gHVzcHNucLewzWhsbnDQa3B2dXBxcnJ5d3Z3doGCjIiFf3t+h3l9hYN+iIJ2cHZ0cWzAlpCkpKy1s8VwbcTLoaWWmbWisKaQj4CEkY6ikGu8vLOYas6OiIOWiYeMnpOIy6CntqeqrtXh2XPQvKZwbrW8udH5jITcoaSxo2+GgXmw1OyEbJiW0Je3noB7f2xuZ8GniaK+ZaqQvqnQm52vmLNlump/qZmGoMK8tHN1bICq0Wd4d9rKy7KcuJOfiqmLgOPdcff5tM6bi4CquJzU8tf5xYuU7te/yOKk98PKhn3unZbDycKKmcPp3s6bpvGE0aeV3+n7jo+D9IT23MmDmLjM2Mi7vb23taympaWcnZqVk5Fxor2E8K6CpJOfzLrA1rTfpfjhgr7AwcDhlK2qqdjL1Yidl8jdrMH4/oKlp7Wm1IWCrc2ltMyl0YCOhpLr5XXCucLk1dnVxLCljppvhonLy8PFj56sjIqJkYyPhHaNlJiOk4qPlJWRn5SPhf6H9+fg5d7T6ubX1ca6ws+Cl+uWmrS7tsq9q42igHy2epuZ55SItLJ6jazzoaTOgP+FgIihwrL04569jKHm6bP+iJ+cqoChrY3+saCR5YDGsNSWgY7/4IyBkLzfo/7H35ibyMyipK34gaaH4N/Rvb+V0NeSmY/ZinW3grmFw4vIr4n/uI+f142hl6juqp/KlphwmbHGqW2QmaNu6o98/a+5y+bx3ebd09vUrKzusoGkhJXzuvXjgonit5fjrmZlZrt3ZbZqlnikkpelYqqhn4CIvZFgb7TIqqC24+rA2aHH26HyuJvCj8X05KOOyd/9kITriIjR6fn2hfP34fWCqbLdz7em+srh2IDtq7rFhNfUjqHWupyty5OOz/l+qG7DkbisaKxgpZDryK7siIdyq7jdqpWmsoroiLGVsrDjtZpstLxwq85xfpGrnYygpJWGpYCxrZT1h9Lkt5egkMKr1beOpIGQkPp/qOWbw++xwtXYjLqmnbmrzIz9xKLJpYeFZHR0ZreoqsqpXoOLWmWgYYx2l6uppH1+pqGToo2AspqzpYx+hZSu552NybfBppmHtLKdo4namKp8gHuDboGko3Ngl2SEudqI/p3M5oCsrs6NmYBOR3huU1xbX29OWGhbSEI/OEVYPkZRKEhJSEI6SS9GLUhhUjgsKSxJOzpZLSs0Skg0VFxgP2A9NCsoQUo+NktNNEY1NFNMS1FKK0ZsSVdQUH9eWmxQcIRTQSY7JU1gUkBpLi0gT1ZbaionJmRjLSQSHhsoIzw3Pyo6NC41Qk1OSIBNXWtSWFRXT3uBS3dbW5RQWVSMX2p6fHCFg4SNj4OGfnd0ZWhfXWFkYWO/u11fZXR6c2disV5qcWdmZGZkZaudslhbXF2zWl1iYl1fXmFnZWVmZG5weHdybWxxdWdpcXFudGxgYGVjZF6tj4eUlJmZkppTUZWYf39ydIRxd3Nna4BicXB5a02Cj4RzS3NfTGJfPktpYGRakGdYdmdXW5R+hktnZm07RnhwbHqETkh5VUdQTjpIRDtWXlg8OFpYlXZ8YlFdXExOTIJXWml/O1RPcm2RWFBvdX88gkNVZVVPSm5nXj9FNTptkURYTXmKdFpNZUxoSVs2LEJTL2pzQVREPoBDRjhjaVuTdjpGkIl8kZJqkHKAV0yTXk9YTzY0OEdIODwwMl0pNT5FclhoLjMxZj+EeGs3S3e3uu3j6Ofg3dPKys3Cwb+5ubeKt7135bSEqZ6o1Lq70L/mnMafWYaUjZOgX4yKY56RlVJZY2Z0boHA13Ffcmpe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0JuWnIx9nL6qmHyL8seexIvWmKyQsOLw6rre+JfZv4S9p6fn3M3k1JHIt8aZuaWli92+13fYvcDgjb2toaOmqpW5nIZ4fr+Pc5KOcGiKuZ2Lg3prT2RwYE1UiX+JXGRdWIxcTYB+hWFveZKdbpDJhMeuwJO2oo2xoMms2LzCuuXKeNPBmnxqdLmsxd6Bdn3Er/XZxnCHdZqzl7Fw0MJ51XR1cIl/1HqggHeYwMt1ho/k3WGkd4eKfnN6Z5eNc9CKuY+ozZXHpIGyppvxz+mEdpuxiqNoXmWMkIpgfHlvYGqUrrq1poCt55z4pdSnmIiouKSmh4mHoNO1i9WGkZqFlqJplruAeYCXeHm3ss6snqTjg4CKra+ZjcmMqICwzeWZofDbnc/z1YTAhJbFjZ3Z5pjh2ZyAgsrqjuiGuZPbs8BytPS0mpDp/6W85YGqxsjfhZuXk6zk+smlrcuA2cme1tCkur+T7YC4fIuQmMS4mZaGemmbqKWyk2VstLB64MmD9Oh4xsBeZ3WBaayzsrny2Mm2o6DHiZe3rXeXhXpzuKNtgXytum+7p6BmVGqIVYKOWk9jcGtrkFFeUmKJXoWvippYj3hrY2muglxbZm9PYFtqc4WsmXl9amSZeLJ5pm+htlhfXWNqaICHi4SXY2xxXl5kr2G9tmlmbGZ8k5WSoqChm4+TmqCfjnp1cnFzeICChoiKfW56dG7NubbJ029scGtyd27DuLzI08rIycXEaHF5fnd5dnN2dXl9kJWNg396eHqDhHSChYp7fHp5eHDJvsSdh6aglr1oZmZlxMOho6i4s6Can46QioB10pGsgoq+hq6trXjNg5CtoKGFbOCNjY+nmJOgvsB8iJ2o0n7/zNHU1cnP9ZKexM/J0491fXPC+tqAgV11qZRmqIKUz3DPwaSy8o+llZhkrrWqcXK/i8PNpLV+hn9wmL5wfr23iLfdp4OZzH2Ch9jzfeuu3r2Yr9OY2eDQfei0zIC2u7WGiNnfhca6h+TOhs7t9onQuJyGkJSjj6mS0LnEiNe7zKGDpqOMnc7g6fqD5Oe2z+Dbkpi+w8/HyL+4t7Wup6KhnZmUhZuLzazh4LKkmfTpe9LF2dua2Jqwq7y9z9G47P/4s6KqgeGokNa6qIGDlpm0sJWi4MGEjc+i5rWgsoDMoNepfnnNxNPJucCmkomE33OnrciGdqKSjpeMfHinuZnLnXyZj6KWhI6goJKQlJKNkJ6djezg5dvb7uiCgX7b4PWLlXfNtPSztLenlo2/0KV2f6HWjc51mq6/draAnomW4JCUq82X1eaHqsS43Maz7oGBo4+HiYKNrZrs7oXkvoC3gJfY//W648+jo6Kf04iV9I/qyfm/tazzyLuL7bGto42Bn8uvmIGS/8OWrYjimKuLlcvu6LPX3XOwyH+5ppDRrqa2qmuemaGDoZiPctDP8IXf0uz+leXQy9DU3M/pyaqatPmxlMzBmYKz5sSupJOEZH6LemJpsKSuc4J5dLp4Z4CwtIKQnbnEh4DGod7D1K7OsZnBwe3J/NXRyvHogebdtIyAmt3P7P+Yi5nix+jp44allrLgyNGG7tGI+IqIg6aK64jBmoeq2+mHnp3k5m7AgZO1rZmgcaeYdMWJrIyYt46xfG6usaj70/OLeqK2kKttZm6Xn5hsio2Id32mvMvEsYCt5J3tn9Cpno6mu6KlkpiMs+nGl9yOg4WIr6KAtN6Ri5aYiZfKz/O8r5rOWV9fcm5sZaF2iV50cpJyg6yYboOkqHqdWWSPZ23C5I7t5pd7h77wieeRvqP92/WDtOqnfnfT95moz4mFrLO8dISQm7bqvZ+WrtiQ3+K49Ou2y76R8IBoXF5za4hyYGNMPC9WVFRWVTUqTjs4RkMyV1o6aXU/SE1aRGk6NjhoQ0hnUz5MIyk/VD9yVkhFWEQqFA4xLCtPYmpSM15nRH46JDtfVmhcTTJYS2F8S2SDXDcqVkBARkBNRkofJEFANDkzLS00IiUlGhkzKzQdMSg/QTU4OTtDRIBiZm5dTVJXREdPiEuYlFhVWlZmeH16hoaFgXqAhYaHem1qZWBfZm1udHV4aVtoY1+3p6Syt15dYl9lamOup6ittq6ur7CuWV5laWNlZGJlZmhqfIB5cm1oaGtycmJtb3Rpa2dmaGK0sLiYgZaQhp5ST05MmZR7eYGMhnhvdGloZYBWm2+GYmePXYmGjleYRDNoeFdRU61AXGBxW3NhZ2U8YHpmbD6GeGxkZHt/hktKX2JXYVNIPjdYc2E0QTZPd3NEc1Nmm1GChGx4nlhhTEZDhYVvR0Z5ZYSRbnNLUjw1QHZGSWtxQ295c2RpfkpFOnh6TnFTaVozNUY6W2B2RHtTTIBBRE44NWiIYX1nQl2FYp2bXz11VFJO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s/SJ5dSn8diI98bulpC5jL3L0M+z2niEl8WO48mywp6Ta5edt7iJuaKgzMOxnIB3hHexr422z7jEp4nEwtGCxZCje7mwkWuFhH6qfnarromfkJyjjJWxx6KAp+aB1Ma41+6U9bOIqur+pau+xJX1l4KquPPQgo2B3sLN0YDGieK9uZTHsHGSdqmggV+GhcZxbF2+aceGXnDVpHSXi2pkVpSTkpSFiX5VaJdzaWmATIBqSlNlblxsh8x6g43UcYBy3H+FmdGrk6e5xdqn8cCqp46WzIJ7mpF1b5rRt9Hdyodzb4x3uJ6meHfdf7StgJiBgnOOlqTHZG7DtHObimV2c4ead3OGWWetqeOW0ZuSyMCL29CrmpeTvpi8e6mgsLLFaWmvqGFxjqNmW4ByhKibfoD6m5ii5cB8iH6Lh6iylIKNqf+73IqctZODnrCMxG6PbLvO0cZpgbWstOua9NGbkYaCidLjgYehi2+AuI2E9+P5tZatpYK84JC10aCA7KWRhoXm65yryJ1riW+J8s7dwcfFsZyZ8qy/l+Ori6zIk4eClo+U0NvX0It+yMDitNKC0ICVuo3Np4N2i5J+hHC304aLhbOBkai1uKeb4uzAl22EjuHxjYWXnba8sJeI/IXAk9iOw6uggZOSuK2UZJW6tndmqHVlVaxhf3+QhGKlbXm0aG9ef15hZHd9s6xpT32SilaCSmlsrJumn31vnIWWeLS+ZWqNkaeMm5COWFujdqKbsYBptVyqd3V+fXtzYG1ma3Z/h5qvpaCUkpKLiZSrqJKMjXx/f4mPl56Tkn2Cf3x2fnq9rsbSzs/L0W5r0M/AcMvLyLquwspqb3N3eYKGgoF/eHt/iYWJg4B7dnV6f4GEf4aBi4Rtg3V9cti7ibTHtWdrbGtnZbqwq6e3sK6fra2Zj4CZkZWTgsh1gbOT2YdyhYCFcX+zkdWjasaBe7WTk4uocY3BdLCkmpiKwL+jmr2SvtPHw7avYMCmfX+Kj25mcbuhjH11iHZqzoJ6baR+d92JmHq9htzXzYqHeaTKfZt1iJpyhLmpfqNvcpbOtaiT34Zoi82PhaZ2sam7q3JvnpmysYCOrZK3nJGHb57ItpDZpsD0xXZ3ibeYwIaamfP9sJvKt83e5uKu/8uxurXB4qT995SB1sCB8feVqM63zcnBuaigqKecmpXi2pmF7HaR0o98sp58foODjIzKltu5gtnLv9bY9YHvgcHKjJuEk8Kxke/alqm+luGauMLs8/ihms6Eo4CC4ovAp8fHyKuttIvqh4zCd6OV53yFopyDhISAhIanv8iH6cPJzuSTlZSboZKRkJiLj5eXk4WA4tfv+fyhprKQhIqlnnap3Zvdja2rlq2dxKigp/iCwrKLzsiG0Lvll5K+ks7a6N3I74WVqOCd8N3D1aeug8fM1Neu3cTJ+ezOt4CRkobLwJrY48/Ut5XL5PuP056yh9W+noGZlpPWnJDNu5GurZeSfY+vw5qEueaEy7OawumU26+JgcvjnpOuiojfaWqQfIu3YGhhwZS4tWu7k+eppoe6o4Knic3Bn4WalPyLiIP+h/6pg4vRuZXEq316bLq5vLmlp55qhcKWi46tZoCMYG2GjnSJpvOZm6DqgY2B8pObs+vBo7XD3e+v9sG7tZas8KKduqGGgLju1+3w6p2EiJuV9rmyh4bwlPnPiaaLkYGstcPvdX7ay3uhknKCfpO9mperam61pOCVz5J7nKSEyb+1oaChxqe+frOqtr/OcHTGwXJ7mrd7bJeFlbefg4D6jo+c48uDkYiVkLC6n4iYrf/C4pCjsYR/mbWU34Oxg+Dg4PeAis/O0ONxvLOGZmFZZ7TOaGlzemVtmmldrY2wm3VwaVeS3ne1zZ145ZSAjHbZ9aS63rSAnIKc8Mq1tMa9n5iZ/aKghtishp+2nJWBi4aR0ODz5aCLy8jqwMFox4BMhmaZeWREVFhAQS1XWDozRXE8Qj5CSDY5SlI8NTtcSlBWYmVbOzhCPjhSrDs2MEEvUHR4XnR0kIRCJTQ+MTEuTUZCP09OJxwuOENlWk9LSGVHVkdVRS1JeldTOlx6cj5bO1EwL0JaS0xQVzEvLlEuFhUaHyUyIjZKLzZpVnx0hoBSgkd8Xl5lZGJcS1hSVV9mbXyJhoZ9fHx3d4CQioB8emloanB7g4h/gG1wb21mbWysna25srKxtmFfurusY7GxrqWap69aX2FjZmx0cnJwaGlodnR5c3BsamttcXByb3VtcG5gbmZsZcSqgZ2nlFFTU1FNTImDgYCJiIN1f39xbIBvaHZ2aaVaYpyAwnZeOzQ7WENPRoM4MXxFS1xXa2NtQF9iQmRVVm1GT01JbX1JUmpiV1BrOmhKNzo/OTI3SHZvZldJTUlIillJTF44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qqR6gK6pqox3uKKivcDPdNfNvaeWj7bJbHBwh36drpKQwHqBkrvjsbnV1KGbm6ail5uUmZeVnqWelPra2YCckLrJuqDIsefIlpyEx5SAqreYoeHJqqDT+9vvwq/95sqF6KrmpP21qe7mua+bfZiBksrNjZOvyN/MpZ2zkXh7t6GUmayZgHXquq3Pv9R4kcGU59rUft+IgNe9jdrTyW9yg8B7dIbUtnvRg4+IudOP2Y2/p/u5rLy4iazrkoKnntLiwpPGiez1mNm85OTV/uHXwbDMnt2btrzqwJ+tpLTXgZTmvsy6yXOBbH5meW6Ypmt1qpx1hFqOhIGAiIaKgICRgm9oeExRgIiAgnFznJtufI+Vl9Zuy3yB0XJzp8GIh5WJvq+ekJSOpaCLmniawNWOrLewoKGhd8p0hH6asaS0vc+plZmCp8B5cbzCZ8azmKR6kMycgWteW1pTT12Rp8WMtoyIf9/Zrsyv48Cf5n/FunqLtmShaqBxuIJ1uWxxaYFnf4SegJnagIn7pcvWoI13dnVubIyn7LCJ/cOTivHLoYTTkrG80sOWfn6KyHnPj5qcfcL+44C8gqegj7r4pZNxYLf1hOiFi+G77OzGtbvploa3n7fcpLijhouJucK4hWiMpI//+b6Fo+S+q8+DwcyOjn2hsY3eiIb4u4mNs4HLfZOEieuSkP79gKzj08ewoXuRicbZ1tDujtKoi5CJ7pahxLnSlrWBuLGCjZSP6qfqiMLjw/q6+MOw3933rW2Lb19zmHCXX4/BfoKFcWWDZXOChp+NmqaHpIxgUYeUdJWTrcSVknaWU1dYgYZUcG1zc2SZamyZknp+inNjhHF/m5ueW61kX2GubGWvgGdia2twe4CBg3pparlwh42hmp6hm5yLlpemm4aYl5GRk4+PjZCFfoiCccfMuq6qp6a60NDSadLRatLSbXl7dc7KssNtaMpscmxqdHt3e3h2hIeEgnh1dnPBxtVtdHuGenqAfnFzdnh3cMmxqcO7vsZoZ7qgraSgoJ2VpqShq4yKgJCWka+rmn6/o6GReaxycHWim6KLi5tymqGIsbuVaWlpyI2717WniYHb1sv03n3b8b57co+LdtrJmYKEcWC1zXmdb4u34NbGw69kfXfEdnl1e+qj0IuEfn6gc115hqecb13UiN+N54nDiLfgtJJ9oc6AcYCmoXdnu7S5/3jsl+a4gLyfo7agjZ2IcLl524Gbdq21pJjqq7qYiJeb9f+btOCngp+k0LyKneL6i8jZnMT+tJa1uICCiJSvurrOwMG0qp6LqqaMu9Kuu9aKhJG9u613zNSajovy5sC018Xred7LhfLuyffwlIKGlo2/yYflqeWE1ePAlbSzrfPq1q7C0MmOgMe5tZWAwqmox8rehPbcyreoo83fdnp1j4amtpmVw32Flb7ls7/c2aGamaKglJaOkI+Mk5qYifDd3oCUhKiypJO3nMu1hYBqtJh/paqWn+m1mpvt3tvhq6HpxsZ84aXdo/vIr+37wL+ojauUpMzmpKPCzfj10czUrJGQysbEwse6gIv80sfr7f+KpdGv9e3oiumVj+zOk/Hu+YaFne2QjZ3s3Jn1g4eFudaNuovCf+uriauPdpDQjoKSiq23pHyndMPBc7KgocKgu72oo5zDjNWonbfKppzXvM3wjaXZ57619Zepg5mDjYHFz4WT27yKoGytpqSjq7Gxn5+xppSQomVngLOlppKUxsiJmKy3sfiA1IeO84OJv9iYmKedwKqglKOUqbalr4691vKgva6/qbq2ieqIkYOtybjI1/PHsKOizdGKjOrreunSsbh/lsehkH5za3FqZHSvnquCuI+Ke9TTqcqp5syr+oTOvoGYxW6tb6N4yo18yXd3cpJ1jZGmh5zhgIT3lbjSo5J9fH53d5Ou6auK+cCUg/PMnYfoj8Ph2eXNqJuc64vxpbiyh7HNvm+OZoCDjr/rmpZuXqm7a8pkVJWXsZ+UgK3fgYu1lamziKeUdImHptDTm4Cuvqbx9MyLquG8w92AubyQkoWmrIjDjoXiqX2Zx3zbiY6PkfKVj+3xgGRyiW55Z0xZVE5GPU9UMkRAPy44VjEvIk1RL0AuP1FIR0lVaUhiM0FUT3ZnckA1UlNfXkxVXU1caEZjPk9fRU5HP0FZOToiLFdWHDtmfG1NPWJDPGg+MW5zY0d9T09AWlJCXUVANzl0M0JxS0VJQygdIyAxNS4vKGRGPS98Vk+HgFBLU1VaZWpoaWJVVJVhcHWGeoeIgoR5gYOMhHiEg39/gn17fH93cXt3Z7O5qqGem5qmtLW2XLa4Xbm7X2tuZ7GunKVbWapdYlxaY21obWxmcHN0c2xpa2q1ucViaW1zaGluaV1gZ2doZLefmKqdmaBPTpCCh39+fHlye3h9g21sgG1va4uJf2mff4B0XY9TRU12YHlcXlVIb1BnVEpeP0VFR1Nhc0dWVD1PUmObgUJZWmZDQlQ/NlRRRDNEOzZ4dktzS1dlkKaGdmRAS0R6Pjo+Uq1xhVlRQkpzSzRAWWxYRCJPQ2xLbFmLWH6MgUs0R2JIKCI0SEU4YGBlbTdVNFBHgEpEOUM2MjtNQYldklNqQUeDbEhwS1g7LjQ+a3Y9SGdDMjM8PD8uRllnPEVKQk1hRTVKSEg6QktlcpfX4ejWy6eSz8qftKydq9Wdlaje3smH6u+alY305ryp2c3kaKOmedPUu9m+aE5ZWFxrcl2xaKpty9iWYW92dp9yfUlgWVNVgI+WrpWE48a509Dqes7Hur+6r970hoiBmpOxvqCY04yUpsrvtsTo46ebmKSilZiPkI2LlJmSg9/MyW+GdZmgkIOfjbOjfGNNhlE5PTc1P4iLNzKk0Z1PU0qES11Wu4GpT6Khg7WjlKaOdqN1bYZUWXm7uNmJZGd7i3Bre01XY4tNgD5+XnCFbZtocJ15vbOuZK1lX5yUUW6loFlYUpVSS1BgQzZqSUo5WoI1WDBOTnRoZEljT3GoSjdTR3NZYF+GVJSgV2NIdk5nfERaWVBlSXxdYFJoa199fmuDYoeLjYaewFZcU41VP0Z7cDxBpdOlvobd2tfY4vPx1tbn3tnW34aJgPfY5MnG//6gWD0sMWY4czxBZzEvPkBCQEA9TWtLSkBLQTpBOTlERUo4SEs7Rj07LlcuMT9VYmNnW2RWU1dKYmtTYOTxgPbmytSEmbaqqZyUhpaQiqHwl4t3yaeih9PUfIyFpp+VznbRx4S28IPEgK2I8qqN54mHg66SqqmoT2mKgEKBRWNrlaSVlZeTkW+qwGEyVE4/PF9LUUZ1PEpXWEEuLzYxUi9GKTIvM11aWkBqTWRwTD5ZQJ2chaiGVd5TQHOKinV4YVZZPDVBQ2VuUWxdQiorSkhANipFSUR9cUI2R21rbpVYYjkpJyQqNCxLMShbTTQyMixBKi0lKE8/Rod9Bnx7e3t8fIh9AX6FfQp8fX19fHx9fX59hXwMfX19fn18fHt7fH19hHwLfX19e3x8fX19fHyRfYJ+hH0RfHx7e3t8fX5+fn19fn18fXyEfYV8iH0Cfn2EfgN/f36MfwF+nX+LfgZ/fn5/fn6Ef4R+A39/fpJ/g36Of4d+gn+VfoV9hHyEewV8fHx7fIR7BHx8fHuKfIJ7hHyFfYN8hH0GfHx8e3t7hnoEe3t7eoR7A3p6e4V6Cnt8fHx7e3x8e3yEewp6e3p6ent8e3p6hnsGenp6e3x7jHwHe3x7fHt9fIR7hnyCe4x8AXuFfAF7lXwBe4R6h3uFeoV5Bnp6enl5eoV5iHoHeXp5enl5eYd6hXsFenp6e3uHeQh4eHh5enp5eYl6AXmYeoN5jHoCfH6HfRd8fH19fHp7fHx8e3x8fHt8e3x7e3t6eox7AXqOewF8hnsVfHt7e3p6ent6e3t6ent7enp7e3t6hHsPfHx7fHx8e3p8fHx7fHt7hXwPe3x8e3x7e3t8fHx7e3x7iXwEe3x7e4V8hHsXfHt7ent7ent7e3p7fHx7e3x8enl6enqOeQp6enl6ent7enl6hHwGe3x7fHx7nnwEe3x8fI57A3p6e4R6jHsEenx9fYR8g3uFehN5enl5e3x8fXx9fX18fHx7e3t8hXsIfXx8fXx9fHyHewl8e3t8fXx8fX2FfIR9hnyGfYN8hH2FfIR6CXx8enx+fXt9fot9gnyIfYp8BHt7fHyKfQZ8fH19fX6FfYV8AgIEAIDct7OawJetk4rT6sy/3eSWl5vkisrX9a3Sga/LeeC43q2v3oiXh8+upc56j+3dhaPJkOy1vuCJ6PG69c+rifeRm/KQzOWzj/v4mc/I/+m6j77fnPWfhonZlY6/vOyXiZG6tYbPtdKjk6rn48aplJrZ9oydgNWN+ZyE48ax7ZD56oDpjZWTkJ+B/JKQ8IuysL6wxcmtsMa8qLS2vb23ra+hlJubm56XkvT03uPCt8HKzeOBioyMhIiHjYaIlZiWmJSN8+b5iYmG/IaSiIGA6uSAkaaklYaC+9bV6IKA/o+Wq7esnY6aoZiVlYCE7tvb9djw9ubL193QyLq5vLWjp9G8roC9rL7EsoyOg4q60NSRzfaX+JWOxprQ+MTt6K7Ri8jX06uqjMzI2pOZ3obn7ce70e2emvuNqYTMeoSep4LLp8nV5Ir10Obz7+jRu73biNfknKW9ko62tb/Xg4CRmpyiwIuC4p7kspPIofab1uvhpu2Fk+jk05eI0th3gMWjrpGYkICTfJ+vnoZ7w9fN25CjmKCVktqHeoOehLFu64iznY3BpIJ9hJKC2LtjedCGj5Bwo5xyenGcndt7loeTooyLnZyMe4DGm5v/goWas662YGpimnXC0MWfhY7p1KLNvvuI3f6J8O3l9ImfnMxlYWNxlmRywWmNeF+Wwo23Z7FgnnWI1oCpwo96f46Uf4h+0HXS1MzUmY5+b86NdZOElpF0zaW5iI7GyrTh0aGkqJ6coZGMiZKSl5+fp5WD5+aFo6jFztiXjpu2sqqyk9SEhPLdg9fQmKDVnaeclZ2Uw8LfzMeA3ICIv/bKdHnj34OEgafFroCP5XeRsJ6gqoJveci0jKO5rIDLf8eheLS8nauy2JuugMfnsXC12+WSv9O7gLFwmZmhzXXD1r/kgLWb0qin0+2+hrSIoceOxKzAp5HmhYejhfOptuK07bXixNrN5caYxayBnsb4x46IsXB/fcd3kLDSgnncyaKTrp+yem+Wool7r7hocnSkhYyXoIWEjXqCaWp+fIBfWE1cX1KQg52KiWyVfbzjv5VwfG7ZhJGYlLW9nZPvmo+5oamS67yscoO9pci5h5fcosPD0r/XcazLvIe7b2+o4L6h1LmXc6elypjBgah8uWNeWWhzorfc6NfFn5SZnv3J38mOkKKE2t6sY4pya3mKcIukoqXLboeCuZaBqL7zkoDbo5ybp4B8sKT9isyYf5XFg5He24+X++Ld+aPDopV/t4xxd7R8s4uM4aaJvaCkkea7u36bp8+0hXiQs4PCnoyekuL0y5uN0o/ng5CJ6O/lnbyWtrr+rX50jXSornGQhYjgknPikqCJmH6e1/PP0czp9IubzpOYtsTlz6eHpc+3zYDYoZuCmICQc1222LzN8s+gpJnmitLS9KzQeLvYhvzN9KKV3pSmmevJwPeAh/7ujK/HhqeVqKVZsLh7pZOFXLVfZKJnn8KKXZ2aZ3qeo6yBWXyFT2BrUmGdcml9i51vZGN5Zkt/gKZgU3WTjXlvYVaSp1lmWqJiw2lko4l0rGu2qoCoaG5tbn1lr2xxuWqPjpeOnqGLkJ2Yho2Um5mSiI6Dd359gIN9e8zOusGooKatsMBrcXNzbHBrcWttd3d5fXl0ycLMcG5tzWx0bmhnv79pd4WEem9rz7e1xWxq0nR6iZKLgHR9g3x6emxtyru1yrLEzLunr7OnpJeTlZCEh6SUi4CViZialXh4cG2FmqNtm8Nsy2Zcm4Kj3Xqb1pSxdrXOu4eLa8KsvJGP1YDKwqqzzuebjNqHvZXYh3SMnGGUdZGbsmjlyMXe57uYp6Owa7zSh52meXyalpmmXWdhZGh0d25tvo6/oIyqmuiCt8jCkdFzaLS4w4x/5PCBj+Wgs7C6rICikrKyspWHrqykwn6qfoyVoON5joyoiLCF9XKjoZCymoyMjIt78uOBjf+qoMGT9NCLsZ6joPaQtJy3tpuarKqUfofLlZHyf4OeurzLa3hupnjM28+hgonQuZbjt/CO2fmR9/ni+JqxsvWIg4+ewIqQ3IHFmYjJ8L7oifKHupOw94C/v5aHkJKbhI6I5Yf48Nvuq5+MeN6XfJuKnJZ52q+/i5DHyLTl2KWiq5+am46IhIuKjJGRl4uA6OqEnJqwtsGKg4+topGpd8aCg+LRe8TQhZjQkaqfiIlbmLHGzsdw2IKIw/3ggYH39I2VlLXTxJif64Gdw7zDwp6LjuPixNnryYDujv3Lk/z0q7O97qrOjN77yoHP9/yf5P7pnNKStLrD74bf7c3egLmU24N9v7nIhJ9xfJ1uv3eWoYTRd4SOfrmCkKqItZy0lrB+j5x+tqB7l6XBqYWTr4KZmeiHgqiVeob85LyqvqTQnJfWyaqIvs55hYfDo7C4vZ2kr5umiYminYB1d2V4e2m2p8moooGxicvv4bKElYb3mKqon7etmJz5o5++rKeb79DBgIu2l6WxhIviwOng+uDqh8Pn46bUlYm8+ujX/t7LjL254Je7eamD1HRxboKPrrfH0cvGjoeMjunF18qYmsCW5Oa7cJh+d4aSepa2sK7ddo2HwJyGq8PtkYDSm5aMmIiBu6n8gNKggpe/Xo/M0WmH4M7A342rqK6b0KaLkNqbyKmY67yGqZaag8GcsYWenNG3hXSBlGWbdlpsb5+ulW11mm2/fol0udTVfrOPn7bcsI2LsY6vromiipPho4H5k5uHnoGezPjV39Pz0WmaypeZtsDa05ODrsactYBkTVIsOCY4PTY9Tzw1PkwxNCxIKVRXZytWLUU1JVtMe1ZJWDE1NU5HUFxBUmZYLlFeQm86Nm1Nim9Lc3M3LolDOmBBdGU1O3F4QDQpbVpHN05ROB5JSUJ9RkFTanRGOChOTz9gWzFKQEdWUE4mJShFWDNBME0vXkU+fWhUhliRhYCBUVNWWWlVjFlhnFh5e4B8iIt4foeDcXiChoWAeH91aG5uc3Zzc7++q7OclpuhoateZGVjXF9ZXVtcZmRnbWxns6msXVpZq1phW1dXqKxbZnNzbWVhvKmlsGBhvWhtdXl1bWNpbmtoa2NiuaumrZmmrJ+JjpKEhntzdHFsb3xwaIBtaXF3fmVpXlVodIJTd6JUgEM1Z11ebjxnj1h6OUhDUjgxJV1MZDdKXjhccmpiaHtnZW41Qz5mPDs7Uz1dTVddeUqjfZKPl3ZlZGl7RWVWUlhkSVZoaWZvNjU0PkBCOy43PzBmWkl7X3RSb3NrSGYzNkJFWWBcdWc4P2M/SkpNRIA8PEA+MS0qWX52g0hZSz9HTWI5NT1NOUg0dz5COTVIPDw8NC82ZFsyOWY9QUQ9YVI8RERpZ4tUeHaFyKmry8GbgJHEbWHDb4av1Nz3g5WGvoHm9uushYHFrIy+weuCyep/38vTxoGVl7RaZl5pl11mzG6Uf1yOi3eXQHw4TUZFd4B0pnBNZJ6qkp6V7HLK1M35vamWiP+niaWWpqCH98bZmJ7Uz73x5LKqr6WfoJCHhY2IjJCPk4V2ycdvioqfo6h6eH6VkoaQXnA0MllZQ2iLTThVX4RtX1ssWUxmRFBXi2hqg72rV3Plyn6EaoN5WlN41oOmt3uIj3lfa8KSXWFrW4BjPWVVNmR8i52SvXWNb62zjFCLqa5pm6+dUF9JV09PVj1yWmJlK1tXQExQWU5TMUFIXXJJjjRnbT5xRFVYUIpeWGVFXEtqYE9AUTdMfEBFP1VvUU5OWzlOVod6ToNdQmHOo46PdkxnVkpng6CW1+2Poqby1uLp7MjZ5tHiw8Hc0YCbq4qhoYfly9JAPi4tNWR3YWo2Ny5kPjs6QFR6WEqNTj1KUWFJYUc9MThjSlBANT5dS2poblxtOWFiVzpYQ0BjoW+C8uKBds7P/YyxbqqR/ZKSlLHE1K+wxM7dioiIh9fM29evsu+o9+rKiruckp6lj7Le08b7hpOUz6NuZm2PX4BzYUY/TVterp2yZq1ggoWSRDpYWzw1bWF3a1JdVD0kQDsvN04wQSsxUkRESE5NSpiEeUJETHW0rI9ndVqUZUVZX4mPblZKYUNSMUI6jo2UR1YsOE5aQjUoPkRWXjY2SEtmPTh2OkQ8KSIqNl9WV0RPYjY/Tz09RUxXSTU1RWlsaQl7fHx9fXx8fX6JfRh8fXx8fH18fX19fn18e3x9fX5+fn19fHuEfBl9fHx8fX18fH18fH18fHx9fH19fH18fH1+hn0KfH1+fX1+fX1+fYV8D3t8fX19fn59fHx+fn19fIZ9Bn5+fn1+fYZ+BH9+fn6GfwR+f39+m3+KfpB/B35+fn9/f36Ff4J+h3+EfgN/f36Of59+hH0GfHt8e3x8hHsMfHx7fHx8e3t7fHx9hHwDfXx9iXwEfX19fIV9Bnx9fX18fIp6A3t6eoV7hHoFe3x9fX2EfAZ7fHt7e3qGewR8e3x7hXoFe3t8fHuPfAh7fHt9fHx7e4d8AXuLfAV7e3x8e4R8gnuFfAF7jHwEe3t7eoZ7BXx8fHt7hnqEeQZ6enp5eXqEeQR6enp5hHoHeXp6eXp5eYV6Ant6iHsCfHuFegZ5eXh4eHmEegF5h3qDeZh6gnmMegF7hH0RfHx9fHx9fXx7e3t8fH18fHuFfAh7enp6e3t6eod7Anx6kHsIfHt7fHt7e3yFewt6ent7enp6e3p6eod7AXyEewV8e3t7fIR7hHwIe3x7fHt7fHuSfAF7inyEewV8e3x8e4R6Ant8hXsHenp5eXp6eo55CXp6e3t7enp7e4V8hHsEfHx8e4h8AXuLfAF7hXyHexl8e3t7fHt7fHt6e3t6ent7enp6e3t8e3t6hnuFfIR9hnwFe3p5eXuLfAZ7e3x8e3uHfBR9fX18fHt7e3x7fHt7e319fHx9fYR8hX2FfIR9h3wUe3t7fHx8e3p6enx8fHt8fn18fHyKfQR8fH18h32LfAF7h32GfIZ9CXx8fH19fHx8ewICBACA+42rjoiF6uyAjPyvu3zTxnR7zPXX65D29ZOf5tiQxM3guoPQjIDFqXq50LGc0KSak4XA+86WncKNj7rjvaWzrqmHrMan5+q21rrn0+TIxdbh6bPFjZCa+vS/rsOdobu9jqCYpqvOpYu9xsyskazTiZCHgo/9jO+ToujHtdzcu8mA4c7K4fCB5NPk+YSUi668xs3BxLuto628s7altKGPj5+E793k7eKA/dW8xOPvgIiMk5eeq6SjoKGLg4WSlpKJ//zf2OaDiIaJg4D06vz+goqHiYKJh+rUgYqB9IeVnbLLsqespp+Wj4uGg/TG3OC3wcS+x9Hh2OTVxreYh/qTqqCAtsDC0rGajpGWg826o+a2t/TOmYe2+vSXt5eH89+J2pGT9qCcotSEtMLkruWOmsOhhoF82NXW6IGwlKON6uHzidi/2ZTk2YSB4ebg0Jqq4rDM89bdmoCm7N+wzJ7Ikvf+6s3ZnvOHnbqVzvqKqJe8+L/5zfCf27WI6499z75uqJiAlYx4n7DV0dSGh5aroq2h/oigjs5uztfZap6l2e2Xh+C+gm9+8L/lgplzzMKQvKCnV2dtnKudeM/MeYGOipiC0auHwrDIharC4daos2Vsa56Pin1reI6Vg87RxPOy95Xf8PqvtOWOmamOf2lpaJqxt8hlWKqoemhvpXufj5TPjZ2AvafBsLe0u4p9aK9xmaqyzZZ1rb19dXPWvdiHiqHAy5Onp7ekrMSxtKScnZV/jJCSnJGVhqGKgffymaW1zMCkwLLjs6OshfGIv5G+pf/8mPrYwuid2J+4ma2Cz/Grsb6BspaagYerm4C4g3WCkPB5oX1/9tO3iLyEaXK6yJOfXraArZ2Vrcqef3Gbj6elkrB2zZfYmY3P2M6iu2Rwi4BzaoCDmYew5JLzhfGwl4K9gJ+fpOCtzOWSmrGMgreIq46ajMSRlLyx0fiWydKssc+4jPbx5pyL66WusHfBjaG4tqOjmo6Pqq6cmYt/blxgnHFqZmtclICKooeQW3JtmoOUXJaAenqTgVqcXW2Jf3K3s6GrgYBy1bG8qLW2pZh9iqKGjqyZjaCM09zeqI60knq2oo+sudnNnbuzhpyjd3F8f9OXrcSRypJ6s7+NscXll6WXf79re1qLdHuvqsSO7o+3vJbyu/rKpYO+Y4B5o5t1ZWCPY2TDhWW8rX2RfZWR3Ib076SAsZvSwaKhyISE652989q8yomFjv2M8oiWjqeypo+gkneqgZ6ObHzSz+npfp7d2tfyiNevgI2fpPXEgpyHqYPl26yps/GApLmArqmHkoWn3Led0MzMgLzJ1KiScoOQ4IGWwKK3yqPEe4Ct1/HPuIWYtfXOkfPn2K2Wyquc8amWyZaA336NfXF0vtJse/ipy4fq04CI2v7Gym/WyoSw386k2cnMtZLxko3ow4nU87yx57Sag3iuuZdaaHZXZoqef3V6ZmpPX3p+wqN0jYGTnKCJhJqel2yBUmFiqqKHbnNmXYSJXllWWG6WdlaDhXdbWW+KX2ZeXGKwYK1odqiOfJ6fgoyAnY6Onqxer5ivwGZ4cY2WoaWbnJiPho2Zk5SGkoJ2dYFry7S0xMJs07elqL7GaW9ydnyAiYF/gIJwaWp2e3hw09G6tMBscG9va2rJwc7PaHBvcWxycMW1bHJqy257fY6gjYOJhIB6dW9vbc6uuriboKKgpKi1sb6rnpV+cdx6iYOAkJaapot/bm13ZpqUkbeVicicgnKbv7RXnYp0yK9+0WdtwoCSnsRijbzKj79vepmAeIiH3d3a6IKLYXJgspqnWpKKqni3sWRsw7GopXed4pqlu7a2jmaSr7KAk2p/ZNDdrpy3kN2BjZ55tN18jYSY0ZW6r9F/48SF45qF4NKGxZqAmZ+OqbfRzaRccJLHo46b54mtjtuD2uv6ib2a2OSMb76+m42K9tb3prmF9vW58uT2g52XrpKbg+/dgo2ak6CO3auFyZqtfaTE3dC1unJ7ea+bl4lzg5CZe+7bxvq49pnl8+uyutKSo7+tkoOFiMzy0eyAgejdm5CXs43Qvbb+qruA27fcvcW5wJOFdMN/sbzJ4ad/usqEe3new+CLj6nL1peop7akrce1uamfnJF+iYiJkISLgpqCgPPpjpOes6aVwc/qmpCkiOd3nnqvk9jOj9a4rdGo5aa9hI57v/G6uMGQvp+kiJK7qYrLj4OVnf+IsYKG+erPoNaggYna5bfTgfKAzrS42PvUp5O6lrnGp7uC2aXwrKHw/O/D8YeXtKySgJOZnpOn24TRiO+jhmCue4htfqaUuc+AiYiBdql9mIOUcI5aWoCJq9tgf4eAiJV/iLDGp5CF8ZyyvYHIlpKZioabnJeZydGsr66do4OQvIN6eYFrsZqkxKeubImBt5qtbbuAoaK7o3LDd4u7mYff2rbLkZeE78vXuMPEtqmDd6iUk7momrCi8OP8uZrKpYfJp4uZrerfrsW+pb3JmaSmk/LR5+Gi/cyn6vObwdHfi5GZgsZxhmmdfoCkoq572H+dpordt+HHqYjTdpCBurOHcm6lbnHbl3HVwYOSgp+Y6Ybz3qeAqo/OqYaew4aHwHOP6eC6jF1aa75vu2p6bIKUoYKvrYbCjamRhoTn1af/gZnMxsDCdtK0hJOCfcWdb3pmim6epHyCh7Rbc39fkXdjZ3Kf16GKoWyjf7fDzbCqgZaj+oabtaK/x6nIgHq10tvOwpKhs9HFkbu/spt/s6Wc+6mXuoKAPihLNjIva2gzKUgsOyVBPiomQExTaT+BfTYwR0QtOE5rSTVHLy1RTDFFZUg0RT46WUg+TFJOWjAWKFlmVFFFNzQ7UWNkTGhTVFZ2VDlAXz01VFtIOk5Ld3RgWlxKS0ssNUhGU1BXPzxEO0FTQ0pWQklEREl/Rn1HRoNrWnl5YWeAdGhveYdKjHeRoVNoZXqBiY2FhoWAeXuGgoR3gHRqaXFhvqWgs7dmw66enaqtWFxgYmhtcmhla29eWFhibGtkurinoKdeX19fXV20qrGuWWFiZWFnZbamX2RftF9oaneEd29zcW9qZmNmZcGhpaaJjY6Mjo6UkJqHfXhrYsVpb2aAbXJ2dmNgWFpeUXt6e6WBbVlGOUlXa1gbWFFQbzMnOjk9WEI7LkU9W1R/Z4pQUWhbWkQxUVllZTZOPUM/fWVbOWNbcleHfkhajHt4fFtVakdQfFpjQUZUaWY0UUNBJkhWWUBGSYBBR2NAV24/WExSYVFERH1dj2c/cj87cm4/ZEWAQTswQEVUT0s1PkRBRVtJjkI+OEYuaGtrMFpaZHZJNUxcMTE0YGFuN0Y4WltMfV5YNzpMfWhrZb2xdZymiqWW3olbjFl0XZXM3ujU2Y2ZltCutqOEl5ykf8W5ptzX9IXK2c2qtLuIl5l9eWJlaKGjw8ppWqZxTlNaXluDa3ebQmuAd4aFsaLO3K+ijvCWxcnh9LqJytySh4Pz2POSnLvu7J6qqLyvutm/wbWmoJWCiomJjYSLf5V8cM7JeYKMm5CDhVKPgoKPa8BYbEpSUKynhJuSdoE9d3J/W1E8PVCAiXtpgmp+b3F7hmyYdlxld2FOdniL9/m3ZJpjUmXF439oMVqAZ2ZmgYl0X2OaiJ+di5BKj2Ska1+gwq6Gijs+OTM1LTxHYExkdTZRSXpaWUtfMz49NGdRlopQXFRPWXlGbD5IRlg2PkMqPFArLkNFRWJTVGlXcVVkl01VaGm+dT9mTVeNi4mFf1ZycVZPUExbw5ePj52C4sXO9ODmiKqf5sTVhfyA3t752JTymqaMOzhkU1pVYjs7bDg6PkBOQ0hRVFBAUEpISkRFRVtLQy43Ny47Qj9WS2hmWmhiT11cSUo9N2htdGpIbHdleLemz97XeniZj+GEo4jClZGcmJ1pw3GEinbXwNbSvpv9lrCE2+CpjInQgIH+q4z27JeYj5NZmFqEdGCAZlx4UDtYoV1llmRunJ+JflFKQXFEcDdKTl1kNzpKOyxEOVM/JSZFV19jPVh6fIKIVIFhOUZfZaKFYmlZb1d7c1tqbZRGVl86Qk5MS2JzXUBFUyxSPl1MV01NQTY7VEdcQjtOWzI9KC88Q19JRDUwM2puOnFhYUg9WFBGUTcuRCQBfIR9CXx7e319fH19foR9hHwDfXt7hX0OfHx8fX59fn59fX18e3yEfQx8fHx9fX59fX59fHyFfQV+fn18fIx9CH59fn19fHx8hH0NfHx9fn5+fXx9fn19fYR+hX8Cfn+PfgF/hH6Xf4V+AX+GfpJ/hX6Gf4R+h38Gfn5/f39+j3+SfgF9jX6DfYp8A318e4R8Cnt9fXx9fHx8fX2EfId9hHyFfQx8fX1+fX18e3p7fHuHeoh7B3p7fHx9fHyFewt8e3x8e3x7e3x8fIV7Cnp6ent8e3x8e3uLfBF9fHx7e317e3x8fXx8e3t7fIR7Anx9hXwGe3t7fHx8hnuEfAV9fHx7e4Z8BHt7e3qJe4N8hnuDeoR5CXp6enl5eXp6eYh6hHkEenp5eoV7hHqGe4Z6Anl6hHmHegh5eXl6enp5eZh6gnmHegF7hHoFfHt9fX6HfQZ8e3x7e3uHfJB7BXx8e3t6i3sBfIp7C3x8e3t7fHt7ent7hXqIfIR7CHx7e3t8e3t7h3wBe4V8AXuGfAZ9fXx8fHuNfAd7fHx7e3p7hHyNe4Z6hnkIenp6eXl5enmEegd7ent7e3x8hXsDfHx7iHwBfZV8inuCfIR7AXyEe4V6BXx8e3t6hHuFfAJ9fIR9hnwXe3t6ent7e3x8e3x8e3x7e3p7fHx7fHuHfBN9fXx7fHx8fXx7e3t8fX19fH18in0MfHx8fX19fHx8e3x8hHsDfHt7hHyCe4R8hH0UfHx8fX19fn19fX58e3x9fX1+fX2PfIR9hnwEfX18fIZ9hXwDfXx9AgIEAICn9/zCwbiPqfDMq9zUx8+8jpqRtbDsnd/FjPKMpbCO8IyTv7iotHuEopO+u4Dt4LPtsPaa5NDBg4fKo7rj9uOhxpDLiIGNhInNyq679761i4aN+oGLj7zx3eyR8OnG94Gr0ZWXwpmO7oGto7nZif7nycTtg+fB16Ws0Mm/rsTJ34D27oWBiouNiKOxrqi0uK/AtqWhnq2nrbOst63As4zg1tLq8vaAgeTj8ej09P7j7oeSmJ+hmJiLk5KZlZONhPOC3trd94SJmo+A8v725u//gPvy+t/X4O39lJ+qtMK9xb2qn4eclpaMhfLuw8DLq5ucnKfG1dfr4tzOwJL86sTzsYDTxbTZ1sSWi4KKzpeJ1cWuu57o+JHapIPy2Krq9Me0xJGRycGV6YycjqnRrbW29seWq6iEuaSKlbXhubSwsbWCgfiwp8amxbPj+/b14dzfl9WygISQgIqxw/C9w7elosry5Jqu75DOt6mTiJSfjcD2s5CSm6qhldjSxLO5lZnekoCB3Ial94+d/cuVwc6p56Hccoekr3+Vh62mtsnp8IPr/Ye6ybicor6VmaBzvpGGmKmfuWxllPGAkJqRcXrcro/07qzG24N/obq+aGttaWmjqaaHiHR0tbiCd4D12NOYhsbX1OCL0qCTj6u9dmZ1trmwYZqlbX15bb+KgZ6ilajIhYCu2uN+r66FaWhiZ2O7u2LJrH+1cHF6cHt/gIV1r3KFgYyCna27r7WkjZWTh4mIhoqD+oCJjYqIin936rPOscDSZ3KGmazvo9yanZOVotysreao8470d5OXoKOKgJ/cm6GWpdqct6aupp1zjLx9g9h12Y/mpsmRhZaCeomKlo6mqoCbhptyjnBvfpTYtb3jxonxrrGnnsClgZSSbWd2dbak3s15np2ZlOyUx5/a28LRnZa+t5TLnZ2asrTcmeHGgenTzObvvPvhxqm2oq2M6KnX3bqV+feygIfPlvuAq7ySnYOawIepf3G05WZYaW96gI+av6eFlGFdVm6EaGBta2xwSYBRTFZZVGRzXW+nnpB/bHyXgI13wrzGupDlfpj/xdy8n4eBkY+J4654rLenh+Oiqr7wpdaRgHqHs3hob5Gvdp+HhNiJq56PZpiVzYOaoIPBq9B+uWzMrvuS8JGzyYuYqLjc5puYm3F+eI65dl+JVIGZtneFiIDJdaq/9IyniqSkm4CI1aK5vs/205KeqYj7g7DCnKvHnsKSgcuQpqiqpJGohN/xhKG10o+qsbPGmdmIxoyYws/8lqyTkr6xpuXtvpjOpLiB1YuGiaijxJ+QrZ2Np4TOnejfq5HdsZTVg7i4p86bhqh8nLHSxoXrs9nRo7bTyOecmdXcvv/KoMDv6Kb2kICS5PGyoJluh97Jvfbv29/Xoa2gwbK2bpWDgvSRscOY7Xmm3te+tIeZuqPYxY3o+bzIpdpso5uPTER7bIKNjohsi1iZblNeXlx6inWPq396Wlthqk5bU2yKg4NchYR7rFFeg1ZbgmxloVtlXG2SX66WiYeuXqeJlG97nYyGfIeOnYCxsmplb29yaYGLi4iUlpGflIWEgIuIjZKLk4mckXO2tLLDx8lqa7+8yMHIydO+xW53e36BenxyeXd8eHl0bclsvLm7z21wfnVpyNTMwcbOZ8vI0L21vcbTeoGMkpqYmZSGgWx9eXhybMjIqaarkYWGho6jq6u9tbWlo3ve0bbSj4Cmm46rpZh0Z2BjpoOBwamQinS/uXWmdWTgxIm2upmWmmZlj5aQxn2BhJKnmp6b1KKFpaeMopOLmKaueXZ9dHtXTaF/epqar5a6xsy9tbvBi7eScGZkT3KVr7yQlYKDepy5tXye0Xu2oYF0cnuBfZnNk32GlJWjnt3j08fWqar6poCR9pey14+R+rSp5efP4K/ziZChxIyfjcKutLPOyXW6046+0761oMepxcmF5say2Nbb55qBjNB9laSjfoXcvpj27aTP0YCBqMPCcXh6c3a1ta+Rln1+usF+hX/0ztaQhcLo3NKKyKSZmLjMgYKX3+LXiLjgkqWni92pjrvSvsXtjoC14vaJqKiIb3JrcW3S0G/fvYjAd3eAdoGFhIp6uXaIgoyDnrHAtLqmkJWQhYiGgoR/8HuFh4N/fpSV+KO0n636iIx9iZjboMWCgHp4gLuyo9Sa4pD1go+Gp7eJdKHco7CdreqkzbC0vbGBltWEkOaF4JPtsd+jk7Cpjpuqtr/j34CzpbqFr4qGm6z5vMT2yoruvrm1r93CmK+tiYmQnOPF//iMloV/bOiPq4i5s2udemiMjHOwg4V0gpjEjda2c8GsmKa5pZuMZ1ZyiYN1rJO5tJ+D3tt+fH7Jjcx3jYF8jIWqz327oIzK/YiFnba0p8HI4cWisXVxaH6cfHB7fIWSXoBoZG9wa3+SdZDZurGbhZGek6KF1rbPxZT9jan9yvHOpoqMnpmS5raEu8m9lvWxtcj+pMmTgIKcyZGXo8jRi+WwpP2kzr+1k6ib24OQk4HFr9SCzXfbt/OJyXihs5aktKDGz5qcpXyNiZnNiG6eZJSoyYCRlYrReK/H9YikiJ2ilYCIzJSgqci/1pF1al3IWp6SZX20o9B/a6ZrlZackJi5evT3hLLN7ZWQc5nHjq1qsnmCtsrtiYZydJyMhr3InGd7dYxYkGheXnp/hnFyqJmOhmGJZbHGtJfcvab1n9ivvPaydJaBpsDryHzYs97jrrrBvtyFg+rZo9Kfh6Lk2ZjsiIAwSXdkV0U7Olc3LkZCQTo8KjM3Qj9iQlpPRFAjMzExTzU8SDo7RCwwOzFGPCZKPDxTNTc8UFloGR0tSF9iQFE2LzQ9IDc/PjtOQ1ZIfG9VNjo9YBs5S2JxXXRJemRSYCsvXkhDVCYtQzJUUVhvRn9rZmWHSoZrbVJefWpmX2drd4CHk1lVYGFhWHB5eXiCgn+LgnZ4cXp4fYJ8gniIf2WkpqWusbZgYK6nsKyusLalqV5kZmlqZGphZ2VnZGdmYbRfraeotl9fbGZdrry5rq2vVq+yvK2mq7C6aW52eIB8gHxxbF1qamlkXre+pqCfhnt6e3+Qj5GcmJqFjGvDxbK8c4B9dG1/cGxbUkxMjnF2vJh9aFCJk1RjNjVNSziBZ1k6QDArKS0jODxTRV97dIuJtH9ZTUEwWVs+RV1vUE9XSFQyKl1PVnF9imd7kYuOhXNZQ19UPzstKzNLRVtIR01KPkZESUFOY0ZYVU4wKjU9QFVqRDw7TWlsWnR6Xl1iTFF9ToBDaj5OZUM+gFpEXU9AZENnMDlCOzQxMFRccm+RhUxLRDhKW0NCSVE9QEgvVllXYV1xZURdeKFhcnp+g4SvlX3ZklR7g09knMu8gpKWjJHX0Lust5WV0tZ+b2LDtLqWh6+zuLh1uZ6Qjq6/c1xtpbCzXpKOUWNgVYFeVF9sfXGBV4CK09lpn7CchoiDh4L79oH+1ZPVhICLgImRjpOFyIaNiI2IqMLQwsizmJ2UiYiGhIR+73t7gHlzb0csl4+XgYZSGidscn6+jZlobGdkcp2RhKtkj0iEU09FeXdbOFl1aXx2eqV5kn+TmI1abVdBUb412Z/0uNmEgI1daJeFhGVrcoBwWX5peFVckpjesKvMllGae3twdqF3TFNaMjczO3JqcHo/WVtPMW9WZ1ObkUh1PTpKOzeFVlJSWn+eam5jK3xrSGFpTjJHLzFKUEtAXkduXT1StIA5R1CIUHVXW0Q7cYCZtGR8U2Jwa1FQXmd1kY+s//LV4pKQhZ/IoImRm67FgICMh5WRip+4kpRygGpOT1BrPD8+RT5DRU2LQVyETFFMWENGS0pFUkk9PT00K0hFOEt0WoZZVFdRXU5QSFpMOWNHOmo5PkFCVrCm6YJ8hH3h0+KT8Y/+0/GBol6PmlVLWY61sqCtuIylo6bwqYvMg7fG6ZOnrZnmicXCoUZgUVNbVIBWdUVPVG5VllVsWzqTS2p3NWNbOkU+NGBKTkxBT0c+NVRTNzY2RSpFUmFjVXxHa0xaY2WEU2lhYHt3cKuogU1RWm0/a1RBQlFEYFRYgHFTWzVYQH2OW16ZUjdTP0k9VHc+PEUyPT9QYDxdRU9AUUBGQ2JWREVbcoZ2XGtbUzZCIAN9fHuFfAJ7fIl9BHx8fH2EfIR9AXyKfYJ8hH0MfHx8fX18fH5+fX18hX0Bfo19B35+fn1+fn6IfQZ8fX19fn6EfYV+AX+FfgF/jn6cf4Z+gn+Jfo9/An5/hH6Ff4Z+AX+IfpB/k36EfYt+g32GfAd7fHx9fXt7hnyCfYR8gn2HfJB9BX5+fX18hHuHeoN7hXyDe4V8B3t7e3x8fH2IfAh7e3x8fHt6eol7A3x8e4V8A3t8e4R8gnuHfIZ7jnyHe4V8DXt7e3x8e3t7enp7enqFe4V8A3t6eoR7hXoLeXl5ent6eXl5enmIehd5eXl6eXl6enp7e3t8e3p6e3t7enp6e4h6Bnl5enl6e596AXmGegJ7fIV6A3t9fIR6CHt8fX1+fn59hHwNe3x7e3x8e3t8fXx7e4R6iXsHfHx7fHp7epF7AXqEewZ6e3x7e3yFewV6ent7e4R8hHuFfAl7fHx8enp7enuKfAZ7e3x8fHuTfAZ7e3x8fHuGfAV7enp6fIp7g3qEeYt6kXuIfAF7l3wDe3t6iXsGfHx7fHx7hHwEe3p6eoR7EXp6ent7fHt7e3x8fXx8fX19h3yDeoh7BXx8e3x7hHwEfXx9fYR8Dn19fHx8e3x9fX18fXx8h30BfIh9FHx8fX19fH19fXx7fHt8e3x8e3t7h3wme3x9fn99fH59fX5+fn19fn18fHx9fn1+fXx8fHt8fXx8fH18e3yFfQN8fH2JfIJ9iXwDfX1+AgIEAIB/vPjziJrjwbKXu+zA6eJ9hsJ0gI3mzrqquvGtwnGzvH2Lfb+xzqzgqIuNhI246IDUgd+838WP04CMpOaBueX/rKjDrrrAk8TesOOluqO12+y3zfWKj6Hrlq+Pw5abn43tlcrug8Wkgv+2meKNhvyTh5OXp5/527KilpLI1YSGioCXlZKalKissb25w83DyLq/qLOksqu1tbO2rKmj+ru64IOKhYn6gfjy0c7f4eT7/4SGiZWPlJKNgPSKh4SHhPTG2tPskZOTnZKE+O78goeMkZiJ/oGGh5ijtKyut7mvtLKen5aampCIgtyk+5iVp5aJo72+x8m/upyplKb3kqOPv4DT6bSqkLa1oqKJzc6q/IqL8LWSmoHNl7ODi5W1/ImVz9iEqbmR45T7krTK8Jb1wqq03tanq5rP9vTct5ai2+DW0szOwv2Cl4qgmqTk2uWY4Zafteu2lI3S0/WWm4WR3I6LmsbiwvmD6qz5lfaNhI2snoOb9YeOyKyckJaSfIW+vICGm5GOmHGco/KGd8im1MLOgoerm4SSi+bUkIfy9d/qkH6PqujCk8h7n7pwscaqqXqRhoJ12IqV8Xx/jpWHkIeFqKXLx+2BrtHObnFolazyxY66rG95f3qAaNG48MfLo4ri29/f2K2xnqSzrpN6uqu71sN9fIufqaxzjoRzZJWT2IB/3ora29jBxqWTc3hqgcR7xI5ze3WByMh3cXqOetCKfuJwi5OcnquZkJeUk4uMhvz34euBqJyVkIuqb7GZrsyfj6yD2Ymp2qGbjo7gq/yd9qnfs/vU+eGH1p/B0JyagJen3nqBmKWomn/YirzPjIe394vcurmpe4uRwn6XjH2IpYDCkW+PjbiNt7bVvKfIiNi3oMGssKZ0q6Gvb5eAZHG5gHpoopGEpNDRkLN+pcy8lvaloaS31OKW6r75hPPTlpjA3/G1ws6auYKo46K+q63ds9OZg5uR5tzG7qHGxYKg9ITIiLDRxnF1i7CSWZuIYWqTc7NkrlNVdoBxnVWjU1ZMUIBMUU6JeJlcd26Eh3bMynWBrM6MnrWUkZ6Ui76AvLaRma6QkZeolJWifJmalZy3mLGOpPWNypjWv86fgImMeGuBW3qZuoGBw7jMxKnGipeLZLDrbm/Nbuj66p/Ry3qgnMT28NH0m9qjkbuSoGWjZ2+9p7Gqb5nEh9DZjL+WyqTgt4C/mo7fne+4zcODgf+y7uPDprOnmJ6Nu9Srvs+/pHiPq6axjJCUpKeBjLrmsZPNlriSm8XJg7qft8WYhYiQot2I8q2jsObZ8+XMhvCEkar3qMGI8+HXguXKdcTAk7azh+a0oJi6h9fM5dn+y3/Y8bLBnIWn3dXVwIyAlLCBiZ3UwICFtuncgIWbipidvtzV4MuBhMWBjJPAmpGIpeOo0YDD2ZOsktvL1KTot5mUfYOs7mOTZ52CkYV0h1NXaYhWeI6bfI+Ub3x/YY+dg7GAhnZ8kaKHlp1SY2SVc39fh1dkaGarWIKZVJNoV7NyZpNoYrxsYm1zgHi+ooeDfnqkrWdra4B1dXV7dISMkJWUnqeeppmeipKHkoqQkpCWjYmE0Z+fuGxybXDPa9DMsrG/wMHP0mxub3h0enh0as10b21wbcaesKnAdXV3gHhty8bSa25ydHpv0WpsbXuCkYqMkpWKj4t/fnp5e3RvbLqT84qDj4R8i6Ccn6OXloiTh4/blqh/loCltpGLeJOTiH5roJ17ump1x5RgYWCHZoZianCU73Fumo9Vg56Q0H3fbJiWsXPMsKK23+qqoIev686fhWh1npmZlYqMhKNdh3R5aoKrvbFqo3Vsib2AbWqvuNN1ZlpysV5gfJu/stR11oC5d9h2d3WVhWiR7X6Oy7qrm6ypkY/TyoCWop6Vl4SWof2NgdG3+eT8oqrCnpKble7MfnO54+35j4OWvufqq++Vq+OW3e3f9rjKu7GL9JGb64aLoZyNiIF+m5jPy/aHt+DbdXtyobL2yJLEtHiCi4Oak+S58d2xloDP3t3a06u0oqm7u6uU59DO69ORpMLW8cyhvJ2Lgq6h+YCa8ZXh18u7xqmYeH5zkNeJ2Jt6g3uH09N8d4CVgNyRgux0jpegoa6Yj5aUkYeGhPny3uR9mYmDhp/Uhcaoq9e/qciN1Imp3ZiWh3qijdyY/LXXmPfH/t6N1qSnspudjKi5/4yLnq+xppDzlc/sloXO+pHfxcnDjpqo5ZitqZiowIDlr4KzquWw3dPwz7fKkN/FqM3FwLmCvrjMhMilgI/dn5OJp419l8HbibCGj4ahetV8gYmY0eF7x5z7f9+/aGZ7oLGWloxsn2R8wnuPcoKpn7GFc4OB0Lmiv5WzqHWv54LXl8fQ1oiMrN3JgNCxiovRks5yymRljZmHvmfHZ29iZ4BiaWWul8J0lourp4br9JKNxdyWpryVmKShl8Z4zsSZorWSopyxmqKsj6q4tLjXrbeKo/aO2bDr2t+2nrTPtrHOgKO4z5uo+cbU0rbIhJCIa7XsdXTWdOzx0JCytoGrr8Dp6NPxn/fCs86jtm2xdX/UvsG7d6XQjdTdirmSwpzUsYC4koe+jeSqwLp6Zat5gqqNcYyGiZ+HkqiGyuLWsoOApqK9np6mu76HaavipIKNZJKAiL7Tjq+Nn55wcndyeppZqYdyfqGLpa+XaM2AfH+2eopYrK68dN3giNvhsdbImu++n6XMjtPU8Nr904TS5auxf3Wa4Mm9nG5gcJZreaHI0IAgTYmGPzhbTEUuM0Q/T1gyMDgpLTVWYFZcYVkyMCE7RDRENkdAREhaNy8zLS89PS1fLGE7akk6Tj9ER1kuRF5nLxguPVNRPTpXPUQ5ZFNMVWUyMVE9MkVtJDU5WDdHSzI6LVlnRmw9MGFWSnlQTZlXTVlfaWKdhW1wc3GTl1hbWYBgYmRpYnB6fH+AiZCKkIaLeoJ7gXp9f4CFfXl1v5ORpF5lYGK3X7u6o6Ksray0t1xfX2Zja2ZmYLlmYmFiYK2JnJGnYGNlb2pgrqy4XmBiYWZet1pbWmZsenZ5e352eHZta2Zoa2dkY7OP7IF9hnl1fIuNjY1+gHd9d3XIoqlseoCEj3V0ZnNvZF9TeXhfllNlrHg+PkZJRUVAMiw0TT40QUofUjMmXklhRW5vglmqm49njE5AaltsfHlrX09Uc25nWFFRTGM+YVVVRU1if1s1ZUA+SHFFNTVJQFA5Nyc8Vi0rOVlhVW85UEdQL1c1PT9JR0FIZEpngWlZU1FGOklbYoBDRT89RDpDTHoyNV9GXl1eOjpAODMzNmptWkpYZmtyODM8R0dQP1s8R1Y2YIFiemFwWGBVsHaAr2RpfnZfSVFTVk2Dkq9vwf/1gpSFsa361pzcypCepJSCZb6j5LOlnH+4vMrEyKasoJi2sYd2tarM4b5nXmRqfG5GUVRDUU5kpoBJiXTM4MO+0ryrhImFq/Sd8qiHkYWT7+uIhY6hjfObi/+Am6Kusr6jl5+ZlIiLiP7z4OR3kH95eFJFLE1GdnoyO05FoHCXzY+McW2Jf891qIOee5lGQ3Rdhmw6TkhyaFFNillpbHGUjXCneF6AZTN2+Z3Vw6i4coqFnH2Sf15mYYCae153cYB+zqOilY6RaqaThHhdh4NTcG91Ozk4LzlWNi02WDlGTGhvM2FMWFOKa3I1PVhfZXZTimaqQ35VMT9KTlFkWUhFa0NIdEteLFFzOVNZSlNSc046MkOOdTtxv3/olJKClWJTU2FeM0hbN0GMlPSF84KDtcOr74P9hZSHi4CEi4bfwfaRrISGi0JgZVNfRJc/RD89OlBHPVE4P0VLSlBUU1djPjZGNj42OTtCLTg6U2dCcV1kZmJRRl1oTlNcNT0/QjRSrtDX5c3YgIeGg8nxgIL4hvnxq32Tmj86Z8vp6uj1oaNudNjC4oTPjpr339fWiLnxlbitUWNAalF2aYByVkhyQ29VdYBOVoJedXFnUmdTPS44Ym5PV1dOR0FJRUZALDIuNi8vQExaSEtUOWBVQkdKK2Jha4FZWWZmYXZAeW9WX2xdcXBkTZpiXF6JXWk9enuHV5pmL0dFSkpUOF07OURPMlJiXFd2VS1HdFBLT0hbU1thaEVDSV40NC08OQl9fHt7fX18fHyMfYZ8B319fn19fXyFfQF8h30Bfoh9BH5+fXyIfQF8hX0BfIl9AX6GfRR8fn19fXx9fX1+fH1+fX5+fn9/foZ/iH6ff4R+hH8Cfn+Jfol/AX6Ff4V+hn+DfoZ/AX6VfwN+fn2QfoN9jH4TfX19fH19fHx9fX18fXx9fH18e4R8DH19fHx8fXx9fHx8fYZ8hH0BfIx9gnyIe4l8g3uJfAl7fHx9fHx7fHuHfAR7e3p6iXuIfAh7fH18fHt7e4d8BHt7fHyEe4x8iXsBeo17g3qEewp8fHx7enl5enp6hHuCeoV5A3p7eoR5iHqFeYV6iHsEent7fIt6A3l6eYV6gnmFegR5enp5jnqEeYV6DHt8fHt7enp8fHt7eoV7Bnx9fn59fYV7BXx8e3t7hHyEewF6h3sKent7e3x8e3p7eoZ7AXqJewR6enp7hHoDe3t8hXuCeoR7hXwBe4d8A3t7fIR7A3p7e4R8Bnt7fHx8e4x8BHt8fHuTfAZ7enp5enqHe4V8BXt6eXp5hnoCe3qHe4N6hXsBfIR7Anx7iXwBfZV8A3t7fIx7hXwBe4Z6hHsIenp8fHt8e3uEfAN9fXyFewd8fHx7ent6hHuCeoV7CHx8fH19fXx9hHwNfXx9fHx7e3x9fH19fId9gnyRfYV8AX2FfAF9hHwifX18fH19f359fn19fn19fX58e3x9fX59fn19fHx7e319fYV8Bn19fHx9fYV8CH18e3x8fX19hHwEfX19fIV9AgIEAICgqJeh+ryLxtzwnayhi3fgtKSNf6bWw9Kzu5+lzMd036rZoYygv6KHj4WLpZG7veDCibbwsrCZ7cLEwN64/brFtaO5qYaChquC3/KD49qTjaiippXEg9KVyLGAhvmzkuv09OKgzuzN3JiJmrqNiJOmqp2MlpKRgsWwpMepnfB+jYCe1JKun6rAwre7s6mxsrzAt7GykPjY4qGlkfWDhKra3NHg54H0goGBi4DyjO+CjZWLg//sgvrn4dXc6eXx6MvG1ePljZ6po5+S9uH+gIj/+YeA/IuPkZi0tqSixr6+s6Odo6Wel4//zKqPhpWJipSqta+grKOkrqSkh6eGuIixt4C9vpeJhby838y2rauPg/3x/a/N2JvLhM+Xh9SApZ6fxOfRr4+Zk4Hq6aDixNaFnY6874i+yp3m/5qNgsWehe/Ui5qh7d/Br7ua9fXolZnFlO+OzcvZqpO5q/msuqn7rNHzipeK44Cly5eThp2jg5mWiab0lfakubF/o7m2qraWi4CRj5G4jMbR8MTey4TfusbitpWgiITfkKJ/0bmk0Ku12NCBn5i6doqnbtGvqqpaWlmCYpVtdIqZfbyA0dt/8dHazuHRrd7KoqTGqOOknZCAep+owX97fXKf7qSSt6XAuY3igYG+soSqoMHIu6inmn/n7st9sp7GbnWDfn/Niaqvg4CW07+C4313dX5yvZGysH/CvMdwbWx1bHd+d3R9fm12hYhwiKCam5qakY2NjoX28u7y5YWVm/uEh4vIwsei0biaiIqr1LSrj/vw/MS4taGcxaORhdjkhKaPv+336trneH/icLyNlIWeinLegMuI1NWy53rQv5CldHJ7a31+fGhukoB1fazNaI5qom+xdIazhvC2fq/AwLmsmb7NqrWAeoiYjrmpoO60ipOV2a/L07n55bmwp8Wh/6mZ/Yu7n62m/q/F7v7fsNySnKu+ucTFtLyiwMqSk6y0s8CxitK0en6dvYmSj7rPzsh1235ugIqTo6mpcmyCiGmDd5JTTVdUV2pySoCAgpVtWZOkdNCNiNSB3M55xsSQp6qKoqP4ssn1lbezgrShg4TMiO2D0q6xj86ojIKCg4mK3sCEzYt2n5CSem6do3acsGl6ydaaenJ6lNKMfm/1iqHEkoWftqPSub6eguqcyfvDxqOUrKtlqrfNl3h1gsKPwouh0KaR+I6Av9GD4IDc25PAzLOP5caRhN7kq9mzoI+TjH+ngrrKpLacfnmRpYKEhZqRpouQzuftrp7AlPXd55m98NWZnYq5osLRjubHr9yImKTYwYCb5/jJhazXzrSjgd6TpaSczHWui6GGcnnAjOXMgImIiZ6DnsbitqC4nf6A4t++p9H+hL7XqOfW2YCmjoGK4KVxobXmoLKmi4DZr66Kg7LbpLCdn4yc3NyD/8Plup+wwKeDiY2UpYuemayOaYuie36Ln316f497o358iHNvg1ZITHhak7RVnJpkV3OFiXWDU39ZiYFbWaZ0ZbnLt5h2jbKOnmtlaItrZ3CAhnhrdnR0aqKSh6WOhth2g4CVuXSJf4icnpialIyRk5uflpCPd9O2vIaJd9B6fJq8u7LBwGrQbGxsdWrMc8RrdHlxbNXFbdPEwri7xMDIw6ihqa+ucYKHgoJ2yrvSaW/PzW5oznBzc3qSkoV/m5eXi4J8gYN9eHPOsJqLf4N5eoCQlZKKkImTi4WIdaWNs3OPlYCamoB0dpyZsp6QjIpzasGyuHyEjHaIW6dtYIVaeW51mJmPfG6RbnzNsX6eiZVcc2yb0YrJuoK0z3ZnYI5yaJuZaHN0qJVtbHpmoqagdH58XKZujJi8mHKKeMyIe3ncg6CrdYV20HR/kmt2b4aAeIGGdpDohtSbvr2FqsrYrM6rlYCCjpC1oPbZ8cLW25fe1en/wK+ykYrvoKWF48Gd0MLb/uqFs4XKj67FgPzj+fKKioLEm86JiZWqkuGM6u+C9eXq4/res+O/rLHTsOmqo5SBfKaqxYmHiXii7JyTt6zMvoDJdXm1qIKll8XMwLCnpYv1+NyU4OD1jpahmp7joMzElYCd48yK6Xx3dYB0w5a8wo3Ry9V3dXN+c3+HfnqGiHR8i452jKWdnJuZkYqJioHv7enr3nuJi+x/hKr44ezI79q1nqnO6LarjPHe7rqSkYRwoJ2Vit7qhq6a1dzs0uX4hYfogtWgn5GploD3iu+Z4um/8H/dz566i5CTg42Ll4OXvYCTl874gauCvoPbhp7Lj/fGibvEycLErNjz0OKrnq7XvuO+sfCugW5xi5/T0p/KuZOAgKV91JKB7oPGo6R33oV7nbWdjKFzf4+Jlp2Wi5iMoJiGd4+inZiZbr2klZKexoenmdLw/9GL+pKJrbLY0NnfiISgpoKjj7JpY3JrcIiVYoCop8GIcbvQle+cjeeI6uGG2tOftrCTsaf/xMjkira3j6+fhYzwmP+O7cDLnue/m3+IiIyE5tKD6JqHtqy3raPT0qri44Ke9fadf3eDmM6Fe3Hhg5vJl4+dsJK3rMWoje2VyfTH3cGt17lxwcLWoYWBj9el2pKp3riR9ox8scR71YDS04OswqWGzLiEd6KTZ6J5bm9zboKyea3Drcaml4WhwZaPkaChwKWj38vRr6Gye9C+6ZbE3OKKi3CMgaivYZ1/gaZbZnGfkGNutbOVZ6GvkpiHXJxvk7225ITWq8Ogg4vNnf7hf4OSkpiFl8z92KW3lut70ryheKGjYKHOluHS2IBDVjlHd0lFWUxFKTQ1LixGPUAxJjlSZH1sYE4tOUonXURaRDNARTosLyswOjI4PVNLN1BkOC0cVVZLV1syWU9MKDc2STxDNDQoW1dJUmhKSSwjIy49M1VDQiolPEw9Okk8YmY/VpNreFRPUHNXVV1sb2VZZ2VnXZOGf5qEe+CCjoCitmN0bnaEhoSGg36Bg4mNhYF/bMCmrHh8bMd9f5iurKSxq1y9YWNgZ120Y6xdZGVfX721Yr+1tKmqsKuyrZiSlZaSYHJ2b3Fps6a1WV62tV9bs15eX2R7f3Ztg4KCdW1pb3Ftami/qpyShIB0c3WAhYSAhX6Bd3N5b76ZqmV5fYB+f2hdY317hnBoZmZTTYV/gmNVYVRUMEU4LkIjQUI3QEk2QTgmKDBfdltyX2dAUk55ij5jhGmNh05NRGZUSWVyUFlTcls6Ok1EaWRTNz1QN1I2Oj1aOzlIOm82RjlTQk9QNzs4TjNHTDY4Lj9CN0dFSlx6O2xlfG1KU2BPQVI1OIA3QURVQl1bfWBZWlKDZmVkQzZCOS5tQ0U/aHBYbk5abmNGRypPM0FQMm9NanY4QDpgPXJPT1aCTWZooqRZnY2WkbCqjoyMpLfnwO2cmo6ChbKz3KmooYi38qCFk4+jnXbHaG6ypH6XjbXDtKednIH88blyf3VuNkJdU0lRY1dwaYBxg19r44aDgY6A2ajY45726fSIhYaRg5GbkYqTlIOIlp2Gm7Wqp6ainJCNjIL09/Lx3nmChOl7dDtAMjk1eTM7NydEjqSeheDT47KMi4Fbgn5sYG+AS2ttnqSMgp63XWWbWIJ0eGChd2KvbHdxb1xc9I2+v5OyaGJ+Z4OEZ1JTcoBgaoOYO35TkEGHUliNYKKPZn+ZnHNxhoVrWGA1PDM3RFhuY5VdTUIxLV97fXGahVxOR29HXmJgkE1sUU83tGJcbmdgbmZTZmFna2NgQFY4QkhPU1xWX1hQO3pkUjdPenGHa25qcpp0bj5BOUFya3jFpabN0KnRtuqKhJmQlLTJgoDf1/yrj+/1iJpPR49JerJqfodDTEJGQF+Xfkp7RVZORWJsVVGDYHk8UDw8QkE9KD87SD1AdWU/ZD81YVRST0pbZVhjXD5KeLmWhYidstiDgoDSdI/WpKOkqn6cglE7Wt5/k/HYfkBCbcCE8NbitpqXo/7G+aW4+o1fh0o3Xl48bIBybT9TYl1MhodfS3h2LWBZRExFQy0yPEJJWVU+MiUwNzMwLTk6MSYpQ1tZRUFRS5eEckJDZ3NZZ192a4yMSGxWapQ+Q0x1YjxPj4VlSHBiY1FiSG9AW5BKRCQvMkVCMS9HO2dUNDgnMjgrQld8ZGJgPHE5WlBWQV1dN1FZR0xMToV8BX19fHx8hX0BfIV9hnwIfX19fn19fHyafQF8hX0NfHx+fn1+fXx+fXx9foV9A359fod9CXx8fH19fXx9fYR+i3+GfgF9hH6SfwZ+fn5/f3+JfgJ/foV/A35/foV/A35+f45+hn8Kfn5+f39+fn9/fpN/lH6DfZF+h30DfH18hH2GfAV9fXx9fYR8EH19fn5+fXx9fHx9fX1+fn6FfYN+hH0FfHx7e3uEfAJ7fIh7hHwHfXx7fHx8e4p8hHsBfIp7h3yDe4R8hHuFfAR7fHx8hHsHfHx7e3x7fYV8hHsFfHx8e3yFewZ8e3t6enuIeoV7iXqEewF6h3kGenp7enl5inqDeYR6jHsDfHx6hXsIenp5eXp5eXmbeoV5Bnp6enl6eoV8AXqFfIR7Cnp6ent+fn5/fnyEew58e3t8e3t7enp7e3p7eoZ7DHp7e3x7e3t6e3p7fI17CHp6e3t7ent6kXuFfIR7hXwGe3p6e3t7hXwGe3x8e3x7oXwHe3x8e3t6eoZ7hHyDe4l6hXsDenp7hHoOe3p6e3t8fHt8e3p7e3uGfIJ7inwFe3t7fHuLfAZ7e3x7fHyNe4d6BHt7e3qHexJ8fHx9fXx7fHx7e3x9fXx6e3qGexN6enp7e3p7fHx9fXx9fXx8fH19hHwCe3yEfQF8mX2HfIN7i3wMfn5/fXx+f399fX5+hH0EfHx9fIR9CXx6fH1+fX18fIR9gnyHfRV8e3t8fX18fXx8fH18fX18fH18fHwCAgQAgHvTq6Xp64CHjoDukvG+3IOUhu/GheDTgbrJxJKqs9iscpTqjq/4+cjd0/Hujov8hNWds4HYp6ed3/OLiYXIrrjNo63djYy65pqoo4KhqaTygdDhuqK/t6T1wOW6+oTtzNTS4dTTjcGHjpeDvqavk9ycoZKZjKCSj5ySieDI6ImGgJGno6ezwsK2wLa0t7SruKqPv62iqcXh8NCBpuD2/oKBhIKC2d7W5+mP/u/z2fOIg/Ly793d383a6PLyg/3/+YKBhYiRo6WPioLBuOTpgIKPi4iFjJObnaS1t8K6x8K9saqpn4Ca1JyZ69vW/4atu760p5ussKua9uvB+Jeir7jJgMPWva7T1uXfw8PX0LSnj+j7u8jO14CSvNvSwbKfyvKzmOOP2/HUqpTko9WeldHPkoGpjdeEp8X8j6GokqaYnpvEpqPD7Lar/Ivkr/2GhK3Eh/jw0Z/4kLu737auic2Xn7ORxbfH8NuTvt+/i5/tqZOViJihmpGCrKrbhbzQloyHgNqB2u7bx5rSipiii366jZ2Rj5y4pqObk5COeHudsXW/rICI4Khtc6qUcsZszop0YmexdrFkc9yinWfSwdGpn7yVqLWxxdaJ27GmteDexHefqaOUeHhvt6nfpqvRw8DF1fjHlsC42OWXo8ezsLyfj+Dtb4KhqLKxaZm4alpwzr/cgJHzyYN65uqFgX7fncGrtYGidXeAhYWLoKqyoYFvpKisiHGLmZ2ekZiEioKIgdba6uvu+IaNgIOLg46ewqy5yKmrzbrCd6zI79/ZgdTPgobyeIV+nLPN07jNdbfzvdqApX93xuOTkpeb1LSQydCtpYeHnMqPk4PSkINwvJ6GgmlfgHV9rJVyxbStjqdrcpnBuqV1yJG6vZKZgNiQeYiXiZdui5Wze5ySn5SCms2AjJOSzcHJyMKstqPr6N3DrYXq/KDh9q7K2bedwsacrbiXzpm5w7LN29TPjtmtiZK2gqeYoJvKtbepqt2td4iBt5d9gZltoJeNWXSTi1BNTk5Rj5Z9gH14d1VSmZWtunWpsNXHkuGdl8+jraWl3s+S6ry1rsqbwpvOr5Oci8ydlHmPsvF7mJT23LKRkcSnmYeAeHWQf4d0bGxhrYVkhMuA1JSOupCpwXHEc9m3huR8mNmct4Le44Fyv7/ApYnMfMqFaod9k6iUgL2ZtcCeo97ksbSSs4rmgNHtsaGvlIqFh+PRob2TtpaZsrCqnvGP/IC6fJR88ODfy7rFenOl4Lyat5rF+97Rs9/7mquyz67k9LqPhK6p+MSavJHXzraulfKuw+Dx1uWmrcnvkuv2fOan2r+tkbaPtMevm6ZwfoJ+x/P2xe6rpMrX2qD24Nafhbas9vrjh9TggIKoe4DHsmlzd2jsidGZsGqIg+jBh9Gpa6O+rIa4xMPDgpLljLHMyaKlutW+bl6sVJBvf1iXe4F0lK5cVU6Ve4+ndHmdX1Rkl3JfclZ8aWqdRouXiHB7eWKphZeJq022kZKAkZWYdp55hI9ljYqQebB+g3eAdIZ4dH15cryow3JvgHiKhImTnp2Vn5iWmJOMl412qZqNlKa7xalul8HQ1Gxrbm1tvsK4w8F1083Mtctwa8zPyr29wbO6w8vLa9LTz2tpa251hYd0c2yoosDCamp0cW9scHZ8fYWRlZ2WnZuYjIqEfml+rZGO59bN7HmTnZ+XjIOQk42D3NS56ISHj5ShgJ+nmo2nqbetmZimoo2IdMfHnqCZqGpoe4yKgIN4gq2QbqlxrMm0k3fEjraHbIqMbGOKeKtvh5jAa3V1aoF7hn+hi4WTondqnVWWjbFVZoiTday/soric4p1n4OMcq9wgJJwqJKyz6R3pM+ueoTToYmJc3p/hJWVwbryls/HlYuLgNh++/n94aTelZ/FqIDUkbCZlLfBrKy4o6GViYWU0of4yJGc1NKIkc6zkuiD/7WigoTjr+OCjP290YPz0+iytt+0xtK82+OX7b2uv+viv32tu7WkhYd/yK3fmaXAr73D1eGmfKqw0+WVncqttMGcl+n0gqPI5+Xcja71iYGX49zvgJn83I2A5u+HhH/io8q4xI6vfYCJjY2Tq7fDrYx3sLG3jnaQnqChk5mEiYGFf9DW4uHj7oCHe3yElaGx0sXe973G7uDQh8/f4svEdqmxZ2jYg56Tk77IvMTdgL//zOiStpKC2uufnKas68yb4+a4s5CMotSknJP7rJqA1bKkmoeBgJGNxq6H4uLSv9mDjqvWy6yA1J3Iw6Wqkfinipi3r7ySoqPIj6eUiXRsl9B4eYF8qo+cpqianZzw7tuujXO4rIHHuZinwZ2KoKCJhIthfnKZnJSmlqmqgamjgq/jcI6PqarVycnPyvLFgqOo5MK4wsiHxruxbpC7sGhlZWZrvMKkgKKZmGxpv7jU2oPEt+nNn+yqnuOsp7qx9M6U9KWnqLmZvZHRy6WvkNGqqYqay/uEpajvzqqkmcW8saSaoavFsb+xlaGg/LWAqdmB0IODs4OdtXXQddzBj+Z7mM6gw43Y+pSFxcDds6T5idmMdZaGn6+YhtCpwcukptrpsbGLqn7dgL7Xho2jg4JnXqeNgHJZkF9xeHB5nuqE4IXHlaqJ8+/43M3Qg4Si/d20vXSs8drKkbTeg6m1s4rEvJRnZoVulnZplVyCjXx6ca2GmcTi0r6XmI+mfsLIgv/C/eTasuKv5N7Uw8iCh46J3erp1eaoqM3k3pncvK2JY4CI2O+7cdXbgC9DSExzbDQ9NCVEMFxGTiYqLm06LWN4Q2iSWTM5PVU+LEBoOD5OR0VBO0pMKzJaLEdCOzRWNCEzVHFBPzdAKzI+Nk51PEFUTzNNSzsqV1h8GTtINCcrQ0NLMzlGcT1QQl1XZWB4bI19kJ1XcHZ/ZpNrbmZwaHlsZGtpY6WWrmZfgGd6dHqBiIiDjYWEh4V/iIBqnJGIipymr5VmkrG8w2NiZmRjs7Wtsa5ovbu7n7JhXra5t7Cus6mrr7i1XLa3s1xaXFxkdXhnZmKglausXVtkYl9bXWJlZnB+goiChYWBeXRwb11qoZOS/fHU3nKEio2HgXmDgn54zsW0zXBzeHuCgIKHe3OHio+FdHeAfmxsXqSSgYN8gVVKU1ZPQDlIV2Q6LTIhTVJAPj5uYo1sTVxlWFJsTIJfdX+dU1lXUWtvenGKe3N2dE9DYDFdSGYwQlJMPGdnXC9rO0ZGW0FHM1Y1OkcrTVdLZGY8TFNLOz52VktQTVVEP1haW1lsPlpPSzY6gGpAbW1pXUtiQzY/UEZnNzc4MjRGSDc8PTc+OzdGRSxfVTs3T0k8OFdOPmI/a05IPDlVVmEpLoI4QkenqKl7f45vd4d5nqR4wJ6lrePcuo3J3drHo6iY5b3poJimpaertNOgb5qgzM2NnMKio7qGi8rPZG9od382OmKXTEJIWZGsgGmbfkhv3f+VlIv3tuPU46/RkZOdo56hv9LcxqGKx8TLoIWfq62vm6OOj4eJgtnd6OTm7YCDdnV0Xk1DRjA2Mzs7TjqDNTRqwLOza6LCZVjBVDpATWxpU42yXGipobBWfl9SbJBueJl/jnFltYuLhnaQqrtwmIHFeoJrz6JEbFhOgFA7aVI5cHpxdIRMQmF7gIRmtXGMfGFmTYJeVE5YNEc3UWh9Nk5IQ0o5Vo5VSkhDUE5YZk9HdUpsmXRnUE+EVFFbdlRsem1mb3tOU182O0JkUFp3T1RoTG53UlOMLklch3RzW1Vjmr5xTlxfc2tjd8+j8ufhirf15YuKh4eN8f3ZgNTHw4uG7c/ikVB/no95b8x9eHVFRj9DcWZJinNtWGBWbGuMcGpgRX5EPzc4O1YyMDCHeHdXYYdmWVxkXU1RU1hcVUdLj1c4Y+iH0XB5uXqQqoj7he3ep/yDpbtgQTF+by820shINVrXlf6ejrCUtbqakvbJ5Oq1dHZ7a2k7RTVogGFqWURbUElMRnpoU082Ty4yXl1bN01IZS5SOT4rV1NMUk1RMjE7UkM3S0pGe2Zgc4iLVlhsgWmdnXhSUmlTZlNZg0NWYkpZT3BZWFZmTlE0S2VvOVZrWHNBPjU5MUQ4UnFVTE85RTIrU2GGdbBuQWdKYEFeU1pSNU1WdHJcMU9ZAX2FfIR9EXx9fHx8fX19fH19e3x9fHt8hX0Dfn18iX0Ifn59fn19fX6EfQV8fH1+foV9D3x7fX5+fX1+fX59fn19foZ9CH59fXx8fH58i32Gfot/g36Tf41+hX+FfgF/hX6Cf4t+BH9+fn6Kf4R+mH+DfoR9i36EfZR+jn0PfHt7fHx9fHx8fX18fHx9hX4DfX18hH2Efox9CX58fHt8fHt7fIV7BHx8e3uEfIJ9hHwJe3t8fHt7e3x8hnuCfIV7CHx7e3x8fHt8hnsGfHx7e3x7kHwBfYt8A3t8e4Z8B3t8fHt8fHyMegF7h3qIe4J6iXkGent6eXl5iHqCeYV6BHt7e3qFew16fHt7fHt6ent7e3p6hXmceoZ5hXoBe4p8DHt8fHt6enp7fX1+foV8Cnt7fHt6e3t6enqUewN6e3yHewF8hHsFfHt7fHuEeoZ7AXyGewF8hXsGfHx8e3t7hnwDe3p7i3wGe3t7fHx9nXwGe3p8fHt6hXsEenp7fIZ7iXqFe4Z6B3t7enp6e3yFewR6e3t7hHwEe3x8e4d8hHsCfHuJfJN7Cnp7fHt5enp8fHuEfAJ7fIR7Enx7e3x9fXt8fX16enx9fHp6eoh7BXp6e3t7hXwOfX19fHx8fX18fHx9fXyEfQF8hn0IfH18fXx9fX2GfIN9hHwCfXyGe4V8DXt7fH1+fX5/f359f3+EfoR9gnyHfQN8e3uFfQJ8fYd8CH19fHx8e3x8hX2EfAl9fXx7e3x9fHwCAgQAgIbC1pD6jNL0zL7djcDToejRufDkmI+Fju/hk9eMk7aizq6GlJi5jdGAgfvt6ev/34rx8aOfutmqgITmuuy15uubzNS4juyNjoDc0YLR5Lquw/GhnKi93vuihtWanbSurIfN39jBmH2BjJ2s/6SejPmgh3N7iarJqsm5p+jB5fqCgJG/rKmnvrGxur2prKegoJTEwLzAuNLw+uDH2NmCkJmBx5DEr6Skoqu+y9h/kY2Ooaurw8PSwsfO0drr5vP3/YGCiI6PhIj7sKae3PmAhY+XkoyIlKSnrrqzwruyuL2tnKyD+OzPkNXDtb+ElqqxsaKjlJ62s6Kenrmtsayoua+0gMLEv7/V7YDxy8+/v6yni/afl9fbybefkIans/m2nJa0luPj3ZOaqLK6wdGa6Yregfb92JXYmZaG84eMr5aIie/S18y/hfLK5ZO9u5XbzsK9v5eC9bPDsf63gtzG1PetqvKMpqLB9ef3jej54vfpjs2k1IKCh5Tfd6ffr7CV1JCXgJ56f76dmNV2zIa2gYbLs6bAlrSHz3+kwpeGhozRz26ybrPHsrOeuWl0raF8bnl/2Yihc7y0uG12gWt8u8iZoLemsK6lmKzQsLnijIycobZfXbCpqqtac5e1wK7c7uDU44Lxnpvy4eSKmbSnlda1xsmdjXx9X2ZrhIi4tnOBuHemgJHSn5uWepeIl+p3qX7Uxq9th5+pxXF4dHXTzW/ZwcSViHiFgpKNin9/ffTx59jZ0c/Z5/2Lj4mKkIi3snqkfJPDy3txs87HdW/G06qc5JHIj4rR47H9m3rcuqud0efhe7moyu2Lfritp4Dod7V6eo7lfnaXrLact65/isPfl6CEgNF6xJKEvbKdsrdvbHOOhIGBndqZuaKU0K+c0ZSZhq6os4XCe5t4ptCX2L2TwvTBtpnKxJu5mpnU8v+yuILSgeLt+vLr2erugregio2RqJu6k6TGr5Oxm/yFkuDYwK/99oe1kKW/xmN7iGlshWeVcZ6PjIJjfHl5hIRzcX5/b2R4gHVhbmZ0icWBrfSX4Iq1eal7hZ3Rv4Hh0fK5rILUpPCnyeu43IZ2m6aZoJiFnJuFz8+Xmaibm5SGcJStqKtbq2ZvVGmRlJqpxJyOq8ucsLDH0IXT44rg6JXp88a7oIGrzI6xlbTOjYTNyLFqcoSTz23O0JOna8W1s8nJpILZrcf8gNb51/aou5nzpamGmr6oxs2Btaqii4iW1bmjeY+I9a2UkPCn4eHa7Jju3pTsmJLBjLSRp4z0gsuTr5Htgo+S9u39lr2gh7mShdTBmL7Iz6+N6M670JTykn9tqcaFypqMq6iYbbNr5LbcmnWb65zpo727znvRt/SJ9eyUrvzMgeOBgHqom16xWJyrm4K1a4eTiMmnn8/DiZBxdu7Pit6Un7mr26Rrd2+FZ5tnYqWpqqewiFCYl114gJF6YF6neZ12lZJegohyXYpLT1GLhU2ImW13fKBpXW2BhopZTItlY215fFiIoJmRg3h+i6Wu5o+NheyUhneBjqO8kaibi8SivtFsgHidkYuNm5WWmZyMjo2GhX2soaCjnq/CzryrtLVqdXtpr4vPxLO2srrL0Np7hoSHk5+Yrq62rrG0tr3JxM/P0mtscHJ1bHDUm5eSvM5qbXV4dHFtdICDi5WOnJaQlJeMgYhoxcesiNTDur53gJCUlIuIfoaalYeHiZ+Vjo2Ml5OUgJyemZqruWS/pqaXl4uOfdV8erm3pJd/cmeDf6F/YWWFday5vG1xi3d/j6Buol6aZc7VoXCgcmlgsl1efGphaMSmsqemeOKxwniTj3KonJ6ZnmdUxX2wob2BZ7SRsMyPiL9hhYyUwcO2asLQz9vajM2iv3GBjpbwiLPzwLuc1JKWgJGAjNW2m+eC3ojRlpzcxLrdpa+Z+Ymt5refipHp9YXmgdXgzMzR54GX5tCikqOh/qO9o+jV3IeIqYyO18+ft9rBy8i+r8jmyMfpkI+iqsZqacC6v8FnhKy4rKPy3tG80nXXg4Tb1teDlrOki8+1y9WnqZeThoGRpafx8ZOj0YKugJzSpaGlh6CJme16r4Hf0bZzjqex0HmEf4Hn5Hvv0tWej36KhpeRjIB/f/Tv5Nrd09DV4vSIhnt4foG/x4Ohka/q95iMzfnoh4GwxZ+ItYukpI/f7cP6m4PcycvD7/r7h8q30ueRh8LAw5H9iMSDjJnvgnyjsMWyz8aOntv/vcKcgOyI15yO0+6/29+JhoqekYuPsO+lxLOi3M2+1JmyndXEyqvnlLeFo6Z68LN+pNKqhX+uoIumlZT3//eekGK6Xaqsrsy+pL3FYJaHhXhuin6MhJG0jHuJi+aCi87NnpXW1oC5pMDp9IKepIaCpZC4lseyrKN6mZqWp6qUkaCkjoKagJV8jISOqfyct/+j5JO/hLmKlrHTzIPm5/K1q268m+iguum17ZaLsbSrvayVppyFy9Weo7Cts5uQgrnO2fWI85u1gpTPyNrW7aCPmqaBraq1tn/P4oPc65bp/LOpnX+b4pi/jrv6oong18h3fpCe2HTU0p27ctG6tdLLqYPKmLDfgMLTl9GYiXqoenppanNhiJldcWpobIOX2rCohqKN6ayhm/6a3f7r0pH652u8iIWtbI91i4j2bp1viXK9aWlfp5m6fYVcVotxcZ+Zm7C3xKyV35x8rXzjiJyCubmi+sGqzb6/i8yC+crqrYWf8Z76t9DQ34TKqtFtwp9ngemtX7p3gDVPYDN2NHJ6Zz5LR1ZUP2F6T2ZYQkI/SEeOXFw3Oko4UU03NzI/N1QuKFFLSD5OSDNRXlQ9S0hBRkFgQE0/b2hIRklQQVs1ODJUPD5tVUM1L0E8TTI9U1g4L2AfQlVJOz9iZnt/h4mToMbS9o2Li/uXlYyWo6/BhZSHdq6RqLJdgGaHgXt9iIWFhYd8gIF7e3SbjpKWlZ+ptKeYoaBeZ2peq5b3893e3OLv6/GChoeLj5yVqaiqpqqrrK+1srm7uV1eYWJmXWPDlpONqLVcX2VnYl9bXmZpcH15hYJ9foF5cHVctLmgieXd0MtxdoSIhX9/dHmNhHt5fYyDe3p5g3x8gIGBfnqMj0uQhYF2dWpzZLNeWpSKf3VnXkU2JltUOUM9JDQsLig0PDZBV3ZSd0NzVLvFd1J1Vk1JiENFXk9JU6KOnJSddN2nsGl2cVqDg32AgEUxYj84Q2ROMl9UYG9DNVMoPT5OYGZYLkZJTmBmR3FbckZPUFqYQWh4YVZWgFZNgE87PmhbQ2A9azJPPkVhVUBbRTs4VzI5S0JERk5rXzRaNVBJTUJLUDE6VlA8OUNEek5GOVNPVzkzOzlfmat8iIuFjnpycXaQhKfhlZavwOeAgunk6vSAp8fFr6S+yLapsme+fnzIzM5/lLChhcCwxsaGdmBuREBAPUuAiV5aSFFxgGifdVxgV4+UpPiDvo/2786Co73F5IiVj43894H53uGumoqbkqKeloiFhPn07+Tm3dfd5fGBfXBpbHF8WzMy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amNlXIBdb2VYW6zJhHnAjcfK4ZrQeHiEiaTh+6mAtbmajY9+84Pwp6Fyne2XmI3BkNLf5cPdke7VoIKIk6WLYGmaja2onqGHu7eMqnnR88qbjKHnzaShy+nzue3Ng5vgo3WFy9uE8MmwnLHt/YiJyK+xzrdvz9OWhYCNhX7k0XW5seOZ3YCTlrvDyteJze+gi6vfyfqXj7iIkeCM1fD3l7l9mn6qlbvhvov+ia7o0bDkv8jkt/mHgO7d0KbOn7yBhJiKg9u14LOG5ZGXvun7o5KFhbr907qOsK6PwMJwm2x8h4jCr7GFaGqs362tmH6kx4TsqZGc2MzZptf6gIaB6/qP8OSU9YCSs6Nvk3WCmV5auW12o4R0gG6YiYiWg9aGgbeBxYnAw7zWnml2lltqb19niZaQjHp3WUtzXG+Ie3pPbaFrVWq/qVNojnZSaH6fc36Aq69keY6WXGdshW9aWIlyV4ZSZpxbYG2hhH+Up7xqb4rEyoXHz32KbXGBgIio0XlxgIyOcoCBj42NmJGKh4yWlpGPjIfGlZKikKO6xGlsqrfMn3e0n6rI0XyJg5mvvcDGvKujnKOlq7y5p7XIbXJ2fnyDe3Ftb2zFtKWgio3CcG1yd3Z4eHFncXV7hYOPipOGiZOXjYp4c6ejdreoxuiBhYmVl5WLjYqIiZCXnJOfn7CFcHWRmICxrr2kp6epuKymvsCsoqGJi3egiJypv5+LmoOPl6yIc3KtsW9ydIS6dIyjZKaOXK1vbGppuWeBhnyCpq+hho1vYmRvfXFovLV2e+eGkIeZm6Kgeb9ya2Oxm3iYjWp50m6ib9+njL11oIrJbX3Kk7nbhXyalp26nYKYlcnhkquw7ICou6uwl8qbzdvu0bD9sIr81eT91+eNkLjFk+Pft4L/7N/U2e+B9P780IWL16qHg4Lt8ryeos7xpNGpsNmKxeTx1cGtkpuUs7v7t8rH03FwcHV1cXByc3igmrrD1sl5zMTmudOHpHjBkJSly9i5lKGHl8O2sdiAgY2lsc2auKjSzoCVkff+rcvrssaThId7yK6BoomRj37o43nVv7Orp5uwzIR4foKIi4h/5eTseubIy+De497u43vp7+WYyvn09JWOjKPS7eXVtqKeuqv1fZt9lfrigeHfeXzg1oV6wr3ruYiRgt7tgYT1nqrW5dHu4OSryLrOkJ/E4Z2ujpry1aTf8ICWhs7wgILF54v89c3rp/zMoZWIzNKej+Hzhd2FtuL2zYef1Yqo09W6naOFhLDCn3OemWfQzqrso8L7gLmwkJOwarCsqMJ9e6GVhItxqYaheXmQipB41IOMzZyBo6ft2O2R7vHTjIa1pYSjnZ+OsvmsqKiWg3K0xXNydYF9h31/c4B0i39tbdX4lILAj8Pa76DdhpCMlabz9rGHpMGEepWJ433nqqGDqvqgpKHLi9W2ycrakuvQq4WNv76igoDO0vHy+eWr+sWm0YzH4aKJiZjmz6Wjx+Pto+bRj6LNroF3t9yS/MvAqrXW95ii6cS4zL901tugjoeTioDf1HarqdGJzYCIgIaMpYpoe5dxaXeJeJ1gXmtgXJ9q1/LIkMKFpoK2l5jRpW3dgIfo1rHcpbG2lcNhYtDu6pazfo5lZ2pkXpFyxJ1pjWd2mOLoh39+fqau07VwhIRx78eLsYGRiIzK1c6lhIPD/L22n4ur34T8vq+37d3ahLDQW15IltF6s7F61YA9TUk0ZFJdZUA4dUxJcVBGVFB1bGdmU2FAVI5bYTxGQ0ZYUDg6TTM+PTg9PDFDSElLRi1BOUlcOGQsU2k+HztRYTA3dVMxOVd3TlZZbnlIXUlNPkc4MTg4N0sqJEA6VWJDUVmLepKwzemDhpy/u4jk/J2khIyWl6e603JkbXZ5Y4Buen9+hIB6dnuDgn+AgH24iIWNgZGjrlxfmZ+uloHZvtL5/oqUiZulsrC0r6KfnaKiqLCxpa66ZGZobWxwa2NgYl+yqZygkIavYFxgZWRmZl9XWl1faGp6d35yc3yCendqZ6OcftbDz913fH2DhIF8e3p6en6CiIWMhZJ1Z2t7gYCPjZmJh4SDi4yNnpmGhIBpbF6MeX9+joBpXE1aW4FfRjM/ODM0NkdUNFh8THlsSIpSWlZUjFJlaGRpgoV+bW5XTU9bZV5apaJzeOaGi4CWm56YcppJQChRWDxCQissOStALl1eSUo2QDlYKSlUSlZ6PDhcS05sS0RTQk5vWlNcgIBbblhjXlhAZlZRYV2HXz9oYWhrWlo1NlJIQIaBUjVtX09NS1MxVFZpVy4yUkc5Mjt8dVxNRFNuYZyJg6Btn5OhlYZ0WV1aY4nZwt7e9YeGh5CSjo2PkI6jnLqywL9wwK/CqbF8onK0iYigyNq8kJ50cIKTg204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YV1moItiZGJbWF9mWYBZnV1cjoSOudCsif6xlLfrjpuOgYiJ+I+/3v6v6IbNmZGVqJGHnoF/qILUxJblpZyuxp7SrntwcH56bF1hX1lZlJejWNB9nNHrq5CZmciPfYqw1sz/x7qapMiBebrH3bOQ6KB7x5Ovk7yMaWuKs7a9w9HEnpeaptOmzneWm5yZk4Cfo5OG4/SL0OPiiJK6mKDu45zPxb6C5M+S/8ebjbb2j5Wzgu7LjJuFsveJmZnqyK6X59r/ifSfoKfBw6qX7PCp1YnbhqDj5eS60p6Vm7S+zZWw7q2Lvpmft3OwoMu84rNzjISadrTF26OefZScl3J/07zBxqGJgu/Kx6iFnaTRl4CqnHp1hYm+ZIabXHR/vXGAhmZhf4ilhbabi2nfsNGcg9HQgHi2kHB8dYd3oXqodX+Dh1WGUF6Up2R4jV55VVFvpI+Oa310b1JueaJpnFdjg311Y4WOl39WgIKGlnF/hKqimWyIgs2Vv8xr0W7VdHuAhJF7bnmBkpuXlYmZstx8g4Byepqph3lwgY2GhNu+cYWslMp/i7fLu2uvmI9/v6il0YKxzNN0dH6Dh4iJhHx+f310cHRw0nJ5foqQkZSRjH52dnlsy9pwcn17fHNvdXBubG1wc3x+dXJ4f4yUl5GKiHzGmdPgd9h4hJGNl56flJmOg4KEnIWDhYajoqTS0nOQkICUm5GQqaiop5mdp6qeoq6OcXLHppmSkn14mpWpZbacbZdz44m2epWnhF5uXXFjaIiBb45wiYh2sKN5jK2dhHmXhoF+hIWKdn57bYORloSRwG55c82RzIWBkqCpcOGDf3Gcq8+Rc26KwLyhsNByhK+e5KCQjbO9jIqPhqKg6Y2IqoDJn9eh/Iz7y+jhx8a244vgwMTQ+qaNgJqljKaFiKi8rbfB5ojx6+fYz+rp1KmN+5Hl2b7EhvTJ54mHnc3x+M/l7buhg42I/7Pu2HF2dnt5e3d4e3xyj4OLorJpzst6yK/Rbmx0cpHYepm0tLe/oJeFpZSAv5mz/qvp54OI8prbv4C7pOiL0v2VnIaJm4SMfdvTyJbFzszW0qGjoI3d3NKQfpB+e3h9hY175ePo8ODPytvnzL/C1vnbebzTyL6K/7bs88C2paKh5qPc6KnP6Yp0tsC+mYbn1r7ajuLbefHozvqIw6qrx8mC247az7/KhdKI1qjM8aGGtMO1hNPnv92ZiIDOwdqa7dvyxfuEgq7QzJ7J7IqB9rfjre3dvonitrnsruDTi9XWiKmMgJaZqq6cgX6faqq/x4l/gox4mcqmfJK0n46RrK7BqbGHgrq4mZ+ioqN8jZ6fkdCaqa2hwqGwye7O2e6UuJK3tePkn6r8x6WznZaIeXKAyKx5fnpybXh/b4BsuG1trqat0OCwjuWxmb/vk6adhoeK+JPD4vaT1YfTiYuWro2KoIyKsIrVtpPTsrC2vajWvJaNnJiZlpCCi5GI1uPcif+KoM7imn6alLmIhoyuz8zwq62LutuMicHU0LWd+LCL7Jesmd2rg4SStrfEyM3HoZifsduiyneRkZCNiICLiG1hqJpnhI2MWWZ3Wmutqnd9m5Jd1bSB9dyrhrrpfnKVcMWvanhosN91eXO1nYNwrcL1fPmIeIGIjoBosMCIw4G+d4/Ks9+xvn18irjBvHaCxZZ82qzx0YG7tNC0+saGoJCjgMPe68K2j5WunYuTs9DLq4J2aph9kHtwdIK7g4BaSEhFUkU5L2ZzO01XnU5ZXUVLaWV/ZXpua1C6cntOMkxhQUJkYUFFQ09NcDdjLzNFTEEtMT1FMEA4TCEjSUgdT2U+S1JPUzZTYXRPcklTXUlFO09LLy84XF5qZD01S259aDx0Z8at6/2D/ob+jJuiqLmajZmdp7GuqqWzvNNvb4BmcoqOeW9mdH97ddO0bZ3Ws9+BhJ2snl2gioKC687E54iswsFmY2lvcHNzcGlrbm9oZGdlv2dqa3V7e316dmtmZGliuMZkZGtoaWNhZWJfXVxdXWRoZV9kanV9gXx4dm67nOzld9x1e4GBhoiMg4R8dXR0hnp3eHeOk5fHxWZ7fIB/hn94ioeFgn2BjY+BiJJ1XF2pkIZ8fG5hZltmSY2AUkomTEBdKkxnWUNMQldLUGhkWW9YbGxfiH5kdIl9a2V4aGhkZGlxZGhuZICPmIKDrF1kYbeEtXBIQVhPNWY/LTJKOV0/OSs5S1E/YGE3P1NKXkdPWV5eSkJWTVtVflREY4BwTlhNnlqTcGxVY2BbbUJoVFpfbkMzOVFJN01DQUZNUkNCSDliWldPRVFSW1VCcDdnamFWMWZgWXRdcXyewXuCoYqBaV1ltICj7YKLjJSUlpOUmJuLoH6Rra9fyMlqr6u9YWBdZ43Xdoarpai1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y7yNmcnb1PvFv7jH4oL+nZ6akau0zerMjbm8lqiUprvPke32os14gsKRj4l2dneAb2tjV6WpjIWnV4qPnFZTU4CHrohuZoCFlMKNmOr4kqvPhYl7rXu1gYaBhayz8cLpn9qhffeWpsLZcHaofMi8on3ftcetmoBvw5uNb59mbF1eWWFrVG18f7R9jafCksm11a+b0I/XkIu6hbSBe7G4mbbkgbLEbl1ytNqLcHZ4pOH+7+rDosm8tJiJmryNv4GOqoD8sruKk8eYr/TenpG3q77JlaLLtrSovYDywqfEocDttr3D3PHVtu2rsYG29+7a4+GZ26PWxN2//M/ziIm9t+SMf9mA1bi28M63iuPHm67nnIehxH25jZF2zc+3z6jtj5J7lrCgsYqIdbOlzb16h6CZioPO6Nuv5oqDpcCZ2tfn94CkhLxdc5OMq5S1emK+pLB2iYeGZniyu5zR3caHxm5vgHNweZx3WHdreZmKrmCSeJmbXq+TX1uEsn1fm7ByaJxhbYSFkWtooJhad717oXuEi39dcYuPkZJ5XleEgGhqn2Z0n45mdJWvxWltbmtxcW59hX1/f3pxdouVoKekhYGRgICat4uilomQgYN/crpvscGwhLOyqrnPe9GWeLexsM+FosBsdGrTbdNwc3Z8ybzC0L+/2HBxcXZ9en6NkZWUkY6bkIh/d3iBgnF4dXBxbnB3dn19hIGDe3t3f4Z9dIZ7bLSs6n2Ef5ianb+iq5uQmKSNjIiDk5mEi4KFgYCHfI6Hh4CXqau5u6+lnp+fnKKfopV103qAfHRwaMCyy4FnlXi2rXiOnKVvrGJ9cWl4ZXK2gpeRl6aCfJ9wlmCgb3qRlXh+oHuMom98act7fn+InoR8jrNvZW9ne7B8ZqV9tYaEf5CQdNOAzL+zuqup7ujAc5Cc4M/NgrSfiKCupo2elJWDyICAgIrpy5TVlcey1Krg4YWG672ztYPQs6XCwpeMppuNl7O44Myjwrqjx+C/26Wh2YfXxLqCr56En6CutJa1va+72OuC3amMmr37z3N8eeR0eXl6daukr+/Jf5V5f2rLzsaIcnjIxdV2v4WwnpaDkK+074qhr92Kx4CS/Ym9kJTcqIDc9YfFjIWhoff5f4GGwqqggc6SgXFxfNCKjop81cPIoNV+dN7vf+DX3NXf69XQxsHAv7DA33l4fo+ik5HJvpaV45+h24X9o7CK65OTvZypupyEfdqZ08nR+c/W5tHi3pGWycqtoI3qstCf4KuVtI+Eq5LG1NDZmOqnl/yfx6DDnICX/dnBs9rlgP3iwaPvg4q71cvkiZ/C0OGinoum7o6aou6V5/GQr4za6uC8prznyXs+W5zBkXaAdql9nLKQfoxZpal5hrLJnLepkKGttGXYboeLdpOwtM6icKnAi6V6o87SmPvplPqIpODItrOPjpGchoN3a8fPp5/LaauywWtmZ4B1mouEfJWbq9SMm8/9mq7Sio+BuoHShHqFg8Z+1srskMyZgu6SvdTqh5S7jPDkwJDmoa6opZWD9rKpmueLooeLhpaJi5+bisyEjrTYhLO46KCg0YfKjoWwmLGPgcTUqsz8iMLlinCE1vaiioiDp8717ejGpMSyq4yBl76KuXmGjIDmi4Jda4p0fI+QYmhuX4GXfH6ge4iRmnXdsKvTrrfXpbGt3c3MrbOMg22TuMCgpJ6CqI3DpcCQwaW8ZGyRk6NzhNB32ryf5b6wcaWhjqPCf2VxsoitnKWI4d7C2rTxjqWXsciyyJaahMfF9NiKmLSwmInJ1qmW1IBziJh2r7S/x4B2WohCSkhFb3N4UEiVgoNZWEVHQ2GRjX6zvaxmWkI8Qzg1RGJVMUNBT19WbDhcR1VRMFtdOjIwVFROYmM8Kkw0PFRDW0ZDdGE5UEJLd2dhaVtDSlxVWD08SzMvOkg9aEpjoIthdKvW+IWJh4OMj4mdqJuenJiQlKu0uLe2opObmYC3z4KOhX6Ed3t2abBqz/bNjKqlnKCxbsiYgdrZ1eKBla5gZF65YLhiZGZqs6iuu7KyxGVnZ2pua254fH99eHiEfnhwaGlvcmRjZmNjX2JnZGhoamhoZmdkanNtZXBqYKGn/n5+fI+MjqiPlomDhI9+eHZ1gYR3e3Z3dHJ1a3h1doCCjo2WnY2Ef39/fIKEhoJpwGxuZV1aVJ2Tn2JNZ1mIgkQ4QDwvZj9YSlBcS1mOY3Jvd39nY4JbeEt9Wmd2d2Jne2Z0gVllW69xeIWLmH55gZlZUFpVX4pOT3NGaUo3NDo6KlU7W1ZHRUg9X11fQ05NbGRuTWRNSlhhZko/NFM8YoBJP0+LgGJ1V2d3eVh0a0I/alZOWjdUVWBbSjAyPj8+Ojo/U1E9UVc9SFViXk1GWDpgXFg3OUE0PmJ5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c2qAd4S6rrThys+foreu1av8vPK7gtGxupe5c77DkJF9l5+6d3ibi7/e24WlpKCupIHZsfeTkY+hi5LskvX7m+WoufrEjNqbsLXK8tPF5/Tct6a4hY6z0a2g0uCtnPrL17eZwuyEhu7Nj/fMdm5ucGpuZnt6baOdkZSdpY+ej11cZKeA1+1bYJmdr3Jy6vDDrZDS7OSz6rOBptCAlqrFnZjrmMrO1LuVlLCGvoKtiodyhH3m5s/zfvF+1XWPxI1uepGipJKueFxoY2xyha6Gu42sdcWsmtSl07Dfl82ugHWTu8h4l3p5vFxhjHGTldGseMHMg7zLs4u086aTnIKEkaWn7IaAppGP7Y6kwq36joSbiaer2am0+s+/hqG1656+tqiUtoSWkeuaiKmll46ty4TGidTP44ryzO7D7YfWvd/ixOPLhuiwxpig2/yQ7/yOr4yfovHn7NN0v4fEgbO9jMfMqNeM0sqvyHF6iZ3Cx3eRraDBta3BtfnjociKtJWO6Z2ig8KAa4vM0HKqbXyUh2ukhb2vj41xiHvKer+9enR2vG2OY2p9boBqgKirmWFuc4eSfL20XpuVi3trd4GMdmOnd4F9UFCNi4aAbZBbZJR3i4p/YYaUgnGKVpyVVpRbWqNiYbijwnmhbnBvtJR6c3BudG9sa2pubW6AdH2JhnuYkYd8c3qAhI6diX5/fnaIoIF0w7ir26q6jpOyq7y2sLLJ04KQo7vL0bq7xb6yv7OrnZyup7W7xc5td3h6eXqFnqq3raGakoSFfHp3b25zdnt5eXt1d3p6gYKCfHFsxsq+t5GckJDv0cDEf6bDcXh31c2NlJajrKWKl6yXlYeLmJOikpOPi4GAlpGgrqynwbynotGyoZR7cnRxeYuDdnVmcXl0goiBc2aShKhcm61vd1erc4BtcpFvjHV9YnRpbm2Yi4yEipmKp4mNdXd1fp/ApMu5zZ60w7WjtKhieGWTeXJ2cZecfbDIkXCVermdqqV5qpWNe7F8n8TTiHejl6mok46rssefsaWAi/WV6NaA8oaQ96OAhLfe5pyUybbPu93ikv6boqyFnZa4vbWYhYmNlbnf18a9gMK+vNnLzePrjaGng4GImaS1obbL2OyxteXMxqzf0svZ2np1se7B/sWtu5nDtJuliXWHccZwynhwfs6hhd+Kg4euxrWfsMqGuL7Y/r6Fz4Gf2/2A1K3G0L2vh7Pr8/qLf+R8xaPS3ZuwqL2Id4+BhoHhwXy60Xrt1sLFxsbI2NfM1cK0ubvZ+Ot7kZ6bjsKQv5+5zIOl0pzD4uDA0ZDCoL++0HnNrYuEcd++lobogPX6iofrpsan2KWR6M7Cnp+Lq825k8WNxoDz4o6M+5zEu6uBhYCAjZve4ND04ffHxO2+5rLdxfq+iObEz6XXgeX9tsSks8DciZGxntPd1oOoi5ysjYKTZcd+cnZ6dXTser2JZ9B+eJ2Rd7Z+koSUuKqAkrm0pJuhdoGqyZ52lL+omvPH1q6Oq96Ba/Dbrva9lIODhIGJfpKWgryzrLG4wKu9r3NyesiAvONrcrK2y4B9/f6rtJPb5O2/1aF8pMVzjqi2e33Nj8m9rr6Wgrea2pbLoauDmojm4Of2g/mD8o+w7rajr77I5cXPrqCpmqOlstem1K/Qlv/Bsvu+68nonuG5ioOk1t2BqIiO5G9xroGupPK5fru+drLEtYW08JqHjXh7iZua2m6Ag4NrtHOBi3W+X1ZNT155kYCAoI6Aeoyo5pW/saaXrn6DgtyUjKGRf2+DsHGUaaaXtW/a2NeetGeonJifjqaXcvyvx6Ke4+CF9euH1KWfl8y9382Bupjbk87MkcvSpd6N5sO/54GIk5Xd1Y2uvbXWw77JsNXGeryFmYhz0I+NbqOAM2eEg1NbS1pvQT95Y4qLY1tJU1iqZJ99T2RWZUNXODxFO1hQWGllYTlAP05SSYZ7QUo1Jy8nI1BVb1pcVG9iMzhUJiRCRkw7QG9GOkxfQWBqXkxgMUNPLU0tNExFRKiox3mTY2RktKmalJGNlI2Jh4aMhoWhkp6qp5StpqCVi5SAnqe2qqCkoZmnsJaV+ezS+qWwjZChm93k2tbm74iQmamysquqsq2osqmjlZOgnKWrsLpia2xtbWxygoiOiYODgHV2bWlrZGNnaGtpaWhlZmdnamtqZl9dsbGqqImXkZD75tvUeJSsZWprvLiDhYaQlo97hJOHgnd7h4CGenp5d3KAfniCj4iJnpOBgayUhH9sZ2ZnaHJrYV9VX2ZgZnBmV0tqP2M1VWVJV0J/V2BTWXBNZ1thTF5VV1h6c3NucntshWh1ZGNgZ4ymkbKmuJGhpZOFj4hOXktxS1xOSVpdOEB0QTVKPVFLUj4pNCtRV3U8UXCCU1FnYE9Q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ieR9geCrl6aC6qJ5oHSlgpirmZKQoIbSysiUiKyLn67azOJ0wa7JnZFvuaqSgJG0uMCVlZO9vKWldtLBgru03NeAgHbCnLeFoX2UcYqy8X17zrOi1Pzvgf6UkZaEm8ugo7CD0p7yluCBtaGUnsyxlcC7qMCkoJOjiMP+wI+ippO1vofH+szegIDm4fKSmIL0mOinopv6iIJ9eXdpdmR2a15aZm5orJ2YklhTWVeLgLWKam+OiH+TuNSP5bGO44fwoIiWwPXfhYWIgZ+ThamnrdeVtJa8w911efKWsovwq5Go4/m/x9HBdnmTv6NdjnqXmX9XeFtSl09gdb17aneTeWpte3ZqqLRqj+W3rI67joq7mXhkzLvvyHG4ctLri7nRx8e5q/uOytPKwq+UydblgOTJgq2QuqGQgPqUhZOAq4z4nbSf+Me2xPnBt9bP5OeZl4HHhoTnoq3fosCi8YbT1dbIk6Hu48m+6rjDvs+jnpbb3q2xtqin/eDSq6THh6zA3ZfikIKCloe2ysOblIqzuZC7taS+xqas2cTyebe6iZCDuoyE06yHlPSFxLGVtpnMgJ2cm46Rk2WZhH/Qm3turrpvnpSpprJuooxmsW+JX2VyZJ92nIdkqbdsgXt2hnKChW6Ua4Z4fFiYn2ZUgn2Nc4WJj4CKd4BbXoRldFhrbV1taZ+Ijllys6CigoKPa6uxqY+Lg3eIlIeCkOCiq5iMi46Nj6SQkJ+XioSLmJ+jl4B1gMhrbnRzdmxpbmSik7zUksPLeHhzxIy6voahubK9ycDCx8VsasKxyri+vLfBtsnEz2p2e3Z9eHJ/hIyJkYiIhYR9acxsbHBucnd/fHp5dnZ9gH1+e21qwL+0o3LUe5+wuZq70m5va89weXh0mJOxbtOhqsjOgpmWj5iWmI2AiYuJgJuhr5+lpb7Jqp6lqqaZgXxyb3p6jIOBf397gHFvc318gnuCgFtbgZ9he16wZWuHc25ibId2X25hamuDdnx9nJZ5br22Yr3Kx2zFr4WUtWSSeXyXnK64g8e4bbW5d+yLaJGd05G5k466iYKMqIOF147OwK/w9Yz1xZT8i9i7u4afgKObkOzx9Ouf69fmzvLJ/a6hh8OUpqzCwc+EmKmWhoahr66di5+UwMDwgduijuC4oqrG0avq78Dt1Lydj46exaqwub/KydCxpYLxlJiJn+bC99fz5cqYna2reL+ww+XMtI5u1c5q1Hzc5H7Thr6Sn6Cmtbrn1vbd0M7t1tC4kcXpgPn6lf2RprjH4tjg0rCv5fburtaIguK/ynnm23uNg+nc6LqatoOBc8S5y9DRydfT3t3Jz+WJnYT62Lzl673inbeS3cOXq4GWh6zHmLiCnKmhhbOiivCAg+u4prGL/6iBt4TCk6qxqZ6kv5jv2d+umMSNmqnr5f9947/3sqaO68isgKfV19KSmarZysPVhefThre5+vaJioTq2+Kiw5LDpJmy/qKu37Kp4PLjh/WXlpaDnKuKf4dupIXAdLZQeH5uZ4GRgoyTfnx/aE+QXYy1lIKJm4eal4Cx2JzRgXa/2uuHj3bWfs+bl5/mfI6Qjo58iHiOgnRud4J/xL2+smxmbGilgLKZe4KknJKnyeGZ0LWM6HvkpHiHr//9gnyEg4J1c56ffK1wqJi5x/WEgv2nx5rdkZGh1P7E093Wi56z+/KOtKjCwbeHq4+B6oCbps69qL7KkYaDk5KHtcuCpvvQw6HOq5bRu5J27cv/4YDSiO31irHOuL+loO2Dxsy4saSHu8y9gLy3an9tmG9eWplgU1xab2GugYeBtpd9o9WxrMrF196JgXTDdH7WnofLnram01uEbH2riKzuwa+cmYeBnLSWhY7Y47G5yLmY7eDgx9Hvlqeuw52jin2QmouyxsuYgZG0tXrGw7nd3MSjz+D9jMzIhImPvZFvvZuEoPyEx7OKln+kgGJocmJsaU1tX0qaeVVOaVJHaX2Qg41SZFNDdkdcOjxCPW5YcVs4ZHRISklFUERaZ2RZISodJk91b0lRT09mXV1sYzhOUU45N1BLUiMtMT9IPHNbYz1RallxXF5nU6W0nH16c2h1fXNzf8+uu7Gtrq2tsr2utsK2q6ixvruzp5eLgO6Ch5aVmIqGjoLQue3ykrW8a2lmr4bM04WZr6attqyrs65eXa2guKisqqespLKssltlbGZpZmNtcnl0dXNycnBtXLlgX2RgZWhubGtoaGdpamlqaF5cp6CjmG/mfJOeqZCgtFxbWLNka2tojoeZXrqMk6u5eImHgIh/gntydnZ2gISFj4GFhZWkkoaMlpCGcG1lYWhlcW5saGxoaV9dW2FdXElTVz9AW3JHX0SDTlVqUk9IV21eTVdLWFtsY2ZmenlgXKOYV6i2slurk3CF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+v2JgO/w7peXe8S7zcm3v726xdXR742BsXmrw4W4eKmknZvOnqLh4LC4w+aHq+XVhvC3v6qB239xcKybnM+G0sN1e6yEfpZ4pZGD54eVnnp8n3+XvMHH0652t6nBj5SFkqKAmLHGlvGFmo+3vZqiuK6vtee/2JrEz6J+frmInYVqfaWjvGS/mqHDgOyLt5aO8omejoCVrYu26p2M+PrM05204vHNioqC4aHnzdLO/8uNmoCEjLWhkMTDr8m3/MDTrs3ly4aWnIibjfbfhqN7c2+ndmK6Z4N9dGtxX1lel5l9dHeAnIhrdY53eYB8d+i+4taRn/e5t6aiuriVhf+elKf23crSptHduL6o9oqvzbCdtPD1gcHM9J/fxHp4fIl2rYx5foiCa3CXk6+lg1d4ZJ6BgX+RhZCzzbq9q4l/yJSfc6rRgLKFprN1yt+A297EjNCQ4sftqoDlpPLF9dHBkpri+u2A9JXJs4i26KyNn++IxZKItqey4pTLzcHFy6rCxOb57/SZz4WQfObWscOOmY2HkOGwxKK0nKV5xJyvhIWKgI2Rm+DQ25y9zHi6vGp+sL62esqjlamkjvCbkrb3rMerkbre/8d+2JGzpNrzk97O0pnSzqyWorv7v9nSfeOEu43DlLOAzqXzu45tnYBw2rN4mr55dc5+zMt3j8mTmHiXebiOlKRgaYGRuWq9ooV0ZXJuflqHd5twgIKegJ5dcHdprXmva499boKJdHVdmmCMXnxanJOHe4ZYSXuYa5uaZLjUesN3f4WLiIp2ioOHnpWLjYeUjYqMfN6ykYKCkH6EfYBycWyAc2doc3FwtLWujougy/WUkZ24wHbOt8jW0cKzqszGy8jYxreq1nFzamtqzmpq0dPMxM1sbM5zfoaNj4+mlYN6atHSa3R2cm5wvmlxcHdwc3uBfXZz09TOuK6lo6i2wc3Md3t7b3LHl7GkiomHlqGipYuRk4KHkpB+hoCNj4GCioSAj42Eo622w7WNqby9ppuKe9B53Xxwc3l6g4d8a25/dod3i52Qp7Gjn2R8f7RzXWpqbqt7ZGWzYLq9am9wjo2Ucmi3oKG8trB2nqOwZpOGlaSRfYasqYKAebKek7N+kHC6ms101ZqTkH19573LuJKKcXzc15H7qdmY8MOZz5eOj5KAla6tkYeTl+j1oNOijMbR0NywjIOUrZ63yJuOnqGhgZ28qaeUr8DT+YmM3rK0sa+sgsHKuN/BnMSlx6XOsbWnuaemrLHAu6Kyxdb+3IaMiNX1gpKqlLa+0mvP24nBb3XIzLh7enF3duSVbniNeIScnbjHwvb47+CY5LKqt9fC+7uAhbWcup6pr4Ht89Xiz66v34P073vbeMfmoOHU8vWB3+qBctHN3ZSYfszB5t7Axr6+ytrV9o6S2JDE2oTAgr61uLHbraLv7sDCy/yEgaKbXKaYwayI54J0dLWipuyQ4dWEhLKViqSGuKuR8YucromFsoKWwMna4biK3dn3oqmUobWAqMXik+OIsqDI5LHMzMPAwO/X86zW4r+bisWXuKOHiait+ILoq5y/fOmDjHeH9YOBfnV8k3GCtHdowLGOnnyKhHu5bnVOnGqko5Osq5GCjn+EiaGkiaKeoaGZlanCpq/LzXmLjniLgOe/f5GLg36lj3TbfKCWjYKMdGxzt7aVi4mAm5V9iaOGhJCIfe6lxMeFjbmYfoSPpLOOc+iUd3n0y8LAmLX0yMub6H6m1aRvudLxfru/34Pn14mWkpiP39Wqsre+opvFwPzu2Ia+iOLPxsLTxcjt4Mzdv6GR3qu/hMX0itOvxNWL6/aM9PHVluui9sXfnHTLmt2947q7jI7H4c6AwHigi1uIumleYqtXZl5eeniEoXOqmomjvKK0t+Dt6OOQ0n+WgODRobaFmX15b5N6iJaDho2B2457Z196YIZxi8ynzJzq+InO5YqftfHciNLKj4qEgemRj5jlra1/hZmj6MuD5qXGs+znj/jd25TV2rGVl6XVoMjKgtdkinOqf62ATT1ocGZPfFdTXzhLSlM/UZlkpaVcaotbW0xDNoJaX2c9UV5pgEWGfWVPRUVHTzxsbI1CNC1XSl9OSUUgR06PW2hOLCBLJEVDW01tNjcxZWdcXlg9NVRePXaBT5vbgLBpcnV3c3VkcnF1jIN5enaAfHp7bsenl5GZo5ujmZeIhYKAjYGElZKQ4ubgsK7J6vyQjJOrtGq5pLPCv7GknLaztbK9tKWdvWJhV1hbtl5durqyrLNdXLNja3B1eXiCeW9pXr/AYGZpaGRjqFtkY2pkZWhqZ2Vju7u5qaGbm52iqbCwZGdpXl+0jp6WgYKAio6SnH6Hint9iYV0eXR8fnFze3OAfHp0goSMl5p8kJyfkYt7br5nvmheY2dn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aKrNpoiaqrikuX2Z4uqAh43Dn5Wpj8qZhe/x9u3UgIKLhNyM38OxlK+AoZq2ntmsz6m3v8/i2tnXtsLJ28m3/KGnjIeP2oTWjfaVr6CWhOyMoozIrcWxtcLLz8fPeMB0tpanoant86y1qrnYpr7HyoCtj42Rs9ji3OOelYzNgYaCetXaopPR3bPRzpx4iZd5loTL3J6MmIB6gLG10tPlerbXdLjFfHuB0aOAqYek13OwjdF40raCmax0ePmGo4OWnbuxjKOdnaPCorGkrXOceefzyOKynoWAj6XT5piwrvaxs+SP8Irzz8ahmpmHiYbQyv2B2d/MzLasutnPqbGWsdy6oq+w777fvMjNscDzeZS72aiixMWnh3DjpKKEdG5rfGZhW6hWWpyTkqCAg5Z+dXCJiYmrx6Xl+bn6t8K044+vzInv57mqtau5qoi968LD4ezX1dSa7bS1jp2ow4rcg/Gqs9hUzs+At2N9i3JtjYFyxGRoVqqmppVwd3VskIy5eIBitILQjXm2y6DukHB/rJhtc8m3m7zIyo+J7Ib+ubOGhNDgtsHD06ezyIuAgsiZqreaqfGwoICngceMtpvBibnYjqX19cOgn8rp76rDkpR/i4aw7uytkc2i2ZS2jbKZov29kbTKp5KEvOr/t7qHpsGvweHNqtHW0eCPlcLCnuyI9qqg5ryBt4qexICewNWgib6qzbyrhIN6zYW7mbL3vJyevYzX2ZOJ4oqjstWAkYi02rJzhZVQ07R2kYyAd6WMct2FwVyDi8p7gI99oK6us75/pKyFksFiZF5aYYJ7vHqaUGpuWIRcWZGPYpGVd2+CW2lvlJ56hn99VmKUbnSOg4KIXnaol5a3enqHxXF0fnVyenV9dM6DiYGQm6KdlY193dK6uLSJvtN2bGtt1MiAv9Nwem27rL2hkI2JiZOHtYWCpbZ3xMPRw9fFwL+yxMvS1s7MaXF9eXOwqsjU03RydHmCfIF/eX6JjZeqkpqRfn5vw73Fw8LCx9DVbnF3eX14dHN2bGvMwLiwzm1tbnR1cXnPb8KnuMG4pKmpoZmYoKJ+kZ6NjYd1ioKDiHZ+foWAma64Z2Vuyraimayln6CIf39y13l2foWIgHtx29lxgXh7gXaFjl+SVWRwcIGdlZ+CiXe5qrZre3Vua4mFfGlvhnJwbXVxc61oaGN2bnSAb2O5la2bsIN+hM9iXmt3t4bGxYCYktV3e4nH+paQaYHRgJB6jvaAzKzdhY6gjviSiYGAtpGKho+kwK+wmYjulpDlk6ijlu2Az727/cigvKaejKaywbC3ztPUuJXCnMXUjMDB76OdgY+LiNrLu5Ovy9DUwMqvvsHGx76+wsO4ydrAoL7yp7ayt8ZtcrXZsIGZrr2ovX+VxctweojFnIqWeLiSfvf47P31hIKWj/Wb/drRsdeAvqzFtuy+2MXD2ebx2d3cub7K3Mq076OojoiS34HJj+aNppOEdc+Gn47Ns9fDvc3T6+z8j+qH0ai9tbft/bzGtsPwv8bBvn20pZGNjpqcn5uHmJDWhIaHf9/vtKvp+szu7ZqLl6mHppP08rCSmJGGl7/A3N72iMX3h+Lkj4+P9bOAuZ+n54XLleGB4sactLiAgv+ExqKqq97kocW8sb7Ppp+cu5rcmfXfzOGTdYB7hpeTw5aflcWZirpzu3a5pKeHcW9tcHCCi8talZCwjYSUns26kJuJk8CtfYKNt53ApsC5sa7egJW61ZyMs7OlcnnuucCgi4SCmoB3b8toa7SrqqWAdKWQhXuHV5W30arWnXK9o4h1nGiCqnbXzpefon6flH618OvF5ti+uLeP46CHZoSYqWGuf/y7zfOA9+yF44auxJSMpbGi/ZSzivLz5+u8x7203cTnkaSE5JTyn4vN267/qIuu2riIh9fCpsO+x5aT23jeoqB0dLzXr77DzqOuuYGAcrSGn25bZa1yblthWIVvgmmcY5WfbXi32raWmL/e157ToJ2Fj36xxrOXeJ53s2abe5pvdMzCt6mzgGxsjNLRp6dto9/R5PHczPXs8e+LsuTtf+dy3J+Vzqt1lWVvelF7j7irmua/59XNg4iCyIOzmLDzpIWMoYHAvnZtt3OTmtWAMTBEcHg4OV9CXFk2Sjw5VHRpUsFpfzRMT2g2PD1FaHFxeHxbbHhtgJVBPz04QFpfnk9qQkdMMlRGSF5RPG12WlBZN0ZMRmBXZGdbO0ZUPDdQXGVnQUx1dnaLcnyJtmRkaGBdZVplZbhzeW97f4SAe3ZnvrqjoKOD1veOgIKD//CA2PiBjYrq1u7NtbeytL+ox4d/mqJpsbbCtcW1srGquLq/wrq2XmVuaWObm7a+uWRhYmZsZGlraGlzd3uBdYF6bW5jqqa2tbGstLrAY2Vpa2xpaGVnXl21rKeesV5eX2RkYWe/YLGZpKmllZiVjoaFio50go6Af35sfHZ5e25ycneAg5GYUktOnaGLhZaPjY96cm5mwGllbHJycGpivr1jbWZnaF9nZkJrOENSUmxyZnhmalqOkJxbZ2FgXW5qZlddbWBfXmVhYItYWFRiXWBoWE+deIh/jWtVU4s7Pjo8fltwZF5SOl4vIjBXaDdnSFdmMFFIS2w2XkhVODxHRoVGSzuAZ0hIVFd6i4WLclN8RkVqXldQQGo+aVdRb2JJUTs7PTw0OTg9Q1FWSDlZSlBnR2VjdmpjUlxdVYxoW1NaeIaPc4t9Y2x3bnyLjW1tendnU2ehoMDC0ueBiMrJmIOt0OK+yImcwshrcofOmYKFc7iNdO7w1uvOg3poUZ5hi36TlamAbXJufrCLsImUmaPFyMzEoLDC3dG18rW9n5af84LGhuyMqI55cs5/lZTpuLSwxdrXe3pHMjYXLilEMipefkJNR0M2L3iPlV1jK0ZCVHp8eniEpKS3hZmRj+3HlH+9wpi5jElbfIZTg2KZkHKDglhOPYrC77yxbti7bJuhinyT6cOAu3V1cyFka4xQlIhqdn9RVK9YUEBGe1xYVnleY3CEXHVfXU1UN3mTeXcyLEFUQUZegGlgUphvamxRhDaBYmlUSzspK0dAMlcfM0BxXytfYmpeaF07SUhLRlNhi0FLbZh8c3PfhpXD15djZ46iZIzbvMC6o5qcvJ2Ui/yChuXX17SAYci2p5qlWbvcoKnJlWesnnppe11zkGG1sW+Re1V+c2CIspuTprWnn52E1ZJgUXGDizh7Ya6MjaFMmpVTd0pSXVlRX1RVnVRfTWVmZnNXW2BXZVduQ05Dlk1ZLypHalqwjkU/RUgmIk9gTWVxdDwpilukSEQ3N2Z2XIWJh2lgZkeARV02PyY0KHdUSSopLGFHYEdFT19kRVZlqKyWm729h15PMj86PzQ6goVDK1dRYENYS1xSOIJrQkY+NSolVmt3aHRFan9ug7GKc4SEfG5GUF1UREk0UTs/dWxHSTFZbEVKVFE1K0dWYVZkWEs8YT1UT1FYa15IUkFOVVY+UjxnUEkJfX19fHx9fH1+hn2EfAd7fHx+fX18j32Gfgt9e3x8fn59fn1+foh9CX5+fn19fXx9fIx9h36JfwF+in+GfoJ9hH6EfYN+i32EfgF/j36Ff4V+lH+Jfot/hX6HfwJ+f59+g3+MfgF9iH6CfYl+AX2EfoR9Bn5+fn19fZF+AX2Jfoh9AXyGfRl8fHx7fHx9fX18e3x7e3t8fXx7e3p7enp6hHsBeo97gnyFewF6hnuUfIl7mnqFewN8fHuIegR7enl5iXqCe4V6hHsEent7e4V6gnuSeoV7BXp6eXp5hXoEeXp6eod5Bnp6e3x8fYV8gnuGfAl7enp7e3x8fH2EfgR9fHx7hHwBe4h6h3uCeoZ7hXoJe3x6e3p6e3t7hnoFfHp6enuFegZ7e3p7e3yQewF8hHuGfIJ7h3wDfXx9jHwBfYd8gnuSfIZ9BHx7enyMegN5enqEeQF8hXkWfHl5enp6fHx7e3x8fHt7e3x7e3x7e4R8AXuIegR7enp7hHoDfHt7hHoFe3p6e3qIewF6jnsNfHx8e3x8fX18fHx7e4R8gn2GfAV9fXx9fIR9Bnx8fHt7e4R8An18hX0BfIl9Anx9hHyIewF8hX0Cfn2FfAh9fH18fXx9fYV8hH2EfAJ9fIp7hHwDfXx9hXwGfXx9fX1+hX2EfAF7iXyCfYV8B319fH19fHwCAgQAgNbXxcHc0YH24p6incON4cuqlN+dgd3ah+XWnNOZmOyBj6aW/r/ftLOgwILyo9+H7LKEua2CysDp4Z671+/NwsXn+Y+ekLfQ7MKbqIjag6f38I6Xu+6D+cXXj9bWnZ6Ykpqck++gnsHvh4eOjYLui5+B1t7Z4bm9w8ae686yssKLgKyVkM60qJaFen6NkJuelomUwprPjYqUkojm1trg9O7n1eXV3vHv176tmbvW/oWAgYaTlqSV8ZCrv9njxZqckYSH3tz6+u/x7PeFjpCPl5GSk5GPj4KG/oCGho2H24uakpeOiIyA59Lx8oHeyMvX39G4r6qquLCSrI+4kpGOlbK4gODuhI+Tmvnd58e5ysq3rbe0mZ+cl5illfSYn5CdiJKojZeuytPix8XXvsjrsbv0ja6tjYWJlbSCjamWv6eFi4eJn6KN04KpnpeRnYODgc+PqK+K492Fw/WNivHsjZnI5aDyj5Oa4/j5vJ6X2qiQ58ub1dbM4ojHquCAgeWBi3iAgIyLqISXoa3lup2N0cdtzI6Nxn/QeI55nn2gv/DnkK6rq6aVl7Cho6qKqH6KrH7Yw5/l3+R9xbOgs7+FfIuGpbGcmaimuK/BtK6mnpeZo4GQvoF+n67NxIJ7rq79h57HqbvFs++A9qij2rfE1qqcpOuN3NjOxcmI1XmDgrfd26dxgM7P1sK2oKW72eTN2NrVzMHIu7nA0Nh5iaN80eXtuP+ko5efipyKi5eQgcXBx7HD05Wpiq3Pk8zBsKi3lLzNz4GHy4PU88n41tK92p6Xoam6hbGAhJWPhN+e1rTc45CAh6m01XOAeG3o5ouAl4ba0Nvkob3DcpeiicF4epSE35d0gKixj4jOgZGMh4V5wpWak4rWhJ9reMGgsbpjXba26uj26Oehdb2FeMl9iebk8ZCJ5o2JjI7bzr2g0fjG3Kmcj4Ki3pvrpPfgmKm/ucDqrZ6GyJr+mqScnaLMwt790Znapbjb1piq2+K0j6e05L7qtJfsb3l1amRjW1iiqqRihZONgNzI03d8lN6atMt/tKSzrZqj35iw37zK65zE1L+Umc3N45Gct5SJ6u3ikIL+2q78rZ+5gKHTi9y3fn7Fal1eYnR3yG1+Z451eL2UwHCzxmR4Xq9ot4FtdYCAbaamwtx5uoqbur2Z0b3AtbWM4/CO7duUsr3z9cafrZmZ9tW595rsgIimtp2To4OdibWVq7mxuJGxmY3P15uJoq7tycmDk46OqrLwgaLXsKWGpaqfmuiOhYOn+/Tpg5Tz+JeywKWLt7Xzp4/EosnGyMSklMKev53Cf7WzzcaT4a3fwt/f0+fJs9fKpXF+0NTa5sXBv33pr9yE1ay1qLmhzdeotoD9laeNgNLp2tDAh2Cihn2Dgn+I1cWkisCLa56ycMekhqqbj8BjcId3x5e8lY5seVmxfpFcqoVdg5FjjZKmnXSImZCIenqAnF9rYXmPqI94hGmUWGiopmBsjJ1dv5umeLW6kY6GhoiIhOGRjazTdnV7eW/PeIdvtb+7w6KorrGP4c3Bx82EgJyHiM7Ew6uZjZGjpK2srZ6p0pKocnd9fHPHu7/C1M3HucW0vMvMu6abjKq62m5pa255eYJ4z3eIlqiym3h9eG9wwL7U1czNytJvdnd3fnl5eHd1dm1v0mpvcHVtsnN8d310cXRrxLLKzm65pqiyt6uZk4+Qm5d8kIK8hYR+gZScgLbBbXNwdsS4xaWbqaqak5uUgYWBe32HfdZ9hHd/dHmMdn6LoKaqj5KeipGugomaYHZ5YmNpcYhkcoNzjHtmaGpteXpsrWSCe3d0dmZnZqJuf39mqKZfmcxucK6oXnCOrICyY4SW2dTmo5J/w5CC+Nqg3drg+JPaxviPj/V7koGHgJiQo4+cpbDIr5qK2dCC96mc3Zj8jK+YuoiwzeDQipWrtry0v8/T1NeuyZKj05f606rj4/iFyK+nw9mahZGXtcWipq24zsvXx8a0p6GjsJ6z35GSsL3ZyYp+uLbyhZ3Orb/Cstt1zpmb4Ly+waWPl+aM4dXb3dSL9oKPkNDz8s2OgObr/t3DssnW6vHl49zezsnFurO90Nl9jaiA4fP2tfeloYqPeot+gomLgdrQ3LrL3LLEn8TzrPDRvLrZocvTxHyGxYHW+bTx+N7C5X92gYGQdLKFhJWOjuem8Mv2+5+PlKe1+YCOgYH5/ZiFmInf1u7yo8HQgKSxmOmOi6ST/KiCgL3cp5ffi6ygkpGI6LivqK74lMaBgNK1xt+MgdK55tTNzuqukPimguWFgd/m5Yd9zX1jbmKkqaOLrLWcrJGHe2mMpn7EcaOadXSDm5TXkXZusYTebYGHeZCuq8vGlniyn6nUzJqs3OKYdqKd5ZXYnpb/hJSQgXp3bWi/x79thqGDgM6/rYCGe4OeuMuBs3WDkGlxhGJsiKC31pm2vaJkeLa65I+Ws5d9xMfPg3nw0JLSj6zGT5zghufVra/0iY6OkYaH9I6xjK6hvv6/7ov294W5mOeF2JuDi6CTgc3E3fqOzKzB+/7F/tDPxs2P+eGP89SFhqrPvqWOmYmY9de37pjdgG2EqIRobFNnboxziHl8iHaIbF+anXdne5/Ytrp2gpOSwqr2jqbJrYpiopl5cLFtenN5lIWnkZPd8HyeopiHs6rXmZrnsdHY1Ma0p9SovrDbiq6qvbmO2ZvIoqmcoZKNjqmTpYCR2Pj6+Lu9tIDZqM55woyCfoOGpq2TpWfIhJ6DgFljXlt+dSphbzYvN2I4VlFcXpBuRlBiPIpeQE1DT4RFSFNOkG2SgW9JSTd2Wlk8emJZaDc0T1BhbFJGYmhcWFdJZD1HPk9hcnpueVhjOVBcXkZTcW9Dl3qEbJ2ojYZ8fHt6ed6Efp67aWpsaWGxZG9dm6aiqpaboKOF49zd7eiDgJSBgt7o9NrEtLfKy9DO2cbT+pGPZGxwc2u4qrS2xL+6rbanrbq7sJ+SiaCtwWFcXV9oZ2pmt2VvdYCIgGRsa2Nksa29wru9ub9jZ2hpbmlqaWdlZmFivVpgYGNcl2JoZWljY2RfrJuxt2Gmjo6ZnZSHgoCChoVzgHrKeHl0dIGHgJuiWllTWJmWpY2IlJaHf396aWpqamlzb8NtbmdvZGhzaG5zgIJ+Z3F5aG2CZWZsSFVbS1FZYHFYY2tgcWZYV1peZGZbmVZrZ2NgYFZZV4xdaWBTioxLfI1UR4l1QVtkckOEQDhAV1RPRE40Wk9GTz48ZnRjYjROR105MXBDRURPgFVQZUZXYW6WeW1oiZNHgFxdbEdsSFJFTztUY2RVRD1EQkBARk1UVlM7XERKWkh+g3Gqqp1doIJyeINfaWBXZXJvX25pcGpwfHdmamhkYltuooR+tcjy14uGqqv9lbLvx8rJud9xwoeZ8sCzqJWGlOaG4MrHvq5mpFNZV3ih1aVxgMuQhYeff4KXxdWotLG4sqyqpJ+zytiDmbyJy+rswf2VmIaQfIF3fH6HfrzHwMTQ0zk5MSw4Kio4NjowLzM6alNISDZ0XoiZS1hDb0lRWWhwecCDga6idsel1qXPvoBvZWpop2dZV1qfs2VadWWfg6WyqN3GbHDEh4V7d6SB1LaDgKaTbEZXQUVGQE9SfHZ8cnadXGhDVpNaanE1NnSGmH6QjXtmS2BDRGwyOWJ0p1lcp0hGNT1ld45pfY9gbklZWz5acU2CR0BIOD9RdGlhYDpHjkOMRDRVNU6Aj4xvYEmCkZrMw5Gt3Ol+Upd5dXuEZo7Sm62voZaUh4Ht+O+AjcqAgKnXoqSofHzCvZpNknFphGRfXlNZeIunvYGUt4NGXIyXs25wiHBiq62teGzWwYTBhoOGKWeraa2Nb3KVS0hOU1VZnldTUllTVWRBazNiZzVLSVo5YD08PkhFMDM+TVNFaklQYGQ5QEJeUU5SblYtdHNKV01xdWFDW1NQp51ueGV7gEdXSDkgNCkvJU4+PEBLVVZnTDxYZVZCW3+yo6pmakA6Oz1tQklSSEpJQzxEPj40LT9jg2NVS0xnQxo/RDBDYGd9bluTfpiSmod4aohuX15lOE0+OS82ZlF3WGRZbHFgSmdVOCUpTl5uinFofEJ/TlcyfWRRVVNOW22BTyhLVEFChXyJfYZ8BX19fH18hn2EfoV9B35+fn19fX6FfQF+jX2FfhB9fHx8fX1+fn19fn59fX59jH4BfYR+hX8Efn9/f4l+hX2Efo99gn6Ff5R+iH8Bfot/iH6NfwF+hX8Bfoh/hH4Bf49+AX2IfoR/kn4BfZJ+hH2VfgF9iX4BfYR+CH19fn18fX18hn2EfIJ7hHyGe4R6B3t6enp7e3qOewV6enp7eoR7AXqEe5Z8B3t7e3p6enuceod7BHp6enmHegN5enmKegF7hXoCe3qEewh6enp7enp6e5J6hHuEegF5i3qGeZN8Dnt7enp7e3x8fX19fn59hnyCe4R6hXsBeoR7gnqEe4d6BXt7fHt6hHsGenp7enp6iHuGegR7e3x8hHuCfIp7D3x8e3x8e3t7fHx7fH19fY98AXuIfAF7hXwBe4x8i30GfHt8e3x7iXoWeXl5enp5e3t5enl5enx5eXp7enx8e4Z8h3sFfXx7e3qFexB6enp7e3p6enl6enp9e3p7hXqGewF6h3sLfHt8e3t8e3t7fHuFfIN9hnyCe4Z8En18fX18fH19fXx8fH18fHx7e4R8hX0BfI19hnwFe3t7fHyEfQF8hn0RfHx8fXx9fHx9fX18fHx7e32JfIl7hHwHfX19fHx8e4Z8iH0FfHx8e3uGfAJ9fIR9hXwFfXx9fHwCAgQAgInK6K3y5tOPmZe6gvO4u66+4MC31avFheuauPfYwKmpud+4ppS4xfua4MKLiIGEkJW0laykiIXh+7TdhPbXnNHR1+rpl6TLiorwjrnG+6mtrOaA9cHd243Tos3p4YLoycfRh+WwlsvDg6OhoIz59oSAnNDMytnr8/aIkI2G98+bgNDBuaS3jYOEgqLdjJ62jJimoKiiZ3FreYKFi8GAjI3+8f7+/u3z4+nS5fHfz+L0iIuByYnO24OZ7Pf9i4KK/ejJvbSzvOOIlpaLjIWDhoT/+ObX19jg0PKAg5Dxg4+QlpqWnZqTjKe1qPzp/vHn2salsr3CvKugos+Ot77CzM3ggPD7h6aLkJOplNbX3u/m3NDZ7NqzlZyR+f6Op6mXqqWZoa6uwd3QxMSpm5WX0IWPiY6moOeVlYmnpZSmk4qomISyqtXR+Zafo4GC8+ju0pG6q8eM0s7t3azX+OiNgtWF48CrpaiShJr9+9K4gb7eqIWSjJHxh8Wf6IbWjomKkK+vgNexobaWuOmKiJeV3nSqiXrSqI7Vdo+N25KjlqvDqZqvpZqjq/p3fN2ovbWq2YOf4crlge15p43V7Xh6f52imaOtuqObrbLTwKKZn5qXnZF8knOKhY991LqAyrmAkIeqpsnWssCIs5Oy0OXVr82sx8Cf1dTb2uuBjnqPkIyvqnG1gJGYeXW6nNq3wsTP4uDKr6/usq/DyMTVzb6Xg5eaqc+yqqGRip2lk6eempfiqbqLd7SYn7ZxpLPMx5uDpuWRxNeErJSHiaHaq5exldjAm6meoKDmgu7em4KQgn+Us9CLoKyqroqe6tuBjJOnwJKAmIfFoLng4ISJgYuFmb2dfqqxgHXIpnSvz3HThYvMw2lqr8XLi36w4LONnbCplLu1yojayNbqoc/YtZ7bh5LnmpnjneSXuvjA6oj17OLk/b2ZoYySmsWqiNmVrbfTt4XCn6OVroGH/oaRm7y1/Pv/9ZmLj8byjcjk3Lb94dDr19zA++iBfXlkXF5krFtcjIKB1bPIgJm22Y2Svt+ouq2L94mI2Iam9LS3sqq7zIPFkeCAk4Wu+KSQgYPfyeSbzqnqwKKui+COjKjAzaKnhIZikKVhaNHByL/UtcHVgo58irtnaqhgeYKvrMyvdcKhhXnVtIbkg8e+dq+LoY+Rjseai7uZp6uZuLSaldPb3uzcioaZldvZgMyTs7fsvoOdr5CE/sj3hsmFqIGIjZHcr7734oTvz4GriouporiPwouwvqeluLyizO6a0rrpnLDowOyMkYfg75210Y2FkojViryouqmj5tbOeKS0sreajqSmksvoh/SnzamQ7OV/gIuavdSAvLWP6trRhse34c2sp8St4vSdmHzbgJbe/aHNsptpcn6MU9Cyvaiz2KmZr4ybbMt2m865po6Rp8SplYifoLlqoodhYVtTX2p/cYKJZ2q50JCTXruTYICBgJSYZHeKYVqfbH+KpXZ6daNet5arsnjEkrDEuWm/qKmydMKZis/Ng5uZlIbz9X11irOwr7zLz9N0enhy0rONgMG5sKK/mpCTk6vWgo2ggKq+u7+0cH1wen6AibJtdnbUzdfX18zOxMe4ysq/uMXQcnRusoPT332JxtDWdG5z1sq4raShpMJventzdW9tcW7Vz8C3tbe+s8tqbXa/bHV2eXx6gX12c4yVidHC08i8sqeQl56fmpCGitGCnKGhqam1gMHIa39rb3WHd7Sxtb66r6myzbybe4F519x3iIp+jIp/hY6NnK2klpV5bGZri1tkZWV5dqx0cWuDfXF7c2t+cmeFgrGlv3R8fmVjwbK+p26LfpJonJOmp4eRnatiY5ttr4x1cXZza5zc0qWibZvMpX+Nmpj8oNmi+ZjrlXyLnLyvgNerpLGbu++Ei5yT8YDHnpfcrJ7/i6yx9Zysmba2sa/MvqOmouuBivLE3La3/ouh+ODsffGCqpPd9oCEhJqhnrbAyq6muMjo0LWpsaWfoKSVroKalqGM5tSFz7xzioOuqc7ZsLF6lIKo0uzcprSXv76Z2d/r3+iJjoKQpZa4vIDSgKmlh4HBoumyydHb49bY0cb7trG+x8TU1cellaqgrMqiq6iHeo6fhp6UlJvtscKaj9awtMiCvsDOyqeVqveRss6CppSKhKLlvJzAm8aTf6Soq7Xpju/doo6ekIGZvtWSqrGot5Cm+fGJkpiqwpGBkorOocXw9pOZj6GVsNaykcPDgITxyoLE34Xuipzu3IWKxdDQlI3D7squx9fW0Ny/ynfBucLMhNXlurDlcHTBgXmraZ9bpLKkvGK6ssSuuJSHhHqBlaqMWXR0hJe2o3qlh4F9oHJ26XFog5+e1sjuyoF4eqTMeajBt5TQwMDixMS79+qRlJF1b3F5yWpnn5CIxZ2pgGdylJWVi5icuKOJ73huoE9gmG94d4qhtnGvibBZe3eP6pqPcnC8rbmIupzarnR4avWliaDb0dbX0MmJ3O2Age3k7dm2rMnlu8murOWJnNiDtqrNuvbHhdy4oYz61JP/mObgjcGmuaWjqumuor6HoaeEiJRoX47Btb/KhYmZkbCtgJmVq4ino2+BinJnyom1cKJlfF9lYmyHf6XayXi4sn+wgoOdoraVwpW6sXuOfI1rls2Qi36+lqD1qcN3e4bE4myk6ZSDnI7inbuxxrCl1NHgibKmrKyNgqOadpC4bq14jYt71/2Mg5m21NKQrJ2C0bSeWaWRnqyPiZmRsbZqgYLqgERZbE9ylXhOVExKQWFQW2FsqIZ+gmd0X55OZn9wd2d2Ym58hYKEgYlKYlM+PjszQ09nRUYlOi8jX1NHH19jRlZOTGJiQ1NnSEt+W2NofFpZU31Jj3WGkmnDi5qhl1GWh4iTXZyBfNnliJWVjIb4/3ltepiamKOvs7djZ2Zgsp6GgMXFwbXYuLGytcHcfoWRe9Hr6evdiJaBh4eGj6tiama9uMjExr27tbaqurauq7O8ZmllqYfs9YCAp7fFZWFlwLmyp5ycmbJiaGdlZWJiZGK8tq2lp6etprdeXmWkWWNkZmhqcWxlY3mCerimt62jmJWChYmIhn13d8tyhIqLjY2VgJ+jVmBOVVtxaZ2ZoKKejo2RpJd9ZW9mu8ZpdXNrdnZvcnV0gIh7b3BaTk5OaEVMUE5hW45gYFtuZWJlYF5pXVlwbpuPomJpaFhSpJihj11xZXRVgHV+iHFscoFFSFY5bmJLREk6KzBpX2k7KEZILzVFNkNzSF9RhkBaNDtWRUxRgHVURGpVZ3xQVVRYmFV3XlabZlR3R0ZLalViUV9OQz5MP0FKR283N2JKTkA0aEhFeZGqW5tbgne+3GJqeIaBeGhzfHdteGmGgWxfaWdpa3Jed26Qj5Nyv6aCx7xvh47Bu+Lls6t5g3uo0/7dk5aJs72c2dfP2c9fZmBaWHCWlWmugJpyZmuffMifp52mrrGvhYzkmpquu7bK08qWbICoxNebq52EeH+MdJWOhJHjvtB9NEg3MTcaJzJLSTsuQ2g8dX87REVFV1ZaTEktS4NnW3VIXFGyULm2cWtyaneWqp5ibmFYl2Bxg5hraHqJrHRiV1usq8/8zm2NjYBzgdacXqXQgH67hEpgZDZpSz9RUDpAf42EV1dee2pGU3NwXGtqfFWHbXyAWYCBcGZ8O0OIWVZ1RV0yN2tWe0CVXUZugVtZZlJbOnRoPjs1WHOTf0R6QlhKUlBYiDIzQkBsqIB4kWppbI6nao+nn3upjpXNpaKL8dusr6eLhoqT94GAyreEooGggGNrebe1fXJdWY2PwWljlE1Yf11bbX+Ko2Kfm5BDYmZ5yn9xXF6jlp5rl4fSqVxYV9WGWW6rsZeWfYFRg5ZNTqGgqZdpXmNuV1lUVmZHTlc3YFVoaHl7O4FXKSVVTj94MlNSL2JENzU1Lz8+MTxMVlo+SlZWUXpnfJ/PjVVQSWJfgElBQVNNVj1IOi5Bbk6DNnE9Xjs/Lk5QXomliEyKjkI2Ojw7S140Yjg0PVdMRTpONV9HbVRVaGZ0bDw6RkJgbC5PiGNeamCYZol0lYJXh5J2MTZEOVpHTFVjSVd6P28yYkw1blQwMzVIbmk9eWJNXVphMnZaS25qXmJ/Ul4xWTpthnwGfX59fX1+hXwCe3yFfQF8j32Jfg97fH19fn19fHx9fXx8fXyEfYV+hX2EfgF/hX4BfYR+AX+EfgZ/fn5+fX2FfoJ9in6Ef4N+i32EfoV9iH6Df5B+B39/f35+fX2FfoN/iH6Jf4l+BH9/f36Nf49+AX2Jfod/jn6CfZN+AX2GfgF9jn6DfYV+hH2FfoV9g3yIfYh8D318fHx9e3t7ent6enl6eox7Bnp7e3t6eoR7BHp7e3qEe418gn2FfA17fHx7enp7ent6enl5mHqFe6B6hnsDenp7hHoBe5h6gnuNegp5eXl6fHt8fHx9h3wEe3x8e4R8hXuJfAJ7fJF7gnqJe4V6A3t8fIZ7CXp6e3p6e3t7fId7g3qNewF8hHsBfIV7CXx8e3x8fH18fYR8AX2cfAF7iXwFfX5+fn2FfoZ9AXyJehp5enp5eXp6e3t8fHt5eXx8e3t6enp7fHt9fYR8DHt7e3x7e3t8e3t7eoR7D3p6ent7e3p6e3t6eXp7e4Z6BXt6ent7hHqMewF8hnsOfHt8fX18fH18fXx8fXuEfIZ9gnyGfQd8fHt6e3x8h32CfIV9AXyKfYV8A318fIp9EHx8fXx9fH18e3x9fXx8fHuEfAp7e3t9fHt8fHt8hnuEfIN9hXwGfX19fHx8hH0FfHx9fX2KfAZ9fXx8fH2FfAR9fXx7AgIEAICYz+L/nI2D6pmoho+/4+TCvqSTgb7575TyxcO5rcy+ro3o0qqdxI+rp8atlZWQpKTFmZel+oyXsrOAgZTPitu0vr+f85e7gNSooOeh0Y6Yjb7lxNztpdeHjZzh6IGF1djX0+rgzcnTxp2MiaCZxLq6uK6N9q7l6fXq0/GDjfSI4YD+/vfA/b2x1IeRrc3DxPWVooZ+a12xZoSYkaawraafoaCxvNPZvaGUe3LK03mNcMrDt6O7cozR4fbz38bj18mw1/yAjpiL/uXu7fjh8oaGh4yJ+tbt8+vyhomIkJuRlZaUmqKyq6a2vrSe8vbFx7yrrMrQyMLDuL2btr3Ex9nr8IDH+KGzp5Keh9nP3/f9gpKNlJCRyaadsYCMmKWvmqSmrqWuvcnav7W/rpyKj4mblZylh4iBjP+i07yqlKaBmZD6+rCNmaimlOiR9I6E+JH47oyz2ejVioq2udelk6HqvfjMxPOD+tHmqMu58sbP36fHhbagmNzQxK+b54Cl7JiPr4CDrZPF9M+Oo4qP3IaKi56Es5yBqb+EpcJ1tpO4yNvLuMPieqXEbnp/48TbxJRygIHV29PD1NCd1eP5gYKJhoemoaKKiqeqn62gta6zkZKGkpbPmYC6obV9tXh/4M6ox+OB4J6dpY+YntBwdd7Dsa+/nn6g1n71hYPp4NS34JroxoCSq32ok4e9r+HO493RzcbHxofmr6u0wLexpYOYhrKe5LGZpcqao6bPkoDJkIPVibS3b32I0KG2ttClgYbfpKvF6sjbwaKFj8h8qc72zsPCqKiAmZGFv4+Oq8e2pYWol4SlrY+Uj5Hr3Ifdipmep5OE0pawqNvDdHx1amO8xom63YCtk32Cubrm0sONuJytu7uKh4+CdJ+Tmoi3yo2Kwsjsq6OImMTz9sfQv7yOjZyx2smGzoCWxrnPhYy5uvuhjo+tlb+QqbG+tKO3uqDAu4W3k56CiNy0jImpy9LSkdWdr4DHgvKorP+srYm/6Mbe2s+RtO2ab2Vhg7uGlM2Ir9KC+oCL2cuflvmL4OzPhsXSqYLgh7aZnpHM54j5wH6x09b4oKHgxZXnzZHq46abpOGv1ZaOinimv7aSlJRtp4OHoIWZq2FrmJbMYJqSoK7DXVhufXR1wLqqgazPb5iUfrZue6KMkIGImpWRo3iYn4uSqLf4667ttdOiiqjHoeb35NXI3oCdqrq4jYevuof1tu3Ig520jPimuYbGuqrYsKmI15ODoPHpsaK2jaHYwdfQqZ6E6a6SpIDajeitsZT9tbLOhOTK4frmkubH2YWckYyA6oSmm4qv+JLZyYzGoq2K7um28JavuILE0IOGuZHFhIST3tXCktXL68DimIqu5v754c2dkoCV1dj9h25ZrWxzWHGj09e3oYiBbrTbz36woZiTj6Sem37byJaJoW18dIeAbWlpbHCNc3mX4npulZRZUGaSVo5nc3Fgt2RyUZB4capuiWRyZJKtl669iMV4e4a+v2ptsLW2ssO8rKu4r5GEgJGJqJyfnpZ85ZnExs7Fr8NsdcxzvYDY1dCl77622IGFmaynrvaPnYd+cWnJcIuclqaqp6GWmpikqrvEqpmOe3bW3XmJdNjSyrrQeIu/x9fQv6/DvLWgwNlteIB218LMx9LAz3BwcHNw0LTEysPIbW9udX92d3h4fYOPiYaVmpOCxc+mqZ2SkKirpZ+hmJyLnKSjpLC9w4Cmx3+IfnKCcbWqucvManV3e3R2rJGGlnJ5f4qRg4mIkImRm6OwnpKah2xdZmBqb3J5YF1iacZ8mIt+coFneXHFw4Zwd4B+c7pwynFjvnHFu2aEq6+VY1+KgaKJc3GxiLifjKBvyKfQlLWZyZu+0JXJi8WspP3ixb2r/IGO/qSYvICJsZfJ5smUoouL1oyTorKasIGDwOSmxeqEw6LB0Ovo0Nf7jsjyh4eI5Kqt3LqLjIvg39LK6Oek1+T7goGLj4mprbGTi6azsr6r2MXLmJ2TorHtqIjKt8uIvX2E5dCuzN6G6pOSoH+Fic9zeuTIqqG+oH2o6oX0iILl8Pi54ar79oCos4u6m5bHs97d8t/m3Mvi1orsv7ayvbmzq4qlirOg4K6Xpr+OkZPQhHjJlYjgk8vNhYyW7LLKxuezjorYo6G8/cPnvKWHkNuNwN7/pKXNu7OCmKmOw56avdu/sY+Xl4+qrpqXk571643kjZedloaJ1pe2rf3ulYqGhofu/avl94DJqo+Tw8P559Ke0La+zs+NkZeIgqy0wafPz7y8+eLwh4RwdprOybnAqpd4eX2FnZBSkWaAkZulUliQnLaHf3aTiqKJkJJ7eYWYooqxlHmFcZR0f9GkZn+aorWrjcmUnnO2c9+Vme+alHOqzae/vbiCruylfHVtj89vdKuKq8Z6zYBQi5ahlu9f29/HgMGKelyOT3deZ1iQsWW6qXV+jrbLfIOzrHi4rHGmxY6Jhp2IiXmSqYix0eXIwsqm4b+wwcbi8oiHrKfphdPO7dTpkISaqJSY4srVkrj3ha6mjdSDl8Shr5ueq7Olv4unt52cqKDfxH2ZeJdla3KWlt367NvY34CktsG8gW+Xj2nLibyWZHKLa8R+j2KamYy7oJhYm3qEnd7VqKqadIHbyMC6f25wt459on67ZL2foI7Rl4yHXNrF59jlhO7T75CahX+GynKPkYWb4IXLuH7KiYFpwrCQxn2FiHDJ53+OlXHHjnNxrq+qd6KqwZe7hHyLxMuhlbafjYBSX1mEXFxDa0VlQ1Fvsa6ki29uT5O6lF6AeGVVWVlhaV6zvXx0gU9STlNSSENCQ1BtVT8iNSEyHzU1Kj5XL2Y/QkU8dUJFOnVhZpBTY0lVTXKGd4qbecZtbnWemFRViI+RjZmSho2WloZ7eYF4joGHh4Bw3IejpqmkkJtYYatfn4C6tbKV787H5n99ipSOlviLloyFgIH9h56qpa6uqq2anJynqrK8pJuVh4X9+4KQgv/69eb6hZGwtL25raKvqqydtcZiaHBowK24sbuwvWVkY2Rju6Cutq+zX19dY21kZGRoa297dXSDhoN2ra6WloyCfo+Rj4uJhIV7hY2Pi5CWmoCHnF5kW1dtYKCUm6mkVmBia2loon91fmVrcXh9c3l1eHN9f4WQgXh7aU5CTERPVl1eSkdOVqhofHFpYmxaZmGqq3FgZWtrYqdgsmBRoV+on1FpkZJvS0p1ZYx9X1d4VnpnVmQ4YlRcPUJQbEM3PDs5MFlXUY98dHFLXDNOcDY5V4A1T0RygHVISkZQh1haWGBUaUJNbHJQY29GaVNfXmFTQzpXMkJJMDI6WTYoPjY4OFefopaLl52M0tbEcXNuaV1nam1odn5mbHNqbGd2ZWxzgoPDonqdf5ZxwIGQ+uHB3e+X946Vpnx/gtyAieHIpJK6nYO04YnpZHLLvZ2Ouo/hzICanGyNcm2nmseswLaXnZiesYLOmZyenaurq32Kj8mz6ryfobaOhXyigGqwhYHXcVY4Gy9LSDI0OzIrND6IU2NuWU53PjIiOFMpMkOFbF5OPkNAVEJlhGhbYKijgmlZZU5pX4FoXGWnrGa/dIqGbVxQtaTIv72OUnlCODyLjzxy34C2knZdYmp1XVcsMjZYc4xkUVVdRGNIU1FxjVhNZmp9W2NMT2KFmHF6eGdSUUxfalk1VT5SPkVHNykzSXJWX1BNVHFfW15PQU9oXj1CZ0lIOFxSXoOFMzUuYXZwR56Fj2yXZsiJj+yTgl2BpIynpaR1qe25k4uEl/1oaKKcr7ttu4BNZXm/tO9GgpaSaKt6az9oR2NPTExwnleWloNqbJ21am+OjmehkVN1qHh4dXdjYFJwcGuPoaSJkYpsoIGFfneNmFNWa2ygRnp9lZWoTUdQamFWanp3ZnaFLzs8NFY2PkZAOC9ETzo7PyktLi41R1N5bk57VHJNRV9pZqOcg2RCToA5NTtVMzBDXE13UnFOSDVOQH9XW0t1inGPUkJGhlA4NVd8QEVlQUs4OUJVRUgzYEZARjJWLlp1OUk0QkxSMoJukYCHXaiho2R1WkhTc0VWWEhjg11wWi1cSltOlXRTgVVQWy9RTyk5ZEhWR1VHWVRUNFhwhmiPOD1OqF5VR3hcSoV8An1+hX0LfHt7e3x9fX18fHyKfQV8fH19fYt+BH19fXyHfQN8fXyHfQd+fX19fH19iX4BfYV+gn+VfgF9h34Ef39+f4V+hH2GfgF9hn4BfZR+BX19fn5+hX2OfoR/h36Ff4Z+kn+YfoZ/hX6Gf6J+AX2JfoJ9hn4LfX59fn59fn19fn6FfYx8AX2KfAR9fHx7iHoDe3t6jXsBeoZ7B3x7enp7e3uJfAd7fHx8fX19h3wBe4d6g3mYegl7e3p6ent6e3uFegF7iHqCe4l6BHt6e3uZegF7inqDe456B3l6e3x9fHuIfAV7fHx7e4R8A318e418kXsEenp7eoZ7hXoBe4V8B3t7fHt6enqHewZ8fHx7enqQe4V8hnuGfAF9hnyCfZp8AXuJfA59fX59fn1+fn1+fn59fYV+An17hXoDeXt7hHoZe3t9fHt5eXl8enp6e3p8fH18fXx9fH17eoZ7gnqFe4J6inuReoR7Anp7hXqMe4R9hHyDfYV8hn2DfId9Bnx8e3t7fIt9CXx9fX1+fX19fIR9Bnx8fH19foR9gnyFfYR8gn2FfAN9fH2IfAp9e3t7fHt8e3t7hHwCe3yFfQl8fXx8fXx9fX2EfIR9gnyEfQh8fH19fHx8fYl8AXuFfAICBACA3qHihZ3inaDc9dPH6LfcpoWU0v+Awrrpz7SWg72ipZyRzISApIixo5vK4bevlpWL5/6++LCmgOCLz9/ymIGqkpDgjJ682J6w1YXcnNvpvfbA1r64ntvfgYDX29vS7sPOvKSUzqmbqvO3vNLHpr24wMXByLyS2/ywsK3G8vPW5NqA5vL91sLAusbEzrmu+suY2+uRq6SKgbaTiZCIioiIf3V2a2hsdmxshYx5ZoKmx7Koir7Z9Y6jo666wbW1pImBho6SmKWnlpOLnqSZgoKRopeTivvn9vzx8oONlJyWi4mPmaippKShnaCcpZ6dlIXWm7DL4dbVxKepp6S1xcbYycqA45WxrJqYrJ2XjY79ipuckYH2u6KooYiEsb2kuLW8rK+moq2xq6ihk6+znvqG/PCMxKyhqbmXhZ2upZam/4KKvPaHsZuJxKiF2Pf7n+n6ybnYwo6JiIvEwZ2hpJechaLeytemrMuxsr287cPUi+KTsJK6xqOskIyewcL1ir+pjJGAr9CJf6nNoriAhMOOoZmIjcOYpct9wcak25iUkK/grJGQl6Gqoaaw4M6bs722l3KWsdrYvb3BjtPwhIL5g7Skl5Ksj/KLmZ2Wnp+dp5WAhYfSe7uWpKfLzeWOq620sMNknMadnJWFm5zVdHtzfuLCvZjKjqGr+ZeO5dbDydCPxGuAoZx1paqW38zQ5oCC8vLOx+bYspy7t6movL6TmMaMiImNnn+92N/FkKDaqtjk3Md3sZyGesmle42Xs5fWl579k6K5mqCLd+aNwr+npIaFtpayqqGmnJ6Coaq4d9Slp4uioaaun4SKkuma8PCSnoz77qSYqnWGn6TFstiKlo6sqpCAkZet0omB3XV8ydS9itDqe6OA3eqtgrC8sJ+4j6PT1vT8gqyp+YDSvdvm3Yikl8Gk2duZiZrLtrbt4Meq74Cpv6WhjrOtp6GfqsvwrJ2UlKiZlPyLh/qJhcXA0KSS9r/GyYOQw77H1entkf6Asby3ppKEtaOAcof06oXVt9z5vLqAh+S3qqe9zdTUrIi58Zatg5zipf6LvKvehrt++5Liy7G/1M6s/oKz9Lmw0fqLmJD6rcj584V4e5+VgpSSlJ2NmaO8ycixkZK9jpqnX2ype6yhgGrTdaaWr7mZhYTiotCNhpSToLqibdRz5eyPoLmVnIbF5ZWjmO+fn/Pvzn7TzaKAf46xlqi1rvDnkeS49JHDrMSbwqyzkcr4lKivyvHAirGSmrbFhsDi+Y+uy4Wi4rmak9yknMySgqzcvKm60IWyponF54OFsI+RvJuxwY2N8tT508vIyPO9z/mT2ZXP8+uV2LaSneGIouyM0ZXumbv/x8e2ia2L0qLL2K6dsvHZpZqAwpfgdXu2b2mmm6CIn5y5hm6CtOt6up/Cs6aBYZmXr6eUyYB2jmyCeG+UmH2BbGZforpnuIOUaLB8oKWRWFtvW1+UZ3l/kXSEplqaaoWdir+Jkn+Phb65aWiyuby2yqevn42Cxa6pseWfobSrj6GbpKaiqqGCzuOYmJGnysmxv7SAusfQs6SnoqyorZya69KUyNB7j4t4cq2UkJiOj42OiHx/c3BzfHZ1i5GBcYegu6mijLbJ3HyJhIyWmpGQhHFtcXd5e4aGfHpzgYV9bG56hXp3ctXH0NfNymxyeYB8dXB1fIeHhYSBgIJ/h4WDeW6zi5Snta6tn4uMjY6XoqCvpKiAuHaHgHJ2jIF8dXXScIB7dGnLpomOiHZ1kp6KmJWajo+KhY6Sj4uDeo2QdbJaqbJgj3x1eYJ0aHuHfXN+zGVqnMJnhXRpk4JpucjGhLC7nJarlW5sYWeTkHaGdWlwZneqmKtriK6Zk6u4z6G/ftOAq5m3w6mvlI+Wzsbjgbaih4aAm8OLiKrIocCJjd2Os7OkjMacusiGxtWy6qaensDvvKinxNvp2tS+2smjvN7WuoOrt8zTucjYkdfjf3ruhMWnnKe3lPqNnKKiqbOstZWNkJfyis+irbbc3/aZt7jBvdNsqc6Wi4tsiYjaeIF4hefGvp69jJqk6Y+I8uHU39WX4oyAxqaAuqud8tHL6H2C9/XU1PPqvbLJw6ydtbiMmM2OiomMn3681NC0fJPJrt/n4eKL07eYhea2k52cv6W3jJPkrbrCpamUgP6Uucqys4uGqI6+qJ+un5+Ira+8hPCvrJCtpaOujYiNlu+p8PCPi2u/5Kmar3uYrr7Kw/6ourDG0KSAoa2+5pKS9YeL3fDCjNrwgJ+C8/u9lMS2rZu8qsbcz87YbYKEy2Grn7jCv3R8d3+LnZd+d36HlIiRj6KW12+Rm5OPf5ehgn6DlJLBl5F+haCJdupzg8dwepOsvZeQ7au6xoGUx8PN1+Paiex0maOdlId5tJuFdnDJs16asMrEpI6AXYh6laixj5jBqXyyv3NqXF6IW5NTeIuwaah7vHCnhWt9j5mBynKH1pZ/kKFXX1nVnrj6/6+6r8TKrr68p6ec1ejr6tfbnK//qbrbh5/yovHvv4T0k72mybqjl5L8tPmlobKrweXIhfGA+/ufssd8fHd/kWKRbrprlO3p0oTv3LGAjJ6/oJ+gk9CqcsWgwFubdYdwjoR7a6bLiJ6Umdm6hq5uh5vAe63X04OjoFN4t36KkMyfjKlxcKGon5KYjluKe4Cq432QwaHN5J23tn1748SvvaqyuNGRvcx5vm6dxLt9oZdxfN2EjaZ8yJbSeIz5yMeqboprmXOewZh4hKawnZGAY0hyTlaSV0xZkFt6jIKmc1xpkLtbnnmWjn9WOmRJWE1OqnZreFRbVE5pY1BYQkQ+c4gzdz8xJy8cS0ldNidOOjtkTV5ZVDlffEt5TV1sZotublx4eK+ZU1COmKGaoYqMgHdtvLS6wd+EhpWPeod/iIqIj4p2y9aEg3mLqaaVoJaAk6CqmYyQjZqVloWN6OCNtbtpd3ZqZa6foqqkop+gnZCUiISHkYuMm6CVh5Ofsqejkq++xmt0cHR7fHZzbmNgYmdoaW9yaWtkb3FqX2JqcmloZsOyvsO7sVxhZmxsZGBlaXJzcnJvb3NzeHh1bWOieH+NlpGQh3Z5e36EjIWQiYuAllpnXVNecWtkX2G1YW1raGC6nXt9dm5ofol6gXx9d3Z0cXZ4d3Fta3d0WX9BeolKcGJcYGVhW2dxaWBqs1dah6pVb2BbeWxcpK+peZCXg4eQe15bTVFwcmB0Wk1OSlZwVFRBSWVBSUxAYElKM0s1Uj5UaVdkUVBYfnxrRFRJPzyAP087OE9tV1JIRnBaX1dKQV5HSmNFYWhaclBHRlppQjAtNjc5RFBabUo5MkRAUDtXgJWmlpGIgMHSd27Mco6MfW2AcNNxem9fZmNfZm5ud3vaf6yJl4emsdmcz9Tk4P+Dx9CTio1nhXzoiJGDkPHJv6Owh6Cu5IR91bSlp6eGq3OAnZBijYd4ybmqxnRmrr6okM/GnYWtp5CPq6+IhbyWjZCRrIi/1cujRnbApMzM2F8lMzMxREEwJzI5WEdKUz2LMi4+OT5CMFpLSG5JOzs8WkhFWztIdnhbcYKBV59xa15oXV5qUE1gWKtrt6xkZ1SPpaOlwoBZhn2hc4tkfHJ+iJSAkYqImEhDaTcyZWlUXqrCVGBOeZleT3Z3gGl8X2qMjJCJSlZDe0R6cG1yeVRSV2BIZV5dUSlPXj9QPGNKbDFXWzozQlVQVE9LNFFgZmBOZYpaUa5dZI4uRUdXeYSJ01Vfh3SZ3dzj5+zUguJsipKLiX9xrYiXg1Szh0aHqrSqem+AT29hfNG6anPNnm1srl01N09iSGs/ZG6JUZWRkWOWZkdhaHdmsV5mqHlocHY6PTqmhJDCu353d42Gg4+YjIR7g4mao6GjjHyRgo6PTFiHSmpoVD1tPnBtdWY7LTJTU2c9Ly0qQmdLMU0lVVgvMD9SSjVigkA6O4U9QHmHaDlPQzmAMS43MUJHSWmIRGdPf1BvPWc+WlJdVpSOP1M5VUI/NUJPV1FEOmBkdz49LURKW2I8P25MPT4dMyk8MEtNWj5VWl5woUhVeVNhiH5hdVhcq4yba2BxiZ9qgHlFhEhngH1DaGU3R0wjOWdHY1aRUk5uPlFRSWhSXCoraYgmS2BpdFUFfH18fHyFfQx8fXx8fH19fHx7fHuEfAJ9foV9BHx9fX2MfoR9BXx9fX18hH0DfH19hXwFfXx8fXyLfQN+f3+KfoV9jX6CfZV+BX19fn5+hX+efp5/hn6Wf5N+in8BfoV/mn4EfX59fY1+BX1+fn19h36PfYt8hX2FfAZ9fH17e3uJeo97AXqEewF8iXuWfAF7h3oFeXl6enmHegF5jXoBe4d6hnsCfHuIeoR7hHoBeYR6gnuHegF7inqCe5F6hnuEegh7enl6enl5e4R8AXuKfAF7hnwJfXx9fH18fH19h3yGewF6i3sIent6ent7fHuEeoR7AXyMewV8fHt8fIR7B3p6e3t7enqNewV8fHx7fIV7kXwBe5V8BHt8fHuFfIJ9hHyIfQJ+fYd+DX18enp8ent8e3p6e3uEfBZ6eXl7e3l6e3t7fHx8fXx9fH18e3t8hHsDent8hHsBeod7CHx8fHp6enl5l3oDe3t6hHsRfHt8e3t7fH19fXx8e3x9fX2FfAN9fHyLfQZ8fX18fHyOfQR8fH1+iH2CfIR9BHx8fXyFfYZ8DH59fH18fHt8fHx9fYV8gn2EfAJ7fIV7CHx8fH19fHx9hXwJfXx8fXx9fHx8hX0BfIR9Bnx8fH18fIZ9BHx8e3uFfAJ9fAICBACAkO+1spzluePHoI/RjsT9hPnnyMW9n6OQue+sodnMoZuVjoHYlIiao5SWqrOdm4ycnYzqx/3syr6B+eXipMzej8bo+Pe3rojKiOv5xbHh3s/A95z8icDR3OHN5s6h2ryhe4CNi31+e36Yi7j358uypa2ysqvPnYvdtY+5nMvW+/yA5ur13tLo9OnfzIqRrsje8oyerK6yoILQzqe0v8DbztvQxbTU5N7bmnZ+uNnM1dTK4oORp7zFvruyraGKh4+Gh4eOh/7NzIGHhfyHk42UlYLz5OqCiYiGhoeOi5iWh5KiqammmJ6Tk5iSnaO2oIT43rj34rrKurKhqbXGvcO/zN2AjKyxn4+ywLaghO781+nn++/YjK6QpLnOyOvoz9HZ7suvvMW8uaCcjrOzqKOolYaRl6yeoYuDwb7yirGC8cDGh4aDhqz5xbfRzLvPmKOqn6GYioLyzaanuIGQ0N+s4/yDmrG7i7PHgM3ry8Whmpm7n4fMwZ3Iv7/McnXvwb2MjsCA4oiSmKCxoZXGsKih5e6iwq/Qh/PGmeilvKWgp5qRhZaXjq3Mppqtm6SbkJ6hp7zcyv7l0dHdzJCfrqGQiqqpdYi9mpSgpqyxp42glot9enx0cXSU0aK2zcyWtbS6uWPH26uX/7mpopCoyoB6gHx9g6jPyXK1n86LsYXyy9ugiGKA6ITpsJp+n6rC5o/z8de4rt95zq3D7MeuqrHc3sHkiIianLSYmJ7w3oOFy8ampJ+Wuoe0ws+y1pqcpI2VpLXbjpKU4saWgYvV27uAv5Sm/qmhkoyPzJN8sKR7qsXhrLSbpLfFo7STk5aN+YTHnLyqgpqgn7+KpqyahoDKj66OcdyAoLx8jnrJ14p64NV71s7t2ee+isavicSFuL3C0sO3zcWEgJicwcqFx+fht4yJnpapuquTpYqNidLKkIaoh7KwxczQ1NHet6q3rrHFuY2lo5mbkriO/KqDsJ+ju8HUnoqTsoSNjI+CdX7ko9WegrWOp67Wqp3hpbn4l5f2rqXjo8mA7O+n8LTR7MHxuI3Tn/vF8pPTgPOqq+jCwYSHk8aCqqqxpPKrod+TuMjBtf+wwJbJ4MD+oYuO06qUrqqSlbOP4bWjuIt5jpJkap6+q2toj5xucouBfZ2OrNmEqOfNi6yWjpR/c9GomIe4ss67hYGXkrOYwLiQwO7vhoXosJinur+Ae658fZPpoqrLlqn82dH36PCu3LyIxIuRnIWpkp+ciZ/Xi+KW+52M0/qjocaT2cru2tLM4vqfoeydr8vLzJ/0rL7h3YyoseHrssfG04PM2qvI692H4tObpoq9y8u2pYyI3J3cgonHx9je2cOKzrmcv9rPmsmE6cOf1d/s9PLn9ceAX9GQiXavg5F/cHSvc5jads7Gs72xl56SufGjlNTVjqSYhXDAfWd3fWpmcoBwcF5nb2GenOXQn4xf07acfpSbZZW7tb+OdmOcXqmxhX6SsJ6TrXzZdqWut7qsx7ST286xho2cl4yKioydfJvPwKuXjZWXmJKyiHvJpX+dg6qy0c+AwMTMt7C9x7y2qX+FmrHAzHaEkJGVh3PBw6m0vbrQwczDvLLG0tHRm3+Hs8m8wsC2yHF6i5idmpiPi4FycXZvcXJ2b9Sxtm5wcdVweHR7em3UxspvcnFvbm91cXx7cXmEh4aFfIB1e313foeXg2/Yt53Gtpuqm5OGkZikmqCeqbSAb4OFdmqMlZCBa8TWs8LAy8G3fZR7ip2roMPCqq61zLCSmqCcnIaDepaRh4N/c2hpb351cGdhkpe+bIpjw5+ea2ZqaITKpZ+1q5exhJGZhoeCc2avnoB7gFNdlZp6p6tpfomHdaWhb5rCoJqGhYawim+8uaLSurDchYT1qZh/fJOAyG+Cn6mppaLOubSq+v+qqJ/MhPbPi9SsyaKgqaSdiJ2vr9DYz9O9nZCUpMjP09jtzfrdxtXUuY2Tn5uXmcfGhZ3XsqyowczRuZy9q52EgISDgIWo2sPf7/SowsHKyWzV5q6U37WTmIeYy4Z/hoSDi7DIzXm3kcGHtYzq3e6mlnOA+I78wp+EoqbD44jt8+LIve+B48TT98ujmZ3EuKvYg4SfnK2Zk5rmy3dzwMusqqeq0JjO2PXE+7W1uZqamKvIpKuf38OTgo3R3dGEwqSm966XhIyP0JaCtKqFqsnbsriVoLa7l6WPjZGW/YGoj5Wjhp6kn8GTtrWjjZHqnsihgPeAt92LnYrw/pWC7eiD6tj24dWsit3YmL9yrK6vv7qsr6trcXqDfpVspL2+oHRsc291kYh8gXdqeICIbnaOcI2MnKuUsqWTj5mYjaGYoYmHi4ZygZ6A7p9yknyOrLvXmmx8s4KSkJd7e3fcnsKIeKl/kpe4lYzOmZOtani7jnaXgY6Anp9uq42ArZ3DtYe2c7eCllyBTYpsibWBkHp/c51jenVuZq6Jh755m6yonruKh26YxbHrwKej4sTC3OOkuL6P+82nxJCKp7GVkM/xz6KescGcp7OupL6YrdeOt/zdm8WtsKyOhPjIup7TxOvDkYeOfHtfdnNKc7O7f434u6m90NmAjMCHg5TdkJ+2cGuil5esqKx+hYZohHB9iHGYenB3a5KvcqF/7ot9u9OWiqR/t4m4r7izy+dgWLOMkHeSj2C5mqS+y4KkuOj2scLKzHq4wpSUw8Fxw7tzlWqxrpSiiYJ4vIrBbXWwk6TNjsaEuL2hxdfOg6Bdq4x2n7i5xK681auAMGhaYmGTc3lUTFuUYX6qX5KDeoFwgoyHk6JcUXNWOzpWW2G1aU1bW0lGUFhOSkBAUT9dLi5NPyoVICFbOmVsNSlMdI9hW01sRH2OX114m4Z9hnPLaYqKjZGLp5qH4ODEmqGonJ6XnJ+na3qim4x9eoGBgn+Yd26+oG9+bJKUqKeAo6OnlpGYoJmXjHF9jZ+nsmZweHh8cmi+wbbAxb7RwsnCvLrJz87QqZWYtsSztbWstGRqc3x9fHp3dGtkZGlgYmRmYbiepmBjYrxgZ2ZsbGTEuLhiZ2VjYV9nYWpqZWdwdHJza29lbG5qbnqHeGfHp4iglIGOgnh0goaOgIaIiY+AU2FfVk5wfntwYbC9nq+st6+nd4NyfIiShaurlpaftpZ6f4ODg3FvbYB5cGliWFNRWWRbVlNOeIelXnVXrI2NWlhYXG20m5irnomje5CUdXt2ZlWJhm1lZDk9bGlXg3ZAPEhRPUxNLUxVSVRKOj1XTzxOWVNTXG15NkCBUltKQUiAXz1DQUZSSEZjZ0tNeoNOVUpPLmZRP2dTW0FLUVBEODMyNkdQQkxNRjk1LSgwOmCXoNW8nZmenHmCh4x1bG+BWlyFeW16fXt9aV9kcH14dGhgXGCBvXqOrrGd2eD18YH85JmXu72WoYqP0paIlZCLnL25voG5jriDqnbYrraTkIOA53m8knhghZSiw3POvJ+LecBts5Gw6r6Xj5S2qZvLgYZ+eZOcgYrdq3Rxp7Wbp35KXTQ4OS8yOC45QEFFXHiXQDA4h4JGQ0xnYVw8X1JfiE1KRUBVk3Jcf3hQeHZ4WGhndYZyXFxTU2duzmZ5b3N8VIKqq9F+l5eda26Zmculi92AjF8vNDR9elZOsKdWfnWUiZNsUmVYUJNSa4l/lZF+eW9ORkhDQThLeod6ZldCTVBFPUxbW1A+V0VIOEJGMkA+YWVLbF0/Rz9GUUxib0dcYE9VZ1ZJfnJGaUFSbJbGgz5ZcoWlkrCFjIK2mbh7dKNzgYabgn26jXyIOkmXeGCGbHWAfYpLgYdzfXKb2ZeHYItfeTxMPFBOb5BXa2VyXIZMXFVPP4Rycp9lipqXiZVmZlpwqpK0iHp6u6SQqKOGj51tqJR1w4mFr5xPUFtqV1VTXVtOUVtSUHF2gqRTV2dYQUQ4KzMrLFZTSSlISU8+LyVHRE06YEQdNWpHKDF6ZjY1QEqAMTUjLTplRD5aIUSNZmh3e3VXSlhJZFVdT0JJIytGRUB2TodUb1E/XXM2PjomXHRyY0xugIssKi9DT0ZfZkt+UmqChmt1g8CsgpqPllSZjnRsk5FJdm5PX0JLXVlVV0pGeD9LJi5cYF9neG9Ff0wsN1FPQnwtSjkdVp9aYDtRjmIEfXx8fId9A3x9fYx8BH19fHyFfQJ8fYt+CX9+fX18fHx9foR9EHx8fX18fHt8fH18fXx8fX2HfIl+jH2OfoJ9l36Hf5p+kn8Hfn5+f39/foZ/g36bf5J+in+sfgl9fX1+fn59fX2Ffo99hXwHfX18fHx7e4R8hH2EfIJ9hHyFewV6ent7eoZ7AXyKew16ent8fHt8e3t8e3t7lXwBe6p6hXsCfHuKeoZ7Cnp5ent6enp7e3uGegN5enmHegF7hnoBe4x6iHuEegF5hHqCe418EHt8fHx7e3x9fXx8fH18fH2GfJV7AXqGe4R6B3t7e3x7e3qEewZ6e3t8fHyEewN6enuEeod7AXyIe4d8hHupfAF7jHyHfQZ8fX1+fn2GfoJ9hHyCe4d8Gnt6fHt7enl6e3x7fHx9fH18fHt7fHt7e3x7hXyEewF8iXuOegV7enp6eYR6knuGfIV9BHx8fH2EfIl9B3x8fH19fHyFfQV8fX19fJl9CHx8fX19fH19h3wDfXx8hHuCfYV8gn2EfAJ7fIR7hHwQfXx8fH18fH18fH18fXx8fYd8C319fH19fH17fHx8h32FfIJ7hHwCAgQAgIe0j6vQnLLD1u2nzpmfpeuNzbx346vBw3ibwIfE3ZebhKKc7IivvKWfmaGXiN/dzIyq9oWXlrni4+zLl5qRkc7utbfKloD2goW/5qKJlomSlpnsnLyrosHHn+vEtbC4jXyBeYV5g298en2X4fTluIyWsaq20s27gMGOn/amxNDggIbn2svtjIuM89m+zM7n+o2ep6+zo5iCg4TzgvzmxrbNyNDp9oWC/ubj9/qAgoyOkI6ctb+1oqnAvMC3o4uTj4iQiYP98o+dmqGnrrKhho2SlpyZjYqSj4SGhYmJifiIkoiFlZehm6Cho5SnnJ353smBieeY5623q8HQy7awuOaVgL26p4yhuJaljeDOyuiP6/iO666pkJnFyaKjmrGZl5+jurDj/OaXkZGVq46m0eWzmKiXi9qHjdvK77aIk5nbwOuKhLeettL7zMGMl8yNltyCwquHk4OBwvmslue2uoyGiYTj4eXH473ujeyXsYrotPOs473EoZCymn21+qPqha+tgKuQ6b6WjZ+08a2utKvZoM2cgZ+RrdKv/Of3xYzPwqGdkYigvba6sJKQh5CeyXavxs/q8Nm8+7atlpCSo6Kho5Gpv6Sae4mfp6Czp4eMfMnW3up7o49wipmn1a3Cu7xorOj3r7yyq9O+osvS2enZgYau1snJsM7crs2Rv7rGgamzgM2504XCmajA+OHswNG6r6CtvKjHetnA2dLbz82wqra8sJi5z67Ds9aVisTy4o6CydXMvsmQpZBycMZueaqP3KWmjfSWsrehxcLQ68uE1v2AwPiKj4D0m4L1w+XQ4e7Fo6e5v6u1tLqtk6mX8/uvg3umd7uJkZOf48twr5+rrIWxgMLHrHjGlZ+Osa3j54eT6vV9sriXlJeqgIaqla+4s725gvKYppGIxuLM65CKg7Oa1L/YzaS7yoPCs5OhxKPit8Sj+qKxh4+7t5eV5P3NlKD0uIWPi8K8maOOvJL6xNbn1YPhtbzY18/wzNmWrcDU+KKcurLHrpbforfCiIHQtef5gMyAh4DkvdP6mqrnsNXQ2YeTw7a0xIzo0LSumai2+oKzjq2w8tPCl6Ccnoa2zNqiqMzwyMGFo/LhmbfFmZCU46iK88eqspSMemqpuXt1a66rraRnh7pizIydg3eMfb2Xms7Blo+ClGzQpZfCe5qbiqLH1+uR6NixpK6rjuvFhXicgNSnpKDKhefpwunbrLWVpqjc2Lv36NvIrsOv07CZ5ey1qbKZo6jh0ubP1KOTlJ+O5LOf+9a9t9G1hIrmo5G9pfWn07WBqo+jvcGPkpak2aXhhLnVoLvchb/i4aKJxISAjOT/pL+ytMydtrWg0bXMnc/euciKt7Thv8mm1py1g67BgG2TcoOlfIB2fJR9knmFitCK0ciA87XPzICfuonA3o2agZF/tmmFk3l0b3xxXqWlkF5oq15+bGp2kZiLcYNqb6HJlpe8eFqyV2CJsoBqe3Z9gYfPhJ2UjKetjN7OxMPQn4yVipeKlH6MiIeIwM3DnXqCmJGata+ic7KHlt2QpbK7gHDBs6jCb2tswrOjrrLB0XSBiI6Th39wcnLact3Puq3EvcbY2nV05dXU4uFzcXh4eneCkpmSg4qbl5ePg3R7dnB3cW3UzniEf4WJjZCCcXd5fYB8dXJ5eG5ub3JyctJvdm5qd3yBf4OEhnmLgoHPuqxuccGG2ZWXjJ6nopiRmL51gJGNfGmBkHuEdLuqqr95w8p1yJqWfIKkp4qLgZiDgIiHnZO+1tOCe3t9i3iHprGJbXpvaKZiZZ+Vs49rb3Csm7tqZYx5nK3Mp59scKhxd61rp41la1pZda1qY5x6h25pa3y3qdbDuIuva51mgl6xr+uQzcDDoHeun4fL7ovXe5GLgKKL5LSQlZq987W5urnGn7mHdpKJqrSW8dXzrG++wqaHiIiu2+Pt06idkJmrzJ3Ixtbx+9bA7LieiYuOqrqop6zH4L6mhpWux7XUyqijh9Pf8v+EsqaPqr7T+77Vzctxs/fzsLyyq9i+mc7T5vPliY+4z9DTuNnjqMGIrq69kMq/gNzG4o/SmLHD58rhvs7Hua22ycDggufJ08LEtbSjqbCzspeywae5qcWIgbf16qGa5Prt3N6juqmJge6CkLOE0amxm/KfsLWfscXezK6M5u6Ctex/jn/znXn0xtrH0dW5nJq0tKOupLSznrWZ2+WxiICxgseXn4uo/eSF0rHFw5jLgOP8y4zqnKWVwLby9JGX6/+AqK6hsZ2qgYepj6uzo5WnbsZjjW9ur8G3zIB7b4lyho2bpWuIhnOFe4uTqWjKjJuNynCDYmqapI6Fy9nCgYjco4GJd46qi4SKtonktcLS0XLEucjg1NDWstSSqrTK7ZKMopqrm4e8hHuFWl+Uf6qtgJpTVlCtd46ofXOZap6NkU50iH13iGuokX6Rio6Oz2aAZnd9va6YgIiGhWF2lJx4dJe2qJqFwPPkx+b5tI6d8L63+b2yvqfMkYrf95OckOHT0NaPsvyD1JWhoZGok+mztu/YpqKZqoHovLDejamjf5KGkZJSd46giqa2mO7YlYajgO2xqqrSfN3XnK+2gIh1h3+gnIenu6qRiqeYuJBhk8ifi5h/kInIxuOmuY12dnNvqZNyn8G2nrKRb1+heGuNer2Lv595o42gr6yMlY2TvXm4ZKC2dpycZKnBp3hpsXd6gc7poa6Bj5iHsKKbyK3HnKTaspduk4Wgk499hVtuVpebgFV6W26NZ2hVW4FoemVraJJLYlg2a2mNiURHVUFYZENMRlhegk1hb1pPS1JLPHh4ZEJTQSocL0Q+QDUgNCIyOSQfJThBOVCLPj1vd0hScnF6eoHAcIN7domMds3W0M7hsqOvo6mao5KfmZl3naSihmxvgn2CnZaMZ6yMmcp+i5edgF2fk4ubVU5Ql5WKj5Oks2NpbXJ2cW5iZ2jJZ8zHu7HDv8jQ0G5u29DR2NRqZ2poaGdud3x2bXJ+enlxa2RqZmFnY167tWVxbnBydHZvZWtsb29uaWZsa2JgYWVkY7tfZV9YZmlvb3N1dW15dnO9pplgZrB6z35+eIWLioR7gJdYgGlmWk1jd2p0ZaebmqNmrbNlsoiJcnaSkXp8c4p3c3x6ioOqvbh0a2lpb2RthIZnVGFZUIdLT313kHxVW1qUjaNZV3NlkZ66lItcX5ZiZZNcj3xST0BASYBEQG5VZUxCOjhsaFtMWkNFNUUqMjpdQ1ZUb0NIQ0NrXUBnj1aVS0xAgEtSaU87O0BRWkZDa1VoR1E6QUxETkZVfVhpSD9dTEE1NjhEUERPX1VJRjMxSS5ekZ/Ax6ORuZaDfHRuaFxlbFthcm5kVVZfcXZnX2VydLS+v8lkjHtPU22Jxcj18PKHwc7uvczEuvTLnOLW+fL4l5/IvLXVuN/tnraCoaGxhe/dgMGnrm+neoSn2am8qLeHf2l+hnWdbsqasqqhoaWRjJaeg1x0b32Ugb6GfLnmzlMzS0c0Kj00NzcrMFoyOUpcmVouMXZKSlNKXGNsb1hEZWw3YJtNd2/EbUdoaHVhVl9pY2yDfGdiZnV/Z3F4oaF8ZWF5ZLKWm4mM8IxBf668rpyEgHBlXDdqZ3psY3askFdXh5xOY3RkYHOEXlhtZIiBYU10Smc6QzlFfpyDnE4/SmQsUjBIdDlpV0tZS0ZBfzJsVlBKfks3OUBhWTQ8a29kZnCyh2NiUlh6ZmVWhni9l6y8tlikuOj+5tzKfJ2FpKiz4IJ+joeViXyoZldVPEhpaI18gE46QUCXV3acfWeXZYRPRzhWdltHUUh9TEB7fXFwn0hhUFVenpeCeoB8fFJUd3BhVmqjgYFqi+Delamxjm5otYmB7sPJx5qBZF2TlldQWaCfqKBKUqpTjXaDVkgzOkU1MDxEMyktPT5aRVlcMTw5M0lbeFEvLzFJOz9HRGhMKiQqgEU6NzZNQWdWM1QvP0gtOUt5aFxqmX1yXF1YazglV2pLKkxWXVJ8VFhoXEInNlVCXE88TGpZXWpZQTJcTUpJQn9ZYFBcenaIkYViZkZKlmGCPml7U2dkSmp8dEg1WmFcZJWZKUgoWzw2Q0kwS0ZHLz1TRmZKWjw+Ml5eTC02Mnl9An18jX2EfAF9hHyEfYJ8hn2Jfgd9fX5/fn1+h30Bfod9Cnx9fXx9fXx8fX2GfId+kH2OfoR9hH4Bf4R+g3+Hfop/An5/iX6Cf4V+mH+Cfph/AX6Pfwh+fn5/f35+fYp+in+EfgR/fn5/on4DfX5+hH0Gfn5+fX19hH6IfQR+fn1+h30DfH19h3yDe4R8BX18fX19hHwBe4R8B3t7e3p6e3qFewF6iXsEent7e4d8BXt7e3x9knwBe596hHmIeoR7BHx7enmMegR7e3p5h3oFe3t7enqFeZF6AXuMeoZ7CXp6enl5ent8e4l8AXuEfAV7fHx8e4d8Dn18fXx8fXx7fHx8e3t8mHsDent6hnsBfIl7AXyGewZ6ent7enqQewJ8e4R8hHuIfAF7inwJe3x8fHt8fH19hHwGe3t7fHx7inwBfYV8AX2JfAV9fn59fYd+BX19fHx9hnwKfX19e3x8fHp7e4R8gn2FfAh7fHx7e3x7e4V8h3sJfHx7e3t8e3p7iXoFe3t6enqEeQl6ent7enp7e3uEegN7e3qFewt8fXx8fX18fH19fYZ8h30CfH2IfIR9hXwBfYV8k32EfIN9iHwFfX18fHyFewh8fX18fH19fYx8EX19fH18fXx8fXx8fXx8fH19hHwEe3t8fIR9Bnx8fHt8fId9Bnx8fH19fIV9AgIEAID44/2TnMiRjPb2rNbivND924jNiZfBwtSQ5LOsi43EuNmOkvyb24y2oZqN/IX64v6Z3tarnpmksoLiqtLF0qa1m6SEpZzE+rDp9NDK48G49pm/+JaT/dKemJKiprKou5aIhHqAdGltd3JxfZ+Vp5yhio6oo72npaiXoJDi5qfSkoCn9Mrr3YiRk4LzgYOBlZiYpaWflZ2pk4uUnZmN/PqFiYj/gYiMh/T7/Y6Zn6SnrK2yubOtqb64s7nCqYCIoJucnZyip7KyvMbP1My8u7i4tq+2r6Wlm4qHgYKMlYmFj42F6vqFiYubmaynoZybmuGymMLZsKHJwsnZ6czLud2EoYC0npiSsq2Ph5rdtveN/IDbo5yuiJWpw8CujYaJnoyKgKGkqLSf45OVg52OjcTU7uawgNeriOm/0Ijwzq6fjP6hmaiH9/+ajeG8tOCo46+NhYDnyNCyk+jmhOqg/IPB8Oy6nJGszsnt8IKisq/QtZWH9LH5jM7a5L2dpoO1lO6HlYCx9YHGyLXi08zfheqK0r6mvofc7uGBksbHo9SPzaOm04N6rKvDxcC+26LgkKfIiePLxfjVz9/szai2io6olp2WtqiTmfuTq6iyyKWOq4XlcnfNc3ZseIKVhZGLjL7Cv4WDnZyfrtF2cNFo0nZ/hHt4pNygn6CtsKCBnLvwyMKRtYCZj5N8oKacprfFrYmrko+YlJ2Uxd5789TKxOHVwbTr98X2tLTJrZnsyIDH7ZJ+ddLRq6B1mdGLxX+dgZ2LlMnA3LTb1Yev0sXA2uyWm7C/04jQ7ab1836R/IvR2YXRztfZzMewiX+C4ajgheSnzc7HiauIseSHptx9f8aEgbOoo4DOsZSUmfigtJ+e69KomebmkJipk5jl4Mv1iZ6bsJ64xMjLts+F9dGFzpqoz8aCnJ6FxJiM/tSy1YLzs6m3sL6itoPIkeK/u7Ok2viL4d325r2rp5yXqdjTnZmBjImHgeSl2Z2G4W1tb9Jx98K6gtXfyeqWybqeqM6Kz/i23r+G5YCEgoKUpaCbu/zEhIae4OLHxLjp1auTgLbfsaLejoD8h4LV+siXhPuDktzXzNjdxsSE09+PhJauqYnNp8adgoWKlZF0m6CQv6eS6aKuvZ/AqKCTVqGnW3dxgYWDyc96gpJ6zeCTlKLRgeCklql8g6z+hPjztp/LmoL0ncm7jZ+TioB64emH0ZCyko/JgZe31uyD9YGA0NnrrrGQspyQgdjDqYaG8ej/mYKD7/GK8oD196q1+eL2l9OsqqPAnI2dk7eRsY2F8K+v4O+O8aut7MPE7fLG96LQy7+om6PQoO683/TH4snigfPX3LLSirid7Z6x/73Ph/KHgrOB1fOcw465lIDRtsd2f6VvZ52egLHPuKC9vIjrm6rY2OKMyKGmgYO0nKtrcL52p22SeHJks2G1nqtckYqEdFpxYlmPbqGysJankY55moSX0Yu1zrGnt7C42YGr3IKA5cqjp5+yuMrB1ayblY6ThHl+h4KCkKOFkIWId3qOi6OQj5KEjIDLz5KzeoCIyavEtW10dGnGamlqeHt7hYSCe4KLeXN7gn9439x0eHbfcHZ8d9nh5n2DhoiKio2QlZCOipiVkZWXhmtzgn5+f3+Dho+Ql52jp6CUlZWTlI6SjISFf3Jxa2x1eW5tdHRswM1scHKAfo6IhYWDf72biKe2mI6on6CvvaimmbNpfoCJd3Jxjot2cn3Al8x20Gu1gH+ZeYKOpZ+ZeXF0hXl3bIiJkJ2OxH1+b4Z4c5+mu6+DY6WNZqiKl2Spnn55ab15dX5nx8p3aayZk7F+pX9tbme2nqV8Y5+lWah2wWSezOSujICTw5irsGZvd4GMgnZ81ZHihLGxr6OUknanidOChICP8nqzu5bU0c/Vf8JxsJKPnHmxycFndKSdj6uCsqCbrZGLu7fN6t/P6KvuosrnkNnB0P7P1N3u0qrImKrSr8KoxLa0q+2gtKi/2bWoxJP2h4DdgISCgYeok6GendHUyIiNnZadrtV8dtpt03uGjoWBsdOppam1uaeDl7LmyceYu4Cemp2Eq5yRn6KtoYqumZuopq2g2vCC7N/Nyt7GsbHL/7zvrqmzk5rkxH3F4pOPh/fwwbWDtPKl5Ii+ma2Tkr241Lvi0Y+q3MOxvLx/i568wn+4vpDp6IGK4oDQxXHFuLPStbCqo5WG3rPbgNOSxsa6k7+Tru2Ot/uUnP6dkLq6uoDv9MStn/qYuqms1eK9oPf0k5mhmJvv7dvyiqOaqZaYrKi0nLNpzLN1soqdsapjdYRyfmFqpKKEiW3iqpOajXx4iHChc7SqmIaZyc5my87n1qaako9/mrOrfnxtdnNwbsWSyJaC5HJ0d+F3/MGugt/fw9aNxLCSirdwo7iFpoVfooBYVl5hf254f8l1V1Vlj7manHzGoIRyYo2Xj4aze23Pb2yZuJp9cdNidaySjZKMf4Vfmq5uY7TKtbvspbm0jIahzM2ApMrG8r6k+qvA3bfiwuy7jfD4h62Mj6O17eyMi6iD4fmfqLzwjfi7r8iGkaPiebGLX2KZkHXlo7CWeaSTj4CC4eJuz4+0fXGdWmaDsbJhsFhmqae6iZSBi4dzYa+akmJuyaTWhX6Iurp64FzQoYybyp7NisihlH6WbFhwboxiknNo35WXxsFtwoWJvKuKtLas44+6o6KdgYapi+W7w9OqpavJZqKNxZHTip58y4qU7H+fbcFvZ5NdkqJtoXmshYCslpxdZoxcVneCcp2SYWF+fkZRLTxfcIRTYFVVPUZaZHdJTn9SclJsVlRHaSVjZ3I3WE87MzRXOCo0JycgTD8wL0AxNSV8dkKDmEMzdWdXynaoxnFvzsGssqS6w9zU6r6yqaWllouTm5mcqbR2e3FzZ2p6d4t9foBzfna+voCYYT5nn4+fk1VYV1KjVVRVXmJlamppZ21zZWFobmxoychpbW3Ram10cM7X13Jzc3JvbnByeHR0cHp4dnl4a11hboRqgGxwd3d6fX6Ggnx8fXx/enx5dHdxZmNdXGRnXlxiY16prl9jZ29yfXt6eXhysYx7k52Ie4yBgo6YjYuAj1FZZFhQVnZzY2Jvp4KzacJfpHBwi3N5gpCLiW1naHlubGV5d3+Pf7dtal9xZmF6f5CCYE+HeFGCbXtPhn5jYVWgZGNmgFStrmNWjoR9lWd8YlhdWJOAhlxDa30/eF+aTH1zX2BGOUlPQU1GKTs4Nz8wNDt+XIhNen1yaU9qRHhlkERDTIJFVVxCVlNLSil2QVFYR0o6ZGVSKjtGQzxTLFxCQTgoLkVGTVNiYXhLY0BCX1erm5DEqK+0uaFyeGVUZGJgWm1rgF5lx215Y3hsb1pyccxYYqxlZldRS2mMmoaV8v3fe3KbmZC45pOJ+IDQgZill5HDvaasrry/p4CRtfPS0Z+1kX1+ZISLgo6alIlmgmxbYmByZ5DGdMqxqZ+ws5J/g4h2akRNYV1nycd/09x/Qyg2MSUpMDE0OmNEPTM6PmCBZ3FXgGaEUVpJSE1weUNVU1FfUHNNXJSeZ2dLPmRUOV1hbaB+e3VDQUNzZnlFi2OCj4xvkYGw2YCRtUJAkHuVfneKgHRbWGuLboNFP4hzOUyOlGFlaGx7qpuEqVJlcIliaHZ6cm9eRZ91VYBWZ15vQzVFQDBATnZSPE8pZG1cY1dFMj4+gGApP0RdKyx9iDiprqecinh6eWKEmIxmZl9oYmBgr4G6jHvzgYeK94D5wZ525+6/yYLArZGApkpQTUZdVz+ANzgxS1tPRmPLclNFUWqRfoBdf0g2RUc4O3Zxl2ZZrVlXWJB+dG7NS2yTZ0ZzbFtUSHSAXVSGp6aHx32KkYCFg5OFgHOUmHipmJfImKCkprGUlolPlZJOYWJxWDZCSykmMixMSS83R4JKbkhEQyYoRVQxUjsoNDAxNmhQWD8oQDAqI05SPls+SEI/Wi8vNjw5P4I5Pld7lWNcTWRDJzJDLS88R3Z9pD40I2+WNWAsUC8kK2lOa1RwWGVYaC82SCpKUGxRPjuubGp+i1mgYF+UdHZ2aFFwaoVqZmBLSmBTn4OSpmZzZC4ie15IRUw3RD1pOThWTl4rXkkzKkFmaS1mQolyAXyKfYN8hH0GfH19fHx8iX0Ffn59fn2FfgZ9fn19fX6MfYd8EX19fH18fH19fXx8e3x8fX5+l32PfgZ9fX5+f3+EfoR/AX6SfwZ+fn9/f36Ef4N+uH+Cfot/kH6Lfwl+fn5/fn9+f3+TfgF9jH4NfX1+fX19fn19fn5+fYR+BH19fn6EfYZ+hX0HfHx9fHx7fIR7h3yIfQR8fHt8iXsFent7e3qIewJ8e4l8gn2QfAh7e3x7fHx7e5V6AXmJegR5enp5hnqJe4V6BXt7ent6hXsCenmKegR7e3p5lXoBe4x6hXsIenp7enl6fH2IfAF7hnyCe5B8DX18fHx7e3x8e3x7e3yHexZ8fHx7e3t8e3x7e3t6e3t6ent7e3x8jnsIfHx7e3x7enqFe4R6i3sEfHt7fIV7jHwBe4h8AXuGfAN7e3yEe4Z8An1+h38Ufn59fX18fX19fH18fX19fHx9fX6GfYV8An18hH2EfAV6fHx9fYV8AXuGfAl7e3x7fHt8fHyEew16fHt7fHx7e3x8fHt7h3qCe4t6AXuKegN7enqFe4N8hH0QfHx9fXx7fHt8fHx9fX18fYd8A3t8fIZ9EXx8fXx9fH19fH19fXx8fX1+i30HfHx8fX18fYd8D3t8e3x8fHt7e3x7e3t8fIZ9BHx9fXuEfA19fH19fHx9fHx8e3x7h3yEe4R8Bn19fXx8e4R8En19fH19fXx9fXx+fXx8e3x8fAICBACAiLayno3v+c+d2MPwi6z13+KNfJ+NzbfGhZ2NkeKHi5qdiY6Slv6IpqqU2J23z4bc7+y7sJX/+OKmx6HLqZrx4NbVkvaJ2MGajv2u7suFp7+TmJ2LuYNvf3t3h5CRnJx+i4l+homCfW+Dgo2cjoKS0PHo1/uqs7Gxo6S1wqCGnsmAxdjQ4dnx8f6ehdbzgYWLkJ6bno+RgpKopqCbkP6KmJ2anZyclJ2ZmKy0tri+zNDd3t/r5tfW3OrezKaIlqmmq7K+wsjN1uHt8uze1tTHvLm5rK2yqJiGkJefqqqbkZCJgYD8gv2Jkp+glo6dk5vruJis4N/Yzdrc1MXAzOz+kpeAnJiWrq6xq5a7vdDcxaevy9z6roiTmqyuq5GSppyRiqepqKiji5WNgoyB+pm40eft0r6dlObsqvyOqY6ihKaamLXUn4e3jYmDqsitp+rCg96B+9a6vJDM5smem924go+axoOHh+vb1dj2hZvCuJGBo66A/4H0hpWP0v2Louy3pYSArrOturi6qbXihZ+Ny5iD3PfxuKCzkby5msaHkKyZuM2ijp6D8t63k5i68MrY1/Xv2b/j1nzeeXvFsaCaxL23zZaQkaGesqasxuDroXqRznR37aiRhbiGroTMe7CpnJCGgMTIjXyQjpiHa4N2b3FvzoPiobannKKjnsW6xs6Wi+uAkYzt16XFtLmFs9qOiI6BhY+fqZeqw86urrKFivOb7ZXukceJwOu+p9nJxNCZxrOVjHySsJCVi9GeZ3OXr62AeOKEpZ+Zp7OvzL+fi5fv2a2w3dGGnaDp9vOBtt/p4NHPze/fxIPm8uzee3yFgNjjg4KceXd5h4qQ2LK3f7e+yZOAcZZ/jdl86M5/nfKO3/LQ7n2kmeGGeYKoq/2hj575o7WXucidkbXUy6G0uuLAz4D7pKmijrGYr/CG9q6HhuPtx+SKj+PPt73L67GN+eDqi5Om0cqHmfOcq4aIionr3tjr/IGKif3J44ffqYqkx7KesrKZioPHlLK5s7yJ8KOyyoaAn8/XveXAzNWq1o2Ascr318O2to6tmsTBpPKbt6z15/uut5j5k6eh29yZhaXX0cyYioWWk/Lnkc7NsaypqrfBooqPj51SkrulooGur6mvoZB/mp5Zp7NjZnO3k4DlinnewoiVrp3cfn+HooXDwOW6mPrY2JaMrJ+QgqbQ6uvC4OmAgvSAi+yIpMiQq6HA8Ki/mdK74pWe/a6Amu6WyunCqcKPr4DK8cXJwNie7Mygneja/NS1vcSxtJKTo5Sis4z7l765mr+fsoya5qubv67DmIrQxueGsp/rquvex8mS84K4kdmyxLa4qrz+vJHZ6degltuB2uXbru6d9oaJhpOoxeaAfZiSgmmWvJlospvOcoqxz+CUgpKa6bu6cod8ebNsbHpzam1mcLdfdHFok2p1gFabqpmTZ3XSt594fFqEiorJvbKrcrp1lrGKcted47yApKmBhYt7to16joqElqSmtLORn5yOmJ6VkoWXlqWvmXSAvtjNw+CUnJmZjpCepox1iayAqbixwLXHv8yDbq7La2tucX57fXR2anaGhYJ/eNJxfIOAgYKDfoaEg5CVlJWZpKWvra+2tKenrLeuoIRxeYeFiY2WmZ2gpq+4urSrqaiel5SUjI2RiH1vdXp/i4p9dndza2nMacxwf4OFfHiEeoDEoIeYurq0qbWzqp6erL7MdXaAeXVzi4mKh3ubo626po+TqrTOl36EhZOTlH17ioZ6dY2NkJGPdn53bHRt03yUpbe9p5Z6camjea9of2p3Xnl2dIeYdmqFbWhmgpaFgLCWarlnybiWoXOYppZ4epqFbH2BmnyAeNTAqbnQboOOknBifItgy2K9ZXxvrr9ocbmZjHeAh4+Tj4SSmLnhd4Bilm9xp8u6hoGbcYeIfKtkgJx8r665sa+U+d/Kk5bE7M/UxOLYwMLg1Yrxg4bK0LKh39rD7KCloLWxta2sy+X/vpax/YmB/b+nm8qRxpbkisK6p5KPg8fPkYCWk6GMb4t9dnd33IrXqsKwpaysqMjDyMGMiOqAlZD95qy4p6WEo8iCgIWCjqO7wLLS4N3Gs7uKifGEs4DNfLd6s+a4ptW/wM6azseqoImnzLCvleWthIWywqWBi9x0ko6LkKinubKAcYfG0oKi2NRugI/l5uF2rtLdwbjAyuHFxITy5fjqgot+bdf0kZjFkoSCjpWe9c/RlePg+beAgbmTm+eD1MeCoeSP3/ba+4Kam/GOhIiooOOjkZztlaGPnq2KhpixtpCiqc+pt23ceGpodIp+brp346F5cMPKtdGCgse3kp2k2o2DzdHrgYSavbl4gcZ+iG5wc3HHubzM2W91ddm3xnLBm4KjzrmnvbmViYPGhYqblpx3rHiEl1qAZ6ObjrCflYqAjFlWf53Ar6iWjF2GdZKPh6Nwlp/Ry9yGmIK9eX18r7BsWHeZiY51Z2B1b7HqvNbKvcjW1PvWuqaitfaHz/jF0ajquLjc+ce/1eSI8e2Tlo3Soojyl4bozneHlbPvhI+ct5Xf0vXCjb+0ollZdot+eqjGzdTG0OmAcuhxc8p1l550hXmAlW2SgKWLoXx8xYNwitR4srKTgpZ+mGGKyrTIust7zrOKiKSnrKOXo7SSoISCc2pndE2XbYJyZJtxfmR1pYRynZaqdGGXp8x0nISsk8jItseX8HyTcamPnZ6DcI+pm4y8orh+bbFporSdkryAsFtVYXyQtdaAc398bVuInopahoTCVl5zYFxAKjs3XmNoSFFEQXNKRVBFSks9SHdDTks7XDo+WDtWTkwoKy9HhHE0MS1QSkmGhHyIUnkygC4wU3Y7SFZddJN0dXdttpqInZaRnLa2yMmntrGeqrOtsKa3sL7IrWltss3Aucp/iISFfX6EjXlpd5KAkZmWpJill6NuXIylVVdWV2JfYl5jV11na2pnZLJfZW1sbnByb3Rzcnp6d3h9g36FhoWJiYCBhoyGgGtiZnFwcnN6enx/gISMj46IiIiDf35/e36BdW1fY2dreXhqY2dmXl6vWaxicnV1cW54cHS4lH+HnZ6Yj5iUjIODjpifWliAV1RXc3R4dWyLjJukmISJlqS2inV5e4aDhHRxe3dsa39/goJ/bnFnXmRft2p4gJCThXRfWYV4XX5RY1RZSmFkY3F2YltrW1VWa3psa4t6XKRXqZ6EkGFweXNfYm5hUVVTajo4M1tqTkphOi9JNDEsN1M9eUOMR0hDcolDPG97akGAWFpXW1FVRkJXJkRITSIlXF5ySi8yITdAJ0AvLk1FTkg2MD1BdX9fQ0xPioGYkK6pj4ShlkuNUFOFaGZcaHF5aFxTVmt0eXJ2fpKNYFFYpmJs4ZV/b7Zuk4SrdNDFqYp7fM/gopOsscGjgKWUiYqG9Zm/qcy7pq2jpK/Iy8GPjeyAiXK+rICklZuJnKVxa21dUFtrcFxyk6p6fYZ1frlGRDRnP0ovXKFvb9KVmc6ZrXQvKDpDMjI8MmpQKzI0O3ZKLF88Sk5QVnFvbGJIRU5mZxlMjXY5TlaQfGQ0T1iAenOBoLqYkVuQhYFyOERQVZSgVk5KPF1sdI2Oy5SrU5eQc0GAP2FMVHM6hoJBUHlFcrCEmk9TW51gWltlaI9eYG+Qb4RoZoBfWG6HiXd7gKOBgUygPjsvN0hMNnhAr15RR3VRY3c9RFxNVVxGlnJIlbK2YGx8m5plaaVqcV9eYmKtoqm7xWJnZb+nsGKsk3+o59jJ3tGTiIPTgnZ+gIlpeFZNcD+AQUBYWnBVen5pc1pARoOSgZuGXD1FO0UxOFJTgpGwrrJJO3GTdXNxi4xPMkd1bGtHOk1fYKDCfbSYrZqUnK+dj5aRkZ5WhZ2Wp3u/tKulnI54jYFNlJdSXXLVcS5XLy1SSjdJTi5RNzEqNzJUVV4/MXBDTDlESjk5PFtYYHheSk+AJmY6PHxGRDM0UVFeWk9eTXpQb0Y1m21BVplNNVpKNlMlRB5XVlNAPkUoPmJZUmtaUE9eXV1LYEhjVk1HZj6ARGxfRnNYWkRqmlxUYnKEOzxNNXxMYkh3ZaWAaWdOfVVmU5FiOjddKjY7PSZMVF1BPWxNLCs6aE4WezMuMWFVo8ERfH18fH18fH1+fHx7fX19fHyEfQN8fH2EfgF9iH4BfYR+hH0BfoZ9CXx8fH19fXx8fIR7gnyFfQJ8fYR8AX2Efpl9gn6FfZR+BH9/fn6QfwF+xX8Dfn9+iX+Qfop/on4BfYl+hH2XfgJ9foV9inwEe3x9fYV8iX0OfHx7fHx8e3t8fHt7e3yJewN8fH2OfAR9fHx9hnwGe3t8fHt7inoEe3p7e5Z6BHl6enmGegJ7eod7gnqMewN6enmLegd7fHt7enl5hHoBe5F6FXt7ent7fHt7e3x7ent7ent7enp6e4h8AXuJfIV9hHwQfX18e3x9fHt7fHx8e3t7fIp7AXyEe4R8gnuEfIx7gnyEew98e3t8fHt8e3p6ent7e3qJewF6kHsCfHuHfAZ7fHt8fHyEew18fHt8fHt7e3x8e3t7hXwDfX5+hn+Ffgt/f39+fn5/fn5+fYV8BH19fXyGfYR8gn2HfAR7fHx9hXyCe4h8hXuCfId7Bnx9fHt7e4R8Bnt5eXp6e4t6Bnt6ent6e4l6Dnt6ent7e3p7fXx9fXx8hH0BfIV9Cnx8fH19fHx8fX2LfAh9fH19fH18fJF9Anx9h3wMfX18fHt7e3x7e3x8iXuCfIR9AX6FfQF8h30OfHx8fX18fHt8fH18fHyEewR6e3x9hHyCfYd8DX19fH18fHx9fHx9fX2EfAF7AgIEAICJzJqshfzZq8+8qaiJ1Kyo/drSy8/I6aelq5zNxujGpqiY85D7m+rZg9ehn6SQ+Y3VuZmCusmEj4uM/qD3iYj7gKre2KmKvbaynYuI7JSHmJaSw3p8c2pudoiSlo+Wl5GFho2Jinh4b3Zyg4p2rZjEw6iLheL8jqK1wJeVuJyUp4CsvsbW5oeJh5fx84GCg4+Kkqmtq8G+oI6VkpiYlpSWmKKuxsKxsaitt7e+zt7f6PP1goH78/Dp9+3EsayzrKy3t8XJ1+X29Pn689bKvsG/sKanorSvqqqtp5eanaKN7feL/P6Gj46fp62hmpGB5IjBndbfhfXehtC4urTgh+mbmICelKmsn6iHzMPt3tfczcCywLKgoZ6ixsm5r87j4q+ftrq8trSet6m0zK+qvcTi4uLCtcPCoo6EjKynqL6yr5yZ8bKAlIHsq5e1x6aGm5KT54ayoZaxv8LQuK2JoPDXybm40Jiz8Z6jqamF+qONmsCvvJeTnYuqlZaE0aWtkLyfzYDrsbiBkc7+t+jFgvu587PvsriT8JWPlprvt+nW9PnJ8ofSzc76ho7UhKTdnKO/wcPql43VxMbBi4ivo8yEvrPl3MmmuZmrwsXExM26npiTq2+Re32OkpqOl6XPjn2TiI2Rn4mIgZN8dXvecXSDbm62cO2zqbOuoZ6Xno/KpK2dlYDm7LqqnsTbvum3oPr0d3R7hH6Kl6Cjoqax14qentStnabem5rcuoX8j+6Ymaf8sovgc4Snf3KkqZ1txZyevpLL1+KotsDL2oHJk8X3wLv735jMioGflYroj5ejmbz9wN3x5vjV/enbsPDz7emdwnFygnh9nsOwiXTWrmptb3e71YDUiY2XqbC99IWM/aSA9YH056CoyODS7JOMvbGOm4qYsq/Fyaj2jerGw7ajnKjB54DN4o+VmIGb9oaHh4qK6oKAtpqT9f6ql+ux0oLU/57NrLXu8YyFgoTb1/Xp9eb53ePGzOvo2oaVmoqH6v/Z07ejm6zHjM3+mZWCurC+vND5+IClgqnSv6HZgZrcnc28u57RgpyYrszAx6yU6dGr9caClNeUiJeA14et1/W7rv2PhtzMhN/tmbrz9aHeqpOGh7aYfJWio5GrpIFmhaPOopKTnZiSyGFoeLG4oKXGh993goOf+MKAind4f3iPf4ueio6N8JDRkbDftvS8r5io6NK504D9idzDk/LFw6bEgPOK7LDz9MOHzbmz15OIzJiV4OS5u6esqYeD4Y3ui+C5x9eT6N7r2JKNtP+vk9HH6IPpyISzi4PTi86Giejmlv2r1N300pWViK/ziaSbsI6d38/Nr9TDprjUtaLtjIjb05PpsYaOv5OKo8vLqZytseeBg5rT64B+rYKMYn+Jg5CDh4Fqy42m3dnY1ufNxIKHjnusosKmf31ws23DdKCkYYtwcmxUj0+XlXh0nrFmZWlRlGO9cHfccZ27oIdZmK6ciH9/04V4hYOCt4OKf3l7gpylraaxsaiZmKOhpY6QhIuClpuErYarqpF6dtHof4+eqYaDoIaAj4CSoqq2wXFxcn/OyWhoZ3JwdIaJh5WTf3Z4d3x7eHZ6e4OMnZyQkYuOlZSZp7Gxtr6/ZGTEvLmyvbiajIqOiIeRkZucqbC8ub2/uqSflpmZjYeIg5CMiIiLhnZ3gYR1x9Fy0NFscXOEjpGHgHZrxH6/i7K3asi5abCcm5m8a8F+doB8c4iIfYhtqKPGtrS8raKToJaJioiJoqebkabBv5OHl5yfmZeEmI+QpJCJmp6ysbSekp6ZgG9jZX9/gZCFhnh2woRjc2K5hHmOlYJpeHFxt22YiX6QiYCAdXNfZ66lkH6Cn4io0oGLlJF04Yd1dYWBj2NydGRvZm1hkHl3aZWAmoCic4Jja5O9icKaac6FsYynk41uqn92dHehnLupwrXI6nzm0bDWeoG5hKLVlZaxubPJhnvazODnmYi2tNmSz8P789+sxKW1yry9w9TQt7a+2IGjk5enorKrrsPqoZGfkpKUoYyLhph9d37jdXqMcnTDduO8sL66qaaiqJjZr6OIhYDb67arm7DIrOOnh9zmgYWIlpOir7a7tL2/1IyXl6Z6iJTBhYfWsHnritqOkp34xZ75hZO7loCkoKqO6qurz5TXybSCl6qjv4KZearJm7HcyIrFg26CeonqZnmMha7Vss7h3OPI7eHJod/w9uyg4YWJoJCXweDWl4LtxYuTjqDt9oDgjYiQpqih23+J+J+E94P146aiye/l/omHtqyJkoeQoaWsqZXEecasrJyTkputx3C0vFhiiXOJ3YWKhnV/0Gt3nIyBvaSRjbyYvWTE5Yevj5vFy3Jta227uc7Hz8jQwcWvtczIvHB9gHR00N/BvKCTkazJj9Dff3NonpaWlJG0rYBoVXGcmICcVnKgcZyQk3yla4d4i6aYhnpum51656hpcaeAd3JarmSHr8Saic13aKOeZ6OwdpLg4ork2cW1ncSgh57T/dPjvoiAqbnIw9Te6vjZ94GTof/6ysbxi/GEj42itIFef4WGj42TjJSug3h6qWicb3SLkdWqrZmq4b6o0YDacKWxhe6qjWibZ6VQnYXBypZpm4aNrXlvxH9xt7unkoF9kFRVyYjZeaidp7Z8yLOzs3Z1mLV8db6jxGGqg1OVZ2ONYotuZrvLcLmZurfBkG1+cYzQYoCWjnWOt6m6jaqYiZekkG68alyolozkol55mnh1gJKcin59cqx1eIm83IB3kXV7VW13bXxsdm1LfFFLZ1lSVWJ1hF5fYVN/fYt7VlZPeUaAT25oPlo9U08yTC9NMjUiQzczSTs0YUiSWWKvZJKheUQ9NyxzZFZPs3xsdHJzuJWclZCMiqq0xL/MzsOupbi8x6+1oqibqKmXsHWTlHpubcjddX6Kk3lxiHRte4B9ipSdol1ZYm2qo1JUVFhYXWdqZ29tY2FfYWZmYWBjZGtwenl0d3JyeXZ6gIeHjZCNSkySi4uFjo99cG1ybm93dXt6gYKHhYmOjoSDfIKDenR6cnl2cHN3c2ZlcnVns7Zkt7FaW2F1gIJ7dWxju4TLfZadVqadVJmIiYedU59hW4BcWG1zbHVhno+rn6SjmZGFkYZ8fHt+jJKMg4+rq4J6ho+OhIV1h311gnZwfXuHg4qDd3t5Z1dLUGdpanZwbGdiq2VTYlCgbmZ5d25cZV9clFqKfXF5alVOTExEQnF0X11WaUNWb0VPTU4tVjAnO0c4NTczRj8+ODU5Y1ZQSXRXWYBiSlA9QWBwSnNZLVpUWE96RltFUko9MTo8NERBWHVTYTVRSVGJTTxdPVSge4CckY6eXFx0YWddT1NtX3I+dl1wcmlmb2BwkJmNfoh3XFVddEFxbGRyiIt4eoi1k3mJdoaYpJ2ZnLCHgof4iZSqhobmhMvBu8m9o52ZqpTgtZh8g4Dc6LCOeaC6oOGif9DBXVJXSj5OVVJmaWJ2lE9aV1MwMD5tTS5RTjuKcHlLdpjTdjJTKDtHMzNFZlg5WjUtSU5ma3RHUGB1nkFlQmqSdWSKYUt6U0ZPQTdnO0ZOTG+McZm6samPqpWEY3F2a4FzjEZAQUI6OWyEe3bYn0M6PEKLnIB/P0BVXmpafUBHlWtkyGG0klZVmrKYpU5ZcnFPZ1pkfXeChmmSV5KEhX5tXG99l1GTkS8xTU1BijU1NU5PgTtOWTY8UVFGZ4RyUCyIn12Sd4OmsWFeXl2lqbSttrG4srCkqbu1pmFrbGJjvcivq5WIjrTRn+bKaUNYioJ6bGWEYYA5MkBjXUqCO1FgUmFSdmWMWXZnbXVCNEBJWXpk8KpWV2ZORFZFk052d4xNOXhgS3l3Xo+WaoO+xm3FmYqDgpiYi56doJGXmHFYfai0pI+Nj5WBmFFUXaHCpr22TFYmJDRInXtWQCkoJCA6KSk+PUM7ik5aR19zVmVmZDpEZkVCVIBmMjwzPVc4LDhOOnQ/fU6Hm3BBbGdmjU9Mc006XGRURDlLOCRCbDRZMWM/X2wugIBZf01WVHRSS4+FfEB8YEE5SDlWRFUmL2RJWIdPhXY1QjwsQj9OOFdJd0RXg3t/eHRlWFI+NTlBGyE/OzNfbjY/bDklKSs/W0xfRV4pYGOhzwF8jH0CfH2HfAF9hH6EfRF+fn59fn1+fX1+fX18fX59foV9AXyEfQZ8fHt8fHuEfIR9hHwCe32Efpx9hn6CfY9+hH+CfqZ/goCrfwV+fn9+fop/Cn5+fX5+fn9+fn+FfgJ/fol/uX4BfYR+AX2JfgJ9fot9jXwCfXyOfYR8hnsLfHx7ent7fHx7fHuFfAF7hHwBe4d8BX18fHx7hHwBe4d6gnuEegZ7e3p6enuTegF7inqOewF6hXsDenp5i3oCeXqEe4h6gnmNeoR7E3x8fHt7fHt7fHt7e3x7enl7fHuJfAF7hHwCe3yFfQR8fX19h3wBe4V8AXuEfJJ7hnwGe3t7fHt7hHyKewt8fHt7e3p7enp7e4R6jnsBfIl7A3x7e4V8AXuFfAF7iHyEewV8e3t8fYR+hH+OfoV/hn4MfXt7fHx9fn1+fn59hHyCfYV8AX2JfIR7h3wCenuHfBR7fHt7e3x8e3t8e3t8fHt6eXl6fI56g3uJeoN7hXoGfHx9fX18i30BfIV9A3x9fYx8DH18fH18fHx9fH19fox9A3x9fYV8DX19fX58fHt8fHx7e3yEe4R8Cnt8e3x8fXx9fnyHfQN8fH2LfAF9h3wBe4d8DH18fX18fHx7fH18fYV8BX19fn17hHwBewICBACAzpzS3oTc7tP0kaXLy5CP0dDBt8qjkObcrpeojpeJqsuinoewn6Kzmv3NyobdjJaE95GmtsX624WF4uaEmqv+4ar5uOqEnumthZCH64vEtJLNl4mRf3l/g4J7hYB6eZaQe4N9h4ZxeGFgbHZzgaSlssSQvMe3tJXn9IqQjpS3s6yAmaC/0N35+ZWfkpOKiYqPiYeZob2+m5+kmZ2fnJ6enJuhpayglqi4vbvH0Nrr+IKMjoqHhYH//vLo1bKnrrq2vMLY6fD4+ISA383Cu8fOwr6npaa9q6Kwqaaqko+K8vSDhv31ipiYnKGWi9W72emc5fz78fDX0OC1z93X5+eCm6GAmJKTqsKg86KKyOeEh4XM+brBr9S1sKzBu7jV5drsyc64x9bM5sXG3dXR1NzPz9Xh1s22raWuuMyopZSkxqeGiP+0h5Wg/7mwtcmstYf/+4LjteeD/azPy8OPnbGS+evGj5Od/brlvbr536atmrL70NrBxK+SnP6kx9zDzcfS6IKA54asvv650++Kj8ew5fDL+Znl7raMwd2rl5q32J/b/5njg/6ghra61vCQ7eibpbrH1JuorJjefe7k0MfI3YHz5cbgwsS3v8XBw9y+r7yXjrPEd21yfZSqnYmqpbCZqX3VwtCbrYl7ucWyl4dudq3R0XXzlK3M2MmrsqKA0qmJlb6A8cqa1vu5yb+foajueXd84dyCgpCkq5q1fJ3Jg6GkrKPpgrTV+b284Om8f5bwtb2OiId0j4v0+ImIyoGpkKd8rYyS2unYh6H3oevlu6LSv6yl6PDSj5P3gY2dtYzu39Wx/9DZhuLbxuP4wty+fLKfn5NxbY+J2HN2x6yfr25ydLGA1LKOjZ62v4OW2NTbn5adj4Hposy/uM/cqp2flZaUh4uovaqomebF6beSoaCzz/CM/JGcrv7msMOK4KS0roWN4qGLoNWA5d/r3Ley9uONjIaF8e+NjpP32vfeztLG0Nri6Ni0vN+AiIf/6a2V6IrR+POeotaEvdOhwIXjra/71IWAgM2YndXev9jjv/KowPvXs8qv7O/JjLXBuJix3bylt7Syz5fdm87xjMjDqPDy04uFvNjcjebKg6/s1syeetiuporCnIyJkZt0mZ6SgaCVl6XEf8SFn5SCs7WGf3qygYLK5par74bsv815s763oo7s48zt8Nr8v7mohrCik/Wh/JSAxpegz6uLqYaVrN/OiZ/huuif4oSQiN2q+Pb/l9nLiIrh1/fCvbznt57DpbzBn7qArYyGzeLxiaefgsTQi6iu/PmSiMiUtILd2sa4m7bup+XSyJu4vcrFk+XGmcnRjJLU2qnYhKGNhfyPjt7MvIWFz63BvImUoeeK2p7+jMjIgfCAsoGwwG2MtJKpaYN9fXF4l5SVl6KXfbe2j4GPb3BmiKBxcGp/cnJ7ar2djmGQX2NHj1+BmqvdtHJilrpngJz43p/Ul9djbKiVfYt61Xmpm4DGo5mmkIuRkpKOmZGOj66lj5aRnJ+JkHh0fomEkq6SnKl8oaqcnIPX5H1/f4GdmpeAiI2msrvS2X+HfXxxa25xbWp7gZOXfYGHe3+AfoB/fXyAf4eAe4iTlpSdpay6wGRrbGlmZWLBwLizp46GiZCNk5iotbm/vmVgraGalpuimpWHg4KViYSQiIiKeXRxyc1rb9bMcHp4fYZ8crql1OKOv9DNxMKwrbiarbSvu71qenqAd3N3jZp9wYhwpMBucW+t05+hlbWdlpGfnpyuw7nKr6+ap7WqwKektbKurrWsrKu8tKqUjoiLkJt/gHiDmH1pY8WEZXZ+z4+Ii5aEjG2/uGSyj7JluYGUhXphZnFzwqiedX6Cy5i7oJvRyJCDhJK0n5SIlodtbrWBgo6IlZCSqmGApVt4j7iHt7JsgKB6tsKn24K/xZB3mJx+Y4CZrHOx+5rdh/l4ZZeZ085v19uQk6u4x46Uh4jUhOb33dHc53fe4M31wLilrbjHxcvY2OG5vd3pjoCMorbLv7PRzenHy4zixtegs5B+wMy6nYxyd5u/2XfnmbfX59S0v66K47STnsKA1rKRxvetuLOMmJDRgpCN4e+IkKa4vaLEhZ2/cXt9iI3Xboyu066z09KtgqX0v9GooZ2FnJD/8IKO5Y6glK6DtoR1paq0dIbNdqG4npG+mJCz0tK+e3ffbWR4hm7Mv7qk3ri6ftPOxdvky+nBgMW0yLKIg6Wj/oqJ6MPV3IWMk8KA7caNh5y2vY2m0MzOpKCnmYvxncjTyt3qq6ChmJCMeIadtaGUmeK43ZqMlpGpu91/8G9yc7nUmap16q++p4J3y3p/f4NVqcmsrKKdzrZycW5txMd0dXjRudS9sbKrt7vCx72gpsNrcnPayp6HynW41daQkcaDnKB9n3CyhY69ql+AY5l0g56viZ6tj7yNiOKbcL+VsayidIyPiHmOq6SbjnV6gH/NeaTEfKaUjqXRsHNqkJ+tdLqLWpTCwNm6jOirrqTYybC4ybyJs8qcgq64z97ro+6gt3qC0NCYhIWdgoPb0XR8mnPpvdaBlMC4m427moGlqZ6ig5mVcJqIlvODwXSAo2VShqN+kGFtZcOvcWy0g7R+umdybayFz8/HZbCdYVWTqreBgY3DpoiHgJmhfItdknVrl7ewb5CLbpaxZ3pmqphmaYtlh1GwrpOVgpy9jKaZpG+WtpmJhNW/m7Swc36ws4mla35nZ7Zga7PPx3lohH2tinZ0eqVpqXzffL24d8aArnOnoVtoe3GEWHNzZ2RfYGBdW3BeYZGRdWtvTUhFZ3tNVVBbUE9TRmhZPjRiQkQrRURNQTpAf0s8eKBXbI723omlfndKQHBuZW1tymuUhXPGuLDBqaOoqqWjr6emsM3BqKeouMKusJmTl6KcqLqAh4ttipCHiXjP2XN1dGyBgIWAfIKSm5yyvnB0aGRWVVdWVFRhZGp1Y2ZrYWVlZ2dnZmRoYGZmYGtydXV3f4OMj0lMS0xKSEWJiYeLg3Vub3RydXeBiIiKhkVGioSAfoOJgoBzb2p6dHB7eHd5a2dnt7VcX8GzXWRia3hyarKf6eSDorCtqaOYlZ+Mk5WRlZlTXFmAWlxhd4Nvp3RlmKNdYmKdvY2Nh6KLhYSOiouZr6a5m5uKlZ6WqJKLlZWQkJOLioahnYx5dW5sb3NpZ2NxfGVXUKtmTmFptnhvcndvcl2XkE+QeJFPjWZqWk5BQ0Y7dmtcR0lBgWqKUkxpZkoxK013WkdKU1E+QV09TWBgXFtkc0CAeEpZa3FVbm1CMUZJbHVba1RvZUQwSU9IMyErPDtYYTpVMlk/MU1LZGU9mJJyeoqNkF1qV05+Qnp6hIFpd0aHgGZze3+EjpeRfXh2a3RXRFVvXFpVXn+ninGUlJ52gWrCzN6tzK6M2ebUuKKDgpO7+YXQnsPx+9+3wbCQ7MmUj6mAsqOUwvGcpKJ9h4rDWVRTj4RXUVhjaGJzOTtSMzg8Ni4/LFZAT0lOYl9VOEa1XUE9MSkuNDuOvWZQcDpdXlRFU0JGaXaBVHCIQmh0Xk5iX1dao41rS0Z8QkBNWUSCiop5soSKXJGLj5yRa4SDX5KEa2o/OUI9kWBqknZqbzhCSYyAmXVaWFdxfkFcqLy3pa63pIrCbJWHgaCViWpuZGJrW2Fyk29zVmR1eGhabWd6dJNRjzwyOm2WX3lFZ0Q8UTVSezg1Lzg2UU5dcnBmn5dgYF5dq69hY2a0pLqnoJ+cpqeqrKeSmrReZGXAt5aAtWarvcCDgLGHh3pgfWKQY3J/YziAKVROTUhfWlWDVGlfZrt1ZaZ9nW9aRTlfVkFqboSbSU5ARFi/TXV0cY9bRE93aTw7aIODXLSAUHymssiHatWboIu+kIWDkZNkhpqojqGPiZObQl1Aa15ncU02Oi1SKixEdU5dXzZOU1AkVlhJQD9+h3p2Yj9fW1dJQFlBJzslSDyAYzonPT8rORs8RWlAMjGLZpRNjFJTV4ZlkoSNO2lxMyJQTlBJSkZnPzxxRmJmWFw4ZE1ZhINlSlRXQmBcT2Q5Qk0ZFFAnVkhuam9qVXWCWWdTTzkubFVLOIpdV3h9Y1dOY11zRkk5PFMgLk5kVD5ASURDRicxK0tQhUtkYJyWZa4JfH18fH19fHx8hH0BfI19hn4BfYZ+hX0Ifn5+fX59fX2EfIJ7hXwGfX19fH19hnyEfp59iX6CfY5+p3+HgJF/goCVfwZ+fn9/fn6HfwR+fn19j36Jfwh+f39+fn9/f7J+AX2EfgF9h34HfX1+fX19fol9CHx8fH18fHt8hHsBfIx9A3x9fYV8Ant8hnsEent8fIZ7BHx7e3uIfA59fHx9fH18fX18fHt7fId6hHsCenuGegF7oHoEe3p6eot7hHoBeYl6hnkBeoR7hXoGeXp6enl5h3qDe4V8Ant8iHsEfHx6e4d8BXt7fHx7hXwFe3x9fX2EfIJ9h3wGe3t7fHx7hXyHewF8iHsBfIR7hHwDe3x8hHuDfIh7inyCe4V6l3sLfHt8fHx7e3x8fHuFfAF7hXwIe3t8e3t8fX6EfwV+fn9/f49+g3+FfgF/hX6GfQh+fX19fHx9fYl8Bnt7fHt8fIV7h3yCe4V8Ant8hHsVfHx8e3t8fHt8fHx6eXp8fHt6enp5iXqCe4h6GXx8fXx8e3t8fH19fH19fHx9fXx9fHx8fX2FfIJ9hHyHfQN8fXyEfYJ8hX2CfIZ9AXyFfQ18fHx9fH19fXx8fH19hHwGfX18fHx7hXwBe4d8BX19fXx8hX0Bfo18BHt8fHyFexR8e3t7fHx9fH19fH19fHt7fH19fYZ8CX59fHt8e3t9fAICBACA772oxa+UpfKTrMnKkI234+mauqSsqYWRzf+Al7C9kJym8Jurma2F5aq7tJ7u3dTq9P6lvOWDwvWIzfXNfqnB0562lNDw6rGElpmSoLu/k6ainIONhHx7fG9mb2pqdYV4bG51eGlyaWlqc3Z8ho3YptDU1crrgPLmv5aK79ngj6iAvrjSsMnzk6GbkaOeiezl+YKQjIHs/IiXnJiek5ebm6GpoI2EkbjC0NPd7Pv+g5KWlI2PiYuLgdu8wrW+ysvIysjh/4OIkIv+1sXEvbfDvLfFw8jGwLCwn5+mlpqZloSHhvX26oD328uunoGiud/ihfzm09rz4O/h3sDJ3O7ciKaAkIiNhp2E2YSbhYWe89HY9+S/1bm+tru2zMzd3NbZ6ork+cjF0Lq80Ozz3YvoxNH9/42HjIXIn8nNta30kaOIjbKgm/eLp7rEwLudkLKUq8eKnL/B4ZaM1J2B+rWv2Pyfrs7Am9W9suOl9LWjyNCA9du0uqq/k66xxYPxxMSRxdOA3NGolL+MwumK89O/mKvUw+eMlISYxJ+qn5y52JXIo+366YqvqumPwIXjqN+Vy9TWteO9se6mobvC1b+14vaA7c7C5/LRzMzVwaqqotbDjoNq1r7EbW/SaHuChoFzhKlxe4GK4MTfmJ6qtaOD3sGrlnmFjqC6v9TJooXht5uWpcSAr5uGuYfD+uuCnqyB3MVpeoGYi4edl5ul67mOso+d8ruJgZGV6bik5eq78bmI4bCsmpetprDCsvzk1IDHqozrhpLp+s3yhMHV25aDhZOZjrCG/P6AhYihrYegoYrkvMq84vqWlZjpr7vMw9PDefXKiYht0tN+iYdqZWXKrGeP2M+AzYSG6evu9qXl5L7xkITs642H4Mi6f8aLoqWaoH7ngpSorLSur4C1oruesJyhwPDo9Mn8mrnFzKzgh4O6mrzStO6syvyDh5e88Lf94oWA9+Lv5PXn2cT1wLnMs/zducfL4NnBreeFhOnIwJWVgYq01IDStYSHwLumi/68g8iGw8yA19m9gInvwfHJupr0hqD/yO7ggMaavZef7JXq1M2A85+ZgaWi6tOw8d6Ii+6IpoOonbbFlJfMmIX2v5DviIe3u6rieHKJhYSliYGIj4eIdKmqyZqb2pbwm3SMhZWSmp3WqIeyjpKFzMiesbX2hqfbz6T9qcCv5djTr7mWl4v5ndKAxuv58afK6omUh+Xt5NbFysGNwYKQkdulloySxZmR2P6g2JqCr5qspeLvkq3WvtmHmsi0hdmGn/Xr44Pmv9LI+ob/mIWE9pKLsNWf4JOPpojCgIrY1uSNtYbtqYi/wcGmhcmKpo+c3riJh4mLhaTg99uexK/DqIDv1uvbz7Deo82AxZuNsZ5weLprfYeDb3CZuaqCp5KRkGF3ospodIKPbn1zr3V8cYZgs4Z/d2mhlYqcpLyHodh6s65infDEfqq8x5ieea+6pHptioqAjKKmg660r5ail4+PjH13fHl6iZyNfn6Ljn2Hf3x7hoqOl5rMkayqq63GasvBpIN63MjEfpOApqC0lq/OeYSBd4WDdsG2yWp0cmrD0XJ+f3uAd3t+fYCGf3NteZObpKWst8PFZW5xbmprZ2doYaqUmpGWnZ+bnZqtwWJnbWnCpp2cl4qSioudm5ycmY6Og4OGfIB9emtwbcjLwGjKvamVjnmRo7y8bNO/r7LIuMG7uaGqusG0boCAc25yboFqsm+BbXCDzrKwzcegs52hnZ2Wq6e9vLq2wHTC1qumtZ2cqbzIu3TGoqzV03VydG+vhJ2gkIfHbnxiaYp4dsNqho2NjIx5bIZrf5dze5KTqnZrlHFZp3h1lqZ7maSjeLKam9ub36R3lJlerpl/hoacbH93f1etophblY+AkZN5bZhzn75st5WRc4GUpLVmYWSBlnqEd4GWo2WZgN3YzG6DgL5rn2OvirR/utDHgqiOi8iKh620zryz0M1s1s3M6Na8xsLJv621tOrRpJyK7t7qiIT5j56su7SVr9uAg4eO4r7in6OwvKmH4MKmmHqAjaTByeDTq43twKOfr8uAuKSFo3O69+B5h5iD9+mClZm6n6K8rZ+o5Z5thF5vmIJuZmZryZiQ28Sl9dKZ3r66l5mjn6LEs+HPzIazmZHpfHCw0LTVbJ25vnFhfIeIgJRx3tJlbG12hHF5fXXMsb6wwemAhIvgrL3l3/DjhezVoJyA+vOSta2Glob2z4nG/OWA8Z6D5OTu9Kjn5MTohH7j54mG6NG+hNqPp7GcqIPmgo6uqLOepnmvk6uPro+gyeLm9MP1gZ+snZXPjJPGmrzBr8ubtcZebXmcw5fTu2tpy7zFvcvDtafOp6GynNXDp7CvwMCumsRwcMeyr36Ab3amvnC+pX+EvaOFdcyRXp1mmKuAt6eKVVqbkKyTinXOYoDGoc+7WH9zg3FxmmjXnqpsxo2EcKelzLqb3Ld6caVycGWFfYuWdoefZm7YvI7khYeytKHbooCMlpbBnI2YmpCUisnP67my+m+6qYmmfHlrgH+5dGR+WmVkkLR9cp/0bIatkWXAdnRwkpmreHtxg26tgpeAi6eiy4Kau3BlWpnKspuLkY5vnmdzcpB6dGdzbHBypcJrsXVlgml9eKWSVW+fi5Nad6GYZah2jt7Pv3GseZB5qkfBdlhZrWFofquDpnVlbWiWaWmwvtdmjGzPmHW5v6yWbqVqgnR+tplze4iIf4660LuVqpahjGaytMjLw6fQibCArIh5fHlmaKVadHp7TViMmIJ2k4N0dUthdoxMT1xrUGNQhFxbVWZEbElNVUVvaF5nc4pcgZZRcohGabnBgKSuq4Z9bquMgGpjhYJzf4+ReLzNzbLAsKqsp5aSk5SZsL6omJOtsZ6onpmYoaWpsK7BfYqFiJCjVqefjHJu0bmscIKAlI+hiJe1bHJvZHdwYZ+VpVdfXFaksF9naGRlYWdnZmdsZGFcYXF3e3uAho6PSExPTElJRENCQYR3fHZ4fH14enWBjUhITU2XiYOFgHN4cHODgYGDgXp7c3R1b3JubF5kXayxpVaxqpiGiHmImammW7apmJWqmJ+eno6OmZ+TVFyAWF1eXW9enV5wY2Bzt6Gcua6NnouRjYmElZCmqaefq2itw5qVo4mFjJato2WrhpO/vWhkZmGZa3d4cm6pWWJNVG9iYqFZcHJsbW5jWWlTZXpfY3J0gmBUaVI7dkNAT3BNT1VMT21uaX9NX0s3Q10+c1hLTUVPNzJETzqCjII+dmGAY2lYUnJRaGtJc2RdRkdKWV83LSw0UzxBOi09UEBHN2BqTCo2PEQwRjBnTnZXiJWUTl9gZJxKUHB7goZxipVQiHpvlZ6TmYuLhGpvZIhxUUxLrKaNR1arT2BmaWNSXX1db3+U88v6ubHE38if/NKqpIVxiqnR2fHpupT9y7impL2AmYZki27A/ddzeoVjmX9ETlVnXVJYW1tngFAxPCw/UDckKi8oWTo0UUZHnEkvajNEREFiZGh3b5WOaTZ5cEh8XEdzmnikUG1aS1JGOjQ+OFNQn5dESEVSWExSSkmIiYaUmK5bX2OcgYp1eX9vRH2BXWM/eH1LS0s/Nz5xZzQ7e5aAiVRWmajB3qvk7trteXba44SB9NqzcYhpc3Vcak+eZnF2enx2Zz1YY3NieGldaIh5gW5pVmtjSFR3KiQ7QVx1YHtih343PVR1on+1o1pZraOpoq2pm5GymJSjjL2xmp2crKyhjq1jYrGkpW1uZWigrmSymnt+uIFsVqZeNW46Vi+AK1hILCdRRV1aVVSJNVd1g4huSVstSFFKXj6mYX9ReG9lZL6rj3hgsHw6NVhWSTtlWnBnYoB/UlWxwpOzZGyfrIGfdnCCjYSUfo2Rn5eUVlVKRDc8a2WgRh8sSk5ISz9lV0dcNDstb2hcUFVtRUxhWFJ2TzpbandRXWNDMTJSSG2AYEFSkEBIRStBRFBccnZjaHJSb01hUXZiXjFST0dWcmJBVFI1RjZdV3R9SGl8ZWA3PWFWSmsiOGFmd0ZbX3BUZyg6MTApV0ZJSkQvb1dJS0tYMkl/jHQ6ckZyWkBbS188PFIxVUxCSlBCRklUVU13e05FRS4rO0J9bHGfvoa5bpkIfHx8e3t9fXyGfQF8h30Efn19fYd+AX2Ffo19CHx8e3t8e3t8h32GfAF9hX6gfYZ+AX+FfoN9iH6Hf4N+hH+Cfpd/ioCMf4SAmn8Efn5+f4p+AX+Ofoh/AX6Ff5N+AX+LfgF/hX6Ef4Z+AX2HfgF9k34HfX19fH19fYl8CHt8fHx9fX1+i32EfAF7hXyEewl8e3t7fHx7e3uLfAF9hXwOfX19fH18fXx8e3t6enqEewN6e3uHegF7knoGeXl5enp5iHqEe4N6hnuOeod5g3qFewV6enp5eYt6BXt8fH19hnyHewN8fHuQfIJ7hHwBe4R8gn2GfIJ7iXyGe4N8h3sBfIR7A3x7e4Z8CXt7fHx7e3t8fIR7hXwGfX18fH19hHwBeoZ7AXqHewF8jXsDfHt7h3yHewp8fHx9fX5+fn9/l34Ff39+fn6EfwN+fn+Efol9hXyCfYZ8A3t9fIR7hXwLfXx8e3x7fHt8fHyFewJ6e4Z8DHt7fHx8e3p6fXx7e4V6gnuGegF7hXoMe3x8fH19fH18fH18hX0BfId9DXx9fXx7fXx8fH18fXyJfQR8fX19hnwGfX1+fXx8hX0BfIt9BHx8fXyGfRp8fX59fHx8fXx8fH18fXx7e3t8fH19fXx9fIV9hnwZfXx8fH18e3t7fHx8e3t7enp6e3x8fXx9fYd8BH18fHuFfIJ9hnsCfXwCAgQAgKSin5ys6bCYm+Wau7LKiKakyI6XieSAocD3o7royceJuKaoos/Lsbyip5Om58SN9Jby6Le5pYOBjKKFi3uHkYncvoitjX/hgJey39Csk4+QjoeAeXh2epyUjolygoaVjn9vcmNlcGZocn99doORsJeZn6/16PLugoXYybnHdJHlgKawk5ep7puhlpSSk/LN39r6/ImD6fTiio+Vh5Kbq6+yqK2morO90t3n+P+DiJGJj436/YD56c26w7azuMLEyNfe6/uAhY+E5r64xsfHx8jQzb+9samrqJqen5SXmp+Nlon1/fPw5PTr4tza3OTb9fj07vLV1/bdu83G9+Xe/IaZgI2IpKmqnIyZ0MLvpZiplPLo3YXY0bnKvsXPyMrM3+rBw9nO0NK5pL7Nyr3KnL3IyPDm8/6N2L/Xw8GzjYqMmvSnn5DFxOb/ss/Pp4TBqsjDn9HO6NuDga7Wg+uy4rSYgZDFjuWV+8PnjaGqg7ei0ur+zd65sau8kayd17mXkOTQgNLr6MaOlqGjiOyEpMio4bSrx5HDut6XxMvbzZmm2/vzm86j5IeD4qWJgOmXoM2lhdGt7KmtkOL3r7jC9uDy5LXKsKKpoouPxbzm0NDneq6LfNm7y3TTs6duk2lxen2cz6HLeIZ5ZLSft6CMqHqxs6Duh5igzrq1t52IieSzn7qygKC+0dukwN+h+ovjlIK3t3WUi3KJlJ7ipceQ08Lv+uKZhs6VkpDux7Wa08/nrZ7w+eCSm4bf0vCkquDm45WX4ZubwZrCk+W/1pDAkNezmO6qyKWTgYiA6P+PnJGFqpmcmf+goJSX/OnxeGt3iILxenWxfLuvbXR5sqVtgnBofbaMgHip9KuX9rbtioeIouTfw/TjvqSG75OctsujiIXy5tb3joyhnpnWouf1vovmua7trvmO/PLm9Y2A0Yt9l8J0fd+IzoG7h4GKjYry3oWUgoPq0uiE8d3D2tHQ89HRwuqCmob37IKViISXio2SmJPx35Dq3ay4mJHQqIW/lbSUl5zigNT3go3mnueD0qCx7N62h8+tvJnMx8PQhvy/msfIlN/Qh6PZq8e2zc2z/JXihpTJhpe82JvXkLjLxrB54aDir4SB3XiEkZ6Hi5K3tKSymol9m83XkKLW97LVhqnH6tmctKHGkYSQ2LfA1ujU5tOM/tz4hoDpo67HyL6syevjtausgKycx+KCgIeunuvo6Ia48+z0s8qU4O2/8oCoj4vK/viCnpOxl4yeoreot9CW4IvCiLHthuuH8MikgI+YoqCU7NGJh4y2xOuG97Hu2OySzY+Q64uAhafk4YSQj7Gqr82hjqe7iNfv2OGp6qf0wMCd0qyKz4yY2oac8IOMwu/fzaCsgIOOjoqDtY5qdIhUfJO0eZeWpIqJcaZkjanDg5u7qp9rkHh8gJ2bf4x2eWx2o5dlrHnq4bCyn4CHiKWLmIeVoJLutH2hdXrihqG43cermp6en5yTjoeChqeckpSAi5GhnJGAhHJ2gXd6hZSQh5WguIWEh5PLw8zFam23r6G6dpHPgJObhoaVyH2EfHt6eM6vvLbS03FrwM2+cXN6bnd9iYuOhYmEg5CSpauzvMFiZW1la2m6u2C6sZ+SmY6NkZmZnqiqtb5hZGxkrpWSnaCbnJ6joZaWjoiLiX6CgXh7foBte3PK0MjGv8zHvbmzt760ysnGwcOvs8i9oqulx7m3zWl4gG1vg4iKfnKBrqTHjYaNe8fGuXG2sJqnn6KtrKurusWkprizs7Seip6pp5+viJ6kps6+x9V1uKG3n5mOdGRmcL1/cGaZm7S/gpebfmWTfZiWfp2crqNdWHOJXKlxj3NiU12RdKhzwJbRf4OPZZSDlamsl52WjYqWaX1qmotwcaaTgJW0qpFtanV8aK9riIeKonxyh2qVjaZ2kY2YpGeIqtemfaeJuGhmqJFlYrNtgqShf7WK05uReeb3rKy18eHd0aDDvLCvlYmNsbPf3tr1gbqtkfzP/JP+49mDsY2dpqTL5rbffYl+bLalvqeQrn2XpY/phI+j18C8vqSOkfG9qce7gKnK2uenrL+Q74Pgm5S1yom6qIert6/toLp8j5KdrqJfTolmam+6pqaVyMrxxbLz+ct9gYHp0u+1ufbo1pSe9J+dsnOnccWis29+ZrWZiMuRmIN4Z29ttMh3dHFtmouBiuSPkIuQ+OX8lIaDmJP6g4/ajunTgo6V4eiTo5KOm8CTgIex4qWX6bbkgX+BksLDstbGr5iJ9pCUr8eqmJH+69Pwk5inq5/RkeHzvZPOtKzttOR62cO/2GqBwH2DlsmLi+FwsG6jdWhucm3IuGt4amvBscRsxr6nurS30LS2qspvgnLTzW58c3GAd3Z7gH/Nw3jLyaKnkYq6k3GmfXprZ2h7gIyvYXq3Yq1WoYWKzqOJa7eZsICjj4qXYr6TgKSOfqWhgKbfscGMlryi5HWXXn2zdXuYlX69foiwtLF85ZvKp4F53JePqaycoJy8ysrZtpeTsOX/o7+9pKDeh559sqFnkXWZalhlpoelnqCxxZ9fuYqcVVKdbHaFm5J7tMiuk4GDgHt0j6JuVGVuebOkxXGOk5Ote5Bup9CBplhcWk15uc1mbnKCeXpxa3t6foxjp2N6X4rFW6VYrpqObHNvcGBXpIBQU2WRgp9ju5S1mp1boWRmqGZid5vl4Glxc6ibobGGbpCbcZ7DrbiU1JPiuryIuaRzvoKBpXF+xmp/t+TYsIKVgGh5jHhxoIdRXXFIdmanhJWWjJSIZIBReYqbZH2Zk4BYcltjan13ZVlOVTlTcm1JfGXs5rStjmBfbJKPp5imr5v4rWKOa478l7jM5sizrbGxsbiwr6KdocOvp6qcpaq5ua6eoYyTnZGUn6ymoa60xXJvcHyhn6uhVVmZlo23gp3CgISOgXuHs21xbmxtbLOTm5iytV9aoKygXFxiXGNob29xa2pqaXFxfoCAhYdFRUdDRUJ5eT+Ehn51eHNwcnh4fIKAhotGSE9QjX58hIeDgoGFhn5+e3d4d21vcmhrbW9camWxsrCwrbSxpqeeoKicsK6soaaVmaCijZKInJiVoU9agFFXa3N4b2dzo5CrenR9brKvpmSfl4WOhomTmJWWpbGSlqihpqOLfIqQjYibeYiJjbWorL1npY2af3VwXExNWphnVE1/gZSUZXR7ZlJ2ZXt4aXl9iX5GPlJXQnpHU0dBNztkW4BZknONND0xMz5OZF5hWVNDVE05Lk1Dbm1WW3RngGZ+e2dTS09GMXAtRlo7VFFISTFBN186VEdKNykpP0JhNU0lRS0nSTEvLGI9TmtQRWZcnWRqUIOPfIGOuYeakHRwbmh+cV5gjXSfkIZ5SnFNXamnl1OmiXtOYktRUVhrnIe4gJaWiMSx18anzpCToYT9f4er8dTLy7Gam//Etr60gJScpq2ClLeV/oXbdlmOgUhZW0hOV15yRE86RT5LWEswKUIvLStUPTs5WWR8PDBxj2NKWUVufo1EPFN6mnRJckI/WD9kSGRWZUFbRGlbP3JUW1pbQUtFfYtSTlNSd2FPY8J2dnpzvK+kPDdLTz+FPjpbWnR6aFpHfnhHVEA0VY9wgFh1uJ+d2brdeHl7g6ainriqmo6L+4eCjZp3Tk2HjZ62W2JwXVtwXIR/gVWLdHGHWHk8goCCXD47LCctTE4mMW9Jg1hqRVRcYVqsn1tlWlummalbqqWSpKKnt6ConLlkcmW6uWNqY2VxaWZpcHG6rWq3u5yfjYmqeVR8R1Q7OT0/gDxlLDtUN0kzV1phb2lOMHBrhlR3TD9TQn9hSkVSQ0VoabX5napfbah+hjxmRFB1Z2F7aFieZHOYsNSI7aywnHForVVRU5mJgYS4wqujlmAvOE1CNFWmb3ZlNVs/XF5JZFVVTjU1Py1Eh0pdh4NTm3eYMSlhTFFqZT9RS3FwXUJPgEA1XmpALTpLSWRYc093fHuSZ3xHkI9oiERJSENdhKg/UUpMUUJWWGdNWHBEbUVlPFNhIlpEUkhAJz5CPDRGTUQqJEFUUEZGjGJeP1dGeUxTbEdEUG+QmV9bOWNUOFZTRT9PO05ZRFxffmSHYmFJiYM1UC9GUDNfmU9jqcfAk1x/DX17e3t8fHx9fX1+fX2HfAZ9fX18fHyFfZB+gn2JfIZ9A3x8fYR8qH2IfgV/f35+foR9hn6Gf4Z+BX9/fn5+lH+GgAN/f4CPf4SAmn+dfop/g36EfwR+fn5/oX4Bf45+hH2QfgR9fX18iH0FfHx7e3uSfQN8fH2MfAF7hHyEe5J8CX19fHx9fXx9fIV7BHp7e3uXegt7enp6eXl5enl5eYp6hHsBeoZ7BHp6enmKeol5C3p6ent7fHt6enl5iHqCe4Z8gn2EfId7FHx8e3t7fX18e3t7fHx7e3t8fHt7hHwLfXx8fH19fXx8fHuHfIJ7iHwBe4R8g3uFfAN7fHyEewV8fHx7e498jH0EfH19fIR7hHqGewF8insBfIR7hnwPe3x8e3x7fHx8fn9/f35+hH8Efn5+f4t+BX9/f35+in8Dfn5/iX6GfRl8fHx9fXx9fH18fHx7fHx8e3t6e3t8fHx9iXwJe3p6ent7ent7hHyCe4R8hnsBfIh7Bnx8enp6e4V6C3t9fXx8fXx8fHt7hXwRfXx9fH19fXx8fH18fHt8fXyEfQF8hH0CfH2EfJd9A3t9fYR+A318fI19CXx9fX18fH18fYd8B31+fHx9fX2EfAF7hHwEfXx9fYR8Bnt7e318fIV7AX2IfAV7fHt7e4R8AXuEfAp9fH18e3t7fH18AgIEAIDxgJ3+g9jjjYyY+8WRgf74h/DtupuFjeTP5IrK2fDZtbexu5S4xMuBhtv5yM72qJ93hXjYp4emxdZ5iH56eHdubJX1tnmAnp2glZ2QiIiZj397iKDKhrKykPrT/picnoHDjIx/cmSyYWVmb4B7g4mFvKaxvMfdydL25LeMi57MjoDlgpmEhL6apaGQjOfKxqu00+T49NjG3/2DiZWZpai1s7aws8jW5+33/YKLkJOJ49Pi4NbU2NjAsre3paCcprjU5PX/iIiB8ti+wru/xMS3wK6znZ6boZmjl5GVmZGUoZuC+u2Agv/47vyKiOLi6/vz8fbt3vDLzO/o9fGD+4+JkYCPi6+smffu7t3L3ZCwtaGlloT/g5WNjZKGg/CDio3ZysC+v9u4srm3uNjUmrmntrm8zsmhoaqjx7vJs5ugoKinqJqb74H25e+dm6KbrrDu37ncv7u/garmuKCe0brSr7eizsif6r2W7q6+gZilgr6Q9+DXzOPv3Z2OypbOrNHS94DKk5i5j7Wfu4q+37Cm9fuKiqnghdaLldaY/ImrtpvoroXCxOSS2YLP6cXhj++UufCP/tXfg5Obqpjo3t2vysGluNSvn56qzamWleCEz6yYe9Cvvnl3wWtlooZztHeXk3PjwszHrr6avNB1r8l437uT14SYu8XRybajoZyF5dC/zYCqyX2SrK+F3MOB54OUtf3o1nVwhq2OseT6kKuww8DBoPvXj8ug/+rT0LDZiaaZhpf14IiR6fypuev4pKGYgvDkqtrLuKPWntq/ovy5v/bSqa6crpagjJqbnJmuga3Khor6lZmPgn/Xvra+2oNveKGoinuLhHp02aiSwnB3eIGNkICWhXu/xuqHm4bsrfeai5WM97ahqqKbnKOinOnIv/Lu4J2Zq32a5vnzp5WnorKD5IHdkKeY9bOl4I2zh9+y1ov+z5Gd3cGA+PuBh4mG483J0brv7bvi+ufa1tjVp9PvgvLj/ODkj5adrbecz6u4x/H39/v/zInRytqrstKipJeHnYD42vmJ4dTd/L+nxfKvzLT7ne6T8cfd3OKjudi/naKpmJeOkqmcjdKEieehroenlpvhprurspKN/fvFdJ7vqNiYl7jBm22TpYy8fqvCl+uYl4u5hIvu5s//mYbkgtzVp7LruNnItNGgkbafk9uE4I3hz6HY5KrM5sTd59SBm4XEm4Cj4sqdmbPCprOO6IvptJX254GXqt+tq+mmv5yX2sqNoqKCiKWIsLDdlcegsu+R75j80eOJgt22mofLr6Pfgti61/m62ae/o4+hk4DetqSbyrKt4Iedz8jDhIfPg+vM/5bluNuqq4WKxo2R0KmA6IWKsNzW6+i6/9WD65e+gI6O9oDSd5LWbq+NYV9voY5oaNfWfN3YpIJbZq2gqWyaorumkpCKj3GOlJdjZaW4jZTAi5t4iXzOmIGozuCClI2JhoR8eZT3pYOSsLGxqK6impmtoo+Nl6fIfaGeguvU84yQkHzHmJSEenHNc3d1f5SPlph7oJCZn6q7qLfNwZ9+fpzblYDSeIl5eqN8g4R4c8KtqZabsb/RzriuvdBqcHZ5g4WOjZCNjp2nsba9w2Noa2xmq56tq6SjpaWVi5GQg4F9hJKmsLrCZ2Vht6aVl5SXmZuQl4iOgIOAgn2EeXV5fXZ3gH9tzcNpatXLw8xxbrq4wc/IxMvCtcGsqsXAxcZtznFrcoBvbouJfMjHybystHePk4OHf27WbHp2dnxybstvc3e8rqSfn7qglJ2Xl7O4haKRlZubrKqKiZGLq52mk4KAgISAgH16vmXAtb54d3x3g4ivqJGljoyQYYetdWhshW2BcHJojJB6tZFqsHaVZHGAXoJhqqOnlZ60sYt1oICwipaUsYCRb3eMa4V1flyDrZR4sLtqYoKgWqlqbadwrGKIkXWge3qkn7Vsr2Clxpm0abRqmsVx0LzCen+EjIzV39+3w7upw9Kvo5Obw52Ei9570L+rhtq+6aSY9YiCz52O/pi6rYX/29nQtb6dvdF4ssh84a2N14GUwcva0b6qq6WN8t/K1IC004aeuKuKzppn3H11jO39+ImHpb+VseHph5KDhoaIaZCJbpxqwsa2t53Oir2hhYvUxYqd9/GSv/HympCKfef3rqWOj3mjg5iQba6Ll9irjIF7i4KLc4F9fYKfbI+qcHfjiYx7e4ju1efz/qOEh7zHqpOnopWB99LC7Z2lo8Kym4CchIrZ4vJ8im7Hn9SAeIJ85LmqsaylpaqqofnQxvbl1aaetIyq2/rpsp6xma+F1n/LcH56xaii0oaCgOmq9ZLbunqCtqNnwsppbnBuv62vsaDNyqTD1sO8t7e5lrvNcNHG1r/AdXuCkJiEtJmirs7T2d7euoTQu9Obn8B8ZWZac4DBq8VQtZyxvo2LnayXj6LRkumP0Y6rqbGIm6qWgIeGepWLkKGOdrmDiM51gWeMh4fGdYF6mHdv3d7BdaLfirWLkrjprIKbrqe6irDGo+qano6/fobp6IytiYPve5aLbXG1jqKec32AeJtraqlUimd4f2ydlXF4in+NsbNrbmSafIB3saN5bIZ9fXxknGyvgmB6k1VkfqmQc3p6ZlpWh4NlfINrcH16d26kbKR3dKthpGS6mL5rXK6OeG6Pcm2ZXK+Tj7aMq4KXemyLcGmji49rm5KJt3KKtK6lfXy9aNG53HOzoriRi3V9rJKSz5t33oCLs8XDzMqhzcBsxIq1eX59vYCnbou+WHlqPDtNb0dIW9bQb8zdlmdASoF+hVl7gpeCenlydFZvdnVLTHmIZG2VdKCClofUkFWBxO6Mn6Cal5WKgYn9tKS81tbQzcrCs7HGv6mnsr3XepeVfufi9oaLiXrSrqSTi4X/i4+Ik6+prq9yh4CGiI2fjpejoIpydqT7q4DKc4R2fJ5pcnNrZaiUkYWGl6KxrqCboqxXW15gaGtvbnBvb3h+g4OKikNFQ0I/b2x+goCAgoB3bXBybGpobHV/hIWKR0ZJkol8fnx9f393fXR4b3JvcW1yaGVpbmVlbm5jr6haW7mvpq5gYKWfo7atrK6nlpySjqCfoqJZpldUWIBWV3V4bq60tqyanWt/gXV5b2PBYG5qaXBlYrRkZmqqn5ePjaqThoyEhJmjd46BfYGElZN6eHt7lYGGemxlZmllZWhkoFGdk55eYWFfanCJhXZ/bG1wSnGGUUdHVkRRRkZFZGtfj21QcEpONEFJQVQ4bm9mYWl0XjpGg2qWcG1rdoBnVVtkUGBTUzxHSEVQeYk4PF1NKT4qN1Q3aTZJRkJbOiE9PjswSSxESjY5K1g4TmhAiG2IUFZUSUuIjHthgHx1cXx5cWx+i3VcYIdIeHNlV6yZj1NUilJMgV5LhltualWopdPdysuhxOKK0N6T+q6T+YGV1uT27NS4ubOX/eTLyoCosWt5iYp+uYtl5XFSYKCkj0lCSnJLRUVFJzY2Pj1DOFBALkMzUl1GRkVQQ05ESmyZYEdDabBnWmeMVnFwU5NuT2lZTENRTGheSnpXTFtiVEhJY15lTF1VVGWAUmN5SVWyanBgY1+dg3KAlUZBRmBQPTQ/SGZ475B0fT02PEtoioCPYEZxd7h0fFmrlrtra3Rz2sO9v7y1sra0pfrOttuwqWlrckVNjYOJSmFeUW1YgjpfPlhahntpZC1HPWRZTDqae2Jtl4lXpa5aX2BdqZygn5S2r5Sst6qoo6OmjK24Zbu0vaqqY2lueoFxoY2Voba8wsvKqYDasNeQk7NjRDhBRoB5UE8rVWFlZ0pUU2xAQ1mrYndHkj1rP1JaWEovLUA2RYqXj5VgZKh8cWxNY1JmXnm7W2ZbelNTncDdi6rOZ4FwfY1TQTR2pX+TaYuhb4NFNzlEMzVrfXF6XkxVJzZHU1lfPGJEVGw5Mj44RH9TgztidEQyVlpPX1U9UGE7RkBSQ4A/SVpSS1tjUVBCU0V6ZVZwfE5QX4ljV2hiWVtScG5DV11INlJIamJbVVRRWn5JgEprSTQ6On1WQilAMUNnOD0sUWhUdWZ4X1lIQjVDaVgrVk1afEpcdHuEQUJkNWVWZTJKQVo9TjxKb0hLpIZPbGZwWl1ga3ZupXdSkn6fel1ajYR7g3yHfQx7e3x7e3x9fn59fX2NfoJ/hn6EfYZ8iH0DfHt8kX2EfoN9hH6GfQF8iH2OfgR9fH19hX6Ff41+kX+FgJV/g4CbfwR+fn9/hH6Cf5B+An9+iH+Gfod/AX6HfwR+f39/pX4FfX59fX2Ofo59hHyHfQF+iX2UfAp7e3x8e3t8fH19h3yCe4R8A318fYR8Bn18fXx7fIh7j3oEe3t6e4R6EHl5eXp6eXp6eXp6eXp6enuJegh7enp7enp6eYt6hnmEegt7enp7e31+fHl5eYR6hHuGfAF9hXyEe4d8Cnt7fHx7e3x7e3uEfIJ7hnwJfX19fn19fHt7kXwBe4V8hXuLfIR7h3wLfX18fHx9fX59fX2Efop9Bnx8fHt6eot7CXx7e3t8e3x8fIR7CXx8fHt7e3x8fYR+A39+foR/kn4Bf4V+hn+LfgV9fn1+foZ9BHx8fH2KfAZ7e3t6e3qEfAF9h3wEe3p6eoZ7g3yEe4Z8B3t7e3x8fH2FfAV9fXt6eoZ7Enx9fXx9fXx7fXx8fHt8fHx9fYR8CH19fHx8fX18hn0RfHx9fHx9fHx8fX19fH19fHyGfQ9+fX59fX59fX5+fX18fX2Efot9Dnx9fH19fH19fXx8fH19hXwEfX18fYV8AXuEfBh9fH18fHx9fHx8e3x7e3t8fHx7fHt7e32KfAZ7fHx7fHyFewd8fHt9fHt7hHwCAgQAgJqpw8OGm6Lu6sjL0MnyrZmtsvn+mfulscfR0+iD2r/V8rzd0bzYxN7v1eCs/Z2wi4HTosbi2oGYgnhvaHFlYGmxiJ6cipCdoZeYkXN+pMrf6YOis6ihprvDuKa+tr+zpZfWydPhjnJpsVhka2V0jLHG48jD08qmqa6xrK2l94J1gI7U4ObrnMrx+OeX/YSf0fWAiIPxgIeD8+b7gpKjo6Sioqy1w97U6vX5gof889630M7FyLy9sbGtqbCoqqa0x9br+4L///LBsrixsLm8uriro5uTm5SVmqKdnZeSo5ugoIWEmZyXgo6VjZeE+/yA4+v78OTg5+bw7fz/4u72h4CCgPr37pjInpKSsM/5/oKwpqaLk5KepKSbmZKBjYD5gO+C3+TXwcDh8Pvn3NDBo5igsaaqscW5sLXCwdnMm4WMnriyqLKBk6ys+P7VlI/pkqusx/T8wKa4/frgx8G0w5fn6IbByL6p47aPo9n4uZfekOfM3vbpy7Obn+a8io2z27jpgIed4cn2xLGypo/++pLWha2Dg5LIvurfzKXo2Za39dCHrtClit2D78e93eXVg4LO34e7z6fI07KNuuChidWhoZ+OqdO15vr4rfC6l/rFp4XWwLC4b3+4as17hoOsfbmazHHZd9/HjJeVoJl+eHm1nqDqfqGrjKh7dsyklouKjOvQgOB5jq/Rz9jPxKyfiujv5r+3gd6I1pO964CNntG4nYyv58bkrcSUwd7QpMW9it2Lk5N/iditmZaK0M3tzI6D79OlrKjkx7CjyL6Dnqusl4SMoZyqq/bIrsO5y9fmrJjvhvbl3PaCiMu3c6G0nIV0wIaP1nmBzXlpvaCYrW6Tj4p2gHWKn9DF3J93gHiAeIyWnqSZkXxziYJ5fniJg4mWoYlx4rHP64G5gOqx5r2vgpq20Pf9o4mQhvSModCb0LGm7Pnt8e6+vO3U7uroxZ+ExqzHm8LT1Mm7qryooqCUy+i93oqFiJeP86+k78jA7e7q/4OJhPPd3Z2Tp7qS7OXmmMiUgIuKk4rp843Q66+akY6Zw+iplZKh45aBk/vn1smNkbCYvpuO7KLkuO6wso7n6Jf+i7n30oTDtaP77c12gv2CpZW2xrrWeLTwo6yZubScoMeYo7GXicDe6IrN8bHYi4jUgO3438WLzsve34+KsqywiujO5fP5qajiq/eNsIav6IbJgJW5/fLi+7jKt8T7jryH5OnB2LPZ1OGz7IGJjdm987ysjvGfj5DAz+PctJKovJakkanFtZu9vO7jzoeM+6ydwrCyiIGb58OrtvXBje7QpOup3MPqs63Yn+bP9q3I/pLgh5LnxbqmxN+GxIiK08e9osvjpKOFkPSG1JrZ99me1ZWegI6drqhvbGyIgHJeg467gnqJk+HFesaEi5yioLJjooyguJGqoZCkmq67pqmEz6C5j4fZmcLp3oenkYmBdX10cHfGmrSwoKWxuq+vpoWOrc/b4XmVpZuUlqevpZOnoaielIrNwcbVkH10ymp1f3eHn7aqvaiks6qOjpWXlJaR5X59gJDG0NbbjbLO0MCE6XuMrcVma2nFaW9syb/OanWBf4CAgIiNmKyktLu7YWW6taWLoJ+XnJSUioqKhoqFh4KOmqWzvmG+wbiTipOIhpCSj5KJhX55fXh6fYN+gHl3gnuAgWxtfH95aHJ2cnlqy8xnub7Lxbq1u77Ev8zPuMHHbGdlgMHAyHudhX2Bl67I1WuPiIlyd3iAhod/fnhsdWvTbc5vwsGyoqLBzdbIurClkYCIlI2Pk6SblJmkoa+efHd2g5ONg4pobX+FwsWse3WxcYGClbe7kXmOxM2ngHx6fV6OkFR2hIF3qnZaZJG6oWqUYox+ip6ZhHh3hcandnSVtpGogF1okoWmjHt7dV2vqWCbYYBeVXB6kLOlooKao2uMvZdaiKKNaqxks5qhtbOyaV2YtGKcrI+xtZt3krWXfsOjrKiYss+kxsjSm96Ni+O/s5706uP4k6HahOONmZvejtK95oDzg+nQkJuYpJ6Benu3nZfZfp+ehaiAetSroJCPmP/egO2Bmrzg18m1qY14bbOrqImoe/SZ1ZHC4XFyhpN9dF1xnKC3dY5yutW/o7+gjOSCl6KCj96qjZSMtMf+2Id709GdnaC/pZGDmZRofZubgm1qenqMhdOrk5+PqMHNiX7We8/ByOODk93EgbTnuJmG45qg842T74iB+d7I65zQ076MgI2itfDg8J93gHuAeY6Yn6ulnYmClo+HjISalJWgq5J47KnD0XK0geew9dC2h52us9nCioODeOhrg9uY05yOwcrCxsOgn8Gvwr+/po56uKK6i6q0taqjm6aUj42KsMWkvnRwcX51x4+Jya2ozs3O2XJ2ctfGyJaLnqiH3drThrR5gG5kbGvAzXOqrnNkXGuDuMh+eop8m3NZa8yvr5lebX91nJSQ3JuyidSxoXzm4YvwgazGqW6ggXjZ2c50hvNuhYCpx9n1htDjmZyOv7CgnryUgK2HbqDdvma3+8HkclaUY7+1qpFQfYB9j09Yen5yWp+eoo6Qd3CVbI5nlXJypHWdgIGSw8CntYSCdIifWo5YmZSNj26QoqqAlEtSVoh5kn5+cbmAb3SLhq+gkm1sc1ptYYCKgnCFlaaYkmldtnt/pXqIaGFzrpqHi8Wacr6qir5/tpnHlZbIlLzD45CG3mi6am+7qrCOtMiF2p+d3cW4ncjxop92fb92voW92MmY0oiOgIeYoZ5dVVBpZlNDSG2pa2Jogt6CXqNrb3+GgpFQgm2AlHeKgXOEe4yVg4Vluq/Km5Xml8n84422ppyVhoqGhYjdmcLSzNDZ3NjYyaWsvd/l5HePnZmLjJyhlIKXk5qSioHIwL7LoJKJ/YSPm5Git8OMmY2LmJF5e3+BgISB2YiWgKTEzNvjjKq/vK174HSAkp9SVFOhV1xZpqOsWWBoY2NlZmpsc4J8g4SCQEJ1cnFifH14enV5cnNzbW5sbGhtcnuDhkSDkpJ5cnlxcHh5dnp2c29qbGhrbXFsbmhkbmhucWJcam9qV15jYWddrK1YoJ+sp5uYmpuhoKmvm56gVFNPgJiXoWaQenZ3i5mqtmJ+enllaWtzeXpxb2phZ2C7ZLxltK2YjZKxusW2p52UfnB1gHp/f4aDf4KLiJOCa2lkbXRyaW5UUl9nm5+NZ2CPWWlreI2OcVxvoKZ+VVJWTj5ZWzVMVlhUhEg5PFBwRj1bRVRNU2VkVExLU6GFYWF/lnR9gEBDWU9rZFhXUzhjSTZoPUY/PEA/PFNfaVJSU0RRVE8tMEAjLk4zXzYsOTxHJTNFSzlLcVFZalhYUGxaU45ubl9HVIp7p52ab5VkWI5pZ1Kik4KBS16eVqhbTkt6X4RjhEihYuTSn6yqvrqXkorIp5nqgZeXjbiMhOq4rpyZmfXagOlygZCtqrmpmH1qY5t6b1trT4pKazU7TCUpK0M+MTBHYz5CNUAyQkhBNE9dQXlLTUM9VHJ0bFA7dnN/clhHaGFAPjlXbk9AUlVBVj89QD09UlJkX56AcXhphZ+PXVqdT5CbgrNiX4aDZHZQUlpTjF5RYjM+c1BjindmXj03OVlYgExKSmqI2J+BiIiIgpqkq728sp+arKSfoJiuqaewuaGD9J+utV2Wd8GMxpN5WlFZZXB9UzpRZbRDSmBGWnZ2pKynraeQjaWVqKanlYV2vKm3g52goZmTjZiIhYKBn6yWrGZgYWljpnd2r56cubbAxGlpZsO2vJOJm56C29S9ZIxDgE5CPj94k05TaEk5OlZro4FeTkxcW1Q4O3BwSEAwLDFTe49+sHSJZMGxkXLitlzAi8TFill8VFh/qtaDhs1RZGN3nFVRRWqedXdopo1fSEg8XExQQWlldTc5SD1eQj2EQDlFalBFbD5HRR48XFdiNFs8QDlSUklXO0gzRjtWUCVXgEdXb4VmeFpqSmKGSElFfIVWZF1hdnBtgzI9UXVYaWZnT3xMTU12dHVlVVROZURfUGNmTlFtd29oXTwjRDVCNi85NylSjH9qeZ1rPEZVZkItL0KFNkeUZZhIVlI2aDs8HypWTEI/Q1NMfV1y07ehhZCBT1xDZJRgmG2QwLqVtYWDhHsBfIh9CXx9fX18e3x9fYZ+AX+PfgF8hH2FfIp9g3yOfZB+h30BfId9jX6IfYZ+AX2Efgp/f39+f39/fn5+j3+CgJd/AYCofwN+fn+Pfgd/f39+fn5/iH6QfwR+f35/p34GfX19fn59iX6KfQF+hH0BfIZ9AX6LfYh8hH2FfAZ9fHx9fH2EfAl7fHx8e3t7fH2HfAN9fH2GfAZ9fXx8fXyKe4t6BHt6e3uEeoR5CXp6eXp5enp6eYR6BXt6e3p6iHsEenp6eYV6gnuGeoN5inoNe3x+fn16enl6ent7e4h8g3uKfAF7hXyCe4R8B3t7e3x8e3uJfIJ9iXwBe4V8Bnt7fHx7fIR7BHx8e3uGfAl7fHx7fHx7fHyEe4t8mn0JfH19fX59fXx8iXsLfHx8e3p7e3t8fH2QfoN9kH6FfwN+f3+HfoN/iH6EfQF8hX0UfHx9fHx9fX18e3t7fHx7fHx9fX2IfCB7enp6e3t8enp7fHt7e3p7e3t8fXx8fHt7e3x8e319fYV8CHt7fHx8e3t8hH0PfH19fXx8fXx8fHt8fX19hHwLfn18fHx9fX18fX2FfAV9fXx9fIR9iXyFfQN+fX6EfQl+fX18fX1+fn6GfQF8hX2DfIZ9BXx8fH19hHyCfYZ8gn2HfAF9hHwSfXx8e3x7ent8e3t8fHt9fH19h3yGewF8hHuEfAN7fHyGewICBACAr8zq6vP2pYbH1bG17cHg4cW0pMWDsJ6ypqzGgu3P4v+E+LrfwqjO3sLsoYd9eoyZ3t681/TXk4t8fnVuZ2Gur2Nle4d+gHV5f3p7w6GsnKGpstHJv7ConKeao8fE0tq8oIyTh3qAfW53a3ZkvWJsgeCyzuHOyYiUqqSuw8DEmOGAkNr4g6S22MeCxb+KssXGxNDy6t3l/oOEhIby/pKqrbq9w93w7ufugojt3uPg0M3OzMTHvsS+s6qnqaytuL/QzuLu4Nn1u7fDt769rKewo6Wkn5mSkZKXoKq2usC7saOXiY6nqqSkpbW4uLmur5359d3ug/GCgvHygYSI/OyB5IaA9YCIjKyTrcTo6973z/6foo+MlZqdk5OGgvXf4oaQnJ2F3tXZxvLjh/u90bybtZeoiq3Jy8PO39nntqibm4WJm62jwb+xvciekYSRh9bA/pyVnLHLuaj2kc7St9fk4tHC7cu95OHZmvXxosmQga+HgZ/08onju9W4obbOzbj3z9uA8rC/8cuqsdDGuaTevImpm43fyY2Boe3Q97LH0cDuzoufzenLgMGLmrn1sIqQit3u6aqUye/X2PPgr5Pr0KSEqJa1iKmIvcrb5s6iqK2bgHOebbG+cnNye3iWiY+Qqqtz33iXiq7Aurasm3/s0ZvcureitOLbfXSQeN3CyqOfpKuAloOCpr+v48G7sf3Op42iidagiu6QnNGtwNe6uKSG1t/a2YClqauvh8ms2eOvhIeNw4mBl7zVppzLqpbcopP8hJqWm7Cyttu6o6L5paCKieGKlp+qmNyf26bxw5KujvHrj6azhofXeNt/q5Clm3x1eJBwkciBkZBnXmHBaWtzeW2A29CB1Jqwv6OTxZ96b259j5i1xa2Um5Kf7ZLpvbGnkYF8eniAjomVjpOQpbCtjdqin+PZ5P/MqI+MgMPb3urXqJvP18DHxKWXlYLh3K7Ukqzgx9XTsdrY6rCswNH4n5GWqpyUk4iJzJ6ipJ+4mKKQw4eBj+vOt83qj6a+nb+Xm5qAs4HB/p3+4/a9/dnK5cKe/7W9tqSWn6jUifmsgquaopCNhpaRrproksiUdXic2Yakrsef5uHhmciwpIV4rsWlndXNp7SPsMu/hqadvcrsopy/oePSlOSlkrmGh/KJhbfticWV596MhY+03oajwauB6fnN6Oj5t4fSgpifvYe3peGAiNqL4vbv9orpk/GG9OXG2J2g6PjD74iJuOTG7umOyJuFyNvni8D80tCNr6rVhs2P9anY/rrG3Oyczta26bCqo+6E3MTjgqrP6ZDakbmtydHeoYSE6tiVg9rjuYOip6SI3tCxlaOU7tCGg3jMnYioh8nQkJH3kv+BhsKBrq6XlIKAkp2usqGcXlCHkHh0pICkp5qMhJBph3mHgYObYrGZqsBjuo6umYSgs5a4hYOCgJWk5eG21vjfnpmIioF+d3HJzXN1jp6RlYyOlI6MxZadj5Gapb60qqGYj5aKk6+ruMCokYCYkIiSjXuCeIZy1HN9jtCarrytqHR+kIyVp6eshc6AlMTZepSeuKt0v7h7mKSko6nBubC2z2tsaWzIzHOEho2Ok6m5tK+yYWWvpauon5ydnpiak5mVjIaEhYiHkJSfmqyzqaS+kpSVk5SUh4KJgoaHgXx3dXZ7hImQkpiTi4J5bnSHioSEhZKTlpWKjn7LxrK/acRqaMTLa25vz8Foum2AwmNucZmAlKbBvLfIrdOChXtwen+CenpvbdC8vnJ5goRyva+0p9HHctiktaSEl4GMeZGlppultrTGnI+DhnN2gpKGnJiMlZ12cGNvZ6aAoXltcYCUjX+9cJ6OfomWjoB1k395lpmdc7GhZZFpbJNgV2icqV+eh5GNgJCxpprnusGAy5GLooh4hJ2OgmaGdFtjeFmMh2NVcrSmzXadooy1mm1/obWrY39naI6/nm50bq63p4R3tM24wc/FnXvUxZ6CloW0fpJzna/P3ryhrbOdiYqxjcfdi4OBloeTmJqfu8uE/oSfkrXBvryyoYPuzZ3esa2grd3cgHeTedu+zKOkrbmAn4uMrs+40q6eldemfGSBYZFvauB7h62jpreSi4BmlZiXr2V0g3yWgcel1dKPcn6Pxnplg6W7oq7NsYzanI/8go+Mj46SkqiGdoTPioV5db9zf4eZg8GHp4HVrX+Mec7PeIqae3rVhuaGvqfKxZCKlqaEsvGissGWjpL7i5CgsouA+eiT25etuqSXvpuCenqKmaO7xbado5yn44blwrqtmYuGhIGHk4+Zk5ORoaiegbyIgsHI1sium4GCb6Szt8GzkImssqKmpo+CgnXNz67Lg5fArbixm7u6y6OcrLrShXx9joB7fHVzrI6SlJGlkJWIqnRzfNPAssznh5iskqqLiH2AlmObtXrTubmsyKicyKt8yYyfl3ZsgXmPX8WLWoVze39xdoxwmnq6dr2MeXyl4oOhqcCPvIWidq+ooYiH4MqXjtXPsb+Uusena5GXut/xh36bf72Tba2Jcn1wiu11VHKfaopZmX9WWVFshl5whHRVtaN1dZO0i16WVnqCpWWJebmAfqBttqCyv26iW5BLmqqKjmN2qo2Ko2VshpmKnq1tk4Btn7LBcKTCuK54enaFSH1dpGujuHyeqK1umqeIoIaGdI1kpZawZn2cvnW5fJ2Qp6K4jnFmwcmBZ624kGqFjYZvsbWbipCS69ylmYzXnY+hgsXIhn/VeMNkbrB2n5+JhmiAgIuOjXV9Tj9eW0hIjl96f3FpaGFUaWBraG1/T4x+iJtPk3OPgG+FkHiRcYyPkKS1+O221vjgp6iYmpGRjIbw8ouTrsO0tLO3t7Ou14yQhIWQmq6lnZaLg4uAiJ2apa6di3uupqOtqZSZjZqG+4uWpceAkpyPkGZteniAjY+VdsqAqb/Pe46Tpqd1xbVyhYyNi42ck4uRqllZVVmop1tlZWdnaHSAgnt6P0BwbXl+dnFyenR7dHt6c21samxqcXN4cX6CeIKYfH17fH17cW5zcHR1cWtoZmZscnR5eX98dm9pXmN0eHJucnx9gYB3em2wqJedVaRWVKavXGFhrKNVnViAnktWZIx2hpOhpJ+nk751dm1jbHF0bGtiYrihq2hudXdnrJmalsC4ab+YppN5iHN6bX2OiX2Hk5quh35ydGZncH1xfHZtdntdW1BYUolcc2JUVF9ubmWKV3hkWlZhWU1IXE9NY2pxVoRxQFpIVn1KPUNneEJsXmBtZnKRhIjbrauAsnVlbVxVY3VlWkJQRTk2MTNbTysiMnx7bENETEdSRC86RkRDLVgyMzJJJy8wKkZET0dFdGtXVmxWREZzdmdMbE5yWXJcanaGiopqa3ZrXlN3Tn+FU2NbWFZkYGdeYGY6gFuMeoWe0drUv5bsz63wtLSur9zmjIGhg+fD0Kuur7mAnoR9j6iWs6OThciYZ1NtSGVJRm86Nkk/ODU8PDQtV2NqSis0Lzg3LEE/UFlWR05FYlFKb5CXZTdbT0+HaFtzPEdBQUVWXmdOS1SCUkk/SoA9Q11uY5dgiWOijWhrWpaXW2h6aWa6asiVnWBWUFBfdGM8SFs1UEExNTJ1QTU5RUCAwZhhzZSxvqymv5qSkZSksbzKzsOysa+23XvfzMW5p56Xl4+Wnpmfm5aVnZ6ObY5iXqOpbIWEa1xVWImXnqaZgX6Xm4+VlYN4eG7Cy7LKd4aqnaaWiqGnsJaNoKe5cm1sd2xpZGNgloOHiYeWjI6BnmlrcMO2sNLrgpKii5yDe2mAfkxcdkeBYmlMVkxcl49calNlSk5TXFBfMWdZNkw6PWs9WGVDZk9xXa1/hYKsx47Cx+WCik1xWGl5loB9rK95eMaxcFxKVnZyUW55jHFSTklrWm93P3FHRE8yMm1DS2ROI1hOXGlILDMvUi9LYFI3RUlTM2p5XjddNzU+Q0NcQ02ANGQ4flZWaDh3TYRHbWVxZjsyaWRZhzU8anx2kmlLV1xWcGuSVm9xYHAyblp3SG5Pclxyj3KEfHpTamhNXGBBNDgqVHaLUmGCj1RwPUNhVDc6LTEgXmFORlFpVkY+LTQpYU9SPk4+gnZZU1rZinCZb5micm2tZ5FMWJxtiaRyc1OGfAJ9fox9h34Bf4R+AX+KfoV9hnyIfYJ8jH2Wfop9AXyEfY5+hH2GfoJ9i36Ef4J+i3+CgMV/hH4Sf35/f35+f39/fn5/fn9+f39/in6Lf4N+hX+GfgF/pH6DfYd+An1+j30QfHx9fX5+fX1+fn19fn19fYp8kH0IfHx9fXx7e3uLfIR9Bnx8fH19fYV8hnuCfIR7hXqDe4l6BHl6eXmLegJ7eop7A3p6e4d6hHuRegp5eXp7fH5+fn16hnuGfIJ7jnwGe3x9fHt7hXwEe3x8e4t8AXuEfAF7iXyCe4V8hX0DfHx7inyCe4Z8AXuFfAR7e3x8lX0BfpR9g3yHewF8kX6EfY9+iX+Kfgh/f39+fn59fYh+BX19fHx9h3wHe3t8e3x7fIZ9A3x8fYV8DXt7fHt8e3x6fHt7e3qEe4V8hXsEent8fYh8Bn18e3t7fIR9Enx9fXx8fXx9fXx9fn18fX19fIR9gnyFfQN8fH2EfAd9fH19fXx9hXwBfYR8BX19fn1+kH0BfIR9BHx8fH2FfAt9fX1+fX18fXx8fYx8CH18fHx9fXx7inwJfXt7fH17e3x9inyJexF8e3t8fXx8fH19fHx8e3x8fQICBACAgIWRgoekmLfg+qHoi9C44sLogYuwlbyovc+/3byts7ve6drOoeDavLK4eXN7i416dnq0vK2SjY95dWxpZWemm2t3fXBudGxwe5SLt7/YwqS0nK6F0daEgoOSkLDOztbPp/endm1ncn+KdMm6Y2Jsg5KdtdTOspySk5mUpbKgjI+A85+Fm7bKxqmJioih3vDGoqasssLb9v2Bh4iFgPWQl7nP0dfc5e7l6O3n19XUxdjXy9LPysq5v66ytKeju73CvsTh29HUvcCkr6udm4iRlqqjo56CkY2Sm67DvbWtoaafoqmlpaKnoK68ubK0s6yO3e734PXs2N/zh4yK/9vf2+KA/JqK7tiD2NzN0/n/g4mE+/CIiZygj42F/IH8ipCQiv3Fx+Ps3byxs8y0xJmWmZ6yucjS6YHm8YTiopnFrpLXiJWwu8Dbua+xsq+WjPD+kKWWhYirw97OnoDUmIaVq7yyz8/uoMC5m5SK88GUu4+Eg4GRl+ax086dhumKjt7hkdOAs/emrqiO3e+arcTCgpHy9fDjhNmP2d32++CoyrnDlazurvyEm4ah19OBj4CDi5Se2tastpPX2PyIrcvd0N/j67WGp7HOlLqF9+GwldGt2r6WvIeQzmjOd46nuaKm0NXIhun1krStysi4kaPS2Zu6g3xx0uCmxMmZkd7c74Dm37+A2tiyw7Cjvt/o/tvMooON7qm4gsayoNij/ZWsq7yP0Zef7JC27Ju7u5nPsrvyubeIiaOWi5edw5eQnpqYhf3PgcGpl5GOppihoY/8lYHi3bf+pvect5KM8oaKy7qrmLiqr4HcxaeloIR+la6opXB0X6OSpc9yZ5VtsbSuwr2vaXiAmZaxd3xvj8+zx9CvfW+IkaW6x4uB7Nvqk4D62K7Xqb6Of3jWbnSFhnuHiovV872ps6v6i/j0j5qHioX427CnvLLNssO1lpiaxHmS5aLI/eW3xubPstfe7fqF+PnBhPSCifHr8ICQ6/X96a3ApcG1hZqO4J/51L+chqGS8p3euPWAxM+iuMPa7N3OoIPrp6uZs4/+44mjr/6Xq6L6zsm2n4HW35iIt6KugICIovV8fb+upMfX9Y/qrI/9spe8tISTj8He83jGx7/Vgc/84aHCxuP2iuunjaSXoZ2th+/njcOx/8Kdo8mY+orcx4rNifrZgJr5heni9oSjw5fLktiTyYOAr8i4ztqenIub8uzwhefixpqTjPrUoYmKwaK3qpyiuLyP4qCDoIior6bw5LbshaurleP2nKKF38LwiOC5lJmH+d/DlOuFkYShmcaw3Y+9iayas/2IsYzpvpWI/panu4OctJCFeHObqLCQe3nEt7yDy4jbnb72o+W71dyZ4+Oul+iAW1xkX21sYISZjHOZX5iQpImuYGaEcpSBlZWPpYyBg4yir6KZeLCtmpGmfnqClJiBf4K2xbWdmp6Ggnl2cXTCtYOSlId+i4GCjKGDpKm+rZemkqR9y817eXuKhZ2ytb24l+qxhnl1go6cgN3Uc3J6k5uGnLGtloR+f4SAj5qMfYOA4Jt3h56uq5V9fHiKtcKlhoyTlaK2zcxoa2xrZsRzdo6anKKorbGqra6sn6ChipyknaGinp+Tl4mLjYN9kpOWkpeqp6KllZeCjYV6eml3eoiDhIBldXR3fYualo+JgYV/gomGhYOKg42WlZCSkYxztcPJtMvBsrrLb3Ry0bK3sbmA0XhswbdttbaqrcnOanBt0shvb4CEenVv2m7UdHt6dNaqqLrGvaCYm62dpYeBgYSVnKeuvmi7yG7DjYSjkYLFdH+Qmpuwl5CRjohvabfOdIR5amqIl6qjh263gWVqdH14hoeicY+Me3hmrY5rknhkbGl0gMqivK56a8RocbW6e7aAnMV8hYFqobh2gomJVV6bnZWMVZBho6C1waqFmYuMbXWxfrNrd2N3ra9hcmdtamp1qqGEkn+pvdh3prPBsdW8y5t7mJ22epNqy7+nj8yh4Myh16Cu7IXqgZyzxKmjzNjei/DxkLu0z829lqjN3528hX5z19mpyc+cktzV8H3d3saA7ei6zbamxdTN3biqeml2qH2EXJd+eamN0X+QhJJtiWd+z3iSrmenon2lhaDRjbySjaB2Z4SFv5eTkXlzasbHeKOahX54kYeOg3vVfG7Fx6PaluWdpn1z13N4sZGKgZSPlXvczLKzr5KLpNXW0YqWge3Px/KbjK6B8Onj6+zrlqaAt77TeoB1ksKvwcmwhXqOlae4wX9639Phh3nq0bDTq7uThn7idXqOjoCKjY27zpyTn5HUc7qWcoJtcWzNtpWPopiqmKaag4SLt3qM0Y6s18KcrMKxm7a7xtNwztGnbsxtcsvHy2t7y+jr4J+2mrOacYF4zJf42caihJSG6ZXZocyAq8CKkpuwvLSsgWe9jZWEmGm1vWRzgtFzgHiwn52Og3avw35urYWHd3uDpf+JgsmsoMLJsmqtjIDqrZzW3pupk8Lp+IHJu6G7ZbfX0ai+s5LSasKEY4l4bXVua+roY3ZqrIRjRH5YqVSsnGeEYKmOTYDGWZuevFdzj4Gqea2CtHWAk4yal5pabWF5pp6lVpiafnJpb6OTd09ki3WFc2p5hZZ2u4NmdGaKj4isknObT2psZIOYbXNispGkXqqKZmlgsp+ddrNgcGRwfZ2LxYOeYYd/lb5llIDJoX9zzYCKm2h3loZ2hJawvcegj4vSubl/v37QkZ3PfrR7nqx0wdSVgbeARkhdTjpLSFpvYVWKVXtzfmOAR05hW3dqe3VzhG9iZ3KAin14W46QgnefkIuUqa6PkY+9yLehoquVjYmGhIfo2aO9vquhsKmmrbh+kpKll4maipp80895dXiFhJCcoq2ske7Qp5mSoay4lv35iYyVrq9zgpGPf3VtcHRwfYR+c3yA2qhteo2dmYh2cmt1lJ2LcnqAgoqbq6dUVVZWUqBZXGRsbHJ3dHJub3R2d3p6YXKAfH+CgIN7fGtucWpjcHB0bnJ6fIaJfX9wdXFoZ1hmaHRycm9XZGVoanSBfnp1b3JucHdzc3R4dHuBgn1/f3xonqKsm6+lm6SwYGRktpqdlJiAplxTppxfo6OUlaeuXGNgtLNjX3N0a2hlx2XDanBwacKbmaSyqpGNjZuRknx4dXiChY6VoFWcqmCrfHmOe3S5aG12f4GMfHd4dWxUUZWtZG9lWVdwe4aEdWOkcE5LTVNQVlhuU21wZWRNfmBSeWhOWlZgbLqYsI9aVKlRV5ehcJ6AjJ1cZWBQeo9ZYGFfOT5lYlhYKkQrX2qKe2M7VlliRz9ZPEIfISc0OjMtMyUnLjI3V19BTUlfYGIwJ1JJYWeEn4hmeIqWW2tVrJd1aaKTo4t4l2JgmEqmWWJwdHt5dnNzZsDJVG+X2+nfpoS23qjPkY6F7N+q2euxndrO+XXY2s2A4Ny0up2Oqb+5z6qSaF1ph2hvQmhTQ1A/WDE4M0A4Tj5OWjtBV0FKS0FoUVZ0VEE0NkhOUXhtmWhWVVVZVpV+T2xMPEhPWUo/VEl+TUR+f3KZaaBxfGRXoFRejGlta316g3zq4MzOxqumr3hAOzI9QGdka3w+OVNDfIWGi5aBQFOAiYCzgouEn7+zwsiym5KiprfCyHd029Pce3bgyrjMqbOckIb3goabmoqRk5Gio3xyhnKqQHNYW2tcYFyvoISCjYWWh5SKeXqBsYGNxYKbv6uMmqmcjKGjrbhhsraWX7NgY7Oss19qtN3g2pO1lqqKaXRrupH439euiI9/44/bk7CAla1vcXqKlo+KZEeKZH1LOjpnQEpaTWA+TUZdanRZN1dVb0Q8f0xHWGZpo9JojvjPvd3rkFaBdkurtabEuHyNgqfT0mVtd2yKU46jl2NNWYOFP1xZP0tLU1JmQlJZUWteaFdEHlwqMjIzPzhzSFpIICdrN15uejI+XEVNRV1AWDKATGpLWHA/ODRUZnt4RXdzVUw7MntUS0RFYUdeVEZTWWRdgmFKYFNWSyUybGuJTlpSUX2SYmpObWWBSnxmS08/elpUSIVEV0hTVX9uakZyQloyKW0xWzNXZzlQbDQxKT5KVDNHVE9gYm5SSF+vjpx5vnPJjYqqZJlTg5ZXt9h4bpyMfQF+hX2Xfol9g3yJfYJ8in2KfoJ9i36JfYJ8hX2PfoJ9lX6FfwF+0n+JfoN/hn4Ff39+fn+GfgV/f39+fod/A35/foR/lX4Ef35+f4Z+AX2NfoJ9i36KfYZ+hn2EfoZ9BXx9fXx8hH2EfgR9fX5+hH2EfAh9fX18e3p7e4R8C318fHx7fHx9fXx8h32FfIN7hHyDe4Z6g3uEeoZ5BXp6eXp5iXoDe3p6iHuCeoV7gnqFewR6enp7k3oJe3x+fn59e3t7hHwFfX19fHuHfAV7fHx8fYR8DX19fHx7fHx8fX19fHuLfAN7fHyEewJ8e4R8BHt8fHyHfY58hHuEfIZ7hXyQfQd+fn19fX5+iX0BfIx9C3x8e3x7e31+f39/jX6EfY1+G39+fn5/fn9/fn5+f39+fX19fn19fX5/f39+foR9Cn5+fn1+fX5+fn2Jfg99fXx8fH18fH19fXx9fX2HfAR7fHx7hHwEe3p5eoZ7EHx9fHx7ent7enp7e3x8e3uFfA59fHt7e3x8fXx9fH19fIV9Bnx8fn19fIV9EHx9fHx9fX18fH18fH18fHyEfYV8Bn18fXx8fIR9BHx9fX6JfQF+in0BfIR9hHwEfX18foh9CXx8fH18fH19fYV8hH0bfHx8e3x8fXx9fHt8fHx7fHt7e3x8fH19fHx8jXsQfHt8fHx9fH18fH17e3x8fAICBACAjOiustXH6KamnYyHkNfOtb6e3ODcz8Gvrr+umbC/subOqNnNm6rLtLWAboqEp5+HxNh8de+BeoN/eXuEeGBhW2hwfXRydWyNhKGQipmr9eyDha6v5snthOqNpa6y0MPK1Muk56eHdYiajoTGXl9eeof3vrzJnainmZuXp56do4uA0dXCkbW0wbWpt7emrcvMtZqnvL7C1YeYiIuBh4qJiJGdv8bEwczT1srM0MfLvsrRucDQzMPJwb+0qa2ztq2vvMHPwLCnp5ybqZ+dopOMtaGkqZmboaKboqu5rqe2qqGmpJSek56ln7Cqq6ursbGsmt3b39be3d/xhpWR/e7q5e2AgPmSjoSP/eHF0t7g3e7n6/n44Iuji/jz9fuG/4Pero7n/IfCpoykrbq2s5qXoMm8v7zR1+KGjMupmaCfpvOIvY2krrnb0sSuva3JvrywkqmUjPCSqrK7sr2f2aPSgN7P192dvbjT2d7Y3bquu6yk1Jrxk7TC0aiIpJnjk+3+7K2Asqiys8HIl4fyhsaywJ6Fur6rncCp86bDkdev1/fW55SAjtXHo8qZ1NmHnuGZ3YWG4P3VwaaQzMeHnaKE4b/g4rmUnYCuj5Kb94bP2YPj7cjG3Nd/ir/P43+wsM3HzMnfhYWWjLe9zILWrLO3vKvk2KqKe358eK7c2Ynj3YD++4uAjYiGgPeZlp2nnpfavreHiOnLyti2yPzK1+WetsT2q/+CtaO+orLS3MGOhabt5MuDkbeJo47tkpyp8oCEh9KQ5unPj5yZpIeLlIKK1+mHnaa4yLel+JKNqbviksKy0vWAzImB0KusrqSlob2he9eBfM+7w2q0sJKzu8/acthwcWmAbHyPj5ubwXRoZZKBZWvImafI2MK9vaCRiPShnOvuyJyYrvL7jdrCv7qbfdeT6uTLqYjfhdztjo6KioTh2+rt0ujHrauXgoOH6b/ey8ejobbLy7jLyuje0t3v+YmMl4+K/OXq/Ovs2La0vPvn34D738D8o4d4rLPkpsCqlZ2ysfuA3NDyhYWTmZmNk6aHlIHnuZ/WqKC3uavNlcS97MGw/Y/1oKOTo5qS9v2riNfUcLdey+yGkqLb0/6rioh4sKLMuqqwi36StdmuvL+ziKOKoO2Oy8qgms2p16KW06a0lZ/n24+m2pjp0NvruITuo9az1LHtnZjMqMzdl5je2sz09e+AoomQwaGfnIWUp8LP3PLiv56JhZ6ss+Sbu6uE/5a3yry1/Y3Mmo2B89+CuKCRo8W/qOPkiqvx+O6uyIKxkJvzu5mhi+TKgsrkwbuugJeSu6GCgvyI/uzFqbSlrrej3MnGk+GO021oZW20r+mNq8+xw4e2psGFguyIis+dy6HNweCAap53gZyAjnmEdmhybpiThpWDq62nlY59g5WIe4WPg6yXd6GddIarm7CJc5aPuLCRzeSFfv+LhpCQh4mVhW1wbHyHkIeIiH2QfZKBfYyY6Ot8gKSi5cznf96DkpudtqyyubKU5bSVhZqwnpPXbm1sjJjjop+phImLfoOCkYuJjXqAv8SxgZ2cpp2SmpuLlKqrmISQoaGnt214bXFoa2xsbXJ8lZmUkJmdoJian5iba3qdj5ein5eel5aMhIeLjISFkZOdkoN+gn18hHx7gHZ1jH6Dh3h9gYN9gYmSi4WQiIWFhXuCfoWIh5CMj4qLkpCPfrS1ua+3tLrGcXt30L++u8KAZ8Vzbmp00rejsLe3uMO+wsrLuHKFc9PTztRx1m7BlH3Q43ekkXuLkZqcl4iBh6eem5utr7dudK6OhoqKjtt4oHqKkpqxqqGRm46hmJaMdYt4c8N1ho2SkZiItY7BeMaxpad4l5qwwsCorIZ/lJSNzpbehaeyx5N1kJDHc7i/uYGAioSGhZGVbmGqYop8fmxljI5+a39nln6hZKB9rrGbpnBrd6OLbYlmlqdrbLKOs2hnmrqtn4B8o56Dl59rv6W9wp+BiHKed250u261vnPa68bd+vSVrdjZ9orAq8nMzND1jI2dibzE0n/Zsrq4wazp3q+NfYB/eLDf3orbz4Pq9IqAhIuOhfOSjpWflo6+pJpyft2xqZ+Dj7SOqNWSkZ22crdbgXmLaX6ZjoBpZ4jZysuKlattf3HBgIqdy2VoarCAvcOnhKCNi3B8gW18utV3ipWdr6OOxnZziZnEgJyVq8RoqoeC07a7vLO5uN6/mviWlf/r/IngxZnO2PH2gPiChIaAhJi5pK+nyXxzbZmGbXPCiZCptKKhoo1/dt+jn9zfx56YqvT8jOPPy7+VftuJvLKhemK0a6/Ec3RxcGy9usfHscKolJKCdHZ41KrFrqqNjpuwr56srMa8sLrIz3J0fHZz0sPH18nKu6ahpvHavm7VvqvxqY2CtrrcmqyejJCioNaAvLLJbW12enpzeYdwemnBnH6hfm96e4qvfqGTuYx5yoXLjoSEmIp/9sqWf9Xbc8Vmy+R1hpGyrtadhpSDxcXLzcrCj4ybtLqnnaiUhJFygqZuurB7eKicuXFlpXh9XXOfhE5dkHOJfIaJh1Kme5mDl32ZY3GgjJmDZ2msqqPG1teAj2huj2htcF1rg6CcpK2Wg3tKY3Nxd5dpjXtns3CTmo96y2aLdn1x2r1ZfnNrc4mTjq6PZYDExb6ElGeBaWS+h3N9Xq+ha5+zm5mSaoR1h3hldct73ta0k5OKjHdbp6iygr+E5IuHiaK+ovOcudCrrHGoi5lqZLFkbJpqmH6hlqeAUnJYbWprgGVtZFtrXXBrZHBpi4yIdW1ba3pwZ2xwZ4luWHx5Wm+Tir+chaym1cei4O+Jgf+PjpyilZqomYCFhZijrKOrrJyieod3c3+F3+t2e6CZ89vvgOWBi46RpKCmp6CN79G0pLnMuKnwhIWGoazOhISLcnN3bnFxf3t8fXJEwMKlb4ePl4qDhYZ3gI+ShHZ/i4yTnVpgV1tVVFNWV1ddcW9oX2dtcnN4fXp8QU59dnqEg32FfntuaGxua2NhbWxzc2uEaYBvaWdsZmVza290Z2pvcWpscnt3cnt2cnNzbXFtcXV3fXp9enyAfn1wo5yhmqCdn6xibGi5oJ6doVWfWVZVY7qej5ycn6Gopq2xr5xmdWS8wLrCZ8VlsINyw9ZxkYNzfoGEjId6dXqOiIKDkZGaYmWZfXR8fH3IbIhrdnuCkYyDeYCCd3xydG9hc2Vfo2FudXZ4fHadgbZyuJuEgGKDhZmsr4yNZWN+iH/Qmtd9pKzBg2aBjqhakZORY25paGRsblJHfEplXFJRTGxqVTFNRmRRUTpvP0Bxb2dRQkZgTS09KTQuJTdIHTwqLkxVS0FBNlc/HiE5LERRcX9gV3hekGBVXICcVY+VY6uqnJSkoVBYj6i2X3iJf3qEe5hjaH53sbjHfuuepbrUuv/3wqCOlJCBufP5lN3Fhefwh3+QiH/bfoGKiYWGtZSKaHawf1l3amJ4V1VEMjo/VD9cMkg3SD5PWV5SQEBTcVtWTFZ1UmJanWhxiaRTV1iSapeaf0pEVk81QoBCQjpefUdaanh/gXeaXFtxgrVrf3mMoFeTh4Xs1drWzNzKk1BAyWdjzcSXOWqDeszX+/p25WlfTVllkLvPweOPh4OrlYCGwX6BlZqMj5GAdGrNqqzOzryemKDw+4Xx5uXQj4PrgI+Jf1pEd1ORpmJlY2Bdp6ixrpulk4SCeWxxcIDJoKyXlHyDi56bj5mZraKZoayzYmJoZWK2qq29tLOnmJOY5dujXrutnuu7n53Hyt+UnpmIh5WPt6KZqlxYYGRiXGNwXmNXooFgbU4+VFQoPzopNWVTUoZVYjdCVkdFUbdyY2/O44r+g+33dI6TlpGVeXGIfa+gnJmlt49wT12JiYBvYl5STjdIhz9JRU9KOTRXS09zVF9ZX1htLjtfLDVMRUBIN0RPWzhbQGFFQldZZ09KVXR9X1t4aU1PPE5ZUEY3TVBYZ4GLbVE4FjVaXFxkNEZLRn9KUWFaV55KWkw+Ql9UK1hAQFByKydgeUlYaYl/bXZdaVBIhF5FUi1qZUqEozh1cnFPYltZTjAbfCuWgklnYGlMPC5gOUhAVmSSUj8+S2VVknuDkYWbYo9zfllPiUxcbklsb4F4hpF9l36IfQV8fH19fJN9hn6CfYR+BX19fX59in6IfQF8hn2OfoN9k37af4h+g3+FfgJ/foR/jX6Df4R+CH9+f35+fn19k36Cf4Z+AX2UfgF9h34EfX18fYR8j30BfIR9CX5+fX19fn19fYl+An1+hX0GfHx8fX19hHwBe498B319fHx8fX2GfAF7hHwDfXx8hHsLent6e3t7ent6enqGeQV6enl5eYh6h3sBfJJ7BXp6e3p6hXsBeoZ7hXoKeXp7e3x+fn58e4R8A318fZF8g32FfIN9jnyCe4h8hH0BfIV9BH59fX2KfAp7fHx7e3t8e3t8hHsCfHuKfIh9in6JfQN8fH2EfAN9fXyGfQR8fn5+hX+NfgF9kn6Ff4p+B319fn9+fn6HfYt+i3+DfoV9A3x8fYV8AXuIfAt7e3t6eXl7e3x7e4Z8hHuCeoR7Anx7iXyEfRJ8fH19fHx8fX18fX1+fXx9fX2HfAR9fH19hHyCfYR8gn2HfAN9fHyQfQF+jH0TfH19fXx8e3t8fX19fH18fHx9fYh8A319fIR9A3x8fYh8hH0IfHx7e3t8e3uIfAJ7eoZ7AXqEe4V8CH19fH18fX59hHwCAgQAgJ3v8YLYioLsheHwtKeD6IWOvuXy6sKpk4Os8+SI8MXi0qSvqoOCuXF+enmEhXfDqH6bg318d3N0c3FvdWxsZW6Bc3qGgeKDhOTerJvLmaKTj57D0qO/zLfQxLXGtb7a09DO1r+K05V9i52Odrm3Y4CRoLGtp6eIlpSUkYGTk6SqgLCg7qbjm6OqqMDKw8fj2vSAgOPn6f2Dh5SQhOz/g5WWmaWwspastb/BxbzY0MXJz9PUzcHNvrzFwLevucW9yMLP3tG/poGipKynn6GVmLGnpJSip6yts7Gwp7Cxjq2kl6Srqqmup5+xo6Otp6anm5Pl3dfx5trv7dLV2dzP3NHmgP/3k6O0jYP/9fTq1Ovi1PeIjoOep4n5x8LUyaK3pY+S8qTK0b3A9o6C5NziubK0tcvbyu6BxfGai+vvqcOtiZ2qnaOSttSznpWXoZSaj5Wwxb2tlJmesaGNjJqA4dyg9MbY04H98ImOh+HF4avd3o+Rga3A8IqAt43izIbB4sbHgMelore5pI+b3su/gf3549Gr9dDYvqXTwZGHjsqVoO3mzPjUmJ+Jkcy544OB/9Oq/sTWrKry5JGO0Z+L2tOiqouAjd6n95+G1+XMs8mD5+uwp6rE9e14487Dm7HHqdSE4LuFnKKf5/HCp8bKz3V2foHRzKez0tDDl56yup2L/IqegKGfmZiMmLG9sqyjnpCNjfHG2sr3hY7N7LfKke+itNXe8dW2yc3KhvzMooaw1cSHiKn5rqyM84yfp6LCqPPWoPbcgYGIhZKXorCtvbCoqKefsK6xop6A593P5Z/x2qak//SOdYWEdYSHi5K/h3xuiMXVnoTUjbazsGNtcXG4csGxgJ2iosBjj4yLkZiPqIeSv4//+czi3J+ZrJ29hYaPs8u/urmpgqeove2C9NLZ9vbzw9Cc+4X/5MOt8dLPzdjx79jRybuegOv9jZWjtr/Ix7nAo8Pj7/GC+O/z9ZCOk5GD5szF2sjd29qV7Ofszfqh2Lbtjqejk6O50ruo5aSIqsq5gL3Vx8zPrNnovsOR7J2anYuXkvG3m83rzorhwKT5iaCd0/WirLe4+ZrciPCHpblmfpHDso+uzYKMvrbGiqSse9y6qOO68J2bpLewnpj1o+2dmqjS3aulrafu08OBj52bx4C7/NaV5orZytaq05SNnpCniMfjxOq56Or1hqbLg8HQgM63q8n9iZuElubDm7vh/ZHz4eHtx5j89+60z6LDufaM7YDDk++qi/r12JmUp5ClxI7c/tSct/SmuJaCifP6+seshJXFuIauoaumrduUi6nf7bLrlcy34aPGmrCoqP60jYSQgLy2bHrM2uiKiMW63MrEgO6h8OPLh4rLi/zdnqXMgHS2pGyjbGC4a7W3iYhnpmRwlK26s5eEZVuEvK9ovJWsnXyBg2dto3OHhYORk4PSsYarj4qIhIKBgHt7gXl5c36WhY6bkdh6fNnatKbNjZKDg5Cwu5GstqG2rqGuoae+uLezuqmA1Z+Ela2bf8XRdJWjpJqVkI90gH9/fXCAgI+VgJiM2KDRjI6UkKGon6O7tMVoaLi+v8xpbnZ0aMDQaXV1d4KGhXCCipGVl5Goo5ubo6iknpChlpSalJCMkJiSmJSfq6CTgV+BgoiDfYB7fIuEgnSAhomLj42NiI2OcIyGe4WIiYqLh4KQiIWOiIeLgXu8ta7HvbTHx6+xsbSqsq/BgNfKdICIbmvVx8vErsS7rchscmmBi3TXrKS1rYydj4CB3I6vsqCjxXNsxLjGn5SYlqewqcJso8qKftbVjqOUdYSOhY5+mLGUh36Ah3l+d3mNnJiLeHp9jYNzdX9vycWX3aextGrV1n+Fe8WcvJbByoCPdqWz2HZynHfOwHOPppmWgJl6fIeMe2lvopCLXrywqJV7sI+LdW6Ni2ddZYhydrSltc2qd4FdYY+RqFZpz7CEuqKbjZS3sHNqq4CNvr2cnoNqdcCK04hutL6lpMWA4OOpqazO/fyE7+XsrsHIq9aE476Ko6ik+uiqpcrN1nd4gYbUz6u52dXHl5irspqC24SfgKGdmZaOkKy/r6GVi399gNuxt6bJZmGVrIKMZrSEk6Wfm5CLmqGTX6megW2m3MeTkqjql5Z3yXZ9hYyhjdXKkc60ampwbnV6hI2KlYuEhYeBi4qKf31pvriuvnq/tZGQzM+KeISCe4WGiZLRoZN+j7zPqpXypM7P1HqFh4TTgsq+gKyzt9FtlZGSlJaSqoeYv4Ly7cjY06WesaC2enp9lqaempqQdKGltNJz4sO+wqy3pK98zGvTv6aSxLCxr7jKyLevqqGKc9jmfoKKnqWtrJ6nkqq/x8ls0MnMz3h2eXhtxbKtuq++vrx7yMnPutuQu6LmlLKwn620uKaX2KJ7mayfgKazqq+xlrjHo6yDzoN/g3N6d8qVgaK4qGW5in3CcIiHsN2MkpuY6YWyd8eFo7xtenylnX+TpGpolq7bpa63i+/VxPLF+56QnqmajoGid61qd42tvJKCh4eHi4RUYGNilF2HiHJitGmQc29ag1dSb1R5YJatl7KKrbjKZHiddKqwgMilmrrHb3ZhbbSZc4ygsV2bl7C+nGietMGGqXORj6xzy2yldcWcb9bKmGVnhX91lHeIwZt3ouSKj3Rpb7WpvZp5Znypm22DcIN+ibR1bYGutJfGh5SYxJOng35sZrhyeXqHg9vRhIvmsMl/fsKtvq2fYbZ6srGdYl6OYbWnc3iYgGGYgUFzT0F8T4+OdHhXglBdfpCblnppTkZrkoxRlnmLfWBkZ1FZloGdnY+qrJbyvI+xlZSTlJKPkoqKkY6PjJW0nay9q9Z3eNzfysDchIVzd4SirIibpo+hn5igkpWtqaqgoZZ96LSXrMeykOD6j7C6soV+enlncG1vcWh2dYCBgIN7yKPJgIGFg4yPhYaakp1UVJien6dVWV9fVJ+sVV1bWmFlXE5fanN3enWHhoB+hYuJg3WFfnp8dG9ubnRuc291h4J3bE9ubnNuaW1ranNubWFsc3V2eHd3dHh5YHV1bHN2d3R2dHB7d3V8dnd5c26rm5epoZeqr5ybmpyRlJSngLipWmBmV1mupqmsmK6gl61cXlp0fGi5mZSln4GQhnh604Ogno6OqmNcqKCxjn6CgJCPk6Zfj7OCdcnHfoiAaHF4cHhvgo96c21wc2NkYmNweHhtX2NlcmpeZGtiurCN1JSZn13Bx3+Gd7uJrouzwHqcc6SwxGtqh2i+uWdufnd0gHReX2hlXlFReWxoRImAfW1YfVxYRENjWkhCRV9PUEVyVWxgRi4yQDsrOCMnVTsxY1NLNypJUzE2TxoaPEA6MS8uSKB2rnBeoKuIaoJjsruViIeTtZpQrJaBZIOMhKRuqYJPcnRipa2Igrq604OJlJrn6cLS+/fkqJ2yuaSM1YaigJ+fnZaSjKe4qZSMf3h2d9Gni29vPDtxi1pfP1Y3N0dGUUc1Q0hZNWhbTVFlWj01XYbLgoZnsl9mb3WKgcbLirSbWVtcWmJobnV0fnVtb3FudXR1amhaoqGZnF6bmYSIra+MhIKDhYaDiZDNk4aHi6u+qIW5ot/w/ZWenpXwlcC0gLHB0PCAoZyjnp2isZGhzX3r69HZ1rawvq68cnBwfYV/fH93Y5eiq7xhxa6klnWGhJRoq1y2qJODrJ6fnaezsqWblI9/a8/dd3l9kZeamo6Vh5ilqaxcs6uusGdlaGVdrJ+dpJ2oqKdqsLG2rMSHp5PiodfXxNC8o5eM1KpzjJaRgJKcm56eiJ+tkpp7tW5qbmFlZK18ZHxmTCdTOU97SmVYQ1JTVURDijdaTXeKu96IhGFsWmdzfE9HXIG3fqm7aLvBrtfG9F1paXV3gGFnP3xlVUE5REguNjEtQjk0T0ZSQTQ8M0EtWS8yNUU/bjklNjBRMldIZ5JhcoupTVByNGZfgEVrN1F4P1RJRm9fT2yCkDRIWGaJW1JzYUldU09XOm8zYkFrWJhTTG1ATzBJOC8jKi47PkRCL2RXeGNhXYd5e2k6Nj5MZVFeU1VmbX9ZS0htTC9yPltePlxjZlA5O21JPzhNUqqRVWGNb4FgcJiaoouATY1mkJ+BS0lpRYaIZGR4h30CfH2EfIJ9i34EfX1+fYh+iH2CfJZ9gn6FfZh+h32CfIR9kH6DfYt+gn+EfoV/gn7Tf5J+hX+JfoZ/in4BfYZ+gn+LfgF/hH6CfaF+g32EfA19fHx9fX18fHx9fX1+hX2EfoJ9jX4EfX19foV9AXyEfYl8DXt7e3x8fH19fHx8fX2LfAF9iHwHfXx6e3p7e4Z6iHkEenl5eYV6A3t6eoR7A3p7fIR7hHyNewF6kXsMenp6e3t8fHt8fn5+i3wBfYt8BH19fXyGfQV8fH19fZV+hH0Bfo99iXyFe4R8AXuHfIt9AX6KfYp+hH0Bfoh9A35+f5F+gn2OfgF/hH6Ff4h+AX+IfoJ9hHwGfX5+fn19kH6Gfwd+fn59fHx9iHwBe4R8CHt8e3x7enp7iHwEfX18e4R6CXt7enp6e3p8fYZ8BH19fn2KfIR9Anx9hHwBe4R8iH2IfAd9fXx9fHx7hHyLfYR8B31+fHx8fXyFfQx8fXx9fHx8e3t7fH2KfAF7iHwJfX19fHt8fXx9hnwffX18fHt8fHx7fHt7fH18e318fHx7enp7e3p6ent7e4R8Cn18fXx7fH19fX6FfQICBACAtaOrzMOAvpuhp/b4tN6goLOLpKizgOTI1fLHuYHMjbuWifSlknd2csbGjZ2CxLB+gHZuc3V3dG1scmxwgoh5goWAh7OKnI++ot3xkbm6zvLmwbnJvN6C+IXQoomYoJCNq72uuM21/6V1c3CIe9dgbHuD9I+QmaekkaCXjI6Wm5KAlpuuiqW1r4qSn6i7u7nY69/o9IL6/4GBi4uThPmGh5Gbpqe6uZ6aqq24zLjIzMGqwczAu8bBtLq3s7i3xMvFzNPdt7+tnaOts66jq5uaoJuUmKOmpqilqKissrKpl6Khl6K0t6ilnZSVpaSoop2ciIL+/+23uc/Sztzz4/qG+dmA6+2BlLGxgo6F+v7i19mC/PKFg5melorz1d/055uKlcC0rMnLz+2dtKmclojv6rWgv9rLwMqVhISX0+j4nbmboKShrLShoKuXpISXp7mA7Ze4qqi2saKjqJCDh5Cembus563O0t7g3dy/g5GstbqStK705/qDn6Slq/y2rLCjrcKAx6qXv6ivn5qOqJb74LzC0cHds9+52PXCm4KdqOqhjv6pzbf+4NKIkrWMgqb70eiKxLOk4O+5voTwoJWS1rKhmpvzs9aC2NaB1sTImKnQo6eszeqHlK3qzniinHjK0LXz8quMoZjt6cGlzMXn2/SFheFz0sbSc3l71bTtj6ja0N2Awq6otKq4r+/nurHU1/K6o/GErd+7hpD0xKWmkeHUoIn97sakqc3j+MDq5q3C+4WlvLeU3Y6xu/KEjpCXla+zs7Kal7Ovraucl5WVnqaWmpigoaT72MbAg/3xi5KDioyH+MK47N2jfJWXkabTn/3ioJSqdYu5z4DFeHR7joyKh4WAgp+1cZOx04qExJGIind5dn53fbbLmrLww56KeYKvw9+KoajM0cmxsr7Isp6wmc7u593LxsvUxbSLzJSbgK2e6vaonIGB/eKfpKavqKq3vbKlzMj19uj1/IyC/+3riubl6Y6T9vP9/IH46N791IXBlnOylKi/b4bZrpD/8JPCuqaAorul3sTz99uuqcaUuJSOp52V/OevmYW8ttzHipi+nvibm8aViJywr8iypY+5l7+oj86Xuf3V2undwvPdncmdrIrllM3Mgrb5moOSxZ/aoamP2/mxsOrNloir0IPox4DeiviCvYmLkrzX15i7o4bT/sOC8tHq+MGN7IDw+Mblg/uAg6LqzrvDsN6VjLivlKCp1q6Y9c6Mr4Dxgfu1kYeEmpqB1oeN957cl530h4yS/P3XvJbfjqawt/SdrPDwxuWK5Z7P6sfbr8mF2MXXk/j0w7PGloiOqsC0ne+eqc6KwKSOg6um4tG0jp3C85ukucK3m+ebztfbg8rhle6Lg6eUxK+AdW14hYVVfWBvg6+ulKtxfpBsfYOMXaSKhbmej2aYdJN2b8WQjHV+e83QnrGR1LuKjYN5foGDfnd3fXd6j5aKkZqUnMGDkYa/odvqhaaltc/IqqKyqcNy2nS3kXuIkIJ/l6ecpLKf7KR6eHmTguZtf42R4H9/hI6Pf4qBe3uChn6Ag4eaepCdl3h+iI2dn521xre+xmjGymdnb3B2asxubXN6g4CKi3l5hYeQoJCgoZqGmaCZkpOPiJKPjpGNmJ2WnaGqkJeJfoWMjYmCiYF8f392eoSFhIeDh4eJjY+FeoeGgYeQkYaEf3l7hoSHgYF+cGrSz8aclqmsqrXHtspryLKAx8lodomKaXVu1tPEu7ZnxL1san6Jg3rUwcPSyIx7gaabk6yqrb2BkouCf3PGyJ+Kn7Wpoqt/dHODw9DahJqFiIqJlKGMjZeBjHiFjptv0oGWioyWkYGFhnZrb3aCfZ+OsX+RkaCiqJqNZXqJoKiLs6S9stJrgYSHi9SqqY+ChZKAkYF3kH+EeG1qg3C6n4CCh4KZg5FxhKF+ZVZmcKJ7XLGAq47HtaZhZaFuYnLIq7tqmpCTqLabl2mneYaKxZqSjIntkbJ0tqxrt6W7iJ6zkp+sx+R/iq3l14KxmoPBzLfl6qCNnZzzxLutyczk5PmGh+Z118vadnx92bboiJ7LyN+AwquksKe8rvXot6zLy9qvjc1liLGOc3vElYJ7aZuVdFienI57jKGtrI/L0Z+y8HuTn5N3tHaWocVqdHZ8eY+PkZF+e5KNjI1/d3h4gYJ3fX2EgobNuLa0ctjRdHxvd3Zw06+u2c2dfJCWkZ/iqfjotKu+eo3L3IPSk5CUpaCemZ+AmbXKe5urxnx7w5ySkoaJhYmJjLnLpbTkw6eZhIuwuch1hYijp6WSkZacjn2Jd57Bvrenpaixo5l5toqUdpWJ0tuRiHZ26cyMkJOXkJSdpJuSs6nMzcHP1nNt3c3HcsHIy3l+1tPc2XDYzMbz0X68mnm5nLLRd3u4l4Lx4Iato42AiqCQuaXK0b6cmbF/m4B3i4B91MCZh3itmJ+gd32fhdN0gbqHbXl/j7eVko68ip6Wab1+mr+cnLajr/zJhMScqIzlndHIfK7DfF9+o33IdXxqt7l0iLiOZ1pwaViUsWavarBghlpdYmaUiWNvYmOctY9jrZ6zqYJzwmq2v5queumAd5nGo6SpgKl1b4iAZ3GAmFtcr6N0kl2qYrKHbXFid2doqHFqxImvfWzBbGxrzMqUdGaOa36Vkat1gcHOnLN7w3uPvaC2iptolYqmd7zEnJiednB1hJ6Zi8WBi6x1mXt1dqGj7+LIlIKPqI6VnKSScah3laSea5mjcatYXIFskXmAVFNdZ2tEW01VcIaBe4xXaHxca293SX1fXJSGd1R7XXhiXaiEkoKUj+Xsu9Cr8cyUlIyChI2PioOHiYiHoqiforSut9aBjIHUteDgepWRnauulZCjmKpjwmWiinWBiHp7j5ySlJ6P4q6KjI6kjv+Cmqio0nFwdXl7b3pxcHJ1eHCAc3iIboCKhGxyeXqJioeapJufo1Odo1VTWlthWK1bWV1hZWBiaF9ibG51gniEhoJyf4WAenV0bnd1cnNtdXt1d3uId352bnJ3d3VwdG9qbGtlaHBxcHNwc3R1eHh0aXd1bnR4e3Rzbmtsc3F1cXNwZ166uLCMgo2SkZikmaJXp5uArq9VWWZwWGRgtLyppKFUlpVcW3F5cmq6tLbEuYFzepiOh5yZmqNyfnl1cGavso19i5ySj5Z0amp2u8PNeYN0eHl3f457en9teW52eYBgt2t1a3F4dWhubGJaWmRraIZuhl9sa3F2e2psVG54mKWQvqqclsNbbW9yc8KkrHhqaXKAamNcbmJlUVBQZFaOdVlXV1lfRWNHUGZQOC9JQnRIMm1FX0tmbUw5OSkxJjlHO05CTzoxTldOPzRgJR0dQS4uJjXGZ4tllY9ZpYuGe36qjI+Srr5gYG+wkU9fakmTmo2kjVhFTlmfZn6RtrXE0PKUmvmD9+T6hY2M8cjsi5/O0/eAyLGotq/Ct//uta3Rz9WqgoBFWFReMjVeUmhkSmlhRjFgWFA5OUtYZFmIi2B3y2t+f3VflmB+jKdbZWlsanp9fn9xa395eXluZWhlbG9laW1zb3S6qrOwaMi/Z25kamhlvqasx7mUgpOZlJvwwvP11tPlhY3o8YfguLa3wry5tcGAvt77kquvx3R0yrCpqKGnpKWoq8fVvsXeyr22nqS+u7lla219gYF1dHN2bGBlVnmko5+UkpOcj4ZxspGVcIV8xMuCfG9w2cOBgoSGgYWNlIyGopavsaizul1cxriuYKu0tmptvL3Cv2LDt7Tx0XrBpIvYu9f5jXSbi3fq2n2aj36Aeot+mIuqtKaNi51uf21ndGxqu6uOfnKXbHFHP0hiTpFHOX5NQE0/ZKFLWGjCcXKFQH1WamJUYGtXebyNYKyPkH28f8XPbZCRblJ2dWZ2VmVUVElaRVo7MTgxJzlgVEd1SWorWiw0PEBXUURRPDtnZ2wpU2Ffh2VRnlOVl4B6O4GAQEtUPUdOVnxYT2RrRWNodjsfUlkyK0VBJI5wVEkvNzESPU5TfU2DYTJINDUwWzxOV0N2P0M5QYhdaaird3g3cUpcV1KEaWlJa2OBYXJ2Y0lHRk05Tz5ANl1ANzc/OE1OSGxtyLeRZV1ke3+Ci5FwUYBabYd3Y4OKZY5ARWVUcWWFfQR+fX59hXyDfYV+hn0Cfn2EfoZ9B3x8fX19fHyVfYN+hH2LfgN/fn+Nfod9AXyFfaB+A39+foZ/AX7Uf4x+AX+Efod/hX4Df35+hn+PfoZ/jX6DfZJ+AX2RfpR9hX6DfY9+kX0DfH19hXsMfHx9fXx9fX18fHx9h3wBfYt8hXuFeoZ5CXp6enl5enp6e4V6hHsBeoh7DXx8e3x7e3t8fHx7e3qWew98e3t7fHx7e3t8fn5+fX2JfAV7e3x8fIV9AXyEfZt+hH0Dfn19hn6LfYd8BX19fHx9jHyEfYJ+l32Zfgh9fX1+fn59fYR+gn2Rfgt/f35+fn9+fn5/f4R+Cn9+fn59fX59fX2EfAF9hH6CfY9+h3+FfgZ9fX18fH2FfAF7hHwKe3p8fHt7fHx8fYh8CHt6e3x7fHx8hHsPfHx8fX18fH18fX19fHx9h3wGfXx8fXx9iXyEfQd8fH19fHx7hHwBfYV8AXuGfAJ9fIp9Bnx8fX1+fIl9A3x9fYV8Cnt8fHx7e3x9fH2HfIJ7hHwKfX17fHt8fH19fYd8gn2FfAF7hXwFfXx8e3uHegF7hHwEfXx9fYV8BH19fn6EfQICBACAmsGovr7Ita6Hu/nZ8oODuN6C/e+kzqCX/ILz0sy2mZukjYiGgHNycHDLe31mYm9pamtsc3F8hIR1d3SEiIiFiYWJsLTkm8HfsauqkIyVrqi+qrzWp6KeqbCiuK2vr6yv5fv408LF0YuwpIR0dnHVu2h1waf5lrrasaminLTAvsWAprm5tKefqLGmqJeQpMXDqqeryeL34+7m/JGZnpWLkZGYpJ2mlZKTi5uxr5ygprq2vbS4vsTKzrGssLe/xcjMytersaCurb24p52kpJORkZGUlZyfoKOioaiqop2RkJWUi5OakqeflIShoY2Lh4eG942KjIaA8vDl8OHl3oGNlJCAk/aIi4WFjOHd3ueE9/TzhIOChvDyg47k9/2MhunJkMHd9ouGzK/ZmJOLgoSG6oOTsMW0rqOaj5eX1eqNtsWOipeLg4CTkomDpKaql6OZ/oaPrr+oj5XS3dbAqIqQi/myzq20q6auhZWI47mlroWUmt+eus6WkKvg2rqvjrHHpbqAq7SsnZqJhtiv++vjrqnJl7nQxKvAgvf4ipKMhrCwqqj9g6S/kfH9j7PnwaWu1ojhqKenndbkravD2p+9x9vdren989W0zq+8hMLUt8iHpZrljr+WiqmtlZOpy8vPgY+Ij8r9te/6h46X9rnqhL7CotuOiox+go6fpaWeg/aMu7aAo6Law8HOybLK1Ky41/C7rY/zg4WeqtTCndOEp8TEnInvvKKg+qWWk5jpq62psaeElrDF/pu0n7yssrOXmKyqmvHgga29w7KVkYro5cvGtvv+nrq5qqS1jpqsxsOpkIHqtMXdip6H5+Lp84LZw5/Np4WonGijuHR4koiAjpqkqrqAqJ+lV11jW15gYWJja21ucW93fqDXz5SXooJy0XBwy8N3oN3ly6WozsrgkMnz8fmD8/T948e3neqyoZ7Mwpq5oa+llZeRqp+flJ6km6nEsKSz0svUyMvVkpugn5ShmJmVjuvh04CGjZmK6ICG3OLVysCVcJSFmOjJxOHxgLyuvcKA39ns0dPgyty7s5bG5/X7zOHHrb+eqbvHiK3F3O6T29izp77Wsril+pWS0vKElJOt6Nak39KJyLL7pLmgwZKSg4Xc/Ye0guXGlJ66soae4aqbja/mpr6tyqrE66vDusTrsK6mjO6PyKHiguGXmOiVyriBsfqbp5XggcTs15uss8eA9oXHv4un2/uVlcGBvOKdw6+VheOs46eivIOTnJv29cmilpzO1KqE142Qh4q8xIe1nq+JlP/90O2FqoiAk9WKrt7Cqrye95jgiNmdjaWl/4P8usyXpPDp0KiP+8fVqd6ex6Tkquz24dajhMGL6eDc2qefqrL73OCsorWR2oquv4svbXl9goKNgoBhlLafvmtomLBoxMaBo3lzuFelmZ6XjpWnk5CMhXt8enjaiItybnuEdoB9fYaNi3t/f5GUlJWYlpq5wOGQrcafmpiCfoacl6eWo7uSkY6XnJCkmZqZl5rG19S1p6myeauoh318d+TSd4W+k92Eo7uZk4yGmKOip46dn5ySipGYjY2Bf4+opZCPkae5ybfDvcx1en94cHNyeIF4fnBydG55i4p9gYeVj5SQkYCTm5ygioiJjZOXmp6eqImOg46MmZaHf4WFdXh4d3Z5fn+BgoCChYaAfHV3eXVwdn94hn93boaBcG5sbG3MdnR2bmjGwr7Ft7q4anV5eXjKbm9sa3K9ubrCb9bWy2hnaGzEx297xdLadHfMsnyhustzcbGUsHx5dG1qbcZ6gJOkmoCUi4N+hIjE1HiZp3h5hXp0b39+dnOKjZOBioPedHuPnYx7f6qxrJ2Lb3hyz5SjiI6FfoBbZmm4oY6de4+b0X+So311i7/Dp56PprODkYKFfoByYWGWhLern3BwhWJ8j5yAjFalpmppX2mHhHaLu3KFjXesvGqIwKd6g49et5CTj4CLuLODgoinkKan0eSe0ObKuZ2ol5Zqsbygq3SamdyNwJB8n6CMkKW9v8B5hnRuptWm7td8i5T2vuV+paqY3pGNkYGHkqGop56D7Yenq5qf176/ycWtycGgqMbhqpFcplx5m6fJs5HJe4mZjXRgo4yAgO2YgYKGzZKRj4+IanmRl4DMgZKBmo2Qknt8j4l+yr9uj5igkXx3csfJtbmv5uSOmJmOjZl7gZClnpF9cNewucp5hXXHytPbd8y4l9CtgaGacb7OeH6sqZ6mscHH0762w2drc2xvb3Buc3h/goOAhoqmzsqYm6OHeNt4dtfTe5rFyLieo728xXihxsjLbMnN1IDEraCL16ikqdCwhJ2Kk46Eh4Oai4t/iY6GlamdkJ2yr7ixrrJ5gYaGfYqAgn53zMO4bW91f3XJbnLCx8TDvpd2oHuNx62ow81upZelpby7y7C5v6y8pZ+HsMPQ0LHArJWmi5ezwImrsqeTcKmlioOYopGmlOmHh7zshZt7kcS2j4C3smKfirKBoYOhho12dMXofqBju5VvcZGGZHehf3BkocCcnZCVZYahho6corV9dntuwlh/ZoVfiVFbqG6VblNqrW+FcLtuprm3iZegvu6ArKNpgb3UeX6MZoSge5R/aWmvh698fINZbHWAz76agIZ+sbF1X6iBgmxiiKlld2p2XE1jqJiMqmCFX1V5poKQsY2MkXO2Yrdur3x6h5TJaNCUon2T1s27jXXUka6Xt4+1lNin5cyZopB/uX7Bo6CQdnWAlLudpHt6hGmPYnt8Y4BRW2RlZmheYUuBlIKcVVaEk1qmqXGLY1qSP3l6gX+RnraopqWWj5OQi/Ofo4eAi4KBgoCLjJScmYeOkqOmqampr7XJ1ueEmKqSjIt5cneJiJSCj6WGh4eKjoaXkI6KiIqstrOXj4+Xaa63koqJg/v4kJ2+gMV0i5iAfnVyg4uKjIB4g4aFf3p9gXh5c3WCkY+Af4CQnaiYpqKuYWVnYVxeW19mXFpXWl9cZHN0a3BzgHt8eXl6gYCAcG5tcHR2dnp7h3R3cHd4gH90bnFwZmpoZmZnbG5vcG5uc3RvbGZoaGVgZG1pc29oYnJvYF5dYGO8ampqYlqqpqOol5udWWRsboBrr1tbWFhdrJ2ep2K/vatSVFdbqq5na7XEx2tsv6R1l6y5aGSgh6BtamdhXWCxcXWDkoqHfnl1en69ym+HkW1wem9oZm9xamh4d4Bwd2/EZml3fnJobYqLiIBwXmRgsHt+bXNqYGNCSFKekYGYfJepy257iGtkdqq2oZaZpqtvc4BpZ2BXWEpHZleQgHNLS1dCUEtYQl44W2RFNTg/PztHOXIwYnJNYHVFRFMzQkFVLFw8MTsxTFtCPlRRKDI1SDs/W5CYhHyMhntbkqGRk2l9fNBwkndie3tqaHCMlKVWW1dHcZV6sYY+VGSZlLtqjJyi5pygpJSap7nAvK+N7Yehr4CXpt/LyM/Pt8mpj6SxyKp+OnFGQ0xHXlZCXTlOdndRQW9XRUplbE5AYJ15gH17cFBcdXmlbn5whHx9f21sfHdvuKtgeoOIgG1nZLfAsLez1t+BhoZ/gIt1dYGUjIR1bNS6tL5vc2Wxt8PNbcavlODAgZqchO71hIPW1snN2e33/IDk4fqCho6JjYyMho6Tm6Sjn6Skuc/JqKqslon9jIf+/Y6ctbSyn6azs7ZlgqSurFuprbSqmY96y6K/0emldop8hoF5fXqLfnxzf4B4hpWQhJGenqGelphobXN0bnhwcnBoubKlYF9jamWzYWSrsrDCuqCJt3SCqpeRrbRilIeTkoCipq6aoqOYpZWMepunr7Geq5uHlYKKtMKaqJx9UEhOUGloX0ZGbVuAWzZ3s36+YW2KUj+ATjBRUXZVemlwZ3xpUpm9XbBco4NhVmFmQU53YVAwLEk7P0ZiNUNcTUtTUYZFPS4oQC1BTUBAeDw6Y15mUz88dltoVIFRgH5zVG1ibYBiLWFhMkBbdFhfb01zg1JdSDg6REYuNS1GTVVgZGQjIzEcQ3t8XUN7U0JGXm1oNltfZD9Bgo9ui1BxVUpMTSJFc1xublyJNIZIRFo/XVGvUZlZZ1FeiG9RVjl1MTREdDx7fKJ3uZpugHtxo2urhn5uXl5tkqyBh2drbVRrSVpdTol9hHyEfQN+fX2EfgJ9fo99AXybfaN+hn0HfHx9fX1+faR+1n8BfoV/h36FfwF+hX+EfgR/fn5+hH8Jfn5/f35+fn9/hn4Ff39+fn6Gf4x+gn2TfgF9j34BfYp+iH2Gfod9iX6OfQF+hn0FfHx9fHuEfIJ7hHyEfY58A3t7fIl7h3oBeYx6h3sIenp7e3t6e3uEfAF7i3wBepJ7BXx9fHx8hXsMent7e3x+f359fHx7hXyKfYx+gn2Ifod9jn6EfYN+hH0Gfn19fXx8hH0EfHx9fYt8mH0FfH19fHyKfYV+AX+HfgZ9fXx8fH2afop/g36FfwZ+f39+fn6FfYd+AX+afoR9BHx8fH2JfAd7e3x8e3x7h3wBfYR8AXuFfAF9hHwHfXx9fX18fIZ9knwFe3x8fXyEfQt8fXx8fX18fHx9e4d8gnuHfIt9Cnx8fH19fX59fX2IfBd9fXx8e3x9fHt8fH19fXx8fX18fHx9fYh8BX18fXx9hXwGe3x8fXx8hHsCfH2GfIR7hXqCe4V8B319fHt7fHyJfQICBACAp66a0LWisb/Yzs6Ro+Wb6rbE1JeWr5iMsLSN57yFeYyDgoiMgn+BeGx2cGG1rqJjg9Dd2dD5rIP3x6afxOKxornbmZujgY3AvaClvr+omYyNiIeBlaWvp7bAtMrvkIXRwNLy8cCgscSW5umQdXJ3brpkd8vdg5Sio4iUlJmgkuGA7+u5gJGfo6Wqq42cpqS3uM7M3enm1NPj/5KdkZael52elZusl5WZlpmVkpefoaenorC0uMe8srOsr6+7xtDQysWsra22rK6sqKetl5SH/YaVmpmVlp6Zm5KQlpuWiJKgopygoqCflI+SiYuNhvPg3/uGkLCjh4Xv5eDl5fSQzs6A2sDd6MTNw9mqveDVvbuq4O3/5oaH69PkhYKA14HSjKnWjoK2pcDI39ilv9P55beHkpD9pKfPtJzjh5K6zL+g6cHTl5ShqKqWr7yX+ZSN9Y79mLmZ/sSmy9XWyOHGt6Cn2d2lysWTgO3inu7qnJKKk7CNjKiX6+O+f4WKg4qOxvyAj/PzzqOkga3froez+NeloJaQoN7al+rUn5ebh5ub97uWp76Azoyt+ai/1ZSquYDapramjq2OoKmYssD3l5uwk6n42tja07WnkpCQ5p/d0qmw2cjB3LHB0eOvs/zf/IbpmITOqZTEl6/Sg/yGiIqA+4p5h5aWmKSeq7KvxqK3n8GAmuvZvrTE093UoNno0aeCoJCP2vLHko/3+5/i1YOQ5/Lkgd+HgIzM7o2J9uSMjoqanqertbWlrr23yKyqpf/zju302oGE07e5g/qzzYyfwMPAzsrKx7nC3tC3xuro3s7ZxcS7vpSF2cGP3I6ixra8n7afl497inRko4aAhJSlsKSAYG1tX11rbnB3dXePi3zJgPSXxHx+lXeChaPeonBrbXRzmYh2iYanz6PHv5WjvdHa9vz94u/UkI/ui6iropqvqJqa//2MlK2+tLG/tMjL1NjT3NHT54aUiYmDloKDhYvu9/+Gjp6gp5qAgv/mwf2TkPjtoYmWlYLz8K26zMHHw8GAwridq5y156mMlq3w4s7gvcSmmK6Wj/PR1It5fJCCkYDi8svKhJ6mj5uBsPOsjYHzpZ/r37+/x8X27IrNx6OxteSUgqKgkZnGw93lhIP83eXyib6x38S2i8mdjuOftMyYidLt1KOqzfW/8YuKgYX0krff0pCTlpKW67ji15fS9POAicj60O+HoYaThqKenpD25NuK07O89Zb9qYPl9taAnoaW//aSwuyutcHVrrvktf+sv4yX0ca82K/g1ZPmksubv9WdvsDLw+b+k66ilJGx5O2Gi9qLyPzpipfRm7Xz5NC39L+ApMXui9zL3bqtvqjQ67+4lpnRtu7BuKue9sG7ns+Ab2tml35yd4yVpaVsf7KBx5ujoX59jn5yi5B3zKqHfpSMi5OUjIuQh3iFgXDQwLNti9Td2MvvmXzsxKipvuS7rMbdj4+WdoCtqZCRqamTiH18eXl0hZOZk6CnnbHNe3KyprLKyKKFlqWBz9OJeXh7dtB0hMPKdYOOj3iBgIeMgc+A29KocH2JjY+QkHmIjo6enq+qtcK/rrC7ynV9dHh+eHt8dnmEcnF3d3p4dXmAgoWFgo6OkZqQiouGiYiSm6ChnpqHjIaQiYmJh4eMfXdtz2x4e317en55fXRyeXx8cXiChH6CgYB4bWxzb3FybcS4vdV2e46Abm3GwLu/vsh3rK6AuaK4w6mto7OUpLavnZ2RtrzRyHBvxbG/bm1tv2+8fJCweG2fj6Cit7KMpLLUxqN4gIDciIeonYfPdn6araWP07O/g4OLjpB8kp+C4YB82XvdgpyB37mRpaqtqLyiloOJr6+Gn590XLe4jdHBiZCJjZhmY3p3yceqe4WJg4uMueCAdLyzmXh4ZYmchGaJuphfa2lldaSYcZKQgV5pZnJ5xp54hbRskmeCt4Kes3d8h1mchpGFhpp9h35+jJO8dIaceZTatq2xqpKWhXuAvYjBtp2q2cK31KO1zOKtmsjJ4nzMf123nomJeJO/erxzd319/ot6ipucnqmirrKqxaWtjbGAjt7Kt7DAz9rQnMnXwZZremZckcSvgo3c85LhvHVxobS7YLV4bXyiyHRwzbx1d3GBg4mMlZKIkJmWooqLhdTKeMfOvXB1wbC2eeKxyH+Lo6KgrKuppZ2kuKmVpLy4sqixn6Kbn4BzxK99zpKgpaG2n7Sck4x+jXltu6Kdoau+yL2AbXp7cG57foCFgYSgmYjEdeCGxIOFl4CJjqLRoHdydX55lol4h4KcwY6qo4CKoK630NDTu8izg4HfgZeYjYSTkoaI6eh+hZWknpqmm6quubyzuLS0x3F7cXBvfW5zcnXL2thzeIeGi4VvcN3CqNJ4d9PMlHR8fW3NzZulrqWnpaaAqaCIlYeew5h/iJjLwrHBpq6ZipeEgNnBxYx9e35qd2+py7OMYJKbfopqovGsjIXZko+6pYueoLHAs3q3rJKxmrCEdpGZfXSdj7C9cG7Rvsu3Z5qQ0qqbe5J2XJFtdnBaWbXRl2FxoppwpF1PQE+ybIaRfVNlfnR8wpC4sn7R6eyAcLLhttdvfGN8ZXZzfG7GqZ9Zm3iMvWTHh2W8zK1fdWtf1tt0jZZ4laCojpKrkNWPlXN/jIV0i3Koo2eXdKuDn6l/mo+Hl6fGdoCKd3WQtLRtccV3ruTIdnmvf5zPyr+i5612nMTad8K6xJ+VlICdrI+Lc3ackLCJeX5ws4t3co+AUE1Ne2VbWmpuh4RYaJZzu42Rf21wfW9ieHprxq6blq6mpKyloJ2hmYeXmYr+6daAnNfd287hh3DYwLGzweHHvNnjh4KGb3mYmISClpaFenJvcHFtfIWLh4+Yjp2vaGGdkZutqYhxfYduu7+LhIWDgvaRoMC7anV+fWlubnZ9dcSAz72iZ2x0eXl6fGx4fXyKiJSUmqWll5qhqV9lYGNnYWNiYFxhWVphYmVnZWdwcXRycXh3d311cnJqbm53fYKDgX5wdnF5c3V0cXN3bGhgtFxmaWtraGpobGVkamxuZWhwcm5xcG5kWllgX2FjX6+mrsRqa3lwYF+xqqanqq1ooZiAqJKarZqdk5uIj5iRiIyElJWwsGFerputZWRktWWpdYOibWCTh5KPoJmAl6TBs5VxeHfReHeQjXrFbXSGl5WBxqm4dnh/fnpsfIZx0nRvyG7GcYJww6t5gYiKjZWDeW1wjYptgYFdRZakhsuwgJmZj5FQTWFktrqigZGSi5SRtcuAZpaJb1pcQD5saFJsknA9TUQzQ19oNVZgPEA5KkZef1JRbVk5akNSZEhUUS87Qy9YQTg8KDQ4Pj81RUpmNycyPluYh4iNkXVpYldoq3GhmYiKnpiXqpOWkZ9dXpaLmkZ/SjF2dWVMQ0BiRXFQU11l+5SGmrGwssG4xce616CukLaAi+HQuq/E2OTXoJuurWxUXEo/Y2xPQT1zgUpuaEBFaY2aRpNfU16Ao2NgsqBiZWBvcnd6gH53fYWDi3p5dsCxare3q2dvw7W2cdi8xneCko6OmJqXlpGVpJaFjaGempScjI2Ih3JptalwwZ6wk4m1qLOgmZSIk4iA58zNztXs9+6AhpOUjYuYmp2bmJ65sqLKbdR6w5mapJefpanHoYiCiZKMnJGEi4eWuXySjnWAkZyktbO1o6qZeXXReY2Je3KCg3h+2dp1fYaTjo2SjJKbpKWdoKCjsWFmYV9jbmFmZ2a2xsFmaHV0dHZkYsKrla1jZraximNlaV6ys4+TmZCPjZCAlIx6hnmOp4t0foqyr6CrlZ+Of4d5dMq5vZWPhmtUUU6Kl3lRQ15KMlI4XauTj5uMLy9yaTVAPDlcWlWhioeyZ1BPWH2jeWpseXyUQjdYRWFuMjRBQjg7UldOSX1WZm1OPHpcRx4pT4JsgEtGMz2dYVhdWDpVVFE+bG2JbD1fj4eAM1OAbnM6NilEQF5RUUeTb1QzNzBFQxNTPy5pfXc1OxgcJ01GYodkc3SBcIKfgJBWTCsvb2dLfV6Ef2F7WmY6Y2lIXXBidWuRSE5DWk5wmIlPTJxffbmnRFhzTi9tjnB0uHpPZZLGZqi2r4aBbmB6h2xoWGqHg6ByYWVZjWlYV2SPfQF8hH2HfpF9g3yHfYJ+in2bfoJ/in6HfQF8hH2KfoR9ln61fwF+nn+EfoZ/hn4Bf5V+Cn9/fn5+f39/fn+EfoJ/j34BfYV+AX2GfoN9iX4LfX5+fX59fn5+fX2RfgV9fX18fIV9hH6LfYd+BX19fX5+kX2EfIJ7hHwEe3x8fIR9kXyLewJ6e4x6CXt7enp6e3p7fIl7hHwBe4t8BXt7enp6jXsBfIR9AXyEewt6ent6e3x8e3t8foZ9BH5+fX2Rfg99fX59fX1+fn19fX59fX2afgh9fX59fX1+fop9iHyPfQN+fX6WfZB+AX2JfoJ9kX6Kf4N+iH+EfgV/f35+foR/n36IfYZ8AX2GfIV7jnwBe4Z8CH19fH18fHx9hHwBfYV8Bn18fX18fIR9hnwSfX18fn59fXx9fHx8fX18fHx7hHwKe3t7fHt7fHt8fId9BHx8fH2EfBF9fH19fHx8fX18fHt7fHx9fYd8BXt7e3x8hX0De3x9h3wDe319hHwTe3t9fHt7e3x8e3x7e3t8fHt8fIR7Bnp7fHt6eoR7CXx8fX18fH19fYR8iX0CAgQAgMfhq+Djvc3f7orDooeAt8K9ktSDr+PF/oPlknyDjXl3h5K5jHV1fH2An7K44v2qd96juc/NrqP/k4mjjJeLy/qNk56SkKzFybOWl5jDwq+vrKmowcCuoJ20vsSknczo+N6/ycbFvK+Vjquf89OThuDIY3htcoyVoI6gtszX2fSAgMWrjIDZlYHLycm7oqKroqi5vcvS1N74hoeNi5GanZqfmZaNkJOTm52gmZiSioqYj5mamqCXmZWepaunq7e+vcernrWropqZlKaZl5GXj4SNpZqgmqCbnJiYoKKdlI6XmpeVl5uQgvTo4uf4hon38e7+ka21sYvp59HZxZaemfPYgKiahYOQiaqmvfLu4cm9w9nW3IGKgu3l/ePn+YHUioOGhNak16LCpqCas7G2vYaSmYWRsqSQjuD7hJq1gf+XurDymb7euZSotLiumpqG8MPs3JXzmoq9lKSas9j6mIr40sa7vMG2qe+A1oSY4t7NoZydpMSSlIDshtjix/rlr6+KgLfG79G18aSiv8i4poD94MSw0YPOteOVwZm/p6nFrOicjai63OWJ1c3NosKToMrZld7Whq/pn8q6psvY+t2yx8GotLua4oSL98SiyZ26huy8oILfjqTQuvWS/MLawq/2z4mjw7qqneyzx8fxr7GH7LCkj5GXj5iFoLbHpb6moI7ngIbC+9SO25GClJKSppD3zIbi1cvfvrL8mqWArsHIkqzl7ZStrLGvtqidoaywnIqUkZCDip6blpSfq5+QlpShmpz8wpaIwryj3pqFlp6XsuTO2djN062jpdnInJicmor9jaeisay5payA99WetoeegfmA4OHs1ueM3G2pm6LAjpN/gI/Pgo2rvcKQjJyVq8rJv7jbmLFwen91inya99KDbm9tcm3OtLTlia2ipt7Ir92TgKfVvs/Nvt7b2frZxZ+3rqemoam5vcC6trS5ubacstfe4u/p9tbg+/r0kPXXxd2HgIyGmJmmoZeO9JiP9NmQhpOlr5XU/ufRt/eU7+bMwZyhgJjMrJefr8Ogx7OS4+vAu+fDqqLyjObqhsmcmoyfhoSHiKnA3OrOnJX6tOPFzvTLwrGN/Krez6KMyt2KnI+fhMvP8aLmp+Tt8tGnjPKHtp3HyLKPq/Cho7m5463Hg6D3qqHQzpbb0LG0wNP00IzP6a39p4ily9W53OO3p6j0yJTNgNuxx46j1urhkMnZq6PE/P2Ah4uFw9/5sduD9Miov6PBq4icwYelsui36o75u52W7O/P6qyN45mY7rmOnYDQo821vrDikMv8zKKGr4jN/LCRi5rsyavb8KOB+YDli7mspoP6h8LWl+rPtZrruq2W4qq9yLSm54Gk4snV6+6Y9rvOgIeNca+ehJWXoGyTe2ppj5WQbqhsmL2t123Li4GKmYCAh5W/mISHjY2Ts8LE5PatfuCYq7SxlJDzhX+Tf4iDyeuHipKHg5qvsZ6GhoeqqZmZlpOSp6qZjYqgp6yQiK7G072lq6qlnpN9eI+F0sCPjezZcIp8e42Vn46YqLrExtpzgLWjiX7ck3Osqauei4qSi5Wgoqmus7jJbGpxcXR8fnx9enVvcHJyeXx/e3x3cnF7dXt7eYB4enZ8gYWDiJCTk5iDeZOFfXl3dIN5enZ7dGtxhHyBfH57fHp9god9enV8fHt5ent0aL+6srPBbHDJzcbUeIuQjnC+u6yzon6BgM/LgI+Gd3WAe5WUocjEuqScnK2psGh0a87F1L/Czm6/dG5ybrqSw4qhi4WCl5WYpHiCiXp+lIp9e8rfc4OZct6Fo6XWgJ65noKOlpiShId23bTVyJHZgXqxg4yGlbLHdm/LrKKYl5uRibNjoGZ0sa6xlI97iKdxcGTAZ7HArc7Fn55ygJOatJ+PtoOBkZeKgWTBqJSDmFiZhqxmf2h8XV+BhrJ1bZOiq79ys5yXfJFudoOcZKeecY2ac56Og6C2uKqepqSJj5N/wG5yyqeKro+gedauj4Drgoq0reGE1pizpprHuXx+qaaOfL+SlKnouruV+rOlkpKbk52IorO5kbeRhnvDgHOy3MqCu3t2goh4k3fPm2GsjJOhiofck5l3l7W3fZG3xHuNio+Pk4eAhIyRf3N6eXlscoOAfHuFjYR5fXuFgoXeuJ+Qwb+t3ox9io+Jnr6ttraws5GMkLuphoWJhXvvgZWQnZiijpp23cafrnSLcdhzzMjOwc160XfKvL3Spq2SgKDYhpSvw8aenqyjtdHJubPKlL11foZ8kIWb17yBcnZ2fHTVrZ3DcY6GiMOwms2JcI23qLCxpsG9uNK1qIqdlZKQi5OhpqWem52doJ+Gl7W9wszD0Le90dPVe9W9tcNybXVwgICLhn950oF41MV5cnuUnou31MO4ouKG3dGtooaNgIexl4ONm6uPsKCGxcioqdq9qZ/efsvNcLOVmI+ieHJwZ4SUy8vElILimdzL2/vcq3td24+6oIRyiaJ/knyNfaqVzJHTm9XJz6yMg9x5iXy0r5B9i86BjZiRlYF8VVyLY2CdkHGDj36CbZS0gVeBsovEcGuBhamctK+WiYrZw5G8gMOgtoecpZy6bpyahHudwrlfaWVkhoi1fpRr2KGJjnaejHmEjWp7f7KSxm+4jXdoq6aGuHdjkW9wvptoYFujeqaYmIebbZrRr4xsiGadz4h5cnLBtZXByYxs1nC8fKykknvugrrPj9m8oYHClI12o22JkICBnF92sJCeoKZnp4mGgGZlU4l6Y3F2e1x3aV5cfXxwWYpfhKOdv2bImZultJaXipO7qZ6fpqOtzdTU4+22kuWKlZqUfX7edXODdHp80eN+f4Z9eo2dnpB5fHqUkYSDg4KBk5WIgYCRl5h+dJautaGSlpGKg3prZHRpsqqSlf/6hqaYkZigpp2corS7u8ptgLKol437oGeOiIyEdnZ9fISPkJSbnZ+tWlleX15lZWRkZGFZV1paZGdsaGpqZmRrZWhqY25oaGNna2xtcnh6eXttY31waWdkY25qamZqZVpeb2ttaWlnampvcnhubGdtbWxqa2xmW6afmZigXWK1tbO+bHd5emSpo5icj211dcbDgH98cmt0cYeCiqOon4mCg42NlVpkX7e0vK6vvmKxaGVqZKqFv4GRfXd1iYeJk3B5f3B0hXtycMHRbHmGac97kajMdo2mj3h+gIF+dXlsyqvDuZTJcWyqdn10fpKfW1ikjYR8e3VvbIxOeU9dj5OgkpBp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k42K8Ofy14T3y6+Cl7n+hfP+g4iQ6cC2trzJ07ev1M3K2c7AssPp38bE2vGC1undhJmWjZr18vTjgpSBm5aUjJGOju/YiIaIiYTWxcq56fHMxv6O27Oyu5u1vIC7p521u7G5urjHybCy9dx/w+KXkqGPk82AnIvFy4WOy6uY3/LwlO2z3Ju0yXfeuPeO29OymK68+/7WhoSaoorG0syTrt+GjYehoNOEr6ynsqzf5f6bgaqyycfTt7iBqZPwmrWluq+Fp9e+ltf3vMClnODYi8CKiPTO6rOImfSb9oDLv7a45raUk4uo04ignKSosPXQ5uLkwp2EgPfw6PbVguCxh+XoyKqAqPXmrefvstCDiL+IsuSbm5+dnIaV2JjossiMk9De/sDJxv2WqIioh9Ce3uDh6unQ7KTthZy9i/D9huzylL219Yv0loK47YSi9ZvFj7+Nydv51+uaxqaD64Cqqn6SqHRgnWtzfoGuq5uEbZKchXem1tLTfpaBe4eg2YG3e3h3gqSfqMXyj5mspH2Me4CxjYWMeYiG6oCAm46IhIiElujVgJajmYJ4jbGpoZi0oqGrr7vBvr2qmsB+f5ilqJa4pH5/i3x3cYuKeZ762Lt0dHxrgp61r8LLyOR+eICGhYZ3e87Jx9qKlYuTm5+ppKy0s7i3vcTIc3t3cnV9ent9cme6bGhxcXN3bNHGzMhqb3RybnV4dnl5fnuBhomKiYB6fn99e3Z7dXZ1eG5udXV8enp1bHJufYKKgndtb3Nsb3tyc2u/v77Cb9FqxdBrdn59jI93acO8rqW/r3zU5oDL4HmQlqCYr8BnxHfHvamem4qElKis0ch10G5rcMbUmKGjmIuEg46EiZqolpCalZB4k97Mc3uJiYNxe4N1gX+EnJ+ZpKd5fJ2fhnSFiXetgregtNd8p57knrO9wGt7np+suaKDep2HbMavbW52xM11dc+3cJdrr712boW0rpuRyICTrIKLeqi3xrNrvpSTe7aSoml+dKmVeLOslmtjfG1odM5wZHvTem2EabZpo4GJaZyNuYZ+iWpqd2CqWKWOYG5vc8HGoKDMk5d60IS538S2ucGbwIeztby7kJ1l0a1sbNF74nuMa3mVsLW4xrCr4JKdr6WioKGWpbSrot+8b83TqoCSkI2bxITJiZuHgn+ieXijaYJpjZS/coOidXePkYt4doV4e5mXj5qIcMe5x87PddHJbmt1fneEiIqFinzUtbLG5cHE4cPgg4iapLyosbamlefQ2pXtta3be9mt0X26mL/CfumBj+3u03rq1rPSnJ6geox4dqR13c+2doCJn36DzICft56m2NLennqCnW9q0MDRwKSXo8OyzIZtfo7CecuIleekdn97eHRzzMHNt2/RtZ1wgJ/RbsrTbHF2w6eem6GptZ6Ws7Ctu7Glm6rGvKupus1uucu+bnx9d4PT1tDFbXxugX9/dXh4ds/Bc3FxdnC5sbOjy9Cxp+F8u5ecn4qcpoClk4qepJuho6KusZyc4NB/tdCKhJODfrV5kofHxXp+sYV0x9rYgdOg06OnvYbozNp0lLmQh5KQn66leHh/hnepkol5qsZ0enV6irtylYduj4C8xr91YpCKhoKkh3pYbmmkaYCFnKZviJx6bouqdY2AeqSnc5NoZ5abuYRzh+SJ24C1r6Gm3ZFtcmmSrGZqcmt6fcCgycKtoHNmV7ysrrqZZ6uMarCaqY9igsubbKKze55UY4Zehbp9gHeIg2N3knXMk6lrbrXA2p+sotdxg2pyXqV4xcHDxcq5zZnOY2mkfNnsftzki6yi2XS5c2OGoFdxsm+PcpJmj5irmJ9nhXVcpICLgWJ6j11MgFdgammTkIN2YHeAbWShx9P8lLKalKKjum25kpCVnsG3tcbqgomVjnWcj5S+g3l8cHp623N1jIF8fH56idzZfYaOhHVsfpSOiIGWh4mXl6Wrp6SYibJxcomSkIWahm1rdGplXGtuZI399uOPjI6Ekam2qrfBwNFzbIB3c3Zqaru4t8h2fXZ8gYaPiJObmJ6dnaSoX2RgXF5kY2NkXFOTWFZgYmZrZLywtrZeYmRkYWNmZGZmaWhtcXNzdG5qbW1qaGZpZmZkZl5cXlxnaWZjXWFjcHJ3c2ZgYmdhZGxlY16op6auYLpdsrhgaG5sdnpqX66impSrqH7S3IDHzm17gIOFkZlSpGWpm4+JhnlxfZGXvLdmu2NgZLK8jpiZjYF8eH93eoiVh4OKhoRvhdfFbXJ+fHlsc3htdXN2homKlZZ1c4yKd2h2e26pi7Cbq79upaLVhZSYmFNegoSNlH1iXXhoWKCIVlphpLJsZbKZWoZalqliXXKVj393qIB3h11pV4FhjZBUl3V0YI11fVNfVHBxWXh2ZjcjQjUy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gvSDw5Sv8IfxzN+AiIfu7/34gfv+8/uD6OPl2LbC3PDzkJWDoJWCkOvK6ICR+4b0iImQnpuXgfaQ57WD+ZKW/aqx0YKZuLq0p6itrs+ugOjAo6/Oz/XQxq6XhoK7jPWk+cjkqZ+f7Y7A9+vCsNqcopDThcKDtOarmIKW1rewzcify9SbnrjIvuCSi7WOgdCJ6NyKt9e0ud/xtrKk7rXtlsLIs4qSmpedl7+w6vDirverr6SastXVvNvKz7/JvJWGj571o6zd1eGWz62f+b6qgKWUx8+g6rqTrLeC54OrnKTr6YTPj82tg6Wjq9+KpYmbpsagi6Dfv+2i88CliquGjJqBj5yCppOolMHcpoTSsOS9yqS0pbyAzpit3tTN09OLx7bD0byQjIu8t9Svpd2m+O+L8IV9rev4kL3jiPjx1oaAioPw8ePhw6yurpzLq/ajgJmRhWaXln6UsoaFaKmIo7C9qaV+y4PKeIKvdtHeqbWaeY+no5KZv4zHcsm3o7W9u6B8poepqdPchY+LjYx+kZWFiIycs6WToqOJ4ISozbGsuNHRp6/NbNd2c3ltxKKfrquwlaGdkYTXcH9zx4jbxIlyaXuSkJaeucW/qLPV49d0gN/fdnmthIqTp9R5dnd+mayzs6i5ub2taW5veIR8eHt9eXd8fG2wuL7AxbCmpZ6gsKq+amttamtydnZ2cnJ4eXp5eXFvfXt6d3p9endyaG1sb21scXRxa29yf31wbm50eX56d3Z1a21scHZ4bXhxgoWAgoWJdXRxariwr6+akoaKgKOSpbaTrKRnyH+Xl4a0rLGfiOjfdoV9gp+xxMa4b2y+us/bvo13j6Oov6aweorXdHjG3oiUgpDVgcnUiZGOlaSlh5y0oel/fXqFj4+IinSVwdt5z8Cdqp/Sm6CwaMuZb4CvyraWgIB7c2tmp6xjjJWBi4a9nqR5ksiOnn+5mJ2TgG5qyX2kmI9sfG1ua2ZtYmanaKCYmIJylndkkY6Vo5JsaI1uZmKUmouoiGqsxnt/pb5ufJR6Y7GXqKVXb7FdaXCKhsfOiYufrLCWtqzLcnHLeIp5z3Nv2aSjpG7Kq2PI02vLj5yKipq6ZpeSufPG3veZrLOplJm0tZ/cfYmhpsbKgKN76X6vkMaklbB7kZWGmcnG0dN01XJ/hm+Ph3m/f46Qd4OMhpd5eYWIfNVz2Xt/iXNyeISIe3h9hH17fXvgeXumwXvT8HeYlIWRoaqtp4R9oH+1wK+jtNvQx4+pj32SmJC22vTX4nh+1d584/iWw4DPjIGfi6y3e7mycHp/yYWfgI+hmpOVh9G8jde1q6mYg4mSsdDQi73TipagrozEcGxtj6LRo7KztLesnp+ov3iKj3xzbMttp4SbyG/Nq7xqcG/Gy9XRbNHRy9JuxMDDup2pvc3Ren5uhHxxes26ymt61nHVd3V4hYKAbdV7xaB46oSJ6pidx3uInp2ckpKVlbOXgMaqkpe0tc6vrJ+MfH+2gOqX6K/GmIeH04+w8uO0rdCGjn7Be610uuKxnoOGz7XO1baKtLyRh4ampq6Cbot1aZRhrr13k7Obma7Klo1+uZfYeZ2chlxrcmF5bIuFk5GQdZdxgoJ6ea6ZiqFziIV8fXZWZH/Fh4i7paF4rIuO5KaRgHqDva54q5RmeZduwGqHdHvAuW2xgLWGXGSAg6dgf3F9ipuGcYa1iJ19vn1oZX1dbH5oYHZrfX6KYYKqf2aKisihoIySkq5qsH2Orp2dnZpdgo6lsqODfX6ko7SDiL2T3uCC4Xxxk8fRcHuUXaqcjFdfZWK9qqC2knp4dW6JeapygIB2Y1V7fWl/m3VtVINig5qhmZFzwHvXhZHNi+3uoauhkKe2saKqyYCoXKCWjZ6gn4tzr5i0sMnLeX15e31zhIZ8fX+Qn5WBiot2xHKPqpWQm6yvi4ugVbJhX2VdqIyMmJOWgImFe3C9YGpgqm61ooWCgIqemp2mur++qbLJ185sgNHUcHCpjpeap8Jqa2VthZCTl5GcnaOTV1pZX2dgYGNkYmFlZVuVnaastqicmpGToZqpW11dWlxjZmVlYWNoaWlqZ2JjbGhoZ2dpZ2NgWFhaX11dYmNjX2Fib21lYmJma25raGZnYGFhZWhrYmdhbnBrbnBzZmVkX6WfnKWShnd4gIp/hZJ8jYlQoWJ+gXSgmpmNfuLWbnh0eo6drrCoY1+rrL7JrIRyhZOVppOecn/NbG/C1H2GeYPHdb3EeX58hJKReY2ikNh2cXJ4goF6emaTtMVrv7Whp6HDiIyUUpp4XXCToZJzYWVgV1ROeYhSdH5tdHCcgXteeLB3hWeYeoF4gFZOlF+AdUdGXFpZVlNXUFCDTXZtcV5IZi8tXVpjcWZOSmhRTEp0dHF8UzU3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8+v++ISOjYqKnY34v8/spbPCs7Sjwfj2ma67t7Oxn5ST9NXJwOft6e+PlvzqgYKE2OTw65GFiIGJk6O9u8fX19TBxKmf+IKhrbiulZGGl5C2qcHHwqiwtYC0tt/h8oyT7r+qwJ+EnNvIzPj+tebavbvG3Iz3gtSkoNKaxI2TgMjhg9/sqfm7qcffhaebi5DG1Kf3rKyKuoHngMLPhPq1gYT13LbUstuk4qmmjvyl7oar0ZfN8bS+nau7wqu70tKOodK+1qr1/8CSgJrCl6e6jZvt1s290/L0n4CL94aHo6aj84GD0eObuK30xc3ciIic2aCx38vUs9GPnd+AyojIyOKt26eNlZX235iGrLPIqcSos5Xsu5qMkYPMwLfdy+m06Iixxtmlus3XqYqbo7ex4pyVr/SG7IP74ZWwmpKys4Ggw9SFjr+O+biYl724wNb009bPjcivlvGIxYBrfpJycX18votrlHeCfpJ+meG3nn3qhIyDs4XZk7OLhpefoo2r2oeq0seovcCbq5SloXzdi4+cuJuThIl9iIqLkYKKmJ+fp5SSf89zjaKtzsvFxMK1rqDEbNG8snXQlrR+kadzdLqel3Zyc6zZzriviN6Im7Xmf+LpgoTf4s/e6YCDgIR+hIh4z8CiwXV4hZ2Xlpmnvr26vcPBbHZ7fIKDfIqBgXhybK6KjqKvrrK4tLihnqSzpLTCwMXNyabKc3Noxs/IdXtuamtvdHBraGlraL/CzMi9y9Jqbnp0w8Nxb3V3d2x2d3NzdHt4dYN9dXR1cG12d3R6dnNuw7uZk5qUnoCcrG3XoZmxwr5ykpKQcNW/l+ClfoWaoKCpt6+YnqWvqZ6XtbzEoKqWp4OUec6DjIh/gYWLoX55fJZ/f4iTlJ6bnrSzgYCDiLLJgpiynIqR09B523TFb8+Pr+Gslq67tqqMhJ+2u76MfXdzanqDh4V7foBgb2idYL+LmZKeo3thdIB2nqKlkmq6v7W9YmJjX7qyuIBxoM2xiI1+iIh2tK1+a3mQp2e4v2q8moS1pHF/mHdqaHOAipGWsWh+a15kr354XbmCdpqPkGhwtqWYl5mpua+3s7O9tMTM0m500rSjp3i0ebDH0rXT3LWr3IXvj42vvau5pomjtJd0rdLL5Xl9eYCB0IKQz33PzHh2dIaGf4CBiIh9gY2FgH+OfIV2b4qKmY592IeVdX2Hi4aVhXt/gW7ZcMXV1Hd2dnKCf3DXdnZ/noyFk6KEcdV8joOAg4Difnm/rLKNiZLYysihppmkxLLY6c9/r5KaoanmjMOu09W+6M16rHR4zcW+vXdufLrLp4DVdHbbhYx/qY13s6ajiZfFcr7De+7NiLiayGqBiYJtz7+7ysHTvaS9z8fRz210c3BvgHTQo7XOkJihlpyNp8zLfYyWkpCPgnx6zbqwpsXIyc56f9jKb3Byv8fT0XxydXB1fYeamaSurq2doZGI23OMlJqRf350fXinl6WpqZiXoYCdor/Cy3d5yaeYp416i8CyttbXocS2n52swHfUb7mWkbeLq3+CcLbSesvXmuCsstfoepiLgImeupvkkJ16nl65XZ2ga7yCbGTGv4uceK+Ox5F6caZuoVRtpHCZuYB6a4WKe4eFjqV0bqyab3OwlYB3XmiOc3ydc364qqqcrM3Ph4B22XF0i4qKw2xtsrx6ioK2qrG5dHZ3oYR3pZ6kjaJxfrlfj2qun6R1o3tvb3a8qXFuhZOHfniVmmGrgWdne2+inZXBrM+30HKHm7d2kpuZfGSFkaypx4eCm9V013DVt4ebh4KgmmZxfohYYYReoX9oYIJ+jKTCp5uaaIt2YaJdg4BRanZdX2JooHthjmZkXnRrhuXXtpH4h5GNyInwmbajm6qwsqPF5n2Yq66XoZ2GkICRjnHVenqBl4iAcnhveHt8hHZ8iJCMkoN+b7Nke4aQqqmlpp6RjoWcV6adnGa3hpxveo5mZ56Ig2ReYJO3rZ+ekfySlqrYeePhe33a3svV3oB9d3lxdXdqv7OhtWdrb4KDhYiLnJ2dm6OkVltfX2VnYm1mZmFeWZaCh5igoKKnoamWkpagmaOtrrO5tJG0ZGVbr7evZWtgW1xfY2BdWlpcWamqsK6jrrdcXmtorKVhX2doZlxmaGZoZ2xqaW9rZWJkXlxka2dsamdltq+Ng4aHioCKkV7EjomTo59dfICAZsWvjOO3eXyLjJGUnZiMjpScl5CIo62xk5qJmXiHcsd4g31zdnd8kXRucYdzcXeAgo6IiqGgdXd2fK3FeYeZin6FxcBtyWq9he+Rt9eVhJOUkol2cYSTmZp0ZmFfV2BnZ21kaWtOWFJ5S6Z1gHyEiGJMY4Bhf4KEcU+Bh5CZT09PTpeRkl5TdJdtX009VmdWhn5cT1ls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v+PFpKq9rK+8sMrK9ezygZuooc/W0tXBsqGOt76otr69uJmdnq2o08TCzcPGgJaA7e3xzt2AveKAgIaJ7+Dez/KE4ouRodvmiJGwpuif44T20Lnt1ov674Lcu8OP1bygpLGP27Cff+72lrKrv/3Ok8Ogooeu5ZySzP6oqpX5hvyWkZill73njaPYlfrS5JWWyMbXj4uh7cS6haelqID++baxucOxo8GHs8z7tsi0sLXW2tO406aAvfDHw/qI1JOqzqyNjsOb2qOjmbv61d7n+OH5zMqvv9LzisrriMSQrsXIidDy4qqCiJWAo56v/ozMts/Bj6WcufbWueD+2J+Vg47mi+XQn4W0gb75tJeek5GOgfmIi83OvJrqmYryh5qKvp2U5p2Sg7u70IySvfuS54zz6rf49dOAhJmWY7VogGV7qXOfZm7b3a29zoWRnaTFuJqQrIeTkJKghn5uvXd9mnzyqp6ld3h7nYHlfdS+0Hx7ubTdeHiEgYl/rMid2JKi0Z3Re3jUepC31ayutc+/gZ+CjZe3u4CE4dqWend/j45z3rilvdGchbKGmaal6YePmpiXmpCijIuAe3p7ct5wdYSTe9BtjJWjmqS1s2hncGvDZXd0dnV3eHqAfnx/eHlybLKRjo+Qg4iRlpiUiXl749rogI2VnZqOkZiOhY6rsLRma21s09DIuLPIz2nLa9Fzzmxyfm9ufnZvfHrRbXVyeHh1bnJ0d3Jqb3HEdnyDfXRt1NVuxLqYvKCAsK+xk5ejr7Rmh5GJfce3ir/MfYKZp6iuqbSrtK+JmImAmJ2Uj52ooaCPpYt+loSFkYKEhJvFb82sn4LZfIGDss6xlJffddW9vM+msMLIuMK0195yjraupq2Bl4GWlKKin4mJfYWIn7ChgXN7fIF4cHeAi4VxXZZwj5V8vH93k2aAhYeIYLGrscOYtV61o5qPcHuHdHiOipeWt4WBeXl5ZmFkur5tcbhmsrmpoq+znJyXmZZzZYV9dXNgcnB7drWkk7BqfpV1iZRerZCzvFaxlJapzLOkoK2wwMp+g3hzy3l4dm9xp3qatLHOr7Syi4iWpKaqqZKwtK6HwJuqmJ6p4Z2A3XxueYSCcMJ1gYaIgHDHutBycH1+12x1dnB71tR4e3Juz8xyhIuRiIaVkIJ8ioJ0cXnWzHJt0rFwwXF/c3J0fXp0eG9sdZOVk6aejMWxmpCmi52hfoNvi9C0sJuWopGGv9zV07mOjIuZss+cxY++wdDntoGGfIGxspSpa8mWq7eA4MqfuX6Lf9bXuHqI1LPCl82zmcOlwnRxdndwbNNwc3VsxGtzcnl6cm3RvXaFgIt0ys9vn76xuKqll4COr7iLioaMkJKCd4Gkg9bDpsWqkZailpylobO12NDUcIKKh6qurKqckoV2lZ2LlZucmH+DhI+LqZ+ipaCncIJx0s/NsMKAp8FqanB2zMO8s81vwnV5h7/HdHiNhsSRxXLUuKjLu4Ht43/WpbKAyL+gm6xwyrOmgOLlhJmGksWSdKKBiHiWvXJ2ocKPlHrab9aHfXmDfaS8XIOtb7mQmV5tmqWQaVltn3WLYnN7fWK3uo1kiXN0fpRohKS2jpp+foytu7CZso6AncqjreZ2qnmOpoxucpF0sYt+gJzEuKaorZ+vm5iDorHKbJzBbZZifIuDZp20knRgb4NqiIKP5ISUg4CVdY+Hgbmjl7i5toeFZICvZrSZbmeaaoLAoHyCfIKGbNlwdaWnnH2+dWysZXdag3RsompkXIp3i1hpi8VxrWazqIixtZuAa3lzSnlTYlhgjVqBS1va78Pf7ZOgqqitl4J7taGsqKi3pJ+J7JOXrHTss6uyamxyiXXYcce5xHJvt7bOa254eH1wmK6MzYKNu5K0a2i3a32TrIuPlaafcYdzhImfoHB1zMiBampzfXllwaWTpbiYiqaMnaWg3n+GkJGNkIiUgX+AdXJzbM5laXJ9ardheHuCgIWPkFNSWVafUl9cX1xfYGJnZGNnY2NfW5qDiIqKgYGIjY6Kg3d87OjygYyRlpSLiZKMg4OglYhUXWBgvbmupKCttF2yXbVks15mbmJebWdia2myXmdkaWloYmZkaGNdXmKpY210cGhkx8RktaKFo4uAlJegi4mRmZhSbXx4cLmrh9DVeXuMmJadkqCZoKCEi311hoyGg5CUkZKGmYN2iHh5fGl1dY6tYbaekXfKb3Fzm7ieh4bPbcW1qLySmauworitx8dolN3TwbBzgXN/fIeCgXJzZ3N3h5GFalxjZGdgWmBocW5eRXhdenpkmWhifVeAcXFqS4uFfYR2kkuQg3tzU2ZbMkdgWlhCeGdmYV5eTkhJjJRSV4xHfIF8b3h6aXBpbWdLOl1WUU1ET1JXVIh/dnpHWG9SXmZEf2uAkzWCf4KSr5uPipaZqLFscWhjsmdmZV9fiGBZWmmAgJ+cdoWcqq+5u5y4vo5bqmaPo6uw3pGAxmxjanJuYa5lb3N0cGOxrL1lY29ww2NpaWRsv75rbWdkvbhldXl+eHeBfXNseG9lY2m/uWVjvZ9lsGVxa2hpcW9qbmdian+DgpKNg9DDsqu+pri8lZeHlszJw6ywtJ6YwNvRzMStqai0xLh2pHC1rqvGsHx9eH+fmYWxgvmapbOA18ahtHN8bbno0oiX58/XmsSursibrmRhZWVfXrRfYmRbo1lgYWdnYF2ypmZxbHJhsLBdj6yemZOJgXR/mZdyc3Fze3twZ2+Fbbmslq2ag4qTipGYlKKmwsDBZXN0dY+RjIuBeW9lfod3gIOFgXBzcnt0jYOMiomPZHJjvLixnKeAk6pZWF9ktKuina5gr2Zpda+zY2Rwba6Hs2O9qJ62q3vn23vWnKJ2xMmbfXJIlHpXPXlROV8/UXI0LDJOW0o9TztBanF8hFWdV41XPjhRWnOBU1k5Sm5whkg8PmBsOkdRX1dKR1tVRiV8ekA3a2tiUFlMal1pe4xwbnqio46DnHmAhKuGdZJUiGl+kntcW4BQYEM+QmuaS2WIh3d8Wlw0Fy9YRX+oXHpUcj9IUTw1Z11MOjlOWlNqaUNfQ1lgTWtUU3tcW3JTTF1AQC5wS4NuQCxTKkltVGFua2InNpY9UYyWjmWpYF+EVWRGa2Zji1RJSHFWckZVdrxwpVmWjnSXlIEOfX19fn19fX5+fX18fX2JfAR9fn5+iX0FfH19fX6EfYV+Cn1+fX19fn59fX2Jfgl9fn59fX1+fn2SfoJ9h36NfY5+AX2FfgF9iH6EfwF+kH+OfoN9jn6Ef4d+Bn9+f35/fop/AX6OfwF+hn8Dfn5/jX6FfwV+fn59faR+AX+EfgF9iH4CfX6EfYV+hH0Gfn18fHx9nX4BfYR+BH1+fn2FfoR9A35+f4Z+iH2IfgZ9fX5+fX6MfQF+iX2EfIZ9AX6EfQF+jH2EfgF9hX4DfX18h3uLfAF7hnyCfYZ+AX2GfoN9hH4BfYV+gn2EfoJ9j34IfX1+fn19fn2Sfp99h3wBfYd+A319fId9CH5+fn18fH19h3wDfX5+hn8BfoR/AX6Hf4J+hX8Dfn5/i36Lf5F+oX+HfoR/hX4Hf35/f39+foR/BH5+fn+Gfg19fX59fn5+fXx8fHt8hnuNfIJ9hHwDfXx9hXwIfX18fn18fXyEfQt8fH19fn18fXx9fYh8BH19fHuGfIN9i3wBfYV8hH2KfAV9fHx8fYR8Bnt7fHx9fYV8gn2HfAt7fHt8fXx8e3t7fId7C3x8fH57e3x8e3x8hnsKfH17fXx7e3t8e4V8AX2EfA99fX18fXx9fXx7fHx9fHyEfQICBACAvcSUyL3muMfNzaiDq62hrrvYxsyyoPnp+/6ggX2OhaCAY2Vqc3F1i7KPjJrr5o3Bv72T1cyOqbD4hP+/poGFiMh8nfCIk4yHmsebqdHDsPntvbOZhp7KiZylwLK6ycK+1eOzjamBqbq5ubLYlcfis5aZ0f/pjL7B0+iotKWvp6OAlY2Mj4uNjpCfmJGNkrDO49X7gY2OlJGJiJeVm5mUmpiZj4mHgYaEhIb238izsrOnmo+Oi5+nnZ6SjvDSuMTK6of3g4qSlJDb1uySu8/d09XxiIiF/fmCgoqQkZmRlKGblpiLhYyEh5iIgYCKj4+WjJSC7YWPh/uLl5ilppX9hO+A7PTd2dvh1faiyKCigvqyfPiUxdzR2si9++Hahof1jrXcyt2GstzZ0cSqpp6zxvjR7tD/gKaFoJ333KrywNLav4iFkKKRvpnzgLLE5YT3q8zj5YNxrdWh1J+/hpKopbm/mZicicGjmJ+1yb61n6SqjpKYnautiOKAjZ7+zJqWub2A3tHy79+CnbfqgeLF9pP94Iumv7q/jqGxwNu0w7m+0faX4tuAhNXQw9GEhfLWysHChsvu0NPbiPepmJex89GyyYm0o7XAsZz7kP/v7tHfu7S+x9PR8NjMwsHehYaLi4yGk56fm6CQ562qvsKtgoHtvM79656yq6SmpqCxssmq+IiAm5HlrbT7i5ONk4iNmpKO7vOUo6aTjY2Z/+/7mZGdo6KygoGaqKOhrbiupLahmKCpiZCGgYPVgeLO0oePg/WyjpSk0vCCorKtoprul4WMcXCBg4SDfHiDoH+MzuCDpHh5xo+XyZKCdmJxiuG7v7flhYjeh8HTu+yQn47yhGOOs5eAqOXn6YL+2oKsjJtuoaV5wKTtg3rsm7zUx+S0muWEjJaL/ery3ffl2+Te4fnPwuHjkZmdjoKViYHnrdOvuJGviuSBjP6A7o3V4N7GvKm0tZr9kKGbuf+Nj62k2/TxgfDSs5mOg52wwb+npK+pnoyltMeqnsDPvbKm+IjG0uGKi4SAv8r/mP6KjJnomaiOoaKZh4yPqJ6fjLXGpMWZgsC4jeDAmcrAm+iomuadwvPIwtDWzOSozeX0y4Pgs72btI3N14b70J/xs/fjyP7DypCLg9iLkvHGm4CMwIKQ9p2qqdP/9ruyz5avk47NgLbDg4SwhtzYqOHq8L7Sxd/03/+xr+yAupKm+YSDlNaD0NrI0a6cmImY8YqO0Mjc3vCJ5ry1ob++humSgaeO05GzmeWmzK6LjIPn9YP6toXz55ifsYjXopzWzcyhlMOK5N/FtZTyz5Ta9Kb4jdC04oS4opK7gKTnjLWN0/q+lb+RuaT4p4LJgJ3556aYj+jp6rL5k52gs4OAhY1pgYOlfImJinZroKueqr7byM+zotbC0OmmjY2jl7OSdnZ3gn2AhqGCfYri3H6noaGAyL19kprfdea2onh7gL54neF+h4B7i7iOncG3qeTXsqyaiKbFf4ySqJ6hr6ejtb+XeZNwj5yanZW5g6/HoY2QvuHRfKmsv9CWoZWelZGAg3t6fXh4enuIf3l1epGktqrKZm9vdHFpaHV0eHd0enh6dG9tamxsa2rJu62ZmpqShn6BfouTipCGguTOusTL3X7sfHyCg4LV09yGorG5sbbNdHFu0c1ra3N3eX50eYB8dXhwanJrcHluaWduc3J4c3hqxHFzb9N3e3+IiHrObsqAx86+uLvDssuJn4KJcOGrevCFrruutqul0sC+fXzhfZG1qtd3k7CwqqWRkYyXpcmuwrbjcYxsgH/QupfSoK6zpXZ3e4p8o4PIZZOnt2rRksDV13Z2vd6fxpmvcnuKh5mcgH+EebKKgYWUoZqSfX+FbXB3eomNbK5ibn3FkmdrgH+Aq6nDuKxhdousXambsXPIw3Z2jJGeV26CnKiGkoeMo75srq9gZaaalJlkZbyimo6cap61lJOdYq17cWxzq5GAj2R+doKQfG+9csq8t56umJahp7Cwzbeppai+cXB0dnVwfIOCgIN3w46RpKSWdHjftcv55pCgmZKOk4mfn6+X33WAg3rEl6Lcd312enF2g355zNF/iIt8d3yB3tHZg3+Ei4yYcHKEjomHkZmRipiIgIaRcntxbG6zb7exs3N2bM6afYWWtsxuh5KNioHOkYWPeXuHiouIgYCFmYCQyuWNqH+ByICIy5uLf2x6keeZrpfhhHzKe7LRut+BjX3qkG6RrJiApNrY1nfz2IWxkaB2rKt7v6Ppg3vpkKe3psKehr1tdXxy0sbKutC/ur67vdSspsDDeX6CeW99c2/Rl7OWm3eTd8NtdNVv03W4x8SvpJahoorrhJKRqN95fZOKtcPBZrymj352boaRnJuIh4yKg3aJj6CJgZ2mmJGD0XKwu8h6eHGAqrHXfdh2dozOf456g4V/c3R3i4CCdKTCprGNfLy2gte+mcTEmdmZj96gudyzrbu6wuCiqLbTqmimlqV2mnuRpmDMoYjRp97Xw+LD0JKJfL55aqWKcWlkhFtnlmRvbqSxupF2g3+HbF9xVoaVWluCYZymhpmluJOmpbS4vdWRicyAqH2K03p9jcBtrLijqoJ5bV9pvm5tnoyJprBWnY+ZiZyHY512aoFtl1xxWo9ih4pyZXDD0WnTq3m2v3B7l3SwfH+qrrGIgaFisLqNjnanonyuuX+3aI11vWurmHaJXne7bY5mkqmLbo1zjX24elyMV2+imWRraqaknoq+Y3B3elyAbWdUYGOJXmNjalphncKzwdr85d6rl7Sbp9W5qKi/s8uxlZSUnZeagY95dH/g0nKRiodxwrVtgIfNbNWvqHB0d72Cqdl4fnRxeqSJlbSvptLDq6mhlrfJeH2BlY2Rm5OMmpx/b4RieYKAhHyge5quloqLtNPHdZ2htL+OloyTi4eAe3FtcGxrbW53bGVlaXmEkIqhT1lYXVxTUV9eYF9eYWBlYV1eXFtbWlisq6OPjY+Jf3p8eIGJhIuEfurY09rg3330e3l8fX/q6+2LmqWmoqe3ZWVhubFcW2Jpam5jaGxqYmdgXWJeYmphXVleY2JoZWlfp2RmZcFpcHN5eXG+YryAs7ivq62uoK5vh3Z6ac+lgPuDoayco5yZvaywfHrhd4Gck85vgpOTkpCEg4CHjqyZpJzRaYBfbm67qIXDjJSck2ptcXxzlHezWYWWnly3g7bHyWmH4fWjuZepZ215dYJ/a2tyaah5cXR+gnxxXGRlVlZeXm90Wo9QXGigbklNYmaAlZail4ROXm2KS4h+e1akZ1FVT0lmMjBSU21ncWpscI5Ti4xISHpybG9JSYRvbWVxUXJ1Zmd1RnxZVVBPd2hhZktZVl1oWlCQWp2Uj3eDgIOOkpeYrp6UkpWnYWFkZmNgam5ubXBlpnByh4p8Y23Mrcz04IKQi39qc1x2i5uKyGmAc2uvjpfAaG5nbWZrdXJtur5yeHxuam1xyb/DdHJ1fH2HZ2Z2fnp4gIWAeoR5cnWAZm1nYWOnYqido2ZpY8KSeoCRq7pleX9+fHjHoJWjlJWco6KblZiVmo2Zw9+fj4aRyHeB1bOkloSUpOV8kGLYiF+Nc7nay+N9gXXmp4adr6CAr9rOz3bw3IK2pryLyMSOz6rvh4P4jZ6nl6qOd6BbZWtitq+wpbSnoKSlpbmbmK+wbG5yamFrYV6zgZqDh2WFaa1dY71lxGaot7SiloqTlYDfeoeJnshqboB5lJ6bUZaGdmxoYHN8g4FycXZ2cGd1eYZwbYaLf31utmShrbpvaWOAl5y5Z7poZoK0aXhobXNuZmNlcWprZZjItqGGer+9fdPAo7vhrNeQhtOwuMadkoGFl650epOXhlFKOzpCT0pKQiFiV0yUcZ+OaX2Ngk1CP25SXIltTUZRcT0/f0dUSD9EV0BeZz9MIDQ6NVZkR0dkU3l+b2OQoYWJVpScqrV6e6+Ajmp6pk43a6JbmJ+LhGxkUkU7dkJWZUg1Y4lNblhGJk5ZR4dhVXJde0E8QWNAZ1MrQkWemD98aEBuh05RY1J5WWJXTjpDLD8wUFReQTxjTCVPPUNXNGNWrF1hQWFoSGOcYolVb39pXmVfc22lZ0V4RlmDf0xSVYWCf3iWS1xkXkyFfQF8hX2LfAN9fn6OfYV+gn2Ffg19fX5+fn1+fX19fn5+hH2Ffo59lH6KfZ1+l3+RfoZ9An59hX6DfYd+BX9/f35+nH8Ffn9/f36GfwJ+f4l+hX8Efn5+fYx+AX2EfgF9j34KfX5+f39/fn5+fYt+AX2Efgp/fn59fX1+fXx8hH2KfgF9kX4IfX5+fn19fn6HfYR+B39+fn1+fXyKfYR+B319fn19fn6EfYJ+i30BfpF9AX6RfYx+iH2FfIx9g36EfYl+gn2HfoN9mn4IfX59fX1+fn6HfYZ+kX0IfH18fX19fn6HfYV8A319fIV9g36KfQh+fX19fHx8fYR8BX19fn59iH6Ef49+iH+Ffgp/f39+f39+f35/iX4BfYV+h38BgJp/EX5/fn5+f39/fn5+f35/f35+jX8Jfn19fn5+fX1+hH0FfH19fn6FfQF8hHuFfAF9iHwBfY98An1+hH0Bfod9hHwBfYZ8A318fIR9kXwHfXx8fX18e4Z8B319fXx7fH2EfAV9fnx9fYp8Bn18fHx9fYR8CHt7fHt7fHt7hHwVe3t9fHt7e3x8fXt8fXx8fHt8e3x9hHwLent7fHx8fXx7fHuJfAt7fH18fX18fH19fYV8hX0CAgQAgNiB3vju9K/34fer+H6no86aoNSW/OrImrN+hJair5dvYaqtYWVkdevS/46C74GI0babh+qyw+D1mIzuhIGGkZXp2omIo/XXupJzbrNpdY+osbKmtsG75LSRmpXJwsLpz+z064fGkpC0sKmjgsrGqrPi3sKStNrd/OvJt8aqur/mgNWvrbW1tqurqaWah4+oqrnM5eyLkZSSgYGLk5SajYyLkIiHhYXz9f/z3N3YycO4xs/Q2OPdxrbAqpT/jIbmh+m6sb/O3ci8r7vCwL7Jx97im8vv+IGEh4mQlpeVkYGNkJaQl6WUiJSUm5SOiIuNlpiRhfn/k4qNpJ2jp5mQkZOZgJWQh+/F0+GHqZ2ZiJbh+4OZoMrz+fijq76PkZCos8LPv6iftbXI3enhztvG442T+N380KmPqrDMw8iVg8f11qyFqsWimbmq09CkxNbM05uGgoi7rpfTncjkgoaaoarAyI61g4milYP5o9PGucjVpIjw7fOamJH+jY6goYiPk8q1gJSuica24uKpu42C/pGK6NG19uHxoZablInj09jwkp73mtKKn6qJj4vD5ILlws/I6M3k8fuDhezKge7BmcbQ6eHF8bb14+zxjO7m2sykrdvZxc7U5tDg//3k4tDP1YqCgY+jkZiSkoD//PKDi4KBgvD4g4mPhoX6gYOH7uHW0vP9gIuTgOmKlZGJjO/Wss6F8/fg8YaNl6ikqZyGhv2Ch46foJmdpZqWj4y8qLK3wMOqqJWfnoqB5PjFrtjl9PH8xvaSg+7YuteQ7cWOz9CKgGJmgofUsZu0+rveoYdtuopz2b/OqIN3cm1vhZSFp4eDxd3Y3HdyYXOCip6umIBobHxlgMBvempvcXd5r6Wks4e8iqTE4brrhJ/Hy+iGjIeXmIXugfvg6dPk5cvK4eW/stDZhYymsJ2hmZeVqK2G+YCd++SFiN3L4IOS+evRrM3dusfIypG5yYCmnZ6c6P/v5c6ZjJCC/Y6arpWWl46Up6yilaKgkqecoZXy/+HMuMGoocvOgMyBjvT28IaVi/v41vCKkZXAoIKB/r2SrqP2uWuFpezimprMdpiG/P+/n/PXmoKCrJym5q2g47Ca7PLblfHqvY6Ol5KXoauJnuu82u+D+8iNj5Wy8oqN34jl9bex9IG2n6StiMOdjZ/wsKmhtr2yuMypo6LcrZyKh5zMmr7PiZSegJGFuYbOvpXNgYy5ksSMgNL62deLppORqJKW4MiMi6vY/5ee54WVlvjR5OXv1Oe//JGPxpCOk/j+h97PsOqtpJeprt3Kjr7dx/HKscDw3vu6+/nHp5S8oIKNg7XNwv3G86nWjNyTwp6bn6jC1dWZ0cSl2+qt0/6Otq2hqayY/qe9gI5Upra3v3m/qMCj7H6lpdaaosyD7NKpi7qKjqSvuqN+bb/CbnNwhenR8oN94Xp9wpyJfNeoutjlhX7TeHR6hIbcz399lOLQtZV5d8Vvf5qrr6+ltcG52auChoKvqKbIsMjKxnKrfXyYkpCJcrSvl6XJxbKAmL3B3s+wobCYpqvHgLeZlpqYmJCPjYmAcXaJi5ekt71scnJxZGRscXJ5bm5wdG5ua2vHx87GuLazqaSXpa+ts7u6p5yll4bvgnzdft65s77J18a5sr3DwcHJxtzdja/IzGtrbm52e3h1dGx1dHdyeYR3bnd4fXZzbm9ye3t3bM7WeXJ2h4GJiH14eXp+gHt3csyosbhuin+BdX/N8XyNi67NzdWTmKWDg4OVmqexppSKnZqjsbewpbOlunJ0ybnPs5N5jZCtqaeCbqTHsYpvi6KHgp2RrKOAm6mkr4d5dIHLw6PVmbzNb3CAhomep3yZc3iGfW/diqmdmaOviHPEw8h8eXXLcnB9fmdpbpJ+gHCLb56DrraFkXNq0nl3x7Cbuqi5fWJnbmSmnquveH6vcKdpeoFpbWuFnF+nkJuUrpWjuMdeZbObXauObIyZp6WauI2wraqtabu7sqp8haOnn6WtwbW/2NvIwrGytXVta3eHeHx3d2rSysZscmpqa8bQbXN2cHDQbW9zz8O8vtLagHZ8bct2fXtzd9C/orlw0dfD0XJ4gY+HioNzc9xvdXiHhoOFjYF/eXuej5WYoaKNin6EhG9rvb6mkLfEycnSqNJ7cMOjla54xqyI0tqNhWpthYfbuaO65bvon4hzvn186L3Eq4yBeXR6jJ6Fi2xmld7f44B/anmHkaGvnI12fIdtgMt3gXB6foKDubOyvo7AhpmxxqvqhZWvr8Buc258fG7Ja9K8w7HDwa2uvsamnbm8b3SIlIGDe3t5iI1vzmqG2MRxcr+2xXF51sq4mbbBqKy1uomqtXOLhIeEu8i8tKV7cndt2nmAkX19fnN5h4eBd3+CeIR9gXrJ1MK0p7Khmr20gL1xe9bW03V7d9zWush1eHyYgW5t1KeHr6bsu3GJn97YmJrFe5SA7u+skOnCiXd5ooqK1ZuTvZJ6wqaWe5eYjVtjcYF/k6OGmeS20M5wuplmZXJ0vmJirWC1oG1ypGOYZm6BUnppVWajcoBsiZKIlaCFgXiad2plaYivZoyec3mOgH10p3exmn6ucGiYfZdpXIaQlK1ciXhyamZmmoFecYKv1oB4qWx7d7yGpX6xrayiymt7pXx8ds7Va72wq+OZi4aKhqqhd5KimcmikprcqeagqsSjjW+Sa2pzY5Oqi7WbyomubahxnW9xeH6UlZJal4x6lJ9pj7lki4R7gXVlqXB3gGU4hI+LmFSXi6ik+47AyP6vqpNe07CFf86np73Fz7eahu3phYuLn+fV6Ht13XNzuIp8ccurvtTadXTIcGpudnrYzHlzh9bNsaOKjPGClLG8vLu0wsnC2a52d3aYkZOrl6ekqGWcb22Cfnx0Y6Gci5mwqqZ1gqKvy7+hk6KNmp2xgKOLiYmDgX18eXRwYmdycn2ElJpWW1taUFBZW1xjWlxfYl5eXVyxrLOtpKCel5eKlKCanKKjmI+akYDpfnrbeuTKxczY3tfOx8/V1Nfa2evqiKG1tV5eYF5mamdiYltjY2ViaHFpYWhoamZjXmBja21qYbjAa2dqdnV7enNsbm9zgHFva8agn55cdXZ0a3TD/ICHhaO8usCNkJV+fX+Pk5unnoiDkImMkY2FhZWQpWNgqqS2n4NuenuclphzX5Crn3hme4x4eo6Bmo9xiJKQlXtxa4Tz7sfsnbK6ZGVvc3WDiW+FZ2txbWLLd4d8gIiOb12goKFhYV+mXFliZlNUU3NggFZlXoBjjpFteF1YmlRbkXBykoOGVjU1NyRrbmx3NViJVHVRW2BOUFBeaUJ7a3Jsgmt1iplESIxzQnptUWVueHp9kHB+f3d4UJWVlY5hZ3qEhYmQoJ2kubyurJ6domVdXGdzZmplZFy0qapbX1lYWKSwXWJiXl2sXWBkua+trr/DgGpuY7ppbmxnasGulalmv8SzvmlsdYB4e3Npacpna2x3eHR2fnRzbW+KgIOFj5B9fHB2d2ZisLeZeaaztK+8nLxuZbuOdqJquaSK7f2amYKCkpL72sbV7s/3opWCqVaA7LfIu6WckI+HnrWMck8/buDY9JmahJGfqbe+r6aUm6CCgPaSk4KWlp2V0NHQ2aPOhpKlsaH1jpOmnalfYVxmZl6tXLSnqZyrqZqeqK6VjqetYWZ0fG1taGdmcXJcsVt3xKxhYailsWRov7emjaSvmJ2jpn+cqWh7c3t2mKGXkYhnYGdhxW1xfG1tbWNnb2tmYGZuZ25ma2ertauemKWXl7OqgK9hZsK/vmpqZsfCnKdgZGd6al5dt5iBuLTsxISWp93Sn6LDj5t66umeh964eW9zeF9QsIJ+qHRflF0vQT5GSzIpNlo4UVhPXoFNq5pOh4JQSFVXXitAXkBehVhfXxsyOU5GUGsyPE1VUV5DYnBxfINlW1txZlBOV0yHWHh6UmSBgGlhkWKMa16SV1B/aYZgVX+PdXdLYz0oEBgggnNBUV6Uq2VhgVVVVX14OUZ5UIhXkEhVhmNaSHyCSH6BSmdRVEhDOl9kMCRLRz03REc3UzojYYBfMDlZUV1pVYqOboBqtoaiXZlek2BkZm2BenZBd29oeYJOapdRanZsbWFOhVNVAn1+hHwBfYR8AXuHfAV9fH1+fol9gnyHfQl+fn1+fn1+fn6FfQN+fn2FfgV9fX5+foZ9AXyMfYt+AX+Ifod9oH6Sf5V+BX1+fn1+kX2Efp5/gn6Pf4R+hn8Cfn2efoJ/mH6CfYh+AX2EfIN9jn4BfYh+B319fX5+fn2Hfol9hH4FfH19fHyQfQJ+fYZ+A319fol9BX5+fX1+jn0BfpV9in6DfYV+gn2FfgR9fn5+hn0Efn5+fYV+hH0BfoR9iX4BfZl+i32CfoR9Bn59fX18fIZ9h3wHfX19fHx9fIt9h3yOfQF8h32EfIJ9hX4BfYV+hn8Cfn+Ofox/DH5/f35+f39+fn5/f41+jn8BfpN/i34If39+fn5/f3+Efod/g36OfRN+fX1+fn19fn59fHx8e318fHx9h3yCfYd8B3t8fHx9fHyEfRV8fX18fXx9fX18fXx9fXx+fXx9fXuMfIR9A3x8fYd8AXuGfAR9fHx8hH0DfHx9hnyEfQN8e3uHfAF9hXwLe3t8fHt8fHx7e3yHewt8fXt7fHx9fHt8fIR7F3x8e3t8fHx7e3t8e3t8fHx7e3t8e3x7h3wBfYV8BX19fH19hHwEfXx9fQICBACA5Lf3lougmZWdivLN3KSiorK6op+jkbd+cayEh5GDk9i/rL29sHO1+aKys4icirLx+9rxw+3xg6up4I/ek4iO1/KjvMfVvM2vp8fh4P3czeXo2tfpkYqcqZ6mtrTM7Pnx3fTS1MKu8d3g4Kyo7dDjvrjog+LXvMXY1e7Jwbbk9eKAy5qanbO0xMHAx8i6tp2lyePr9IOSm5uU/4KEkJCJgoeNgPSDhIGBgYSD7dDGt8O+4Ovn2u/99OrHo5GXiZaF7YSI9oaGyeyFgfTvhIj8gbGZrbDO8ZawwvuUiYzdjouRjZKUmpmRjJeaj5aYmpWXj42Kjo+Vo6igoKOhpKSWmo2A/eft6ODZjpGrm6iysYXGhYehs+Dgwq+3xb3K17mrzsjP4+DpxrC20uHP+v/exfK43Pv9ktbaurSMz5LoqYqgk52pxpmmpfK5w9aFnKKWjoqvdmavfHqF2qWbnJKCmrqxneqqm/aY9YGrtLmqpaOqyrCCgouG6vSDmaDUuvD/iuOA5//+36izp8ibgMPGl//Fv+GUrMuPzs6uhP+svMGNrMXa2YuO+PD7iZrm0MjUytmI3fb86PCIip6J/YWIvrPdpMzqt+r7g5mKlp+al5KHg5SKlaH7gPD8hOz5hYSCipKOmZqM8u3+5PT44/799u3rhYmNhOeKh4n7iIqK+OnWsZmApM6cspjU48+21eje08O4x73O1oqi2dT19viA+4eBiqLCo5SxtbGqtbbSzKy5rpGjlIqo/YXQ9/jjgui6ssPTudHWxY2wzML8zM7krLqtuJ61qIHC1+qNipuQeXKmk8qVzcm6+Z2ezcybq4dxaMDJybWgkWvHkLG3wKe9p19chLyAupN6faeKa3J+ost2ksbW2dfWqpmWjIuOmJ634P/56/rUzcvBvNfRy8TLybjUjpKCkKmWlpSYl6iyraCZmf/p2oPqj6OBqNiDg/2JmJeV3eKe1N77iez6pYSO79i7l4uXk//ugJuVh4eUjpGV8Oz2/omChIDyz8yVkKSe4KObmJaAunfw2rapobylpqmhs6OCiOWl5IGv9v2Yt2fAso3uc29wadGb54TE4aWuyIynxYeWsLKH+q27kKWA64277Nb/m4uVm4ycvpaAwZ2JnIvj5IDhqIKCicXpsaa0qOzKyIm+s4+51rKoz4Ga+Ive/qSyxbqz0cyyw77RoZy9ipPkhrqAmIm6m8yrtIWHnejRpayeq+7SvJu9lqTjwfyUtfTLuYal7+eXtJrtifGJoe3Klvyg+b3FjYu8wczC3IqA8pyUnLLHgI6v1bykq5/Kvquk68zd4oCFsdvZwtCGtYymvM6KmNjLoOHx6+jzyffyvOfBhteq04jDyrSgmLTvkpjg0d+AnoTGgX6cjo6Wg9u+4aaip7S3mYeShraIe7KAhYuAjNrEtsXEs3qz8KeztYWRg6/e59LmwODmeqep1YPWkomQ1uqmv8PMu8+uqMrZ1fDQxNXYzMvWgnqLlYuSnpyxyNTMus6xsqaUyLm4u4+OzrbKrazPdMe/o6u+vNK0rKDI1cWAsoSGh5WVo6CdoqKYlYGHobO8wGdyd3Zxv2JjcHFrZ2xyaMdqamhpaW1pwaumnaSet729ssLOzMSslIKHeoV55nl74nh9w9p3dObfeH34e7qltbXP4oecpc53bG+vcXJ1cHV2e3x1b3d7c3x8e3l6dnVxdHR6hIqEhIaFh4d+f3WA1MTKx8a5eHWNgomRj3W3fnmMmrvCrZygraiyv6OYsrC0wLu/opeZp7GqxsmyoseYr9LPeLazlpJ7s3bEiHR8bH+Pn3yMhciTk7Jsfol6enmgeW27gH6EvYeCgnxtg5qRh9GMgtWAz26QlpmKhoiLoI9rbHBuwMRpen2ljq7BaamAvNaLc3KTkZF0Xp6phMaqp613iYlvoJxxXrmAiINqf5KioWhqubbCZnaklouclpxknbO+tq1dXmtds1tllI2rf6W4iLrPbX5ye4J/fXltaHNrb3bRbM3YccjVcXJvd3p4fn5zy8XPtsHIs9HNxsHDa21warpubnPXdXd21Mi6nY+AlLaQpoe4yrekvczBvK2nsqe4wIKawLnT1NZv3XZweouhin2WmZWPmpqvqZCbkXqHfHaJz2+szNC+Z7WIlKm1oa6up3mYrqXlvs3OscK1w5Wonn7H3u+GgI6MgHmphL+Uzsq875KW1c+Vp4x6cc/b28Wvn3TVk7OyvKq+rmpoiLiAvJmAg6uOdICMsdl8j7jDwb+9mpKViYaFjpOkwtTNx9Oysq2jore0sKexr5+0dXtveYp6e3h9fIeNiIB9gNjMvW3HeYpxmMNvbtt1gH+AwcmTvsTaecnViGhuu6qXenN/e9fJbIJ4cG95dHd7w8jR0nBqbGrKs7OGhpWU3Kmin52Avnnw2amclqWXkpOEkYJvdcWQxGya7+6awHHQu4vgdnR1bMWT23q40I+fxYGWrXqHm5p015SlepFwvWWPspq9aGeBd3ePuYqCzYSKlnKtrGepgWd4doC1jpZ+drWirX6JkmR1lnd3jkpsqmS/yYOJqJ2NsJSCjqCsmY+FZ3PDcqaAhneyh7CQnmpse8K4gYJscpGOhViae3nEirxwiZ+aiWmJyrpwiny+db9idLamccJ2w6GmgX2zvKqzwnFr0IF3hJuianKEoYmEjYCOYXBhwra+tWlueqaRmKthiXOAiqdcXKKvfrK7vra4kKaee5Z+W5R0iliAhXJrdIqnY2qVjpqAcmusb32vkZ2ih9fJ77Sss72shGx8d7+glr99goN8g+DMydjQwJC567a/xIGJe7DO2snfxtzjdbCz1nnSnZug3PG4y8bJv86zs9LXzObFxtPTzsnKeHF8g36BhomcrbOsnayXmZB/p56ZnXl3saSzoaG0YLesi5uusMWloJe2wrSAo318e4GAjIiEhoR9empwg4+XmlNaXV1Xkk1OWVxaWFxhW7BcW1paWl5bqpmWj5SQpaSpn6i1tbGdi32Adn926HV34XV5ythzceXddXz5etXF0s/h7YiVmbhmXV+RXmBhX2NmaWtlX2RoZGprampraWhkZ2drdXp2dXh4e3lyc22Ax7e+u7eraGh9c32BgGywfXODjamvo5aYn6Crs5+Sq6arraWljoeGiY2NnZqOkKuFlrK4aKKYenhromKjaWRnWG59h253dLN8fJxea3Voa22mhYLeiYmMsXNvb2phcYB6dL52c8JtsmB3eXtvcnN2gHZXVlhXm51WYF9/b4aZVYSAdVZFQVFtYnRgSIJaTnJuWV5IVmZFdHJFKFlEXVQ8XXN+ek1PiIaPR1p7cWVybnJJdoOLi3k+PkU/gT5IdnOIYoOTbZ2wXmtlaW5qaGZaVVtVVFexXrO8YbC7ZGNhZ2lobGtjr6mwkJObkaypnJaYVFZZV5JWVl68ZWlpv7Wrk4mAjqqIn3yqt6yZrr6yr6Khp52otH+St63DwsNlyWpma3qNenGDhoR/iIibloGJgnB5cmt9tWCft7alWax9dpimlp+amFl/pJnhvM/F09zW55qpoo3q/v10d46Uk4yYcJl+y9XK+5OT29mYp5eJgfD+/+bNuoj8ormzvLXHuISDmryAwKmVlLOaipuozvOIkrO2tLKulpKaj4eGjpGbsbWyr7KampeUkaKfnZefm4qgZmlgaHVoaWdranF0a2hqbr+1q2CwbXllkbViYsRpcW9ytL6Lr7XGa7O6dlVXlox+aWVuaLyyXnBlX2FoYmdopqq2s11YW1yvoKB+foaJ3bq9tbKA0oDxz5uTh5eMfXxkcmxgZa2Eql2M5uKm64v+5JfXiIWEhcKT1nSzwoGNxHyMmXN8iYZmtYKOXnJYjD9bcWOKSEdbSjZESTNWa0Z9iGOUl1WLXjwiIl5sRjJXT0U1JSRSQjJjUD5VXzlReC5eemFueoV8gYRtbFpjOEdsUFuUYI+AdWmFYH9melNLTKWUZG9ZaIp9W0BkRj8oQTNRWVhqaFhwr6BWaVKfRFxMYotBTnxClIyUbWJQXWB2g1ZMa1tMI1NGIClNVU02R0RLOTw7jVFli19APD9ogYBOSlRRY3pTXJy3h6avu7mtdIB2X3dpQ25icUNhWk5LW3uGRk9panCCfYh8g3uFfAR9fn5+hH2Ffox9g36IfQV+fX19fpl9mH6GfQN+fX2efoV/AX6JfwF+h3+VfhB9fn59fn59fX5+fX1+fn1+hn2EfgR/f39+o3+Gfoh/pX4Bf4V+A31+fYp+hH2GfgR9fX18hH2JfgZ9fn59fn2OfgV9fX5+foR9BH59fHyGfQV+fn18fYR8iH0BfIh9B35+fX19fn6GfQF+hX2EfgN9fn6JfY5+B31+fX1+fX2Jfox9hH4IfX5+fn1+fn6IfQF8ln0Cfn2XfgJ9foR9AX6NfYh8hH2DfIZ9g3yFfQR+fn19hX6HfQF8ln2ifpB/DX5+fn9+f39/fn5/f36Ef4Z+Bn9+fn+AgId/gn6Jf4R+hH+HfoZ9A359fYd+hX8Mfn5+f359fX18fXx8iX0Gfn19fn59iH6GfQJ8fYR8gn2EfBZ7fHx7fHx8fXx8fXx9fXx8fXx8fH19h3wBfYR8B318e3x8fH2FfIN9hHyDfYV8AXuEfAd9fX18e318hn0IfHx8e3x7fX2FfIJ7hXwNe318e3x8e3x7e3t8fIV7EHx8e3x8fH18fHx9fH18e3yEexB6e3t6e3x8fHt7e3x8fH18i3uGfAR9fHx8hn2CfIV9AgIEAICrnfGByom6v825tcrviIOBqK6yt/bY19n39tS0uruciZiGj5nj0Kevi7ChhLSNkY62lpKLoor99ZXe6drz8/WAgfDw4o786PCB9ujwgYeF6oSQnp2niKOglryktLGjrMm0w8q8w7rH36nEtaeUrIHhvYKN2aibtZ/d2KrD8cvF1oDl5MC9vMOpx8i1tLO5qY6DwPOHh4SKk5eTkJWLg4OG/OfVxcvP1drIy8nH593T1s+flJixwsC2spmPkaKXh5SKgIWJiZmvxLm5v7egjv7Am6m6tbG6pbSql7+CpcXv8+fugo6Jj4eQlp2in52RlJyJkIuXj5SfmpqepamampGPhICIhYSCz96YvdrRs8avhtm5rMua1Mm6vOPSx9S6ucTX2dPh8+7S0N3k6Pv6ho3n0+j8iMv/gP21mfGFjI6O/IiA1vHXgob91piP4Z+yuoCImHZwv+OLttaTobSskYntmIvq1ZSS7ZiZkZCNmaKjmJWwwKrl1tSpuuqKi4WB5f6G5ICkyuXC+5fvhbri35bq6M7J+J3PpJ2Bg96hmpS1m6We7ZOH5Oz27OToga2E3fiLko6Uko6LiJiqnpWciYKBgfXuhJ6FgIyMi4/qv9rkk4T6g42TnJCXlpyRj46knKanq6yejbmHyrTC4sfx7trQ2uXu74L+/YuimpiT+4Lr+O3LroDi182Mtv+GjYGL9eeA78W79d3p49bp3ubk+fKEk42Shvb4+vOKoru5ptDBt6O3qpeYmZqNweaDlceJsZ+i0MaksKWd9ZKclor9zqi28beCgN62wu+owrCe9tXV2XqvzJqD7vB5eXxvZmdit5ukpbVjamdrbGxoy4uPwI5yvau+joCVmYyFqL+qn7POdY3A5taWidXE2uqJlI6Llq/Y5uDt3te8nZ+7tNq/t7bH9IXn6vHw5tvk8uyBhIaQhpaPh9CpyoWQ9v2Bn9LJ7czt3MmSrvyChJ6eneCQjvHXpISMnpSBjISHld6DgpGC1+zfiPyD9N7Xs7e3iebOhINtgYd1a4B5enysqPbB8v6Qpqmlivv30Nru3qaAv/OJhYzEv92uhp39jIT6lfuAjJiE2t+syIShm72y3KeymPTSoejUmtDXiobC7aLezKiUh3+AydX+k5KMyLyCoI3As4yDkLe5qJmhuonrm4CIm7PhzfuLz6jzn/uRp9DTwof3+Zak4aTNwoC9r9mlpM/kkoSkmIiO6vLAsqGp1IHywJGpmc+UmKfJlO6PhKKesaWV34HM1JC2rNuv/Mfj6bzUzuTPj9zrnL+mwLvXxp+KvZHTwN6Tw4S86ZCtjIamncTI5K3z3eeLvIH3maK2zOuq1+mOqu6Ft42LiceyouaWqISHjv+0+Y6VxYB9ca90xom/wtC8ssTtjYmFqJaYoNnLx8fc3860vL+WgY2BiI3cx6KegpiReZ9/g3+dhoJ+kIDv44rT3Mzu5uV1d+Df0IHm2Nt3593keHx62XeBjIyVeY6MgqKMoJqNlK2ap6yhpp6muY2kl4l9kW3EqHuIwJaJm4rDwJiu17OsuoDEwKOgm6OOpKSVlJWajHZwncJqZ2ZrcHJwbnNsaGdry76xqauus7Wrra2pv7aztrCNg4WZpaWcnIyDg5CGe4WAdnl8e4WToJicpZ2Mg+/DorDAurrBrLqyocV7iqLCxbi6aHJvc250en2BfH11eH5weG5wa3eCfX+Bhol8fXd2boBycnBws8Z/maymkp6PdMWqm7mOta6hosK6rrWnpa+6vra+0cmwqLKzuMjEZmy5q7vOcKDLa8+mjdZ3f3t00mplrsajXmXGqHt9roOSlW9zi3x2zeiLp8J/hpKPfnfOgHnLwH59zoCBeXl5gIiHfXuPnJLRxLyZn8BtbWhotMJjqICGnaqDsW7MXqXBo3zAwqOsz3mjf4ZiaLZ9a3WJgYGDuW9psbC3sqGsWoVrscJvcm52cnFvb3WEfnR+bGpqasvGan1xbHh1c3bImrG5fG7TbnV5gXl/foN7e3mKhIqMjY+EdpZqk4SRrJS6tqKepbW6vV+3wW6BgoF91W3K1citnoDGvrOBp9hxeW941Mtv07Kq28TQyL3PwszK1tJ0f31/d9ra2dt7ipybjqyfloiYj36CfoB0nbtsfa15mIGHtqmQkYyCu3+Hg33qw5e+8bJycdq9yeiWpJKJ58/Z5oCptot86vB7fIB7c3Nw0628u8tveHV4enly04qMw5d30cXNkICaoJSMpruwrL/eeo2xyLyNhtXC3O2Fko6IkKG9x8LLvbmhiJChmrinpKGv0HDBwsfHwLnFzsZsbG11b313bribsXJ71OB5lbatyLPTxLGJoOJwcYaGgrJxbb2qg3B1gXdqdG9xeblqaXlqtsW7cNZtzr65nKaof9/Phop0i5CAdICCgIO2odis0dh3hoyJddPVtrvQwZl9vumMjI27udGrip3tfnvoiux0fYh5z8+Yv3qTiaCWv46Vgcq1g7KrgKWsc3253YTMxayYfoKEpbTCbmpnmolmeHSPlHl1gp+hnXd+jGOpcVtqY4KkqNBzrYzXjumCiKGxrGbX3YqQv4SlooCemsKPkqnPgW57dmt1r69+cmFgiWm/l3eDfaxwc4Wae8p1aH9+iIB6uGioq2lqcqiaz6bFxabDpsnFh7HRi6iVsZmVk4deom+VpaBtZD6PrnWcc3ORfJ+h1KXGt8Vto2/Mf4man7l/kJlYZ4NKe1xdWo2DdZdeb19iYLCGsGF0o4BlW5Vy2qLe6PLWtLjemJ6SpHyBiMPLxb3H0Mm8xsWLeIF4foHUxKqNdoSAcIx1dXOFd3hygnrp3oTP4cz25d1ub87RxHTWzcxv3tTYcHVzzW94fHuDbX17c41+j4l9gpaJk5WNkIiNnXaKf25jdlupm3qGrY14in60s4+myqmhroCspI6OhYt8jIqAf32Bd2hnhJxTUU9VWFtYVVxZWFlbsKyhm5+gpKOdnqCerKakpKGIe3uKkpaOkoR5e4iEeH98c3Z4c3mBiYSMlpGEfeLTvMbSzszQv8zMv+GCg46pq5+eWmJiY15laWttaWlmaW5kaV1eWGRxcHBzdXhubWxrZoBpa2losbVwgJGRhYt+arWkmbOKp5+VmLSwpKqfnaeusaSturGZkJKQkJyWT1KTkpmvYYmsXrSciMttdGxOl1NJg4+GSFOplGdulHF+fGBlhI6K8f2KpLdxdXx0bWa5bWq8sm5tvW9uamtqbHJxZmV4gnzAsaGEhJ9YVFBRi41HfIBcYnRfiECFSlVtd1WQcFVEVkVxSVFLTYNSPS1OSEVDc1NNhYOIhXF5QWhYkZ5ZXltiX2BdXmFqZ1xoW1tbXK2oV2dhYGhmZWaveYmWaV+7YWZob2dubHFqaWl2c3Z5entxZYBRbl5jeGJ1cmVqanN2fkKHk1hnb3FuvmG2vK6ZkIC4r6V5mMNnbmVsw71mwKafybfAubHAs726xcBpdHJ0bsXHyMtxfYqKfpePhnmGfXJ4cHRkfJxXaoRPdm1knqGGfn1egl54bHfnwl+7+LJrbt3T2eeNkoWC5tbo/oykqYd79fqEh4+NiIiF9tHf5vCDjIiLjo2D7o6F0KqJ/vP7nYCotqugqbS5w9z9ipOstKyJhtXA5P2KlZKLkJyutLC5qqKPe4SQi6SZl5Wht1+tp6utqKS0u7BeXV9lYmlmXaeSpGRrvMVzjaSgtKK/tKKCmM9mZXV0cJNZVpqNbmJkbmRaZGJjZZ1ZV2danqegXr1etqWkjpucet3WhpmKpKycj4Cbl5zGl7mar7NjbXVyZbvAnai1qYl2wOKfpZq5r8Wul6fkdnTWgOBwdHpxysaIwnWEfYqEo3uDca+hcX52VXl4WUlbcEJma15aUWtmgYOgWVtVd1U8SUQuSi0gHx0aHj9MRE5xVy4/O1VPcHVDbW6aYaBoVXMmTkp8WTRkp3GSh4B/dltPUmx6ZUtWVVxqoJtsaVZMeUFbbUdtUVRLTVZjYbRjW2hqY1xneFSRjlBMT1hqp4utnI2KZZpgRHh/V2Q9JlNXMxshY1NnfGZJRCVvgUNOVEo0ZoVtWllCQU9FhXneg4iMlqtxcG89Sk0vZkVJQnJvaX1JU0hOSIFyi0xjiAV9fXx8e4h8hH2Dfop9hn6DfY9+A319foZ9EX5+fX19fn19fX59fX1+fn59n36GfZ1+jX+ufo19h36jf4J+iH+dfoJ/hH4If35+f35+fn2Efg19fn59fX1+fn19fn59hX4IfX19fHx9fX2Gfgh9fn59fX5+fY1+hn2EfgN9fX6HfQd8fXx8fX19hHyEfYJ+iX2CfoZ9BX5+fn19kX6CfYh+hH0Dfn59k36PfQN+fX2FfgJ9fot9hH4DfX1+jn2FfoR9kH4IfX1+fn19fX6HfQF8hH2FfAN9fn6EfYR+hH2FfoJ9h36FfYd+CX1+fn19fXx8fIt9h36EfZd+AX+Jfoh/BX5+fn9/jn6Gf4KAjH8BfoR/Bn5+fn9+f4d+A319fop9hX6Ff4h+jH0Ffn59fn2EfgR9fX59iX6DfYV8CH18e3t8e3t7h3yIfYt8An18hH0KfHt7e3x8fHt8e4V8A318e4h8AXuFfIR9D3x8fH19fn19fHt8fH18e4V8AXuJfIJ7hXyJewR8fHt7hHwBfYR8B318e3x7e3yFe4J8hXuEfAN7e3qFe4N8hH0EfH19fYR8hX0GfHx8fX19AgIEAICB0NrL25Rtum+Zi96wjKmfiYjX+5KPvZGOh/GxsIq/3oSDkpb0xpu8tKKoi4Wbsr6wtq6Su8Owk/uqqrOnqK2dm4nz54iJgfqU/J2lopWOipWF9oaG/ZGro8TBrqDEvLC0wsjTjISLt8m7nZeEl4bFxa2ClbiagpnkiKWblIX+hID8h5bixcvIwMrHu8KynomMu9Xr7oOBg4yTkY2G/f3x1crBv7azpYbNyeaBhpmfoYebpqympZOM9NPn3MuHq66txrjH1trZ287Gw7+egr6mtYd5epOjrOHEn5CKgoKp9rLugPH484SKkJeYlYeBio6PkJiclJiTjpOcopyGjpKF/4Dz6tni4v2l18m2vLqen9ziuabW0bbEyd3U5eLTzaO/446MlJeFg4SC5+/v8ZOA9f/a84KOk4birfyDqa6mxqmPnaan49fz5YHKprbLuqb0pJelcnTFlsmRlJyCzt2gr5nxgoj37oyhkojtiZaQmZadrK2oprCMxfz/jJCtmvXmg4C47PO9pNSPxoHpwoHF07aXgvyM2NGprMXpu7Ham/S95Oz77viBjYyIiomNieqKiont1Njo9o+ro5OOkIP6/PX7gYbzgo+Pj4icrvSXoJuRgf2bmpmXn52go6WhnJaakJ2pm+2voKG0vszjg9bP2ezniILa9P6dpq6sm4yJgd/J1oDN3L3viPjohIrt/4CIqbCPlpbdrv+q8ZyVipKSoaKyoY+NnqmLiaCgmpSiq7eqnJikmZWmtIjRx62Dn7m0qJGblI6JqLKgr8S3w5azxMm/l3GDlJqutZiWiXKomZ7usL79m6yvuK6ppp6ikpinoqCOkKGjpqukx5iqgsKcf61jYYB4i7OJnJ9+x7bI13aQpZyKeOPq19zpgIWOmrXI3PTy1MG8o6unvKKdv8XK/IDUyuuA38DCnczN5/rx5Nz/g4rV06CxopLToKyHy8+6jLHd8dr2qL3V+vfRsI+M/Pugidbo8vSSg4uTh4OH6OjngoTox7ea3LyslJ2l3JuThoyTcYCoqGuErnyb6PWHk+z5tuDFv56VttGI66fKqZnzz6TJl6SIe5S4m47N69GLk76E36nUs9G3rtLHqem/wJaEraG1mNesj4PTnKnfrs/ujI2omNGqwYWattGfi/KxsLv8ub/Q/cSj8unh3fzc/rzP+bisjNmA14D4ieG8tJj/86KO1oCulpmAxIG8zcaAnqmcpbSF2/mjlpLltqGgqI/mm5P/0aScrNGXoLXT+5j12PyB+bb3tIKVi6/O6LaylK2P2Kj9y8qxjKuKiJy9ldO93o73nYuf1pCth6aozr6au5eWjICq8rXCrKSE+PCcqcfshZuKlqiU/pCRlfeWl+Cw2JSjt4Bxv87A1ZRvvXWcg8GdgZSRe3nC34OBpX+CfN6rrIvC34F8i47jsoqjnIqRfXaImaicnJaCnKSZg+WYlp+Wl5qMiXve0nt8dueG6Y6VkYZ/fIV32Xd134CWjqqol42rpJibp6mzd3F4mqmcgoFwgXSsr56AjqaXc4jMeJCGgXXdcYDVbne5o6imnqWkm6KWhXd3mqy4umZkZ210c25pzMvBrqmlpJ6dlH7LzOV6fI2Rk3+NlpmVkYSB7Mnf1cl9mZiVqqCpsK6wsqamqqWQer+xvJGFh5+tsNjAppqXjYyq5JW+aLnFxGlvdHd6dmtpbnFxdnh8eXt4dXqAgn9tdXlv2oDNzL/JyN2LrZ6UmZaFhs3Nqpu+uqKurLq2xMS4uI6myHh2e3ttbWxqu8LCuW9jws+zw2lydmy8lN9zlaKdsIt4jYp8naGwrWWkiJGgj4jSn5ild3W5k7Z6fYJut8CBk4DTcHXUznaHeXTLdXx4gH2Cjo+OipN4qszJbXCGecK5boCTs8KRgpyBpW/Zp2eYvKiAetd5p6WJkaCgioakdsCUpKy3tbNhbGpkZGhubr1ubm7EsLW9zXWNg3h1dmzOzsvRbHLObHh4d3CMl859hX96btSCgIB+hoOHiImGgn2BeoOLf8KDd293gIihY66kobu4bmq2z9mFjJCOhHd1bL+vt4Cwu6nSddrMcnTQ2251kpV8gIHCne2a1YV9dn18iIiSh355iZJ4eYiIf3+Jj5mMgX+JgX2Hkm6ZnJNshJqHg3mEgn5yaIJ8boCPq4GcqampkXSCi4qYnImNhHSypKntnKTmnbO3xMK/vLa9p6u6triipLe5ucCz0ZakhtKnisFxa4CAk7aAlJx/0sLT4HqMnZiIeeru3eLsgYeLkaGyxNbWuqynkJeUno2Qqqqy02u5q8VsvqaojLGuxMzGwb/XbnK4t4SRinzElaB6tLehfp6/yrnOipuswsGmjnZ01NJ+b7PF0c15anF0bG5wvr29aWrCq6KR1buvlKOe3aaek5ufe4Czt3eOu36T0NpzfsvXor+wqI2Go7d/4pfIqJHszKXKnKiJgJS2mYK20MCCjsB41paynbqjlLWvkcGeooFtjZKQe8Wqg3HYm67mttzrb2+PkMGMk3dteIdjcMaXdYfEhHOgw5N4tbmuhMi66aXB4ZyVhMpzyW23VbKUmn2+wX9yp4CWg4psrGyjrp9je4uEh5dsqq9vdnqqjIF2aGiwaXrZrXJ4gpV2e4Km1HDPt9Ju1Y3YnWh8b5W52Zydf5151p/mp5mAd3x6f4Kpb4l0hmLQbHSGspGieoiGqqV/mW97cmuNzJObinpdsqdbXnyiWGZcYXljn1xZYaRpb5d6o3mGl4Bqx9rW8a2A3YqneaKMdYOBcGyyzXVzj3N1c82qr5vO4n14hITSnYCQhnV5bGt4hJKPjYRyhIyIe9mIiY+JhIh8eW/MyHBycNl824OGgHpzcHZrxWpqy3OCe5OUhoKZkomJkpKSZmNqg4yCbGlgbmOam5N9jZ2faX+9b4J3dWjHZYC4Wl2YiZKShoyLg4iCd29rg5KWllFPUlhgYF1Zr7Gqn5yXmZSUjn3W3u96fIuOjoCMkIuMioF/8NTl4tl6jIyImJOWmZWXl5CWm5qKftbO066io7fFwdjLvLO1qae95YKlWKCpq1pgY2dpZlxbX2JkZWdraWxqaWtwcXFkaGxnyIDBv7i/wMh6lYuFhoV1d7/Bq6G0spqknqiqt7esqoieuWxqbWheX11YnKSglVZOpa2apFliZFymhNFpi6Kdl3VSSl1kc4GKi1eNdHyId3S8nKCoiIGsla9ubXFiq69re22+ZGnDumhxaGe5Zm1pbGtveHl5dntlkZ2YVFhoXJmRU4B1i5p5VVI9WTk3dlR4g2hHKF04gHxZT2V4Z2R0VW9vhIiLh4lLV1FLSVBaW51aXVyomKCksmV5cGZkZly1s7O4XmS3YWtqamOEg65rc21rYbtwb25rd3N1dnh1cWxwa3N4baZoX1FSWVtzRXxtaYSASlSds8B0en17c2lnX6ubo4CeqZu+asa8Z2q9xWRogYNucXGymOyRwXZva3BxeXmBenFue4Jvbnp7dXZ8f4h+d3N8dHB5gGN/c2lOaIN6bmV7cWlrT2xlWmJ+mXCImpyimIWKioKKkYaOi4DNwL/ujJLdqcLO3uPf4N7hxs3f3NzCyNva2eLN6Jmjiuq8oPGLg4CWqMWCkpmC6Nzq+YWRmpiKgfz78Pr6iY2PjZmmusTBrqGZhYiFiICJnpuiuF+lmbBdp5WXg56crrKxs668XmGkp3F9enO0jZV1qKqWeJKrsqa0dYOMm5iJeWdlt7hpXpuyt7lnWV5gW19fnZycV1ejk5WH1sCvnqah2ru4rba6kIDY3Iyk2IaNur5jaLG2kKyflIF4kp103IrGsoTjzqLJq6uRkZqvoYCptrd8hsBw0YmcjKKThZ2ahKCNkXFfcmVeWINbSUdVUl+EXo7SV2NgWnxqaEJITmsuPnJNNTp3PkN5eldae4RQUnk9Q0BTV2BnUW9GQzdcJGl3YV6TpHdhkYBvTEtGZUZ5iGQ6YXVzfoJWg41gZVeDaF9iW1iLU1BZRlhkcHtMR0qColilkJc9aGqmdUlYU3WUnXtfNUI5Si9POlU9GSIWH0MkJk9HTCVIJDJGVzBANUBhamdUXUFsZ2mK4JGVd2VNn31APlBsQk5FSlxHfUZBSINOU2lWgGd9iQF8hHsFfH18fX2IfoJ9hn6GfYR+AX2TfgF9iX4IfX1+fn59fn2IfgR9fn59mX6HfYN+hX8Ffn9+f3+Rfoh/i36DfY1+hX2RfpJ9Bn5+f35+fpp/h36If5J+iH+EfoJ/hH6EfwR+fn1+jX2Hfol9hH4KfX1+fn59fn59fYR+AX2MfoN9hH6IfQh8fHx9fH1+fYV8h30Efn59fod9iH4EfX5+foV9h36EfQN+fn2FfoN9hX4BfZF+iH0BfoV9BX5+fX19iH6HfQd+fX1+fn19h34FfX18fX2ffpR9kH6EfYJ+l30Hfn5+fX19fIV9hH6EfYZ+hX2WfgV/fn5+f4x+BH9/fn6Ef41+iX8Efn5/f4R+h38Ffn5+f3+Efo19BXx8fX19hH6Cf4t+BX1+fX1+i30Jfn5+fX5+fX59jn4EfXx8fYR8h3sCfH2FfIZ9inwBfYR8hnsJfHx8e3x7fHt9h3wBfYV8AXuEfIJ9h3yCfYR8Dn19fHt8fXx8fXx9fH19hHwMe3t7fHt8e3x9fX18hHsJfHx8e3x7e3x9hHwLe3x9fHx7fHt8fH2IewN9fH2Eewx6e3t8fX17fH19fXyGfQV8fX19fIR9hHwCAgQAgPaOxIvvn42spbPjtsaGhpeTspmSsZrWsqClqKGdh5ne8YCapKGs7bzgysXBkqOs27adrJbEzNa2oJ2TsqOzoJ+jl4eKgvyH4tfZgvyK+O/yhZWOgISZs7CunrzZzr3H3Luoo5yHqaymwrubhpLHnJ+OvIPmwbrgwsD/jvWD2dj/gNrR8d/Kx8vh0rm5w7myv7ins9rRztnW7oGD//j33t/i0c26r6qbg/+B946ij5mqq7XCuLKcjPrfy8XurcnN1uHYv8zU0+PKwMahhJ2ViYyLh4F7fWtydXt4cnJxdHJye4yPqYCVwIGOh4WPiIWLi4uPjYuKjpCQi5OOi4X/6NjmgNC2ssqFgqm4vK66tKaZzbTAv7Wzy9vw9sfO8+OQ3NXwgJGIkP7+h4L14oyUhIf/9OfQv9z70qmXtY2mg7T5uYCuvaebqaunl6KNr7vDo5rSzvnVh9WQtNKgmvXzl8mysZ+GntjYgo2PgK/Jg5+TmJCenamsvL3CvLH78f+CtpW6gITc5+rDhYiPvIC/haCKueePhInqk42v+K/M0Nf+t9uAxc3l7KSChJzyxp7/6OzfvODj3s+Wi52H3+Te6+Xt+v2Fj5KNkZns/IaEg5KXj6uOhqaik/f//I2XnY+Li4uNjomLk4uI1K/CzuHp6OCSjv+NopGF+p6lmKizppmN9+z9gIGLgYGKiYyFhpiZlKSZlbS2ua6RhJCToZGYpo6CgZa3speUnJ6HhI2Jjqujk6SeorjAiKCdloLSy571lazctLy+s6yglsCStteC9PTtrJfsyYGdxMHJofbyzpqHeqDV4evGwbqii4yalaKglImMl6K7q56Wq7uovNJxaMGtjYCFgHjC+vj0ypR82tTOscxr1sdscXDcbtfSz3SRqsn2iObH0Ke2ssDYoJCrwcDE3dnO2tXgw7WyueiF3snM+In/64uBlZzr1of+uc2O9t7d19GEnLXIgYiorZKAg9rc06WxxM3Y+JKCgI2H/4X76oL/7tS+h8iWd3eJqm2Vfn55hYx8gLq0f5CXpYyqu5Ha4v2t3Kiqs66yhYGnm+bM8+vainB+nqJqwI+IhafY2vjzlqu2obmD/+Oj4Lq6zNHWyNTTibOfg4XBn5Kbo6mflayn9MeX6JalvZy624OFvcKPur/+tbjogd+7zZjVjODesPmr8PO1qPCH0rzliJyC7relxeOGgLuopNfKsJHW5qyH5dDpxNyyvb6Vufie/6bOoMeSi/6dspKasYKHqeKa/YDU6fjnj4y2q5yNkaWPtLifprzBseXYw7H5lIatxIuk3JjN/p2SrvjgheqgzIGQpsDy8sP2g62uiOuur8uEgY/uhM6ShIab5MSdmIanx5+Sv7bmlo59gOOKwITZi4CuqbjZtcF8eoV7lIN/mYCzlomOjIuJeYjO3niNlI6ZzJ63paKjgpGavZ6Kl4msrLSfi4yDnY+fjo2ShXp+duZ70czKd+R94dnYdYJ9cXWGnJmWiqO8s6Wuv6SRjIR1kJCNopmCcHmkhIZ7pnnjq6jHqKngfNRzvrzbgLiuyLikpae4qpaaopyUn5iOla+npbCswGZozMjGsra3raielpeMePB44IKShY6Zm6CooJyLgu/czMXlnK6us7q1o6qvsLqpoqWNeaeimJ+dmZGKi3mCg4iEgIB8gXx7hZeVpXV+oWRpaGtzbm1wb3BzcnFxdXd2cnl1c2/Wxb7FgLmno7dybo2WmI2ak4iBvqqzr6CZr8DO1q6y0MZ6w7zRbHpyd9LHbWnEu3F1bGvQybuxnrLJro18lnR8caTJmHCZpYZ+i4mCfIZykJugiYG/rN3bhsKNq7+Nf9bSfqCRj4Vyg7u8bnV6b6CxcIeAgXqEhpCNlpqhl4zMwNhwk32qgHjJ1cChaHiGmGGhcYFwpL94Z2moaXCXv4GYmaK5k6BkpJ+spHNaYXO1mXvCq6eslbTFuq97dIVvuLq4xbzGz9lvd3p1eH7F0W5tbnp+doN0c4qEetDX03Z9gXd0dHN1dnJyeXRzs5GPn6myt6x0dNZ2iXtz2omLgYyWi4B10crYgG52bG51dHVycoGBf4qDfZWYmZF5c3x9iHyBinhwcISalYGBhoZ0cXp2fJGKfIuFh5mbc4WDfGWvr4Labm2UfZecfXpucJ13jrJpysnIlYrjyXqNp6eqj+jt1KKTg6XM0NrIy8azn5+vqbmzp5mfqLTWxrekusi2xN94cdbCoZCSgHiy1dPPs41/4dzYvNhw39Fyd3bmdOTd2XiQnrXYc8avtpSem6u4j4Sdr6emt7eyt7S/p5qensRvu6yszm/Vxndte4XRvXbirbZ508PIvbVxgpOfZGqJjnlta7e6tY+aqK+403doaHFs1W3Lv2vUx7akeMGdf3+Tt3eeh4qFk5qDgMrIjJ6jtJKzvojCy9qavJqYnZ2ffIKpjOHO6OXXjXWEpahxv4N7eJPPvubkiJeik6Bt3LyKyKqisa63rLOye6GOeoHMqaGdnK6dmrGAzLORwYuKj4OEkWlxq51bhYiwi6KwVKuVm4qsc7i+kuGZy9e4o8N5o6e3dId1uX+CoK5xgKKOjr2xnH64w414xLbJmbOHlpd7lbpsw36UVIZxb8dphWVvb2pthbNqvma4xtXCfXSbin55ipJ6oJCWmqu2rMOQlXi1Znx7im2GtG2dzoR4kuepdeKXrm58i6vcx56yZ4+IZrOMhY5bTlepYoJiVFhklHtgY2F5mnNsg322iIN2gO6cyoXId3O3uMfWu8Z3dHZne3BshGyVf3d7dnd5cHrByW+FiISJrISSiIiJdIGHo459iHqTkZWJen12in+MfnyBd3J3cNh1xsXBcthyz8jEanZyaWp3ioWAdIqjopWcp5CCenRnenl5i4FtXWOBbm1olXDtnaC7l5vMcr1orqm9gKCToJeKjI6ainuCioR9hX99g5KKi5KQolhasK2rnJ+fmJaPjY2JeO953n2LhIqRk5mdl5GGf+7n39jpj5yYnKGjl5ebnKGYk5aFeMjDusDBvbOsrZmkoqWgnJ6aoJuYo7OvtXN1jlRVWFxlYWBhYmJmZGRjaGppZ2xqaWfKvbi/gLSloKtnY3uEhX+EgHlzuay0qZqSpbXCxKGmv7duvLXCZG1naLajXFqioV5iWliyq6Kai5illHlsgGZpaZ6qgWmHinNteXRsanRggIqMenK0m9H5iq+Mo7Z5bsK6bYR5eXJmca6xY2dsYpqmZHdvcGpuc3l5eYSJfW2joLleeGqNgF+ltXpgOjkqLytoRlxBVHJDOE2ESUZTgWF1doSJVWtKYnmFdU9BSliNe2GRfnuHfpaloZloZXRio6Ghq6KutbtgZmtmaW2ruF9hYmptZ2dkZnlyarq8vGducGdmZ2ZmZmRjaWNdnn9wd4iRkX9aYbtndWtnwnl5c3yDe3NnubO/gGJqYmRqaWhmZ3JzcHl2b4KFhYBvaW9yeXB0fG9oZnaLhnV1endpZm5qcYB9cXt3eoeHaXd1cVyQi2CaRk5qVHWJX0c9THVcdJlatbSxjYjt1niBmJmfjPL36b2tma7Cws3Q3NzPv8DOxtzTxbW9ydf96NjA2ePP1/CFgfzlwaqsgICqwLeuoIeD9PT12fiB+/CBg4H7gvz78oKRmKzJZ7ahpIaSiZObhHyQn5OYpaGhp6Wpl4ySlLNjppqasl64sWVeanTDsG/So6pvwra6raJicHh+TVFxdWheXJ2ioIOHkpqhtmFXWF5bt12qnFizq6CObcCxm5m23JGsm6WdqLGYgO/6p7W6z6jP0oWyub+PqYyIj46KcouzfdfN4+DYmYWSzc6JvHhwboHCs9XVe4mSiZFevaF6v6mVopqhmaCfc5R9WFBpTFhjYUpWRmZao04uazQ2P1JfeDkyRjshQldZO0lVLm9ue0xvSWh4R2pEXH5JSm1HbHCCRV1TqHp6jJZfgIZ5dIZ3X1qJj3ZspqWsgptne4N2fpFTk2uKSGlfYkElZEJfWDE6VIlSoVOHmJmPXVNzZ2JZWltdk19tWXJjOztTXDxbLhwnLiIgTjpNaTM+ZEZSNUY/mF9waH2GnW2GVIaKWrB3bm9AOz+LUFxHREZNclhISEhji2BWXl6UjIeFB3t8fH19fn6GfZJ+gn2kfgt9fn19fX59fn19faF+DH19fH19fX5+fn9+f5t+gn+NfgN9fn2MfoV9kH6YfYN+ln+Ifop/jn4Ef35+foR/Bn5+f39+foR/jn6HfYx+BH19fXyFfQR+fn19h36CfYR+gn2Ofgh9fX1+fX18fYh8hX0FfHx9fX6FfYR+BH19fX6EfYR+A31+fol9hH6IfYZ+gn2MfoN9jn6IfQN+fn2EfgF9iH6Dfbd+BH19fXyLfQR+fn5/hX6CfYZ+on2CfoV9iH6FfQt+fX1+fn59fn19fYV+AX+ZfgF/hH4Df35+hH8Hfn5/fn5+f4V+hH+CgIV/iX6FfwV+f35+f4V+AX2FfIh9gnyHfYx+A319foh9BHx8fX2EfoR9hX4Gf35+fn19iH4EfX18fIl7iHyFfQN8fH2GfAF9hnwEe3t7eoZ7BHx8e3uEfAt9fHx8fXx8fHt7e4Z8gnuIfAV9fHx9fYR8h30FfHx9fHyEe4l8Ant8iHsCfHuEfA99fHt8fHt8fXx7e3x7e3qGewh9fHx7e3x7fIV9AXyGfQF8hH2CfIR9hHwCAgQAgJG72r+3v4lwcYK/gPPPmKWnvtvnvq7Q4MXC1djguYiBjLuyiP3nlubLz+vb36D/+oPL65qPrrfInamrrsHItLfDubiWnfiEi56A7t7L1PX3jaGtraemqKOtqrfT2r682NvYxKmDltnNjPbBxZC1uJWS+8qQsdPR9cWEhIPV7/fJgLW+waahusHCzcbIva2tkpX/mMTLzMHGy8DP29/b0cjJz7mhmfiBkJT/hpabl56RoKrB28/Awc+jnLvagIiL5fLMz9/h2unWuKWjh5yOi4uDfHt2iJCIzdr2+4KB9eSEi4Ty1srKt8PfwPmChoX9iIaIioSDhY2MgoDx2MW7s6GxgKaixfiC7J6ruJnCvKaP6tLZtMXq1srthOXvi5KD5cf/+JmPhILo5M/u//C/yf393ebPtLjV1MStm+CJmNO+x7TBovOipqicnKSRorLVvaGPyfL3vp2e96mvgYafmZ3EuqOMi+6z1IWL77Ps3pajqKCqkY2f3pe4wa7/7/CF3fShgK7c44ic8o6g2auImfqW9NbqjfLQ4ZCklp37sL78rL2t2uy4q4DS3dzc/IeLyt6Cw8jewJ+/j4yFzd/Dt9/E7I+akYqEhfPyhYP+hpekpvaulIqjnpyL/42TmeO/wOf8yf2AkY6F5+Pv2eKCkY+Sm6CiqqaZmpysnZ+bg+X7+ZCGgNvn4/bqiJWsr5qLgZT5l6qOpKiJiIaE+ILn2Mvb9Pr5g4KSmZSSlYOQjtj39oGC/euU+YiNqIXg56D7u7mzwd6DlMnQ1uK7tuHw7e/XvJyK/fmVo6SgmIeB1Z6AfHSa8vCrqIuBgnh7hYysrKekmaSnrL23yr/Frb27tLqmf4GLgJ3G3uGupJiKlH/cvrqhlZ+y14yDwMK0xc/R5YqWubbDgJOTgI2G4viA67y4n8qRlJyOraPG0sHBzoL317DchfPVgon8m4TIyd+O292LrbGw0fOaqvyhlP3lnoeXsrP93ODz6pDd14SA26mlw9LGzreQzo6+moqnt2dygW9uaWTGgKyRc5icm4aSd8TOt9ONlaOM/ZbfdnrgkeHdzdGgcLi7s7uY+++Sus7Y0Pybx8XExbjziobJzcycvNux26+3m/vb47DF5ImmsLGOobHflOGmlIb9+67X5szn37Sr6cvX26z/s+SchNyrhcug9Yjyhqad2sLB8Z+L9IGtmJWA5PKDgMe60cO/yd+Rg53k05XCj5en0oe8k6uR6pHBno2ltfyFwIzng6222oDflYmGhYnnx8Dc36a9o+bRmevApaOUnNOBlq6V0pGZvpn30ay6m9iOqb+/iISD15qbzdeSntaluMnO/4u3iZSt4JHpnJOm6f/wpb6vsaGdjpaokt6aiIGngIa107iwuIt0eIq9c+TCgouKor2+oZOmrZydra+4m3Z0eqWYfOndh8ilq8Gwso7p33a60oiDmKCsiZOUmKmunp+so6OIjN94fY5z18y2vd3cfo2Xl5KRlI+YlKG2vaWiu7i3p5FxgLGlb8OeoniXm35817OEoLq52Kxzc3O5z9WtgJqfoYqGmp+hqaSlnYySe4Dmg56lpJyhpZypt7WyqqSkq5aIhuNzhIfrfIeKipKHkpipv7aorLeUjqe4aG1ut8aqr7e4tMK2oZCUgaecmZqRiYeAkZeQx9Hn6nd03NN2fHbfw7u9s7vOoMxpbWrObW1ucGxqbnRza2vLuKqjnpCfgJaSr9VuyoWMl4SfmIx90cPCm6jKvrXRccfPd3txybPe0314bmq+vrO9ycGQmMHLt7yumpqysaOOfqhmfbWWloyYi8N/god/fYF3hJKvnIFznOj0rZOb2qCfb2+Gf4OflYd2dtGgtnFuxqPQyIGLj4iOe3J7w4SYn5Hj2NJ3r82SgJnRy32M4XV/uIxpheJ4u6rLdb2bo3qJbnq/gIW9f46SqrCHe1mSmpKXuGVjhJxqqZ2xmn6bc3RtqLqim76mxnh+eHVwb8vMb23ScH2Gh6SGfHWKgoF01Xd6fr2ilrfKntJqd3Zuvr7Jtr1seXd7gYeIkI2DhISUiImFcMvc331ygL7KxtrLd36RlIR2cH/Zg455jI11c3Jy13DGura91trZcG99g3x+f3B9eL7W1XFu3Ml82nJ2iWy7wYLZlXp4jLJVbaGrrbidm7rExsa1oIZ+6uWCjo6Oin9706aKh3qY5+Wvr5mUm4uPnKPCvrq3q7e+xNjP3s3Sus/Mx8uyf4OMgJWxwb6WkI2Fj3/jyMawpK694ZCIydLD1t7a6oeRpqKmbHt6a3Vwv9Bqy6efjK6BhY18lo6ttaqlr23WuZi/bc6zbHfehnWzsr54wch0jpGTp8B0gcKBd9HFiniEnZ7Ltb/OwHO2sGlms42Rq7GqtaKDwZHHpZm8ynV+i3p5dW3UgLukgayqqpKbeLi9ps6FjpeC8o3ceXvZidrXyc+kdcHGvsae5NeAna3FvtqEsa6urKXPcW6usrSLqLqat5adjOXL1qnI542woqqEhIu8hNWNh3Tb1JKiqaiyxJyOko6in4bLlbp6X7N8ZqyF0m+/boKGz6qbqXx93myMgIttvMtsgKeap7C0r7J8aoK/rYafe4CGnnGefIVyo1uNbWl7jsJujWC8Z4CHt2Gud3VqbHm6qLLMwpuplsWritzCnJSEjrxqeodpsIKGfnjArIeCjb16mKGodHl804l9rLtufqd+jaKew2iOY2t5k2GdbmJto7yrdo9tZ2VpaHV/cbGLfoCmgIKzzLCyupyJkqHBbNzEc3V0iJ6jiH+HiICBkpOZg2lqcpSGcdvNd7uNlJ6Oin7aymqtxXZ4iImQdn+AgpCTh4iUjpF+f9JxdoFuyb6qss7McoKJh4F/hIKHho+hqZOOpaGfkoBnb4yEVZSBgWF5f2pqt518kKesy5tlZGeruryZgImKiXhxf4aIjouMg3N+bXPeeIaLiYWIjIeWpaGhmJGRlYV+guRvgIPpdn+ChImGjI6YqqefnaSPipSgWF1boK6anqCenKmllImKhMi9uLmvo6KYoKWhycvd33BqzspsbmzQvre6vsLLi61bYF63YF9hYmBfY2ZnYWK9raKdmY2ZgJKQpL5ktnR8hHeJhH5xxb23k6C+tbHIabzCbW5pvqvLw25pYlykoJmZnJ1zf5WknaOXhoeYloh0aYxUaKR+dWeFfKRsbnVwcG1qd4GVh21cgvD4o5Gbx5mYZGJybm9+dnJnaL6XpWJcrZ7BvXN8fnh1Z2FkrnZ/hHjDvbFtlquFgIC2jV48mlA+VmFOVI5Sg1lYQYtqbkhST1iOXmaUT15nZoRiXj9ncWNtjk5HWm5Vh3uKg2yDYmNekaGPjKWYtGttaWljY7e1YmC6Ym52dG5tbGh5cXBkumhqbaCDaYeZfLRcY2dhp6Svoahga2hsc3Z5e310dXaEeXt2Z7jGx29ngLC2tse6anGBg3ZtZXDFdX9vfIBraWhoyGe5q6aww8jJaWh0eHFzdWdvba/GxmVlzLlwxmVpd1+mq2CJdVZXdJU+Tn+PlKWQiaWvsbSlln9659d3g4aGh4F94r2hoY6a0d27xLKyvKuyvcrk2tvazdri6f71/efs0O3s6unLg4aSgJWlrKGCgYGEjoHz3uPMwcvW8ZaN2/Di+P/6/o2RnJaZYWxqXGdgo7Rcs5aThJl3fIV0iYKfn5qUnV+8oYquX7WkYGvPfG6npLJqsLZmdnh5h5hYYZRqYrOtfHF3i4WimKOxqGGelVdUlXV8l5aXn5B1tZznyr/n+JKdoJCSjoL3gNzOn87ExKW3gK+ulcl7hI575ILUhorYgdXRyM6thOr26vKp18hyipKzrMh3m56dmJS2X1+ep6eFnKSMnYeQgd3I1ZitvUxiZVJcWFaUYWVAODBwXkJNel1MVEpNQ0BHND5vM2BSSIhiOnhMfj1tO1hRZV98n2lfflVtUVxdlKBXgIVye3dPUFtIRG+8mnqCbXJyf1+IZmdamE1sVD5aaGVIXhRNQVBEREl1VUhTVll9cYFuh2uDaZR5YoBxg3lqaV4zX2FHXTkyISZVYDlIHm1EQlRXMjEoYW57kXBbSoF2go+SsFqHV1hidkp/V0pSg5B4UWZMRUZNVGBiYpqLhIi1i30Dfn19ln4EfX1+fYZ+BX19fn19kn4BfYR+hn2YfgF/iH6HfQR+f39/lH4BfZN+BX1+fn59kn6Df41+j30Hfn59fX5+fod9Bn5+f39/fot/i34Cf36If4l+Bn9+fn9/f4R+hH+Ufgp9fn59fn5+fX19jX4DfXx8hn2KfgV9fX1+foR9iH4BfYR+hH2IfAx7fHx8fX59fH18fHyGfQV+fn1+foh9AX6FfYJ+iX2Dfod9hn4FfX1+fn2MfgR9fn5+h32EfoV9kX4FfX19fn6FfYh+AX2JfgJ9fod9in4JfX19fn59fX59hH4EfX19fIV9kH6CfYd+pH2Nfoh9gn6HfYV+hn8Dfn5/kH4Bf4R+Dn9+fn9/fn9/fn5+f35+hn8FgIB/f3+MfgV/fn5/f4l+gn2FfId9g3yGfYR+AX2EfgJ9foR9AX6GfYR8CX19fX5+fn19fYd+gn+LfoR9AXyJe4V8BXt7fHx9jXwWfX18fX18fHt8e3x8fHt7fH18fHt9fYV8AX2EfAd7e3t8fHx7jHwRfX59fX18fHx9fX18fX18e32GfIl7gnyHew58e3x9e3t7fH18fH19fIV7g3yFe4J8hnsCfHuEfAh9fH19fXx8fIp9hXwCAgQAgLKCkoSuxdu42t2bnYigpqqvqLW/r6L48O+Wu87JoJ7J1ofH0aWJhH/stZu88NW2lKSdiIuenoablJudq5Kht8nAzMKpl6KmoZuM782jwOTn+7e2rqq3sr3ApMXPw+TP0uHh8f3usbOgy7/H5L2Jhq67hvLJoOL9/6HX6oPo6f7xgOa0rpSRnqnAw7WuuLK1po+Gl7GanZ+ruryvqsO5qbCoqo38y+7n+4qJnLi+u8fK2fqSu7SqmPTs2vPxgufGtKi0wqiqsrisl5KqwZiPi4CDf5Cv1uGTnqWxqriikpqxoMmwoqG1ppD3iveo3oD7+vyF/u7+hYeKkIry0aiqnZyUgJ2xx97a1veIoaudrpuRiOaKhOX1xePx7oWUlpLw44aPhpidg9yA1JCvy7vr/Yb22Kqyy5v0gJiSpcW2wrHIx47g7JKWmY2PqqKTnbHEzq6g78eZ3Zqbis/M/Pngn7Ku0ZLl3IPO0ZKxusWG4JCVlpSio4KA9YqRjru8tpiHzZqhgPOWk5aAp8rezZiGmZLOs5/Dhaq4x5XPjbG8oPPW6Ifv96H1ytPo4IXR18e2mqb8g6yvhL3c/dG3vtG8tuHNwtzqgfjrxMe15eP18ouSmZKBj5uVkImYmJaH682mrLTG04Ld4+jD+ILR1JiinJ6YoqWcm5qqo5mRl6Gol4r1i4yUgIiJgO7o7viMopyKgJqYiOzu4vrVvrza5PL1+tS8wsTK0/Hzh/Dz+cXT7PfppMD70bnfj4CHnqi8vJzq/P+NkaSIgf2isq2Kn+WUw7yYpKWaqrKe2bTy4IKJ6di5jpi/26GLd3h2gHh1dHiAnLKsnZ+dkJGgm6m6xtjcndrdmZGegKjI7oLqu5v//ZDjy765oKHVeIf06M++q6mpts/4j4WZsre6uNviv8Hd49ja1rKatbm5k4mikKyu24bam5iil4uTpN/BqtO5k//i1pLS9IODjJSfhpXB7LGijZPX8by8qrfkx8PPz+nX0tqI4+DIw9SOqI2NpbzVho6MgppzZaeogKeykMbCxszCg36QmpKZvMGWxJCur3N2kKapk3jVg7+nhoXH8azh4OzXsMD41eeapryzwLC6uaqioarBqNOXpb3be7KJtq2Fr573wM2P1buL1vmjxJ3C3Ja25ZCFwPnV0JyOsYS9gICXk4yXiOj1oOvaucLV19LV1rzozvnPnLbAgKWX0pWR6qHM3K6EpbyG/cz09In0pI3l9Yqm5fq8iMeIk5zRhtvjiL638bTLjvvexfSMiJOA0vWPvIyeqPOJkcmTqMyS6Maan+Oe4cnyh7jrgqn1oJTSvp76kcrMq4+4847QiteUzsT31L+vktPa0oys78iFzp2DiJCvm5mo64CTgLB5gXWkucupxMeFhHmKjZCRkpaimo/a1dODo7Gpioq6xHSltpF6eIDUmoahybKfgoyKeH+LjHeJg4iLloGNoa+psamVhpCTj4l817qWsc/U46Ofl5Sem6SnjquxqsGwscC+ytLIlpqHqKGjvp12cJObdda0j8Xa3Y28znLMytvOgMKZk357hI2eoZWOlpaZjnx4gpGBhIWQm52Tj6Ofj5SNjnzuwd7V5Xx4h56ioa6vuM93k4+HfcvMvMvMabqonpOcqJGWm5+ZjIaayKiemoqNipux0d6HjI+WkZ2MfoSViamUjYiXjoDhe+SPuGjMzc9t08vWcnBzd3LKsZSXiYiEgImWqb23tM9xho5+jYJ8d8d0ccjWtMnV0XF9fXrSwnF6cX6AbrdqtX6Il4GkwmfGuJOUqIXdcoZ/jKaXppSipX65v3Z5fXV1j4t9go+gsJaB0LiR15eUdrm52dnEh5KMqXjJvW64tnygprFxxnt/f3yFiG9w23Z8eJmbloBzsW58gK92hIV0lKSzq3htgHuZhI64dYORkXqvZoKKdL+st2Obp3OskZKhmF6Ni3+AeYbNa4aNapCr06SQl6mflr6uo7jDa87FpaabwcHPzHR5fXlrdn96eHJ/fnxtwKyLfICVll2rr7uexWuzsX+Hg4Z/iYqEhYOQiYF8gImOgXnVe3l+gHV1bs/M0NZ5hoV4b4SBeMnSyNm7qqK+yNXW17eqrqyxudPXdNDS1q+7z9TPj63dtKO/em51hI2Yl4HIy9FxdINsZcmGlpN4ic2CpqGEj42HlJqNzavl2YCD6d7EmaDC0qCUgYiGlY2JhoySrcG+s7S1qKm2r7jM0uTmlsXDi4qWgJesx2zKnpDs84vhzcbJr6/hfIj18dvNvrm8wtf5hXmLnp6gobq/o6bAwbi6tpeInaGbgXqPgpCOt3C/i4iKiISHlMqtmLuiheDHvHmsxGhnbnJ3ZXioxZmRg4O0y6CelZ68paKwrcK2sbhrw72qp7eBqZCSq7/VgIqMgaR/cLSvgLHAoNzU19zMgXuLmI2ArrGJwoObrnV2kKGnmn3UgcawjIS42ZXBv8W0lrTYs8SKkqWeqJumpJaQjZepl7OJobfRfrGHt7KPvobPoKh1p4tzyMCOl4aau3qgxG9ikaKIlHRrfmOHYmtobWiDfePlgLmqmaCxvLq6urHLue21hp2kgIiCs4iI05K1w5N1j5lr3rbLzXbRhXO6s1dhnZBzXp9udW+dbbG6cZqc05iveOTYtMuFeYd7wuqCwZCdr+B9hruAma52yZh9grB3qI7NaZm7bp7LdW6VkYjCb4uNh3GUr2aYa6NtjYOji4l7Z42LmWJ1rZJfiXZia3SZkIqb236RgLZucWmntMKitL10dW54dXp7fIGNhXy/w8d6k56Ren+wwW2OnH1paIfIgXWMqpeQeHx6bXJ6fWx3dHh8hHF9iJSOlpGEe4GFhH9yxrCVrsPI0pGNh4KKiI6SgZqemqmZlqajrbKlfoV0iYOJm4BkYXuAZL2egqe7woCmt2Wzr8CxgKSFgWxtcHaHinx3fn6EfXJydn91eHmCi4+EgpORhIeBhHjuxtfQ3HRxfI6Ukpyen7BhcW9taK+1rLOzWaSYkouSm4mMjpWTiH6Q6s3BvamooK24zNh7f36Eg4h7b3OAe5GHgXyGgXfWc9h/nFm0tLdfvLfBZGVname8qI+Og4F9gH6IlaumoLVmeH5wfHRwa8BtacHMs8PJxWpzcm/EuGlvaXFvYqheoXNqeVx3lVGjooaDknXQaXhye4uBi3+Kj22mqmVpbWppgH50cneJlINrt6iJ4JeVaaqrw8G0c3dxhGW2rGCkp2yWnqhlt25ubWtwcWFkw2hsbYB/e21ilFRkgIVecXNVbHtvMEdBU0BhVzE0MlVXVkF6S2luYYlziFFudVR+YXJ9bD9aXFZaXGOlVGlyUW+Fp4B7gI2IgqWakqCqXbOqlZWQr625t2dsbWxga3Jta2VubmpdqZV5XmJya0V6gpd8nludlW52cnVvdnl0d3V/eHRvc3t9c23Eb25wgGlpY7u4vMdtd3dsZXZ0b73CusexoZixvsXHxrChpKOorsbHab3Cw6ivwMLAiqHJrJmwcGdtd3yFg26nr7ViY29eVql5iYJofsl5mJh+hoWBiY2Gzq3h5YKI/PfesbTI062nmqOkuKyppa21zN/e1dbZy8zYztru6fz/mrmrfIWPgI2drlyqiITf5oPfz9ngyMz6g4vy/fHs4dvc3+z+gnSAlJOVlKaokpavraSnnIR9kJCFdnKCeX99pGKtgX9+gX5+i72kka+ZfMu0p2uPoFNTV1lZTGCOoYaAeHefr4uIg4+jkpKal6OcmKFUqaGPkZt0qZqmu8Pae4eIfbmXh9XEgMTUuf3y/PvohICNkohroKR6w3iLs4OCkZuqnoDiguPZno6sxYKppa2ghajEl6h9hZOQmo+bmI2Jh4+diJx/qbjSk7qKzb6CeleUfZBddFAuZHpGRltZflpTXU8rOkhJTVE8SUBXSThUR0FGTmZuOXWKenCMk4iXh3OgjImPaGh+gHRyoFhWqWN+lIB2fYZdoIK1rma2amOYoVBXcX5XRkA+RV1ZKlF2UHppXGZqVKp2gIw7OF1cq7NcSERNT79ralpZY2c6WUxSKDVKYmFdJlySV09qWEFzb3yPWEFJGhpxck+MXp1gbWiAaXRmVm1ffkxagmVJXlZQWl6bnI2d34aRBH1+fn6GfYx+g32GfoJ9hn6CfaF+h32hfoZ9BH5+fn+mfoV9in6Ff4V+AX+Ofot9kn4NfX59fn5/fn5+f35+foV/jn6IfwN+f3+GfoR/gn6GfwJ+f4d+AX+GfgF9i36CfY5+B319fXx9fX6FfYV+C319fn19fn19fX59iH4BfYh+Bn19fHx9fYZ8hn2CfIZ9hH4HfX19fn19foV9AX6HfYR+jn0Bfol9jn6HfQF+hX0Dfn19k34BfYZ+hH2IfpR9AX6OfYt+hX8Hfn59fX5+fYp+hH2CfqF9iX4Hf35+fn19fod9gn6KfZx+AX+RfoN/hoABf5V+AX+GfoZ9hH6DfYR8hn2Ffgd/fn5+fX5+iH0EfH18fIR9hn6CfZJ+hn0PfHx8e3x7e3t8fH19fHx9hHwFfXx8fX2EfBB9fXx9fX18fX19fHx7e3x7hXyFewJ8e4Z8A3t8fIR7hXyEewh8e3x8e3x+foR9D3x9fX18fHt7fHx8e3x7fIh7A3p6fIR7AXqFew58fXt8e3x8fX19fH18eoR7AXyEewt8fHx9fXt8fHt8e4R8hn0BfIp9hXyCfQICBACAibOzkY/6nd2Lgb21heWGraernJKixbaDkZ+ftI6HkKCdm5W7zZmKzn+4qbXEraSUl6SXlZSekKCcpP6Hl6KDnrGAnaOUlKidtbOVl4T+gI+HlqK2u86+o7W9s7qsu82mo6W35u/P7sONp7PbroeInsyfsITbiIeLlsCA6t3z2euA1Z27pamysa6qobS2oZSHk52dpZqHgoaDkpmbl52IlYT1ucXu//6FiqGztbnOztnm3eGQ/v7DqNC6wb61uMC1t6ugkoqBkJH7/LiXlJibr8frgYmwvMfGv7i+x7WPoqyp7c7IuY7j45Kax9Hd+Ofq+ujT4oKPhob25c7Av7uyra6AusPr9ubqhoqfoqqmqqWL9o2C+vfG2dz9kZqK//T0/Zv/ioq//rvJl4mVvP/HpMOvioWThfSYp5qrvMO4nYyCk4+YjYfhmLefn5vQ3veFxcmEoaKP4L2Fh8L4gPWC/rPA/fzw9emIgbrlqvSFh4Py6o+jpbSql6WJn7GooZeH/vOAy6HCmpeNmJK8x8bNvIHnqYDxgNzlpICesb6e1ej3tsepx4mH4sjUx5+5vs/02O3y97iJgc2Pt4O57veQsaysudHN6q6nyujt9+rY1Oah+fv3joKDgYOEhIGEhIDUm8Gtlc3MqbHt9OHt95eksp2I+dr6paqjn56zu7+wl5OO+emAh/rh6oD4hYeBhIuHgvvj6Y6Mm7bw8ubH4eTZ3cG2upyOlq+944H884yQx7Pk+Nrp8dG1se+2/pua9YuJgOXf4cDV27yHgZWr0cuRk4+VnpGH+eTNwcfA23uxqYZyl9jOto2Hfnl5fYByaXmSopKBhn5+gX+Yo9OL24mP8+ji1MWA0Nrsxbzbv4Tg89Crfbiqs96Fq6WBwKeXjYybvOuHmbXHz9DS1cmtsaSvxrmyrbOkmv/j/pSSjKSO9M2nl4aY26WNxLmv3NLu7NCt7oGKjYmDk4zspKWmlK+EtZ2ZurPBwNyust76zdGt1/3HvtKyn5CRhZqhkNTNgoTv9I53ccCAfZ6vrMmlsd+rloiUxrGDlpa7/KX0yM6Rj4WE5o+s+ImJqqu97sCghY+qrLnjkOKuybTArOLxu7fIyJzojK2F5968t8GniXx+4KSToqbIhovkhZ6Gy6X4gL+WjsWxue+3ltuxqOaqpvW3kZ+ggcGDh7jv7viR+Z3rw46OgL7fh6SA/qeL7cnkza/Sm5HgxIKuoq/Bt9r7m/H3iY/NxtLXoITKwZqw6ebJj8qEioaM34rbruOnybC4p57Cw+Weh+DnhpCMwZbPsdrgkJ+EhNvm4uyAks2ssuaiwt+A5daFnaqlwcGWkfT7r+Wfmb/J2cyMuZzZleTlzuL+y8rumJuPwNGAfJaVen7aj8J3dp+YdNN2kIuRhH+Hopt0hY6Rn3l2f5GMiYOgroN8x4GzkpyqlYyBhJGEgoOKgIyKkuh4ho1ziptyio+BgZSInpuChXXjcH11go6dorGkjpykmqGWobKPjI6bwMWvyaN3hpe6lXN0hq2Io37cgnR0gKZwyr/Tu8eAsoediY6VlZGRiJidin91gIeHjYh5dXVzf4WFhIl4hHfoub7g5d1yd4iYmZ2uqrfDurxzyM6ikbOjp6SdnqKcn5ePhnx2hIfw87+jnqGhtsrpeoGeo6apn5yio5l8jZCLvrOvnH/O036Dp6qwyL3By769wG10bW/NwrKoq6WclZaAoKPIzsDEb3GChomGi4h40nZt1taywcHYeX5z2s/Q13/XcnCrzZWpd2Nmhr2lhpyUeml5c9eBkIORmZ6Vgndue3d/dnHEe5WEgoCmsMVtp6t0lpGK4bN0dK7caNNv1I+d2NHQ1dB+bqfEmtJ1dHHV0HqIi5aRgYl1g5OLh39449uAr4aSlId1f3WNqrKsqGy1jW/FWrnFimR2f4d2pbe5joF1kl1aoYydkHGHiJixqb68votobKB1j2WIp8luj4+LnKOkwIqBnbW+yMCyr7yJ8M7IcmptamtsbWlrbmqsdo2AcZuggIixv6zBy32JkoNy177bjZCKiYaYnZ6VgHx618mActTEy23WcXJucHV0ctnEzXx3e4fP1cutxsi/wKuhpo6Bi5ynxW7c1Xp6rKPJ2MDN0bico9Sf0359x29uZ7e4t5mvs5xycoaVtK2BgX+BiH135t3QxsvA3ny8sYx4odvMvJiVjIqJj4+Deo6irZ+Tlo2QlpGor9iHv3J3z8bGuqmAtLbKqKXDpnK+zrmef8O4wOiGp6CFybWmm5qqw++BjqGts7OwtKuYn4+aq6GZlpqPiuLO7ouBdI5838KaiXqJwo19saecxLTIyLWPwGRrb2pmcGixhISDdpx9nIaFm5Wen7iVmr3KqbCTssaiobOblImBfZCUhbm6f4Xt/5iCfcyAhKq9utqlps2jkIaTyqd+lo2u+JbLtMmRhnp10H+Z7YB7kpWjxqSYeH2XlprDg9GVqKComcbPrKeusZHag5p839awu8Gri4GA1qCIjoi3bXXPe49ip43LdZxybrKXl5ODcZ+GZ41yfK+GeYuLbqp1YJi/yeGE537MrXt7dazPZICA6Zl217XYr5yygXq4oGyWhpugosDVgcvIbl6HfXx9amaik3yZw9mrfK1scGxyvXy+j86Cs6innZGuv92Uf8vRd4V3soa3lrSUa3dmYrCzyb9ifaN/ial8mahht49WYmNwkpVpWqasdZ1pZ3J9hn5ifWyfcaSnqtTuxMjnjZKMucOAcoF/a2u1iLRsZnh4Z8FqfXV+c294iIFqfoeGkG9sd4KFg3iMlHFtu5G1fYuain54eH90dnR5cnx6hdpweH1oeYdofX12dIN4iIRydmnOZG5qc36Lj5iPfouSipONl59/fnuGoqSTqIlgaH6ef2NicZBynn/lhGBhcZNfqqe3oqaAknaFdnp/fn1/dYKKeHNpc3h3fXpwcG9teH1/f4R1fnbwz8je3tFpb3qHiYyYlqGsqKherbKViaSWnZqRlZWTl46JhX54goP4+t/FvrmzxNPqdniHj5CTiYiLjIhxe353l6SgkXvJy3NzipCMpJyhqKeoq15lYmO9taqjpp6WjYqAj4+qu66qYGNwdXl6fXxuyWxnzMivurzLcHJqzsbFy3HHaGSfp3uTXEZOZJCKdYR/bFtnZsVzgHN7gIV+bmdibGhuaWS1anxubG2HjqVbkZRrkICN96pmZqPFXbtiunCBvLO7wbqAY562lLppZ2TAwW12eH56b3RncHx4c21ozMGAlmtvQ0RVXlRQS15OQDdsQTuGOFNSUUpdZWpheIGHcVtSZU5He2RtZFNlZXGDh5+dnHRQWHtgck9odapbc3BxfoJ+kmxid4qZpKKZm6V33bmvYVxgXFxfYVtaX1qKUWBaV3h4YV+AkIOhs294gHRnwLLHfX98eXiIiIqCcW9txbiAZsGxuWPDZ2hlZmlnZ8e2u3BtZV66wrqis7qzsp6WnId8h5Sgt2XHwm1tnZa1xLO7vqqXmMWMtWxvtGBiXqSjoYKdnoxnZniJpqB6eHp6fXNx4ujl2t3Z64TayZ+KseTVyq+wqaanrqugm6/BxLixs6ixuLDHzO2NrWNmsq2yqJmApJ2sk46wmGGgrp6ThNvT2/aFn5mI3szCuLnH2vd9iJSeoqGdn5aKkoWPn5KKhYyCe9LE4H5wZ4J01ryMfXOAs3xvpZ6UsZ+vs6B6nVBWWlZRVk2FaGZkXIdzi3h5iYOIiJuDh6alkZmEl5+MkJmJhX52c4SKfqGofYDt+qick+iAlr7W1/unnb6djoaQ3aGAkoqg9Yqupcyeem9ovHGI5Xhwf4WQp5SMcXOHh4qleciGmJWZj7S9oZygoojafIt35tOtxsi1mo6M5HNWfWh6QjRURUIxgWmYRXheT0E8VEFXSG9cO15TP4ZbQEJNOVtBSH2Xo59LhF2Sb1BXTXeSRUiAjWJWroyYnJOqd221gVZyVW1xfZO0b7CaZFx+cFdmQiQvOi9SbkhwVnxVNzJGVEd9aG9TXFVzeH1mdZNucrPBYlQ5UFFbUFtiUFQ2ITxMN2E2Tmxod4pqhYRTmmclHhwng4xXRIOJUIBTT1FXYFZNW1V7WoKFnNbt4ev8hpCUuL2FfoN9hX4BfZl+g32QfgF9kn4BfaR+BH19fH2EfgF/pX6GfYx+AX+Ufop9lH6CfYx+hH+Pfol/A35/f4Z+g3+EfgZ/fn9/fn2PfgF9j34BfYh+E39+fn59fX18fX5+fX1+fX59fn6GfQF+hH0Ffn5+fX2OfoR9i3wJfXx8fXx9fHx9hX6HfYJ+jn0Jfn59fX1+fX18h30BfIt9A3t8fYt+jn2FfoN9jH4IfX1+fX19fn2HfoN9hH6RfQV+fX1+fot9CH5+f39+f39/lH6HfQF+nn0Efn5/f4p+A31+f4V+hH2Efoh9lH6DfYV+gn2FfoJ/iH6Cf4eAhX+ifoV9AXyFfYd+AX2Ffg19fn5+fX1+fn59fn59j34BfYx+BH1+fn6JfYZ8A319fIp9hXyGfYd8AXuFfAN7fHuGfAd7e3x8e3x8hnsGfHx7fH18hnsFfHt7fH6GfYN8hHsCfHuEfAR7fHt9hHscenp6e3t6e3t6ent7fHt8e317e3x9fX18fXx8fYV7Bnx7e3x7fIR9CHt7fH18fH18i32IfIV9AgIEAIDzqJT7uLmJqZCMkIqPtb+FmrrE0bTEwbqiv5ipnJrcpKeyr5Oxpb3Gub/K0KutpMXQpZmtq62VmJySi/rvkpeWm5Wmmpeexqy3wL/GkJecip63pqOZl6y1tJ+n19DIu7mtoYafrLzEy7GAneOIyYv8trSrqsO423iRtoKp5fTh/oDi1rmqsLu3sqOjiPXZ4PGCg4iFh46JhPv1+fb6+Pv76tHh/4KKkqKmoK+zyMjPztvf6OuxoKDMfo6Df5OikvH4wKytr8Lp4O7v7vCB4LPwjJCfudLD09O8zreloJ23rpjHzMqzg47W7N/f7Ory3en3gYf4qoDb6+Dw9P7r5+fczYDb6eSHlqKimZ2kqamfl4iBiv/ziOO8ydLh5ejA2M/Z/tPC5rivjLOIkqWvkrfC8M2tkoeRraeqpqGg75mdoq6/nvr1l6efztjEhoKo6vXCsIrCmpH4sILS3O2M+JOVkoCridyHmc6Fgtbvjt/33oybxbmipKahhvX7mZOfvt3Sn4CwrLeSrqzfhZ6lqNTH08nw4MTh7uSjzY7Y3JCH7oOo0rab0tPCztLS5YDkkbOQ0K7DyNDFw8Os3dvtxs3C7OGimcGNzZqKiaG1lamSm7jI/pmjtpHVwLP31MLAwOLtz7y5v5u+scS6rLu01fKGiZihioeeuMKcloilrb23sbuokoDV3uGB8Om8ysjIrMe32/zG4uqa4aCa9una9vr379/qrI+hmLzQ2v6WnqKZh//9h4iXp7W4yNfF8PitvZqR1bbRmJDap7myqaWopKPOspSOr5n0xK+xnJCPx5ueqLJ0g+a0qJqYkY6RtKyLhZiuoYmGfni9vICMjoL695CA07vE+YDgu+q534KBgOevuruNurPWhKedlYbUxa6Tl5i7z+WCmLLR3s7Kz8Skn6CTrJqwsYWIgeKooI6EjK6spvOO2MGdvvzE2eySiIbC+uP1/YiMiYuAh8yW2YfckOP20LXiwbrOtImLuszAqpnO4MGtkqKZt/34qqnI8o7Vw8GHcX57mYC9t6zrgKSl+uTGrain/Jy2v4t7mJP6mtegzc+xvJ/J2fSQgMjVw+L61cjXzbXE9unWo6zM7+jpx9mY2XN2yIShsZv7l9K6hKl4gn7zsL6o+c7D9/Xd3oqhrdWb0Mzf5Yv1t+PX16aHws7hjPKV77SBvcuzkPm6isKb0eHV5rL6l4DYobmHlKCaqYjur6rfuJO6nbHbrv/y/5eHhdP/sZnZlbaRo/fV1r3igIHLgrTDyYaEgMSKxJntvu7rwe/r3ZGSsc7U1Y3HqvCxhYvhvurhlfrR8evNvLPa6rLOrrjG4aum/Iy/7YyLm/ODmsu1loLNrKCF0tfQzpCbs7GF/LNxjIDik3/gqq58mYWCg3x+sbJygZmisJejpKaNpoSSiIjPk5GYlYGYipuinqKlqJKZkK+yjoSXlZmDiImCfOHUg4eHiISQh4SJqpWdp6arfYSJeYufjoyDg5OdmomRubGtn56UiXSHj56nq5lxh71wpnbYm5eSmcLA43qSs32fzNfB1YC/tZ2Plp+dl4uLdtrBxtNxcXZ1eH56c+Db3+Dm3uXn38rS5HF2f4mOi5aWqamvsbm+wMGZo6PRfYR9eoWRh+Xpwa+yssLi2+no5Oh64Lnmg4SRoLGjrq+grZyOioiYlICkr7CceX6wurW1vr/Es7vDZ2zIiWrAx7/LzdPGw8C0qIC1v7xveYSCen+FiIiAf3FtddjRdMass7m+w8eoure40renwqGQa4Vta3yNbIOHtqGRenF8joqNiYOIzYCDhZKchtrYgJCGo6udb3CJvcSglnmvlYrelG67w8tx0Xt8em2Ncr9ykL11crfJesLWxXmDpZmHiouIctXYgHuFm7GtiICUjpVyiHqia4KLi6ylvbLXvpqnvsCPn3Sdr2pwyWVzi5KEnYyHlaCjslqmZ35wpI6ZpKqdmJmIqKm5kKSSq6J6boRsqXlxa3qMdIR1fJex3nZ/imyal47Jp5eQhp+zppWOj3eSjYp/gJeMq8hycn6HdXmJn6WIgHaMkp2bl5yMe4C5wMZv0cikuLCxm7Ggwd2xyMtumoOA1Mm/1dXUz8LMmIWUjKm5xdyAhIiBct/XdXV/jZqiqrOjxsiTsYd9v6aof37Aj5uako6Tj4+zmYN8loXow7e7pZqY16Wor8B8hOi9tKinoJ6fwLiamKe8rpaWioXJqm94eG7S0HltuKSozoC9n8WftWlpacKUnqmKw8LhhZ+Uj4jc0Lugp6TG0+Z/i560wLKssKuRjo+DlYebmXd7ds6TkHt4fJ2Xlcx3wKmLqtutws58c3Gm0rW8xmlua2tjZ512tmu4gtPnx5m8pZqnmnt9maehloqutaKZhZOLpervmpSuzYTaxsqQeouFp4DNwq/wcouK2s26pKCb+KG5v45+hnnXlNuRtqqWo5GyxdV8cbC0r9jmtK60s6K75sS1lJmuzsfMrcCO13R5yHqUopXvkNa4iah7g3/fmKSR7b2vuM+wyICDjbF9paW8p2S9fqeblYBmj5mudM960YFioauZgOKwcY1zssbL063kgoC6j5dveoaAh3HPm5TDnn2ki6G2k93A0Xdtb46hfGehcYFvXb+0x526XWenaYyctXJtaYVxq4PatuHkq9rWy4yZo7XEx3/ApNKfaWuyls3EjfTBycKql5ufqIObc4OFmHp1tmV2m1dYZKlga4NwZlykg3tyvbrFw32Jpa546qp0k4Deg3LOoqdxiHd0bHBysKljboSKmIORkpaEk3uCeHnIjIqMgHWMeYSLhoiHi4GJhZmWfnSDgoZyeX13ctDJdnt4eXV9dnV2kYKIjo6Ub3V4bHiGendycYCJh3uCpZqZjIh/d2d1eYKNkYZkd6BahmW/gHt4j8rV/IWfvoGbt7ijqICcmYR5hYqIg3l7btG2vMVpaGxscnNwbtjU2dze3uPi4NDW32xvdHyBfYaFlZmenaKopaaOur3phoOBgIOKhujq18XKyNDs6vTz6Od58s3dgH2Ei5WLkpeLk4yAfHmBgHKJoaKWd3COl5yVnaOlmpmfU1eob2GwurG3usC3s6+jl4CcpaFcZXBvbHB1eHhxcWhna8nFaryrrrKyubuhrqipvKufsJF6W2xbV2h0WWVqjIV9bWVueXp6dXB2uG1xcX2DdMDCcH11g4mAXmF0mqWIg2+mk5LWgmOttrZhvWxrZmJ1YaRkjLhuaKe2bLPFvGtzi39zeHdyYr/Cb210g5KKdIB9eXtaY1d3U2JiZX19Zml/d3FudltddkFxi0BEgjRHYF5Ra2JibX6DiEJ6Sl5einR3hY2Ac3VugnyJa4dygn5hVWVYlF9dVl9oWWNYYGuXyWNqcVZuZl6PfHVwXmd5aGNYWk1paWJZW2pkh6ZjZG10am18jpJ5dG1+gYqJhYh8boCqsLhkvreZq6ilkamYtMymu71WbnNyxra0wcTGw7fAlH2Lg5+stcVxd3x2aMvGaWpve4eTm6GWq7KLrX1zuJ+VcHe4gZCNhYOGg4GainZyhXzo0s/XwK+s7rq9v9KHjv3N0MbDvLu72My1t8bVxrGwpaPipWNqZ163t2ddoJGYr4CaiKaMmVhYWaSBiZmG1976iZiMiIju5da7wcLf5/R/hpKkq5qZnJmEg4R7h3uLinB1cMaGhm9vdJKJhbVkqpiBosejtLxuZ2aUvZqZolRZVlJNT3dallOWcsnWwIWejYGMhHFxhYuMg32UkomGeImElN3ii4mdsoDk09unlKWbwYDo0L39ZnNxv7qsnJmV97fKzJ6TgWbDjuCCnpSHk4enuMhxaZubnM3Tm5ibn5G21ayjio+ivbe7orOG14mLxHKJlo3ph9q+maiLkIXcWWxTXkJPhWdDjVRma41ralNvcVCRYl0/TWRIT0xZQHVCbGNLboh+X4NLNVdHdnlUnD9eToCCXmtfWmpsbWTLoI69iWN3aXCLf7Kjt2FgVnSMSj5AMU46Kl5EWU9RH0GCSnpjTj1HPlZSh3bRg1tsf6y2tGpdWVBhXlIcH3dLO0Z7Y05oND9Sra+2j4yLkV9/Wk9TU05YllJadkJFSotWV2NUTUiQaWhoqqbEwW57o7Rr1aiFowZ9fn59fX2HfoJ9j34BfZx+gn2vfg5/fn59fn5+fXx8fH19fZF+hH2Ifox9kX6DfYd+jX0Efn19faF+BX9/fn9/jn6OfwN+fn+mfgF9hn6CfY5+hH0Hfn59fX1+fYZ+DH1+fX1+fn19fn19fYl+gn2LfgN9fHuOfId9BXx9fX18iH0Ffn1+fn6VfQF8in2CfIR+mH2UfgR9fX1+jn2EfpF9hX6CfYx+CX1+fn19fX5+fY5+jH2CfpR9AX6EfwR+fn9/iX6Df4V+g32Ffol9lH4BfYl+AX+Ifgh/f39+fn9/f4aACX9/fn9+fn19fZV+gn2Ffox9g3+GfoZ9BX5/fn59iX4Hf39+fn59fYV+gn2LfoR9hH4CfX6HfQR8fHx9h3yFfYR8AX2FfIJ9hHwFe3x7fX2EfAd7e3x8fXx8hHuKfIV7AXyEewd8e3t7fHx8hH0FfH18fHyFexB8fXx8e3t7fH18e3x8e3p6iHsTfHx7e3t8fHp7fXt6e3x8e3t7eoZ7iHwIe3x8fH19fXyGfQF8h30Ffn59fX6EfQICBACA3Mju4PCBjbjCyOjDr42VpI+Ht7K2vra/u6y1hI2CoqGJgoeur4apkv6Lvb+znarO6L+6qZ2mlKSQ6+q/iaORqKKpspiJlJDY6tjfv76nkp+bqJ+/rqG0yMnPuNLZsZ28vd2mjZmHj7HD4MeMzePu/bObupOjv8Jngm98mJm31JKA5rGakpGNlYXo9feQlomImf346remxIX8/vfkz9fo4IKMnp+eqKWvnqenusXO4uXo6ezez6SbucbJsrKwu7qojION6Yahpbi1nJOtmZK0r52/1Ovs5+HTzd3Gq52VsZ2gqLzNwp/C39vV94DtxrzFxNjnh4+C7IOHmZyZ/JWVoJWAlZyitrmrmY6Sm5yagd/9hPXi7u7LorXI3s3t7s/Jwb7RrrG9r5irxJeVlf2erM6si5aenaWRoajyiI+Q9YqjtZr2ydWCnarUpruliJGPkKKijIPTgMmQ6uKN5fCsi4SPlKOnuJjAhofixIKS+5OipaqlkZOmop2TiYubwNfFw+mAsqmdqLWYv/OPhaObv8vOtaPw++mrndDEs5fsxJ64koiJtdSDwISAgYrRvNj7jPb9qvnsyNCDlLHKpqKp1a+XnvmipISLmMKW0qCL55mEgN24pdG28qLl9+b54efe58rpxYHk1NeCgdXz4snxj5Gcqp2Oh5+WnaGUopuGiZG/x6+Akr++yKzA3t33yb3WzM/r5IuWlKCkqIrMqLi0t67Itaqfq7TBs6HBmrCprbmnwMPBvMSegYGlsISfvu2xwZDqvZilpcqDnbW6wbnLxrytit/TrIbHq45xgYGAlbO91NCuurammo+hs7GxoqHM39TvxYuqqqehj4KCmaOwqJmVlJKAk6OW+Mi7urjHu9Ozi9+7yu+KloDsxtmyq5+lqZudv+6Ih6K/tZqwpZ+WiZ6fiv2BmZW6sZiMouLwkM6n+4DA4tfj5v/wjYTz9qPz+oiHgoT46NitgsLTmoyhqZTY2dnjy+O0pdncqJLhtNTCpZ2Wg/eIkYSrm4bKroyEg4SRtpuA+ZWyo8ujroGD5bWciKGA7JO9hsf01NBsb5GFsZmFi6SfxcLv5PTHruCAsMOaw6mJq9C23M/Z3YG4jKjXos2PqriK0uDBpsaZbW5ppoeWvr3x5uDW5P6V/YXOj7OfxMHUtIKJqaCM6I7+noHuk9bGqsCtgu+Agpmsv5KJr5H79JGAn4+4hIqhnuG58uLCxrze2O6OsOn9z4GwhqvLmfqKjPO85NrIn4XAucPCmpiE6KujvLah9r+/5eOQooT4qsfrq66oopqo7PvVt9+395elgKaE4ZTE4PvTiszqrMT6yrqwiKyJiJa0/prFwt/KuLi6us2ZtJuGsOqZheni+KmwpquAzr/cy9Nwe52lq8KlkoCAkH90npefp5+po5Ogd4B1kJJ5c3iUl3WUgOp2n6CYho6vwqSgkYmQgpCB09Sue45+kouTm4R4g326yLjCpKWQgImFkoiilYqaq6uwnLK7mIiioLiOeYJzfJWmvqp3q7zF0paDn36YxtNxi3uHqrDM24SAxpmHf397g3bN19d8gnd2ht7c0K2kuXff4+DOwcfX0HV7h4mEjYyWho2Mm6Spvb/AwsS6spWOo7CvnZ2boqORfnuD436QkqShkYqbjIaem4unsr+/v7iwrb2pkouDloeGi5yopImitLWwymjCpKChoq+6a3BpxGxye4F+13l3gXiAdnyAjpCGe3J1fnx+b77Wb8/Czsy1lqWxwLHHyauqqKG0mJedknuMoHx7cbZrgaJ6aXOAhIZ4hIvUcHh503CCk4LVur5tgoqni5eLdX96eIeEdnDAb6d9zMh2zdOZc3B4eYaJqYGod3TKsG9/3H2KipCMe32Mh4N/d3eDobCloLyAlZGGjJN8m710bJB+mLS/mYO3rLeJd4mXhXPCp32NY09eh5ddkGdqZW2nkKXEcMnXhM3DpbJsdo2ihoaGpol1fM96dmpueKV/rH5vunhnZ7aViqmZqWqYqKC2rLSkoZOqkGOopqhlYpmvrqHGd3qEjoR6dYmAhIl/ioNydn+ip5WAeqirs5mnyMLXsae5s7XWzXl/gIWIjXSvkaOboZeyopWPl6CpnZKshZSNkZyPpKKhn6WIdHKQlnSLntyXnnfPq3yHhqlsgJOWnJOlnpWKb7ezlXzBspV4ioqFnr/M4NOzxMKwpJqsv7u7sa/Y593tsHaPjIaCd2trfYONin15d3WAdYJ5z6mdnpurn7Sgh+bE0fCDjn/z0OS8uKyys6Khw+mBfI+mn4eYkZCEeYqLf+l1iYmhmYh+kMLNd7SQ0nGoxsPHzeHRenPTz4fCxmppZme9saaMa6Gug3eOk4KzsrO7pbmdl7eylYTYnrOqlI6Geex+hXiajHrDspSLj5CbwJOA3X2TiKSEjXBzzKqTiJyA55HAia/SutFwcpB8nIlxdYN+qqzMxNGumbxombePp5R7lrCgv7K6um+ff6Tcp9aGmaWDy9O+qcKdcXJuq4iUr6S31Ku2y9mI2mClgqh+mo2qkmVhf3t5zXjHf3HDe7eehJaQcbhlZX+IlXdxj3XK2XiAgHGRanGEgcOOuryfqqC5t8p3nM7stG6Fbo6jb69VaKh6opiWaXS5pZeQgItwyZSJmZ6MzZWx2+COnHvXj737pq2ck4acy+LEpr2V5YuoWolqsneiscela5u5f4m4kYaEVnVdW3WBtnCUlq+OfoyVnLKFmIJ4qtmGdtbR6Zqfn6iAwrfKvrhgbIeOk6CMfnR5gnNsioGRmZWbmImScHhvgYRyZ2qDhmyDdNppiIaEd3+ZqI6Ifnp/c4B1wsepc3xvfnh9g3VpdW+gq56jjpSAcHlzf3WJfXeAlJGThJeliHeMh5t3aG9jan+Po5FmiJagpHpuhW2R2++Am5GeytDq7XyAqId4cnNxenHDzcZxeG1qec7NxLO1v3LT1tbJwMjVz3FxeXx2fn6Ken9+iJCTpqanqauqpZCHlJ6ilpaTl5eLe3uD7HyIipmYi4aSiICQj4SVm6OfpKCZl6aYhH93hHl1eIKLkXeJk5qWq1ywlYyNiZKbVFpXrl5kam9tv2ppbmiAZWhrdnl1a2Rjbm1vY7DHZ7+6w8GulZ+otKm7tp+dnZWijoyMgGx6g2ZmXJRSbIFgWGZvdndrdHXBY2lpvmBue2++r69hb3WBd4B3Z29saXRwZ2WyZpBwwLtovMCUZWNqZW9roXmcbWe6pGRwyHF7dnx6bm95cG1tZ2pyhJOHhZSAenpzeX1pg5VXTFhZWV9qWV1xYW9hW2V2ZlVsdltnLCUkOmJHcldbUVuAc4GbXKmxYZiXhJNWWnB6aGppf2ddYqteV1dXXIduillSl15QUpN5dIl5fUhkdm6GfIN0bXCAXkNzdmtNS3SCioWmZWt0fHRubHt0dntyeXNmbHSRk4SAbJygp5KdtbHDpJuqp6fEvWxxc3d5f2uhhpmTl4+llo2Dj5SelYmhdoJ+f4mBkZCNi5B8bWmDimx+jc+FhmOcf2d6bpFcanp+gXuGg3x0XZ2einzNya2KoJuQrNbm9ebC19nIurPF1tHSys3v+fH8qmx7dXFsZVtcaWx1c2hjYV+AYWtjq4+IiISRipaNhvbY6PqAh3z95fvTzcTIyLKy1vKBd4aWkH6OhIV+dIKBd91uf4GTiXt1g6q6ZZyCs2CYsa22vMzBbWS7snOjoVVVUlGQh4FtVoaLbGh/gnWXmpiejpyMiKCYhnbKipuRhIB5c910eXCKf3DGvqqjqKm20ZGAw2lzb4Bscl5juZyOiJaA657koKO9qdmCh6F3i31naWtpmpuyrridiqVZhbSSmIdyiJuRq6Wpq2SVear+0PZ7ipV7zNDAr8SohIiDzJyKaD1KTnB6b35Xp0ByUElMcmp3XjU7WFZEOT1PWkRrVXhuYGdjTntPRVltcFVMYlKHmmCAY1RoUWNtap55kqKXs5qcoLBWiYqjglVkWFJmT4tIR2JVfVhAJik9OnNcXWJUklYjOScvW104c30zTE6rb1tWZ1RHQ0tNVkREHkhSUSUhMlJUnm6TqaqKX5KcZWyccmxqPF1ISmdukWJ8hJR1a3qAi6ZzgXFvqM54bcfG3oqMna6FfaN+AX2QfoN9uH4DfXx8iH2JfoN9hX6GfQF+iH2jfgF9p34Bf4d+BH9/f36FfwF+kX8Dfn5/m34BfYx+BX1+fn59hH6DfY9+Cn1+fn59fX59fX2Gfgp9fX1+fn19fn59mX4EfXx9fYZ8BH18fHyGfQF8iH2GfoR9AX6GfQF8i30BfIV9CXx8fH19fH1+foV9AXyMfQZ+fX19fn6FfZV+j32HfpB9k34GfX5+fn19hH6Lf4R+nH0BfpN/in6EfYN+jH2OfgF9in4Ff35+fn+Hfgd/f35+f39/hICFf5N+AX2HfgF9hn6IfYJ+iH+Gfgd9fXx9fn5+hH2PfgR/fn19in4Hf35+fXx8fIR+iX2MfAV7fX19fId9C3x8fHt8e3x8e3x7hHwBfYp8Cnt7fHx9fH18fHyKewF8hHuFfAd9fX59fH19hHyGewN8e3uEfAl7e3t6ent7e3qMewp8e3t7fHx8e3t6hHsLfHx7e3x8e3x8fH2GfIp9hH4LfX1+fn19fX5+fX0CAgQAgKy+wcaDkJ+629PT0cC/sce3nq/ixt3ox+HFvLannJGojZGcosaFkKSmisrApI+bl9HIwODPvqqjnJeV+tjc+sr0jLCzm5ShuMe+vKeotoiToJeFksCgtMDRt7uho5mZofCNidXtwaCP2aW4mpCKyvzLlKOxgofEwmVqa2yBmo6RgK+SrbyjkJmfmJeVkpyakJKOi/flpYmGuveA/YKTo6WosKuimoiRpKqwt8TSz9jF2Nvo7vX9gIKQkPjT1drOtJ6bnq+8xdPQuqm/sqettau85OvY3tvXw8HCuKygusm9sby4z+rp5Puah+mI+tDSvM36gZCcqJiTl5qSmvCYqa6vgKqlsaeimIGQiZeSjoP29PbYxMW5qc/DwrC/3cCopqOon4KG7ZONoqzLtfHz0dTauv36lJaLlJqqkYOFi4OamoeGw8Hf0PWMqbTRrP3p7JyEmp2KhZyknI/l/cy/y9DNhZqgmvz8jdWx8OiOnaWgm6SWo5yinqKlmICGm7m2qqOkgKOgp5efwaiWgraR/oDGz/THsK2qivK/+/TGmcLC5sLTyIOmlpD4g5zqmqKiu/7zzbHp3s6ph4mTutew2/Dy2unEw8uWg4bAye+z6MerrvOe99y2tbmN+KjDu9Pv5Yve3cuIj92zyunt+9P0i4+gs7KpvKSJ74SMrKa4n5mZq7K4gLKPieHBoqafv9TT+r/sidO6u+2IiNbU1uu2wZvm7OPU1YaCup3ngqfDxM+trbq3ub+4kZCQmqKMjsW8xtOTq67juZKAt+zp5NTEutDSw8GzpoiNgbLgt9aVp4LQvnemwdjbwcbK18m/v6PWhbG/vb2+sIqCjZuasbWmm52empmWgISMlIKF+OXt+oP12r+W362y4oD02cughn+AkpOhlrKw0OGSlZehuJWepPWJqKelrrCmoY23t4Crs5+IntDBl4bbzoLq2oevraGYxPPvhv/v+8ir1YjdjI+U7OLH9onhweXelqWRpIfIobH7rJiYx5OgxfzNs6GQz8a8geSDw9TmgPGKjY2q1srs6L6dyNLli6GptsfK263xhJm5sdDN3NvEvLOy2JuIiPW9vImGxbbXw6vR0+nmysPc0qeay9NnkoSnvu/BptvIxo5vxJqUubmdo+nws8P/98iBrdDr6MmTj6XCjcH8m/bO7pfBys2wp++DusGIh4SLtJyA0+vrtJz+gO7/g4abz6WEytjAvcvL5PPkrITEguqzw8yOr5jNwJC9tLXb4K72t8nLjdjvmvKTraaaiuCvu4SzoZWG59KCnJWf3e/6wqe/y9Tj1P/rmozR6K6Ry5ab74ef4pm1qYCQk7SnwtesqamNyqzU+MyI446iyKaQ8Z2Y+KCK6oqGobq3gKe4vL17gY6htK+sr6ismqWeiZe7p7fCrLunoJqQh4WXf3+Giat4hYyQfaqfknyJhLOrpbyypJSNioWD4MbG3bbYfJmch4GLoKyjo5CQnXR9ioJ0fqKJmaSynaCJjYODi856cLLMqJWJypGghoN2ps+qf42Zc4XQ13F2eXuTtZ+jgLuKlqKPfoaMhISDf4WFe316etrQoIyNs9p043V/ioiMkpKQhHZ/jZGSmKGvq7GisrfCxcrPaWt1dMyutbmwnI2LjJqkq7SxpJiknZWYn5mhvcKwurS0pqKjnZGJm6eflJqXp7y7vch7bL9uyauplqLGZnN7gnV0eXh1fMN8hIqKgIWDi4R/emt0bnt2dG7RzNK6qqyolK+tqJqmuqiPjYSMh3J1z3x4hI6imamvmImJfLC2cXx0foGOe290dnB9gnFzra7BtM11h5KolN3OyoNygIBzb4KGgnnK3bWvtri7coKEgdXziL6k1dF6hIqHhIuAioSJhoiJgG5xg5uXkIuLgIuJjYCJoI2CdaeE7Wqzw9C6l4B7XbKXwcGYfpyYrHxrcFt8b3C8ZH7Af4WEk8rBqYy1rp+DcXFzk6yOqbXEqLqhoal2ZGaTlrF7pZyAhr54wq6PioRkn2Bufpuvn2GnpJppbrCRm7bAzq/ReHqHlpaOm4x10nN6loyah4OFkpWcgJR4eMetlZKMrLm53anOe7mlpctzdru3vMukr4nIzcO3vXZxo47QdpGmpKyUlZyYmp+ZfIB+hYp7e6OcpaZzlZK2mnNlk7m1tKmelqSlmJqOhWxxaqXnwt+PmX3RxXqcq7i4qKmtuK6orJe/dJScm5uaj3NtdH99i4+Ff4GCfXp4gGtxeWptzLvGzW3HvKuS4rO333/03tOnjYiKnJuonrqy0M+DhYWNoYaPkuh7k5STn5uPkX2inmuMkIRygKCXf3TCtHLMu3KPi4B/n762ZcS5v5uDpnC5eHh81s+mxG+9o7q3hpODj36/n5nQlIiOv5WdwOWtm5SFyMLEhOR7tLXCgMt2eXeJurfS0K+az9ruhZegqLOvuZjje46nn7ezvbyxpaGbtn9xctCupXt5t5+5qJSytMrFsaq8t5mQwdlqknycutusmNXDx5Z0z6KYwL+Yk9SflKe7yqlde6S2qJ9+gIaTa4urcsKTzIamrKaRe7dpoJp2ZGRokH1qr8W5h3fBgLvPb2l9oYJttMCnqrKvvdWze2mpb9GNjIJkiHegg15/hIWbpoHEnKuiabjcjdZ8g4aBc757pXmTgYNjn5Vrl5OHwMvwtJWwlKi0pLa2knCruo9un250tWhwsV9dcGVrcoNzkZ1+d3NlnJfC5bp1xH6Qp45/3pua6pV92oiKpbWwgKi4vrlwdoKQmpaTmJKZiZGNe4mhlaConKiUjoiBfXuHdXFzdo9veHt/cI+Fg3B5eZuWj6Caj4F9eHV3zri4xKzHan6FdXF4iZOLin5/jGZud3FncYl3g4yUg4V1e3JxdbdqXZSplpKXyYSSdXthfqKLcHWDZ4fk9YKKj5Kx1ba9gNCCfop/cnh+eHd2cnZ3bm9tcMzHq5+pvNFu2m91e3iAhoaJfW94gIOCiI6Yk5mLmJ+pqqyyWlhgZLmeqaqkkYeFiJCWnaChl42WkIqLk5CPqKqYo52clY2PjIJ4go+MfYGAh5mZn6NiXaNgs5mPfYCdU11kZ11aYWNka61mcnZ2gHNwdnJubV9kYmxqaWXCwMOwpqagjqWioJWhq5uGg3l/fG1uwXJvd3yAgYOHdmVnY4eaYmxkcHB7bGVpaGZubmVjn56wqLhpdHyPgcO4tXFlbW5kZHJ1dHC+zKqorauxaXJxb7b1hLGewcBudHp3dHhueHJ0cnNzbmJicISBenl6gHh0d297int0aJlwsEdbYoRjWE5RS4ZnjphvRWJwg1tCPzVLXF6fUmqaaG9ocZeZe2h7dnFmWFxcaHxseoKShJiChI5bTktlbIlacmxbaqZcjnprZV9Mby4yYHeDbUJ7enlTVYRsb4KZqJeza2x4h4V4h3xpwGhqgn6Gd3Z3g4OJgIJtbbeii4uFoq2sy5u+b66cnbpra7Gpqrqbn4Kzt7OmqWlll4a7a4CTkpuJiY+KjI2HcnRzd35ycI6Ji4lcVXCWd1dQc5GTkIuBe4WFfIB3bltaWqH82eqLk4Dj14CWnaSlmJaboZuYm5Gya4KGhYKAdF9cX2poc3VubW1tamZjgFpfZFlYpZ2hq1qoo56M5sTI3Xz35+C2n5qitLC8s8nB3c9+fn+Fln2Fh+F3iIqGk4yDhHaSkF1zdmxhanx0bGSvp2i2qmZ5dGlvh5aQTpuQj3hpgVuZbmhqxL2PoFyii5idd4V2gHO2ooqsgnuDtZufttGShoV8yMXNgOh1o5qogK5gZGVqoqG3uJ+Q4uv2h5GWn6WbqI7deIWZkaKhoqmhlI2Ko29lZLeelG9wp4ygl4ego7evoJejoI+HxP2BpXSYus6ai9HFzqSH+MKy4dycQU5GWnhnX0QrPWt2emVASFRcMDRtOFtTbjxhgXFgUI9UdGdKTEhPb2VakqCIW1SMgH2OX1tkemhdpqKRj5OepbOPXF12QqFqc2tBTlGCcz1PY1Q6Sztje4CLUHx+RmlcQlJBNj8+Sj5KQz1Id3RFOzBzpqVQRklIb15RWHNzPFecqHdRh1lip19gpk87XF1cY3BhanVwXGBbm6HR/b1suXWGjXt11qms44d01JKds7mxhH23foZ9n34DfX5+hn0Efn5+fYh+A318fIl9kX6HfQJ+fZp+hH+ufgR/f35/hn6KfwF+kX+WfgF9hX6JfY9+hX2FfoN9in6HfYR+An18hX2ffgR9fXx9hHwEfX19fo59B35+fX59fX6efQF8hn0BfoZ9A3x/f4R9Bn59fX1+foh9iX4BfY5+i30BfoR9gn6MfQV+fn19fZh+AX2EfpF/CX59fX1+fn59fY5+mn+EfgF/hH6EfQF+j32IfgF9i36KfwV+fn9+foh/AYCHf4R+BX19fn5/iX6CfYV+hX2EfgV9fX1+fYV+hH+GfoN9iH4BfY1+g3+FfgF9jn4KfXx9fX59fX1+foV9jnyLfQN8e3yHewp8fXx9fHx8fX19h3wBfYl8iHsNfH18e3x7fH19fXx8fIV9g3yEewF8hHsFfH19fXyHewl8e3p7e3t6enqKew98e3p6e3x7fHx7fHx7fH2JfIN9hHwDfX59hX6EfYJ+hn0CAgQAgIOYwJfJ3OzP68HF2sHPwM/P0MbU4ub18Mytus7BocPOzK2Ni52R7sGfl9rXrJCYoqS4uOjlqKujqJDClY2H6PzV3YGgk6CzspCpi/2Mn5uipKullpubqZytqK3QwbSjp4XjooqDoY6E0Zm5sfDo2aztldC5zZ9nu7dicG1wbHufgKmihcaOj4iQl5WOjYeK/4qKjqmZ8q6leH6ryIOHkJWjoKOqoaqop6Sov8HIw8fY4ero7/H3jrSoivvUytjO2NnT9vXs7PPS54Ls3PT89Pbw7d2A9PSA9uTE0s3HvqusrLTF34COlp6KhICC++3j2tbc9oCUmq25t62lmJGHoqqvgKCjn6Scl4T5iIqA/vz68ubLua6t4vyD8rulo5KQjYeF6Oinj42Ss4uPzY2cuY3U+YqMno6KjfSWieSQm6GnlZOBmPvjx6brgJe6vZmTgpeNjKOej5mZjKSs84Cuwtue7pSllI56oo7N4vGTnKusrKq4orWonarSvaqskpSIqbKsgKu0uZKEsL6Ci4KBgoXr3c+fmqqSqamKv9ipgo/wy4DOgISRkcaLtYLR6oGlxrTn0tjl4uL2+q/J/9CF3dOIj/Hv+IHdvsq4/uXk3fL82sm8vtT6z9SyqY+L0NX7jsvS4IHsh9K/3tXVwM3g2e7x1tjax4aNkaOlnLy1op2FjaKKgJym5dTbytDIo42RxeDXgZGIiI6AxpOw5+vu7uX7/oPx28G215+YkKO6samoi5uVmYTx8uaqrpiBmOKvjNP1vo2mkMCzx93g6Obq2srY5dfPrvrco3na2pbm4Mu0tK2fprfF0LK/zeP+oqO6saa6ssO/l5qbq5OG4+7q8faOjPnYgKfR942G+tzs1qKhqZP/39La+/7e2t3jr5OOeG94nKimrMfD6OPc0OzivIajqby1zsvD0/GF74yboZ2tvK/XxJaSo7WPg4y3u6CJjuSD/PeJjNm3qJG+lK3qwMHJyeaPq8aMr9SZz7SmjIb4n5nNkcHWwbHQpp+Tj+f1kYeatorsgIK/14H919j0xZ782dzw04Pykqm/3f2MiYL9yKDa2IDYkrf35ZeJ/8S7lq2nyY+r2+bc19Odobfg4b2l/qqqpIjCkaDBt6Kon7G8pKuSlY2yk5G8wM/TgoTyjonPo5fasJym2Yf/srWYsOCC2Nng+eXBhKCNsa7FrZTr8o3045iQgN6Anf/3h/SNx7DMhu6MtISw6ejii8653eufiKf2xsOU1Kjzs46Sl5i5lojxir/dyoySi7WVv9K4ldHrpZiVn6CQ9ITpt/a1y7W0v6783q72j5+lyYTxs/y2052K4erf4sKx4tOour6ZsuPu/riT96e9wKT8i42xn4KLhNq4mHR9gIuhxIurvM23yKSotqizpLS2tqq1vsHIx6qWn66miqqqq5V9fIx/3aWHgbSwk3yGi42dn8XEkJWNkn6rg315zeO+xXOOgIubmXuPd9l4h4WLjJGOgYaGlIiVj5Owp5qLjXPJjXp4j3xzuYKgmtDi4abZhsmywp5wzc5wf3+FgZK5gL+4lsJ+fXd+hYF9enV43Xh3eY+D36ukfoetv3V2fn+MiYuRiJKMjo6Pn6Oopaiyt8DCxsbKcouBbs6zq7Svtbiyz83Fxs2xwGvEt8rOysrBwrRqxsdoyrugrKekoZWRkJmktWhvdntqamZqzMC5sKuyxWZ2eIWMi4WAeHJqgIeJgH+CfoJ+eW3PcHNq0tPVz8awpZuVvdJu0KSTkoB+e3t20dKdVEV3k3V5onJzh22fo25qgnp0eNN8dch3foSJf3xtftjDtpnJa32TmXx8bn51coOCd2x9dYeMwnqascWUznyFe3p3qIu6ydd/hpCTkZGcipuSiJKun46Qe3xxjpSOgI6RlnhwkZpzeHNycm6/s6eGiY5+h4domJ6IbnOtfVOGT1Vnapxrj2myx2uQpJG0qKiwrrDEzI6Xxqhus5lsdL+5xGi3n6WYxruvoau0p5WRlqG/oKeDeF1UlZK0ZpaWnmC0Z6aYtaurmaCxrb/EsLWvpnB3eouMg56Vh4RyeIt2gIWNxLa/tLmzkYGEscO8cX10dXtvrYGdysrSzsvZ13HJu6egv4uFfI2elZGOeIOAgnLP0syTloNuhceUbaXUnWt1c6aSmq6xt7i8sKOstamijM66knri3o/EvbOho5uLjZyorZSmq73RhoSUkYaYkJmbenx9iXVvu8LBycx0cc64gJKux3Bqz7PBs4aNkoH42tLb7vjj4OLotp2ZgXd/o62or8a719PVzuPWvH2UmKafsq2jt9BwyXR8gH6Ik4minHx/ipd5b3WamYNycrRlwMBnZ6SKgnGhg5S7lpimpryAlat5rMSaxLCle23Mj4vFlcfasZKslY2Ghd/zj4OWo4TigH6lwW7Wv77XtJb92uL01YLtjpixxNp2c2/atpC+umy5d5XWx3pt2quohpiaw4SbuL23urmPj6G6vqSW8ayvo4m+gY+nopOZlbPErrWcoJS6m5GSoLycWV6/dXqZen+yg2t+oVfEiIxxhrplq7jE0K2VbHxpiI2YiXW2ynXav390gLRrdsvQbsl0qZKka8Z6l3GPzMOyZJCFn3huZYC8kH5ObYW1hWRpZXKGY2u2bZy/s3p6fZBtqKN2WJuldUxed19Po127lsJ5fGt7gY6rg37FeH+EnmK/fLuHk2pgt8WxsIiIop97lZl6kbjA25p/6o+eoIvgeH+onnh/ds61n3yEgKe0yYGVpbSjp4mWnZWhkKSipJmioKqvrZiLkZuUepiRkYFvbnxxz5V6dJqSgG14e32Mjqukf4N+gnKXeXRuusmxuGZ9cnaEgml7Zr1odHV5eHp2cHR1fnd/enuRioV1eWe3gXVxiW5mqHCJhLTn+6bKecizu6OA4uaAk5ifnK7TgNjRtMtybmtxdnV0cGluyGtpbH1317WslqO9vW9wd3h/fn+DfIKBhISCkJGWk5OXmqKoqamqXmxnXraknaehpaiitbSwsLaho1qvo6m0r7ClqJxZqaxXsKKLk5GSkYuEgoaOl1VaXVxPWFpdtqmklY2SolNcYGVoZ2VjYWBZa3F1gG5ubnFubWO+ZWZfvsTEwrionZSMq75kvpuNiH16dnVxx8efNCNsf2lug1tcY1J2gFtXcGtmab9qZ7Zmb3J2b21ha7+xqJa6X215fGpqYm1iYG1tZ1puaXd5qn2TpbeRvG1v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uKmhmpaYuru4s6ihpZaZnpiioKbYgIGQ69Gvx5HJpMvZ1Z//lJbhiuOgo6WijeWjgdGt+/OIlPir//++qIji37rehJDq1+mDgMval4+HhN6P7b2W75V9etewy+fSg5T29YqJzsrti4mRmMeq4ILYvZGCsryQqnOV3+XQiOGbrYTYmvOhqa+7jnbGhtG/mqOzo4KBmMCwm4CsbGizi4Ky4OX9jIuT/e2bps2bkJPB7v3Oh6nJqJGw06TIqbu/sdqIy4ae1O/eiMGHgOnW99rOs7263bzuxOiZnejZzdnH2Z3R98rRuo3tq4iexoyJgs/iq+nxwuLIweH8+P6KuezXr8n1jNuUsbKtlsPuu4bmm7KC9cLnhYyCqJPqh8jgu4fNio6EzsH6iObIq4Sase6Gxuf5wa/WtaqxkI2coNi12tTXsLzrype5loyMgKet65iTsMtrhX62x7pwa8jGwLGturqsbtifsJSVm3+Tm6t8jXmIeMqteaaYi4HIiJKgr8y8rJiXrpWfpqOIkIV+dXl1dYCWjn/a3IF9gaahmZaPgZF71HOFkJGit7CXmIF5c3aDeoaK2b7K0tZ9tbS65H7PtKSK1Ki6bHd3f4yygM6pmZOZ3YSMfYZ8fYJ7em56go2FeLqhmZmEntHkcnp3gouPl5+XnJWbpZidqLO5uLK6t8HAv7C5rKKmp7TBa2lxdHPTzMtzcXNzdHdzb8XNaL+1xsKxuMCupquNiY+dqbe1yMBvh5aAc8KxsZu0xbOtvsVpZm9xdnp0zLWorsVxgHR3eHpwb2vPz9Zv1M7Ew8ypmaOryMPSvLl3x+Fzd7LDxtq/udPKwbV1fZKfm4+OgIyFh4l/eX19fnl9d5Cgfn1zeN29pZO31YmUk5SHe4Rqu3tudH7VpXd7bKJ/hKy0ob5uaH/coHWBdtaOqLO1pZuclIWJnYius7y4lod7hZGcgIycmYWDf4mMiY+JjJWFa7qsl4LfmaiTkWVsr4tpumWaa2t3YH10iXJtmMGLxMG9cMS+a7igu22lfn2jt6SxzqS8uLCVobhtjJBospdreICDoa6ox2vGu6KVeY6bp8WcdIt8epCYo6eyspyOoJiko8zKoLpyc4zC24OInIjZun6IgIR0f3px1c2xv7Wfn5aShXyMl5uKdrC/rpLB1tXPe4eSe9x0tHNx39aMlYKCdrOacrDEy9DCfIRscHfEsbB8blhOo7Znmp3TpbGyq6ipopuYoaVyq5eKeXSOsZyDmpiLna7KysV0dH16f4GShoaNj3pycWdqatPAt7e7u7Svw7/DgMPJsLm4pau3zcCO332Tg4J5g4Dk2PPt4dK1pKOriouLt+Z5gIieqqORnaOZmZzGyL641tBwcHmIkIZ9fHl7k5CQkIWEiH1+gHmBgoKlYGBssZ6Blm+jjqGio37eg4TcgM2eo6WfftyMaLKW6eZ9luSTztCkln3X07jdgIrm1OaCgLm/fXVycMSH8qyV9ZGAe9630OvBc3vT3HJztbDKdXV4gKSUwnK7qYZ5nKiIp3KAubutfNCbp4LDgMSNoqmzjXrLerSmjZSglnuEn8u+p4u1cm7AjoGfvp+/aHWAx7V8jJpyYG2gsbuobXlzjH+cv5CUg42Vj7NwoWhrtL2zfaRtgLmevKyokJycw6LDo7h/hL+rq8SXqXCRrIiKiXOuiHRjfGNkYJuRgqOYeqSkmaS7r8BuirWviYOyb7VmWFJnXHRza1KcfI5RgnnJdnZghnrAbJankWaqb3FpqZ3NbrqRi2Z1lNByr8nUq5Gwmo+WfXqAg7+qzcXOqbbYvZfAn5WTgK2a1oiDlqZabWKTqaBhW6SppqCgq6qcYr6OmoWEi3WBi5Btemx2ar2pcI2Bdm+ud4CLlamejICDlYKNkI54fHNtZ2lnanGBfXDCw3BucYuIhYF6cXxpvWZ1fHyImpB9hHBpZ2lzbHRzv6ivvcBtqLK023fLvrmf8b3VgpCSmKbNgOHFuK+ozXV6bHNvcHVub2NudHx7crutoqKar9DabHNzeoGFipCJjoeJloqNkpmgnZmdnKWnp56lmJabnaasXl1hZWe9tbFiYGNlYmdjYKuxWKehra+bnqygmJ6HgIaNlp+dq6JaZWxiZKucn42cq5+Vm6FST1VaXl5gsJySma1igGRnaWxmZGG+vcJkxL62uLygk5iet7TAq6N0ytducLS/v824qsHCuLFtcXmCfnp5cHp4c3Rva29ubmpua3uFbnFoacGtoJOwwnd7eH9zanJanl9YX2m+omVqWYVeXpummK9fWoHpoGpza8V7iZCUi4ODfXN2hHOSlaCcg3dscHeBgHZ9eWxsa3R1cXRzd3pvXqmgkXirZHhrYExShWJLe0pxNy9MSWdicWJcfqF5qpiVVYaI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+vKjlY/R2YC24aCQideGwLLrqZCX39Xkxbh7p9zPya2fure96OrT8NDKuLqtssOyx+Li+cWq5bT+rJPh17ecv5CixZv8gLymiN3e1tnOn4rsuHGzeqO7vbmzt6CQrLSvg5mEq7mhkYisiYHnh86GisXw/bmZxvuAroSrvMnO+f3j4ZvO27aN5YCUhdnO5cy6ps66qLqr69KG1cbakvClpJuds/OAipnH0aGukK7FlbOO0r+/6Zj4i4e7hsHs2/ukl9WTudDYuJbZ1/qL0oWq1Iub9MnIiJDSmd3177rWvKC+rquuj5eJrcHam4CkoZ3DgZrihqywkuWVopSA+5HKhIh4ya1xiY7BtoCt5YeYmLiun5Vvd2xvvcS6qa6Hk5KhsrPH2M6og5+kno6CeIego4Lqf9W/mZSEnYiTk5a8wKunraXJusGipZysnniDhpeMgoOZmoeDmpGMhZOPj4qGfMuFqYiDgpiBk36Jcn91e42SfHN7fIfJ2IZ7v9+pnauegq7bvstrh4aPk4C0rZGDeoam0s/K2tDPf32BnKWNjIKAgXKGgs6bruCCfn1/hYqWm6Gmr52io6Kkpqi1sqy5ua+0sJ6lp7u3xbvIwLm+uMHPbmxwbXRwz9DKzMPCvbW4kJyglYGCgHqGppyRnrZqd5iVZ2qhipaxr66ToK2wwLLGwbPGr6SSffrr5ICJk5y8urO8z8jJzcCpx82wo6Ktv87K0baXgcnTxKJ3tcO1xNDAvIPPu7Xfd4CNn5KKgX+IhYaag4t/d32GhnyDeXnIvsHklHWTmpepn4LJy9PD0aCwjZzzfXzNba7FiLx/g5mhoqGTm6mro2dpza6gnpOUopyNl6CEh6Wpt7mMgoCQjp2Cb9qDl3WOdXFubc22oJGP0duNjIRsdou9aL2lt5y9oJdbkr1ioYN9eI2ny7m+oaSWsq5tyaesu8i5tb+rsLiYqqywvclvbqiiinF4h5KrqYSJcGe1yJtrZ6ykomFkcb/AubChoLtvdIWPi5SVhZOenqScn6iZnK2vpLCutoCcl6Wlm4qGtmrObcub0obejbPTw6Skv9ZxeXh8hI2mppmisrCV4Xx7jZyvnbXM1ca+tJemsLGtrcGVdayhm52DtYV2kGbDgIqem5qPi3uCc3SEgXzKj3l6mox1h4HfmdB2dnR1aW7QcG1qdXx9fnd2za61vKu4sqysopu6uqi4sYCtusG6naKmqKWYjZqDlZiAi5OChN68w5SJb3Jwc4F8paC3e4S1mY6ywcG0u8a/vm5w0HV6hIyOjoh5hpWSj4mBenyCmY+RiXGmwGp+qry2p6uafo5xp9Zrno+Le62k13+Yp7Kug7vI0MCsv4132JWzt7SCmOrk3O2E9fKnm5TR14Cnw390b7x9sqHSnomS5dvty759oMexspyTpaSmx8O30LSxqayen66ers7D1rCd2ZzUmpDf0a+KqnCAro3nc6CYf73Bvr21lH/gvHa+ha7MzsrDw6mWsbieamp7pZ+JdnCJamKqZLRmcJWws5R+sOpvlGWJjpWj0bSTemKXpYRqsYB9baemvq6ci6CSiZuOybJrtKa3c7+PeVRyeL5gan6ho2yCZXeCWIFTgYGStIDCcWCHepewusxyV51mf5Oia1utoKhmnWOFr2h92ad/V26oeaq7u5WokHmImIV+W29miZa2iniem5e6dIXHeJOXfM+EjH1y44G9hIl7zrl6kpS7qoCv4ICFf5qTioRWYFtfpKabmKB4iYuXpKCmuLGVdYyNinxwbHmHg3DNcca7f3tzhXaCg4SgopCLk4qmnaKOjYaThmlwcH52cXGChHNzgXp6c3t6eXh0bbR0j3JycIN0gXJ7ZnBqbHh/al5nZ3W1xXpwsdKViJKNerP11fOGpaGpq4DKxq+gk5ywyMHBzcjBb25vgo14e3Nyc2Zzdc6pvdZ6d3l5foGNj5KUnIiIh4uPkZKbm5ahpJmdmo2TnKyptLC0saqspK+6YF5iYmVjt7eusKimqaWoiYuUjXt6enR6mJGIjpxVXW5rVFySeIWbmZyIj5KUnpKjopSmmZeGevTp6YB+iY+mqqitu7S2ubCetrWimpqirru2uaOJesLIwKqLt7u1wcm7uo/Gt7TQbHB4hHx2b21zdnR/cXVua21zcm52bGq0rK36mWp8f4GShm2rrbWouaajWo/oUlZUNWXGi7JzdomOiomBiZGPilNSoY+Khn59hoJ7hIt3fZGUnJtzbYB5d4FtX8JveWByZGFgYLakmJSW6eqDcExCP1eTT4yCiXyWe2lDd5pTg2hjZHeQrJSFeH1rgoZYmoOOl6OSj5eNlZuElZeapa5eVYaCbldTYFt0fF5oUkp8iGpPTIaAe0dIWo6Lh4V2dIlVW2tzdHp4b3iCiJCJiI19hZWVjpWVnYCCgI+Ph3l2nGS1XrB8qnvOhaXCt5qZsMBka25wdnySlIqMmpeDzXBsf4qYh52rt6qknYqSm5qYlaV/WI5zfIRqYWlZbEmXa3WCg4F5eWtuZGNwb2qtfGZmgHtrdnXKgrBkZWJhWVyyX11aXmZoaWVirJqeoJaglZeaj4yhopegmoCTnaCWhoyLjouCe4Ryg4N3gIV5edLAxKGYhoeJiZOOrKK4dn2liYSmsK+lpbCpqWFgt2RmcHR2c2xkcnp4c25sZmhufHZ2cF6QolpniY+GfX90YWpZhsRhfXZza4uJx3GEjZCtd5mor6GYpHttzYednJl3hdff2Np97+W0rKbZ3oCasGphXqd4opW+lIiS8O/749WBl7Sfo5OMm5ubtrKnuqamoqOWk6CQmrmquqOV2Iy0iJTr3618lFdjmIDXa4+Mea2xraaiiHnZvoXppdv5+fTq8MyuydWeVUIqQF5kWFNlRUBtNE4yS2mGlWNJU2pEWUJiZGNugXp3VFZmYExNgoBqZYR7jJuLgX15dZyMqJxNhn+aWI84MThQUX1GQDglOxwtQlhUIzFHbmOAfVWzUywzJmBeLm1XIkUuLWRzTERFQnlLflJoVi8oTmk8NFGPZIydpIaXjGlyinVjP1VRcoOkiYysp6S9a3W+b4OBbL13fG1n1HS0jJeN8uiVpqG1p4J9h36Ef5p+BH1+fX2rfgF9lX4GfX1+fn19hX4EfXx8fJJ9jX6Efah+hn+XfoZ/lH6DfZp+kX2XfgV9fX18fYd+iH0KfHt9fXx9fHx9fYt+gn+YfgF9iH6FfYJ8h30Bfod9BH59fX6OfQF+kX2Cfol9hH4LfX19fn59fX1+fn6HfZ5+BH1+fX6EfQF8iH2NfgF9lX4GfX1+fn59hX6Of4l+A31+foZ/AX6Jf6R+jn2NfgN/f36Wf4J+i38Cfn2HfgF9hH4BfYl+AX2GfoR9AX6HfQV+fn9/f4h+hX2cfg99fn5+fXx8fX5+f39+fn2LfoN9jXwFfX19fHyGfQd8fXx9fXx7hHwEe3x8fYR8BXt8fXx9hHyQewF8hXuEfAR9e319hXwMfX59fX1+fX17e3t6hHwLe3x8e3x9fHx8fXyEewh6e3p7fHx9fYR8Ant6h3uEfAJ9fot9A35+fYR+AX2EfgJ9foR9gnyFfQICBACAkbDHxai6gITMmaGX3ZKHgc2YnKObhpy339j9uaWrrvHIr8vh2ru18qCf8InPpMLXrsLAybrh5u3X3svI2tPbx8yxnqvBw6Kkv7eE9pO0sMXPoqKEnZqXiZqfi6q9mY6dsZj+h/TJ0NbgxXJ0dHiXotnU7rCLaoCIbG6uqrVlcXGAc3pns2NnaXzFhJijqMXPrLS8s7ilpbCokfOmjNexqu/sjqmztsvPyMTCx9HGw8zNz8nJzNbX3+Lw6dvS2tfi5+HQzsrT9vLRx+L04uTb193s7dvHoIGPl5ebmY6Xt9ObusyDi6rcq4mM/OLNzsnVtLjQzs7V0MS5ppiOz76orJOAiJict9jqsojU3fPltYmJ/enV8ZO7pvrbxK6TiHFng5fb0M6ftq2234rPx+yKjompiKOorI2eo5v6kZiMjfyMn4mIhZrIwvaBlrCmnpjSq66b4qTInIvjjZ+YjoOq25vFosfY2tavrsiCw//8gdzW5cu7raC9na6suf2VlJup4c+ArJujnY694ICVg/nd+oqUl4PCv4T8o52ZuZCOh46Midnno6CI9Jzs4NWR+Oni/9nK5e/P79jXhtH4hIa33+7V6/bx8OzT2uuMivyOhMzD5OO89rG3z+y91ebe4/yI9IyC293cgJGyt8P6+sCbr5Sr3d3etre2taKjr7ulqrm9wsOAz8ra4Nvk7Nvl4/Hnx7eym6md/NiHo7rHp8/B0ezEka/Q19b60bLo94OHjYr/i4yJj/b894+PhYn++de/2dn8jZmbl/T/hYiLjKSwrKq1o5mCh/ODjpmXlYyYkpiSl66zrKyni/PohObP9IqB8Mu/oo6Jjfqxh9C0uby0pauqjZ2AmKrH5dvK19zh97+diYiWiYHs5LCjs42urbWGcXmDeJPyhtiD856mwdr49PDk6vrz+o6aq66wpZ2brazpg5uSjajesJr33MH1g5yI2fuDhv20uamPx5PdgPLwhfSevryH05vn9MHv0rDAy8yvqsjTsruR/Yeg4YaZk4Gklou8lbaA+Y+M/ITMrqTx0tizvJXWhay/f7C0w5GDmrKyopiikaedntz7/J/F0+LUrK+M6PyXpJK1h873lIHf7bbNu87iy6XSsY3ZzaDlkJfVu6+7pKWaiby9lm2DnpadtKvYjLaroYefnJ3BsYiDhoOthKCjm/rFzs+Sw4fc++eV1eO37fuAu5+V/fHT5MKtlaPNjo2IzojB1v6yu6aJmP+ygsm3n5rW55KuuIrQ+5yLy8u6sry/poGNoqmi9ouDq8TnmcGVt//k28WL+c6gtdvD8oOZprXRy9Xo16DygaeHkOqHkI6hq579jYKm7pKck6ybmYuN+JaSkLDHfmxoaqLa0pOIh+iAjJ+rpYicaG+ueoR/vnZubKmBh46HfImdvbvVnJGWksKllqy4tpqY3o2I2XmwjKa3lKWiq53Aw8e1vaupurS6qq2Wh5KnpIuNoZxw03yZl6ewiot0ioWCdoaIeI+lhXuIl4Xjd9y3u73JtXV/foCbo9jT5LCUdo+ceHrAxNJ4g4aAiIx3zXF3doe1dIKKjaKpjZSak5eIipePfN6SfcusqebZf5GYmKeqpKGgpKikn6Wlq6ioq7GyubzFwba0uba/xLyvrKu00ciwqsHLvcO+t7vDw7qsjneDhYeHh3+HnrOJn6xscIaog2100LiuraiwmZurq6ywrqWnlImBzb+ytI6AgIiQm7S/oILR2ObXrX5/79nO5IWikMbJwbCck3lthJTPzcearKSqxHfCvtV6eHiQdomKjneDiYTXeIFydNBzhXJwboK0yehqeIuEg3ywkZeR247FmWuze4qRiX6izImkjaq1tbCTpLx2pdTKaLOxvqmbkIadhZORnuSCe4KMtqaAi4GIhnuhxHB8btq+2nZ+gnCtsIHukYuDlnV2amhqZK+uf3xkt3iwp6VxtKalxaunvMesyLK0cLDAaXGZtb+vwczQysquuMh1dNB2a6OUqKWEp4WLn7SgrLmwssRvxnFnr7GsaXiTmqPNyKSFk32Os7K3l5qZmIuIkJ2KjZidn6GArai1uLO5v7G8usW+pJmVhZGF28F4i5qjibG0yOe1gZautLTLrZbAyWttcW/Mbm9tcsfMyHNwam/Kya+frqrGbnl6ecXOa3Fzc4WPjIqThn9qb8Vrc3t6d3F8dnh0eo2SiYqHc8nCbsWswnBpyKiihnx3ed2le7qaoKGcjpGRe4eAf4qnv7WpsLa6yqCHd3qGfHXY1K6nu5Gxsr+OeYGLepPofc164ZGSqLvTzszBxNTJznR6iIyQhH94iIvHbHt1doepjn7UuKvdc4NupLVeY76JjIFwonrFb7u3Zb94nqFssozX56HArJmnq6+dlKq0m6J/6H6P1H2PiX2onZK/jaiA1nx00Wy2oJbOvMWnv53ghLLHgqytr4h/kp2elouVh5eIjNDt65Cxu8a7n56F4/aVk4Otf7nVd2+8yJ6torTDtZq9pofBuJLZkZzayL/Ktresk8vQoXSIppuit63IfqCRj2x7jYGjfXVxbWCLeoCGgd+vtqN1k1iJqKRsiaB4pM2Ah3ZTt66OinyHenudc3RvqXGfuNKPinJqdMV4W6GVeXW8wn2KkGqevG9hlX+CcpeRgG1pcJN2u1lTeoGPYIVgdMe6soRw0qKCj56iuF1qZYiapqannnvEZYBjbaxlcnGDjYPhiIGf3oSKg5WIg3t734CCg6i+fnJwcaXW1I+BgOWAhJWckHCGVFqTX2hnqWVhXpN1e4J7dX+Oo6i7h32GfJyOhpSZlIOBy3p2xWuTeY+Wg5CPkISgoKWXno6NmZmfj5F+dHeKh3l2hoRju2yBfo6aenpoeXZvZHFzanyReHF6hnrUbMqqq6WyqYSamJirq93T3LOhjaq1jo/a6f+QlqCApKmS/omRj52xZ3B3eImPdn2Be350dYJ6bMqAcsaxt+HUeIWOi5Sal5KRkpGOiZCNk5WUlZyfpKWqqqemq6qwt6+jnp+mvbainrC4r66vpqmsr6qkjn1+gYF/f3t9j6GCjZZXXGV1ZFxiuaKamZCahoaTk5GOk42ViX15183LyoOAd35/iJWejYHi6PDfuIGD9t7W7Iebh73UzsS4rZOFlKDJysikr6qrvnG+vcpwbW1+a3p3d2hyc3K/aWxiY7VldGVgYW2r6/VcaHVwbmR3aIiDm2vSjSl3XHF1e3ejx36MfJWdmJN8mrJqkLGiVZKQl4h+eXOCc4B9iNN2bnR7l4iAcWpyc2eRr2JoX7+pxWhsb2KgpoX3iIN0dlhdUk1TS4iJZWFPlGCPioFckoqHnY2AmaePooyNWoiVUF1/lZuSpa6zrK6XorJoZLRjW4J3g3pfdGJpeoR5gX97fZBPjU9KfXl5UV1ye4qpp5F3gXJ6lpOZg4eIhX54fot7foSJi4uAlpGaoZyeo5egnqmhkIKAd392ybNrfomPeaShxtqoc4OUmo6mkYChqllcX2CsWl9cX6yuqGJeWV2srJmKmZCfVmJlZ6msW2FiYG14dnZ7dmxcXalaYWhmY11mYmVhZnV7dXRzZKmlXqiSoV9drJeMd3Fub8ieg7iOkZWNf4WBb3eAb3eRoJiQkZuenoRzam14cm3Hxa2rwJu4uMmjkZmgi57mdMV12IeGn6zEt7Wtr7+tsmNlcXd5bGlfbW+tXWNgZW+CdWy8pZ3LZ3Vbf4pHSoxqa2NVgmm1ZZCNTpZZhYpYm33E1IyakIaOlJiNhJeciopy2HV+zXeDfHi7uKrPip2AwW1jt1yllom4qLOe07rogsXjhqKln4N+jZeWj4WNgoyAg9Pw7YyqrreulZSC7PidhHaod6S7Z2Cep4iTj52sppGwm3+to4XRmpvs7+n33+HWtvn8wYyixbW+1L26aHpic1xqQ09XQUJNVFFNMjVRSHNOTmVTa02Caz1MaF0/d5eAc2U7io1vaWJtYmh6W2RWhlmNmax9fFlVVWUzMmxKRSwyQURRQ053mF9Sa19qYW0wKzEzGi0xQSMlGzRYPl8zOi8xIzsmRTUdOlE5MSVTU3SDkZJ+fGi0V2ZMXIxZZGVze3jTmZap3H2BfIh6dnFx0nJ0da29kIqHiLLY1Id5fOSGfgp/f35/f39+f39/l34EfX5+faB+AX2WfgJ9fpZ9g3yGfQF8hX2QfgN9fn6FfcF+h3+SfoR9iX6FfYJ+hH2DfpJ9BH59fX2MfgF9hH4BfYZ+A318fIZ+hH0NfH18fH18fHt7fH19fYh+gn2EfgF/jH4BfYt+CH19fn5+fX19hH4EfX19fIR9hn4HfX1+fn59foR9g3yJfQV+fX1+fox9BX5+fX5+kH0Hfn1+fn19fa9+gn2FfgV9fXx8fYp+hH8BfoR/g36Ef4d+hH+Cfo1/AX6Rfwh+fn9+fn5/f4d+hH2afpB9BH59fn2Mfop/AX6Ifwt+fn59fn5/f3+AgIV/EH5+fX5+fn9+f35+f35+fX2OfgR9fn59hH6EfQd+fn5/f35/h34GfX19fn19kH6DfYh+C319fX5+fX5+fn9/j36DfZN8Bn18fHx9fYd8AX2FfAF7hXwNfn58fH18fH18e3t7fIl7BXx8fHt8hXsBfYV8Dnt8fX18fH19fHx7e319hHuFfAR9fHx8hX0DfHt9hXwFfXx8fX2EfIZ7CXx8fHt8fH19fYZ+hX2IfgR9fn5+iX0Efn5+fQICBACAy43N0tL69Nrcm5r0yuyCwsTExNj2sKKw0NzgwK6GmK/Aw7WwxMfPxKPGqu63mdLDx7/MwLTg7fTVtunkztHU39LEwOWvvbnFwaCdoKSon8e6sZmTlaGOkaSknZynoJfEtJGGgfjKjpjQcHV4aqa1uXWEgXVourFna7u9sZegW2uAenFptWFfanBtmfi31trS1cOrqLGztbjG0LamqqqrjfKFi5e1sLOot7q1trPBvrzMwbvCvcTC0NHO08/TzdfW2e+AjIaA/Obr3er459ja2OXfxMqVopywuLS2p62947uozeONhZ3xrJCB6s6/xtn/+OXPoPKbf3l4c3V7dnWWwNOArveQpa/i07nalJCHg4KHkpWQg3p8enR2d3F4jqHO8dXazKep6PDH+vDZ1cy76Iael3jFq6unl52uwJKB3c2IrJ3Y3r7S/d3298TDsaqqjK+2xoz4lbaQmZLEj4qAgqWdo7W10/OHg66ghNH9ytrayLWVnqu+ppuamZehoaT9iP+AqYOH2PGesKnr/ouRjoiklOrh2YGp0vr+5JirqZObn42YkY7xyd235cucoryt6tG8vtm5yay93+aNgpqilYuK/o+S9JSD3+Hi7uiEopybho+HlYKCk5WdqKKata7Px7CvzN/o3dfK0trttLTI3ejc8+HFnZahk5jDz+iHg5+oxdeA07iqssDU59fCs73U0+f/9vzXz9Pg1+zwzNzE0b7D5/HU3sDAu7jIwdXHmJqbvcu+oqO/yMHPydW/hOzd8ZidzPmKhfGAjIqLj5KSnJmSnKKos6Sdk6CnuKSgl5yjrrakmaaQoJDW5/GUvsC+saezqqiPiZmRjPCGiaiZirKslfmArci7rLG+rMCgpL/LrYXWs8aEkero7tzX0c2xe8hkdo3DjJKU2rK9yOLb6+uTmYL8hpullZeHju7o7paVlKCRpoblscu/38jm4LHv/YeKjoC3vauno8G0qr2xk+iJp+ClrMTG87qR2ae6tKqRpZ6pgrSH/O3X1Yqcs4Kffoueg72A3c+C84XxhfiIzLaCwJGgwZC/g6HSgoDh0pGGi7F1rtCRruX41MPfk7DI5dnC+rmV4/H15O7hr9y06eD7gtDSs77Uhuugn42sksOSuLW0YWRfprSPiYeHh6Wsp56c3Kqg0c+6pvfcy9qthurwgp2E6biknKm65Zf5pY2Up/63n+aAod2p2tuowoHz9q7p9N3ZyKyLzY6Y49rur6GV6aLvi7OD2buZgaCM+quij5ni25mW+ua2x6Pmhb+CqujvsomMmtTKgoOciIuxitCUzpualq7ElJOr18rdlcngi4yo3MyJhIX+hfOIp7mI4pCVjJLqvq91Z296e6nPnKW9npStk+KAwIzPx7PLyLa2gYHRscduqKWoqbjNm4qYsLu4n5J2hpObnpiTpqaspYuhjc2bgbKlqKSto5i9xc2ymcK/rbGzvbKmob+ToJ2mo4mGi46QiauimISBgYp4fI2PhYeQjISpm392c9y4iZjadnqBc7PIzYaYkoN10Ml2etPXw67Abn6Ai4J1znFyeYJ3nN+br62rrqGOio+SmZujp5WLkZCPfeF3e4KZlpiQmZqamZSfmpmpoZyjoKSjrrGtsq6xrbW1uMlpcWtoz8DFucPQw7i+tsG7rLCGkIucnJqglJqjwKKUrrtybX62hXRpwbGmp7PQzbyzjeeijoqHg4aLhYOlxtKAsumFkZi7sJ/WoJ2Sjo2Un6Sdj4iJh4CCgnqAkqDB08TJvqOhztu44dLEx8iy1XGHkXu5k4+NfYOPmn1vwbJukIa4vKfO8rnG2K6omZubg6m9v5TuiZuImIazfXhwc5CEiZaZrsNtbJSMdqvIo7Owo5Z7go6ciYWCgYOMiIjYdt+Ajm5wuM6KmJXK2HV5d3GEecDAvHmcs9TVv3iJhnZ9gXJ7d3PHq7SNrKF6eI6Nuq6goLeaqZKhtr5yaX+IfnR213d+0X1tvL7Bx8lvhYKDbXVodmlnc3WAh4J9k46roJKSqbO7tbGlqa/Al5SlucC2xLWihoCJfIGfortyc4iMpLGArZyRlaSxwLOjlp6vrsDQxc2uqrC8tsHGq72itaOmvcOwuZ+gnJujnq6mgoODnqihjYufp6Gspq6dcNXK3n+BpcZtasRqcG5wdHV0fXt2foGFj4SAd4GHk4OBeX2BjpCCeoN2gni2vsiBmaGkmpKbk5R8d4R/ftR0d5SHd5aSgdaAkaahkJOelJ+GiKKrlXrLssF6g9vg4tbQ0M61gtNtgI67goiCwKKlrcS7y8R7gW/Uc36GeXpwdsjFxHx4eH53g23FpbityLHKwYq0uV9iZV6HjoF+foqCfYh/bbdtlLqSmqar5p9ytZGgnJiCk4+Vd6F98erR0YGPon+ihJGSf62Aw7NvzXDNc95yt6yDypmsyJfNhqPUgoLi0Yt/hbZ4qseFmtjxzsDRi6CxxcCt9LaGv9HPvca/nNGsw8LWcay1oau2ftuTkIKdh8SWw8LHam1ptciel5KSjay2rqKd3Z2RvcOtn+HOsrmMar3DY4By2rV/fYWTlVGdh3Nrc56CW46Aco08VmJMYEeUk4O9vbWyqpBtoXJ/opemfoF3s4OaWGpnsJB5YXNgtoF4TFSJknp4x618j32mXIFUbpSKX1pXWH14UlWGeIWOfKVsrXFzanSIVWd1j5ate6O9b3KCqKZycXbmett5kZ980oKCfILWtq92a3R9f6TEkJ6ylI2fitmAx53ww5auqpuVa2+zoq5fmo+RkZusi3yKm5+ZiX5pc32Eh4N/iYuPi3iGcbeDb5SMjoyUi4GWpKySgZuekZOVn5GGhpp6hYGIhnZzdXd5dpGIgnRxc3dpa3l6cXWAfXaTinVta8u3j637joyYitz2/aa2rpuM+vuRkP7+3MrlhpaAn52N/4yOkp6OrtiGk5KQkId4c3V2g4aGh3lye397b9Jwd3aHhoyGi4yOi4OJh4iUjoqPio+RmqGdoZ2jnqeqrLleY2BbuLC0p6+8tKuvpq+qoKaEi4aPkJGQjY6Sq5qJmJ5dXWOBaWNer5+ak5iwtaKch+u7rKqppaStpKC+2NmAv+R+foafk4PUtrSspqStusC2qqenopybmZGXpae9vrW4s6ijw8u01Ma6wb+tymdxloi2fnt4bGx4fGtjrqJefnaoqJrk/qSrtJaLfoBzbZt4UTOIa3eXp32pb21la4B1e4WJlp9XV4B7bpOchZSPhHtmanJ9cHN0cnV6dHLDaciAdFRZm6l+iYy0wGVnaGRvZ6irpnmXpri7omRwbmJqbGBnY12jio1lgn5bW2ltlo2Jj5mGjH2ElZ5bVGZyamVov2druWtcoKaqsLVic3BxXmRUYFNQVlViZF5bcW2Ed3R1h42UkpGKi42dh4GNnaKXnpCKdHF6b3SYkKZnaXd7kJaAlouEhJSgq5+Tho6dm6u3q7CYmZ6moKOplqOToZOUoqWaoY2MiIyPi5eTd3p1j5WOf3qMl5Kbk5mMaMbCzHNziKhbWadZYV1hZGNgZmdjam5weHFsZ25yfHBtZ2ZocnhrZGxjamWao6NthI6UjIeNgoFva3V1ccZsb4Z6boN/cceAe42GfH2KgoZ2d46Qgm+8sbdwd9DY1s/K0NPEl/2BkJvCfXx7spibnrGquLRtcF69ZG5zaWdhY7Ctp2hkZGlkbFuxnK6huKG3p3KNjEVISENkamNeX2ZgX2ZfVZlVgJt/iJKT04pXkn2JiYd4gX+Fboxy493L0HqHlXixnKaKfaKAsqFhtWK3Z8NgqKKE27bK3q/ri6DriYTs2oZ8fsORuMZ6jtXs18fShZGgraab8Lp8pLazo6yojc+yta28YZCkl6CkedmMh3eLfcih6/L0hYeA4vnEt6yurNDazLm28ZWGtLqgeYxfbGxgTJGfQ1ZHd0YuLUdcWTtoSElAYoRRSG6AXmMhNDwzQDFnbmR/fYmdl3lfgFltbXuIVT80a09vRz42XmJNSlZBgm1cMT1mbVhgjHZRPEFlNVYxNVhRPyEsOUAoHiwkFA0jF0I2U0NNVV1xQVVaa3yedpWtZGhwkIliZ3Dic9V2ho5yznt5dXnOur2Ig4iOkanBgZCeiYWQgdcEfX18fYV+Bn9/fn5+f5x+AX24fgV9fX18fIR9g3yFfQR8fH19hXyFfQF8h32UfgF9oX6Ef51+h3+Kfo99hn6mfQV+fn19fYl+Cn19fn5+fX19fHyJfQR8fHx9hXyCfYt+gn+WfgZ9fn1+fn6HfYZ+iX2KfpV9h34GfX5+fX5+hX2tfoN9wH6DfYR+A39/fqF/kX4BfYh+AX2OfgV9fX1+fol9AXyEfYt+BH9/f36Hf4N+h3+IfoN/hICLfwJ+f4Z+A31+f4x+hH2EfoN9hX4Kf35/fn9+f35+foZ9Cn5+fX5+fX1+fn6EfYJ+hX2GfoJ9iH6FfYd+AX2Ffgh9fXx8fH19fY18gn2EfIV7CHx7e318fHt7hXwCfXyHfQR8fHx9hXyIewd8fHt8e3x9hnwEfX59fYZ8CHt7e3x7e3t8hHsFfHx8fn2FfIx9gnyGe4Z8g32IfgN9fn2EfgF9hH6KfYd+AX0CAgQAgMaph3S9yOPq94yThYGeh7S4web8hMbJ9ODV/czf5KetxZ3KtMyA/fXGwPTOnKfL5Om4x+bU4/Hr7NbS+t7k/uLT1ce7oamuwM7ApZSiqLCqys3M0MjbxMPU5tixp62qoM3FuKmqp5SC6OiD1ZPVjpG3YGt0enZ6eH50aGm7rKSpgFxfYLy4Y7Kgt3J1n/KUqa+8rKSksdDUtKSys5uopLaonZKaoJCLjZyiusa6tbSfpMO/xsq8vrK6tbGqs5+ZtMDQ7oHu6Ove7Obx6uje29Tc17mmkvCIkJ+wsbK0s6avsLTS9f+Iv6+P5r6xy8mpjPfmlIF5e3RnaWtwamdxcGhugGpxfoN6hKeNiYaIhXh1fHpyc3NoZ2TJv2V2fnVnc4qUopaenaW+vNvuwrLPnYiHhoua0OXi58ftysi4nsvfnJmStKy1wqKyiI2M4eHH2M/C2+iwrMPU/o+unci8vZjdssbL2cOxvNe2oqOo1a7P4d3Ftc+qsYbigoHo496YiYiXgKG4xpTQv6WeqN6HjZOgtZnH+tG065+W2cL5kZKrp5n07P2Hnq+0uKGQ8NqFoe7YtcDs2/TxloP6lZOkmI6nl5WLpZWS9o74jZKQmpSTlKKcrtDc4fD++9HoiJCsr6GPmKahlNu/p7260L+UxO/T7fDZtama+drt9OSvmdD6nvKYgKe2saCX2OuChpmQg7e9/KS3tq2zx8jZybfF6ubf0d7My7WizKejoZuG/4OzpLfK28rRwI7zgoKErry6raWfr5bHzsPb3efo+ObJ5+7u7PaA7t/k9JGE74GHh4CEgISPjpucoqmQj4bSsMjR5eff1tjBvNHLxaertbrB0drIwdvfgOHr//H/5ODo3cDQvqixlPaCg+72gYmQgejRyaNyeoet56rS8d3Y1oOJgIbwiYbu5eDo+YSMiI+Jm52elv2BmoKy49fj0YOc8tXa+P+CiouG+cqVwoHnhqawk8HPg+r3udSDyMWH7M7Hrp6mivH+8NKh9OLUsrScmLG+i5LAuKrzgJzLv6O4o6SKgOOIzX+toK3Xqr2+1u/HqLzooOqPfLKZ4JH67uGz+ImOj6isjtKv6+iS28G3q43ygqJ1+Nr43uCBzoiN1O7CgI2k28GkX5pldWetrrigj4qLoWZxd3XDnr7huomhf/rUvYqwjKPkyoaojpem6vL8jITuiJHNwdPpgIXR07qP6ouW/aOzmavavrqEhK2QjKSY+aek9Je7nJ+ytI6pp7Se8pDx5tfCvrqIxIyV8t66m8av14ngsIe3lZ+hhYHk88ic3rL9lrb6us+fheiXst+K39r3pqDAyrGvqrO0qIWdjqaIiIm/eXllwGl9hK+Tn66tuuDmuquekoGEgMivjXi6qrTA1XR5bWyEb5qjqcTWbqurxbevz6e4vY+UqYWnlqpnz8qlosmsho+swMObpsCzvsrDw7Swz7q+0ryxsaifiY+Soa+ljX+LkZaQq62sr6m5pqSwv7SXjpeUirGooJKTjoJ01th3zJXZkpnKaHZ/h4OIiIyBdXbPxsfKgGxsa83Ebb2rwnp9nN59kJKdj4eFkquulYyVk4CNipiNh3+FioB9eoWKm6SZlZeEi6SdpauenpWdm5uXnI6Im6awxmrIxsG8xb7Lx8m7urS7uaWXg+KAgY6bm5uem5OanZ60zdBvk4Zvu5uVq6+VgerXopKLkIl6fYGHgXmHhHmBgHmBjpCFj6uZmJSYk4aCiIh9f4Bzc27bz26AioBwfZKapZahnqG0ts3bua3FoIuKjJWjydfV2Lrbu7ewoszTi4qGmpSapouWeHd5ycq3x76zwMOgmKm44HyRgqObnYGylaapuKibn7KYiIuRrY6pt7SjlqyPlXTDdHLLxsp+d3aBgIaXo3qyp5CMkcNxeHqElYCu1bSkzIF7u6jMd3eLiHrNytZxg5KSmIVzw7Bvg8e8nKnJus7RfHDVfnyIgHiPgH5ziH581njSeX16gn19fYiHk62+vcPNyqu+bHKGiH1weIF9cq+djJ6bqqB/p8quvsKumo+B0sDW2Meaib3eiNiBgIuVk4qDws9xc4R8daqv4Y2cmZOZp6i3rZ2nxsa6sLqoqJiMsI+JioZz4HSbjqGruq+wo37cdHR2laKgmYyGk4GqraO0tsHAy8CovcDCvMlpxb29yXdrw2txbWhsZmp1c319hIp1cm6ulaauxMS6s7Sjn6qsp4uOmJyesbSmobK8gLq+z8HPvLq6t6CtoJSZguJ2ed7hdnuJd9rL0654go2x4qC/1cC7t290bHLLdnDHwb3G1290bnRvgH9/etNpeGyfz8PNvXGDz7KlsrNcYWFesJNyjmOxZneBcaKqacHLorduqalvwrStlpCTfePTybaS7uHNn6GQkKW+j5rGrp7vgIyypIOQg4Z2b8p2v4K3rbvetMTH3/DOsb/jkeGUgbeSvITt3dCw64GBhJWZg9Cx1MN2v6mimIDwhKN1366/uL1tsHmBxea7e4ac28esaatxgXK/vMmvm5KTqGt2fHe0lrPSs4uif+/PtX2bcI7AuoSfX2t3go2sYGjCY2KIiZSZgFhraVI/g1ZjpGuKfpObgJJnYXdjaW5pq4R6tnqSdGt3lHeSjZpurXDGtZGHkJN4mm5xtJqYboh+jVCRaVBqV1RtWFOevpZ8vouaY4C9j5trXKNhdaFovLbRiYSbpY6QjZOYkXuKfZB4gH/CeHlpxW6FibGJkp+crr/Io5qShXd/gNLApJHGj5CbtGJjVVpqW4eTmaq6X5qSo5iXp4uWmnqCknWEeYxTqqiHiKKMc3yOn6CCiZyRm6SfmpSRqJicqZ2UkoqFdHd7h5WKeWx3foB9k5GPkZGZiYuUm5OCeoWCfZ+TioGCfnZr1dNtx6b4q7v8gJKdoZyhn6KWiYjr4vH6gIeDgfHlgtvI35KQqNtrfHqCeG5rdY2MfXl/d2t7d4N5eXR2f3p5c31/iI2JhIp4fZOKkpeLioWNjI6OkIqHkZ2lsF62sq+psa23t7arqKasrZ+Vhe2BfoaSkpGVlY6PlZWhs7hdcW1goomBlp6PgPXfw7awt66eoaStpZuqqZ+hgJmeq6meqbqtr66zsKCcoZ+UlpWJh4L/84SXoZeIlaWqr6OspqaztsLRuLC8opWYm6exysrSzrvVu7SvrMfLenl2gHyDhnR6ZGBSkJaOn4ukmZl8eI6fyGx5a4WAg3GPf4iKmpCJiZWBeHuCknKPk5WAfIx2eGW0aWm7tLhvbG11gHh+gV6Pk4OAhrBkaGlzfGyft6Kev21mp5uyZmVycWi3tsBkc31+gW5bjohVaaakjZivpLK4aWG4bGp2cGx9cWxmd29uvGa5aW5scW1ub3d3gZWmoKGrrJOlWV1pa2JaXmNiWIZ/dYeFjoZxkrCVm56OhX5xu7LCxrWLgrHLdshxgHuBfnl5vMdrbXt2b6qv24OQiYWKlpmkoJaZtLWkn6WVkIV7moN9fH5r1WmJg5Cbqp+elHjRbGxtgY6PiIB2hHSUm5GcoamosKiVoqWlnKlbraqosmVerFxhXVpdVlhiYWdma2xcXVmPfo+Xr6ylnZ+PiZaYkHh/jIqOmpuNi5mfgJqgqpulmJecloyUjISFdM5scNHSbXGAbdDF17qNlqXF7ZyyxrGqqWVqY2a2aGK0r6yywWNjW19eamlqZa9ZYFuXvbS6q2Zys6CFh4JFR0ZDfWlYaU6PUVtiWYuOVKCjjaBZj5JboJeXhX6CcdWwrZ+I5N3Kj5SGh5m/p7Pjo4/ogIOdkmp2bnNnYrppsYPRz9rvyNbZ9f3dwc7piOSsnMyLpoDn29K54n19e4aKes21u6ZirpyVjHr0lryIxIuYn6xioXB4v9i8doGU4NTAgNeKn4ns5uvTu6+tyYCLkIepi6jLsY61hOOokW56SnGgiUdTNEZcW2B4OSZANEt/eIKIgEZUTTctY0RShlN1a3lwV3FVUWBRWFxLTyklX0FUTFlkZztMPVZVm1uylYOClZFmlGNppVlCUmdZZTZsSjU+PDM3NzVWVT8UME9cQ2Wfg4BQPXVBTn5ZrqvEeHeHi3h5eYKHhHaAcX1nd3XMh4qC7YSen7eAhZKNnaKrk46HeG12hX2EfoZ/hX4Bf5B+AX/CfgV9fX59fYR8i32EfAl9fX18fH18fHyEfbV+AX+RfgF9j36Ef4d+p32CfKZ9jH6NfZ9+Bn1+fn19fYh+hn2GfoV9BX5+fX19hX6DfYd+BH19fn6IfQN+fn2MfgN9fn2Sfop/kX6JfQJ+fYZ+gn2FfoN9mn4BfYp+AX2afgF/hH4Df39+kH+ofgV9fn59fYR+iX2GfoR/A35/f4V+iX8Efn9/f4V+B39/fn5/f3+EgIV/AX6EfwN+fn+EfgR/fn5/h34BfYR+g32FfoR9Bn5+fX5+foZ/BH5/fn6NfQF+hH2DfoV9hn4FfX19fn+FfgV9fXx9fYR+Cn9+fn59fX1+fn6EfQR8fX19iHyKfYJ8hXsBfIV7D3x8fX18fH19fH19fn18e4V8BXt8fHt8hHuFfA99fH19fHx8e3x7fH19fHyEewJ6e4Z6Bnt6e3t6e4R8BHt8e3yHfRZ8fHx9fHx8fXx7e3t8fXx9fX1+fX19kX6EfQF8hH2NfgICBACAqIW5l5Pn6YqVlJmLl4Pis66cvMHiqLC6ucbUzq6evqCxn7DQsubn383D4oePiYaH4d/k9YT85vP9/frig+/j88vg0cm3qqOtsqmcwL3Jz8fb1dzo49HQ4dLb3NvG4tLZ09Ta2MvI4Myzs6Wjj4L9srG75s2/i354w6m5ucDAuKWAo65aXFtgvcBl18B/eoikzouQkrKpwrC8n6DFzLvMz72wrqibhPuCjKe7sb+trrW3rrO4w8/J0NXP08G6w8/Fr6e1saedpsC4zMm5tqmjp6CZk4H7h6a5v7+3s7SzxdC0u8/b1Ofpp62X1aSg5YyAfW1wbGJja21mZGNlX2FfYGKAZmhqYl9gZ2trbXV6f4GEiY6RhH92eoKOg3dwd3uBkNmdvLKjivWqrbSpqLbww4uEg3h1gICCfX6CiIaCzMOzl/bI5KCYpK+1us/VsbDAl4//wMuLp6Odrcy4p5+TmaOC9tqrp+rlmbq4lqmuwMzQwbmgr6+vtJKB3OzgrN7HzeOAjaK4tMC4g9HPw8P9g4ymnoeN2d76oKT0gYyI5JGHg4CHvfOXhqCcrbWysZ2T+NfSo5TS9e+SspalsreohoL0gISClZKSkZDzgYqgobejv+2supbFw8GzupKsxMXSzvKOioqIhob91LWEmaSyw62otLvXv7mij4+F2N+ouNCJiqqAsJCcyKyC25Xg9POUhOb9htbtmseAjYG/xqqkm8W5xbi4xYuNi4KaoqyitLvLqr7NxtjGu7W7wbC2yd3d37Kgrr7E0dLT0dj68+PUzNfV0OvRl5WBhrKGid748M3SztHyjIugmoX67MiYp6ury8zh39K+1dbTtaqbm4yeqKa6qKGAqq+zx93Cw8HHzeHm1tOms6v6yomGur+so53JsKOJhqbT2aOavdeBgPyBioaD48ml0YuOkYv9pNCwrJOViKGE4tqNg+a5h57Rj5Kpy4OA+vHXyriW5uLn0PuCoLy3iILggMyWxsuNsqOWh+vDutWPpZyrleneuIKGqq6j1cbQqoKAzs6asqWKlq+OrKOivZqXjXmDjZKFd3F98PiC/Pnsh7O1r/PbmpSMk3ysidnk2eu9l5+V25GgvpeciuaR8v3S4eCZwL6j7OCUv42Doahur7Gff7NospOqgdy9rnGCgpSC96q+wZ+uptPr/KaEsoLGoqCXzq2t56uomqKyw9Li/amAmoqRkoGCuo7A+aaekMCzheWL7fnI3rKB14fn0rTptIeUyrL/m922m7mYyN3izo7l6L+Jirmug5C/wqyNhqGg1+a/ybqpgpfNl6D2o6e/3dWRsLOnw6CG58/9iPifj4mpsL+1zb+Q6tjdyZvSwryuvI2Xpsy3iZ6w6Y6jra3ZzrOAlX+1lZbfw3N7dnlzfWy9l5aMpq2/lZihn6qxqZGEoIyXiZqvmLy7uKmjvG91cG5uurm9yW3Tv8rQ0c66bMa6zKy6q6ibkI2SmZGFoqCqr6e5s7jAvq+xva20t7envrK2s7S5tq2pvqyZmpCRfXPmp6Wy2cO9kYWB0bzQ0NnUzryAustqb21sy81t38WKgpOlwHp8fZiPopWfiIOdopalqp6Sk4+Hd+F1epCdk6GTkZqZlZmZo62orq2qsKCbqLCpmZadnJKKkqegsq+ioJWSlpKKiHvxf5OipKSenaKgr7SfpbO7tcXGh4d2qY2O3ZuSlICEgXV2gIZ9fHx5dHdxdneAd3l5cGprc3Z2eIGHjI6Rk5mdk42Ch46aj4R8goaLksuFm5aOfeCQlpuUkZ7kxpmSkoaBjo6PiIiNk5CJzamYguC514mCiY+TlqWuk4+bf3XbrbVziIaFkaOTiIeAgIdnxLGLidfQgpeYfo+PnqSmnpaEkJGRmH1wwtLJmsm0uc+AeoiXlKCYcbm0pqvabXaIg3V4vb7ZhYTMa3JwwHdvbWtxps9/c4WCkJaSkYJ91LmyjIK40MyAmn+MmJyRc3DUbW9tf3t9fH3Qb3mJjZyRu+CZooeppaeYooCRqaKxp8Nzb21qamrKrJR2gIuUo5OMlpivoJiLfHtyusaWprp3eI+AlX6Ip49yyIvh696Cds7gdr3Sia1uc2ulq5KRhqicopuZpnl+f3WHiZOKl6CtkaOyqrGjnZyfp5iZrbe2uJaHlJ+msbK0trfOyLqwrLayrca0hoRyepp2e7/Nxq2yqrDLcnSCfWzLwq2BkpiSr6y+u7Gfuba1n5SGg3mGkI2ajYqAk5WVorekpKGmq7i/s7eSnZ7swHx9sbenn5jHsauOja3a2puLqLxtbNhsc29wwa+TtnF1eHTThaWNi3l6cIFswb92bcenepK4dnaEm19crqqZkoZyurm+qshme4+Obmm1aKuFqq98nI2IfePDo7KApJ6licXCpYCFr7Cn2rK9nn+AtbB5jIJzfY95oZydwqSinISSnpuQfneF7+d88vDigqKio+7Yn5aNkXuqfrS/uNqgen5/woaOqIqRgtuFzNWzwcCGo6GO49eJr4h+pLJ3wbulgL9vt4qshuTKtXmKiY5/9au/w6Kxps3X4Zt9omOojIF7oIeFtXR7fnh+mpunsGWAY2ZWWllXhXSSsoCAcJp5Z7Fvsbuhm3hirnG8oJi9kH91jnvFfqSJc6RtlK+2m3m8t4teaop2WmJrdnRQUG9yiImCeYZ6cICeTEyHcnd+k5lifYd+k4JyvrXTc9yIf3uVnKWbsKaG2r7QwJTBvrmvwZGdpNG5hJGh4YOSm5e+sKCAhnfApKvhpGJoXF5gYlaag4V3kpyggYiOiZKXi3dvgnqDdICPgaCeno2HnVpeW1pZmZadp1msnaKnrKuZVaCWooiTiomBenV7gXx0iYmMkY2clZqenZKXno2SlJmPpJydm5qfnZWTppaJiYGEcWzeqai33Me/nZmX/eX9+P726+OA5P2GjIiE7+uA/92jmKq0wG1sa393hX6MdnB9fXmHkIp/hYB+ctxucYONh5OEg4qKh4yGj5mTl5iVmZKKkZqXjY2Ulo6JkJ6YqKWcl5KQkY6Ih370fouYm5yVlZibo6WWmKKnoq+ua25hlHqF6sO7vqinppWbo6imo6GdmJyVlpaAk5WUioKFj5CQkZqhpairqauurqaZn6SooJqSmJqZmsJzfnt7b854fIB8eYDXxqqlpJuWoqSmn52gqKSc0458ctOyyndvdnh3eYKFdnR3aGG2nKFhcHBxd392bnVubHNRlo9ydcK8bn1/cH1/h4iIhHhueHx7gGplsb+5kLyqtcKAb3iEg4V5W6OglZm9X2V0b2hora6+cG+xXWFgq2VeX1xgmbluZ3Fve4F8e2xotKObf3ilubVvg215hoZ/ZmTBYWJhbmtubnDAZG15foh+uteJknuWlJmHlneDlI6gkaZgXVlWV1Sii39pb3t/jIB3fYKPh393b25lqbWQorNsb3uAgnJ+kX5qvorv9852bL/Vb7bHfpxhZF6Xm4iHe5SNjIyGj3Fxdmx8foV8iZGdiJSjoKSRkJCSm46ImKCho4Z7hZCXoaKioqWwraKZm6Gbmq+mfHtucoxxcqayrJmZl5mrX2JuaFmnppF2goqGnJuqpJyQppyfiYV2dW54gH6Jf3qAfn+BjZmKi4iOk5yfmZ2Djo7XtHN0q7KlnZjCvLiio8Lt7puIoq9iYMFhZ2Rjr52LpWNnamS3cIJ0c2ZnYWhXqq9qYrSZdYaiZ2Fse0ZEgH9xbWVXlpmbkKNVZG5qV1SWVJBzkpZvh3h5cdK6kZVwpqmsgKqolXqBv76+66qqk3yAn5hjcmhhbXlolpaV1MXEwaSywLWrmJWh9ud67e/ifJSUm+vYq6CZm4qmc5qlnMaFYmVqroKIm4WLftyAsrmhqKqAlo1/2dWFn4B7sMWT6961d7+FxICskPzs15Cgm5F/+cjZ47/Hv93EzI19l02RfG5qhnpRYFdFNS9VYX2Hq1yAWFVIREQ+UlVoeWFtXH1SUpFknZxygV0mUjBSWE1pRTVPbUhjWm5fTkVngqq+mGi4tntOWm5WQ0JMRk82NFNLKiEgRU02FCNtLS5bUFlec3FCTGlpeHFmqKm/Z8x5c3aNkZWOlo50q5e0t5e0v7+8yqavstvDfYSQ33mMkIWrnZSCfoR9AX6Hf51+hX+EfgF/h34Bf7F+in2KfIR9BXx8fXx8hX2VfgF9rX4BfZJ+Bn9/f35+frR9hX4BfYZ+kX0Gfn5+fX19jX6DfYx+AX+EfoJ9kn6IfYd+hX2Gfgp9fX1+fn1+fn59hX6CfYp+iH2JfgF9iH4BfYZ+gn2PfoZ/k36FfYl+EX19fHx9fn59fX59fX5+f39/yX6Ff6x+BH19fn6NfYR+A39/foR/hH6EfwF+iX8Efn5/f4V+hH+CgIZ/hX6GfwJ+f4l+CH19fn5+fX19hn6EfYZ+h3+Dfo59BH59fX2Efoh9hH4FfX5/f3+HfgF9in6CfYR+EH19fXx8fX59fX1+fX18fHyFfY18AX2FfA19fXx8fH19fHx9fHx9i3wPe3t7fHt6e3p7fHx9fXx8hnsJfHx7ent6e3t7hXoQe3p6e3x7e3x8fXx8fH19fIR9EXx8fH19fH19fH19fXx8fX19hH4FfX19fn2Kfo99BH5+fn2HfgICBACAw8ephfHJ+v2PlcmgvfbJo7/8h9Xe9evj24WDhciaipqjuLfn4bv40tLEjfyinIaP8YqThoT12PmQgpqMkI+EjY7u3+D19urs+vXK1d3e8Ozcz8348oGEzOO/1YuS4t/who3h4t3R7vba09bky8a9k4SFnbrXz6770ZB3ZWGtvb+Ao622YV1eYGlqy22Be4OQhH2m5ICEmJWaqp+Kn7y+r7WeoZKF7uuJoaqPjI+RpLW1qbnLz9LM1NXe2tLb8/D16vjax6SOj5WcopWgo7C1sae+u6+zt7TN0se0npqGu621qqOlrsOyvdLQ8JKSf3p+fX53cmViZ2tsZ1lWWFpaWF+AYGCvpKq0aXZ+fH1+iaii1eHDvPzg6oKLiN+kdnWakoz+v+WSk4GnurKfqpR3b3VpuKq7Z8Nseoij5+WMoZmD5NbrnLXUvqyppaGekYDo6MnfgfCkqqi/tqaL7fujtLCxufT04ezuyJ3sltC5vcrHoIyPkIf0jpiEh+/Mq7e11MyA14bnicbd7Li5qpekrZiHhtPBysjugoCLkIHw5s7bg5aNkI6AhYqZm4OOm6iXlKSYj9Hp1r3f8ZSlmZaGkPzxxrb9iJahmq+Zq7nCy8286auPkfPG7+Clno6Anq+lubW5w9qBg+3X7MKig4GKkZWJhoiQpK/C1L+i1ae7przylJWApJOhuMLQyqnKl5G0vbCHmrTKzLv1/4CH+tam25m7wrqwsbTCy9TMnOPY7KCLlqSpfOSmpKuXp7/O0MC2utPNq9Tiy9rn4J/JybO4ztvEs87e4tm/z+DFzNn2guXWt6KSwOyF/YCK+4Dfm93tqqS30cLE2cTNu7WzspeSqqS0oKyAqJ+fpJqaobK++9TOvMrC3cnHy5OUgaqYguHxrKyUobJ564mawfuYmJmam46G8t369IqTm5KVjZqqoKGgq7WbpIrwo5yz84D5oYCMz/bn5su8vMzFkpSK4tOBnIbT0oGD28Xs1dbYhonTuJWQldXU6L+Ou8TXw7OR3oCf7ZjavcKAzJS6j4qOlu2Esa3XspyOkHl3bXaSrcGm9r6fgfiYzeTwl5/0rcee/KjE55Wegsu7gZfkx8O9y7G5rZ67n7/i1tbj9/3ju6LQxbOElXlwbozL+ZWK75rcmK6VleHDlIW2h4GnyMvM3Y+Tp+KV276e6r6vlImgmb+os5nRntvbk5GA6pu7yo6A+Z2jvrb2gsG2jM7CpImTu62Z8Izjqd/34JiOyZaFo5ecnZOwmfyikYLqkaCD2LCTppzi+J2spLbEmLvVou6OlIy7uLTLqffgv/u7urm6qKCstfnsh+bd29mEmbG/y5bh4ZiBoKO+lKyRjJG1xYnYzeebs5mxutOAyseApLGYe9ir0cpyfKeMpc6nkKHKbbO3zL28s21rbaOAcH2InJm+vp7Jrq2gc8+EfWtyxm92bGzIsstzaXxxdXNoc3HGt7nOzMLD0Mmosbi4yca3rarMx2lrqbqesHN5v7rJcHS8vLmwx865srS9rKaigHV2i6O6tp7uzpd/bmq/0dWAtsXScm9xcHl22XeXipCilYujzHBygoCCkIh2hJWdmpuIioN22d15i5KBfYGFkpyWjZulqauora+1s620x8TKxc22qpOHhIeNlIyQkZ2ioJinpJygoqCxs6igk4+BqJ+onZaYn6yfp7iw35uhj4ySl5mOjnp2fHuBfW1rbnJubHKAcG7Kub7HdYONh4iKlbKu3OTJvO/Z3HmAftergXuagH7lo9OSmIiouLOer5+DfIN1z7/SdNR2hpGl3t6BjX9w0cTThZq2pY+Li4eBe3LN0LbPctWMjo2dk4l1zdeHlJKSl8HFtb28pYTOg6ycnqinh3d4d3LOdH5wddGznKWt0sCAwXPLeKWywpmbk4KMkYN2c7mmr63LbGtzdmzIwK67bnx0dXZqbnN9gW91f4qAfIh+eLXQxKfC0n6Kh31xe9vUtK7ddYCMhpiElJ6or62d2ZR9gt2mxLuQh311jZaLnpmdpbVoasCzw6GJb29yeX50cXF3h4+drp2FuJaymq3YgYSAjH2Imp6rqI68jYGanpR0hZuvraHO1mpv0baNx4afoJqUlJWhqK+qhsrC1peGkKGmfNqcnaSKkqSurqKcoLSrkrXFr7u6uIisrZmdsLalla21vLWir7mprrbKar+0oIuApcZs0WdyzmvBi8rUj46Zs6CnuqawoKGbm4d+koqVhpKAj4mHioGFiJahzqqtn66huKmpsIOFd5aHd9Xkqa2Xp7d77IaQq9R+fX19gHZ00cHXzXF2f3d9d3qLhYGCiY17h3fRko2hzWvNfmpxoLSnppiKiZaQcHJwvrBqfG2zrWhpuaa/s8jXf37IpYR9d7az48KSnqm2qqWL5IGY0n29vK6AsXeTdXN1fcx+tbThvKaan4SHfYWjucqw/MSgffSPydvhlp/sr8md7p+pxnaDc7ajZ3jCra+pt52noJCmjaXCtrq+09PDp5jLybaMm4B2eJXS95yS6JbbjaOJi9a7lIa9i4aqy83P2oqCjNGLwaWQwZ2FfWqIgaRtfnOih7vAfm2ApXaSmm9ly4SAn47AapqXcpqGblt3j3trunWthq++sHh4pnpthnV1d3R/eeODdGm8cnVknnpibV6IkGFtbXKRYVeCfa1wcWN+dWqDZKCmgql7hIqSjYqTneLce9bKyMh3iJyisYnZ0YhxjJKohZyNg4SjsH/LwM+Fm46lr7lsrKmAkJyHdceUrKhfY4x3kKeKe4qkV5aZp56dmV9ZWoVnWWV0gX+bm4akkZCFXadnYFBYnFhfVlaekKBZUl9XXVlOWVeekJKjo5ugqJ+HkZiapaKUjIumpFRViJSCj2BloJykXV2bnJmSpq6elp2glZKQdGx0gpGdnJDpz6yVg4Dp9vaA2er/io6QjpSN+Iu2pqu8r6KqwGNkcW5weHNpcHuAiox6fntw1NdzfYp+d3x9hpCJf4qQk5aRlpicnZeZqauurLWjmYuEgoaJkouMjZSZl5GbnZeanJahpqCYj4yCoJqemJOTlp+Vnaaf5LbEtbK3w8K5tKKVnZiippWQlZmXkJOAkIv86uv5kJ2mn6KirMG629/MvNzQ0W5wb8SslYmhbm3Rgr2do5mvvbWou66WkpiH9d79ivqJmqGv2tN3f21jyLrFdYScjnx1dnBrZ2W2vau/ZcN7enmCdnNkuMd1fXp9gZufkJKPhXC6co6Fh5KPeGtraGO5ZmxiacCmk5yl27iAs2m+cI6WnoKFgXF5enBnZKSWoJu0YF1gY12sqJmmYWlgX2NaXWBnbGJia3Nwa3FpZJ+zq5Ssum52dW5iar61opvHZ293dIJ1goeSmJiGx4VwedGVrKiCe3VxhId+j4mJlJlWWaCao4tzX2Bha2tkYmFpc3iDkoNypIedj6TBcnaAgHJ6jIyWkn+zjXWPkodseIueoZe9wGBhuKWBwXmRioiDhYiOlZqWfcS606GOmaelhu2Ym519hpKZmZSOkZ2Ygp6uoaimo32Xno+NmqOTg5OYoJ+RmaKYn6WtXKmhj4J2kKhdr1hgr1mneb3GgX6Ln4uXp5SckI+Lint0gnyAdYKAendydHB2eYOMrI6UipiPnpOQlnV2boZ5bsrcrK+jucuJ/4aQocNwbWxtcWdquq7As2Fna2ZuZmV0cGxvcW9kb2WzhoaSr1uyaFphfYZ8fHRpaHNsWFpZnpVUYVmaklRUmI2dlr7OdnG/kXVvXJaX2cKhipWflJyF7YCTwG6nyaCAnmN4ZGBiaax2yMXp3Ma2waSooKa/0uHJ/8ayd+2Jy9nZoa/qt8in4o+VrWRvZ6eTVmOvn6GcqJKblYeahJizqKqtv7yokIfKzr6gq42Fj63Z76ec3ofVhZJ8fsy0mIvZo6fL7+7h54trariDrpSFsG9YdWZjTWQ8VkFTYXqXdmOAi2aDiF1Uqmpog3ajW4p8ZHtqVEhkeFhEcT9vW3hzVEZHeUlCWUA5NS1BPmFucmOlW2tNfWVIUkhfbkZRV1tcHyQ8Q389RUxISUtoTnl6ZXxfaHJ9gX+Ah9jUc8fBu8Jxf46TlnO9xXpngIqSeouAeX2Tn3jBtr10i4adoaVblJSEfgZ9fn5+f3+IfgF/hn6Df45+An9+hH8BfoR/g36Jf5R+gn+Efgd/f35+fn9/lX6GfYZ8hn0BfIl9kX6CfcN+mX2EfJB9g36FfQR+fn1+jn0FfHx8fXyGfYR+g32LfoR9An59h36CfYx+AX2LfgF9hH6FfQV8fX1+fY1+hX2FfoR9k36GfYZ+hX2MfgV9fn5+fY9+gn+UfoZ9in6CfYx+Bn9/fn5+fYx+iX0EfH19faV+AX+Hfgp/fn9/fn9+fn19rX6HfQJ+fYR+h3+EfpB/hX4Cf36Pfwl+fn9/f35+f3+Efg59fX5+fX5+fn9+fn19fYZ+CX1+fn5/fn1+foZ/gn6SfQN+fX6KfQp+fn5/f39+fn9/lX6OfQJ+fYR+hH2IfAN9fn6JfRp+fX18fH19fHx8e3t8fHx7e3x8e3x8e3t7fIV7EHx8e3t9fXx8e3x7ent7e3yIewF8hHsGent7fHt7hHwBe4R8Bn19fXx8e4V9Anx7hXwBfYd+A319foR9hn6CfY1+g32GfgN/fn4CAgQAgP3brLTKvoK23JqP29DNy8a+3P/e9fiT18Pb2IKJ58Hk78fH0NTD5sqYv9fdg4fct77H2L3Z0uWC+NLb9d+bofWYkeXz74eH4O/5+uva8Pj19teGifXT5radz9v7/oPK6uX48+H29bfMy/T49f7d5MTDv7fNvMrApfDOrKmncWm+gF6zsqWyZ15aYmxzeX+QhnVkYXy95/yRpampk6qvprmvpZ2akZCSoKanoKavuLzg3urX3s7K2dbo1dnU3t7Vz83UxsjEubK2xbKim6mTiYWQmpGRk5OqrKWak5GOmaWde5F+e+iBr8bbj7binoCBhIGAcG5pcnJnZV5SW1hhYF1dgKKPl7Zyf4OBgo6ck5TXhqaguJKlq4Tw27afb2Vze3J4d3ybmY6Us5d9bL9ucHBru6enuLeRhdeWqsiAscCliZqn0d+917mxmY6Vn/aH//3zv4ePp6Svs+Wnz5y595SsoLi3zc3hy8e61aypspuKhYyE9v7N3YeIifTV4PiC+9jJgOiNmcXG0dnMnYLojL7e0cnQt5CIxLasu9HKtKme3MGBkJ+jlIj5goqMkI2wvJOdytvdx47lq8DtiK/J4NvNq8bjwtyCi/+s7/Gkt4Pj3b+zkYaA06G46Nmv/pelv720rJG91MDj1eDQ4rT5t6Warq6Q9uT4jcu3tYvqy+ze+5mTgJCNiomhhqirn4aIwNzg5tO/y8S5s8rGtrutya6QztO/rrevlqnGuaWKiJKBk43Az5SSkKyP3oOyu8rE3sPQ2dDVyOzk6MaamLeTls7MpaC/zb/Q0L26vq+bmJ2v1dmyx7O9ydLvk4WLhYCw6YSUhZqmw7vIr7fGwrTCwLW8q4+NgIuwybK2y9q+xbKtxO3LwMzUusu3wa+ioYSTgvGA6Jae0dTxpN2Cif3kz8K62djqgIWF+tna6eKBjoX6h4/9/aWgnpDW0eGgqdKJ/ayjs9i2qJuer7nKysm0lPCMi4KI54KP7OPLv+u6l7PFofjHooSKgvHi+r6nhIa//rWmgNfqgNCP4o3ptaPZqZurpLnQro+CY2JscIqbh9TQyeTg76rKg76j0vjNpYjmgYiehoyOiJKWlevWw5X8yaKLi6bAs7St+O63quCQbnF4Z2t2a7OJx2eNtYCOsNDg4uHMju6G5+vWtoLXvM+TxoaPzq+3uLvCtK6emPm8z+GXjoTkzNjngLLb9sLx7NKI9Z2qlouggoy0iMiK97HQpuWMk/v6qpKnzZi10bXW07WQ2a6p07iP37yGr9OM25acoofJ7LjHyPqrrZyAqtKcutSXps/h9LaHsLKYv8DX5u+7iraspPmRjoi+tIPw8pCNmauZz/f2jNnmz66slqPakbvPzLDA7+TigNO4lqq3rG+hvHxysK6traikvM62zM55tKS5r2pvuJy2vp+gqKuivKZ9m66xa261mJ+ktpyzrr5oyamwxbd9gMh6dbvDx25uu8bKzcS0x8zLyq1tccmwv5mFsbrT1G2pxb3Nyr/OzJqsqsvNx9K5vqWmpJ2uoq6nktrFr62nd3LTgGrGxbnLd3JtdYWJkZajnYh2b4u60tx+jpCNfYyQip2WkIWFf31/h4uOiI6VnZ28tsCvtqmnsrG8sLOut7Wvqqqxpqqqn5mgqp2SipiGgX2HjoWJiYaZmpWOioiIkZmUeox8eup+u83dhaDaqJKUl5uYiYeCj4qBfG9kcm13dHFtgL+lqsl9jZGPj5imoZ/TfZKSooOTmnvl07GfeXB8gHd/fX6cmY6UsqKId9R7fn561b670M+didGGlsB+q7mcd4CKqLSbr52Xfnd8hNV02dzVsHZ6i46Uk7KJuJSo34CQiJiWpKWyoJ6Wr5GLk4J2c3Zu0tewwHFycsq0u8ls0rqugMV0gqSjqq+qhXbReqC5q6iumXt3qp+XprCtnJWMu6Zxe4SFenHXbnZ6fnuVoIKOqre5pXnOlqzNdJiouLOrkqnDprxqcNeb2tyRnWu8s6GZf3Z/vomYvLOY44aOpKCZlH+0v6K1rrqru5fTpYyDk5N71MXVd6WVm3jQt9PI4YR+gH95eHaLdZCSinV2pry7wrGirKadmqumnZ2Vrpd/sbWflJqWgZGlnI15eIFvgnylrICJiaKIy3SboKypwaeztK+3qsW5waWMiJ6Cha+qjYqkp6Krqp2fo5WFhYaUsbOVrZqgprHCeWxxbGufzXF9coWOp6Ctl5quqJmkoJqgknx5gHmWrJaXsb2dqJeSositpK+znrGcrJeRjnSBdOR66Zyfz87plb9qctfBsqijt7bHbG1vzbW0vr1wc2zKbHLS0YOEgHu8vcGMkq9z0IZ/ip6MgnV2f4qVlZiMdsNzdmpuvWhywsC3qculfJ2njMirkXyEfsa926ibg4av4KeZfNXegLp4unPHopDYqqG0rMPYvZ2OcG59gJSkj9zRydjXyJy2friavde1mH3IaXGCb3V2b3d8e8e8sYrxtpuGgpamnqGV1M+lmtmQcnd/bXR/csKT02+Wt36FoLrEw8Ovg+aA2d/FqoLawdKMqW6GyJ6koKGomY6Ff9WcsbiBe33EwMjIgJK3zJjWt7Bwx4GGfnd/Y22PbpxZmX2IbbZ3b6e4e2t7j3d+qY2bmZBxgWSKqohtvZRefJ9ljmVhZlqHqYaPjbxvdHNjeo5kcYFgZYeKjXVbgYt+mZ+uusakf7SlnumHgn+onHrm4oV8iZWHvdzXgM3Xy7KwmqbShqWxs6Gwzb+7gLCehqGsml6NoWVZjpKSj42OoaeUqalglY6Wk1hakH2Tln6CiYmEmIhpeYmHVFaRen6Fkn6RkJtQl4KGl5FhZKFfWo+Wn1ZYm6CeopyUpaOjnolWWqKQmn5xmJyuqFWInpqko5qop4ealqutrbWgooyOj4eRkJaRgtDIvry0i4f+gIDw6t3vjYyKlqWor6+8uKWSiqPCwchvfH16bXx3dImGgHZ4dXN4fH2Ff4SLkY6opKman5iTm5ykmZyYo56Zl5WclZmbko2SnZiPh5GLh4OIjIiKjIeTmZGNi4uHjZSTgYqEgPZ/2d/mfJDhwLW1vcDCsa6qureroo+GmJWZm5eNgPPa2vuYp6qpqKq2tbPKb4CCinN+f3HTvqafi4SNjYWOiYqbnZKdubGWiPaNkpSQ/OLf+Pe6k815graFqrSYZW1yi5KDkYN+amltcLxku8fCp2tue35/fIhtqJCj0XV/eYGBioiLgn54j3x3fXBmZ2dhur2hrWJlZbajpqxbuaWegLBnc5CLj5SQdWzGcI6fkJCTf21nlo+NlpmYjoqDpZhjam9vZ2C1XGVrbm6BinV6kJudimSxiJizZICMmJGLeZKmjKJXW7qO1tOCilqglYqIdmyGuXuEoJyK1XyBkY2JhXS0to6Xkp+VmXy0lXVwfXtnurS/aIp+gWq4q7+2yHN2gHdvb22AboKFfWtslaeqsaSXopySkaCXj4+Jn491nqOSiIyIeYeVjYdycHZqeHGPmXeNiKGKumuLk5mWrpuinZ2km6ympJOBe5J6eJ6agn2Qko+Xl4yNkYZ+fXyHnJuEl4iLlZ2sZl1fXFuGvGlwaX6FmZKciYuZlYqQi4eLfm1rgG2FiH+Bm6OIkYF+jqaWj5qbipyIloeDgGx2bt556KGs2tDpj6xeY8Cto52Wqqe3YGFitaejqKdkZV2vXmG0sW5ua2eqrKx/hptltmxocHlual5bYmpwbnJuX6JbYFhYmVVboKSfl6qSYoqNeaCRgnV8eJ+ivJKMf4Wjxp2PddbZgKRjpWKvkoTYtrXMwd3s3L+wjoyjoqy4quvSy8zOrpGneMCSq8GojXarW2RuX2ZoYmZoabKspITpq5eDeouclpeKv7qaj9afhI2VgIuSh+23+oisxnp+i6amoKaXedd0zM66pIju4u6HZk2A3JaYlpONfmtmdbhuSXZbODt6Z6XAgHugsHKykI5gq3FzbGZyUlx2Z3tDc2dmU200PXN2WE5cclhbfmFfOzctTjUrLiwvXGFUa4BWb0tOUktleEQyTmdHVmBUZmhBQks9SF9hZ1NFanRzho6VoKiUdLGZnNx6eXmajXPd13tse4F9r8S7dr/JzsjGs8Def5iiopWir6SjC35+fn19fn9+fn9/i34Bf4R+gn+PfoJ/iX4Bf4V+Cn9/fn9/fn5+f3+LfoJ/iX4Bf5p+h30CfH2EfJF9zX4HfX59fX1+fpZ9hHyKfYh+lH0BfIR9hnwEfX1+foV9jX4CfX6EfYh+hH2UfoR9g36EfQF+hH2JfgF9iX6LfYZ+AX2OfoR9i34Jf39+fn19fn5/hn6CfYV+AX2HfoJ9h36CfYV+g32FfoV9s36Ffa9+hX8Cfn2vfgJ9foZ9BH5+f3+IfoN/hX4If39/fn9/fn6Ef4Z+An9+j38BfoR/A35/f4Z+AX+Vfgl9fX5/fn9+fn6WfYR+AX2Hfop/hH4BfY1+iX0GfHx8fX19iX4CfX6FfQh8fHx9fX59fIl9hHwffX18e3t6ent7e3x7fHx8e3x8fHt7fHx7e3t8e3t8fYR8hHsCenyGe4d8h3uLfAV7fH18fIR9hHwBfYt+hH2GfoJ9iX6IfYl+AgIEAIDh38Kn5I2LkN383O/4gdv00PCivYbzjfb4rZ3L6ZP65rOVn8W8u67QmJrFwISEnKDWt6OeyMeE8pn0q9TS7peOgYCH+96Dg+Xjx+fwi/CG6rPEh/7x2c7M4vHk7MW6yeCF9OnNprDv/9jU5t/e1Ojr197JxsXnsresrKeYiv7To4B4amtsr5Kis6xTXmFpb3BxbWNtf3Wi0PujuZeBoqiN/YiB5O2Im6Cos7C2rrTFuMbGxrWzzNDCwNff5t/n5+nx4+XP1N7X1s68tZ6N/vyJnISMho+LhJCFgomYpJP1fXl4y9b6jpONpqfL3Mq+iXtxa2ltZWVjXVteXWFbY1lZYIBqc4igtOPGztHaz92Er5upxLTesKuPh2xpvbRnZmDBYsO9dJShs9SGoJfPsItwZ62jqsm4kLq1gJfM0Zur0LCTobmwi6DApP6BiJqR6OPpgoHWspm8jIOu2LL8rp+InMyw3rywtayxt7irqbainI7/j+OL4OicjfOpyeDW6tvi+ICEhI+gqLKrmZ6lnJagtrWun7/Q18WR+8e8xNzy4cqPifKMjpKuzcK0ycvI2LO6yeDT6/H83IGOrbDOv+6Ty9H/kYjr//XNuMX6o9bWz9nJ9peTx4eui/PissLGt5SgsojBo5vOor+or8TN5+jo3u3s69va1sTj58e6i4WAjJygnYCO/4+rs5+ircquo57znsbQuJuF+5+LjrCunqWUi4O4y6Wrrpv4j5ydlYaIhoTwgY+Xof/1hqzVzd7l2KeRhcrl2d7m1t/j4efe6ODlxL7M4KaNnI/8nL+9uauks8ChqNHJuZet2efs/vuE9eTPiu3k9ZCXlKasrcTawMGxr7eelYCmtdbr7vP7ycPAxNTT68O3wLOyw6aXlZuS6NODy7H0vtyz84/D3NXauLTNqJqyxNjHxp+sqaSJkL3K8dHL6/zt6qCkmPLU6u/l7cHH6p3E0qqkpbG/qJ2YoqWZ/O3X+/zV3s7J0pWVmJuV0s+xmoeUhYWY9urHt5WMlq+rlt3UjIDOiozx06S7pITC7H/Kr4unlYV8e4NxYGq14IaTpczMt6Wz14X2j6CLhoWF1oCGi42UgoLp3NPPqY+I3IHfiJiQrr+Gks6gnoyEuXmOubxruLC1x/K0g67Hiqbixaq63oSn4c66nrh0wL3w1OPmsYn7rouzivqN9uSpn5Sqh/2ayoDGm/vZ6tn/qKeG46GiiuPOmZ6F56jmir6amqv/neyfuaD7kenH29jM05Ss2uXD/vXohYSM1NqGuomPzLaAv93Ng779n7yp/cuDsuiyla2q1s7WsKWcutTV2IrzxbnTyIPU3dK6jJG2s62Ljomzy62iwMq4mP2OneqdkI3k7ITo1IC2vKaQxXV2ecHUt8PMaLfJrcaLoGzGccfHkYmnvXfGt5N/g6Kamo+pfX+inWtsg4SwmYiDpqNqx4DRjqyrxHt1aWhtybVpa727pbzGcsVwwJWecNTFs6ysvcu+x6abqLluysKrjJjH17izv7q3r8DEtLmqqKfEmZ2XmJKHfvHOpYB+dHh4wqG40M1odHN8hH+BgXJ8joGfwNqNnn9who1+43p529RzgomMmJaalJumnKimppucq66jpLO2urO7ubvDuryrsLmzs66jnY2F9O99jHuCfoaBfIZ9e4SNlYrzfXl60NTzhYmDlpevvK/EmYuDgH2DfH15dHB1dXhxeGppboB3fpGovOHMzdPb0th+nIiRpKDdtLekmnt31spzcWvVbNfKdpCWo79zhoXBr5V+c8K4u9q0gZ2Ub5DX2ZSivpOEipKPdYWfiNVxdYF5ysLHbm+6oYGhd2+LtqHxtJ16mbuVt56XmI2Oj5WLiZeIg3jZesR1wMiNheWYsr20xbq+zYBvbXaCiJGOf4WJh4CHlpiQiKGrsad/4LCosMLYzL2BedV6fICZrKCYqqaqs5iuvriywsPJr2d4k5SpnNR+prDTdG7Ez8arn7vqjrOup7Gmx4CCsn+neNbOmqSlmoGIl3W2nZzBi6KOl6Wtv8HBu8XFw7u5tam8uqCWdnhyfIaIhoB54XqVnIeJkayXj43diaarnIt64Ix5fJiWiI5/dnKfqoyUlYjZfYWEhHV0dHbRb3d9iuXac4+0rrjDtI1+dq67tLS7rrW5tr66w7y+pKCst4l6hHzkiKKhnZGLmZ+Hk7Gnn4SRsLm80c5ry7y3f9/L2X6Dg46Tl6W1oaWWkpqKfoCNlrDBwMPJpqOip66sxaSXoZqcqJCFhImG0sF7tKLnuNet54KltrO7n6OylYqiqLWpqIyZl5d+gaOtxa6tyMrHwYGFgNW7xsjBxamsv3uRm4F/d4aPfnh3gYJ608e+1tCzu7W0uH98gYB7uMOUhX6LfHl5zsa0q4+Jj7GvmtrXjoCvcXXMupenloLI8ny8pY6xoJOLipN/anK74ICJkq+yopWmvm7QdYJybW5yuWpuc3R7bm3Gu7u6moWB1nvafo2GnqyDkMugoI2MxoGYxst1x77F0eimfKGyfpC6rJeu2HuQxLWmkrF2w7vo2OHMlHjbj3SbeNlzzL2WlIOaddKIv4C5kevCyb7bi5J+zIiBaIyVfH5jm3eQVol1enyue7SIg23AdbyAdn1ub2Nmn6aTpJ6yUVNpo5JRfVRboI5oi4GXYYm1ZXVokHFSd5JubYCBoaKnkouEmqqzvnzswrXTx36+wbWogoOlnpd/gYOgsJuUr6+hi/KIj82AdnXAyG28sYCboYyAoV5kZaqzmaKpV6KnkaB1iFamW5ebenOIn1+bk3ptcIl+eXKGZmiChFZXbWiKfnFvhYVUn2mzcIWInGNdV1BSl4tOU5iUgZCfWppZm3t8Wqicj4yMnKuco4h5hpZZpJ6MdYKjtZ+ZoZyakqKjmpyQj4+lhomFioJ6dujNsYCRiI+Q6cTe+f2CkpCWn5eYnI2WqZimucN5hGpmc3Fy13Juz8xtd319ioeKiY+Yj5iVnZWSm52Tkp+eoJienJ6moKSWnaWgn5yVk4iB8/V3hXt/fIWBe4R9eYGGkIr9g4GD6ePygIV+i46cop/duaqhnJymnaKcmpacnaGYnouIiICRlKW0zODR0tHT0NV3hXV3g4fUuMK4spCJ+/OIh4H8gf3rgZKUmqpjam6rraWVieng4/2zb4F5YpL28ZWdt4F2eHZ3ZW+Acr1naW9lsrCzY2GqnnSJaF9rnJL/1qVzobyFnoqGgHZ0b3t1cXpxbGi8Z69kqKyFgumPoqSdqaSlsYBhX2hwc3x6cXN4dnJ2gYR+eo6Rm49uwpuToLPAubR2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yM6SgsxwiICHg4mA4b+mkoy6gYmDo5t1pZePtLKYhKLPq8fStsu1yv2D84OBkoH/2srEpM3o0+TrgY6glYKJ9qeJj+2vrIeimabUc8iDvXGkcGSIvKK5Zbh0hqSxrNjB2v6c9NC0ka+nvb7whMaP5dDAmHpzgH6D2viYldurypT6/IyM1bKUn4D+59v5uoR7hHfTy9eBjpbc5ZmYufDG/sH8yqyDkeWnvqrOoOu9zJuhitKzt5Wgzair8LugqqnDoYHQ3PSK5ee3xNW7rPjdnsKOqbmZmvDZyuPiqoyPhcrovZi3u4+gpIXwzcTAkH6Xiq3V/JXI9/3r/uy2qYz7ipfA9PaG7OXz94Bt0650aqCPjHLEc2q4t8W9u6+DjLWld2XGtYmLncRsvaGXf5uKa22vd3R8t3F8p2yGmZCLp6qwbbi/nY29anJ5b8/IamzPzpiPc5Keta1rzZ+csZutyb6wr6ymlJl1qXF2ipCRj5iXa8+/wLzMuqG0vre7yKusrKqYiZSWlIWF7oDSn3dzd27Jv7ayv8u2yHV7fXZ7h5SasamzxeLczop5e8LccnaEiYyIiouTl5OGjIyYlqOtpp6nqLO6vcDLyMG+t766tL21saqxppqgn5+Ul42GhoaJioOSj5eUg4GA5+LZhYuMlqOYhoGeipP0xaGYrcGgkrOPg5GQjpuSj4WHkYCfuLjTdnyckOjke4HjzbS6on9tgIB7btFu0292dnNxeNZ8ocG1fJ16vIGPr3PJuKyiu6uliYbv3sXDdtfXfn2EhIWNio2V2K1viYWKcay4wradx6GflcbA2qOdm9eLqcaOi3yanbqQnKGRfcyrrrOywtlvbbqO0nSovo+IrddveYCFhISDfHt+fM97fHZ1eHJ1e36AeoDMceBxeX95r6e3gd18gYCBmajDscHFqZOEjbjEq7zIx6CldHSAfZWGst6OobipxK+ui9CCuKqmr53e03OOi3eGnJ2Uk3bec354fIPetaLZ2YvcoNXB4rm8ysW6tcDJdnRpabWundXVpcLWhIDqxc3V3nR0i4XgpIxxepWf09i1l9vgcpKcd7h4dnVzdH2Eg9l1gd9x26uV0+OWmI/EhcqBfn6Ae6Grp5qWh5KelH2Io6ael5SSn52trJ2XiZKRjJiTe3uCo5uFc3FzeneHkYF7gZCUpaa2yb9stIfq03N9kquvoJudpKSjmoWWkoCWqbS+vKikp7GrloKVoKGqoqWynoeafuGKgo98qZLUfdzih5zBtcKzwaqOiZ+3sJuPrJaBmMrJysHVy7vDt3J0bn1tt81vwXNwtqbOcW+Tm4qPcoJ8e3t7fnd7fZmKi4KAiXTKh311dInQusltwpqJgbp1mZOll3vCx9aZidN1i4B2aXRswKmaioa+gHVxn5x6sKWdycKnk7DSnbG5p7anstxvzm1qdmrTu6+sl7THtsHEbXSBemxw0ZeBheivrYKXjpbRecx8vnStd2mPyq3IbcF6jaehn9K/ws1+zrOhi5+To6fJcbaH2cG5m3x0g32ExNaNhsumy3/a8ouIwZuPmoDlzsbisoJ4gHPNwslhVTRsqHVtcquIv5e8kndWZKd4jYKSe7KYc3NqVp51aVp6joKLqJR4e3OPdmGYq8FjqLKFiKWWd7GRa4Vfbn5vd7imnq6ykHuAe6vFqo2npYmXm4Tvz8rEl4efjK3M6oKo0NvI2suemILvgoWmyMZsxLzGx4BbrpFcWX10b1miXVidmqOanJFse5qLYEyYkG54gJ9Vl4N7aX5yVlWGYGNrlltjiV5zgHZxhYmPVY6ginSYVFtaUJycUlahoH14YnyHlo9WqoWBjHyRpZ6Wl5eUhYJqnGdufYGFgIWDWKahm52qnI2ZoJucqJOYlZKIfYWJiXt86oDYro6Mj4Tz5dzW5vbk/ZGZnZOYpautwLnH09PFvnJyb8LVbG12e3x5e32EhIR+goGHiJOhmY6Uk52lp6ivrKimoqeknaSin5efmI6SkpWJioaBgICDiIGKi5CPgIB/7O/qgIWGjJePgnaNhYz+2sC1vc+6qcOom6Slo6+qrJ2fp4CzwL/Ob2+CetXLaW/KuKq0o5KDlpeRgvmC/YWLiIaFhvWIpLOlZ3hlqIGRq4b14NHG266FdW3769u6acbFcHB0dHF2c3N9xKVndnR0YpuosKeTu4eEgLmuwJeXm/WTrMl5eW6ZoryDh4d3ZqmYl5qdq8JhXZuB0Y+60IqHocBfZ4B0cnBwZ2dra7ttb2lsbmhqbXJ1b3bDaNBpbHBuq6Wwec1ydHVzg42hlaaqkYFzeKGklZ2coomMZmRvbZCIp8x+i5iPoJaUfsR2mJOSjYbGwG2De2d1hYF9gGrKaHZvcHfOqaDNyHzLosy+2aGnsamho6evY2FZWZeIgru+l7bEcoDRs7rByGlofnrXqpaCiZuh0dO4n9PZbIaOcbRwbm5sanN1ds1rddNqzqSZ7PGWlojLfrV0cnR1b5KakomIfYWQi3R7jpSJg4GEjo6ZmY2Gen6CgYaFcnN4lJCAbmxocG16hHNzfIWFj5GcqKJbmXzSy213h5uXi4qLi5CMhHeEgICBkJqfmIeHjpePgXKHi4iNjZGcinuKcdN9d4FzloLHds7Ue4mkpbCisJ2GgJOmno6JnYd6jbSvrKi3rKaqnV9cXGNcoLthq11foZOyYV90eXN1XGZhYGBiY2FlZndwb2ZmbF2rb2plY3GyoqtWn4Z6dp5jg4WThnfMztmxo/iInIBoVmJbp5qPiIbIfmhgkZOFzMK77ebIr9Xikp6jmaSZor1csFpWXVixnZaajaW1pq+zYWRwaF5kwZJ9f+fFyIGPhY/Skfp7u4DLmIWx887yhOyOobaPkNG0sqdhqZiNf4qAjpGtYJ961LiqpI6IloyNs8OHeraFTFF6Sh08kIKfrIDQv8DPt5SEjILi085oXjpfk2hgUm5SRl+TfGNATnxhbGNSTmt6TENGOnxHP0RmTER/bntmZl14Vk5ydH1KdHVjc4uDWI9eU2JJTWNXZ5mOi5aVgHJ5c5ium4ebk4SSloTu297ctqW+pr/R23aUusGvvK+NjXrmfH6ZqqhbqZ+ppwN/fn6GfwN+f3+KfoJ/hn4Bf41+gn+JfgZ/fn19fn6EfwR+fn9/iX4Bf49+AX2IfgF/l36HfYh8j30Ffn5+fX28foN9i36YfYR+BH19fn6LfQN8fXyGfQF8hH2DfoV9hXwLfX5+fnx8fH1+fX2JfoJ9hX6GfYN+hn0KfH19fX5+fn19fYV+h30Efn59fYR8hH2KfgF9jH4DfX59hH4FfX19fn2afoR9iH4BfYZ+gn2KfgF9hX6FfQF+hX2IfoR/g36FfQF+hX2Efo19hH4BfYh+EH1+fn1+fX19fHx9fX18fX25fgV/fn59faZ+AX2GfgR9fn19nH6Ffwl+fn9+f39+fn6XfwF+hX8Efn5+f4V+AX+FfoV9B3x9fX5/f3+Ffgd9fn9/fn5+iX2IfgJ/foR/in6Gf4R+g32EfgZ9fXx+fX2HfAx9fH19fX5+fX19fn+JfgN/fn6NfQd8fHx9fHx9jnwLe3t7fHx9fXx8fH2EfAt7e3x9fHt7e3x8fIZ7AXqEewJ8fYd7hXwQfXx8fHt7fH17fHx8fX18fZR+i32KfgF9hX4Bf4R+AgIEAIDK8a/C4pein62UlPOTlY2J49XL176k5IOEhYHYyOHjts69kLSjy7Sqv4eNq8zLqZ+fxNnS1Lvb8sr68O2ej8vRveuT9PuP9PDbqOyPmKeow6+Pof3pjYmbxL+9v7yqk4eQh5zFxeHx9P76k//7zrak2N/h7YHj5PPj5dHDzLSloYCOkfGRyaiei4+ZlYultba3bXFyd3mRoJmWi5rA2YiQkYedoYyYmpWksqzEy8fDvr+tqK6lrrG7ysXGxtLRydbb6d7TytDb0NTWw8LCy8KxrqWmxK6erKyZiJiLkI2C5oKTkZKIj6Cnj6uloZn6h+m8tNHQ7oiWgYOGz723no2Lv4DZz7rqkoyX1MzQz4t0dXpoaWRdYWdkX2tlZm1zamGnrMWAqvKPj6HnwanDoIZktbOtr3jrkZmFgYmszMOmsJiRnbeXk5mHi4OfmISH/9HTzt/Ix+fsgNSk3NfRstSKvaGAiIXjmJ3GkLnMuKWhhvC1yv6E6M6JleXA5fGAh8OK8oDin4GUjpihsfGP4IDy4//h1Nj3j5Gj9J7PjoaFm8S7gIaMorX/0P6ppMzo2sfCz9HI0+rk5NzX29zZ79uuq4OYwdzWy7/PjKHVzcvV7eClofyrsJSit73Y3NCw49LE69DVhcL5iZyS4our9dGHrsPk5u3y3umH94bWybmTtp7QnoDF07ShzNvCu6+blOzOoaHN7YKKgL2TipassKXD17X1qp+GkICBj6KsopyL2NTlmYT8rOLPt623utHdv8HCuKawwYiEnbKgs7iwqKubn7nK1NrV2tzBoo6A3Obz7cPqnqKSjq65zL++0cfE0Nzj1eHwsbiy3IOKm7K/tq23wcXNzoCsnKfA0d3Ov7uirLKqtOXM6NLIzNXloqCQoaKuxcqzqYuBpe7m2u6G3qeMl7K7wp+ir72934KklIyH7/Xl58je18vNmaqv9amzq6yyhsOQxrmTqcXCysPDtKz58qaMxKWduoqdv4L5gauvjM2JmK6nqsGnlNjipYiSgt7vrau53YCXie3ntOWjucO/66X6z4x9yp+vuMCAd4TezZuj3+LH0tr1wd6Q8YWEyZeU5JyCit3ekJKPlIu7saC6oMaYe43ElJPgaGyAe6XKvMmUuavqhZ6goo+Qn/e+o9DAxNjW04Po+YPpxKqusMPEh8ambXN62sfIl5GqqJuIl5OespG3j4CWtKq1zbu6rKWrtai6qZqVhbPBpY6f7syYofrE2NXLyaL8toaUi/H+mJem/YKarqDdv/zBtIH9iIGdsbybvfeCiMC+qpSqus7QiOPojZrs1+Xb7ZbijrGD0b63sLq0mIJ+hI7aisTdzt+Ig/uqo6TJ6P6I8eOqkrmov/6Vj8qH54CkwJKpvXh+fIZ4ecp1dnBvta+nsJ2OuGdnZWStoLS0kKSWdpKEqpmQoXF5jqini4SEo7GssZ60yKbUzcaEdqarnsB2xs92zc27j858hZGRqZR6jOPSfnqJrKmnpKSVgXZ/eIqqqr/LytLMdtLQrZqLtLy6xGu/v8u9xLGqsqCTkYCDhuCS2Li1n6GtqZ+7zczNgIOFioijrqSij5m9x3Z+gHaFjXmEhHyGk4ygqaWmnaCSjpOOk5WerKekpa6up7CwubayqKy3ra+yoaSkqqeYl5GSrJaOmZmNgIiCgoN523iDgYN4f4mPfpOOkIzzgunHvNPS5oKId3x9zMK/p5eQuYDVxrvSfXuBxsfDxZKAgop2d3Jsb3VxbXxzc32CeG3Av9aGp9R5eYXRz7bNoZJwx8i9vnrSfIR3dXiRrKOLkoJ8g5eAeoFydG6CfG1x2re5r72tssjPccOZwL23odaLt6FxcnLHkZi9fJynmYmGcc6ksddvwKx6htzA5fB+g7R50IDMh29+foOKl9F8yGzRxtvHvMHafH6Y2prCf3R1hraudXh3hZfkwOGQi6m6s6egp6iircK3tq+rrrPB1caipHSCobKto5ypeKHIray0wbaMjeiYmoGKmJ+xs6yVz7uvzb7DdLXcd4iBynqW58l7mafBw8bKvsVtym6xpp1+uJe/i4Clr5aJrbulopaJgdS+nJnC1HZ6cq6TeoKTk4qmtpfdopZ0fG9ue4iQioV5v7zMhXHmlr6smpWcoLK5nKWkoI+Xo3h0ipSKlpmUkJKDiZupqrKttLOlkIF2yMfb07HUio+AeJmcraKhsaalqLO9srvIo6ylx3F1hJWhmpObpKGpqoCSiIiXq7WpnZ6JkJSPlrypwrClq7PKioh+iouXp7KflX10j8XCu8lywJaCi5yhqY6XnKejv2yGeW5yysy/waa5uKmyjpicz4WQjIuPbaZ0k4t2hJaVmZaWiYbIyoVylod+k3CDmG7PboqMc750e4yJipyJfcHFlH6Lf9/sp5qav4B/b8TEnsmVprKz1oravYt+0Kq/w8+IgY3etJKVwc20wMDPo7p3yGxtsYaL349ucbzCdnVxdnGkoJKqlsOagZS9iYnda3OIf6rRxdGZuqnifpWbl4WCke62lK6kqrOztmvBym3Bqpmioqiuf8Gmb3d+38zOmo2upJuCiXSbrY68kICVsaixybq8r6mtt6S1o5F4RleIeV12waN2gdGorrGopnuVa1yAbNDUf3uDtmVxd37FsbyQk27RcGuClqSJo9Zxc5qfkXqNlauvcq+raHWxq7SywHnAgqJ71sbAuMe/ooqIi5Dag7vdz9h+d9qUl4+twM1txLqThKOPmcZzb6NrtoCNon6Uo2RoZmdeZKxgXltalY+Ijn92lU5MS0uEfJCSc312YnNpkol3gF5ndomKcW9wg4iGkYSRo4Wzq6hwZoiGfZhcmqFcpKqefb9td359kH1secrBcnB9nZiWipGDc2tybnuVlKWnoqymXKuqjIZ7nJ6YoVmhp6mjqpqWoJOHhoB+f92h/eHjyMjWzsTk+vf1mZ+ioqK8vbe4n6TCwGd0dm58fW1zdHF6gH2PmJiWjpCFgYaCh4iOmpqVlJmbmZmboaejl5yknJ+ik5aVmpuNjomFn5GIjpCGfYB9f4J74Xd+fHtxdXyEd4SGh4buffHc0d7c4Hd+cXN109LHuaaivoDKv7rHcG1uvL23vKKUmKCLioeChImCgpGHiJGUi4Ds5/6Tpr5pZ2iw7tjnoqKE7PHh4YW9aWxoZGh2jYl1enFudIBvZ25kZGBrZltguKOmnaaco7S6Zrear6ypm/GOtKdoZ2a1kZu8doyRg3VxX7GWnLhdopNxe9bL8/qEiLJwxIDAd2RzdHh+iL9xumO9t8y7s7XJcHOZyJq5dWxpdrKnbW9rcYTTts2AeZGflZCIjImGj6aYj4uGiI+tvbCWn2x0io+OhoKJbJ69lZWZnJl/gdSOinZ+h5CYlo+Av7WrvLS0ba7Ma3x1vm6H38d0jJSmrKuwpapbqlyYjIZsroureICJlIV9l6WUk4l+dcq4m5bAzW1xba6XcXiFgnyPoIjRo5Vpb2ZncHmCfHluubDBc2HOf6GYi4OHkZ2mipGVjoWIlnVteoR9iIeHhIN2fIiSkpuYnZ2UiXpzxL/V0rPEgIN2cYuLnI6SnJOTk52gm6CrjaGdvWhteYiSiIWNkY6XjoB+enWAk5iNh4R6fn57haCQp5SLkpyveXdxfICMlZ6RinFrf6epqbVnsI59gYeVm4OLkpqUql9zZVxks7Srq5WcoZOeg5GSuWx2dnJyXZNic29kbnl3eXd0a2iirW1hd2xpc15ueVy2X3NzYKVgZm5tcH5xaKitiHiCe9rqraCYsoBtXKOlj7GJl6apv3a+rouE38Pd4uSgnqvopoyOrbynrqyxjqBhqFlcmXmD3oReX6e0Z2RjZmOalYmeicmrn67Cgn/ggJKoldH45O6fr6nVdo2PiX14hN60hZOPkpaYmFumqFedkYuTk5OXd76vg4uL/OzprXaVe1JoSzdhfEuKmYCpsbS2ytHU0cvQ3MrXw6l8OUdqSExkm41ydb6Nm6WgmWBpRT1tSnpvODpGk1VfVjsxNYV6hWO/YmN6gntni89wcYSKh3V/hJynbZuOWGCXmZydpGGkgZl86d3Z0+Haw6eopKXrhMbg4ON7cs+QjYiZoa1cpJx/dY1+h6BaVotXk4V+hn8BfoR/h36Ef4p+gn2SfgV9fX5/f4R+BH9+fn+EfgF9iH6CfZV+AX+JfgF/jX6CfYx8jX3BfgF9jX4CfX6GfYV+i32Dfpd9EHx8fH19fX5+fn18fHx9fX2EfIJ9mH6JfQF+hn0HfH19fX5+foR9h36EfQF+hH2EfAZ9fX1+fX2HfgR9fn1+h32CfoR9hH6CfYV+g32SfoV9iX6CfYd+AX2KfoZ9C359fX5+fn1+fn19iX4Df35/hH6DfYx+hn0Ffn5+fX2IfoN9in4GfX19fn59p36GfZN+g32zfgF/jX6Ff41+hn8Bfox/gn6KfwF+hH8Bfoh/hn6GfQJ+f4l+AX+Efol9i34Nf35/f35+fn1+f39+foV/hX6FfYJ+hX2EfIR9h36CfYd+BH9+fn+IfoV9inwEfXx8fZJ8Cn19fH19fHt8e3uGeg57e3x8e3t6ent7e3p7e4R8hHsBeod7AXqKewV8fX5/f4V+AX+Efox9AX6EfQN+fn2GfgF/iH4Ff39+f34CAgQAgLv3vqbGiJCC9qKQwrLgh4vBvuqLjIaBgtn2xKuzy42LwcXq/Nflq4yQ/YCQiqX6tbGitbjaqMq4vKDh/LawgdXJ1Yro3Of7kYPxqvOG99HEon2V2uL0iJqgsKiZh6KcxLuumae0sdDu8uT67tzc2vnr79HQ4OLn8POIgPnWzcXDgL+0n4/+qZlyaGC3tKW1vL+5ZWttfIB9k52im6m5xMjciYaEgOf9l6Klq7q8w7uuu9HGvrq+urvAvsHO0MK/x7+xtL7c1tbDxMS9v8Gqn56on7Cam666urSpobSysaCWmo6RsZ+3rZ6auaueiYmP/vD5hpOInJaJ7uff4anM3vSDgOWhz4jvyL3859SCdHRob2dtdHJsa2JlY7OvuL2ssaG1cZGRspvsmqR4osiAt8qmks2HxaS+792EwJqquc7++cjGy7Omn5iEjJaS/P380M/l3bSrzv3tsZOy2Pjh2cHGs8nSg4iMjrWw75WtjJeOt66MkebK1bid63e5t6GMlbu8gNiMk/vu5qz/z4jchfLhlIKE39KKjMaI/u6M/ojxgb6WmbrFsq6mkIyD+r7Bxs3V2tGzxM/BwcyUwIKE69jGkavC19XL0p/em+7DlKjl+pr+8K7Xn7zA0tr86cONvJTP2fL7j9CTpbqnsNu6suXF0YP8gfTv/f/t5fDw+sjFsLnJY8nT1MbLzL3MzbmdoJiThoiFk6OgooPdyuKAgo6fj+LTo5LLhdSI+sTA84H3gvH6pa+8+PPHr8XPs8XAyrSytcHTyry3nf6ikavSzaSjxNL375Ox1MbDm9zR23yKst6flt6MrYTKgMXAtbSws7nO6orkw7iT+Mzn4Pmcr7K2rJ2Qpq28obyuq7OnorbJycHFzLy0wbm0qJyl/qa4s5rDsqfLjInqgP6B7cbc6fbb0s/07e7n0NeB6+T6zubF1Muzutva5oTgj/zojaGVhPv2jpT2ncbM4+jfxqOhosa127TCwMzV15qzgJyQoJ+qzNfixKSPuZudk/35xJOKu52pps+Eh5biifvZ04GUitXPqZXB9YXY/4fq5ZnM6MG/1tnDgp6OgITL1vX02pPL/Kblyorc27/t4vTe24DUz6SsgHN5pMCteGllgrLxiY6Dtojqw5W2qcPPp5zIsoC3zceWhPuHguXky4zIgILjv76s0KuAoaSJ0IyUfeG/w9u5zInp05Jsf4mMp4GBobxhwN3V66G/oPu2y7Oei+XghNON1aLXpsSQp5n+ua2w34+3xdGH7qLGqLCjo6CDrJuHn6i8xqOTlKCosKerrcigtdyEjoXyqbiZ/uOfouz9wtKxmbSgfIfBu5+j5aGhGZ2Wgp2v1+GAtIb1x9a7v7S2r/es84vkxrSAnMOakaJpdmbAf3OhmLptcqKhx3Bwa2llqcKeiJepenefosDPr7uNdnnUbHpxidKUmIqYm7qPqpechr/TlpBrr6ivccS4wdR6bc2S3HnfvraXfpDC0t54h46ZkYh3kYiqopmGkZ2YrsXKu8jCtre0zsPHsK65vcHIy3Ns1LmxqKqAqKCQgemjl3l1a8zJt8jS1s5yeH2PjomiqK2eq7e8u8x7eHl3z9h8hIqNmaOkopWcrqegnJ2am56foaqrn5ufnpSWnbmwsqKhpZ2eo5CJio6JloaIlqSinZeMnZmYjYWIf3+Uhp2Rioufl45+gITo5+x+h3yLhX3Y19Hap8TM33WA2Zu7edm9tufWz42ChHaBdoCHhn58cnZ00M3T18LKt8h9lH+UhsqTrYSty3ypvKOT2oa3i53AtGyiiZGbpcnKp6CokomDfm5zfH3X2dm2tMO/n5q10sech6K80Mfcx8WqvL9wdHeHrqXXg5R+hHyYknZ7ybS5oJHke8DDsY6Urq6AxHiB39HMkN69ecZy1Md9cHPHvHt5t3be2IPrddt2uIKCl6mUk46BfXrenqSjqbKyq5egrJ+dq3yhcXPQw7J+jqCxr6avh8yV3KODj7jIgePhpM2NnKKstcq+n3esm8XS5PuJu4GPnJCYuqCfwK2ybdBqycfQ0sO9y8bQpqaWnqmAprGwqqipnKirnYSKg390eHeAi4yMecq5z3Fxeod6xsWZjrdxwX3mtLXdd+p96u+Ol6HJx6OSpq2Vo6GomZeXoK2oopyH4pqHnsS/mpuzvN3Rf5ixpqqI0MbZgIap0ZKLxnmRqamnqKWgmpaUk5ysv2/EpZ6D4rzWx9uHlJiYk4iAfJKRnYecl5KXjoyZpqahpquelZ+Ylo+IkeWRnZmCqZiOp3Fvwm7Yb8arvcbQu7Kxy8DIw7WxacfAzqnApbium6i+vcJvw3rUw3R/dm3S0nZ5ynuYnKmyqJqDgYKai6mSmpaipqx/kYR4f4WMoKmvmoZ4k36BfOXauYl6qZ+mmbKAbG55vnDZwr1yfXW8uKSTwfd/3/6J8+2RtMaqq7e/rHGDdmlrrLTKz7uCwfGbyrB0wb+jxr7Nvrhpt72VrYR5fKfCrntraYWs74SCead+0a+Jqpyqs5eSxrJxmaqtg27ObG27xbJ1snnIrKmh1bKCp6yO2ZKcg+HBwdq7z4bi35+AcIWOla6GiqfKZ8ff0eWUrIvboK6Fd260umy9gbqKrZK1ho6B2pWamrRgdnalcLSEt5mml5eaeJOGdomQq7KUgoOKi5aLkJqsf4qoZm1pu42bhOTWm6Ld8qu8oJO1p4OPxb2hqOCWlZCFepCaydNynHfkqLCbop2flN+TwWiypJKAhKGBe4tVYVCbY1iGg51cXIuLqVxVUlBNgJR+bnmKZ2Z7faCtiY1zYWK1XGhgcLB5gHSAhJt7jHuAcKu3hHxaioiSXqORnqxlWaqAyGzPuLadi5m1zdVueoGJgHpufXaUi4d2fYWBkJ+jmZuamJyVqqCmlpOcn6esrmBdu6Ofl5uAmJCGeOCqoI2NgfXy3/D6/PWHkJWtp524vryotbq2vs12cXFrv8hud3h/ipOWkoyRnZWRi4uHipCQkJeZjoqOj4iFiaKeo5SQlI6OlYOAfn99iX+BipWXkYqBj4+Ph3+CfHeIeYeDgH+RioV6eX3k4eZyfXR9enPNzsfUssTE1W6A0J2zbcK0ss/MzKCbnZCZjpyinpOSiIyH9vT7+OPw4fCPnW94bLSQyanM33+hrZ+V9Imtc3+TkFN/dHl/hp6ijoeIeHJualxfaGq+v72mpa+nkZKnt7CThpuqurbt3Nuot7VnamqSqqLJeIVzdXCDfWdqrpudkIzxg+Lx3ZWZqqqAt252z8K9ftG1b7dmw7VuZmq4sG9trGzNyHvfa89tr3RzfpB/gnh1dXHMh46LjpWQjoKDjIN/jmuGZGi/tKdyeYSSlYmPdcCWzYp3gZekb9PXpMeBiY+Um6yghGeil8/W5POItXeCiYCFopCQq5ufYLRbsKu1uauksquyjpKDhpOAj5qalpKWipOYinV7dnJqb3B2gIKDc8K0xGprcH1vuLuUjalmuYLwvLbbdex99tl+iYyrqo+Bj5qHioySioeGjpyYk4x72qKOmbm3lpeotMrFcYibkpeAzMj6jY+lw4h+wHOIm5aUk5CNhoWCgY6Yp16kkIlzyLPKvtB+hoeHhXqAcYN/gnWIh4GFfXqHjo2MjpKIg4qEg312gNODi4p3mId/kV5eq2LBY7Ccqq+3qqGjsaevq6SjXKyrs5aqlqOdjJWpp6pesmu9rWNpYV+zu2ZqsWp+gIiNhn9ua219b4J1eXiBhYhrdm5hZW10foaHemxoempna8rBondtpKiwjZuAWl5lo129rqhkbGeno5iOy/577P6I/u+LorOanqmwoGVtZVpZk5ussKB2weSMsJ1isK2Vrqu4qqJbpquJtp2SkbDDu4+DhJq15Ht2bJtwtJp6mYyUmomGzLlpgpCOc1irW1uYp5tioHaxnpyY2cSYwrii8aClhd2dqOPHnERwipqAiaSxucahss3zgPb+5/KRpoLTo6JoaWGcqGKte75wiG6Uanp1zpGUh4FET1SPXXwzXGh6X2ppW3Z8dH+Gp6+RgX9ygJOPk5igb3WOWl9bnn6Le+HXq7XY6pumkorGwaWy082yxe6Sjop/doSNxcdrjGvglJeHjIeNhNCCnE6Mi3uFfg5/f39+f39+fn5/f35+foV/in6CfYV+AX2EfgF9i34JfX5/f39+fn5/hH4Gf39+fn1+iX2jfoJ/iX6GfYd8j32EfoJ9yH6DfYZ+iH0Ffn19fX6UfYh8B319fn5+fX2EfIV9A3x9fYR+AX+SfpJ9CXx8fH19fX5+foR9iX6FfQV8fXx8fIV9Hn5+fX19fn19fn1+fX1+fn59fX5+fX59fX59fn1+fYp+AX2RfoN9iH6DfYZ+hH2JfoJ9hHyCfYt+A39+f6R+g32FfoV9A359fYR8BX18fXx9ln6MfYZ+A319fIR9A35+fY9+AX+EfoV9n34BfYh+Bn9/fn9+f45+AX+NfgV/fn9+foR/BX5+f39+pH+FfhB9fX1+fn9/f35/fn5+f39/hH4IfX1+fX1+fX2IfoV/hn4GfX1+fn5/iH4Ef35+fo19BH5+fn2KfoJ9hX4If35/f35+fn+GfoZ9hHyGe418AX2EfBJ9fX18fHx9fX18fH18fHt8fHyEe4V6B3t7e3p7e3ySe4R6CHt7fX5+f39/hH6GfYR+iX2HfgZ9fX5+fn2Hfgd9fn5/fn5+AgIEAIDSw8mvgtnl/Zinq5L4gpCOh9rU8O6Q8tvgwrW147abgKm1k/yNxea6vb6dl6u1n5CpoaKXrY+KpMXSsOfl/ozT+ILbpJu6yuu3p6+loba6tbeeg5i0tbTFwrK7sr2X+YaXqbOOnr21seHZ1N7O4NriiIDv+vrY6erS8o2Civfc2oD36bqppZ2B8Mawjpx8c2vLwmp0aWtzdHyGjZqYlp+De3x/nsqt4eXsip2lmqalqrCopr+xuLbDxcXDxsDEwcG7u8W+vcrSzMrJxraurKupqaussMG8wrnCv7qys7WjoZqjrae5s7qzsL6I8IqSh/6Kl4XujKO6rbnG0r7J64rv1oDlveLe4MWNd2xuZmdyaWVcXm5jYLC0XKiWpKGhjZywZHCNyYiKxK68kq//lqWA1PXYnazHvNmBlITi2fGEj4+A8Ynsyonu8fDq3ePHocXi+8zV7OjW45SOja+pj316vtfKzMLLlX2L0/PljJ3AuaOipoqHgIOsebWum6duwYCIkYDt7v3p0b6swMiI5IH0zfaH/vSG7ISEgo3cjJ31992esr3xg4Ooq5SB2JKtxtjDyc7V3rzJ0de5jr2a+/yQhpO/vtXLs7uDurTA99igj6jLq8Kfv8eWm6+574C7jcqdldOz2fyfjd3GlJHhu8Pe4PHw+sS9tNPt6MPi+YPet5+dr4DAurGvrsLj5e/X0dHJrZukj4SGtJGuwp2a1dnfie2+m4OY9qu2kJipo5rah8OQo7Spn9CDrbiMipn9kajDk4+Tpo35wbDUxr/Z5sebv4D/sJWMg4bH59eaerrCs8HXl5ST+oGdyM632NG7p5yqvbq63uTt8O7189q/qKGfwavTxIDAs73Do5OtuaqtpcC+usXDxsjQvrjGrJjCxriroK/J6oOE8PiCkInh39no4di9u7bAqLzByc3l3bKUjYuYtrbEwebYysLD/oDT1Y2WmPeBhYT844+PjI6zmd6IlLzJ/4Ts0+TmiPDhs7bIleHL0rColO/e7vXJqcO0stb/hN23jYCOiaOVh4Pz/YrcwM7HqpC8qd+E9oX2vOfP1NnxntLc9IHt8oDl+uney5X6oZ285YDY0s7L0/TjhPbWu7mCnZeS6vDdl+6Do5OcsdHT08XOv6WSlNnwjoOKfauK8OOGgvyO9/LviPTOkYi7zKSP9dCf84C+uYnMgtGli6rFtrV5jYCDhnqAgHuFkJymhZi60HuawPeJoLCfjIKB0+Pnt+CY5r2Ov+TdzuPaxYeon6y6pfSN7fiVlJSTgueLmrK/ldZ/25exyqKqzeiKlvK8kvnz5rmJma/FkLrk/enp5L6A7pzGuPCBicDnw/Ke5NyolYeBkLOszZbzjZeTgYyeyM+ZpICpnJ6JcK22yHaAgnPLaXRwa7KuwL9uvqu2n5aTupN9a4yTe9Z1oruXmJt/e42VinuUiIqDm3p1jKStlcPA1Xez1G68j4ijq8WekZiQjaChnJ6KdIWdnZyrqpuimqKE23iDlJt5f6CakLiwr7usura8bmfF0tCzwMOvyXZtc9O8uoDQx6SVkYp03LiqlaCHgHXf2HiDc3d/foWQkqCdlqGKhISFnsemzcrTd4OOho2NkJSQjaOSmpagoqGfo52inqGZmaCZnKiwqamnqJiTkZCOjZCSl6afop+noJ+YmZ6Pi4KIj4uemp6dm6R854GEfPCAinzcfpK0qrK+vbS5zXbUwIDUscnGyrqOfXd7c3aDeXVrb4FzcMrTbMavvrq8obDKbnd+p3WJ07zGkqTafoxyw+HMiZCnn7VndWvBscBob3BmvWy8oXTP0c7GvcOzl7bG1rK4y82+yYyJhaCchnt6s7+6urK7joCKwtrMd4SemIiGj3Z3b2+desW4qrZyuHJ0eoDRytbJua2esrB1y3DWutZz1tF1yHBzcn3Jeone4M6dqa7WcnORkIByyoGQprSjqqyvuaGjp6yYfZuE2Nt4coCfoa+nlJhzqqufyLeKf5Wjmb2ducGCg5abwGaXdrWLjc+wy/WafLyngHu8n6W3ucvIz6SgmbHGw6C7zGy1mYiGlICioJSTk5+8v8Syr62qkoeMfHd2pYilspWOvcTDdcyrlHmJ7aq4lJuzrKHfhbiBjpuQiLh0lJp8eoTYe5CpgX+Bi3nYq6TEtrLJ1ruYtW7jpJKKgoC31suUe7e6p7LDi4aE3XCBpa2as66gk4iQm52btrfDxMXNyrWkk46Ho4+wo4CklZuoj3+Rn5WXjp+cmqGlo6iwnZ2mkIOmqqCVkZWnv2lox9RseXG5u7jDv7amopykkqSnqqq9uJWCgHuLn56pqMe4rqWp1WmzsXB5fc5namzPwHZxbnCNer9teJGbvGG1pK+wab6ykZeefKqeo4+Hd8nJ0M6xm7Wpq8Dhcb6jc4B1c4J4cG/L0nLJrLmwn4ysot6D+oPxr9C0uLnOj7W80G/PzW3D0sC4q4XtlpWtxm3CuLOyt8u/a8m4o6F5nJyU3uPTjOF+lYaJmre5uq+0p5aDibzXh4GMfaiAzLxycM9z0MjCb9C2hoGjt5mL9dii7n7Bu4zUiuK9jq/Uwsd+mICRlIeLjomSnae2i6C/03iSq8xxfol7c2dpsru9nb18v6SCtNbPs8HAqnVyZZSqeax10NiMjZSQetmCkKOviNF9woagtZGatsJoccGcfNbQzbJ7jJu4hKPE08jJw6d374+tpuN+garHq9mNxrqRhHVxgpqTtYTafomBc32HoaeBjYCRgXttYpCToFtiY1qlVF1YUo6QmpdVj4CSfn14lHNjWnJ0ZbRjgo9zdnplZXJ2cWp8dXh0hmtnd4iOfKKluWieumKngniMkKaFfoaAfo2Mh4d5aniJiYeVlouMhoxzynB3g4hqa4R7cY+KjpqPnpufXFWisLGUoKaWqWRcY7qlp4C3r5OJiIBt0LGtpa2YlIX9/5Gdh46XlJqnprGtoKyVmZ2css6qxcTQcHl/d4CBg4OFhpKFioaPkI2Ki5CSi42JhYyIi5edlpWWmoyIgYF9foCGiZWQkZGXkY+JjJKEf3d5gn+Mi46Pj5V75Xl+dtp2gHTQcoK7tbe5tKuzv2m+t4DGsLu2uKySiYuSipGdkY2DipuLh+//g/DW4+HjxNX2gYhwiWWQ+uDnkZu9a29itsi5cXeKhpRSXFSgjZRPVldPk1KLemK2t7WuqLKkkrC4v6aot7mrtIeHhpiWh4CDsrWzsay2koqWucvBa3WHhXd3gGtsY2WZhd/f092Br2lrbIC+t8O3qqOXp6VqvWXAsMNnwrpmsGRnZ2++cHjPy8CcqKfJaGqCfXRtyXh/k5mJlJSUnIyJhot8bH91w8VpZXSGjpGNfHtmnaKGpZh1b4KFiLmkubxydYOJoVV9ZKOBhsmyy/2Yc6WUd3OkkI+am62uspGPiJ6srImjsVyZh317hoCRlYuGhImho6ealpWRgnp7cmxtoIegrJWOtLazZLeilXuH7cPHp7DQyLb2ialzgYuDfrJqhYlwb3jCboGZenJ1fXTNqaG+sa7AxribrGPQpJaVjYi1zcmdhrK6qq/Cg3l7z2d4lpmMoZeNhXqBjIqOn5+noqqvrpyKf398jYObkYCOf4OLf29/hX2EfIaEhImNjJKZhIuNeneOlY6FgIKWnVVUr75fZ2OgqKizraOXmJCSg5eYmJqsoId7dnJ/kI+Vla+fmZWcvFyamF5jaa9UWFuxsGVhW2N0aKtcYXd9jUqMg4qMT5OHdXt9ZoR7gnVwZK6wtbijkaqZmavIYqmVYoBlY2tkYF6zs2KxnqOclIKcmN2C/IHworqcoqS2iKKlsl60s1yuuKWbj3fgi46grWCtqKKepLCrXrKkl5Z2sLSr2N3Ug998int8haCkpJealIt3eKW7gHuekrh5q6FiYK5frqSjXLGjfn2aqZSH9+O57nvLwpvun/espsn6y+GcwYC4uq+0urW8xtLgrL3c8YCPm6tfZm9pY1lboqaol69qrJB/vevYtLe4nWtYUIyrX3xmwdiKiXBqZdmBk6qvlfGOtnSSqZqXrbFQWqKOcsPAvrh1gou2fJStvLSzrZRu6Imhmd13fJ21n8qDq6mKfXBsdoqFnnrNdX53bHR7iolueoh+hH8BfoR/hH4Bf41+AX2afgR/fn5/nH4BfZF+gn+IfoN/in6IfYJ8l33Cfgt9fn5+fX5+fn1+foh9AX6WfQN8fH2IfBJ9fX5+fn18fHx9fX1+fn59fX2FfgZ/f39+fn6EfwV+f35+fqV9i36CfYR8BX19fn5+iX0Lfn1+fX19fn19fn2EfgN9fn6HfYZ+AX2RfoJ9in6CfYh+hH2FfgZ/fn59fX2EfAF9ln4Bf5h+iX0BfoV9iXyCfYV+AX2GfgF9iH6LfQF+kH0Efn5+fb5+B39/fn5/f3+gfgx/fn5/f39+f39/fn6GfwF+hX8BgIR/AYCMf4t+A39+fod/A35+f4h+BX1+fX59in4Ef35+f4Z+AX2EfgF/h34Bf4V+hn0Cfn2Sfg59fX1+fn5/f35/fn5+f4h+hH0Gfn19fXx8h3uQfIR9h36FfQV+fX19fIl7B3p6e3t7enqFewF6hnsOfHt7enp6e3x9f39+fn6EfQR+fn59iX4FfX5+fn2FfgF9jH4BfYp+AgIEAICmke6jkYaywM78kI6EkJD2wcjX0t7j0ePy0sLP0cKlkJ6IiIObz+3gkuTsiJCom6uuztfOyMO0jIycmr7UgLeon/ei5+O18+3U8oiE8NbF19jH2M/h1cbY5+nH09O2qqGXm4SKh4nVsp+coanF85qzob/649La8Pnj0eD39ICC8oD169LF18+4tLuki/HSsIHMxGVqbGhmzmlxeYuGjZWZp6zFsZSWrsXulqytnpSkoZyhqLjCzcbMxL/JwMHEuLzAsbjD0tXXxMq/wLm5q6mxtrK4x8jIz83Zw8jDrrmyvq6xqr+qnaisqpT2h5eKk5eci+aWgY6UrL3Gycfp9sif0IDSyNnVqnm/tmVkYl9mtlemqK2nmZimm46qsZmUjqW+tXSy1KZuktHVwoG70N7TvsKQu9TWsNfz9eHc1feBj46R7pe9gNPBsNrwsdXo6ovUwKiR5Mm82YB9nLGPqaWTuMmu4qyW2qqI8ND8lZ3Cwa+i6pSXvZjLeWl4jcPQzc78qICV/YT86rC5v93QyNjTgNSq7qObj4T7jJ7wpJ2JgdCqq+N21o3U7Jqn5IujmKvD073Vwa/Cw8rawM+6y9GNorKlmKKhnNrC9ILN9vHb79Oso5XUs428mo2Rx7rvy//v6tGMqIV+5L/svZvFlZ+nwNfZ/uGzw7iIwd7KpsLV4LSR/IDMvo6Kh4SswtDO1OTJ3+jR3MS8zMCnhojXmfDagL6Iu9PD5Yp52MbGtLGfvbbDvbqumpabnKqZo4ydpbKuq4SKnJf72tPTt4+a56G/j4T23XvQ7I7xsp/LorGCiKaVnq3FwrmnwsfLvqanm8O2oqystbK9vsLCyb20qqqor7vh3oDJs7i227y6tdPl4ae4zM/WvKuoob/EzqKPmrnE1oHXu7jf74mhif3n3Ovu29O0uMa5wcq86ebIqY2eloujyeCG9e7kguDa6NHp8NvHyMras9C2wN6Qj46i4OyWt8rti4XT4t3d4d3Lp6uQs87Hnpaqk/2H7qnftIj1+ouI4Ovt/4CJ/6CRjI+R+IPk3fbp+6G+p+aZ4q3TyoWqqdvNq8bD1PjQvdv7junuor2B3u/hrene4+W34f6HhO7c6IDMqNzLh7aIrq7W37ikvtDAj7bcwImDg866peupyantjuDjsdmAjYKE+NHCu5nlqJj/g6+02L/LgLt2ccycdqZzZm99jICWnZ++trSioJGVqbjXiHaAjvGK5I6HvICblI/voMb35KOX5IOinJDdvs+d+q2ft6SJxa+m+POO0fiLpZXSh8yBgNGezMWuueD/4+Kysqaop4uR+bGZn8vS49zd0ubTwaCtlqLEmfzf0snLka3AvZLS//eMw4vViYiF6/yp9dGNsICBdsqHenaQmKbKcG1rc3PCoqiqpq2vo7PAqZajp5yFdoFvb2x/rMO3eb7Dc3iOgpGUr7asqqSZdnqHhaO0baCSjt6NxsGXz8ay0HVxy7epuburvLLAuKu5xcmqtrielI+EiXV4dnfCp5aYnqq634aZi6DOva+2w8+8rrvQzGtty4DMybSourCfnKKTf97HsYfY0m92d3Fw3HB4gJSMkpiboKrCuJmYqbHSfo2Rh4COioOLkJegqKKonpunoZ+ilpabjpWerLCzo6qhoZydkI6Ul5OYp6enrq20p6mnlZ2Xn5WSkKGOiZGWkojrfomAhoaNfduJdI6Wq7S3s7PQ1LyYwIDDu8HFpoLSy3Nyc3F31GjCx83It7HFtqzFz6+pnrvWx3qq3bRzjcLHtG6Wp7GxoKWCoqu1lq2/v7Swssloc3Jxv32eb8CqoMTSoLzK1Ia+rZmE4s7D2Hp8j56DnZqNprSf5LOh4Jt21LnbgIScmo2GzXuDqpHQhnSGncrUubnci4B+43TgzZ2npsS+vsK7bsGgzoiBfHbdfIbdjYl3b7ueoOF1wny+0IOSzneKgZGeq5uuoJOfnaSvnqaYtrp4hpKLfoeFhbik2nemyMWyxbGNjIPEqIm0h3yAqZzEqdbV1MeNpomA1KHIooemgYuRobGxzbuXppx3orqoj6CvuJp+4YCroXt0dXGSpKurtLuoucOvuaWerKCMenzJk+zUfLB/r9rI5Yt+1cC8oqCQoJymnJ2XhIKEh5KFi36JipaUl3R2g4DkzsPGrI+Z5piwiXvx4H/N3oDbq6DBoK94eZeKhI6hoZqNoqSon5CMhaSci5SQmpafnqCeq6Kbk4+Qk5u6t4Cnl5+atZicmK69wYyXqKuynJaMhqKlso5+hqGnr2qvmJe5zXGCcNK+t8PPu7SgorGipaykxcWtl4WQiXuSqrRuyMrAb8K5xbK9w7upoKe2mayZp8d3cnSDv8h3jZevZWOkraurqqmfh4p6kZ6dgX2JeNly1J3NpnbU2XZzxcbG0oB01YN2dHZ603HExtnI3Zatl+WS4625rnuZlryylqqwucqun7nTdMHHjaF41tzensq8xseewNNsbce0ym+wmNfMf6qBnJyywaOTpbWpg6TBqX16ebOkl96nu5bJdcDHobtseWxsy7GppZDenJD6hba528PQebt8ddmleq98bXeGmoCksK/Rysuzrpygt8Hch3aCiNR3wXV2o2x9e3XKjanUxISBzWyGgnrRt72F1ZuSqpl+tKSe4eWMzueEo5HSiMB/fsWYyMOllrTNtriXm5KWjn2H7KKNkrC2xb/As8W0rpKbi5CqhejZzcTIg5ulpH+86t96o3jDfHd309qd37J1jYBnYbJyaWd2e4imW1VVWlqZiIaEhoiHfYuThXh+gHpnXmVcW1lrjKCRZqGlYGZ1cHl8kJeRjYiAZ2x1dYyZX4yDhMp/p6B/qKKUrl5dqJ2RoJ+TopmgnJOgqKmSmqCLg393fm9saGm1ppyjq7a41HmIe4utopaWmauflKG0r1xfsYCzsKCWopeJi42Fc868tpTy9YaOjYeD/4GKlKieoqSkn7HHxK2pr7PQc39/d3WAfHh+hIiQl5GTio2SkI2ShYOEfIONm6Cjl5mTkY6MgoKDhIGGk5aSnJ2lmZyXjI6IkYeGgY+FfoaHiIPpeYB4fH5+d9V5cKKktLewq62/vrWgt4C7s7O4ppP39ImJi4qO/oDq9vrz4djy4Nrw9crDt+T/7Imj+NqDkLS6q116hIyNhopuhYmUgpCcl4+QlqNWXltYlWp/YKaYkbK3lq+4wYiwoZGD7OPd6nuCkJWBl5GMoqqa/dfK+ptrw7LFdHaCgXdzvmx0n5HprJivxuTssrDMeYBt0mjNuZWcnLO0trexY7WYtndwa2vHbXLGfntsZKyZnfWBt3K6w3KFwm58dYOHkIKViH6IhomQg4l5pqppcXd4anN0dJ6LxWuJpaGUppV3ene8oIirdXB0lYmnjre9v8eTq5+ZxpCxknqRd3+CjpmWrKGHkoduj6KSfYmVnYt00oCVj3FobWiDkZWWm6SXoq2anpSMl4t8bnG/kvPffaJ1s/jd7ZKI1crCnJR8ioqTiY2Gend5e4J2fHJ5e3+Fh25udXPZxr29sZmi/pavjX///IvD2XrUrKK2pbJwdYt8eIKNioiBj5GUjIJ6do2KfoaCjYePi46Nk4yHgn6BgoyenICMgomGl3yBg5GenneAjpGVhIJ4d4yPmHp1fJOTllePg4agtmNvYrmkpq+3qqOTmaOWm56Xr7KciH6IfXOGl5xfqbGvYq6prqKrqqaajJShh5aKl7BpYWNwr7Rjb3iESUmBhoSCgIF+bXNpd3p7a2hvYr1jupO1mWi5wGZksK6vtIBluG1iY2ZrvmGtscKzx4ydi+mQ7LqimXOHh6mfhJOgn66XjqS2YqCqfo9xztjmlbSptbSRq8BcYa6csmWgjtvafJp6ko6hsJuKk56Wd5CjjHFydKORi9GmtIStZamylalfaF9crpqZk4bbkYz+ic3J2snQcMKRiPzCjtCUhJCgxYDJ2Nv//P7f1r7F2+X4jICHirhorWVqml9rbGe4iqG/r2psvF1ycG/Fubt3xpSGq5Z6pKCe2OmSxuqKoJ33oNyWhLSV3dypgJuxo6aKkISJg3V+4ZF/gJiotKyupK2bmImQgIKTeuTd1cjSgY+ZlnOz29Fxi269cWhqwceX1ZxjcAN+fn2HfoV/mn6CfZJ+BX9+fn59iH6Cf5p+iH2PfoJ/jH6EfYJ8hX0BfJF9wX4BfYd+A31+fpJ9gnyFfQJ8fZF8BH19fHyFfZN+hH+Efo59hHyLfYR8BX1+fX19hn4FfX5+fX2HfAd9fX1+fn1+in0Efn19fYR+BH1+fn2Efgx9fX18fX1+fX1+fn2RfoJ9in4BfYp+hH2HfoN9hXwBfZp+AX2Yfgt9fXx8fX1+fXx8fId9mH6HfQF8hH0GfHx9fX1+hn3DfgF/hX6Df5l+BX9+fn5/kH6Ef4J+hH+CgJF/An5/hH4Ff35+f3+EfgJ/foV/An5/iH4EfX59fZB+AX+FfoN9iH4Kf39+fn5/fn59fZZ+Bn19fX5+f4R+hH+FfgV9fn59foV9BH59fX2WfIV9BX59fn59hH6FfQN+fn2EfhJ9fX1+fX19fHx8e3t7enp7e3qEewl8e3x8e3t7fH2MfgF9kn6FfYV+EX19fX5+fn1+fn59fX18fX5+AgIEAICfhsbQ9t+vkcKow8/a/Jz329KawLPGg5KAwo/AwbKGipKi8+3L3qmWi//j/LWuqri/64D38+TZx5iblqTBpZ6u0/Ds3cuwpsnRjIPd293o1fbq4tHJ6NbC3cPVt5OFi5aPobOvs7nK3MScoKaotbrZ1MfhyMuxstL1+u3+3dPjgIDdwqusx8nRvZ2ol46CiYeA4pp2ddrTbdHYz3PYf4SEkKCvs7/ciZebnqCdnJOKkpiRlqCpt7vM5Nq5x9XKrqnCudTJxcTHxMq+wbWvp6m5vLq+uLy6xs/Dyr22tby+tKmWpK2mjJOIj4eFjYqflaGGrvngeH2axszQ0eXgzcPby4Dp4M7ZgW9vZmRzdW1wa2JcrqydjZeZkpmbsJGYjaxjZquhfHub19jAjKrZ2e36t5O0nMPgwbu8t6mQgKfzk/jt3cKh6s/lwuHw5dXjq6SNg8SatKWXjpusn9bt8azO67KEgdSN3buOmfSDh4qUgID37PvvrJWCfo/eqenbhtzVkoDvhJeLiIWBoZvj3qCq3v3fnKK1oImjm/+y0LaThv2TgsCq44Sst9qO+IuvnZamq9Ckk4ytuq36w8bLiuCUgO7k6cr8xNXyuvq6vrqx1PbtxqKeqs28uZ2lvLO+zs+rj8eBgaOEu/Prz7/WtYz7jb7U4+Tg28uot8rm5N/R1N3DyYC1v5/fk5Cno6CeoMS1vcna5drl0NXBw761lIqRjZWWi4mQkJalyb3Q6PuG/N7Cq62kr6mgvbHFqJq9w8rUtpyB8IiCrqKq24SJ9uCxmriFqqDX2bb8usLco7TNp6ibr5mZlIuZprCwssLbxrKnuLPNvaabosDDycPCyraxtcjJtYC7y7+8ts3ewb3N0+SvvrHAzMzTutvwwLXDvcHE0PnJytXY1svGgN/a2uDK2PLT7/CMhN6H9dvbxeDA7cno94j5y9SRpKCQguWZiYOl6ZqZpYXg2+WHhK+Fm6e89PCSkMW4sqfL2Kz+j/KRlOLTqLeN9u7k6dDzl8f/i4LsxY/n3YD4nrqZkJmKgpaI8dOz0J6Ymo+G9o3MsLnP4c+3u77Iy9nl0qLm2Muoi/OS8vCP+LjJuPz5iYmG/uD6+4b0hYeOhIKl5+65tK6qlNi6sK2WmZGImNK+h8rwvZTD1Njc6f/fnf6xyKem1MeLgvra2amrh8Vun5aq3+DUwpbcz3DKsoBnZm5+ln6DdHJ0maiv2L7ocKydlNrh2o+hlIjSv53PkKHg24CUhdWy6YuYycGojvHm0bGMgqWQgf3Yz5qwfo6M/7aGg5qU1MKytKSnsZr6sKqqw9q1x+X74t3X2L2lpKDW4dngpM2L9IDh4Lacpof+i4n1sbSOrZaAnbCMoZihh4CCcLG728Ofe5+QpauyyHzJsqyBm5SbanRlnnScnZJtb3eEysKntYt8ddrF2JeSjZidwGnJxr60qIGFgo2rkYmXscbEvauXjaqydm+7urzGuNLJxLWuxbiov6m5n4F4fYV+jpuYnZ6ruaiMjpKTnaC6s6e7p6yVma7Jy8XVurC+bIC6pZWWqay0o4mUhX11e3p1z5R5eeDYctnc0nfdg4mIkZyqrLjQeX6DhoSChHx3foR9gIaOm52mtrSbo6+ojoeama6mo6enoqqeopeVkI6Zn5ygnJ+cqK+mraGamqCfmZGAjJGQfIN9gX17gX6Qho5+rerWfoObvbi8uMvFvbnIuoDT077NiX1+dHOFiH+FgHRuzs25qbC0rbW0zquxn79vcsKzgn6YwsOziI6qq7zAln2WhZ23o52am419c47Gdsq+taGMz7bJrcDMyLjHmJ6OgtOqxrammaWzmsfT0Zm9zqR+e7t5wqd1gdpvc3R6bGrMzdHNn6CUj53dodbGd8i5g4DXc4F4dXJxl5HNxZqgyuTKhoqaineMhOWVqZeAct+OgMGuyHWkr8t933eViICKjqaJe3qRoYvJoaKldL97asjMy7Plq7HEntqZn5qYscnEpo2Ikq+gnISRopidqqyRe7OBfpl4nszFrZ+ym33ffqCsuru6tqmTnam9vrmrr7Ogq4Can4a4aniMiYyIhqSWnaW2vbK8rK6lp6GYf3V5eIeEeXp8e4KTqqCsxc1sy7ehj46MlY6Im5eljISeoKmvmYZw0HpzpJ6dxHZ43s6olLJ3lIjE07H4tLbTlZ21ko+Ck4aCfnqFipSVlKS4qJWPppenopCEiKCkqqKfrZiYl6mqm4Ccqp6dmq22oJuoscaSoJSirKy1mrPHopmooqGjqMytqbGzsqmoa7u0ucWsvNO2ysl0brpyzLu7qsCgw6rDyGrKsrl2gn5yabyIeHuZ24uJknrZ2Nd4d5lxf4eMsrFrapWNioSepovTdtV5e66njZNwz9HIzrvXgbLZc3LNrHnHwoDVf5J+eX93b3tzz7mfvo2IjYaC63+ynKW4w6+gqqSlp7S8rYrCs6+TfuOD5+SP7qixnM/KcG1tzbXK1G3NbHB3gHyTxcqkn5iZhbmlmJmNiYN8h8OtdazNp4etuMHKztvFk+qXq5aTtayDf/Xl3LCwjs11o52r29zUwZXn1nXYv4Bxb3uJoo2TgIB7pa2owbDjb6eXjcXOw3yHf3e+s4W4eYLAvm97dsOn032ApKCQeNnWxK6Mg6WRgfPX0ZaqfoyH/rGIg5Z9q6eYmI6SmIjjm5OYp7iaqsTRuru2vaWQkY7Cx8HTkrF/4XbO0aiJmXjleXfWlJh7kn9vgY91jYeTc4BoX56rxKuSbYV9kZOUol2ajYVoeHx9UllNfWB5eXNZWV9opaOJk3JnY7you315dn2BmVakoZyWjG10cXqVgXeBkp2cmo+BeYmUYVyfnKCrnrKrqZyXp6CSo5ahj3pxdHlygISGiYiLl5J8f4GDiIqflI6akJODhJalpaW0oJanXYCmlomIlZWdjnqEeHJtcnFrwpiEhfnzgPX47IT3kpeWnaGrs7vMb3F1d3RzdW5sc3VxdnuCjI+Wo6CNk5yTenyJh5eVlpiWlJmPk4mHgoCHj46UjZCRnJ+YnpSKiZCOjYZ2gISId356fXp4fXmDfoN6utvSmZmquLGwrr22tLq6r4DEwbK6l5SSiYyio5qfmo+I/fnh19jY0tvb9NbVveeEhu7gi4uctKunk3iGiJeQemx8cYCWiYZ/fXZsZ36nYKmel4l2uKavnqq2tKuxjpeMhPbT6uPPwcfZn73Hv5avuJuFg65psZ5mbsRlZWhrX162uLm1mce+uMPpn8i2brqmdoDGaHJsaWNlk5G6uJ+fvci8eHyIe2t5ds5/h3xtZMmLh9bFumujssB00GyEeXN1fYh0Z2x+i2+kiYmKY61pW620tafSlZehhciDiYaElKejj397gZeMhXGAkIaMlJZ/b6F1eZFtj7Gtl4ycinHLdJCUm56fmZSGi5impJyTmJSJkoCLiXeiWWt6en11dIqEiZKepJyikpGTlJGJdWlranh7bG9sbnKAkYmRp6VXp5qNfnt7goF2hYaOfXmKjI+WiHtqxHBtqqGauG1wy7+mmaxqhH7G7Mj1rLHEho2ihX91hHp5c3B7eYODhpSjkYOCloiOj354fZCTloyNmISHh5aWiICEj4aDhY+VhIGOmaiBh4ONlJOYhZakioeTkI2HjK6Vl5qbmJuYX6ehqrOdrLeltLRmXaNksqysnKqPqJirqFepo6dkbGZbVp57cXSIzYCAiHPe39F0cY1kb3JthYhPTXVvbml6gG2xZbppaIaDdHZdsbWyu6zBbaW+Y2S5n2izsYDBa3dra29qYmZmtquVqH9+hn9/7Xmbj5CkqZiOmI+Ok6Coln6nm5uFd9N03duZ6pujkLisYV1hsqCwwGK4X2Zof3uLsLWWk4iKdp2QiIt/fHhyeL2qapCmjnqWoq25u8SviN+FlYmFlpZ8gfnp7cPDpPWOsKuy0tPKuZP874b64YCIiZikt66xn5uUw8GarKLegKmckcDIvnN0cWy2qH2raWmwsmNrabihwnFzjI6AbcLBuKiQiLqghd/LxoChiJuO+KyalaZ0kZWKiYeJi3/djoaJlJmGlau3o6meppaFgXuvs6fIgp152HHMzbB+jG/ZcG3HgoFufXBha3djgoGIYYJ+hX2HfgF/h36Df4l+gn2FfoN9hn4Bf5Z+gn+0fgF/kH6EfQh8fH18fHx9fIl9y36gfY58BH19fHyHfZR+AX+Ffo19iHyLfQZ+fX1+fn2GfoV9hXwIfX19fn19fn2Gfol9h34BfYV+DH19fXx8fX59fX1+fZJ+A31+foV9hH4BfZd+hH2JfgF9ln4BfaZ+AX+VfgN9fn6EfYJ+hX0Kfn5+fXx8fH19fc1+AX+KfgR/f35/in4Ef35+foV/hX4BfYR+Bn19fX5+foZ/goCHfwN+f36Hf4Z+C39+fn9/fn5/fn5+iX+JfgF9lX4CfX6EfYV+g3+EfgV/fn9/f5N+gn2NfgF9iH6GfQF8iX0FfHx9fHyMfYN+iH2EfoR9Cn5+fX1+fn59fX2GfoZ9g3yFewh8fHx7e3x9fYl+AX2RfoR9D35+fn1+fX19fn5+fX5+fYl+BH19fX4CAgQAgMW0joiQi+uY0aK+38TikYj7leyfysfV7Yr5oZi/uJTchLeYztzvv8W4x5uAmKG1xtjX9/7g1PH24ty7097m2s6C7NTBuKCcu+GPjOLj9e3fyNC9xMLPxr3T183DvL2qqbXNx7ispKWroJK1wtPNwNbNqa6srNmAhf/3jKGL/PiEgPjm9PfZ3cOlnIGEjJiKiZCOiePIyZrXbc7X3G1xb8Z/gnmygY+To8PF2byqpqWpopeXnaK0sLu7xczMtLu4t8i2pqSosrfCw7W8sKekqbu7saOwrLaytLa9urvGwMGopJuOgoXx/o2KiIyShoyB1Na/qYKGltzj3bzc8sah4vjxgL7U2eydiYJqcXlwZGNjYGBiXlumlJeNhpWXp6ecssJhsK6YsfzJ9Y6H+MXBs6WdgtX5kNnYkaGSlMG83ILU28nX4qaNoqb3iPzhv7GG07J5al5og4GcxIXSx7a7mn/F8JC7ldLtz9u91tDowM2k4I3uoZSr4bL3nuD25YCR9/CFgN/6/JSGituv4OHpn4OavoGH3+6Nl5KcobPPooWgjaOXaZGYhp7Nl72y4ZKJja6bs6iUhYuil6++qZyOw8HW7ufgmJ7J59bJgKeFq9LK2MLCg5m1u9PFn7anqZaz2t7wwLm2w6vY79boz6mlnI3egq2cytLiyb2+4MbHxpym2OfpgM/TsICKgYebjqenpaePo62urLXCpqegnq6RjJqet/aJ2PHurNySg4eWw97248+xvLm7t7Sfo7ekur3GtrKsoZK3rZurmOO0q9CKjZD3v/GAjp6Q9Ie32+/V0tzOxb/Rz7qys6+YlI+Sq6qzsb/FxqCejdTE0fSAkKqpmJiZr7/FgMazweXc58/BwuTM18bUy9Hc19jwgdzGt6SkqbTOyr/MvrPKuc7658vR8vj1i4iJh4eNh/7mv7K+uJ20xN6Gh+azrqWbnIno1dGVq5Keo63lgeKMjaCN2pevp9fXxdnhy8LFoMHP6ZOW3Nicy6ablO6glYPJ/YTx95XmwbWIh73ngKGTgpiTjfHlhNKnwaHGm87YsaDAnpjCxMjF1M70yNTG3s+9uKuPkYGJ2vLEjqzp9LX03ujnho6Qh/37j7ezmP6KiKeskviClJSl9PriuaDMwLDVporGk7LJidPX0aaZz7+Bjajdp9SS8r++eNye8OfCiZuHwYeW34HEtMqxsozbgI2viYJ+f4ZuhoWJhK+54MfJg5Tci3t3kayfiIvRgb7N1rP70Na1vubziN7elqvGtKCC1cLL7barfrShlo2ZmJKpm8bs0veDkoHz2tC2r4fkobPC18vWvbm4rcfqqoSF3dGRkY+LoYf65/v85o+noIWah6X9tsnAkOOHqqqG3oXDgLSTd3d7eMx+q4WeuaK6cm/Sd8CCoZ+uvW7DhnyWlHuybpl/qK7AnqCVpYFqgYiXpLG0yNC3r8bLvbqftrzAtapqwbKlnoiFocF4eMDDz8i+rLOjqKSzq6O2u7Goo6WSkpywqqCUjo+Uj4KeqLWupbWwjpaVk7Nla9HKcX5vyclsgM29ztC3u6aQiHN2eoR6en5+ec61tZDdc8/c5XJ2dMqDiHyvc399haCcr5iIhoSLiIJ/hYmWk5mZo6urnJ6blaibj4yLkpiho5mhlo+Kj52bl4qXlJuampqgn6GqpKOTj4mBdnnc6YF+f4CHfIR40dW/rYeKmc7WzLHJ2LuZzublgLjKzeSonZV4hI6CdnR2cnJ0cGvJrrOknbGxxMKxx9ptxb2Xq+G42IqC1qCakIaEbrrceq6xgYx+gKSjtGmutKWut5B9iInWdeTQqqJ92MSJem13k4+q1ofKu6etkoC2z3eYfbnJtb+ot7HIqbOVw3TKjIOr4LnxlMbWyHB629R1gMrZ3X52dsamy83anoWPqHB4yNN3h4GIi5mqinOHeJukc56SdYi9kbGnxXx2dpCClY1/c3WIf46hjYN3qKa6zs7Hg4mmvK6lcI5ykLKntaCldYOZnq6jhZiOkYKWsr3Iop2cq5HBxa7ArYyLh3zKdpCEpKi5p56ftqWlpIOLsbu/gKutkm50YW2CfIyLi4t6io+PkpipkJGHhpR6dIV8neB3tsrKlsd/cXaCoLPDuKuUoZ2ZmpmGi5+NnZ2mmZSRi36ekYiVhNiwo8J6eYDnstVsd4l74n6lucSrsLOnn5yssJyTl5eHgX1+kI6Vl6WnpImKfb+0uttxfpGSgIOGk6CngK+Vn72xvK6iocCqtKiyqq+5srjIa7qmno+PjJGqqZ6qoJaon7LTxbS3xc/McnBvb2xycNW/opqipIqdprhsbr6fmY+Ch3jKwtCLnYmPj5bRd9SCgZ99tXiIh52dk6GnnpWZgZaeynt7wb9/n4aBfdOEenCy3HHX1XrIrKF2dK/BgIl5bHx8dszFbrGbqJS1kLa7no+vkYmmo7KstK/MpLSrvLKknpqDiHd7zOC9i6ni4Z/Muru/bHFzbszTdY6MfuGGf5aYiOd0g4CNzdXLqJG1qJi3k3iug5yufbe5uZqOsax2hZS5lsuG7b/BeOGg8+fFkaOPw4ePvm22prafoobWgIuwkomGjJJ5kZKRhKao0cO3e4fUjHx5jqCWiInBcJumrJPhwL2mrM/Zdr+7hpKpmox1yL3B2aimgrmmnJKelpCqnMTYrshpeWfCsbSZlXrTkpypsKmun56Yk7DEj3NxwrmEfn96jXbj0uTmy3yPiXOCdpnkma6Vc8h1jItyyn7CgK97Zmtoabhvim+KnIqZWVepXJBqgn+LlFKUa2JwcmWWWXtog4mWgX11g2lXaHB9iI2UoqSRjZ+lmpuHmZyekohQmZONh3V2iqFiYaOmq6ijl56Pk4ubk42epJuVjY6CgYiYkoZ/e3+Jg3iPk5ySjJmTeoWHg5dOVbCoWWFWpKlZgK2isbGipJKDfGltb3lub29wb76pqov8heXw/oGCg+WVmZK7bXJvdoGEjX10cnR6eXdzd32IhoiHl5qbi5CMipmOg4CAhYuTlIyRioJ9go+PioCLiY6OkI6TkpCVlZSLg355c3LW33t6eXl/d3xz2N7Jvp6fosbJwK2+xq+fx93WgLTCyNe1uq6RoaybkI6PiYuMiIH21t3IxNrb7+vU6/2C7uecqcqtw5CLyYGBdm9uYKbGbpCTcXxvc42Pl1WSm5CVmXxyd3PCZ825mpZ46+Oxn5Chu7jR/ZXBs6mlj4exv2h8a6qyp7Kdn6K1oKKRsGOwg3y65tH8lLq/vmZsx8lsgL7BzHJtabahuMPNo4eDmmdvur5od3V+foWOd2VuZ5nClMGSa3i1kquitW5oa3tyf3huaGh4cnmLeXNll5SltLa1c3yPmpCMZ31ngZyJmIqRa3iJjJWKcoN7gHOElKWuj4yNmIOurJammHt7e3C+a310iomdj4eImJCNjnR6k5ujgJaSgWVdUmB1cHt1eHhyent8g4aWgYV8en9sZXBpidJomquviL5zaGl2iZOcmJKAiIqFhIZ6fY+AiYqLh4ODf3KHhHuHfNOwprlwcXXcs8djbHxx4XmYnKeTl5iMiYqZnImBhIl5d3N0gn6CipSTi3l/cbaws9Boc4SEdXZ8goqUgJZ+iZ6VmpOKi6CRm5OblJ2hm5+xW5+Ri398dHiSlImWjoWRjaG6s6SprrS2ZGJfX15gZMCrkouRlIGQl6VaW6mSjIB1e2vBwM5/kH2EgYXIb9F/eaRxnWZ0dXx4cn6AeXN3Z3Z8sWVnq6xtgW9oabluZ2Gjx2XCwGqyopRoaqSxgHRpX2luZrmzYKSTnY2pjqalj4ahiIKVkKKVmpqwj56WqqCXjo96f3V2xs+2lK3W1pOxp6aoXGBiYrW/ZnN0a9CDfIuOgN1sc293r7q0m4igmIWggm6UdoqWcpyloo6FoqBzf4eehcyA78zZgPG4+uvHoLikx3+DmlufjJ6NjXvUgIa6qKGRrrKYsbeygZmZvsyxbnzRnJKOnKWbjI+4Z4SGinrHrbCgoL/Ib6qneICVi4BuwrSwvqKlicq/rp2wn6OynMvPnqxbZlilmp6JiHTKgo2XlZCRiYl9eZWifGtmsqp6cXh2g2/bzd7cwnWBfGx1a5fVg5B2X6tpd3Vnu3/jAX2FfgF9h34Ef39+f4Z+AX+GfgF9oH4Bf4h+gn+rfgp/f35+f39/fn5/kn6EfQl8fXx8fH19fXyEfcF+gn2IfqV9jHwDfXx8iH2GfoJ9in4Bf4l+An1+hX2KfIl9g36MfQR+fX19hHyEfQt+fn19fn19fX5+fol9BH5+fX2Lfgd9fHx8fX5+hX2RfoZ9rH4BfbB+AX2FfgF9oH6EfQZ+fn59fX2EfgF9nn6EfZ5+AX+Xfod/in6Cf4d+g32Gfgh9fn1+fn1+fo5/BX5/f35+hX8Rfn9/f35+f35+f35+fn9/fn6GfwN+fn+gfod9hX6Ef4J+hH+GfgF9oH4GfX59fX1+iX0Efn5+f4Z+An1+in2EfgR9fX5+in2Ffod9iX6HfYp8Bn1+fn9/f4Z+AX2PfoJ9hn6FfYZ+gn2EfgF9hH4DfX18AgIEAICcqbq+0MbE5NqrncXEp7POu/D3w8TH28aEid6Utr/bnPK7o87AuLulpa2lg4WixdX5wb3ky8LM0eaF/OeBgYP18tbjubCGp6mu3OOU9/ri/IDivrzGwra4u8/Iyt3lzLWosbOei/fG/LbBwbS4stPb2c24vOjOpJfO39HA8vuFhYDv3tvX5s3NybeyuuHYvrmlqbS3ooPl5NbT1JV+c3R6dX16f36Rtt3c4ezy+5mmsbvBsbCtqqqgp6GXmIuRipGRmaamrKyotbKssrG1vK6qsKWSmqKwr7a9uLGnqaGbh5fNgOv37YaR8IGLjfHwyZuqoZPA29Dm7O3t2sPHyc3k3YDx7djFgYR8eW5jXV5dqVywXKmXj5KXiIuUoLRph4+jc7ZmgHt5mr+JgLeUzaHm48CwqoSW3eWpwe7U+YzhsLjMvIm4sLOPgNPdk4/d7nReWWWEhbaIfXGko6HI43990Jm7j9na8+vj2/7YucqUkf7P4tCHloOgwqmjstbl+4Dg2ID44YKLnv7O7t/pjIaErrfJ8Hfv1a6Gkai7xrOvuqPMlXSD07LZg+Cr1ZiAkoOHh5qRqIr7hpH37b+ewN+ViaOag4TjsbGmmf+vu63Lv9DBtqWrssjQ28i6q7a0ravJ3ODd0MnE3Nfc7N7Ol461xqGvoqTF4dLbwLq6y9DRwdHE0YDAtJqNhO78mZWSosDFsaOvq6WftLOgqJGesYynzLeSuOz73OCk87iemIGlxdXSxLmboqW1vcGyuqjBzLuxrr6itcDn1NLNyruM8ursje6tt/fyjpycna++wqOdnJ6ZwLe5vs23n6mgmKKturO9xsS7ifCP2pa5ssG8tKijv9Wpw4DXvqbEwtXQzs3h7OP279/k4ufc/IXfvMSqtcG9sY2jsr/p4NTk393Y+v70z9va0dv68OfGw5uSloagz87H7fmDo7e7jImFiZ+NgpaZsf+G64ajl8qGq+yrtb3IrsWnm+ixybO3vLXFmf+dsKnEmuSkqpKBzofp6ujlwImDmoGbmoCbl5qOjf/2+fG6wq/ft8flz9Cclv359KWjxOjc0c+A+u67wMaskY+IwMHQiJWH/vaSu8rIgP7giuvygYynsInXzNKDsZWRuZ2T5Y2Q3c64wczH3tfM7sXlyu3XnvL+pJLpjqCesqq2vJC0t39hb9fVs51ycp+xx9XK//2Lo5Lm1ICrrabCn4OmvYO6f4nIioSyq6KetaG2yrvGZ6e2bamGtb28gpCgsZWh2oGnnZOrnJiopp/Hwenrp+2VxZfIcqj36MfZnKHD7u6L2N3fzZuUrKmA2ofxhI+lop6stJymuKaep66QwazAzqX9tti6rPyKqqP0w9/8jaO5wr/Kxb6B3YCTkJmgqKClt62OjKSljpmrnsPDnqCiraJpbrJ8lpqygsqaiayimZiKh4+Kb3GFo6/NoZu7pqKqrr5u0sJsamrJybS+nZdxkpGWvr98z9PA1Gu+op+pp5yeo7KrrbzGr56Qm5qIed+66Z2lqJucl7a5uq6dn8OrioCst6qgxMpqbYDGubezwa6vq5yZn7y3n56Nj5mejXXP0MXAxZOEdnp9eoN9iIiXsMzOyMvc1H6Fj5ahkpKQjZGIjIuEiICEfHx9gJCLj4+MlZaQlpSan5ORloyAho2Wm52hn5aPk4yJe4nJfOHm4HyD4nuCgOfqyKGvqJm8y8XW2trSzba/wcHUy4DX283GkZePjoF1b3Fwym3Pbsizp6+znKCruc52lJWjfc1vh395mLGGfal8pITAv6ublmx/w8OSpsCxzG65mZyqnnealJd+cMPJgXfI8INvaXaUk8mOhXilnJq0zIF9voCaer6/0MnNvtS7o7GGlPKxwLWCmH6Sq52aqcDN2nLEwIDYynJ4ht2608DLdnZ3pKu23Xfst5F3fY+ZoJGQm4u2pICO1arFdc2lwIRueXJycIF8inbWdXnR0baUrcR+d4Z+bW/DkZSPgeOWnpKsn6uhm42RlaWpuaibkZeUj42mtbu3sKijtbCzu7iqg3qZpoqWi4qjuq20n5ubpamroKqeqoCemYV2bs3Qg31/jJ+kk4mUjouImJqKk3+HlXmPs56CosjPt8CP2J2HhG6Loa+sopqDjYqWnaCXnJKlppyWkqCMm6PBrrCsqaKD2dvZgNmmrubWeoKBhpKcoIuDhYaAnpmYnqach5WJgYqUnpWhqKGdfOWMwH2al6Ohno6LnbWRoIC2no+fnbGsq6e2wbnJxr2+vMO60HC+n6eSnKWjm3uLk6LAuLHBvrq00M3KsLm7r7fPx8Gmp4mDinyTurCpw8ttkqSrfnx5fYyAe4uNn/F84HiNg8OClcaHjZWWg5GCfL+InY+SlJKdftuEj4ecf8aGindts3HOysrGrXdxfW2FgYCCgYB5e9vQ08qmq5zDpq/ItbWMiP/l3JeSp8S2srBp1MmjpqiXgIR/trjPf4d65tyApKunZsu1a8DLaXCAhXTCt75/rYqJoo+ExnZ4vrmlqbGtwb2txqq+r9y4gtPslYjfg5CLn5qlq4OkuIVndNfHrqR5eaSgrbmy2dh2iX/QvYCdnpyvkXyar3a5hY/Ff3unoZ2TtKO+z8XMa6q5b6Fylp6meXyRoYiPynWUioaRhoCOkY6po8rHk9yVvJjNd5/Y0cTTiIacur9wsbSxp4SBk5F303zVdXyQiIiTlYSTo4uGjJF9ppOgsI/fq7yklN96j43YssTZdIWXoqCloqNyxoCQfoSHi36Jj4R1e4qKf4aPiKGahICDiYFPU4lkdniJZ6x/co6EfHpua3NyX2FwhZOkhoGTh4aPkJxYraJXVFOiopagiIFlfXt+oJ9lrKygr1igi4qQioOCjZyVlqGrm4yDi4Z3bcy64YuMk4eGgZucnZSJj6SOd3OQmI2KoZ9WWYCnnZ6ZppueloqJhZyXhYR3eoSJeGe+vri4uJmVh4eKiJWPnqGtusbJwMLRxHB0fICJf4F/f4F7hIR/gnt/dXR1eIV/goKCh4qHioqNk4iJi4V4fYGJjpOVk4iDh4aCd4LYeeLb2nZ843h7feTp0bS+t6a3wsDMzs7GvrW5vb/KwIDGz8fHq7WrqZmOiY6J/YT/hvPZzNndu8DS4viMnJuijfyGlY+GmqmLh6ltfmmqppuOjV5qsrWFk6KbrViXhIeNiWyDf39vZrjBdGqz9aeUjJ28t/CclYimn5elu4eDsXGDbbCuvre+rbKml6CBr/qdqKd/rYCOopySpLa+yWq5tIDKwGhwdsawvrC0aGhun52t0oHyon9udYCChXt6gHamyp+v6KC2bMCktXRiaWRnYnJsdmq6Zme4wLCVpLZvaHNqYGCrfH58c8yEi4OWi5KMh319gY2OnpKEgIF/enqSnaKgnpSMnZmXmp6Rdm6Hj3qEfHuMnJOchYaIiouPiJGEkICJh3psYb++dW9zgIqNgXmCfnx8hYh+g3N3gm5+mpB2jq23pamEyIx5d2Z3h5KSioZ4fneAh42JjIOTkomHgo+Ah46km5yamJJ4zs7LdtalrdTJcHVzdoKJh3ZyeHh2joiGjY6HeYN6d4CGiIGOlYuEatN7tXOIhI+Pjn14iJd9ioCWhXuHhJSSkI6Wn5qrp6Wjo6uis16ki5GGiI+Rim5/hZGlnJqvrKqitbG1n6qrnaa6trOYl4J/g3KIqKCVq7FehZmadXdzdH91dYODj91z0W19dMV5ha1ydn13aXJraKBreXJ0dnZ/bcByd3CAa6xwdGRbpmS5uLmzomtmbWF0dIB0c3Bsbr68v7SbnZCum6G2o56AfvHRzYqDlrGem5tbubKVmZaJeXh0rq/FdXxw1ct2k5qUVqudWqa2W2BkZ2Oxqq94r4J6kH9yoWFlqKmbmqOgq6iaqpinl8qebrvoin/cgIiEj46YoHud0KSAit+4q7qSkrKRlZuWs7Bhb228q4CUkI+dgniNlGu7m6nIdHaml42CrrHh/PP2g9DfgJ1jfYiObm+AknuAw2+GfHqBeXN9gHyOkK+if8WcvaT0g5e7wcXSfXqJlaJYkZ2Yj3d6iYRy1G29Zmx+e32Eg3iGkX15gIR1k4ePmX/Gnq+VhtVyg3zDqbHHZXB6hYmLiIxotgF9l36Cf4Z+AX2YfgZ/fn5/f3+MfgF/hH4Bf5R+g32WfoJ/lX6XfbR+C31+fX19fn59fn5+on0EfH18fYp8hX0BfIl9g36FfQR+fn19hX4Bf4t+BX19fn59iHyLfYN+i32CfIR9AXyJfQF+hH2DfoV9g36FfQJ8fYp+AX2EfAZ9fX59fX2KfgN9fn6GfYZ+AX2EfgF9vX6CfZ5+AX2jfgR9fX1+hX2ffgN9fn2gfgF/qn4Bf41+Cn1+fX5+fn1+fn6IfwF+iH8BfoV/AX6EfwJ+f4V+i3+PfoN9h34Bf4l+CH19fX5+fn19hH4Gf35+f35+hX+EfgF9hn6Cf41+CH1+f359fn59iX6FfYJ+hH2GfoN/i36EfYJ+hH2GfAV9fHx9fYp+AX2PfoR9AXyGfYV+AX+JfgN9fn2Ufgl9fX1+fn1+fn6EfYl+AX0CAgQAgIuV29Pn68Lr9Nff4djEqdHVkpPb5ebe5tCN1sG1ibLJm4OzxMDJ3r/AuoTm2IfC38G8objBz+b4h6Kb/enk+9/Q6/CA9N+4zdr329qA7OHY14Lq1/3p08C8zNbautXV4ObasrTav7W3xNrLwtPcwrTA0szNwrzE3+DVytrP0NnYgPLi4PKDiouE+PmD7+TJv+Pb3eTHs6+fj/TE2en155mJf3SBgnl9d4/blp6nqq+zusfCrLmwraGdoJOOjYuKlqikoa2mpK27u7q5saCMkJyklZ6SlZicsaWmlJKHhPTR28jHyLShrbi0vKedmJV8f6S6vrm32o2TnqS/x+7cwOTXgMK2j3x/g3tpZWNaXl1kW16kqKKjmouOf5xdh7+Za2qsXWKyi6+ptaGj4ozE2KzAysOg6bDF1e74g+zU1IqirJL00Kispu2DmYzOr5nBhoZ/gLOWkaONnanpwPDKlsmewfHygNmFs6DQ6u+2jM3FhqzTu46Fr6uymrHEyID6/7SggKqE+fqB6cTKhIyUl8ilzNCOh3yrgIGBsLjHu7Oi/vPcgIGToLjT1tnKoIjymJeQnYeDg/WfmoqO8XFlyqPt8f69j6GCpqWwzcq8xuLYw8bJzcS4qLzbtqOXguLS/p6np8vYvfamvKWemJWWj/GTrr2kjZnAv7OKh/+nwsLPw8zEgMO6y6CY54SE9+f9g5+3q7izuqyUrLS9laOsmpiRk6e+xs63ybWx95CZjIGYy7+3kJz48PCRsrSgj4yXucusq7DFz87Cv8zOy9TFva2nuJiQl56FhI+NhZ22m4aFzsKJtsG6wa2yn6Camoj2lqSupK7FyMjK1cm7vsbT0cGwvtXEgLe7tujrwL2tqa61tMLx7+be6u3iyLvI1+G8vKK1qZim3t7p9vP37tbRrrr0+Pbw4buVgOfF7IaUyK3CscvSyNj4hIjPzNTSq5rCxq+2nOunn6KTqoue8YmtuqmEg4eEmLOYj8vXvZrkjYyLoqqljamTiemE//7+xq6hg8qB5Y+EgPebm4SPle/syNvq1+7Vx8va7I2ck4utvKfdwtvVprvkwa+wrJXUzfOW28WWot2AlY+lt8/uwcO94LPV3qXKzuHpo+n2tcK7nsnrjK6q4528xISS9M7Jlr/C4o+Ig+jmoZfrncKi68Wp5KvZ24N2d5WosWSsbpqmwLDi9+T+kOjGgMCox7zajeXTr/XkhrSvw6el1Zvz4uzq5qujpcDdsb/Pxb2I3KTL+YGOmbjen5OHk5Wqmb2vvbTEuP/NkrWP5JPCo4/f+6+hw9jetLedmI+foIqSqr2rsauYtMPFxMju19WxrpWjkfmJiI6RjKKJ6o+rlJ6XgKiR54i/zriuzbGYgHuDtKe3vKG/xKe0trCairGuf3ywubOzuqhxraCXc5WlgW6XpJ6lt52gnG/Gt3KiuaCeh56jrcLMb4aA0L+4z7qsw8ZrzL2dsLrLurprxr65tm7HtdLGs6Sgrrm+oLW4wsa7mpm7o5ycp7qpo7G8pZqir6uvp5ykubevpbGrqrS0gMW8usltc3Nuzcxryb+onr28u8KomJeKft+3x9Tc1Z2SiX2KjISKgpTJf4CGhY6Pk6GilJmPk42HioF+fnp1f4yMh5CLiI+cmpyZl456gIeOhImAgoeImI6Sh4Z/e+jP3MzNy7yqtsC9xbCmoaGHiKi7vbm10IKDnaW+utfRu9zJgLy3l4mUmY96dnVscXF5a3HBx8DCuKenj7Jrk8amenrCaW3BjKabpp6b03edrIybo7KPw46eq77CZ7qurX6Mj3nZuqGTj9V1hnq7opPVmZmQj8Scl6mRm6DUsc+5jLOTrtLVb8Fvn5O0yNGihcvHfZu2p4F8n5ufkaSzs3De4aeVgJt13N5x0ba2b3l/grSeubl9enyhcXJ0kpqhmZaJ19PgiZKblq+8wMG3h3XWf4B9gnNucdWJf3F66npoz5PKztipiplwjouXq6efpr60paOpq6SckaC1mo+Bcsm76YePkaewn+OOmoqEhH+CftF9kJyLeoCgnZZ3d+CKoKCsn6ungKacsYuHynNw2MngdYeakJmVm5F8k5uigI+WhIp8gZGhoq6cqpaW2ICEe2+Cpp+beobZ0tCAk5WKfXiBmaeOjpOjq62ho6uorLKjn5KkoIZ4hIdzcHh0c4ynj3t8va5zm6Gcn5WhjIeDhnbbgIiTjJOhoqSnraedoKOurp+SnbSggJmhl7/An5yQj5CamKDBwbqyv8K6qZyntMSjpI6Zj4OMt7bBzcrPyravk6DP0dHNwqSFd+C64n6FrZKonK6yrbfQbnGxrbeznYysrZefkd2lm5+QqHqMym6Hj4puaWtueYl4c5+kkn7GeHRxg4qHc4l4c81w2NPbspyTeq9qxHNvgNeAgWx5gdHPsrvLv9C4sLK9zn+OjISbpZO+p7WykZ2+ppiblYHCu+WS0LyKkdF2h4GRnazAoaObuJizu5Kvrb/KkuTsoqqkjavHdYmCwIunsW5407KxhqKowHdvbsjMkIvfnLmRzq+c4JjC3Yl7fZ+xumq2dZ+Tp5q/0MDXd8esgKuYsKy+e8i9ou7beqKap5mWvo7d1tne2aemorfSmqq0raV6zKHB5HF9iZ3Cj4F0e3+Ohqebpp2soOK+j7OBvH2wn4PJ5ZaNo7a4kJaEgXyHjX1/kaKQlJGBmJ2hpabDsbKUlIOQg+F5eoF9e5B2z36PfId/cp6L0Xeep5eVpZF/gGhzl4qTlIeXm4KRl459dZGLbmuJj46Mk4FUiX97YHmFaF2Bh4GDj3uBgF6onV6Bk4KDdIKJj6CkWmpkq52RmpaOm6JaqJ+GlZ2inZ1Ypp6YmFqol6ykl42IlZ6ljaGhpaijhX+djIiGj5+RipefkYSJkpaUjYiMnJeSh5OOjJaWgJ6fnqdcYmBaqalWpJ6NhJmgnqWPgX91b8qxvMTFy7CnnpOkpqCknKzLb2xscnh6e4aKgoZ/hoF9gX17eXJud4OAfYOAe4ONjYyIi4V4e36HfYF8fH99jIeMgoJ7eOrU39va29HFztbS2c3Bt7qloLC8vriwx3R7qqq4tcjGwdbDgL+/qKK0uq2Sj42GjI2VhYnt8+ry49PKr9uFpMm0k5T0hYTpk6OcoqOgzm6DiHGCgZ+DsnSCipmdU5qJi299fGq8r6V/ecZsem6snZb+wry1sOelo6uXmpvDpb2piqaQpr3FZa9hlpCltMCWgtbWfZGqnnx5mZWTkJ6nrmbOy5+VgJhqy9JnwaytY21zcaubr6ZvbYKiZmhqfoKGfH92vsDvp661jqOqtbGqdWnCcXBwb2NgaMd7amJq9peC1omvtruYg5Fle32GlJGLkqaajYyOkY2EfYebiIB0a7utznqDhpSZjNKChH13eXJzc8hxfYV8bnWLiYZvb853h4aUhJGRgJKImnl6vmdjybrOanqJfYN/hoFwgoeOd3+FeHx1dYSOkZuMl4aFy3d6cmdvioyIcXbNwb5yf4R8dW51ho59fYGLlJeNk5mWmJyTkIaWjnttdnxsaGpqZ3+TgW5vr6hvi4+LioSPf3d3dWnNdHmGgYONipCNlJSLkZCWj4Z8hJaEgIeLgqKfhoJ/fHyIhYqjo5yWpaahkYuNnaiQjIGJfm57np2ntbO3taOdhZa5ur66s5yBcty+4HmAn4ifjp+ioKa0YGKbnKSij4acnYiQhtKqoJ2asW56nl9yeXReWFpdY2deYXt+dmirZmRiamtwYXBhX65iu73EoY6Oe6BdsGZkgMdwcWJscL28o6i7r7ypoqKrtnaIhHmIlYejk6Cbg4mllYmQhHO1s9mSyrmAg8lsfniDkJqnjo2JnYecoYSdm6i1i+Lplp2ag5isYW1npIKdomJovp+feY2Po2NeXrO6ioPWqb2JupyU3Y2x4qWTmcXW0IDejraCiIacpqGxYamagJaImZSpa6+ijePXdJWOl4yEqIPMzszOzKmsqLvLh5qinJFyx6zA2Wt0fo+ef3FqbnF9epaLko2XiMyxkqZ1mGumnXG92IN9kZ6UfoN5dnB2e3R2hIWCg39ygoaPjo6fmZqHhXqDedV0c3NxcIFvxXaAcHVwZpeLxW2GiHt+iXdsmX4Bf5F+gn2LfoN/iH4Bf4h+AX+EfgF/sn6EfwN+fn+NfpF9tH6YfYJ+mX2JfIZ9BHx9fXyHfYZ+g32FfgF/h34MfX19fn59fn5+fX19hnyQfQN+fX6HfYJ8jX0BfoV9B359fX59fX2EfoR9BH5+fX2JfoJ9hHyGfQN+fn2HfgF9hH6EfId9l36DfYZ+AX2IfgF9i34BfYx+Bn1+fn19fZt+AX2KfoN9qH6CfYx+AX3IfoN9i36Cf4t+hn2DfpB/AX6KfwJ+f4h+BX9+f39+hX+ffoZ9A35+fZR+gn2GfoN/hH6Cf4d+g3+EfoN9hH4DfX5+iH0DfH19h34Bf4d+Bn9+fn59fYh+in2GfoR9kn6EfQh+fn59fX59faF+AX2HfgF9hn6DfYh+AgIEAIDQuNTa5f/vzsng2+LNw9mq6NfavdvZ49zPjYPDv6j2jqK5qrXMzNrxwYuYgfSErr2vv8SjwMbYwdTwg+6/uNrR4tnqj5KDh/PugYWQjpD++tjk1sHDtbq8vcW9xMnLws/Hy8O1vb2iu8fRusrP0sjBysDKv8bm7OPm9/ju7vPK0IDg8Ifr84mFg/3w8uvn3sKkioOav8mxlYX6gvz07N7rvpCEg3t7dG1xd2+Bo9OIqK+nobC+qZaNk4SBlZWan52UnKiurquyr7TGt52fhP6EgY2L+ZWqkIf99eHGxNOboa6smJeIgYmKf3h4d3pzcXl1dXd+eoaXgHSFg36GiHt6d4B5e3RjXGxyb2ljXmRhXltbW6RaYKukpadngJ6VfHpzbbyvcoK/vNtwo6H596Goy4yHuOyB9dSWkIvp7L/G1a2pp9Pq59aH+YDRq3l/gazki4eQh46BmfK61rDD7M71yfHtwc2txcuNnsepkPSUuvDy2ce5mJejyYTd+tbtwrS55oC55Onj6tK3sYGGoeDbjOGDjpqK1YGLlKmeq6Gcwbyavvby6Kqdq7HNtuX6gIGA+YXjoLnkip6C9PS2mqOy94ePkbys9aqxtaqxxtHM26CsuMHN5+rDu77Uxb6U7dmIkNGEpJuPqcm3oby9sZOP++yEhamwmovph5KjvavF3+Pby4C2t6ON5OGKqZ+EheLpmoGKmKu1qbWtxtGqsaGanKy1p56vr7yxn5iQ4oDGhJa4uMCYhYeLsqu8toqGk4uPho+TscfQ49fa09/078qyoZ+A5+GCgo6crbi4w8uxoImHlKbEysbDwKynkYSS/8765e2EprSor6y+w8jZ1+GqqKGk9ICUur694dOrmp+cp9DU1OHi7+vu3+/cwcrU/uPcqsmHguTq6MrW2rqfmqjC5vLXupni9/GKj5+SlZ6ws6+3r7akqcHW0IKM2bC4nZGmoIjW7NuPq+CChvWUl6KJlo2MmqSf956Fw4/zjLKKn/qyl6Og/4iMyr/SrKf6lLvi5YmK1IC5h/z9+vT66NKXoNn018786NTT0aGkw9bQ0r3JvIuEkJSdlo61ytyvtMftlLT5k6b5j7HovNHJ49OvsKzCxtPh376Rtbqqs+TviZ3RpIe2s731gsDsgsy5tejjysHG78mk+JCLgpT6/fqEh+2HgHaVmaKQw+iagarLt6fP4cqynIDV5sCu0rTGqt6b3PTNutmXwLHklJjCnrbBnKadnMTIoJ2Sk+ef+Ob9mdjEs4O+1qalk6+0lL7PzqXysbyxq7ei9/inh6nq4JKgvLvZxc/uqqy0yta+w+fNkI7Fydbbz9Da5dvAq52Q+ZmU74OXiOffx+r8i83Vp5WQj5SxvsWkmICqkamvvc28pqO0rrOim7SPuq3Fra+tt7GocWqgoYvPd4ifj5WopbLHoHSAbs9xlJ6Uo6aKpKe2oLDMbcOdmbiwvba/d3hrb8nFamx1dnbSz7XEsqKknKCipKmip6yvp7OrraeaoqCLn6awnqywtamiqaStoqXBvrm6zM3ExMOprIC6x3DGy3FubM7DxcC/uKOMeHGEpKqYgXfgduHf1NHavJmUkYmKgnl8g3iDnblyio+Ih5SflIV7gXlxhoKFhoR/g4uPkYyTkJKhm4KLd+d1c3174IKWgn7r5trDxtakrra3pKWZk56glImLiYyEgYuGhIWMhpCijIKUjoeMkYaIhoCJjoV0bH6Eg3x1b3d0cGxsbcBqcMa+wMB4kauljY2EfdHAfIe3r8hzrZfb2YaKpnt1nLtguqyBfXa3vKCgsJSRj7rVzcV62XHEqnyIi6fSenqGen90hOC0x6Ov17bTstPQr7eXqraCkayUg+yMo9LNvK+jjYuUtHPG2L3QrqSrzoCpycvKy7eppnF2lsbIisZyeoN6wHF7gJCEjIeAmpuCs/Dx452PnKW1p8jYcnFy2XDKk6zHdYVy1dqilqGg13F9ep2R3JKXnJGYp7KrtouVmZ6pv8OimaKso6SA1Ml5fcN1jIV9kaecjpqgloB85NBxc5CVgXfRf5alsJKitreyqoCbmod5zc14jIdzeMnMgm93gZGXj5uVp7GOlIiEh5eaj4iVl6KZjop8ynG5eYSenKODdXl6loyZmHh3g3t9d32Al6aturGyrLvCx6iXh4d22M94dYGHk5iaqLGZi3Z3fIygpqOhno+Pf3eH9bnXzdlxjp2SlJGboqWxr7mNj4yR0YB7mp2bu7KSh4aBiauwrr+7wMDEtcOzn6qw07y7k6hvab2+wKm0uKCQi5Cjwcu4n4fP5+mBg5KJiI2bmpqhl6OQlaq0sGdwuJymjIWVjnvL5tZ+lcpqb9J7en5weHFxeIB+yIFql3TPc410hdOMfIKC0nBzrqe5n5jwlMC9wnRzu4CidtvZ3NfSxKp3kLjJvLXZwrO5uZSVrLmqtZ2nnn1yfYeMg4Cpv8ustcDbhaLrgpbmgJzDnqyluq+VnY+lqLS7vaCEnKWWncDCcX6fg3GmpajMb6TLbrGjn7/Dq6Kuz7KX7omEfInw6+1+gvOMh3yeoKuWv9+OeZy0oZW2vbOhjYC3xLCWuqOqnduMvdK2pruNv6rjjH6fkZ6njZKNi6qtjo+DhdaW6dXmg7elmnSgto6RhZybgKOur5DbqK+rlJqE3NWFdI/Ev4CJoJyxoKzEjpeYqK+gobate3eho7C3qaixubOikIZ62oeB13qFetDGt9TadKiti357en+RlpyJfYCKdo2OmaWQiIaRjIyDf453mYqrm4uJkIyHV1GBgXKuZHCCd3uDgI2cgWJrXK1deIJ6hYh2iY2bhZStWp2BgJmTnZecYmJYWqOdU1VeXV2opZKgkoeNiY2LjJONj5SVjpaTlIyFiYV7iouXi5OYm5KLkI+ViYyimZaXp6qjoJ6Rj4CaqF6nrmBdWa6gop+amImAb2l5j5KIdWvJa9HPwcfQxbOyraipnZKXm5OVo7Rqenh2eoONhnx2e3NwfHl9enh1fH+Bgn6FgoWRi3iGdeNwbnd22nmLfnvm7OXT0ufFwcnSvcK5tMDFt6qpp6mjnqunoJ2inKO6q6Cto5ycpJ+jn4CiqZ+PiJyhnJaOiZKOiIOCg+qChO7p6O6Uqri6pqujlv3sj5ixqr6D253OzHh7jmxoho9CjINsa2qMkoWCkn6DgKvLwbttw2i2poiYmqW9aWx2cW9lcsyxvKClvae/pb27pamRoqiBipuKfuuGl7u0qp6Xh4SNqWe2wK7DpZyhvYCjvLy8u62fomdpl7u3jLVqbXVvtWVsbXpweHRreoBxpO327JSJlpmpn7jDZmdpxmS5kaW2anhnv8aVn62XwWdua4iB0YWIjIKIlJ6UoH+GhoiQoKWMhY2Sjo5zxLxydr5wgXpxgY6If4SKgHJu1cFnaoGFb2i+grG4pYGImZqZl4CNiHdtv8Jse3hqbLy9dWZsc32EgIiGkpx9hnh5d4WHgXqGiJGMf31yumatb3eMh491am5sg3qBh3Bud3FvbW9wgo+Wn5qYlqGnsJSHe3dvycNtbHN4gYSEkp+He2hrcH6OkI2Kgnx7b2p72avIwsxsgYuEg4WLjY+Wl5d5eXp6vYBvgoKEnZR8d3JweJORlKKen6amnqaZjJidtaGagJJbV52nrZmprJKEgoSVrramlHzK3ON9f4uCfoSPjZCPipmGip6gm1Rfn5CagXuHfnHE18pxhbJaXbVpaWtfZmBfYmNkpmVYdV+xYndlcLNvZ2posmBgoZinl43upsiqqmVlq4CXZ8XCw8K7r5priqWsq6bIrKWnqYuHl6CTnomTjnRqcnyAdXakub2lsrzQfpTkeojceYypjZaSoZaDiHyRkZ+do498iZKJjqmhW2V6aF2Vl5qzYpaxYJ6Skaark46auKKI5IR8d4Dn4Nx7ffakoZa5u8GowN6CdYyZiICboZ+PgoCgrJeFn46UjdR+p7imn6mBwbP6jGuCf4eRgIN/fpaegoJ6esWX0sbQdKOYjWuOnH2BeoyJcpCYlYHIoKOlhoJtvcFuY3+knHF/jIyWi5edcoCFkpOKjZqObWyJjJSajo+aoJyQhHxyzX1zyHJ5ccm7ssbJZ4uIdGlnbG51fn9zbZJ+gn2FfgZ/f35+fn2NfgF9jX4Bf4h+hH+CfoV/tH4Gf35+f39/kH4CfX6TfaB+AX2EfgF9hH66fQN8fX2EfIh9gnyGfQR8fX19h34Bf41+hH0Dfn1+h32HfpV9AXyLfQF+kH2CfoV9hH4BfYt+BH18fHyIfQV+fn59foR9Cn5+fn19fXx8fX2FfgF9l34FfX1+fn2NfoJ9hn4FfX18fH2KfoJ9hX6CfZt+A31+faR+gn2ZfoV9kH4BfZ5+gn+QfoN9kX6Cf4h+CX19fX5+fn9/fop/AX6EfwF+hH8BfoR/A35/f4V+Cn19fX5+f39+fn+ifod9Bn5+fX5+fZh+hX+EfgR/fn5/i34BfYR+BX19fX5+in2TfgF9h34EfX18fY9+hX2RfoR9BX5+fn19pX4HfX5+fX5+foV9jX4CAgQAgMvZ5+DD34aM2N/kubWHuKS86KXXnebtguLi7/e8mYu5qaukk46uzsTEooHz5Y+Vt9DZ16y1s8LC5fD1w72xuLbE19XsgIuM4973/JeN8vDd+fn4hIL05+nXxezo2NC+5vHiysjMy7O+ytTJxcjQ3NzuzcmpqdjY5/fDptOA5d7dgN//5uLu8/SA/+ncytLPvbfT0K2UiIWRiITw5N+xi3JjZXJ2bnWGgIJzeoF1doOXwOaI+ufZ+IGMl56sp5yfmZ+ysKmlmp6MmqKOkeipvIaIho2F/rmXioqBiIqQioKCgomFh4WHgHx5bXNpb2pva2xmd3BvbWtdXl9cYWNrd3FvgHB4a19kaGhuaGJfY11YX6iztKWxrKSvXWt9bZVjbKy3bYBwhaXt92uxn7/D4Pfux5Xuq52HyYiRjMyoi7nAoZSXjMSLt/aFmq+hn6efoqWeiOfXmaX6xsGzqKTg19ji15/Q0cChs5eXn5OboLPA28rPuL+7taWu3sbiy+7Tz9z/gIbJ/+eB8a+15IXbkJHl6cjriJ+chZezn5eKiJGWipLr/tvX56e90LCruL33ieuFhMu3sdKHjZKQjp6E6I2Tp+HuiqeHnJOdnaCwx8S5pKWyqaK/zb+ympikqq6ym/Pu7YellIGhpbDCxbyzwb2V676Xr5ihvbeK3ZDjnKOel663gKmntqeR1cCal43O3YrHpKSduLKvn6qm0OHn2c7c2Me7vqy6rsXi86eGr9XPuqWvtJmpmqOtqaOtqayrxLKrq7SSpbm6y7/S78nh6M/YxbyhkIqdp5CbnreonaafpL7FycjExcu5ubOVmrKso7vPzuDQ5d/JxLunuMPW0s/Rxs65gKLA0t3EnaWXk5egkPqTr8PW6uPOqpaTj6mvzc3y6OzD3MWrpK+enK/j6NfHuZeT6/r1l5qata212sLW2d6sxbXBoJ2kpJKM/4yjt7GlnNuLk5qVkJGfo46lm6aZ8YqKi56nicKynZy2rqCYxbCSi4yDjvW83N+yzuGzme6c9ODKgNbgwfSH1qGHrJHF/f6/yu7dw6SOjomBnLrRtb6liO7gzI+A5KmQnof+oZSXhoW1zK61yIPaq6a9xayuvqGnq+Da4/LclsjqrqzBj6GI487f6uPR6f+AhL+dkuCH9ZW9lZqOqreDiuiM25iW/Zb5qLOuyMrxr9i29+LqsdzkpcXWgIuCxYuo/qCA/Lni0a6dhMOygZN2kdnUxPn3iM/SusrPobjIi7ClpK2QpKConqCoy7yVi9u+weWV1Yisofmcjr2M3eSl7IiN78HBxbutstCZmZ7Ov4LG/qGCh6qHzO3u4tzI0Li1pejG+Za+9YLj3YqTuZ+2q7+wydW/q5mTsZfMgKKpsqyismdsp6+1mpFxloqZtoi5gre+aba1v8mdfnObj5KIe3eUrKWki27Qynx+mrG2tI+am6alwcfNoqGTnpqks7DCaHJxurbP0Xpyxse4z83MbmzKwcS4p8jEubKhw87Cq6qvrJegrLOopaauubLFqaqPjrOxu8iejK9ov7i0gLjTurjFyMxozbqzqLCrnpuxsJSDeniCeHTXz9Goinlvc4WJfoKUjY9+ho5+go2dtc585tXH4HF5g4SPkIiIg4WTko2NhYZ6hZB/gN2punp4eX567bykmZmRl5uimJSVlJqWnJuemJGOfoZ6g32Ae353i4GCgX5qbW5scHJ7i4J/gIOPfm91enuCfHV0eHBpcsXS1MHPyb/LbX2TfapyfMTQeIt6jKTZ4HK4l7OxxN3VuJHcj4d3u4mKhcCghrCyoZWYj8SPrttzgJKHiIuIiomEdcjFgovVsLKlmZrFwL/IwpPAu62QoI2Ij4WLjp6uva+ynq2rppqfwrLGtta8t8XggHO03clv16Kn0HbbhHvM0bXMdYmIdYGaiIJ4c31/c3rL3MG/05mqtqWisLHce9Z1c7irp8F3eX59e4V0z3t+icfXdo91hX6FiImTpqSdjYuVkYufqp+TgISIiZCThtbU2nmPgXaLj5KhqJ2WnZp/z7CSpYWGm5R2zojTiouGfY+XgIqOl45+xrOCf3WtxIK2jomFmJWSiI2OrbrCs6u4s6qgqJajlqe8xY10lK2xoIyRloKSgIyQjYmVjZKPqpiPk5h/j5qYqZysxai+wa63o5yLfHiFkXmBhZqTgYuHjaGnp6Sio6aZl5p/jJuUip6trLmtvburpJ6Tm6Kysq2qo62hgISdsrOgho2DgIKMfdh9lJ+wxbmukoKBf5KTq6rRu8OlvKiVkpiLi5rHx7Gqm4KA1+nmiIyHo5ugwae1u72arKGrj4uTloWA7YWUpKCUjcZ1dHx7c3aAg3GBfYN7y29sbHmEcpWMf3yQi4J6mop7dHZxd86pvsCjtd+4ksyBzsCygLW9sM1xtJB+l4es0dCorMm5sZCBgX15jqWzmZ+NetjQwX940ZeCjnnvkoSIenuis5ucrHHAlZCjrZKcpYmQk7i2vMe+iqzGl5micH5vwrLCx7230Ntrb6WRiNd954GpiY5/laN8g+ON1ouM9pT5rb22ys7nnrqd1sLMn7jGmL7KgIB/unyZ9KB66J3BtpyJdLixg5J1k9C3qsvLcbGxobK4jqSxfJyKjpl+i4yTi4+SrZ2Ce8asrtOCwYOmm9uFd6qBw8eGuWpvw6KjopqPkq6Bio6un3O74ot0e5R5qL3Bu7ShppWXjsy11oSk4XXPwXJ8pJCqj5uOo6OYj3x8k4GmgIGGiIeCklFShY2MgXhifnKBk3ChZ5GZUZCNlp5+al98dXlsZmR5kISFdGC7r2dnfo6Sk3eEhYyKn6OqhIh6hoOIkpCdUVtal5Kkp2BanpySp6WmWVemoKGai6aknZWHpa6mkpCUkICIkZmOi4uTmpKjkJJ7fJiPlp9+eZVVpZmUgJawmpijoadWppWUjJSOiImWlYN2dXN4bmrHxMimlpCKlKmonqSvramcpaaanq66vc111cjF12tyenuGhn98e32FhICAe3t0foV8fOS/vnFzc3p38tjJvr60urrDu7W3tbmyvL3EvrW1n6SWoZuel5uUqJ+dnp6Jh4WHiIqYppyYgJ+umouQl5mgmJGQlYuCier8+e347+v7jJ2yktSNle/+i5iJl6fMzILinrCqttDIuJvSfnJtsZGUjrWdk7i3qqKmocycqMVmbXx3dHZzcnFuZbOxdHa9pKCWkJOzsa22r46wrJ+NlIaBhoGEh5GdqaGgkZybmZKZsae3qcGurrjOgGiqxrhmyqGjxWjxi23Awq6/a3t4a3CCdm9qZWpuZ2ezxLCru5GdqJyap6rPcM1vaa+jo7ptb3Rsb3VmvW9webrJboFreXN4e3qAkpGOgHh+fXqKk4l/b3V2cX1/ecnGzXGEeG19fH+MkIuDhH9xuaiSnnpzhHxov4a+fn15b36JgHl9hH90uahzcGaisoKufXl1goV/eXt8kZ6kmpKbnZKOlYqPh5agqn9pfJCXjnqBhXWCcnl8fHqFgIR/k4h9f4V0fIWDk4qPq5WiqJqgjoaCcW52gGt0domDc3l1e4+QkYyJjoyBg4VugouDeYyVl6CUoqCTk46CjI6dnJOMhpWDgG2Bj5GGdnxvdHJ5b8hvhI6apZmThHh4dIOFlZewnaWTp5WKho2Cg5G0sZyaiHp3zt7cf4J/mZOWsJikq6aRoJWaiIWMinl33nqJkI2EgK5kYmdpYmducF9qaW5msl1WVV5jXG9rZWd3cnBnenJlYmVgaK+XqKubqejMi7RstaeigKKpordjo4h6jYCctrCZnLeopId5e3RzgZKbg4d+ctHHunVwx4t6hG/hgXp8cnSTnY+NlmSsioSUl3+OjnuAf5mbo6eoe5etiIaJWmddqaKosqaqvcBcX5iGgdZ22HSSe4J1ipd4geCf04CD75D0vtHQ1s/Vi56KtKarjpuoh77OgHh4unSM6adx4Iunnol6abuyj5mDqNKfmaGpX5+ZlKWphZWgc4F8gYh0gIOJfX2Em4t2b7qlqM12uI2lisF5aJOBsLByllNXmI6PjoeDgpFveYKYiWivz3tqcIZwkaCkoJqNkYWKgL2tvXKLzmzFtmdrloqhfIB1fIF4dWZqc2qGhn6Cf4t+BX1+fn5/k36CfZd+g3+EfoJ/hn6Cf6d+AX+KfgF/kX6YfQF+hH2VfoN9hX68fYh8hH0FfH19fHyIfQF8iX2DfpF9i34EfX1+fqt9BX59fX1+hH0Efnx9foR9jn6NfQR+fX5+hH2HfgZ9fn5+fX2cfoN9jn6EfYV+g32LfgV9fX5+foR9/n4BfaJ+g32VfgF9h36NfwF+lX+GfgV9fX5+f4d+AX+ZfgZ9fX1+fn2EfgF9in4Bf5Z+g3+Ifgh/f35+fn1+fYl+B319fX5+fX6HfYp+C319fn59fn59fX59hn6HfYR+AX+YfoR9AX6FfYJ+hH0Efn5/f45+gn2Pfg59fX1+fn1+fX1+fn19fYx+AgIEAICVpdHOvrLI6++A8q+bsaCVkc6xiILAufb8o63V6tOzgpOdkZypmsTUpo6M/ITZjc3T0sHDx9LD5Ofm7+bSyNv02Mq6uNDs6Ofjz+qHhoHq+Pzm8Zizl4aJ+YT+hvvl6dTgytnk09Dcx9DRzbCLrLmfus3QvLC8uNTJtYKPs665woDN0fzfxrvS4+/uyPXZuMHN3r69ubGxwb61rKSZh+Wtkod9ho2WfXttcXl+f4h+inVteovYkIiNjZ6ZmqSUlpuem4uJi42hl4P+g9OIkMfe2sSto45/enZ3enl2enp1dG18f4SGf3hlZXV1ZWJeY2xpcG1rYWFjW11iW2BoaHV1b4Brb2RraGRpZ2ZjY2RmZluomqigopqQorFidXR2dHRveYpzeaKeirylbZKttOKMmpV5cnHIrK+4d7/o9aXa15v46/vJmNWQkIWB+ZD9vqT/3Ly1ysPS54i8rpWzrJekya2glP7qhKOW5t2EoMbju4T+ytXRxLOxv5mmmIDd/IrSo4Cs29aGyNy82sjf3o323fzXwYGYqrSpnJT74ZDlgNf4h4r+tP/ns9DQq5e5pZXigvKBgKrzkqK17vP0h4r/gJGd84mOn/GDoKewk5+bkpqropyI4eb3lqWQj5SWlY+PjYKiro2OkJyLo6qNoKGzzcmvsJGHjbTCh+Kdtpb576u2toCVgpeB8vOVnom7rLGH8Yf5y9n3+KGnsL3R3dHSvLaywse15er30MG6na3Mv8DRxMDOrZuXiZGGi4mQoKi+u7a7u5esub+5qLO0sbi5qf+SkJeP7oSLl5ahlbDGvISClKi4qq641cm7tb6swryeq7a5w7muuLHMybbN7PPl0MvVzYDEtrCShJGBo6SVlpu9pZGGlreUmJDOgq6gzu/Dubq/0buI+/+HpL7s8cW4sLunse/+47ezr769sLe9u9e6saPAvKyxqa2pu5/Qg4qVqJmSk5yekp2bpJynpLKl367MhuO/ksrYzryxnpL7k5T3nJyim5Dfzf/e1tKSi+OB6KPA2YDOwoSQ1L634rfG3KSK0b3Jo4y+k/iVn9KmpMzIloGYjNa6ms7v18nPyoiG//LNmcmxr7zFvoOhzbTM/cfaiaKqoIWK+evs9eT2hp7BwbnHm8LP8MPi48mC6a6OkHOXkOrBoqeg16v78Zadu5yj0tiG3rjgzpaN+uicgeWamNixooDShPH0jYXYsJGZ0LqvqqLX8YiRgvywztramZn0kO36iKXjh+GzqbCtxMOiso+nk5iOj66Wmfa834PegIr85e6SyLu+ssvp9/LJtNbIr7ulqOOl1s+n9daPheKBvdKOq575odPRvqWdsI+moJankOGxpJ6a6MHig7PIvMrbqpeG6YB/i6ajnpOgub1lwZSClIZ5eKeTdG6Yk8TMhY2tv6+YbnyGfYWQhKWxinh213G/ea6zs6Wnqa+lwcbCycKwpbTIs6qcmq/EwcK/sMFubGvAzNC/xnyPe21y0G/UcdS9xLO/r7rBs665pKyvr5V1kpyGnqytm42ambGomXB4lpGaooCpqsyzopuuuMC8psm1maWtvqWjn5mZpaOck5CIedepl42HjZGbgoR2e4WLjJmHl392ho/Ge3h5d4SCgY+Ag4iJhnx5enqOiHvneceOmMHRzcWuqZyPjIiJkI6Kj5CLin+TmJ+hm453eIyLeHZwdXx9hoKAcnR0aG50a3F8eoiHgoB9g3aCfnmAfX14eHl8fGzItci8vbKovc1yiYaKh4V/ipqBgaGej8y0cpSkqc2LlpR+dnbWuLvCeLrQ1Z/d2JXWz9W2krh0eHNy03zbn4vbwaafs6m1x2+Zk3+TkX+Xt6GUjvTmfZaG1c18lKnHpm7VrLu1r56cpo2Xj3vE23W5k4Cgvbh0uMepx7TBy4jYzt7ArG1+kpuMh3/ZxXzKcMDRcXbdo+bIpbq4pJKzpZbXdddwcZrukJim0NPRdnbebXqF3nh7itJ0jY6XgIeGe4SQiIZ0yMvYgox7eXx8gHp6fXKMlnx8eod8jJR3h4qUp6yVl394dpOedMyIl4LdzZ25s4CHb39u0duOmHibjpd22XTjvMXe2omOk5uvta2tnZqXpamcwsDOrqSehZKsoZ6uo6CnkIaDdnxzeHV7iI6jn5eanYCQnJ+ajpqXkpmckNiAfoaBzHV6f36OhZ6tp3dxgI2XjpCWrKidlaKToKGFj5mbo5+Tn5isrJqqxMq+rKqzq4CmlJmBdYF1jY+AhIWglHx1g5mBhH/EepmNqcOlnJ6fsJ973uZ4ka7Hw6mhlKCSmM/ZyaCmnayooZ2fnbOlm5Cno5iZkpuVp5C3cXN8inx7dnx/eYB+hIGJg4uBtZGebL6Zc56mnZOPgHfSfXrKf4CAgXbFste8u7eLiMBrx5KquoCwqW93uqem2quzwpJ/tqusjYKphOWKmraRjbGqhXiMgdK1l8Day73GvX158eHKiq2el6Ovp3aPsJ6tzqK8c32Dfm511MXIzMPObXyVlY+eg6yyyaK+wa972KyQkHKNgMasi5ORyJ7s4IySp5Caz9uG2KjIuYuH6sN8bMF+frmgnYDKe9rafX3Mr4+ZxaGWl5HN4nqAeOusyc3IhYXZgt7sfpC9b8Odj5SYraaHmXmQfH95epF+htyxynHCeYTZytKFxLa1kqbAzMWll6+kjJ+LlL6NrqmL38N9e852u8J7kYfXia6onouIl3uNhH+SgMejmJOO3rHEcZKflaWxjH130YBqdYmEhnuClJdRnXlye25kZ4l6Ylx3eZqda3ONm5F/X2hxa3R7couQdWZjtWClaZOYkYmNjZCLoaWip6OSiZShk4uFgpGfnJ6glJlWVlWZo6mao2RuYVdcrFqwXa6cpZqlmJ2gkpGXhImPlIBogol5iZORgnN/gZSRg2ZshoGEiYCOkaWOgYOSlp6Yi6aWg4+WppWTjoqFj4qJgHx6dNSwqp+ioqSnlJeOmaGlqraor5eTpKvNc29vbXh1dYB3eHt8enNycXOIg3fgc9GtqsPS1NDCw72zsayrsrSvsbWurp+0vMfKxLWXlq2rlZKNkpycpKGejpGSgoiNhoqWlqahnICdopOioJugnZuYmJmalob14PPk6NfR7f2MqKOopKKapK+bl62ooPbihZujqMGWmZmOi4385eXrh7TFw5758Ze7tLupjKVjaGZmuWnEgXXCq5eQoZqitWB+fWt8eGmMo5KOi/nxfo6C1893jpirml61nKeen5aQl4WNiYG3w2WskICYqaporr2kvK6xu4vJvsywoF5rfoB0cWy8rmq3Y6+2YWXHnsy2oK6smpaup5vKbc9qZ5L4k5ykx8XBbW3SZnB51W5wfMFtgXyDdHd4bHN6eHNovb/HdXtraGpscW9ucGd/hXBycXdxf4Vndnl9jJmEg3Fua4CFar93g3POu5fOx4CLaHFnwsiOk2mBdoJrx2nUtL3MyHl9gIWUlZOVioeFjZeJp6WumpGLeYCXkY6Wi4qNgXh5a3Fpb2xsd4CUkIWFjXWBiI2MhIeHg4SKhMBrcXp4vWhxcXF+fY+bk2xpc3uCen2CkI2HgY2CjYd3gouQlI+GjYqYloucq66ik46VjoCJeoJwa3FnfntwdXeKf29qeIZ3e3W6col+jpyMh4yLlotw0thyhZ6uq5iThpCFj73HuJeXlZ2akZKOjp+MjoWck4uKiY+JmoWlZmJsdmhqZWlpaW5tcHBva3Folnt/VqB6V3Z9eHN0bGW8aGWsamxtbWWuorinrKWFga5etIWdqYCdmmBoqJuc2J6iq4J1oZiYhHuYetyCjaOFfZiTd2+EdcuynbzMwLW/t3Vw39fCfZqPh5GdmG+BmY+XrYqfYGVpaWBkurCys6qxV19wdW5/bJmbqo6nq59yy7WjooOWcaWZfoeHwIzb2IKFk4aO1d+G5JSqon962aVkW6ZoaKORqYDGdM3RdnTMspqqyY2AgoPD0XF0cNmuwMS9c3bIc9fbd4OiXqyMf4SJmZJ4g21+cXBub4Fyc8Ktu2OseYLJurl619q2fI6jr6iPhpOHeYl+f5d4ioZ4z7x0cMJtt8V1hHvFfZOMinx8hXF8eHSGb6yUkYyG56y0ZnqBeYeKdGhotol+AX+hfgN9fn2dfoN/hX6FfwR+f35/wX6XfZR+An1+xX2JfI59gnyLfYR8hX2CfId9hH4FfX59fn6IfYd+hX0HfHx9fX18fIV9AX6OfQF+hX0Bfo19h34JfX1+fX59fX5+jX0Gfn1+fn18hn0Lfn59fn5+fX5+fn2NfoN9on4NfX5+fn19fXx8fX5+foR9hX4CfX6Ffbl+AX2EfgF9wn4BfYx+gn2lfpJ/hH4CfX6IfwR+f39+hX+JfgF/hn4Gf39+fn59jH4BfYt+iX0Ffn59fX2PfoZ/hn6Hf4h+hn2GfgR9fn19hX4EfX1+fYV+EH1+f39+f39+fn19fn19fn6FfYR+BX19fn5+hX0Kfn59fn19fn5+f5J+BH19fX6HfQN8fH2Sfgx9fX5+fX59fX5+fn2NfoV9A3x9fYl+AX0CAgQAgJCKh5S0w7fD3enNnpGotJeakc6mj7Gx0POvltLG7NapqJqQlqadmqifqJD9+vrWl9vdu7a/ydK7u8rm2dDx+IGAzdfhu8bqtL3l+5yWjo2AhYGEjYj4iImKhYWEgor789/RyMLW2svRw+jqz764sLXL2OPpzde71tuqo4+ZrqqugLCRp6GpqaSxy7jCu8a9vsG0x87e2cTBxMbSuZTR5/yGhP3vyLWxjIWAf4WKd3qBe3x2dH6PqumJkZGToJeUj5qXiJSXgb3Y99euoKOXj4x4dnB1cndranFxb3N2eX10bnV2d3NzbnJsbWphWF1mZl9hZ2BmZ11hYl1jX2Bhb3JrgGtsbWtoYWNmZmJjXlpZppSRjpF+eJBZX2VwZ3daXmlsaWNfXV+7m5etpaCSh3V3bZuYnMpquYCTxM+Mj/7j0dSB3L7c0duUl5aKnJGxjoDhvIaK9f/O8o2EjaX54Na4l2uT+cTVlsOZgJyCoqPNgYWUhq6rppKrv66qq6fi3cS7gMTWv9r/09DP6/7vlsPehov9kLe40K6L9oPw+u7s7ez6pbmZs83bzqyW0rWR7Jmw+8TOyriflI281IeTg97fv9nf5PuUqJyFob61paWEoqeysZ2HksXli4uG44ma+YDxyKGr/sXAiOLmhISIgqC90byVi52PxoyWzYmmtpbdk/nDgJ6Qr8nU4+uAi5+2va+CiJOQlpyM+42YrbeqpsGx0bvZva+lparCtaOdpaqUpZ+nrqedk5Tmgv3z7v6guKv56piXlILrgJWis7qzvqivlaqjubqcnoyCqrTTw7i4uvuMudnZvba+z+7Z5eO9lIeUlZmWrbG5rcHT4c3R3eDa1tfTgMvGt6yzut3z4ejauLPGrpuExM6tm+upur/g2r3A0OSzobW8m6awzdWuosLX4tHEwMq2w6+XvOLH27GxtKzg/tjKzbzAtr3Gw9+ZlqKlrqmnu7uQiaCrtLPGp5rcroH9vpiqurivtI//95Wim6CqjYOBsLPF99f12Y+m3by9xbuMgJylieffqNaB8MKqv9/LsO29nveYqbzBuKiirNLz8/6Q/ZCWmL+Ogdyf1NOl/5qJw67X0czC5pCSjpD26oeMk5SK+YeE9fTj/LWmo6qspJWVx9LZw5r/usii+pCt+dqPxrrVyKzsieierNmNx9ifmr/U+qSniYuuksCFoqid8ob3gIHf3ZiyoomVpKWTp6Cpo9mnqa/PvpD26NLS+rK0uKHpnLbYlJm0w6mkw8+jjevtqJ6S0JD79aPI85DeueHRt4uy6IyE5qW55vDp1s/Z0+7jyZzf9Pi+wNG6mqfx3fT/g5fd/6Gxt5u2tbiqr5/C6Zzkg5Liy8rL162jhquZk5+hgH59dYKVnpOhr7ughH+Sln2AeKiKd5SXrMeQe6ymw7KOkoR8gY+Ig42GjXzh29y9hLu+oZ2irrSgn6rDuK/M0mxrrba/oarImp/Azn13cnFpa2pucW7OcHFyb29ubHLRzLywqqWyt6muor+/rJ6blJepsLa8pa+asLSNi32DkY6TgJd9kIuOkImXqpumoaqhoqWara+8taejp6q3oIbG2eR4eujev66qi4aHiJKYgoeOiY2DfoeVpMp2fn99iISCfIiIe4KEd7vO5c2vqauflJSDhH6GhI18fIWFgoaNjpeLgo6RkIqKhYqBg4F1aG56fHR1fXN4eGt0dnB3cnN1hIiAgIKChIN/dnl7fXh4dG1tx66tqqqRjapnbXaEd4xpb3t+e3NramvMn5irp5+Lhnt5c6qjp9JwwYGMt8d8gt7Nw8VxyKjDubp6fH12hXuTeW/Jq3F2ztm1zXNwdonTwbihkW+T8cHTibSJeY13j5Gwa3B8caCYlYSWqZqbnZzFv66wgK61q7/jubm90eDVkLDGdXfbe5qaq5F21HTT1dPW0MfmmKiRoLTBuJ+LwKuQ8ZOj9K+7s6mRiYOpvXZ/cMDHscPIx9V+npV3h5+ai4pzh4+WlYR1kbHOdXVyy3iG3nHUv5yg27i2dczMdXZ3c4mgrp2CfZiJtHeAuHmLlnzGf+mugJSEnbO7yMtxd4aXnpN0eICAgoV523mCk5qOjKKVrp69oZeNjZCiloqDjY6AjYaOm5KJf4LJc93c09yGmZPY14aCgHTXcYGMmZ+Yn4+SgJCOnpqNkYF3lqC0opufqOd3mLK0nZidq8a0vL+kgXR+f4KBk5ihlKOyv7Wxubu0trOvgKqnnJaZnrfHub24nZymlot3wMKrmuSVn6C8tJugr76djZyliI+VrLSWjaa7v7Clo7KeqpuHp7aswZycmpXA2rStrpudmaOsr79+fIWDj4uHkZp3cH6GkJCahHmuiWXHmnaBjY2Gi3XX1XmEfoSLdW9pm6G10L7RxImcw62staSBgImSeNDPmbduyqqbqMi3ns2nj+CGmaaooJOMmMPl4u+D84OGhqqDeNaOtbqV8498rJi8t7OuvnFzcHfNwXBxc3ZtzXBvy8q+0Y+Bf4SDgHp3r7e5ponztL+Q6oOe89mGrKi+rpnggN+NnsyCqruVkbG71ZqZg4qcdplyg4mCx27NgGzCuoeajXiEkI6GlI2SkceVk5axn33f1ce/35uXnI7aiJy1i4ueo4+Rp6uPfNHQiYV7qXrg5Jq833rIqsm9qYWjz3p30pKducHArqyyrr+9rYW2xsmco7Ochpbc0ODlc37D64mWl4KblpmSk4SctYPLeYjNucfNwY+IcYp/e4mJgG5uaXWChXuDipV8cHB+e2prZotxYXR7i6F1ZY6MoJB2e3JpcXtzcXVvdGfCv8CodJ+dhYOJkZuKh4+gmpKnrllZkJidh5KshIeeo19aWFdTVFVYWVmhWFlbW1xcWl+tqJyXkouSl4+SiqGlkIKDfYSOk5WaiZSDlZd3enN2fH6BgIRxg3p9fHmHl4aTkJmQjpSKlpmimI+Nk5SfkoLP0tdzdObWwbO0mJSboa6unqirqKqemaWrr8VscnNyeXh5dXt9dHd6cMXP4dfAvL64sK6ipZ+opLOem6iqpKiws72xo7C3t7KwqKuhp6eYgoqZnZKTnJGUlIqOk4uSkI+SpKadgKGnqKaglpebnZaXk4yH9djWz8yystqAhZGglqmDjZmcmJGGiIT4o6O1sKeSk4yGgtLO0fWC7I2Trr1xd87Gv7dlt5yzqqdobW1mcm98aGGpm2Flsr2jt2JganK5qaKQhYus9tDjhKaBdIdyhoqeW15nYJCNi36MmpGQlpSzsqOkgKGioa/Qq6yzvczIjaW5a2fGb4SAiXlpvma9uLnBvbLPk5yLmaiuqZmFs6WS/ZWh/Ka1rKONhICgsm11ZbK7qry9u7xxlpRteIqFenhkdX2BfnBpkKW9aGVjt212yGrGs5ubxq+xa7u6a21saHeMl4hzcZmOqWpxsGx7f2uxcNGggI2EmayyvbtnaXiGiIJtbnR2c3Zuy292gIZ+eoyFkY6gj4N7fYGNhnt1fYJ1f3h9iYR9dna8aczMx8d1hIjPy3h3dm3GaHV+h4+Ji4KEbnd+jYN8hHlwhoydiIiOlM5qiJyWgoCKmauao6qNdGx0c3l6hYqOg5SfrKGgop6cnZeWgJCFhYKGiJeglZqZhYmKfnpqurynn9qEhoqgl4SLlKGKgI+Ve4GJm5+Kg5ywrJ+VmKWQn4+CnJucrY2QioevwJyWmoqJi5WeoapybnNve3dyd4JmYmtwdnuAbF+KbkuRgFhham5qbWG7umdvZm90ZWBZjJahtae3soOSsp+fp5d8gIKJc8XHh59htZ6QlLCeka6SgdN7iZaUkoV+hbjR0dt45np8eZN5bsWCn6aI6YRyl4uspqShp11fXGSwpV5gXl9asGFhsbWkr29jZmlhX2JinqSjkn7psrV82XyS59h+oqGun4zWeth9i8F3kp+LiqCnt4uIeo+TWXxjanBrq16ygF2nmniCfm12f358hH2Dgb2JhoaYiHPPzMO804mChYDKfYqbgIGNkIKCkpeCccXCeHhpiGrAyZCs1Gmsl7KkmYmdv3BvzoeUpaWlmJSTl5yej3OWo6eHj5qHe4fRx9Xaa2613n+GhXiJgYGAgXOBjW25eIK1per6wIB1aXduanV2q36EfZB+gn+Kfop/AX6If75+BX19fX5+ln2Ofsl9iHyPfQF8in2EfAJ9fIR9gn6EfQF+hX2JfgR9fX5+hH2EfoV9hXyJfYR+nH0Dfn59hn4CfX6TfQR8fX18iX2Dfod9A359fY1+C319fX5+fn1+fn1+h30Dfn19in4GfX19fn59hH4CfX6JfY1+AX2ffgJ9foR9BX5+fn19hH4BfZl+AX2zfoV9s36SfwV+fn9+fod/gn6If5J+BX19fn5/in4BfYh+hH0Cfn2GfgF9hH4BfYl+hH+CfoV/A35/f4R+iH+Ffgl9fX1+fX5+fX2GfgZ9fn1+fn2LfoJ9hn8Efn9+f45+AX2GfoV9hH4BfY1+gn2FfoV9AX6IfQN+fn2WfoR9BH5+fX2NfoV9A3x8fYh+AgIEAICgrZ+dn6jH0+3u0qyLla+S9MqGkZSStqPTqbmlzOrbzrqgqJmmlJGJ7ZSJkYz9h/qKo66fvLXiz8DQsLe9xsTd0MPT/tysvtrt4Yebopuo6duJkJKSkZKTjI2H+eqC7vH49Pfh6Ojs4d3e3Ove6fHk0snK5NnMy72+09HFutjGs4Cdn5qru6yTlYiAj7nOvLrCy9jg19jTs6++p5ifsaqgkoLr8N/s4a2lkYR9e358c3J4eHpvdHR6jrPc5Oz4gPeDhIyH47PX2dW2qamhgHh1cXdzd3dwb3B1cnZydXVzbGlqaW5sbm5tYmNlW6NfY2VgXGFjY2JkaGNhYWRmYmlqaIBmamNhZWlsb2tpZFZSnpaFkZyHbn1WY3JiYWdXqqChWa5hZGGveK9wZomno3qyc6qWta13k6SP0ZCMhov8gerswMH72/yFiIWIlY6HjPmR/PnZzsvEzdu61eSF+si61N+Ekqi1o5+qo6KnlJempsnhtISkwL+1wum028eyy8e/v4Ch4dvP2PLZu8nS6Y/MhJaXh5Clw8usgoaektbC2f3bx6zAzuyXlrvlqrjCv7bH9tCl39GupoDihbj3g4/jpNvGhPzaj4WFl4eepo6Wq7GHpLevof7X04WZqZ2Fl5iH1OCc1aSVrrz0m5qqr7y+raWrn46Rm62XkZKdloS4v8LGrYD9r6PkwP2h3L6Epa+2p7mW/YWcrKetsriRmqDB+/Wqxrest8Oip5eZ+eGFjY6FlI2QlPb1k5ibxv2erraqm5f41rnP4N3y/fn+hJ2nrr2wq6y4vNT039/06dbd7PvX1cXY28Gvtaq52dPdy7OypZmez+7q0NPo+fHp3ebW2+yNiYD3g/z3iIyQjfjbyLCimbGvm5mrorC1uLK+6Or81sa+qbrBi8/BmYnoi8PJxdm+ysKqobSMnoaVidXQzNP3i4+Q79zMxLS7nrPv/ZacnJmprca/sp+hvryxqKyUgYyng7732JeWqLOTn6HEnpaWm4yLg/S7y+uUzIXsroDm1/mejYCSw7GxtaT28b67muCIlPb4oK7w2f7Q1Libk5CLtZij0oCCydrJ9or8hoaBg/PV2omPhuTe8ZGQj5KGyICWgObJiIbz44OFgPOsp6fOxrTutNvj59fCopeZmvTegYuxg5ajpvGc2viVo6//g/iA29eXm6eau5aN67eB4veIjJPg9oCM2cKhyKu1wamZkKrHnJeDi/+ksqKMn/GRk4KB9ImahZiagbuwpvSK5YapmobYgo2bkq2xheL/mLusiMa1upKKhq3drYaJhJ3IxcLG8cnL3NSFhLa5u7iorLDNnYOghJjErvuioayks7GovZybxqP++Yjw2N3d4Y6K8dnWtPXJ14CKjoaEh4ukqr29qI95f5V5y6lxdn59mImzj56KrcO3r5uHj4KNf312zoB3fnreduZ5j5iKpJrFsKWzk5yhqaa/sqSz17qUorjHum57fnqGvrZwd3Z3dHV3cnNvzcFsxcrMys68xMHGura6t8O5wce8rqakuLKop5ycr66kmLKmmICGiYGQnpN+gndxfZ6yoaCmrbe7traxmJejkoeNnJaOhHfb4M7b1aijkYaDhIqJgn6Ghod8fn+GlbHT09Pid+F3d3575bHP0dC1ra6oi4WCgIqGioqDhIWLh4uGjYuKf32BgoeDh4SFeHZ5bMNzeXx1cHV3d3R4f3l2eHp8eIGBgYB9gnl2eoCDhoCAeWplwbmfrL2ggJVmdId0cnlmysG/achxdXDCfrR5a5G7tnusd72nyLp7lqORxIF7eH/ddNjUtbDcxt55dHV1fXdxdtl94Ni7s6+strujvMNx2bOhuNJ+g5elmo+XlJKThomXk6vCnHWPqamiqcqfxLmftK+rsoCPxMHAxNTBq7O+25C2c39+cnuJm6KPcXOFgcaxv93Gs6Grtsl/f6vgmaSvrrbL8M2b2L2lmHzfg6nZcXrGl8W0c+DEeXJ0g3SFinh+j5J0i5WTieDBuXKAj4R1gYB2v8uHw5uOpK3ZhYSVk5yelIuQiHd8hJKDfH6IfnKZnZ+hj4DVoZjHrfWj3Kx1i46YjKSD4XSEkZCVlpx9hIWi0M6RppmPmaeFi3+C3NF5fHx3gn57e9negYWGueiKlp6TiYHhw7C+zMzc49ngdY6MkJ+QkZGcnrbLt73Iv7G2ws6wsZ+xtaSUmZCZs7K6rpyakYKIrsjEsrHEzsfFuMK4t8Jyb4DNbdXOcHR1dtK1ppeShpOYiYydkJugopmfvL7Ptaegk52jfcS2hHzTeqOvrr2krKqalamAknJ5brOyrbXNcXV0x7eloJiah6DO132BgH+MjJ2bjX+Al5aRh4R1dG18aZ6+sHZ2gIl4gISggH18fXZ0btGosct8s4Dqpnje0+iXkICTvZuOk4POy6GhksJzedPOjZzIstCrs5+KhYeHoIqPtGttsr+y5YDWbW9rb822unF3bsK8x3R1eHRvqWl3bcCpcGrNwGtmZcWEfoGfmJLUncDD0L2uk4aJiuTQeH6ce5Wal8uOzu2HjprqdtFrub6Nj5eRsZKKxY9sxcxycHbAyIButKaJqZCaopCFfZixg4R1fOKLlox5i9h9g3dy13mDeIeJdK6Wjt580nWOg3bPeHOCe5GRcsrgkbWedbiqnXd/do+ylnZ1d4mroKWlx6aitq92dKKgoJuOlZarhXGJcIKgldmHhZKFlJiQn4WHrIvV1nPWws/N0Xx11snCruW4woB4c3NxdHiIj5echnZobntjqpJfYmpqgniXeoh4kqGYkYBxeG54bmlluG9nbGrFZ8hufIB2iYGik4qafIKHkY2jmY6asZyBi5ykm1lhXl1nnZlZXFxdW1xaWVtZo51YpqipqK2do6GlnpmamqWdo6SdkY2Hl5OMi4OGk5KGfZSQh4B6d3F6ioJxdW5rcIudjIqSmJ2dmJyZhIiNhYCEkIuGfnPZ2snb1rCsm5OWnKiin5+mpaSZmZmgrcbZzM3cc91wcXVz4L7T1tnEu7vBrKain66oraynpqitqbCqsa+xpp+lpqmoqaapm5WajvuPnp2Wj5OVlI+VnJeUl5mdmaGioICfpJmYnaGkqKCflYaB7+bF2ei+ncaBkaOOjZSA+vj7gvuQkY70kbuRgp/v54uphOzb+OuRpKydx3hzcnbRbtDJravGsctua2lrbWdkasRwxL6pqJuepaqZra5jv6CSm81+gJGck4qMioqLf3+OjZqskXCFlJmQmbCVraiXpaGfpICMsa+yucCznaWwxpSsaG9sZGtzfoV7amd1dLieqsWypJahpbNsb57ikZmhpMjb9t+X4bGbkH3qg6XNaW2zkrmtaM61bWdqdWt5d2hue3xneX5+eMewrWVteXRpcnFrsb14sZKPnaLEeXiFgIeJgXl+eWtvc4B2cXJ3cWeDiouIfIDBlpK2o/nB66BrfXqFe4510Gl0fn6FhYx0dnWEqK2BkYl8gpF2d3F0zsJsa3BueXZxcsvOeHh5sNd4ho6HfHjMu6+3wcHP087PbX96eot+fH6Fipqwo56lnJibqa6WlIucmomAg36FmZmhkoiMg3V9mqyqnZ+vsayooaedm6ZcV4CpWKquYGFhYK+Xjn+Den+GfoWQg4qQjYGDnZuomZCPhY+QcLe0enPKdpSio66VnZuSjJl7imZjWpujoaSyX2ZhqZqNjomKfZa7wWxwcG19eYSDd21sgHx7b2tfa1heU4iTilxeY2pjaG+BamlobWlkXrKWoLNqonzunXfi1eadnYChuIh3e3C0s5GPg6tiZrS2hY+plq2VnpF/eoN/kYKEoltdnqmh1HW3XF1aXrOfoF5kYKikrGFkZ2BemVdiXaaVYV22rl1SVKlnYWZ3dXa3ka2wuKmfi318fNzOdHaQd6eUjLCDxeWAhIXSbq5boKJ9fIeFs5qWoXFdrLNjYmOnq4BZlIp2in+EhX13c4eVc3JsctF3fnpte8Vsdmtpy3F4cnl5aKuGgs1yymp7eG/qe2R0b4B7ZbnLktiXW5mZgF99a3yWhG1uboCXjo+UpY+HmoxnaomFhoJ7g4mVdWV5ZnaGgMR1dnx5hIN9hXR4lXm3vWTCqre3x3Bmx8CzpsquuZB+gn2WfgF9hH4DfX59mn6Ff4J+in8Dfn5/w36cfQJ+fYR+qH0BfKF9iHyHfQl8fHx9fH19fXyFfQV8fH19fYR8hX2EfgJ9fod9iH4CfX6LfQF+hH0BfK19jX6KfQR+fn18hH2EfAJ9fIR9Bnx9fX1+foR9A359fZB+g32IfgN9fX6GfZl+hX0EfHx8fYd+AX2XfoJ9iH4HfX1+fn59fYZ+in21fgZ/f35/fn6Ef5t+BX19fn59jX6Df4V+g3+KfpF/B35/f39+fn6Pf4R+Bn9+fn1+fod9BH5/f3+GfoJ/kn4If39+fn59fn6Efwl+fn5/f39+fn6Ffw5+f39/fn5/f35+f39/foZ/i36CfYR+AX2Efgl9fX5+fn1+fn+Gfg59fX1+f39+fn9/f35+f5B+AX2FfgF9hH4BfYZ+Bn1+fn1+fYR+Anx9hn4LfX19fH1+fX1+fn2ifgF9jH4DfX1+hX2Cfod9AgIEAIDC0cj2+IORo6+yuLWN8JakitPw9aqivrGz2MfWt9nHsq2gmZaepayj/IGUrZukn6qpoLivr6rHwrnuv63Ju7TGvbyyn7jI2PDd4O/965GK9+uI+pOhkP6HjZSMh4KH8urw8+/4+/DuydHR0+Pt8+ri8YDp4PqLhPrt9/ri56qnvoDAucSzwdLU29/UzaCe4OjSucHFwL/Luq2VnI+FlqChqpySn4Dz64LZsJuIf3p0dHR8cnNvb3d9enp4foSJi46Qm6imma21lI+Ei4yHent6b3BrbnBydXVxcHFsb2xuaGZlZmBlbGZjXWFdWFxcYl5dW11hZWlxaWVwY2BeZFhXX4BdWFJVWV5dYWBXXVmWlJiYmYptfaZlbGldqYOXqFSTipmlWamVpHRZYLebkl9hq69we4i11Nro263g/fWAkZCD38zg+O6KosLCmJKrnJGEiYvuz96Dvp3J8dqB6fXg28Cstr3R46bNsr7BiOTwkbe6x5mfqrTb2+HExr7aguvDroCn4NOylszh5dDQ16z9/oCTlJWos+ulweP+i4+T49fDpdK01+KCh4HM2bnbhtaph7yHw7SUhJzf4IaM1uPR07B+vfn2gdz98vaHn66RkZCou6iMi5Lf0NaMnaKrqIuKkJOfs7eM+dS2/JSblqu0sbS6ybCM9fqDhI2WqLPF2My7sICF8Z6HlvK7zt7fgbCyva+B+4Dsk7mtpMG8qpely4SOh/GWqqqSmpiZjJObm4eYmuPS64vy2aOZkv+WrKebhsTK+fbqy/b18ICQt8OpssDI2tHr3+TS3OnX4vP59vv79Oba3NTn3Nfj+Pru6vjTxLTV64fv9ezs4+X08f/+/YX86YDs8ZWUkYmGkf2+qp6Snq7LrsLK7dj26OOE5Lafp6Sg+dv9hJeak4eEkJeuzM3Muo+Ipp+zw9LY3MjO1t7++eXU3ujAvKGdj+Tq4veWlpKdnaKomIyhq6qZm/yho7Slupadguqft7DDs7u2mIu6yOqDk/jFx6qV292Bdm5ujoD/x4CIss6xl46D38jH1tDopp72mrq/2ILj1sewsr+U1vmyvOKH/YqO7PqdmpX7kfmCppWL+9fuz4yF2+745+r38e3e58jfpKbLh9iersT2sJSLh+Xb+orQrreW3NXIqLC/qbHukMSOi7ON7tHd9+OFu+ecy+nv0+uChIeT44H4+enwpoC2tKOsoaCXwc/S3cKqjJGgkZKRhPGSgIuugbqlpI/r/KrohfOSpY7m/4uOhoDwx83AlITw7emb0YewoZSe7a289KC+poGfyM6r3M6ekoydn8jLo4255IiJwqbDiuzx0rCNhZ/bqp6frLaRo5mQj66e44ykopT364Gjpqm3rI6CzYCzu7LZ13h+hpCRlZZ4zoOLdbTPzpCIopeYtKeymbSll5aIgYKHjJON3nKBmoiQipOWjKOZmJaup57NpJSrnZqtoqCZip2qt8e2tb/Lv3Vwyrxty3aCctBuc3dxbmpuxb7CycTN0cfIp66vrbrEyb24w2i9tMZvasa8x8y5vI+NoIChmaKUo66vtLuwrYaCvMOxnqamo6StnZKAi313hIuMlYuDjHXi23jOrZqJg4F/f36KfoF9fYSMiIiFi5KWl52aoqmsoq24nZyQmp2Yi4+NgYF+f4SEiYqFhYaDhoGEfHp6fnF7hHx3cHZwbG9vd3NxbXJ1eoCIf3qIenh1fGxrdoB0bGVqbXZyeHZqcW66t7y5uaWBl8V5gH1wy5u0yGeworLBZ8art35ma8qvpWhqvL54f4qvy9Ddy6fO5+V1gXxxxrzJ29eAjaWphnuSg3lweHzUv8JyrZCvz79zz9LBwa6do6y9xZWyo6mthdzsi6WptY6Ok567wMCusqW8cciunICVwrqfiq/Aybq7x6jZ4Wx7e3yJlMagrsjadnh/zMK7nLmgvMNuc3G6xqbAc8Cfgap2rqKNfpbj43+DusW9wKF6rdfZbcDd1Nd2hJd8f3iNm4x3d33IwsN+g4aOjnh4f3yGlZp538Op34OIf46WlJadqZR42NdzdHmDjJWmr6eXjoBy2Zdze9CuzNvHcZeXoJRv3W/OfpmRjKGbjoCOq2lybcmAk41+goOCeX2DhXmFhda903vbwpCBf92GmY+GdrO06drdvtzf2HF+n6OPmaOot7DBtLqvt72tuMXLy8vMyL6zuLG/t7e7zdHAw82xqJ22wHDI0MTFvb3HydPSzmvRwIDDw3d3dG9wddejlIh7h5iymauqzrrZv7hqwJuHkY2J6s3ldIOGgn57hIWasayvpIV9mJGhp7G5uaizt73Xzr2xwcaim4WCf8fLxNJ7gHuChIeNenaGjIp7fsh+gox+mouBasB9i4mZjpeRfXShs8ptfdWtuox8wN2DeXJylXzzrYBzkaKPenNqvrGstK++jo3eiaCluGm6u7GgpK2Hy/GbosFy1HF4zdZ9fnjSds1tiHpw0bjMr3BsusbLvcXJxcO5wqa0k5GoaLN/hZa+kHZwcsC80HOxnKKI0tHHqbC8qK3kgrOJgJ6C47C+7dOCm76LrsXLs85sbG15vWjPy77GjYCak4iOiIaAoKuttaaVenyLf3x6ccp+bn2gcZ2Ni3zV4I7PdtyBi3rM33x8dHHcsr+pf27SzNSQzIWljYCDtY2s3IWejnCEqqaVxreGeXaEhqWni3WbvWxypY6kd9rVwaN9dZnNkIqGj5V4i4F4epODx3mJi4Pa3HGNjoySj3dzuYChrKzExGxzdXx7gH5nt3F1Ypq8snt2jIKDloyVf5WNgn9zbmx0en98y2dwhHN5dn2AeIyFhIOUjoexj4CRhYOTjo6IfYyRmaSTkJeellpboJhWoVtkWKhZV1pYV1RYnZeapaCqsKOpjZGUkpqjpZ6Yn1WYjZtYVZyUnKWZmXl6iYCJf4h/i5OQm52TkXVvm6aYiZCOjJGXhoB0gXV1fH+Bin56g3Tg2nbRtqaYkpSVmpilnZ2ZnKOqpaKhqbG1tbq2uLzAuLzIt7muuL29q7KypKOho6akq6+rp6ylqaSpn52co5ObqZ2Yj5qVio+Ql5aRjY+Slp2nnpirm5aWnIiMl4CWi4OMkpiUm5SIj4nu5fHm58yryfuXoJqL+8nl/oPjzuT2gPje7JWAg/rk2YKE7/SLkZ260M7ezrLK39x1d3Fot7rCzM13gJOUdHB9c2pnbW/Gt7Njn4yfvK1kwL+vsaOVmqKvrouhmJqggtzmg5mZpIeDiJKiq6mjo5aoZLOllYCMr6yXh6KtsKyquZy+y1xnZmpwd7CcprnFaWhvuLKxnLCZq69kaGiuu5yuZrCahqRso5iHgJT064CBrrW0tpyCqsfIYrHLwL9ocYRucWt7hXZqa2y5s7FvcXN4emxtcm92fYZtzbak0nZ7b3yGhIOHj4Bqv8Jpamt0e4CSl46DeoBozZRjbLyn3Om7Z4WGi4Vlzma/boOCeoWEeW96kFZdWq93gHhucHV1bm1yd293ecizyHHQuIBzdNF4ioR7b6ym2s/Rr8nMy2lxio1+hpCToJiilp6amaOTnKmtsbGwqaKcnpeem6GjsK+jqquYlYuhrmCxurCtpqKpq7avplespICjpGFdXlxeYbKOhXpueYiciJqZtKG2npxWnYN5hH5918HRa3p7dXVxen2Rpp6hmH95j4eUl6CropOlpKu6s6Odra+Nh3R1dLK5srlrcmtzdnh7aGd1eHdrZ6hlaW5kg35gUZJhaWp7c3l2aGGVoq1cabmdonVpqtiSioKBqX3xmIBfd4N2ZmFYop2cnZitgX7Sf5GSoVqfp6CTl6R/y9+KkKlgt2FosLhqa2SxYa9cbmVfuKSvnWFcpK6ro6qsqK+lrJigiIOMUJVfZW2NeWdfX6eutmKejo+Ay9DRsbTGsLHVeaeCdo143Jye2cuMg5l3j6KpmqlZWFlgl1KoqJ6ffICGfXh8dnFvhZKTmI2DbnB4b29uZ7twZW+YYIl/e3HI1IDDbs1zeXDEz3N1bWjOsbWcamDCvLuO3qyncmlwi3Gdx3aLfWh6k4p7rq13bWp2dIyMc2qLolhckICObMzGtKZxaprEgHt4e35odW1mbX9ttWhvdnHHyWmBenp/emhkpIV9iH4HfX5+fn18fZR+AX2kfgp/f35+f35/f39+h3+TfgZ/fn5+f3+tfgN9fX7lfYl8hH2EfAF9hHwOfXx8fH19fXx8fH19fHyMfYR+hX2MfgR9fX1+hX0BfpB9gnyPfQF+kX2GfoV9g36IfYN+hH0BfoR9AX6FfYJ8i30BfoR9jH6DfY1+hH2LfoJ9jH4JfX1+fn19fHx9hn4DfX59in6Df49+Cn19fX59fX5+fn2Ffol9qn4Bf4t+AX+EfoZ/kH4Bf4Z+g32pfo5/AX6EfwV+fn9/fol/C35+fn9/fn5+f39+hn0Dfn1+h3+IfgF9hH4Bf4d+EX19fn5+f35/f35+f39/fn9+hH+EfoJ/j34Cf36IfwR+fn5/hH6JfYZ+Bn1+fn19fYh+hH8Cfn+ZfgV9fn5+fYV+C319fn1+fX5+fn19hH6EfYJ+hH0DfHx9hX6CfYh+gn2LfoJ/hH6EfQR+fn19jH4BfYR+gn2IfgF9AgIEAICUireC2rnEgae/ssGZ74KCjoWznaSlpbCnq7iYlK6x0KKEjYWct6qflYPp/fP4kKSzr6aur6O8wra1ubm6xLnBu8yyoa233Nzc2ev06Inn/IDu9P+FhIqF/YuHkZiF/Yuck4yMg+/M/OTy9PL05d7v5dfi94KJhfuAgOji6+fex4C2yrnMx7e3ydnMycjDorTF0ceznpOirJ+hlpKkyNjc1cbYs6iknITn0LeaiHp5gn5ycW5rZ2hucnWGhIJ4eX2GioeCg4GBgH2Dfnd4dWlsanBpa2lrbGplZ2NmY2JhZGhmYWNqYV9gZ2dmZWFeYmBnX19iY2FnYGNmWlZhW1dbVoBUmZlRV15SUpKOhYSPlox6gYCQWWdnYaSak4yPoqdcoVtbWKablp2UsG5vdI2Dsquxn5+VponKhH+z3eiTpZyT/IHpkpKtrJ2KnKeoj5eviNC+zuaHlfzK1PGdhIDX2ua7ys/VpMzQpJqps5X5tamWhq/Oysrpv8/L14aXjr+8wYC3tJyiiZu6x+LL6/qCmYjh1+yXmNC52qrHhpOCvsrS5dyVm7n3gubo3bqkuIb+3fmFkf3EnvrYmW5zxbD4oM3R1I6gpuvzga+EoaSXn6mnkbKnm4+Dg/CHnay3r5+JlZ6Zoaun/5SW7eGFpbCf99jL44GTrqKpvLCai46emZSxy4CgnpSmqZaD3/CBmZurs8e4lIuHlaS+sK62tKOow87ih4jSo4mmopWGlI+WmqOUh56wnKKrkYyinIuClpOXnKmYiYjm6ony3pGQwtK9qbezxs7c64CK7N7g8v7e2O38hv39ioP36dq7we7n3/fl2cPdi4j99P338tb24Mjk4d/b3YDn8+rk59vvyL2+ocWrytvj5uf6jpv91dLF066K+fns6fLag46Rkqul6s6zzLqqr5+xur7ExcvR38rO2er+68OwsbrQvcq2tMDt6YyMkYP4i5GRlKShkZWcjYWC8oTd3s/viuimuqOdtbmaheXMk52hpJeZm46Nh6yRr+KForuxvoC/s5WTj4eCttzZz7f65Zer2te61LzMzdW2mIqFjeCcjY2vp6Gzr6ylivuBhJaD+OnZpa67urLNs8fdg4jt5M3rtrnGsqWLiZmMosaXl5OPhYCG8MzDjfHcvLp/xaailoWWn8KJp5TqnJmtlunut8SB34+Rmoj194mRkuiXrrGxtoCfkI+dqbO71fSCyK6wu5qyqpmagfWAlZKP+of774ygrOeAmpqfkZmM8qSSoOaOjofvsKrnl8qduI3oz+yHtYXI5KSggN+Ai7+zi+2fz9uzt8XDwMHs58Pow8DSxM+u6/ajieTJ39/t5oWVlcbEu9Ti7Jyg8eHt/bbdrIOk9tGE8oB/dZpxx6y1bouhmKOByW9xeXGbkIuMjZePk56Cf5WXsYtze3KIn5OLg3jT4t3mgpCdm5KZnJKlqp+eoaCgqqGooq+aiZabt7S1tMPPwXa8yGfAxs1ra3BsynBrdHhry258dnBvasap0bvIycXIvrbFuq22yGhvbMhnaL+5wsC5pICUpZmrpJqZrLWrqqemi5ypsKeYiYGNj4mNg4GMq7u7t6y7nZORjXndx7Wbi318h4Z8fXx3dXV9gYOXkZOJiIuXm5iSk5GRko6WjomMiHh+eoN7gXx+gH12eHR7dnZ0eH57dXiFdnd0f39+e3V0eXZ8dHF4eHd+dXmBbGp4b2txaoBnwL5manZlZq6vpaKwuqyUnZmyanx9dsa3r6amvsZsumtracG1rbKpxHp3fpaLuLCwkouFlnu/hoCs0NmFkIWB6HPQfoCWlol3hZCPdn+Ye7qrvs55gdq4v8+IcnLFxdKtu7i+kLSzlIqYqYrvopeIeJ+4r63Irbi0vHJ/e6qpqoChpo2QfIuhrMi40NtvgHLEws19f7aqvZy4cntwrLC8z8qJi6zZcMzN1aigpHHhxNlyf+G2m/jaoXR3wqbeib27zoSWmeHqgaZ2i4p/h46Ne5SLgnVwctN2hpCZk4h4gYiHipON34+Q18N1kZeH1r+30XN6kImNnpSCd3iDgXyVp4CFh36NkHxvxdFug4iRl6qdfnd3foeck5KWk4iKqaq7bWuuiXaQi39wfXt/gIt/d4mYho6WgHqLiHpyhn5+hpKGe3nLznreyn98o6mdjp6ZqK24wGhywrW3ytC5tsXSbtHQcG3Lv7qeocLEucy7uau0cHDVydPKy7LKvKW9u7eyuoC8zMO4wLnGpp+okbSSrLi/v77Mcn7Tsauhrpd53+XR0+DHdH5+hpmPwrKcrZ+VnY2gpaWlqa60wquxtsPTwaSenKOuoq2hmaXLynV3enLPdXd4f4iDeX2CdG5tw2y5w7nIbr6AjH9+jJJ9cMq1doCDh31/fHd2cpuIo8xzi5aOl4CYjnl3c3Bqnrq1rqLr1YSbuLCgr56xr7aeiIOBhcaDcXKLhYOPjoyFctFsb35rzcK2lJukpp2ql6u2am++va3Jo6Kwn5FycHhpfJt6fHd1bGpxzKqnfuDZvraAz6qpnoeXk65/j4rbnY+bhdPjnqVpv3JzfHDHyW53dL6ClZKRnYCGfXmGjJues8poqZOXoYWUkoGGcNRthn161Hbg1XeGkcpwg4CIeIF81ZWAj9N8fnjXpZzJfbSMpYPdvdBwlG6wyYmEb89weqWZeNKIrLqVoKajqKbEwafIp56rpq2S096NedK8y8rSyXB+e56glK2yvYeJ1svM3KnHlnGJ1rN0zoBrYXlht52pYnaGgohrrl1hZ2KPjnl5e4R+gYlzb4CFlnlobWN3i4B7d23Dx8PMdIGIhoGEiICOkoyMj4uMk4iRi5eKeoKGmZSSkqKsomGXnFCWmqFTVFlWoFdTWVtTnFNdWldYVp6Krpynp6Kln5egmY+TpVZbWKFTVaGepKCbi4B8i4GPiX6BlZmSj46PfImTlI6GfHd/en6AeXd8l6Gkn5qijYWHhHfZy8Opno+QmpmUmZqSjJCZnZ6uqqympaq3vLiwsKywsa66sKuuqZiemaOco56go5+Wl5SdmJaSlaCdl5mrnJaUnaGhnpaUmZabkY+UlpOclZqojYWVjouPhoCD+/2HjpWCheDj3djn7dfGxczohpmalPnp3tPS7fmF6YaHhPTo3uHd+JCQl6qiyb7AioSAjnfEkpCz0tV+hnl122zHdXeKh3tveoJ8bXKGcbSktcdvcsWrs8N4Z2aztMKlr6yriKWgioKQo4PqmI9/do+jnpywnqmnrWRua5ubn4CanomLeIOTobasvr5iaV6usLhtb6igrpStZmxnoqCwvbuDiabIZ8C8yqSenmjPtcNnccetl/fluZKW3afTe66r0n+OkeT2haZre3xxeHx7b4F1cWNiZLxqdniBgHdrc3Z3doB6x4+TzrtqhYV0xrawx2xugX5/i4Rzamx4dXKFkoB5em98gGxis79hdHmBh5aMdWprbXaEf39/fHNzj5CZWFiXf2x7fG5hbHBxcX1zbHyHfX6HdnJ/fnNqend0e4N6dHHBu23Pv3NxjIuIfomLlJqgpVZeqJ2aqrGkoKy6XbOxXlypnKKKjqiqpbGioZaiYWG0sLStrJ2qoI+jn5uUnICepqSYoqWpjYuQiJ+DmKGipaWrYWisk42GkYBs0tTDyM29a3Vze4yErJ6SnpKKkoWWmJmamqCorJido6q3pY6TlJSalJyUi5m9uWhqa2S5aGprbnVyampuYl5dplmfo5qlVphkZ2Rkb3NmXbKnZmltcGpraGVjX4+CmbRjc3x4foB9dmVlYF5ai6KemZTkzXaNnZeTmIidn6COgISEhLBvWl91bW53dXZtXrZdXmlYq6egiJGUmY6biZigV1ufo5mslJWckYVeWl5QYHhlamdkWFxjtpmXd9LTw7+P0by6q5afi556gXvQqpmEdMDPho5Rp11dZVydoVhgW5x3gn1/ioB4c293e4uNl7BaloWGiXqChHR2Z8Rkd3JxxmzUxW53fcFrd3V1cHZzyIN5gc1wcnHJmJK3bKuGl4Xprbxkel+jv3lzY7pjboqDbMN7j5aBipCRlZGmqJWtlIuWj5B8wc56ar6zwcLFvWRwaHp4eIiRk3F0wbu8wZzAf2N0vKVkuoR+g32GfgF9hH6CfZZ+hH2ffgd/fn5/fn5+hH8BfoV/AX6Gf49+Bn9/f35/f61+2n2CfIV9i3yEfYd8BX18fX19hnyIfYV+hn2EfgN9fn2NfoR9gn6EfYN+j30BfI19g36PfQh+fn59fX1+foV9g36JfQF+hn0Jfn19fX5+fX19hnwNfX1+fX18fX19fHx9fY5+AX2NfoV9hH6EfZZ+gn2WfoJ/oX4FfX1+fX2MfoJ/iX4Ff35+f3+NfoJ/oX6Cf4d+hn2ofoR/AX6MfwJ+f4R+An9+iH+Cfop/hH6Mf4V+gn2Qfot/AX6Ef4x+gn+Jfo1/hH6LfYV+C319fX5+fX1+fn9+hH8Ffn5/f3+PfgF/in4BfYR+CH1+fX1+fn59h34IfX5+fn1+fn6EfQF+hH0MfH19fn5+fX1+fn59hX4BfZN+BH19fn6GfYt+hn0Hfn5+fX1+fQICBACA9PvuhNrK59+QpJKhn6WE3syAqNa2w6mlpKmnnpyirqWzsqWTn7K1sp6amo2KkpSgobGisbenm5eTo6yeqaalwK/B0sTc9oL//frX293lhIf2+4rzhouKhoXs5IT95fWFlYHd8YGRgoX+hvju3+nt9vXq7e6D6uzy+vTs8uDt7feA7t/a6N3Y0bq3ur2ZmJP5h5ynqsrM1PHIpKiyyr+lwq6rqLSeiY+G+YSK+M/I1sOqlnlubWtjY3FtcnhxdHR2en57en6BfXyBe3ZxbmljaWpqZmNlZ2ZnXltaXmVrZ2hmZ2dka3BlZ2JkZGZoZmNjZ11aXmJaYWVeW1hVXFxaU0+AVFGcToyMh4B5eGt3eHt0dpZYYlpXVlekp6yho6GXm5+nnZ2grWRxx5+TgG3H4tK/+9XL2uPk0/ODr5jNjMKswqKqu7G5oI+Oo7DHhsCC2tWryujljZaLgO+BjoX1u/6GiZmJ0b/UtajMu7fh6ujqyqaamJS01b29xNHag6PO4uKA2p+qnY+Kn5Kq0KSh6oqIg4b3kJXYyNXlpcTo7uKIoZjW/9Hx38fM/O3pnKH25/+Diort6di92N+j5oty+LGuiIellbHGsKnpptaRlqCol6CdlP7JhpujnaGuxMOttpycrpiVxsO5uozvs7WBobTAl8+hr7fAjK7a74uXh46FzbqAlaTf7diEmMyb6ZWE/4KdprOekez5iJ2lu66tq7zNqpKltMLOqYLr4t7x5e6Rh5GQgpmjoe/Dt+SEmZqnkqu/0sKrj4yS+YKdoqS77dLW18C+2ezwh5GF/PPz1cjL4/qKjIP5hYyM9Y6TjIny3uTV4v6FhYj78OHf2d6D/fr7+OiAhoCKityxvMbI/9TJ2tfsgICJiYPr6tLJu8GsoPDV6P+Ot7/CtJ6sy9XJvbLE0bnYxMS1tcHJ2ejmw8vj/8+vy9nDr9DT2NfmgvWKjYv7+eGLlKSamKaXjYmBiIXgtpu6u8anpKCMua+fo4/0rvrtk5GSjOqblpWGgJORpriQoKCAv4bYtIvW0NS+w7SJp+Cyy9usqZiWlcLm28iigdarrJqNl4v+iIqOkYuHhv6G7tDTsr2fvb66wsvbk/zU/Nzr+tmPgN7x/5OD/oGnm4rkxJ2fguC8loS/l4B+f5t1v3a4wY3HyoHCvZqIw6XDqoCl4LW8uOPYha6RutqD4rCXv7CAzcOsnbWz3OTv98jQyb+ykJmeoI2WkbGqj52Ni/qVtaickpCto/CE+eKhop6llYKkyZ3S1tHVlZnXq8uW7ITvjLXWvLvF2+KXx4GVnqa9+tPF09HY09rX0sbH397V2bKH/bOe9vLS1dWyg5273NbZ4eXct8+smbeSzeLssdv9lOCA19/OcMG3zsR7jXuIh41yxrZujrqapZCNjpCOiYiMlIyYmpGBjJ2gnY2JiHx8goOQj5yOnZ+Th4eDkJaLlpKRqJWks6S6y2rO09K1uLy/a23AynDEa3BvbGu/uGrPuspteGWuxWlzaW3Scc7Gtb2/yMm9v75qv8DEyMW/w7XDwMqAwbixvbSurJ2bnKKGhX/YdYePlKyrr8apjY6Yq6aPp5mVk6CMeoB85HZ958bJ08Wrm4F1dHlxbIB6gYl+hIWFi5CNjI+TkI6XkIqFgHpze3x9eHd4enp6cWtqb3mAfIB9enl3goZ9f3d+en1+e3p6fnJvcXZudn51cGtpcnNwZmKAZ2e/Y6+uqp+WlYKWlpuRkLRpd2pnaWvBxcu9v76yubrCu7e6wG961qObinTF1c2/58zBx8zay+F7qZS8eaGTpI+PnZajiXl/jZmrb6dzvr+mvNjXfIV1b9pxenTVqNh1eId5uaq9o5u3paTHyszOuJaLh4Ogtqmpr7W7bo21xMSAwJaZkoJ/lIaaupaM1XZ2b3TWeoDCrrrQm6vIzMh1iIfB5cTWzMO94NPPl5TXz9tveH7Vy8aswsWU3pB37qejeHiWiZq6oazkoMR9fouOhYmCgeG5dYKGhoqQpKORmoGCk4J/oqGfnnzaqKtxi5ShgLeYoKe2haTEz3iEcnhzwKyAipvHz75xf7iRxX5y4W+JjJiIhtjYd4SLnJWSjZuqjX+IlJ6pi27LzMfVydSBdHx8coCIiM2xp891hIaOf5SfsKGUf32G4HCHio2fw62ztqWit8HEbnVqzsXIr6uruc9xdWzKa3J0x3F4cXHOvMO0vNJubG7Qybu5trRqy8zOyb6AbWZwcriXo66p1bOouLLEaWdxb23DxK2pnaCWjubK1OV9nqmsoomXp7KropistpuupKaZmqmxtsbIpK3B1rCZuMaqnry8wbrGctB1eXfa2bp3eImCgYZ8c3NrcWy8nYugnqmJgX1yj4qBg3XTo83GeHd7dcZ+entwbXp3hZV0goWAlm2zm3G0sbiirJ5+p9aaqbSQkoiKhKbOvLGWe7qIiHpxe3HacXJ5d3Vvbtdxy7C2maaPpKaho6y8fs+y0bvb1712a7jGznBnzWiCfXLErIiHcL+ljXq5l4OBgp55yHu2wZDFxHa1tJWHrZSrkW6FsZednbaxbIp2p69ou5OGo5SAqqaWjpubvcPJ0KqxrKCdfoaJiX2HfZeUeYR8fdd+l46DfXqSi9934s2Ki4uLgnSiu4q/wbvAfny4jaV/znDNdpSzoqKvvsN+p26Gi5Giza6lraixrbesramis7KwtJh14ZyH19q+xsKjc4GdrbSttbaylKSMfpR7scnNnMnXesOAwse/Y6unvbZteGpxcHRhs6hieqmGjX17en18eHZ7f3iBhIBzgIyNjH96e3FudniAf4d/ioyCeXh0foV+h4KAloOQl42cp1ajra6cnKCeVVmUpFmeU1ZXVVOSjFKkkJ9XXEyInVNZU1iwX66omJ2cpKKZnJxZoqSloKOgoZijnaWAnJuRmpaRkomEiI58fHXIb32ChJSLjaCUgX+Dk5SFlouIipCDc3d33W5z4MzY3sq6qZWJjZCIhZeVoKSZnqCirLCsra6zr7K7ta+noZaPmZqcmJWWl5adjoiFi5SgnJ+empeXpq+foJmhnp+gmZqZoJKKjJKJkp2SjIeHkZGNg4CAhYX5gunq3tXNw7fIzsrFueSFlISBhofz9/3p7+zg6enw7e3r64SI/a2ono7H0s7H48vHycrV0OB3sZ+7cpCIloWEj4eTfnBzg4qdX5Rot7KltdLPdXVnZcZnbGe+n8prbnlrq5utmJGmkZe1ubq2pYmCgH2RoZ6eoamqYXahsLCArI+Qinx4iX+Qr4V7w2ppX2W9Z3Gzo6y7l6O7uLRmc3OuyrW9uba0zsTHk5DEw8dla3HEurmftbCI4qmW96Cabm2PhZKwnMXvm79xb31/d3Ztcc2raXFyd3l8jYp8g25wf3FyjIyKi23FoqdpeoCHbqeQmaGsjKC4vmx2Z2hosp6Ah5m0vLBmcLKUtG9q0WV6foN7fMnCbHR7hYJ9d4GTfnBzfoOOe2WyvLzFuMB2bHFxaHF2fMWno8RreXqEeYWOl42FdnZ+zWZ2e3yIp5eYoJWUnKanXGRcrKutnZaZorRkZFyqWWFgrWFlYWKyqa+gqrZfXF+yrJ+fmplWpaqqoqGAW1VcWpqFjpmWspOSn5qqV1heW1mknpSKg4aBf9G8xdZ2kJiYkYGKlZ2bjomcpI2alpmNj5mlqbOyk5iquJePqbegk7Kqs6i2aLllamvFvqFmZ3VwcnVpZGJbYFqfiXuLhop4Zl5ccG1qbGCwkquwY2JoYalsamhgX2hkcHpia3GAd12ahl2dm6KRnJJ5sdiKl5p/gX6Cd5a3rKOQdaVwbWVia2G/YGNraWVfXbdgrpykipeFkZiNkJKja6yas6fDv6tlX6CrqlZUqVRnaF+unXd5ZauchXa6ppiSi6uP9pC7vJ7JvGuuqZ5+jXyQeF9uioCFg46OVGlfj4lRmoF4koaAkJGGfoyMpqeusp6fm5KOeHt7e3R5coWFb3ZwccVvhIB4dXGIf89w2MR+f4GAd26lsXezrrGyZ2ekcoZqsmO7aoGWkZCcoKZfgl5yf4CMpJSMk5OYl56TkpGNl5aZlYNozopxw8ausa+aZWx7hIySjoyJdoJyaXdloLS1kLTAaa8EfX19foR9h34FfX1+fn2yfgF/h34Gf39+fn9+hX8Lfn5/fn5+f39/fn6EfwJ+f4p+AX+ZfgF9mH4DfX5+2H0CfH2NfIZ9jnwDfX18kH0Efn19fY9+A39+foZ9hH4HfX5+fn19fYR+mH2Cfo19A35+fYR+A31+fol9g36PfYN+h32EfAR9fX5+hX0EfHx9fYh+gn2UfoN9hX6JfYV+h30Ifn59fX1+fn2GfoJ9kX6GfYh+hH2NfgF9jn6Df4h+CH9/f35/f39+hH+GfoN/hn4Bf4V+hH+LfoV/iH6Efah+CH9+f39/fn5+jH+Hfoh/hH6EfwF+jn8Dfn5/h36CfY9+hn8Bfod/An5/jH4Bf4d+CH9/fn5+f39+hH8Ffn5/f3+Efod9AXyGfQR+fX19jX4Gf39/fn5/oX4BfYh+BH1+fX2GfgN9fX6EfQl+fn1+fn59fn2IfgF/mH4DfX5+hn2PfoZ9An59AgIEAICP7+nx2sm1psKLlKikkLq6gvPy7b29wa2pnZ2qqKWchYefraihjrCulK2gnqGcnqmjqcOWl4iqpp2asbCjkZeptJq5xr2yx9bk4dne3/Tp9frp4vH/k5WD9vny/uny6IGRpZyOjomC1szw4/f16/Dgxs7oi//y38P09une3Mrc1oDMz9/i3r+8xL+tsLjF09KhptDb4oWT5dLCqZqroa6staqnma2nopqkoo6OlKOelJeT4pF7f3RuamxtbHBwamdnanB3dnZ3dHRzcWphZGBtbGlnZF9iY2FiZWRiY2Rna3Fzb2dfXVtYW2BfYWZfY1pcVVthZGdpZl1cXKNYVU6ZkYCJm4N8gHp+fXZnbWN3f51eX1VVmZukqqyRnaKqs1lXWaSsXmNwpcbOr8vPjba1z8y539zt14SSiqGRtuCVrrW9v7XEvpmCmMPRn8uUnLGxocuR5ozp7ODp+PaNiYCa5eiKh4qR7K296uDh4c6q19fht6Srp57A2NL1586A6uHX/YCO9fXesbyyorrbuMv4q4CRjYKJg8bH6OXUudPj8Paght2i8aCP8N2x7dDe0/Po5oaV//r1/fDNz/qH2/OGjunPu5qcmo+K4Omsiqj5jfr6jrSnq52MoK6bkpGVrrqypaWjlpK0urO4wdzZqJ+jr5zY67/7kKCI29+V4oGCg4aA64DuuNfpyuLKzPePn+ju/4yenLWxwMHCnpqlrq2hosi7lYepxbyql6KQ9I2Uo7Cmmvrug42Mh4fV4Pn4zMWru52glKS/roLK+PWUp6252/eB9+bw6PDk4/mDhvf3gtTN2fnnzdLx+enz3eLh7vHm7e7979DG7un/0dvXx9PWzsu804Dl19zq88vi5eTc8OHv+fiChO/n49Xz993m49vX///GzqShmqKoqqnX3ODEsLayv7C6ramrq7/T0MizodTs1crQwb3O5fjZ+/eIg5CNhIeGm52Xkoycl5iGkYP83aWYzeKvxZzXo7+ylpOS9beDjK2zhqeZj5yAq4bDm6KWk4yfmICPwfGG5tLdhM3oqZeLw7H0k5Lh4LL4kYv09oCQh42WifPf7/aSoo2FhNHN39z59drQ2sbEv724uvjo4Knw5fT/gI6QjeTK2IiYkaiT4oWPrZz30o2H462heXSll3d1la2ln67PuOPX7Iyfj52Xm/e1qcLQ8vmAjqCJ8IWF6tvSvIDbm4SolrGx/IT7zNPPrMqzlJukq6Kzw8O+wf6cnpyaram4oq/HiZ6I5ZKDlYuJ8K2T5YfioJPI6LGgi/2Nmc6p89utwLXnu7edjMXIquSqo862sLXO5tXXm53Q5KysqrjEq6ukmIWalcmP2Iygq5WcusmpkuKflpqNjOa0mtewsIB6zc7UwLOjl615f4+LfZ6hc9zT0qifp5aUgoWTkY6IdneLmZOOfpuZhJuOi42Li5aQl62FiHmWk4mJnJqPf4SUnoagqaKaqLbEv7W6uMm+yM29usTSdnhryM3HzsHGvml0gntwcW5sr6bJu8rJvMG1oajAcc7FtaHGyby0tKW5r4CrqrW3tp+co6OUl5yls7KKkLO5vW13vbWmkoSVi5WSmpSTh5iSkomRkICChpCPio+O5JqBhnx4cnl5eX6Benh4eoCIiYqJiYWIhXtwdm+CgoB8d3F2dHNzend3eXp9goh7hHtzbnBsbnN2d3x2eW9waG94e3+AfXBvcMZuZ2LCuYCowaecoZifn5SCiH6WnLxxc2dnvLnFy8qrtrzGz2pmZ7vEa298q9DQr8fKjLOzx76w19HkwnWEfpyNpsaAkJOgo5SjpYN2gKKth6mGjJiXi7WE1n/S0cnU3dl7eHGIzc95dXl9z52sz8bCvrGZubvCoJaZk4+sv7TTyrNs0Mm82oB729PIpaedk6DAp7PVj216eG1zb6+xyce/qMHE1NaHccqYz4R72Myq1rzJvtbPynR+2dvU2tG5td11wvCRj+C1o4GGg3t60eu3jprZeNreeJaNkod6iJCDfHuBlp+aiouKgH6cn5udn7a4joePkoSvwKHdiJWE3+yRw29wcXJ0zoDcqcPRuNTAwe2MkcvS5HuGgpeRnqCnioWKkI6Giqebg3iSp5uNg4990X2Aj5aNiNvVdHp7eHi8zdzjvLWfrYmGfYefkG663NqFk5aeushozb/Gv8i6tcdqa8fJbbGqsM/Arq/DzMLLtb68w8O+xMTQxqynx7/VsbGwpKu0qqWXq4C+r7W/yqu9vLy0x7nEzMpqa8m/vbDFzbW8vba22NKnvI+Lh4+OkJC4uLyolpqXppegmZaWmquxsqqYkbrMu7K5p6qzydi72c90anh2bnJygYB5eXSCe31xeG3VvJKMsL6WpIepfpOOe3p0yaNwe4+Rb4d+doNqi3Ssg4Z8fXaDfoBzpM1yxLS8bq/Fl4qBqprgf37R0KDNe3LP0255b3V3cMO6zMt2gXhwb7ezvbnO0riut6enq6GemcrCv5PNwdDSaW9wabatvXB7dYZ5wG53i3/Pu4J82bCogHuunnx6nLOroq3JttTH1n+NgIR+h9mWip2vy81meIFxw2tswLW1poC1iHWchp6X02/Xq7KtlK+bhYmSm4+bpaWhp+OLioWHkI+ZiZere415yH54gHx+16SKzHfLmJCxwJN7cOF8h7KVzreRq6PKmJJ5caGhj9Sfkq+dlZuvwaysg4Squ4yNjZegjY+GgXOChLyJ1oqJjYaJmJ+LecOGe395ecegkruVk4Bouru/rqKbkqFrcHdwa4WJZsK8wZqJjn97anCAfXt3Zmt4hYWDdY2Jd4x+eX58e4J9hZh5em2Egnt9joqCc3eFiniLj4uHkZ6oo5eZmaOYpKWYmJ+pXl9VoqScn5udl1NYYVxTVFZZjoamnKimmp6XhoqjXqqjlYioppqXl4iZkYCOj5aWmYiFkJOFiYmPnJp8gJ2dnFhgpKGOhHiHf4R8hYeKgY2FhoCDgnp7foeDgomI4q6Ym5KNipWSmJ6elJCSl5+op6quqqesppiNlIyjpqKelo+VkpCSm5eWmZueoauMo6CUkZCPjpGXl6CXnZGQhIuYnKKjnY6Li/2QioP+74Dm++LQ1c/V18iytbDK0PCMj4SB7ez5/PTX5On2/4WAge77ho+Yv9jXt8DEnL/Cz8Gz1MzYunB9dqSQosJ0gIaRlIWVlHhudpGXeZd4gYqBgqB6zXjHw77GzcpycGh3w8dxbXJyvZehvrGyp6CLp6erkoyOiYidq6W9taJfuLKtx4Btwre0m5uTipWtnqW/eGBoaF9kY6alt7a1orS3wsZ1ZbmVv3NvycGnx6+3ssnEvWlwwcHBxsWxp8BjrPGkqeWrk3F3b21xwPvUrZ3KbMPKa4B6enZseH53cG5yhY+Ke3x9c3SOj4mOi5qffnV8f3SSm4bDho2E6/WPsWRkZGVouoDMnrbBr8Gzt/OOjbzF1HJ2cYF+hYqVgHl/fXZ1d42Hd2p8kYN9dX5ywm9wfYZ+e87Ea3Bvb3C4uc/Ut7GgqHl6dHiFfmewyct6hoaNoK5XsKeuqa2fm6dYWKSnW5qUnLOlmZqprK2wnqikqKqorauwqJWSqaOzmpWUipOblIp/lIChkJuhp5Gmo56dp52lqqtaXaukn5eoq5yinJmfu6uMon6AfYKAgYSioqmahomKl42Ti42OkqShp5uGiayzqp+rmp6nuMWuw7plXmlmX2RjcG5naGRvaGphaVy2n39+m5+CiHOLZHJzZWZhrJBcaHJwX2tjXWpWb2OfcG9pa2hubYBijLRjraGoXp2vjYF+oY3Od3bGxouvaGO6wGRoYGFgXKSeqq9ja2dkZaWiqKK3tKKZopKOloqIgKarqoq5qr25XF5eVJ2Xol1kYWxorGNqem+7rX9837q0m5e+spGSr76ypqu/s8a3vm57cXNwc7t4cX2UqbBWZWlamVZapJydkoCYd22OfI6HsmO+mpqWh52LfH+Ci4GMi4+LkdV8fnp5fYKDeIWYc4BxuXJvd3J0y6GFvW+/l46iqXdcWspoeJ2MuJ2Dm5i7fHBeV4eKfMSghpWLhYWaopKMb3iVmXt/fYaFfX54b2dwbrCO8JZ6e3V0gHtyZapvZ2prZ7GUiqt6ewF+iH2IfoR9wH6Df4d+iH+MfgF/oH6Cf5t+yX0EfH19fZF8hH2KfAV9fX18fJN9g36EfZZ+An1+hn2EfoJ9hH6XfQF+hH0Bfox9h36KfQd+fn19fX5+in2Cfoh9An59hHwBfYZ+CX18fHx9fX59faN+hH0EfHx9fYV+iX0BfIV9mn4BfYZ+gn2Ffoh9h36DfYZ+AX+IfgV/f35+f7N+gn+3fpJ/in6Gf4J+jH8Bfoh/B35+f35+fn+Hfgt9fn59fX5+f39+foZ/hH6Ff5d+hH+DfoV/AX6Ef4R+k32GfgF9hn6EfwN+f3+MfgF/kX4BfY1+AX2FfoR9AX6FfQR+f399in6EfwV+fn59fZl+BH19fH2IfgF9hX6EfYJ+AgIEAID2+Ork/cTV7cDb6pyXnN+DwvSMjoT9oaXz+IHCzMKwmpGetrems5+rppiOmKyUkpGXtM3Jrp6ToJyfv8Kysqqtu7PDysO+vcvk5OTd5fjp5Ojf1eHd44T02tvF6e3z+PyAi5uQmof82u7s6/rv8ID1+/Hm1uLk1s+nxN3e8u3Eu4Cmp8O+uMO+vtHa0OTu4N3Ova/X2cu5s7TQy8zIyczEtrmuppmRi6GnubCblpept6i2n+nn7MC+m5p7Z19paGdfYGxtcHFrcm1pbm1iYGVua2ZkXF1ZXF1gX19gXmJhZW3KYFxhXlqfV2FeWFheXl1YXFldYWRZVJmnk4SOj4aEgYCLdXt6c356bWh1fZZgZmZeV1VdYFtanp2jq5uisFems3NxeXSDwcq/q/KOl4eYq6Wh4Kyv7pGC2La6/pWcqZGhpZysj6iZn62Z952Gk5nNl4eipri3qpinqYiWooqD5uiRgNb+iYH08tvGrsH7hIP53qvKzb/p9YWH7OTjgOHFxYDwmJ2T9dKutu20kaC2h/OIgoGz2rXjhueexti5gY6FjNLVufD0gNfA2dfr6unI3tDDv9+Ck+mB6rTnkoG08YaeluOu6ruq7dSNqtaW7tuV5Yubt825rKeQh4uRocinnqPRmsyKnJefqJCbnaaRjbvV6uzFl/rthLSO0pGipYuSqICmnaqRoK+Qhf7tqJi/6YODjZWkta2ekPXn3o6wq4+X/+H3n5aPlpKnmqWuzsmhpIzk+/aboZD+xuypm4qT/8fl//aLuaSQhu2svai8qs/Ourra6Ne/zNf7hoaRmIzusdnZ28zq6MrW0uDkz8rJztO9n7axvsW30Linpbapu6emuoC0wKimyN7TyM/k8+rX69jQ8/b24Nfr99jL0b/G1sjMytTh0uHf1MzJwMu+oqGnwMHmy8zJw8PZyq23ptHY1dLj797j94qOkJuRkZymlfuOkJCKj5WQlI6PioqB3rjSwtuE8/DmmaqYlJuDhpSepImLwLqQiv6QhISju5DlioiH8oD6+ojXgbjpgOm6mq2Wlpva9dzW5IWF+YeD893//Yv+3cLegsXqjfrU0IWI2Lj+5d3yv7a1yObb34PgzcHbg5aC9uHpydG/3oGYsqSS7oaIiua4h+rZs8aIcqakcWbAxoCnr6WzfofKnp2ghayWhYanw8+E1rfYmZn4jv6Cgo7iuICxm5eVg6DVx4iS04L8uq+ouJeoy8W4jf7Iura2mqmlq8rPyL/Qm7qmlLDt2urd0eG4wvHs+ZykhoXsipimlail/uPN5b+A5/uhucTAvbeupKSt3ubCm5CT3LynoKmsh5Ky27e74KKd3KCFm5a9pdn0qqe9spLlrqXLsqSD4MXs6IDT2c7H2bG+2avD0YSCisZ0sd99e3LZio3T12+kqaeYhX+Mn56SnYyWk4d9h5qFgYKEnrSwmo6Dj4mLpqiampGWppysraejoa7BvL+6wc7Bur63sLu4umvKs7OhvsXJzM5pcH51fnHRscC/vsq/wmjLzce/sbi5rKiHoLOxxsOknICLjaehm6ahobK3rsDIvbmvopW1t6ufnJ21ra2qpaqlm5+XkIV/eYuQnpiIhYmWn5aglebg6cTGoqCGcml2dHVsbn1+goV9hYN9goJ0cXeFg3x7b3FsbnFzdHV1cHV1e4bacm13dWy/anVwa2t1c3RtdG5zeX1xarTCsqa0taqlpoCxk5mbkZ+ajIOTmbNzeHpxaWZucmtqvbi/x7S6yme+x318hH+Ev825quB/koacp6Ki1aipzX5ywq+w5IOMkX+LjIKRgJKEhpKG1415goKqhXmOkaacloKQkHWDiHt61NmAdMbfdG/a1cW0m6ndb3Pdyp6ztqbO2HR2zMjFbcOurYDPgYR80rmbn9SihpWiccxxbm+evqDCc8yQs8CpcHt1erjBpdHYccGxvsTQzM+vx7ivqcNvgMxwz6fHenCi6YGYisKRv52U0sKQs9eSzr6N5XiBmKmfkI18dnx/i6aMh4m1hLp7iIKGj3+FiI99eJutv7ief9jUfqaHvHyGiXd9i4CJho16iJF5ctnRn5Gtzm9vd3yPmJKIe97QynuSk3qD4MfRhoB6gXuPgpCTqqaHjXfO5NeGk3/dstWThXeC26/M3dh2oY1/c9CUoIyekLCrmp66xLKjrbXHaml1enPIm7a3uKa/v6ixrbm+sKWorbOhhJyanaSbsJ6SjZiOno2RnoCYoI6KoriwpKy8x8K1wbGqw8zKvLPBybSptKOksKOrrLC8sLm6s6yqoa2ljo2MpKfGs66tqqe7r5ijlby5u7fE0MDL23h4e4F3eH+Ges94dnVzeXp6f3l5dHZtv6O7psBvzsu8d4R3enttc3iAgXB0nY9zctd4b3WGmHjHdG9sz4DSzXC3a5/EasSfjpeGjYq3zba0wGxqzW5uz77g1XLTuKG2aaa/bsq7unBvtaHSvb3IoZ2arMW7vG+8saq2a3hsv665rLmnvGx7in90w21zdMGgfNfNssSOd6yseGvN0YSrsKa0gIO5ipCSe5yHdnaQrK5tuZyyfH7Ec8lsaHa9moCZiYqGdpC1o3B5tG3UoZeUn4eOsq2fheSrmZeZhY6MkrOtpaK2g5uMfo/SwM/Hu82tt9bP35GffXe1c4SOhZ6S5sWvxKp2xM2GmKCZlpGTjIqTt7+khH59up6NhIuUdYCVtpyeuYeFuYlzkJKhkL/aiIqWjXvKjoSplodvwbHLxoC7wbm2waCuw52xvW1werZmpslva2S9dnq6wGKLjo6DdXF+jo6DjYCIh31zfYp2cXd3ipqYin92gHt+lpmGhX6CkIqUko6NjJSln6KepaqamJiTjpuYmlahk5B+lKKjoqVTWWRdZVynjZybnKaZn1Wlq6aglZqYjYpviZuToZ6HhIB3epSRipGOjaCdmKSqpKGYjoOZm5aRkI+gl5aVio2GhY+Kg312c4CEjIl5eX2EiomRiePl6NTQtq2Zh4ORkYyEi5qfo6KepqKco6WXj5mqqKCgkpKOjpOWmZmak5SVmqr9jIyWmY/6h5ORiouUlJOLko2RnqKWiuny6+Dv9Ofh5IDnytHVzN3Nu7XFy+eQlJiMg4GKjYSD7erw9N3m/IHw/pWTnZaZwM25sdVxmJaptKeuz6amwHZpvbGs2X2DiHiDfHeDeIh7fIR1yoRzdniTdnCBg5GMineBgGp2eXJuxsp2a7vQaGXMxLWmkp7EYWbEupenqJy5wWZmtrS1XqienYC6b3BquaqRjr6agY2XY71lYmOZrZeuZLiNp7aiZ29ta6uwnMDGar2prrjAu7yhtK6io7NmdLtit6C0aGWY3oCVirJ/nYiBvrKSy+KQvbCJ7GtxhJGKfHxxanF0fpF5d3ibebRyeXZ4gHJ6fIBwa4aQoZaCbMTAc52ErG1ydmltdYB3dXxud35tZ7/Amo2kvWZjaW5/iIN6cc/DwWt9gW9yyra7cnFqcWt7cn6Dj4x3fG7B1cZ2hHPRrMSBe210z6u6z8Znh350abuAkX2Ng5mYipCorKCVm56nVFZdZWCphqGfmZOnopKXlaOkmJSTl52LdouHi5CJmIeDgIV+jHyAjICBhXN5jJyXkZWkpaOboJKSp6uoo5ujqZeQoY6Ol4uVlZeflJienJWSj5mXhH6BlpuzoKKfn5usoI2Zi62pq6iwuq23xWpqb3BoaG1xZLNoY2NiaWhrbWloZGNcn4qjiKBepqaZXGhfY2JYYWBkaVxkgmxdYLRkXGNtfmewZWBctIC2smGmXpKsXKuLgYl8hX2gr5+boVtYrWFgu63IuGKvm5KcVZGmXqumqmRgn4+xoqmrj4+HlbGkoV+pnpehYGZdn5KXlZ+Wo2FqcWlgp19paauTeNTPvc+ejbu2koP7/JS5uKm4j42weoOFdY17aWp6oJNaoYyRXmWdXKxdV2eoiICCeXx8cYellF5lnV62kIqFiX6GnJuRdtGUhoWIfYF+hKKalZKbeIp/b3rBtcO4sryjqcnCzo+6lmSVbHd7fpGF4KuXsqRqrqF6iIeFf3t8fX6HnJeJdHFynIh+dX6DanWClYKLmHd4mnVhi5OHebPHd3N8cGe0dGqGem9eqKO0tot9D35+fn1+fX1+fn59fn59fbx+AX+JfoZ/iH4Bf8N+rn0BfIV9AXyQfZV8in2HfAN9fHyKfQF+in2CfoR9jn4BfZR+CH19fn59fX5+h32Cfoh9Bn5+fX19foR9g36JfQV+fX5+foR9AX6FfYR+hX0Bfo19C35+fX59fX1+fn18hH2EfgV9fX18fIR9AXySfgF9kX4GfX1+fX19jn6GfYl+g32FfoN9jn4JfX19fn5+fX19hH6FfYV+AX2QfoV/536JfwF+jX+FfgR/fn5+kH8BfoZ/DX5/f39+fn5/fn9+fn+MfgV/f35/f4R+AX+Efgl/fn5/fn5+f3+NfgF/hH6Df4d+hX8Hfn9/f35+fop9gnyIfYl+Dn1+f35+fn9/fn9+f39/in4Ef39+f4t+AX2Sfox9gnyIfgF9hH4Bf6R+Bn19fn59fYV+AX2GfoR9AgIEAICC6ObZkd6KoYHd+JuokoyK1orw0/nm6YOjk+/l2aW/urrPyaefrKCVlqOtxtXArZCMiZ2msbCkn6K44tKfpqSajrGjw9fg2drSz+v0gPnk8Pjyh+z01OjS0cG/wNDaif3T0teCheHo8uHsge7v6t/Z2+zc5N/U5uLDv6ilrsbTyYDLtq262ca6wcLDv7zOurGvubCnqaydmqq7xNznz7+0qa2kpabD0NHJv8KwqLuts7rLuMzbyrueoYC3s8GijXhnXWVram1ta2pmXF5VW2FkZ2VfUqOhU1FSUFBbWlhXV1KYrFhXUlxZXWVYUldXVVNWYGBcWFFbUIGAgnt7e356h4CFgW5rbHOBiJiuZWRkVKSkqKqur1ihV2RamqqqWLVtkaGNhL/u9uSQp4fP7dqTq8S94emIhYeL6JeKpKOZj5Sjl4vEwe+jn6OgmI6eio6Um6GiuNXxv+63nZ6gqZ/g4+f9zoqikfTt7fiDiPiK+tuIpqua/PSD5t7r9vrWgfGyroCqlria89GI98icnKers/WG7Masy7XL4a3tmd680+De9ILy6fmSgb2U1Yr29PPG2+HGvdXa+Y39/5nU8oWQzIWUodXkkvGWvJ6Y5dHE+5nliK62wcrDoZuhloiMnLK0rbu9xL6MgpGbzLO3prKcg/mptcfhxIqM97XN55qyv8S9vYCtoomKtcjAr5yehfvC24WIlYuSmJyQjI6YgYCit7KVgaWquJ+wnvqDqaeRnrWgk6GlkZmfqpKhhfj9praboPvsiI6RoY6AlO+Gh4iYlp+pr7TAvb+nwb20sqm7u7OqtcjT2+DVs7HJw62jnq65trrJxL+zmYmJo7HEtpuSm6qwrYCspZ+90e7958XM2NPl4dOEjIPgz+/oxsXN1tvUzNfc48/UyM++pay5yeLE2tLDs5eBj6mtpLu3qsCj2NL159XhgI2epqukramXnpyZoZyXjZOB/YKB/+6Jkobi4YP546CoooWRjpSIjpaIjpSPk4GXmpuGjqOnnpGwo+6L4oTX/YCDgOmA0szRuqGLu52Swezr++nh19Hm1unwydvR1/7MlsLdg7/zheX794OTj97b5tnd37HFyNbG2e7D3/LezYH71Ma0tdWNoImeqqaP8fWA7LmO7tDQ0ci+jo3DfXG8p6xpdnu6kI23sKS/luaB+pqXkvjphdrCxoWXjYj2zPuKgoDkoL2P5cq0/4D1+tbh3MXI+c6nuaCSrpOUl6vPprmxoryYqrHG27SS7vvWutyS7q3U7MuegNfjrIOd4pbTm8P+lOSV062ZmvCXvOatmbnb8eWXjtG6xuG1u8S4tsC5svaRzJDAwMy7ueWHlZyK7vaejMX1kISrnoP+obKgpe73iYBvyci8fcV5jHDD2oaSgHt5vnjRutnK0XKQgNXPwpCjoKC0r5KOlI2Dg46YsLmom4F+e42SnpuQi46ixbaLk4+Ie5yPqbjAtrqyqsPMasy6x87IcMfPs8OurqGgo620b9O0sbJsbbS5w7nCa8bFv7u1t8W1vLewvbigoY2Mk6WspYCrm5KduKeepaalo6GvnpWWoZmQkZSLh5Siqr3BrqOZkZONjY6nr7Kqo6eWjaKYmp2woqy2r6iPkny/tcWrlYJzZ3J7e36Bfnx5bnBmbnV7fnhzYsHAZmVlZGRxb2tqaWKux2psZnJudHxrZmtpaWdse3hzbWZvZJ6gpZ+dmZ+apoCnoIqHi46gpbTLd3d3ZcXCyMnKy2m7aHZrs8nHZsl3naqTjL/k5daDlH/B0ceTprWw1NR3dXiD14l4j4qCe3yGgHWlotyRiY6MiH6Ken2BhI2Hnq3HosmiioqMjYnFz9fdwXqMg9bY0dVydNt418B0ipmP39l2y8bK09m+bt6loICcfJOB3bV22rSSj5iboNpzyqyZsaWvwprijcept8XEz3HOzNZ7b7GQvXjY19O0vMuzpcO+13rf25K/0HN5s36Nk8DIftaAnIiEzcK23oPId5OWoaaih4OLgXd5hZuakpmeoKB4c4GGsZudkaCJdNuPlaa4nnB63KSzzoKTm6GemoCRiXR1lKadkYGJcdavwXF1gXh8f4J7eniGcHCMmpWDdY2QmoSRhtdwjo56hpqGfpGOf4SHknyJctfckpyEhtfNcnh7jHpvgtZ6d3mHgYiNkpWjnqGMpqKWlouZm5aTl6WstryzmJmqpZWMh5een52tq6SehXl8j5ukmIZ/ho6Yk4CQioafscLVwKm0tq6+vq5scW67sMW/o6OwuL6tp7e4wLCzp7OhkZKdpruqu72qn4Z0iZmfj6WglaaPwLfVyLnDa3yFi4qJj4qChId/hoOBen5t025s2NJ0e3TDyXLWwoaChG90bnZtdXhzc3Z0dGp5e35udoWEfnmNhsZ0wGu314BubsJstrGvo5KEqpCGp8fC0MDCta6+s8PGq7qvssyuhqi7a6jNbb7Vzm93dLm1v7O2vpqspbepvMekuMC2q2zQrKaYorR2hHN9hoJzy8tswp9/28jGx8W9lJXMhXrMsbVufH68j4elnpOnidl554eJiNnBa7CepW57c2/Ur89zaoC/jKR71K+d2GvKy7bAwqyp0a+PoZSGkYKBg5CvjJ2XjaiIlJensZV9zd27qMV+5aDB0LiTdcXgpnCHyYCvgbDkhMiExqiQitaEncuThpm2xb+Cf7Kbq8CXnqKVlpucmduDrXCcoKmcm8h0gYZ31uCbhLbPeXCRgnPoh5OBi9Pcd4Bgs7SraqxreGGtwHR9cGtqq2u8qsK5vWh9c8vHtn6Ni4qZl35/h392eH+Hm6SWjHVxc3+BjIl/fYGUtaiAg397bol+k6Kimp+VjKKpWKqbp62mXKezlqORj4OEjI+TW6uUkZRYWI+TnZeeWaaopqGanamanp2UmpaDjH96fouNjICShoKKo5WLk5KRkY+ZjISGk4uFhYV9eYaRmqijlo+HfYJ/fYWUmp+Uj5OHfZKHhYqYkJmbl5SFg3XOx824pZiLg5GbnaCiop+cjY+IjpujpJ6Zg/7/hYiJh4WUlYyJioLh9YmPh5OPlZ+QhYqJhoSMnpuXkYiQhtvX29bXz9nX3YDe0r26v8bR0uT9kpaUgPjy/P77/YHtg5OD6P78gPuQr7ioo8rn4tZ5hne1ubeco7C10cxwcHJ30oJ0goN7cnN8c2mQh9SGgIOCe3V/cXJ0d358ipiujq6QfX98gHy7xs3SuXB+dMTFv8Jpacdsv7BneYiBy8Vqt7S3vMGsYcOXkoCPaHhvxqloyaiLh46RmcZqu6aSppmitZXoirugqrK6u2a7vL1qZayTr2rHxcWmrbuonrStvW3Lx4+xumpso36KjrG2cMZyhXV0vLWuyHS8bIOGjY6NeHR6dnBueoiHgYSKi4pvbnh6oIyGgot4ast+gYyag2JvzJqju3J/hoqGhYCAfW1ngI+EfXJ4ZMajrWFocW5vcXNub297amd6g4J2a3p3gHJ6dcFid31teIV6cIJ/dXd2hXN6asTNgY14esm8aGtxfHNod8xwc3J5dXuDgYeRkJOBkJWHiX2FioiJiZGaoaCaiYuWj4J7eISMjo2Wko+Id21yg4eQg3Z0eICEfYB8dHOMk6Oyn5KgnpOfopZaXVqdlqiciYugpaeVi52boZiXlpyNg4WNkaGYqa2dkX5rg5OShpqYjp2LtK3FtaqvXnJ2enh4e3hydXNsdXVzaWtfvV9eubZmbGWnr2G2nnNqblpaWV9ZYmJjX15hXFpmZWdcY21uaGV2cKhhqFyjvIBgXqtgpqKWj4V7nIN7lq2ptaaom5qgmaiqlaSfna2afZSjW5e1XKa7uF9kY6KcopuZqY2akZ+WqLCSn6OgmGC0lIqFkaBkcGRlbmhfsLVhrJN52MnFxcXBnJ7+k4v209mDj4nhlneTiYWXfclx13t9esygVo+HjlhlYF61lLJjXICfe5Jxx6iOvF2xqaCqrpuVspmClIh9f3h4dH2WgIyGfpl9hoeQkIFvvtC2pLdx0pmyvqqOZLbytF9xtG6MbarSc710vbyFfM57i6eDeoGZp6R1cZeIlp+DiIZ+gIOGhMR0l1WCho+BgrBrcnRowsiXiq65bGZ8a2bSdXhudbPAZwt+fX19fn1+fn59fYV+An1+hX0Gfn5+fX19r34Bf4V+AX+LfgF/hH6Cf4V+AX/Ofpp9gnyLfYJ8lX2TfIR9hnwKfXx9fX18fHx9fIl9g36JfYR+AX2MfgF9mH6FfYN+hH0Gfn59fn19hH4DfX1+hn0BfoR9Bn5+fn19foh9AX6IfQF8h30Kfn19fX5+fX19fot9AX6FfYJ+hn0Cfn2EfoR9An59n34BfYd+hH2RfoN9mH4BfZF+gn2EfoJ9h34Bfcd+g3+ufpJ/DX5/f35+f39/fn5/fn6bfwp+f35/fn5/f35/nn4Kf35+f35+fn9/f5J+AX+Gfod/Bn5+f35+foh9C3x9fXx8fH19fXx9hn4MfX59fn5+fX5/fn5+hH8Ffn5+f3+EfgV9fX5+f59+hX0BfoZ9FH59fHx+fn1+fn59fX59fn19fn59l34EfX5+f4V+AX2EfoZ9hX4BfYR+A319fgICBACA9fCa7oHlxfP1xNaXi+7c2OW/o6qjlYKNmqewg46ZoZa2rr7Ar6qlo5ONiPSFhYqDho2FkYODi5efmqWhk/vy+YaEnKq+y8XTz8TI1+Xu1+bR1fjl57zWzby0tsDBvdLd3tTJ8+7g1tTS0PbQ4+Pr8e3fys/Q39XRt7/U1tPT1bqAp7LAw7vA2ti+tb3EuJ+dnq2tnZmNoKGer7m2sq2tm4qctpSPnqWns7C5qq6otri/u8/s3a65xrLKybavo4raqpeOkYJtZGVgXl1dW1NVW1xSUqFPT1RXWE6EjZhOUFGNklVTWFlaVFNVVFJVUk5Sk1FQTE1NlIGFio2Ld3d7eYGAgISNjZyeXGVrbWRpYF1Zq1mdpVZXo6NWXmldXltdhq+m5LGkueaUsJbijtyww7nHot3/9IWmm4i6r7KakKOVhoiGocito5WCnJGXjLSvxLq0wYiYjLfHx52MmaL5xvuMqY6e2pyyufya046I/O+H7ILyoaiGj6anh4Pug+LVyKiAqPqF7cHBifzazqiSnoaugIPLr5rGvZCUsdDkztKDyuDujffMiILfpfKe6cz0/4Pjp9m1tcjp4tD2gJPqhIr10JuMnImLzIWajoCck9r55+3ykK/BpZHjhbe1nKqxtKCNjIbAyq2cnbKhtKWmwcellcbH3PvMr6GcgYu/sJy0rbiArLeYhJ+0t7WktZCU18mBo6CPg4mQn4Dv7M3vkpamk5ifwLSfnpSTjJWXnJaSnrO+t4/yhJiX+4jW2snf8oPa1fSHh//tr8O89Y7z9uqP5+bGs8G30fziqH61s3u25KXJ1djax8/Fu8jX0eXAsaOvusLKvK+xkJSMo6Onp7GgrrWAtMG1zcXWxKmcs5arstXR4e6D5tHH3NHi49HCxc29wr3N3+fi4vPh2czY1cy3rpWinsqupMasp7G6w8jU79rL9oCFs7y3uK+2x8K/oq+gnJSXjI3t49rw/JCbpLGnsq2kiv/09YiajY/9kqOQgPnzgYKQmJiThJiL6f7l/P7i6dGAw9Dg59PbhYaxosHb5Pbz3dHT4b6txNrT1trYs+ji59uKgouH8u/a3trpwdWEu+n34+i96PjtiNnSzcDTxNbY7M2eupqyzvmdzJ/78PXr582itNvAhI/i1JSNfZRssLRlYm3BeZWHiIf0p4yOtp+psavll9j3yLL65/mcgIXr5OyA8saxhqWXwon9gd69tqyeuNfsu4Ti9Peho8HKxMvi87q8nKykqMenrJmC7pLyoYbiw//azfnY2tem+OeElY6popH73O3R2MqFiZexoKKVtKXM0YPF0c/Fv8uIlq6yuL2r2dKZgJOfoaepkau2zb66ioLqytLrpZeSnIGYm5Ply7KA1s+EzG/Kstfctb6EedPDwNCwmZqNgnN8h5KadnyGjYOimKOnmZWQkIF9e+B7eH90eH93g3Z1fIaOiZGPhODd4nh1iZWkr6i2sKestsLKtMGrs828v565rJ6TmqOjn7K8vLKnx7+4r66tq8iuvbzEy8e6qKyrt6+smqC0sq+tsZqAi5Wip6GjuLeim6CpoIeHiJeViIR8jYyLl52cmpOVhnaGnYN+jJGSmpeekZWTn5qin7DEv5mlrJaop56gl4XbsqCVmI17c3dyb25uamJkam1jYsFhYmhsal+msb1iYWOusmdlbnFvZmlpa2dqZWFluWVlX2FiuKGqrrOymZqbmaKAoaStqby7a3h+gnh9cW1pyGq6xWZow71mbHpqbGlnkbGp4bKkuNSCn4bOfcipu7K5ns3l2naMi3enl5SHgo+Dd3dzgqWQiIh3h4CEfJeUo5uUp3eDd5umr4d+hpLiuuh+lnyJw4eYouGQwnt1381zznPQio90e4+QdG7OdcW5speAl9Vu0Kmpd9vJup2HjX6ebm+ynoisrYeOobjNurp1ucLSe9i3dnPRo9GGx7Xa2HLMnsKlp7LMzr7YbX7JcnfTupWFk4GDuXGEeXOEfsfd0NTTfJOfi3rMdJaZhJOVmYh6fnShqpSIiZyLl4yLnaePgaalr8mploaEb3qhl4SYkJiAjZiEdYSTk5WMlnd+vbBwjId6cnZ5g27V1rvTfX+Jf4OFn5iGhn17eH1+hH9/iJadmHvScoOA2nm4wLXN2XPEvNlzcdvUn7mu3X7X1dCCzMu3p6ykwefQn3+2tXyuz5Cosba3pa2nnqu4ssanlouVm6KpoZaXgIJ2jIuOkpqHj5iAlaOaqaS1pJWJo4WZl7S0ur5pvrWpta25urCorLSdnqCuu8G7u87Etqi0s6qbmoORkLaXjrGYlZ2jpquxy7ev1m5vlp+WmI6Wo5yXgIuHg32DeXfIwb/P3HqDipOJjpKGctjIw218cHPVd4JyZsjKa2tzen18bHpvxNK9ztK7wLGAs7i9wbe9cHCembDAwsvFtKiru5+Vpry2rraul8GxtrVvanNux8m+v7zDpLh5pcDKvMWqxc7IbrOspZqsqLOtuayHoYqftM1/o4TOw9PHvrGRr927fYfdz5qUhZtzu79tanfNfI2GgHzjmYN+o5eamZfUgLTGpJXRvsZ9ZW3Fu8eAzK6ZeZV+rHTZabihmpWKnbLJpnjR49uPiZ+spqm5zaKphJOOjaaKkoFy2YzSjHXFreO+vd7JzMSTwbVxg32ShXzZv87Ax7t1d4aUhoZ9mI2lsHKnrqqhnKN6foyVmKCXx8SCbn2EhIqUfY6XqJuhfHXKuLrMiXt5gW2Df33GspqAvrdwtWG0psLDpbFzab2zscGok5F6cmZwdoCIanB2fneNhYmMhYOAgXRzc9FzcXZsbnVvdG1scHqAfYaEedDHz25ue4aQmJCdlI+WnqarmqWSlq+dn4adkYd7goqKhJqjnJaKpJaVkJKQjqWVo6Gmr6iejpGSmpORg4mZlJOUl4WAe4SNlZCRoZ6QiY6XkH1/gI6Jf3x2f4J9hYeLiIKBemp3kHp1goWGi4aMgIOEiYOMjZ2pnIyVmIiPjo6RjXzdxbiqqaGVkJeVj5CSjoKGiY+Hgf+Bg4mTi4Pl8P+Dg4bq64SFkJWSiomPjYuMhoCG+ISHgoOG/t3o6/L72NPW0t6A1Nfb1+rvh5Wcopabi4qB+oLq+4SC+vSCiJiGi4eCqbq34Lyxucx6jnzGcbmpuLO2oM3a1XKCgXWaiYiAe4d7cW9reI1/fYBxgXd7dIWEjYiEmG56cI6RoXx0eobVst11h3J7u3qIkc2Qt2xoyL1nwGrAfHlnanVxYWG7Zq+lo4+Airhdu5ugasm8sZSBh36WYmKnmYaipouMnK65sa9rrbPAbcWqamnFn7x6tqzFxma9mrSfnaa+wrTIYm+1Z228o5CEi36Cr2R2bmd2b7jMxMvJcYKIe23BaX6EdYSAg3dxdWyOk4F5fYt/h3x8hZJ6dJGMjKOKf3ZzY2qJg3qEgIOAe4R5bHSAfIF5fmVqqqFkfHtuaGpscWLEx7PEcW93cnF0hYB3d3Bta3Bxc3V1d4OJhXG/Z3Z2yW+2sq+8ym28r8VoZ8fCm62lyHXKy8N8w8CzqrCqu9vGo4rV0YKtwX+Rmp+ajZmTjpqgoK+ThX+GipGVi4SHdXZtgH56f4h4f4OAgomAioubkoaAlHeIg5ienp1VoZ6YmZKYnJaVmJ6Ji42ZpqumpbqsnpKcnJeKjnuIjKmLg6KNjZGXmp+itaKhw2Noh4yEhX6Ei4V+b3dzcW9yaWOnoqS1wWpwdH1zeHxzX7GamVViXV+zaGxdVKSsW1tgZ2dnW2Vbqa+crrKmraGAnqWqq6SqX1yQjqKrq66nmI+Too2FlKSil5ePhKORi5FaWmJfsLOqqaqvk5dvk6SxprCbrK+tW56Xj4mSlJyWmZJ9k4KNn61pfm6wprexp6GGsfu4doLg3K+pn6mG5+iDgpH7kIJ9dXPYiXp2jYeJg4nJcZKeiYWqp6hlVF2ooa6AtJyLcIRumWjAW52Oi4iAj521mnXP186CfI6VlJmXp4+Yen6Be499gnZsxI2/eWu5o82vqb+10al8l4xmdXKAd3DJscK4vbBrbXmAeHdwgnqOk2iTlI+KhIRpcHiDhomEt7tvYm91cXl/bHmAiH+Ha2W5qau6b2hmb19ybGuvoZIFfX1+fX6GfYJ+h32XfgF9kX6Dff5+lH0BfIZ9CHx8fH19fXx8jn0BfIV9kXyJfQh8fXx8fX18fI99BX5+fn1+iX2ofoN9hH4PfX5+fn19fX5+fX1+fX59iH4CfX6GfQV+fX19foh9gn6MfQ1+fX19fn19fn59fX1+hH0Bfop9BX5+fX5+iH2GfoV9hX4BfbV+gn2JfoR9l34GfX5+fn1+hX0Gfn19fX5+hn0Ffn19fX6LfQV8fH19fbN+AX+ufpN/hX6Jf4N+hH8BfoR/gn6Jf45+gn+YfoR/kn4Bf5B+g3+HfgV9fH1+fod9B3x8fX19fH2EfgF9iH4BfYh+g3+KfgN/fn+KfoN9k34FfX19fn6HfQJ8fYl+hn2ZfoJ9j36EfYh+g30CAgQAgO+NgYuVp+rT5J2ph+jN26qfkaCVwtv994eAmY35kaipkZGJobajpKqmu7ackOnzivSIjK6zpKuppqGpqZ6TjpCcnIzmg4uTtLC5rMTCs7C5ydHK2oLrzcziwK3Ax8PM18u/xdfn4dbj6uDs8OPI1ePp5uvm8+7m19zBw7e30MzTgM/WzbfDrq3CycHAsKmppKOonpinqay4u7S6xLKzzMSoiOz9naK61tTW0eXt3srBw9LRy9LxgPLW0+XRxrizyMmrrKSRhtiOdWhZq1dWn5yTl1Obko+EkY2MhpZPk5lQVk9aVllcl5tMVVRTUVJQlZKMoFKeUJGHdX1zcW1uYmt3gJRWY2VmZGpkW1taX12sX15bWZiZnaSof3aCl5FvY4WvjYKwgfzfheiag4ze7sXI7YXRk5ulwK2hi7aemv2U9PGNkq/IvpiJqJjbkpO8stDGwqSXlZKQi4Hx+pmI/uiIl4mHg4iPkaCGgeHsn5OdjIPT/5uMkbO2vKDf2vX4/MW5gMbM4r2ksMv7zOjDibeMk4aD3dmvqp+SybTS2sjh2Z6CiZvLodeD7qi05O/qxMjR16/Yr73+/cCmx97i++Xzk+z689fOkbiHmoGi14GUqunEfNWhhIif6r291en0nN/bsYT8iImstMCqpKWtwsCcwbOzwcPQvdKxrLCEgIqXlaiqgLWlq6yUlYulqKKRk4mD/If3zrvq4/KZjoPmo7/GrM73k4qUl4uDhZGU9/+VpJiTkZeHhfT23+j057q93urVzODq/PP3k4XY34KOifyBj/6Rp6f3qsvajNuBj6q/xZayztjL4sm1npisvsOvvamJma+tqrGJ2/TNsKC/54CVjImVgKrDx9W+oZyYtrjHysWfucDg6M7V5dvm5c682M3q09jMyMKxrqy5xb+/5OjExsm80vXl0sPCvsLY0N/yxdvi74D8762yurG0xLqqwLPDvb+ytZSjj4KImKOgta26pqWnvLOalpiLhoX+/PDjhIL55evtgZCThuzt69Hs/OqQ79nGgM+0z9zGt46B2snhgMnL5fHM7qb6i56fp9fM2J2ezoHevKOym5eFq6DN1ub7+P72gImNhYb34uvlkpHKxtLS0sWspZ2SgbqHwq7xkZuD0d2ypY6Njd6XybKWrH1mb7ukqZ+osp+NhpeChujmjZrFzcXapJ2uyejk+8/0ho738viKgMeulpjt+5HiwL3Dr6qIocbQtavWzL7VpbLV3K+oxuHEsJXDxpbBu66qkoSfgIXjkrKP8orxs4CCiOX138SrxLS8tqCDrYL1nLm07JHF9Nngpb64l7/RsMDDrf3ghM3CmdvTzu6KmJqalIzwr+/Ou5qr4b+G/JSkubORopeh5a+WgM18b3iBj8++zoqTdtC6xZ+Uh5aRtsnf3nlyhX3dgJWUfn16kJ6PjpGQo6CLgdLffd17f5ufj5eWlI+WlYyDfYGJi33LdnuDoJuhl6inmJSbp6mgsmzHrKu9jI+hpqewt66hpbS+uq+8w7i6x7yotLzCv8G8x8e/sbmipZmarKyxaa20rZ2nlZKnqaWll5GSjY2RioOQlZegn5ifqJeYrqaPddLlioudt7K0sL7DuaqlpLOtq7DBadCxrryrqJ+arbGfn5eHg9eZgXZnyGRku7ittGW7sq+ftqyupbtjtblhamNuaG1yuMBgaoRngGa9uq/HZ7xktqiTn5SRiYp9hY+xZnd4enZ+eG1rbHBsyG9va2q0srq/vI6DjJ+ee2mOtJaHs3no03fPinl90ui7vM53v4CDi6SThnqeho3jf9zafoGOoZ6IgpuIy4SAnpmxq6SMhoJ+gXZ00dmId+PMfYF5dHN3fYCKenTK0YF8gIJ3dL3ghXmAmZOcjsC61tfisqy5sMaklKK23LTIr4ingoRyc8rAnJeVj7qnur21z76DcXWJvJnActOgqcjY0LOytr6fu5+n2uq6n7nDwtLKynjH5Ku8z4qndYhynsNvfY/RtHzclHB1hc6wrMHQ3IS4spF63X52lJWeioqKkaOegIeimZWbnK2cqpCPlG9wd4F8io2VjpCUf314ioqCenp2ctt31rSo287WgXlyz5exup+w0392fYF5b3F6gdjago6AenqDdnLW2dDQ29GrrcjNv7fEydzW4IB6yst0enTbcHzngY+Q4arP4JHRdHyVoaODnqq1qMGtnImHkqWmlaKUgHiEk5SSmX7M4b2ql7HTcX99fYCOoKa6o4qJhZ+epqqpjKmnuL6zs8C2vbupm7epw7OzqqqjmZOUm6qfm8PFp6mvprvUw7GnpaenurLBzqe8xMts3M6PlZiVk6SXiZeQoJyelZd+jntzdoOKhZSLmYqNjpmSfnx6cmtu2NbOw25rgMO7x8xmc3VuxsbHtMfRvX7Juq+1ora/r6R2aLisumurr77KqcWR4H2JiY6uqLeIiapns6CKmIiBe4mJtLXC0czSzGlvdW9wzcHIy4KBsaqurLCnm5OPhXKibqCQy3V+bbG7mJaAfYLWj8SylrOEbHjKsrmttL2hfn2NeX3f3oSNgK+yqMibj5qqwrvMqMRpcMXHy3Wym4eEyst/w6KfqpWbeZCqs5uayLm4xo2btLaYkbDAspyDp6qEqJuUjHxyjnV4zIShe9Z4zaR4cnS/xLKgi6KQnJyIcpRv3Yaalst/o8Wsuoyfn4GerZCcn5PhzXaxn4TCwb/Xe4KDhn993JLFE6aVhpXLsXjff4eTkHqKgIrGm4OAs2piaW95ta26eoFovbC3nZKEj5Wwus3Pbml0b8lyg4FvbmyBjH57fX6Qjnx2xNJxy25xiIh7g4GCgIiGf3hxdH5/crtrc3eNiJCEk5SGf4SNjoOSWaiNkJ1sd4aKkJefl4uMl5makJqflpmpopCYn6CcnZmhpJ6Vn42NhYaTk5iAlJubi5SHhpiWkpGKhYaCgYSCeYaHiZGKg4uRhIOUjnhpytl9f42fmZuVnaKflI2PmJiVnqdarpuanZORjIubnZGSin983a6bkYL/hYT58ezyhv3v8drw6ure9YT79YCLhpKPkJz8/oGMiIeLiof9+Ov/hPWD++fN3dDMvb+sr8CA5IGUlZaTnpWJiYeNg/uLjIeH6+n18vGroaSyuJqGp8OsnLh02M9wyHxzdc7buL7Kcbh1eH6Uhn5yk32F1nfP0XZ4foqOf3yQfcZ7epSKn5aQgn13c3dxbMPFfXDSwnZ2b25qbXN3f3Fuu8Jsam9rZ7HMeHB0hHp9d6ulwMHMpqCAqaKyloybpcajs6KDnH2AZme3r5WTkpCwn7Ovq7+wcGRre7eZuGzLpKe+zceuqK2wl6+boMnXrp6xsa+8tbRmsN6EttyIomt8apm5ZG1+xrCA7ZFkZ3C/rqW1w9B4mZF5b810bYCChnR4eH+OhXWMhIeGhZeHjn59g2VnbHZven+Ag4CDhnNwbHl2cGhmaWbLbcapoM7CwXBqZcWUpbCYprlxbG91bGZnbnTJynaCc2xodm5pxc/Dw8nFpaS2xLSutL3Jw89zc727bG9szWp23XWCguGy8fmUym9yhI+Od4yZn5qslIl9fImSlIiRgmt4goGFhW3B1benmazCa3VxdHKAeYeNnY98e3qPkJOUkoGXkZydmp2dlp+ai4eekqeblZGVk4iEhYuUi4uurJSanJ6vwq+al5ibnKiitLyarbS6Y8jBgoWIhoKOhniBfYuGh3+AbHdrZmhxdnF+d4J4e3qBeGtjXltZWbG3sadcWZ2gqrFUX2BdrKqpnauzoXKrqKCAppWkqJ2ZZFWhlp9Zl5qmqZOsh9Jzfn6BkpCdfYGRVJOKeIV9eHN4epaaqLSxurVbXWJfYLOps7h7d5yUlZOZlIqFhHxsklyBeLRjal6ep4uMend71ofDvaq6loWO8+Ll2uTvqnF1hHN12tl6gZublrGMgoyWpJyllKNYWKetrWSAnY18eLSzba+WkpWDjXKFmaSSkL6zs7+DjKSeiYSXqKKMe5GTepSIhHxuZY1lbMOGmWnEar6ie2JmlKGRg32Hf4uMeGt+ZMp6h3+8c4ucjJZ5joh0i493gYN5yr5slYt2trW0xXBzdHRwcMZ4oYd8c4G5qGnIcnR6eWl2bXarjHMBfYV+Bn19fX5+fox9hH4BfZB+BH19fn2SfgF9kH4Bf8x+gn2SfgF/j36FfQN8fX2EfAF9iXwDfXx8h32CfId9hHwDfXx9jHyMfQF8hH2FfIx9CH59fX59fn5+hX0Cfn2KfgR9fn19iX4BfY5+Bn19fn59fYt+gn2FfoJ9h36WfYJ+jX2EfgR9fX1+mH0Yfn18fXx8fX1+fn59fX5+fn19fXx9fn5+hn2FfgF9rH4CfX6GfYN+h32JfoJ9iH6RfRR+fn19fn5+fX5+fX5+fn19fHx9fZx+h33EfgN/fn6lf4R+gn+EfoR/kX4Gf39+fn5/h34BfYp+AX+QfoV/kn4Hf39/fn9/f4d+An1+h32GfAF9hX6CfY9+Bn9/fn5+f4Z+AX+MfoR9lH4MfX5+fX19fn1+fX19j34FfX5+fn2PfoJ9hH6EfYZ+AX2GfgR9fX59iH4DfX1+AgIEAICEicem8puroKKyrqyXhMvq9cPjuJ7Cg6CN7oDv8OvO75WdpJGV9JO7wbKmsbadlaampJifqaiWnrGup7CpqKeVq8Suob2+qaSgl5mYq5yhl6qfrNXY19/Qzs3Rzr7P6uTm1OjL98LcytLz2tnf5tna9PDR1bfEz8rY09/KwLrCvYDP1NDYzNDNwcbJxbGuuK65q7/CuLGzsJ+mqK+9t7u4up2kvMjQ4ODV2Ofo6M3Qx83L0tbo597K0YaIiIqA9+i3xrLLmaaZg4L5wXZkX1eglZWLkISEm5qXkZCSnY6SVVaaTlGSmpdOVE+eU4+YnJpSU5+bTY+Lg3aDhJaXoVpdWoBfYGFlZVmXi5WqYmhoYGNpaFtYpq5hh66pjJGbc2p9oce+5Ibp8fLxjou2rJaBnKW6iJbLqLG/p5f+hZ+UjfaWpMW6pJ+Kqp6s0cS/wL+yp8ag74GJi/LlkY2JkIG/3JaL/52VpMHNifaukvqao7yO76Wk/4eowbG/0av8qdvQ3oDr4IXH3KzVguP498OyzLW8yI3z5bKyzrjOxumA8NyR+/jz7dyllOvMz+/0gYPD17zHztTD+I7UwLnSu8v3lZqPsZnf5MyBuduLj42XibDY0oi5n5HNnKmV++LEx4CmttnBmv6jy73CxLmdoaarncDS27KppaWWqqKUi5uRlZiHlICSkJ6WmqyUkJiVlpSIjJGVgIWHkqCfhYWTnZKFh+Xw1srXh5OZqIr+4faOk5aAv8T1i5+cm5L+7YjZ0L2m19C0ye6B/Ors2bvDueuCiff0kqjRuqaO7vyC/Pnkxoejm52yr8C/qJOftcKlrcrKuaSbo7O2vr6JusDBtqjC6IOYl4CyvbOisL+2sKG7oaWgv6KTj5rQ1+q3y9G/ssm0s726ysGompmpq6y7sbjI1dez2erUwrOtzLe6tbq/0oCRkIyNi6OtqaWkoKCinq6rtK2fra6ps7KlrsTEscPIzs3Vy7mJh42XoIyC98j7hIzc+fTu5dvp8+r4+NDK9Nj01ffo3oDFy8/Pscbp3ebc1drYyeDQxKeaiY+806/LxrWEmKiTg4mxppuj0aeE+9qFhPPn8PqB/PqC8M/Z1tbLytXAzM7NzayOm+yBucKZ/oyI7reNorWro5il+oXtk3xyaHdrY7K/Znue2+/e8YG4r4e2z7rLuIONh6Sft8nGueXk3eb5/YDcy9HQ7PPz4buhqY+Pq7eQn7Gti97Z/JaXrcS1pZLIr53xqrbGwcXIsPKfrovyvKal9qz5g7fMw97C1YCDtK6vs66kus2dkYqRio6qtbjN17OjkpeojLCyxpD+8cWJpI/h9vft5vGXnp6tkJyu2sCc9vz6/5SQj6GogZSks5nQgIBzdauP04aWjI2alpaEc7XR27PQqZO4do1/2HXZ3tO414OJkYCF3IGkqJuQnKCKg5OSkYiMlpSDjZuclZ2VlJOGl6qWjKimlZGMhIeElIWGf46CkLW1tbuqq6ywrJutx8LArsSqz6G3qLLMsbe9wrW2ysiusJakrqu3s7+rop6koICvs7C3rLCupaqoppiUnJSfkqOlnpiamYeKkJWhnKCcm4OJnKasuLi0s8C+w66wpq+srrC/v7asqGtraW1oycOdqpeuiJeNeXv2x4FybGS6sK+prp6et7y5s7C2v6+5a2i7YmOluL9ja2K/Za27xb9kaMTEYLi1p5WkpbWzv2ttaIBxcXN3emu5p7HEc3t5b3B6fGplvsZskbSzlpqnf3KFqsq713rb29rcgHyblYlyiImgfoKqjZSljobedo99e99/jKOcj4t5l42UrqmipJ+akKSM1XN9eeHRf3p1fnGtv4N53oSBiqSxed6XguWAgpl804mM4HWLopWcrpThlMK7xIDLwXS33Ku/bsHT3LGhtaOrsHrRxKKovqy5sslv18F729XX0s6gjcu2v9fYb3K0xquxt8q01X3Btaq2orHTe392nGbX4rh9qMd3enmCcY+usHesmo23hJB828+2tXGPlq+ghOiNqp6eoZuFiYiRhJ6ss5eSiol/jIZ7dYJ8gIJzf4B8fYaChJB9fYB8f392eXx+bHd5f4WEdnR+hnx0eM3Uv7bDdX6Bjnrdxdp4fn90sa/XfIeGhoHZzXa6tq6Yu7ifstNx39TRwa2xqM1zeNfVgJGxmY97zuR02djPrnqJgoablqSjlYWNnKWUk6qtnY2JjpaaoKJ+t8bBqZ221XGCf4CWm5iPl6WYloyoj5CJppCIgYmvsr2XpKqgm6eel52cr6KShoWVko+dlpqnsriawMu7q5+Xs5+gmZ6ku299fXZ5eIuPj46HhoSMho6QmY6GkZONlJaRkZ+ikJygnp2sp5hwcHN7fnFpx6vUcHO4zMfFxLfCz73Ry7Go0bfNtc69wICptbKwm67LuMS/tLe4qrqupZaHeIGhtJmtsZ9/j5SEe3qZlo2EqoVoyq9ua8i9xMxsz8tpxa27t7auqa2fp6aqrZmAiMZtkpp80HFuyKWDlKSXl42Z8H3ul4F5cX9ya8HObYCf0+TP53y4rHukuKSuo3iBgJOImKKhlr2+sb3R1oC6q7SvwcfGvqKLjoCAlaGFiJuTftXK3YOFlLSckHyxnI3ilZ2ppaWmlNOLl3jWqJeZ3pTgd629tsGmtGZqkpKTlpeLpKuHe3d8dXiOmZafrZSHgIKQfpqZoHrc1bR5invJ49rT0Nh+h4yXfoqYtZ1/2eHi3oN8fIiObn6LmIa3cIBjZo96u3aDeXmCgIN1Z6G3wqfDppKvbYFzx27PyMSqxXR5fnN2y3SPkYp+iIx5dIKCgHl7gYJzfomLhY6DhIV3hpaEfZSShYWBdnh2gnNwbHhueZuZmZ2Jjo+TkYOSq6egjaCMr4WXi5mulpygopebrKWRkH2Nl5KdmaiVjYqOjICXmJqelZWVlJiSkYaCiYaMgY2Si4mKiXh0e4ONiZCHhnF4iI6Qmp6XlpydqpiZjpmVk5agoZ+WmllYVlhYraCLlYuagIqHdHbu0ZuOiILz6+Xi69bQ7f/68fD1/e/1iYv9hIbW7v+Di4P5gefy//eChfv/gfbz5cnT0+Hk8oWHg4CNjZCUl4bv2uP5kJuUioiVm4eA8/iGp8rKrrC4mo+evM+9z3HX1czQd3OQjYFuf4KNdXiTg4mYiH7WcoZ0c9Z1gZCHgX92ioGMnZWTlI6Lg5B/zWx1b9vPd3FtdmmntXNvynd0gJSbcdSKdtZxbX5uw3R7z2p7jIOIlHvBibKrroCwr2il4r2vYa28y6WXq5mjp228spmktqeyp7tmxaxry8PNx8aglsKzucbLZmmruaKjrbqpvnK4qqSomKO7amxijkra7al+obxramt2ZnmMlm2pmYureH9sxLyuqWZ+gYqHdtZ+loiHhoV3d3R/dYaTmISDfXl0d3pvanVydHRnc4Bycnh2dX9yc3ZvcG5sanFtYmtucnRvZ2lsdWxmbbrAr6e1a3JxfW7MvMVqcHJtqaLBb3l5eXjLwGy1qaqUra+Zp71lzsrDuairnrlqbsvIdIGWhIJ1ytFsx8zDq217dneMh5SSiHmCkJyIipiXiX98f4eIjIlvrLuwopasxWhzcIB/gYh8hpGEg3+VgIN7jYJ5c36Zm5WAjIyKiJGIhIiJnox+fXuJf4CLhoqUoJ+NtLisnpSPo5iSjJKcr2h0cW5ucYCDgoJ4eHh6eHx/h3p1f4B6gYJ8eoiJfIGFfoGSjX9fXF9oZl5Xppq4X2ChqqGop56gq5+sqpWSs56vn7OkqYCbpqWgjJ2znquim56imKKZkoh8bHSNmoaWmIx6hYd2bm2GiIFujWhXp5NaW62jp7Jdsa5VpZamp6GclZKIj46UmYl2e6tcd4Jrt2BgrJh8ipiOj4iU7HrrqJePjpSEhPH8iJmtydnK2nO2s3aWpJaelm97fYl8ho+NhJ6mnqu7wIClk6CZrbKsqpOCg3d7jJF5fZGId8vE0nt+iJyNgXKdkYDUi5GZmJaYhsqAkHPMo4+WxYPJbKSup6WWjlNWgHuEhYZ5lZV4bmxva3GDhH2HkIB3cHV/a4Z/hmzLxKhpe2/C1MnHxMt0fX6Dc3mHlYNuwsTKvXJubnN5X250f3KlYoR+AX2Jfoh9BX5+fn1+hX2FfgF9/36TfoV/i36GfZB8DX19fH19fHx8fX19fH2EfAV9fXx8fYl8iX2EfIl9gnyOfQF+hH2RfgF9hH4BfZN+Bn1+fn59fYV+BX19fn59hn4EfX5+fYR+BH1+fn2Hfod9Bn59fHx9fol9AX6JfQR+fX1+jH2Cfoh9AX6HfQd+fn59fnx8hH2JfoR9g36EfYZ+AX26foV9hX6DfYR+g32FfgN9fX6JfQF+iH0Efn59fYZ+A319foR9mn6Hfb5+rH8Ffn5+f3+6fgZ/f35+f3+EfgR/fn5/kX6EfwN+f3+JfgJ9foh9gnyHfQN+fX2pfoN9in4BfYd+BH1+fn6FfQN+fX6FfQN+f3+dfgZ9fX1+fn6GfYp+hH2KfgJ9fgICBACA+9Orxou2uaOSq6SYmoXqw62G/Y33vaGQj+OGi4jXu/DekLGMj8edyaSNjertlpynvrfCpY+gnKSgpqmyqJuimYvjm5aTrralq46NioeQk4+LlImhqLHFx8HX28q72uDJ3ty/u7Kogoqmr66lrLe8vb/I0NPmyr2wtcW8y8S6xdaA6M7Q0eHh4+He2NHFv7u0sczd8OfLyd3MzdHFvcjDyNDfzufW3tvV3Ofc1trq6Yn56t3OuLq0q9Tx5tni9/SD99nIwKGL4L29ta2TbGxjXrKnnZ+WlJZTmlGYj51RUFGTkIp4eYqVkU+fnJqSi4OHjJCUl5imq1dcXFeckaVfqp2Ap6hdW6GtopqGoaleX1xufWxiWrGtgZ2SgKvwwKma/73ZkNCHho+RmYSpj5H/kJWKrZGhg/Xwke3w1pSWsuOYsbCWnKONrMberbLNwaS/rZiFnZWW4cLb79Th0PTO3PyKz/GNksm9u6qRnpiHrpyQmoSE7pSjsbicn8XR6bnlz9WAkojN5Lva8Y3J5Mzh0cLi0db/zcq0paSyqIXeyPCZn6GU7trKqoiDjMW7y+fggqDL1cOWo9iKg/uA7trRhI6Oku3H+dfinIaet9LUgPOZuePJqLWc6tPGiayti6eJ8JCXoYuWlp2isMXQqqOrnrC0sra6mZyVm5yYjpCJk4iJhrKA4o+FtdWnt6CekYbV1dv9gJWXg+6Rscvfw87gyZvgz7bB8JGem6WSio73/5ejmqK6u7evtK2np4Tnh5bNu9LngIiGjP/i4cLL1d3FsMLi6YqIlazC7/LTq6DqioCBwomoqqabrca7hZSzxsfHx7Wwur3GuaCI3aO2uq6ByazllKGApcTJ6+7u48m/tr7Byb3HxqGjqr/P5M28taWwnpqjtMi7pJ66rMPZ4MfIwaWqvrrg5tG9udPC07ysw7v4lJWMlIiQm56UjICElLC8v7CrrKrGtL3IzcjWz8vC2Mu6rJ6Vko2H4oD0tuTE59fG6oqF5tnw/O/d8Le/vObj/9zZuMeAz9G5yry46fWAi9fi3cTKxL+ywZ2yz7Ta4+K5s7vagPaA7tLFrrShhdX/24z15uiH3ubHzujZ0MnC1cvGzbufsMqrx9nTidXTqp2Oh+m/0qO40cSxmqX5zq7FsGqSgKCrxo3Ct6V6tI6C1K6r8ZmPm56Mg/3g+KW3wqvL0bnIvcGAzsLLy+vm2MXDr6Sbi4+ytqm7wryOi57k7d3buqz0uNLl5KuswNDKppGUiYrBusSXgtqLnq7hxvuZ6bemyMSkppKdqLfNxbbpnqKioaO1v7Hmtaf7o+m+6L3Eq7aeiIiejqychveNiZSem6KgoLuomoS945WNkIySjP/26or9g46A3LyUqHmhn4x9lI2DhXbQr5932n3fsJh/gMt3enrCq97Mf5p8gb2cvZSAf9XZhIqRpp+pkH6RiJKNk5Wek4iQiH3Ti4aCnKCRln18eXZ+gH55gnqPk5qrr6a6u6qZtLmnu7mjnZSOcXeMlIuEjpmfoKKqsLLBq6KVmqmfrqSaprWAxa+xsb2+v8C6s66koqCZk6u2xMCqqbeqqqymn6mipq65q7qvt7SwuMG1srPCw27JxLusn56Xk67Cvay2xsdpyLKio42A0L26trGYdnhvasq9tbmurqxjuWG0qr5kY2OwsKeLd5eytGHBwr61pp6mr7G2u7jGymdvb2i4rMZzx7iAw8VubL7NvrWevsBsbmp8kH1yaMu+j6mYi7Huv7Kc8b3Phcd3dn1/h3WYg4zofX93mIWOc9fPf9fRwYGBl8yFl5F/io16kaW7kJWpq42jloJyhoGC0rbF2sDNt9G5yeh3uM56f6yin5WBiIR5lIF6gXRzzn6IkJqHhqeqvp3GtLiAeXS0z6rBznyxw7TDt6q7sb7ouLinnp2onXPAtNOEh4iA2ca2oIOBhrmsuc7KcIWxvsuNmbpxb+N12sGycHh2d8d71cXGkYSXqby/c9OAmLekkZ2H2cu1dpSUfZJ81XyBiXWBfoWHjZypjoyPhpmTkpGbgYJ+goF9dXhze3d2c5WAwo+FsMSMloiHfXfDvcLdcHyBcc9+la+6pK65qYXNxKyy2HyEgol+eYfl54WNh4yko52WmJaOk3XKd4y4o7jJcHVwdtjEyrK3vMO3orPMz3x1g5Wexb+ujorRh3t3rXiUlJCGlKuidICdrK6krZ2cn5+vo41+y4+bm5lxup/EfIiAhqOjv8rHv6eloKWrsJyorI6Ii5qkwKWXl4mWiYWJmqqil46dkae9v6evrI2UpZ+6ybGio7qsuaSVrqPXgHx2fHN6f4V7d21wgJSdnZCNi42lmKKkpp6spqGarZyWiIB6enJuv2rPn8GlxbOnwG9rubbJzMa8yKGko7++1L64nKuAs7ScrJucxsZmcbO3sqOpoqWcp4maspe4vryfnKW9achrwbKuoZB+a7TWu2/Hub5tucGuqb21r6umtLWptKOLmLOarbqscaqtioJ0b8SntZWjt7SojZr91LbPt3Kaf6auzZHAtKh8r5F+zqqs2IiAiIx8fPLO1ouTpZWpsp+wp6OArqiwqcDJwqWnlYyIf4KeopGfo6F/dpK7z7y2npTXnrTDwZaYp7CrjoGHdXauq7OFccJ8iZbMruGHyJyKpaWKi3uHlp6vrJ3Zh4iGiouXnZbBl4/Zjsafw5+kkJmIeXeIfJaHdNt2dYKMg4qEhZ2LgXa1zoN8f3p+eNzXyHncdXyAwal9j2qNiXdrf3pydGe7o5VqwmzKrJh0c7tqbWy1n8m7b4ZudLmitIN0dcfLdHh9j4ePfXB9d4F8goOMhXuDfnTJf3p6ipGFiHJycGxuc3Ftd2+BhYqYmY+fn4+AlpiHmJmLiIWBaXF/hHJufImJiY2Ul5mol46CipiOmo2Dj52ArJqYm6GgpqiemJaQjo2GgZOapqWSkJyQjpSMio+LjJqglJ6YnpmZm6GblZaip1qjp6GUiIiIhZajnJafqq1ZppiPlIV718rHxr6ukJSMhv3y7O3l5eGA9oL24PaBgYPx5du2g6rg7YH+/Pnr083Y3ubn6uj3+ICLjYXw3/eR9emA+PmJhvT97ODU9PKFioidrJyPhfv1pb+xpcHqzsGq6cjUgMZycXN0dnCMfoDgeHhyi36Ca8zHdc3Gunl6hcV8iYF1foJ0hZaihIuXm4SUiXhqend3y7G8ybfBrr+ru9Rsrb1udZyVj4p7fnttf3Jsc2pnv3J3fIh7e5KVn4KnmaSAZmWlu5uruG6hsaavqJ2npa/Pq6uhmpifmWqyq8N1d3pzzb6umYSIj7arssLAZG+jr7eJkKllZc9oxa6gY21pabNawrS0jomXp7G1asJvhJuOfoZ3wb+oaoGBbHtuxG9yeWl1bnV1c4CPfHx+d4N7fnmEcXFvdXJvZ2pnbGlqZnyArJiSv7V3gXd2a2y4rrTGZG5yZ8Bvf5SdjZGXj3e5uKqlwWtxc3VwanjSzXp/eX6RkouChoR+gW25a36ynKi4ZGhlasi4wKmtqbWxoKjEyHRveYWIqKeZgn3LinpxoG6FiYR6hZmUbnmNm5aTmIuMi46dkYFuwYKCgX9fq5i3bHaAd4uMoaqqnoyQjpOXk4aQlHp3eYSHnIR7f3uDd3Z7hpWOiYCJgJSoppOenYOJl5est6CUmKugqpaMn5rGdHFqbmlvc3ZsaWNncoGIinx7eXuMg4yKiISSjoeEkoB/cW1mZ19cqlqsjp2Rp5eRpFtWl6CpqaOcp46KjKeiuqeji5WAn56LmoeOqZtSW5mYkY2QjpSPk3qLl4ebo6KNipSqXKldqKGhm3tnWZ+6o1+roKVdoaObkaKfmpeUoKCWm5CBjKCMl6WWYIONeXFoYa6apo6YqKSehZH528T/65Kud7K+0Zy8tKuMqpZ6yKyu0Xl3gYN4devIw3h+kYeXpZOemJeAnpiemq20q5iYiIB8dnuQlYiPk49ybISjtqCfjILKjaWss46Ll52ZiHh6bmunpat3abttdXu4o8dzt355j5N+fW53h4+gmIjOe3V1enuDh4Odg37DgaKNpIyJeoh7cnJ7coF6Z81qbHl+dXpyc4dzb2Sku3FtcW1uaMO/sGnEam2CfYx+D319fX59fn19fX5+fX5+foR9hH4IfX19fn5+fX2UfgF97H4Bf49+AX+Gfop9h3wJfXx9fHx8fX19iHwBfY58hH0EfHx8fYR8gn2HfIh9gnyMfQJ+fYl+AX2Hfgp9fX59fX1+fn59ln6LfQN+fX2QfgF9in4FfX19fn6FfQF+kX0Efn19fYR+jH2CfoZ9B35+fX59fX2EfgJ9fol9An59h36DfYZ+AX2ifgV9fHx8fYZ+hH2EfgF9iX6FfYd+gn2NfgN9fn6EfYR+jH2KfoV9l34BfYV+g32+fqd/An5/iH6Cf5l+gn+UfhJ/fn9+fn59fn9/fn5+f35+fn+Vfod/in4IfX19fHx9fX6KfQF+hH2GfoN9p34BfY5+Dn19fX5+fX5+fn19fX59jX4BfYt+AX2QfgF9jH6CfYZ+B319fX59fn4CAgQAgIv495mjioWDno6nnJSFifnYytOFgIXn9Y7y0uC8kZGFjuWFo66xspWqqrSsoYyCioqIqambmq2krLC0o7Ghp6eckI+MiYqfrbjR0cS0oaqmoKWpmoqNnKeSnJv2i4D8n5mZm46Cge6C9e+Dlp6nmpWfvbm6wLyrvr3DtL/T6dTNgMy+v8vR1N7ozsm9y9zg4dzMxrvc7evf4OTx5+bj0dTIx9TR3PLr5Ojy5oX8gofwz8zl1MW4qJ6qtKLQwcLH29WogNiui3Rlrl+xW2FlX1xcYWhjX1mdlJOOkJOSmaOXkJWTl5yooKCgpJuanalWVlpeY19fWVZXWV9dX1egpZ6igKqroZ2YXWhpXKWtXl1qc25uaWZtia3DgInUkbbtyM+yxd2ktZH995uJhdSIg/6B/5qk8tGUrbOFxqDgiqm2hdKRy7H6kaGjvKmxo6ukuI2GmJSH8eS+pcuxurzeg+DgjdXc3pPUg6r6l8mtnZSKmYuHtb/7gYyPkJi+y83zie+1gPbBpun7gouA6/XU6ey128+Gjd7HyNTQy9PL/IWfrJGRlrj56IPbho2/jqW2pbPTge7M3r3X6ej9g//qv8SG8t+W/oS9tvqt6omEjHu7g9KYvJeFns3qr/WKkqa1l6mkn5qklpGUrrS7va6wraWIjZWLifqHhJCOhoaFgfaHjIqbgMOqif+VkpmM//Scg5Gdhd++9o6vxNfX18zV1PTy37CpnaW4qZyIl6PCoIecq7ausr3EzMmpoZCDhuT4+eva2uaC/vTV38SmqabH3aCDkbC/4fmSobGvstDYw63jtsO145mijqGvwcnFwJf6/pOrsqGdxrqul5O2gJOA38jGqKKOgIqjuMrGz8TC286kqN3g3+HX2ty8rZCSrKWXr7nAmKnZ0c7w2NXa0tXXubmyxcmw0dDNwMXQy9Db4tnegPeHioGGgYXx59jIgr3X1s3d29DRx9nU2dO73e/Ut7GkqKebhNfc3ePr0+bYvby644fh9c7PgeXx7Ynx0sTZztnN1ObPgNfZ1fzr74GLh+vdyrm/xLWuj7XI8tGGmO368tPIz9n2gPjezPOZlbmMxJCQ3ef0+oKruvCB3Nnav7aqq9TU0sjLrLrL5pXVwJuG/+fCu5GyztbExaKVhtK4fYTWvZGniZvk5K+ienWGn7ew//D5ur7Iv5uY+aLlyOKgw7uwq8DMgOe2uvrS8Ojq2bytoaiskoqSjqiSqa6oxoP/8buc2uv02MbMnqfKt6ydj5yMgNTN0YmQlZm+q56jo+qqzMafkpOnwbuwoLi1mp+Pm7euqrHy9dKroJuaq8mtgKu5oIz4h4GoqpiXmYWHi5iTuKaMhaPy6ZSQhtK3xvHdhJT21ufwgHrX2YeLeXRziHuSh4J1ed/GuL13cXbO233avsqqgoF4gdR2jpibn4SWlaCWjX52fHx4lZWHiZeSmZmdj5uNk5SNgn98d3yMl6C1taqejZaSjY+ViHp8iZOAh4vIdm/djImGh391btN02tRzgoWIgn2Go56ipqGTpaOom6SyxLKsgK+kpK2ytbnCraqerbm6u7SqpZu3xsO5ub7GwMC7ra+mpa6os8fAv8HJvGzMaW3DrK6+rqOekYmRmImqnZ6ksLKSdsuwkHxywGnCZGlwaGZnbnRvbma0ramkpaystMCvqrCxsbnJwsC7x7i9vcpoaW5wdnBzaWdoZ29ucWa9wre8gMjKwbixbHl3asPHbm16hX18dXB4kK/De3+xhbXawtCzyNKLm4Lm5oV8eb5+dex33oOV2bl8kZp4upPReY+cdsJ+ppzihY6KpJOYipaRoYN4g3xz182wm72foqnCcMvMerzGy4DBdo/ljbKThnx4h3p0lp3ecXd7e4Ofq6jCbsmcgNWxl9nfcHZwzdm9yc6nv7ZyeMq5vLy8usO82HKJkH99fpvkzXLBg4i0ipyonaS8cMaywaW6ycrab9nLtaxy1MR9zX2mmdms44GCi3usc8SGoYF3habCld99gI6YgZGOioONhICAkpabnpKRkIx3eH91dtJzbXl5c3JwcdR1d3OEgKGPd+B9e4N33d6FcXuDcsOq13uSo7OwsKe2sMfItJCOh46YjodzfIqliXaGj6CXl5+mqKWOh35vecbV08vDvshu1ta+xq2SlZe3yph/j6S51uSEkJeQk62yoJXJq62gxoWQf42aqbKqpYnk5ISRmIyJqaKah3+WZHdqwK2rjYt6gHmMnLGtr6ajv7KOjre4vL+3sbOekHl9lZSFlJujj5e5tKfOubS3r7Gympyarq2ZtLSvp6y5rLK6xbvCcdV4d21saW7IwbmtbZutrqmxsp+mnrKosKiXs8Kxk5CDhYh+bLO9vsXFuMS0pKmlwG63xaqsaL3IxHjHrqW0rbistsOwgLO1r9/QzWpybL+3qJyco5iYgqCqzrdxesvOx7Srr7PNaszDst+OcpRxqnhztMDGyGqYocppuLW4pp+Tkq6ysqWnkKCtvnionYBt0MCopIOfsrmqr5OJgdW8gIncyIachJbr46+oe3iJn7Wr7Njlo6StqYWJ64vCrcOTrKCUj6WzgMmep9OwxsDAsJqTjY6XhHt+eZR/lJGKpWzYxKKCt8XKsqSyiJKrnpqRfIN4dcS5uXR5fYCdkIWKkM6TsaWEe3+UpZqSiaCbhIp4hJaRjZPDwqmQj4eIk6yWcJSciXXbdXSQk4SIgnZ2fIJ9mYd4cojSy4B9dbeisNbEcoDYwM7XgGy6v3J4a2Zlc2t+dnBqbs+3rrFrZmi7x2/ErLmdcm5tcsNre4WHinSBgouCeXBrcXBrf31zd4Z/hYaGfod9g4N+d3VzbXN/houcmZOKfISDgIOFe29wfYZ0enyuaGXNf314fndwZsRsy8pqdHRzcGtwjIeOlZSJlpGXjJGcqZyVgKGUkZmdnJ6jlJCGlZucm5KPjYigqKOemp2lnqGflJeNiZCJlKWfo6WsnFWjUlielZejk4yHgXV9hXyNh4uQmZ6LdtnKp5qP/ob6gYSLhIGEiYyJh4Dm2trT197c6fnm29/k5u359+/p+uvu8P+EgouOk4+Qh4SFhIyNjoP09+fsgPr/+OjohpWPgvT7h4uZpZqWko2UqL/OdXyffLrVyNK/1dqDi3rd5H10cL15cOJx1HmL0bR0goptqZLHc4aMb8N1k43afIOBl4mLgIyJmH1xeHBry8ComrKVlp60ZcHGbrK3v3S5cYbghJ2Gemtsd3Brf4HQamxzcnePlZKkWqOCgL6ijsTKY2djs76sr7merqllarmytLOurbuxyWp5fnVxcInUxGq3hY61kaCnnKGyZbSkrpestrvGZMPArKNnxrVurX2agMCg7YCFkIWnZ7d3inJtdIigg85ydHuCc356eXV7dXNyf4WEiH18fH9ra3Npab1oY2xuaGRmaMNqaWV2gIt8asRwb3VryMl3aGxyZrWixGx8jZmXk4yclKKkmHh6dHp7e3doa3eMfmt1fo2JhIuOkI59fHJob7u/vbe1tbliwMO0uqaLjY6ow52Jkaa50dd4goyEhJifkYq+pJ+Xt3yFc4WNmZ2XlXzU2nqDiX16lYyFenSEU1xVnJKNdndrgG97hp6ZmIuQp5uAfZiapKOalZOEeW1xgIN2goWHfYekmJO0oaKflZeai4yNo52LqKObnJ+lnaGpsKmzZ8Vra2BbW1+vqKWeYoSVl5WWl4OLh5mPl46EnKOXfn1sb3NoWqCoqLGxprGdkZOOoFiYn5KUVqSsoWWklZCZl5yRm6OZgJqZk76xrlldV5ycjoiFi4WFe4+UsqBfZLW0r6Kan52xXK+ooNOPWnhakmJclqKlqVeGkKxaoJ+klY2Fg5aZl4+UgY2Zm2KKg25fvK+amH6ToKigpo6EfuDPlKLq0YOLgI7p47OtiomYqLSr38nbk5WZlHp+4ICom6uHmZCHhJajgLeSl7ShsKmnmomGgoSLfnZ3dIV3g317ilq+oo90mqitn5Wef4ibk5GLdXhxbL2yrmhtbHKEf3Z4fsN9lYx2b3WCjIN+f4yEdXprdX6AfoGknIp4enp7hZGAZH+JemnNbnGCfnV3dm1sc3BugHZnaHC4uG9rZaSVoL2vZXDArbrCA359fYx+hH0Gfn5+fX1+hH2EfgF9uX4EfX5+fYd+BH1+fX3AfgR/fn9/lH6FfQN8fXyLfZh8j32JfIR9gnyMfYR+h30Sfn5+fX1+fn59fn59fn1+fn19hH6DfYR+BX1+fn59j36JfQx+fX1+fX19fn1+fn2LfgF9iX4Df35+hX2Dfoh9gn6JfYd+A319fop9AX6IfQF+hH0Lfn19fn19fX59fXyFfQJ+fYh+AX2afgF9iH4BfYd+AX2EfoJ9hX6Dfad+h30BfpF9iX6FfYp+gn2LfoN/wX4Cf36Gf4R+mX+MfgF/hH4Ff35+fn+QfoN/jX6Cf4h+DH9+fn59fX9/f35/f4R+BX9+fn5/kH6Ff41+hn2Efo19hn4BfaN+AX+UfoN9iX4BfaR+AX2RfgV9fX5+foV9gn6EfQICBACAr57atoGBkpSonfSagoOanJT31fzbyfeA7uLDxqbbzOPJ9oCThYeWkqyks6SwouLt9oKDj6WtoqGjk4qHkqm3kZSah5ulo5fyhZKfp6+ypZ6oo5ejoPL36fmG4PaClpSbjomEj5+3tquipaCjmJuQjI+Ohqeor72zpKG4x7/G0s6A4dbJ2cXK5+Tm6t/p5N/f7tXg2MbU29DR39TRz9nt8/P19Pv4gvLn+oj26eHo3NS2r6/R4cydtr2bgZ6isqqblu7a7ODNlYOYpKSt2ZiWdot1ZmdzbWhhXaxcraSfnq+uoKhSoaJZplWkVVtfZGNlZmRmXqpaXGBhXF1bYKanoaqAV1xarnVrgJJ9tKFhWl5vdGFsdqfHxuv7hY+BjqCRw5umps3Xi4eB6tyDz9+Qo4+J7JGzlYTj48vi2aGE3oyd8oKnnJaD7JyrjI6J9eS91JL/iofy6fG8wb7r0sbDt6XVw9bJguHo/ZOUhomQm5SUkY6ViISw6/+Glai90sDbgoCAvZLjobXu1NbS1ajMzuV/pbu62qqZgsKRktvlg/ziyqObrpf03Y7Jn31+ipeS0rzHvM3e2oTXscLnk6jexebi/I+Y69/AhILpx9zutIaJ376FmoHmkbm+trfhy8PyhYycn5ufr6mWmaSqoaWRiKnGmpKDts3I5Nnj/ob3ioqcnqeAqKu8oJ6AgZidoJ+YoaW2u7WFhJKYoZ6ipcXa2s/g0snAvJ2dqrOXqtLBsKy0t6aVjaCuqsGlj4yggfXjgPjv2MfG8e+NgOiOpcbm58aVorjQ5oOB8eWMhZiAgPjA5Kq0ssnH0qugk6Orx9i7qKigtYeKxr2XiJStzuDz7/nl5dyA1tjZhNbQ0MDCydbczr++qqiqs6q3rpWwycu0prjTytHN09rX0bq12a2x0fDb6cLTxcmouODCydPS5f/XhIGOjOviw8vV8eX5vL60w9DAxbSsv7q4ub22waaym5uRmIje4tfT7ujc38zX1NH6y9j35cTS4tyG/4KC8JyVgoaH+vaA3ezQ49Lv6dXn57+qscKI78zqlPLn2vbf0cTN3POFhN3NzfPg0YWoopbTtfHIvvf44MXR3uvMztrHzLCsl66NoLrNzOzuh7b5n+3gzeug07+bnr26pI6O7+C59PKgzezH+dmzuIqai5mdnIHemrCgpeS0gsfS3+656djEwbS70MOAt7nKzNnp94nwy9zHnr6sjZickIOLzta/tuOC7MHW8fDEraqSqbmlsJ+imomR7v/P2KKmya3KsqKKzoXGr4uloJSOiZWvr6CHy926qsXJ5IfJrLrDqZiqo4qazMqslaeUl7efwcyYkYSQoI6IlZuwpIj36ujk+IiL+tr7gda0puqAmojCqHNxf4KTiNaIcnKIioHdwOTGut9x2NC0tZvLv9S343SEeXuGgpmQnpCajsrd4HVzgZOaj46QhXt5gZSigoeLe4qQkYjieYGOlJyekoyUkYeSjt3m2+J6y911ioaLfnp3gYyenpWOkoyQhouAfX99dpGTmqSXjYmbp6CnsrGAwbSquaapw8C+wre+u7a4xa+3sqavtqutubCrq7LCx8bGxs3GacS9zG7Lvbe9tLObl5Sst6qLmKGFd4uMlZCEgd7T3NLMmoijqqer1Z2dfph9cXN+d3Vua8ZpxLy4scnFusVhvbtpwGXAZGtxd3Z5eXZ6bsRpbXR0bXFrcMTHvMaAZmxnwYR4iZmFy7lvZ2p8gWt4fa7Hwd7we4F4gY6CvIeTkKm2fHtz1NR6xs58jXx30XyXhXPCxLjUzJFzy3uN2niTiYV224ucfXx319Gtwn/heXPaytSuqarVva6wp5y6s7yzdczI3YGCfXt+hX6HfHqCdnSiydVwe4+erp+zaWWAoYXIkqLHu760tZe0t919nqyox56Wf6x5fcvQctjFtIyDkIDawny6nHx7hp6Z0q61qbXFxXXHoLDFeJHGscjB2neBz8arbnDItszesYV5zLd3hnjYf5mbmpi1qKDadnmEh4SIlY+Bf46NhIZ6c4ihf3pwr7GxxsLF3XPWdXWHho6AkIuchohvboGFi4aCjIyZoJ5zdX2CiIWJjaSzsqW7rqafnYKEk5p2j7KfmJSaoJCBd4eTjamPenuKbdTCcNPPwrWy09KBetqEmbPLzLiOmay/z3Nz2NN/d4VtbtyyyZicm6+tuJaLf4uTrb+ol5OImnt6paKGeX+OqLnOwMa3ubeAubWya7aor6Okq7e5qqCjlo2NmZOgl4GUp6maiZ2zraqrsLOvq5yXwZOXsNK2x6q7sLWUo8SrtLm5yNm3b210b8C/qLHC28fboZ2Uoq2cpJGKnJyTl5iUnIeOfX11f3K+vry8zce9wK7AurDQrrDOwKWvvrhuzmhpxn95aG1n086AvcqsurDTvLC/vqaXmqV43rHAc8G/tMy5r6iyu8hsbbmxrcO9t3uJgHaymcaro9DMu6i3t8KssbmqrpiXhpR/jaGrrMXGcZHEhb64tsmLs6aHi6WmkIKE49i47e2jzMu07du4v42fjp2lo4XQiKGLksOfcqu0vcyjxL+rq52fsKSAnp2zsrrCy3PNqLevjaiVfYWIenJ2qKylmbxtwZ6uy8qllZeBk5+Qm4yLiHaD1vPLwYuLpZWql4x8uniijnKMhoB6dXuRlIp2rLeYj6Wnv2+jjJigj4KPjXaKqauPgI19gZ+Mo6d/fHJ9hnVzfIKVjHfVz8zH1XZ53L3bc76jmdCAhXWvoGNjbnGAd8N3aGd6eHHLscizrslkwrqnpJa4scetzGh1b293dIR+h36EerrLzWZlbX2HfYCBdm5sc4OQeH2Bc39/hX3UcHWDh46LgX+GhX6Jh9Xj09JwwcxugX6Cc3Ftdn6Oi4R/hoCGfIB4dXh6boKFiZGEfHWFj42VnZuAp5mSnY6TqKWfpJacnpycppOalpKWnJGSnpeNkZWgo6KhoaihVaOiqVunm5icl5yMioGQmZR5goh1aXl9gIR6e9vX4NnTtKKzurm40KuwmKeUjpCSkZaNhv6D/PLr4fz05/eA+PSG+oL7goqOlpiam5abj/+EjJCSjI6Ij/798vuAgIWA+JuPm6KR/PKLgoiaoImUmsHOzd/teH14fIV7x4GIh5uic3Vx08520M52gnVtxXOGeWmzt7LLyIVtx3N8znaKfn1v2YGSeXZyz8aswHPTbmfDu8OhnqDAr6Wln5erpq+scMK9znJ0dG9zdXB3b254amiducRmb4KMmI2cWFSAh26vhpCqqKikooydo+CBmaShu5uUgKNrb7/Gace3rn1xfHTOvHKymIKAisC/66msnay4uGy7lqG5an65prmzwmdzvLWeYGSypL/FpYdpvatseXHIcoaFh4aYjIrGam14d3R7hH91bH16dHNrZ2+Cbmtmo6ijs7S1ymjFZ2l2dH6AfHeCdXhpZG92e3dyent+io9oanByd3d2fIuamYydmIuHhXBzfYlpd5OMiIWLkIN5bHd+d5KDbm96ZL+6ZMTBsq6mvcF2cs6Ej6O4wreUnKe5zG5pysl0bnlpataruIWKi56cpIh/cn+DmqiUhYB8h3NukIp4bnGAkKGqo6KWlpiAnZiWXpuTk5CTm5mXi4iMf3l4fn2HfnOBj4+DeYaakZKSmJqXkYuMqoOKpLqmtZ2upaSKl7OcpKyqvMGpZGJlXqKpm6a3wLHEjYmDj5WJjX13hoR+gH9+gG9xamtlbmaprqujuq+or5+rqJywlZSupZOZoqBZp1NYq2pjVlxYsK2Aoa+TnZuvmJihnpGGhops0JaiXaChnLGhoZugpahbXaKdlaOnpnF3Z1+Yh6eQkLKtppWioa6coKOVmYaEd4R2fpGVlaSnYHmddKilp61/oZWAhJmbiX5/4dzB4++10bCj3ta+yKSxm6+1sZTKfJaBhaqLaZukprSYraeenY+Rn5iAlI6goqutt2O1laOdg5SGd3t/cGtriI6NiqNco4ubtbSVgop3hpSHj4OBfGx50+O9s3R8i4STi4FzsmqHemZ1d3Fra3GCgXprk5Z+fo6VpFuDcoCFeG94d2l9mJh7cH5yeIx+kIdxb2VtcWZmbW9/eGe9u7WzvGhqxK/GabGblcAEfn59fYZ+AX2GfoZ9AX6KfYx+g32WfgF9jX6EfQN+fX3IfgV/fn5+f5d+mH0CfH2IfAd9fHx9fH18in0BfIh9hHwEfX19fIV9gnyNfYZ+AX2IfgV9fX59fYR+AX2EfoV9Bn5+fX5+fYV+AX2FfoR9BH59fn6QfQR+fX19jX6DfYd+BH9/fn6LfQF8iX0Ifn59fX59fX2EfgN9fX6FfYN8hn0BfoR9gn6FfQd+fn19fX5+hn0Hfn19fn5+fYh+AX2Vfod9An59v34DfX1+h32Cfox9BH5+fX2FfoN9pX4Bf7h+hH+Ifpd/lX4Ff35/f36Ff5F+BH1+fn+KfoJ/iH6Cf5x+hH+Ofod9gn6MfZt+AX+SfgF/kn6EfYh+AX2VfgF/oX6FfQZ+fn19fX6EfQICBACA5Jnr75CWk4mLlaL8793ejpm3n5aP+4fr3IPE7+LL6NDH8cr2h4GSn7mrpLCfi4+G6a/L4uH6jJehoKKZm6COmaOtpI+TnamL8YaUoa6dp7O3lZOUpbWngv2Yj4GDh+jZiJ2jpKORjpypmYqUmJCfjZqkqbXIzdnS0ry2tL7Dzr+AucvFx9vi9f/p8NbZ6PDi3snCx9jc0d/n5+79gPPX6/WK//+Eh4OShuv26MWckPHii7CzqJWcsaSJkuWD6IGTlY/+26+Ylpubq6nU57+MfIyOkXuZlXljWVlbY2lycXBvbmViYGZqYVZUWF1kYV9iaGNaaXlydXhrY19Um6aenrCAcH2PuquLmpt/eX9yXGd+amBunt79+PCPqq2hppustJXDp4ehoIWtgISgz9qVrLSdhIKegYLzh4iHlZqE2Iqx98LBwbLW3Pnt5bf29tjmjomXkqLb6NL3jd/EtaOrt7upw9Dbp6bY1/KSgNfr9pOHjJWHi/W0i/6Hi/aJlZOoxf2A+oTvzKCG34mNlILk9tSP7/Klr5afp8n/3orniKXLzuL4layshvXIwcic7MSKrI7AqrethrbOvc3GmZnmtKm80fuhkZL/gvCHo4PSn7W18/zl49SEiJ6rkaK8yLa7n4CJq5abmY6HmKCnmaCrkIKUorGqlYPCnsSrqbb1go2Kg4+AlPnnlqSdmIWdr6GFkpGOla+0sqGggvyaqbOnnJOhsbnDzLjFws7BwMbL4Ma4pZWHjpyVp8Cjho6bopSbjtvwkaGUk6yGnbXcvai/+aGE5dft+NfHu8ae0Z2UvYfliIyHjJymqLSajJelkba0xsG0yfzyycC9nOaGiIqbsrTFtMSAxsvZ18C4oJGu097azdvjwcTr+4Tx2cfDx8fDx9PAxbizwbyoo72wtKytybvGxc3bhI2R+t7/+/OWhoT14+zb1NPFucHe6PSLlK3ExMnFw7nKx766vqK5q5edi//l1Mqyu8/ctPTz7uTi2OXk+vDV4Ozm6Yj578iZh4787/LO64mAh//n4rna4casqrjItMvmrP3G7u7E07e73NLphPX4/PzXzrTV9MbMk+SKnYSAv6zgx8LG2L+srL7lx7avk5e81+eAjp/9lZOR8Yfn6uqlxZKZscPG0/r14eKwwsy/+bbYhJGImqCtvZ2QnnHVj/GHnYKcwoTLy7yxqq3UmpS6o7WAr7S0xr7y5N7Mw8u8s9SgnYXwk6a0q97H+Irt4bqCm/nIrJmlqYefnKnV9r+Xl6iX4Mzbia69t6SAsYeugvKQhJKaqIWyiZmWyOyzi56Dyu/h6dXjy8vqt5uJpI+JlbWmx9i4iISYj5GKjY6cmYOIl4mW/JzP3ebO942Wlo/Z5N6AyofQ1ICEg3p6gI3h18bGf4ieioR93HfXy3a12c+71cO548LmfHSDjKWWj5uNe4F40KK5zsrifIePjo+IiZB9iJKZkoGEjJl+4XuFjpuNlZ2ihoSDkZ+WduWIgHV2etPGeIqPkI+AfouViX6Fh4COfIeNkZuusLi1s5+amaCkrKGAnKqkpri6zdPDx7CxvMa5uKWgpLC0rLO9u8HMZcWuv8Zuy8ppaWh0abnHvaeGgtvKe5OXj4KHlYx3fs562G98gIDp17GZlpucrqjH4sGThJOUmIKeoIFvY2Rnb3V9fX1/fnRucHh7cWRkZ2x2cW9yfHZodYmBhIV7dHBhucW2tMWAe4uavbGUoaGGhoqAaHGMc2d2ntju5+t+lJWPjoaSnIOfk3OFjXupg4WcxciAnJuEc3KKcHbUdnt6hoh6x3mX6Ly4vKrG0ODTz6rY4MTOe3iAeobBybvdfMeuo5ibpa6Ysr2/kJHCxNJ8bcDJ3IJ0cn52eNiiddZzd9x4f32On8iAzG3EqId4xniBi3XJ1NOO5+yiqJKTmbrTwnjKdI+9ws/TfI6Qeey9tLmU6daSsYitn66lhqq7q7Grg4fRq5eit9KFfnrhc9Nvh3HCm72p3+zMy791dYONe4mZo5OdhXB4kH2Fgnxyf4mMf4OOem99hI6MgXi4lbGdoKnWb3l1b3eAgNPIfZCEg3KCjoVzfHx8gJOWmIiKcN2BjJWQi3yLk5ieppmooqmgnaSou6ebkoFyeYZ/jqOIc3mBhnuGfsbYfoR7fZxykaDArZaq2Yx0zcLU2MO/tbmbxp6ayIPOd3x2fIiSkp6GeoSPfJ2aqaWbp8/Kp52ijdx8fX2EmpqtmaCAqKiytaOejICZsrm0rL2/q6nIzmzFsqWfo6Wjo6yfopiWo6eRkaaVmJKXsKKqrbPCb3V417zb3NF8b23Jvci2s6+roazCxctzfJOhpKCenZOgopmTmYKXiXx/cNXBs6+ap7a8m9DJy8PEur22zs2zv8nDwm/Mw6iGbnPPwsqsx3CAbM68vJ63v6iQkZ6qm67Yk8yjxsKlr5+eua7BacnIzdC5tKS5yq/BgrxwfWplnpK/pqWlr56SlZ+6ppqXhYWltLhrdH7QfXh4z3DCxMONpYCHl6Wntuvg0N6wvs659afAf5OMm6OxwKCSpnPRhuWBkm6KomunrqahlJG6i4KljpiAkpeXqKXVv7aupq6enbCLiXXZgJebjLGiyG7Gvpxqfs6rk4SRlXeKi5iuyaaGhZWGyrbBdZSfm5JvpXiQbdF5b4GCjXGVdYSCpLiUc4pyrMW7wK62o6e+lYd4kH95f5qLo7SeeXaDeH50d3iFg29zgHaC2om5xc632XqBgn2/zsiAu3e7wHNzc29tcnzKw7O4c3aGd3VswmrCummnxsGrx7q21cLacWlyfY6AfYZ7a3NrvpmuvrrNbniAe3p3eYFueIKKgnZ7fYh10nN9g4yAho6ReXt4hZOIa9Z9d2ppccW7bnyBgoN6d4CGe3R6fXiCcXyBgIqanaCfmYmFhYeMlIyAiZOMjp2csLeoq5GQoKmcnYqFi5OZj5CenKCnU6GOn6NZop9UUVBZT4mdoZJ3dtbDcYCCfHV1f3prbb9tyWdwdHzm2L+uqquxv7bI3taynqanq5qprpeNhYKAiI6TlpqenJKNjpickYCChYmUkI2PnZqJkJ6hpaCYkpCC9P3y7PuAk5+uxrunsa6emZ6dhJCpi4CPtt7q6Oh7iYmGhn2DjHuPgW9/hHS2lpOox8R8lIp1bWp8a2/Ib3J0e4Byy3OM3L69wLHH0tfJyajPzrnDcG1wa3GstLDKcbmjl5CSm6GRqbK2hoKxt8BtYrK2zXVrZnFsbsCdZsBlaspvc3OAj6mAqlufhG9lrmhyeGS2vsGM6vGYn4yMkai7tmy4aH2vucG/bnmAbNq3rbGQ+eu1zoimmqWZiKKuoKShcXa8npOZqr5yb2vHYrNcbWS0ltCfzdS8v7ZqaW96bnd+hX6EcGRofHF1bnFmbHh5cHB9bWVucHZ3dG6wlKeXm6HGZm9pZWaAbbuzbIN3cmdvd3Nna2xvc4KAiHh8achye4CFf3B0gIGFjIWSi42IhYuOoZiKf3hsbnhxeYp8Z2xuc213dbvJb3ZxbYZrg5XBo5Gcwn5vwrjCyru7srSj4Li54YS3anFscX2GhpF4bXmBco6IlZCGk7OliIqIfMtvdHR5iIWWgoiAlI+UmIqFe3SJlZmRkqKikZWnqVqglYiFjImJiZGDhYB+jJKGhpOHioKJn5OcoKe1ZWZovK7GvLpqYF6uqK+fn52cl560tLNna4KOjoaAgHSBhX56fnB+c2ptYr2spaCKmaejjr2rq7Cqo6Warq6bpKyjoVmknIx2WF2roKyWrVqAWaiZnYmnoot8f4WNgZLEg6WLoqCUn5KQpJmrW6+qsbCjoI+hsKC8d5xZY1hRiISmk5OPlI6EhoidkIeIfnqOnqFcXWGvaGZpvmWtrKyEl3l8h5KZqOLcz9muvM679J2ueaCbrrfEyKyoroTIfdt1h2V7jleXoJmVioamf3qShYuAhouMn5q/r6SgmJyQi5qAe2/NdYOIe5KKolutqI9ZbLqZg3mHinR+fomds5t/doV8wa2yaIKOkYVlnWl8ZLlqZHJ0dmd+aHJ1ipV8aXxsk6acnpWPfoSUenNvgm9tdoZ6iZSFbm91bnRrbGhzcGBmbmlvv3estr2sx21xcm2xw7kEfX59fYd+hH2GfgV9fn19fop9jH6GfZJ+AX2PfgF9hX6Cfbt+AX+EfgN/fn6Ff4Z+gn2KfgN9fn2Efrp9hXyXfY9+hn2JfgF9hn4DfX5+j32FfoR9AX6LfQp+fn19fX5+fX19hn4HfX1+fX5+fYd+AX+EfgF9hH6EfYJ8iH0Efn1+foR9hH6FfYR8i32CfoZ9DH5+fn1+fX5+fn19fIZ9oX6HfYZ+gn2TfgF9pn6CfYh+hX2Cfol9hHyCfZl+AX2cfgF/nH6Df4V+g3+MfpR/mH4Bf4R+gn+FfoJ/jX4BfYx+AX+KfgN9fn6Ef5R+CX9/f35/f39+f4t+iX2Dfot9An59hX4Bf51+AX2HfgZ/fn5+f3+RfoN9hn4FfX5+fn20fgJ9foV9hH6DfQICBACA5OLThfiLoZeSi4GZspu4kJ6ZkN6XoLSMhvG7yd+AiIrulJWQgOeOr7SZiJyspY+BgNzAssHb1uWKlozYgoiJkI2NkoeOlJeTl6CYgYSCkqGWnq+kkYWBjobt7ufQgvzt+uDl8/3k5IaJlLahorfAvb+sws/SwrfT28atmpecpcmA28bFxcXUzNTa6O7l5NvR2dfb3eTq+fPu4+zc1OfsipuYnIiTlITo2Ivu06X7nqeOjKy51q6WrrnKu7ORnK2blZKC++zP0tHH3uqL58rUu9D9w8vt87mKmJSxtaaGfW5uhHRza2O3X8Fzf2tgWq5kZGRgdHNqVqVedW5YpIygXYeAh5TH2Y56emVcdLSalqB8bm2TuojxkqDCzMu4lZ7IpKu1msagpayUhN+B/YiCgove6JPphe7f94qeiJmLh5b90qfIpcSyrc/TmJKOhoL4jZuOs6CLgPD2gPrw3dzZ1uDRv+jkgYiKg/DzgISF3PT00YmQiIDq6IGAlIuVlIKEv+iA04aPkYzamu3wjKqIjaGGsJexk8iRtLvm27Da+fCH+ISihJ6flqGGjPasy6KEqH++8frPn6bR2N+upsv3gZq52fb35v+Km4n1y7Gci7eOjJ+Ml5CFhKK8wbvDxoiho5SSqoeHi4mOnaaWm4iforCrzcK6wauS6e+PhrHI9oeWmaOAkYqGjO7E3IyTo623urC0qKihy8KsoaKXusesmsKnq7jGtrWssMbBwL28xLnGtbudkJWZrK3Dr5u3uZmhrZWMipKRk6OurpuSi8OllrXisJuEmJimnoJ2fZvEvJHHtMzx4+KAgZOphqa1tKOrrq2ro6Omlf2NoszYxtvSn67D09qA3NLX19q7sMi60eb8+Ove2dTt3MfUysG9yM24u7/Nzt/LwMfJtZyIk7S4q7jD4eONioSwuqKWh5GDnpDtz7bEvs/e2fiN/ZOSmoS81ti7sLKonKKTkPSE/YHQztS5uLelocbQxNnO2KSsuceA+/bt+4yE/OiF0eWHi4uN/IiFiI2A6t7a6NLDwMOqr6iVlZWfs5DY1LWbtay/69zt7sX1iIjI0vHi+47TgsacloTZvtPj08GgtM7V59zs6+PoupCuw8nhubXFsPSCiJmFjZym/LW259G0pZChh5KQgeeS+cbOx56MiYGit6R91b7qkImeo5yqttvHtbujr4+XtrSvtqqAtYaGkIyVkLnT6NnBqqylqJylm4mikbXL7ILtiuqG6c29jqHK27ykiLHh17S70M3ElYiCiYyxlo+A9LuhjYGf/ubW4b61/OmisLaWhZqVr8zw7++F5M6BiNmfoqupk8eMr6Kom4nyhYqNmPaFiq/BoaeQlZ2U/f6QoLGlko+QmqyAzMrAdt98jIaBfHGFmYWffYmGgMWFjJ16d9axvcl0e3zUhIZ/cdOBnaCHeYqZln9zcsuxprfQwtF7h3zCdnl6gH59gXiChYiCiJCJdXh2g5GHi5mSgnl3g3zc19G8d+Ta5cjO3+rMynp7gZ+NjJ6noqSSpqy1pZ+3vauVhICGiqmAu6ekpaiwq7O3wMO8vLOssa+ztLi+ysPBtsC1rr+/bXl3fW50dWe7rnXZxZ7kjJN7e5WctJaCk5utm5N7gZGFg3tw4tzExsa71Nt93cnVu8rqusPd47KSoJystq2QiXZ0iXx7cm7IbNB7g3ZvacVydHRsfnx2Yr5pgHpmvqC2Zo6AkZ3J3ZaHiHBkfLugm6qFdnCYuH7ihIqkqKSbg4WljJKXj7qboqyXhth13HVydH3N0IPSc9vP4HeMfIZ/eIHiyqK/oLqrp8C3fnl6cm/Ue4p6l4t7cNHRc9nZw8TCwMS/sMvMbXZzctTObnByx9TOsnJ4dG3Iym1rfXmDfXR2nbWArWducW20gtDPeZN4fZB2oZOgisiOoavKxKPF3tR43nGOcYKFgol0d9ek0K2KsH6t1+S8mKDCwsyjl67Xfo2jus3Vx9dygHS6kpOEdqmEdoV6gnhzcIianJaqrXOAhIB6kHRzeHZ7got+h3WFh5SMqp+WoYx7z9J9c6K01XJ+gImAgXN0edevyXp/i5SYm5Sbj4+JraCTi4x+nqSOgqSOkZyonJKRlKWfnpqYnJulmaSLgYGBkYugkYSXlX6JlX94dXx8f4yUmIeDgrSai6HBnI5/kJGelYR4gqDCqIW/scXn0NB0c4SXdo+dm4uTmJaUjImNg958hKiypra1ipGhrbiAv7Wysrmjmayeqr7RzMS2trDDs6ewraCcpKuWnp2prL2upamrnoh2g5mbkp+owsR4d3COlod+cnpvgXjMsqCup7S/uc920XZ3e2uVoqSTkIqGf4R3d8tt2G2ys7enqqiWkayurLWvuJGZo69szs/EznFt0r1wscZvc3JyzHJucXWAw7m3wrWooqSRlo+Dg4GRmXS1tpqKopejyLa8w6jIcG+rs9LD0na7e6N4cmu0obK+tJ+Km7W0urXTxsTHpX6SoKm2mpSwmtBwdYJvdn+I3KSiw7KWlH6QeoWHfeKK77C4xaCNi4KhtqV+zbnmiX+NkYuSnLOpnaWMmYKBm6GViYmAmnh3fX2Cd56+wrSlkZKLjYOMh3eSfJWqume/db5tvayqgYyquKGQeJW4spqeq6akfnJwdXuVf39v4KmId2yK3MvCy5+W3diNkJR8cYOGlKvBv8NpuqxmbreKjZSYhrh7kYyNg3Tdcnd6gtJzdZWkiI96f4eB3dx9i5iOfnx/iJmAvLmzbM9wfXhybmZygnOIbXZ1cLNzeYhsbMWptLxqb27AeHdxZL9xi4x0a3qDhHBlZrqkn7PKtr9tdmy1a25vdXN0dW54fH14foV+b3Bwe4h9f4eHfXVyenPTz8a1b9XQ2b7E1ty6unB0eJF/fY2Uj46AkZCclZCgqJuGdnJ6eJOAoZCOjpGYlJ6hpqWdoJiQlZCUl5ugpqKhlpyZl6GZVVtcYldXV02VjmbWz6HZgIJzb4SIm4J0gYeShH1tc3p2c25n1tXExcnB1dh328zbv8HYu7/R1Lagrauyu7upoo2Gl5SLhIb4gv6LkZCQh/2Nk5SHkJOUg/mGlpiK+dzrgaOApLXW3q6jpIqBlsmzrsGgjIyrxH3cfoORlpOPeX+UgYaKhMCtsr6pmtxx1nFrcHbHynzFas7I2HKCd393c3jbx6e+p7yysLmsc25wa2XKcntugXlqY7u5aMXFtLi2sLaxrLq8YWtjaMK7ZmZlt8PDp2hsaF+1uGJfbmtzcGlti5iAlVJWVlKOb7a5cIRtboBtmI2ViduMl6C4s5640sxqzmR/ZnJ1dXtnZr+b48yx0oKixdCslpy1tcGfkaLDf4iWrLnIt7hicGSdcHpvaJ+AZ3NudGdoZXR9gHufo2ZscGxofGlra2ttbHtyeGx0d4N5j4mBiXpswL5sZ5mqxGRvb3SAcmVpa8Shumxze4CBg4KJgHp3lYqBentth4x/cIt/fYWTi317gI2LhIR+goKMh5GBdnRxeXeIgXSBgW55hXVvbG5vcnyAiX57eK2UiJm1nZCDkpGbm4+GlbDBqITVw9Px1dJucIGKaICKinyBhYWCf317dtNyeI+Rjp6XeIOLmJ6Aop+WkpaHhZKGkJ6sqaCYmpSjlI2WkYmBj5KCh4mRjp+Wj5SXjnlteImQhZGarbNqaGd5f3RxaG5mb2a1o5ahl6iwqr1puWVkZFp4fYN4eHJvam9mabVjv2Gko6WXnZ6LiZycl5+epIWMlaJfr6+nrVpZrJxbmKpcYV5bqV1bXmGAp56apZiOjoN9hYN4dnV5h12YoouBlZCVsp2lqpWvXV6WnbGptmanc45eWlqcjZuhnop+h56dnZu3qKeslHOBi5iWgn6Uj7hfZHRmanF1xZqZs6ONiXiJeIGBeeCE5qOnzbCjoZepuLSSx7bgfneDh4KGjaOakZiEjHl4jJKHcXmAjHJuc3V4co+traGXh4Z8fXl/fGt4anqLlVOlZ6Zdr6CbdoCZoZGCc4CdpZCNlZKQcWdgZW6Bc3Zjxpx0a2F0zb23uYR9ysh/fn1qZHN5fZGinJ1Rm5FVVZd5gIaHdqttgIB+dWjIaG1tcbdoan+Ic3trbXZ0ysZteYR7bnBxeYQFfX19fn2OfgF9hX6EfQR+fn59hH4BfYt+h30Efn5+fZ1+hH0Bfol9t36If4N+hH2Vfoh9AX6afQN8fXyFfQF8iH0BfIR9g3yVfQJ+fY1+h30Cfn2Efgh9fX59fn19fYd+in2FfgF9h34DfX1+i32EfgV9fX5+foR9hH6CfYt+hH8Efn59fYZ+hH0BfIl9An59iX6CfYR8ln0Efn5+fYR+gn2LfoJ9mn4HfX1+fn19fYh+g33CfpN9hnyEfY1+AX27fox/iX4Cf36PfwR+f35/kn4Bf4R+B39/fn5/fn6EfwF+hH+QfgF/jX6Cf4V+B39+fn5/f3+bfod/jX4FfX59fn6Mfa1+BX9+f35/m36CfYR+hH0Efn59fYx+BX9+fn9/hn4BfYZ+AX2EfgF9in6CfYl+AgIEAIDYhPv8gY/mlZCM6ZKrqfOIoYrV5YX5kZ2mnpDX7/3J2dzO6e3+i6uZj/Xb1NuI9e6C6OXjpcXNysS5u87s/vbb0df47f//7YaZn5SNh4KOhurUhI+Qg/qFioXe6oGOi4KPiY6HgI+RmqaIi5iivsvAy8yvmbK828i1oa+yvMDJzYDl8/eC9eDf0tri49vK2eXv7P2Cg4CCgvPf0dHf24iKh4qDlInkoveqlLG254iGj5iko6SuuaqmmK6+zb+/l5Srk56h7OiKlYeB+Nf92oGB7oPdjvq7o5+3ssqhk6aovOSmo7WutLra6Ir2pGKrp3uBlKmron1vi3+Tl5xsXXiGy4DVxOyzoXx3i4aWprmFjZ57mYr4g7Hh3J7/7/ydlZb0kdl2kJjF1OH6hLWhko+NiYadj6m0qrOPkrq2vaKqhJukibaxtr62reSnh5L8jY6LgvKA+fnOv+WOhtmDksjV3eDy5u/0w+j45tTX7+SzzMDc/+PXhZeG8t3IkZDq0LeCrYDd2teJj5SYxI6fzLTz/OKN5ruY/sXXzruinb27q9iNk6eEn475lJKS/samy6Z+n8mmv4D1g8/B2PGuksTV3M6vttSstu2Ek7ycyLzg4sTHkI2Kl5L2+aexvLaUnI+MgIXygqO4wNrqgIOuoIuUpJSM/ZKMjYzZjL7a5uyQrZOLpoCcipKeiqqTrpedutbRz77O08HoxLi8z77EybzEyqiUkpWeqqimpMHVz77Cwre/0rqlqK2xzsjZzMarpJi2ppiaqJ+FkaOYnJmP9eivguf28o+bs8eB6/X7gvys9KWrl6yhtrrl2YmjoImFlIaNlJqzv52CgfqMkqfGpoqUsrGqwoDU2dPBvtrg6ePY4/L6x6fFudLbzNG9ube8x7vH19jn5MPMya+QkZm3wLe40dfq//qdq5SKkaCjq6KilILz3MvKuNjqwdL79/mZr6eXlIeQhoXv3+XMrqOlxMTFzLC4mKO8o8bOmsKzk63Ooczn0c3h95OOjpWNm4uMoZaFhYDqy4C/29Xr+eyzy8yvr6jM5KqOybqnlJyXzou5uqiwrNrnh4b0gIOOjpOE2JyT/9bV27Wej5y+2/z5ioOI0qPGopHCtLmTi5/R8PCAiPWYlqGzj4rZhfXGgsy2rsCn5p2Qitayg3Nwvareyc/e9fKbob+ynKHAvqOkoLeupZmdo8HCv4DOuOz1jYWQs9HJurW4trCzrpa4p5GWp9/2j5mehc+yu76lpZabp46ZvL3q09Dl7cbAoayvoYDLs/KE8IGaor2Xm4vYi9HPj5Di9bfdxIvti7q9v9XZjoX0wOHizLaDwNGLj56C84eRlYunjJKQmLbP062Xmdre8O6Kh6CZhJf474DEduPjdH/RhYJ70IGVldR3jni9zHfffomSioHF2ue6yc661d3sgZ2KguDLxMp63tp319LOm73DwrqvssDc5uLLxMnk1enr23yLjYR+d3GAedfBeYCAduR6fXvM03WCfHaAen96cX1/h5B5foWNprGkr7GZh5uhvKydipiYoKWnrYDBy81qy7u5rbW6vLSlsbrAvMlnaWdpace0ram2sW1ubHBodnG5itqnlqem1Hh2fYSLi4+Wn5SQgpafrqGdgX6OfYSN4NZ9iH13587p0Hdy2XfLgOi8qKO6s8yil6amtNKipLaorLjQ14LooG+8tYWKnayuq4d6lYifm511aISP0oDZx+e3qoh+lo2arLR9haSAm4XueZe8tovj2OCLg4jYf8R3mZzCzdjrdJyOfX19enmJfI6XkZl+fpyaoJGQd5igg6ius7atp9CPc3zTeHt4b89w2tq4p8V4dbxxgrS9w8jayc7NrsnTy8DB1cyftqXF38O+b31xyr+ye3zRuKhwj4C0s6xsb3F1pniUvabR2MmA1ayU+K+8trmamq+yn8F6fopwhnndf39+5rOb07F+ma6ZrnDedrmtwNKfh63ByrefobiaostwfKOBtabCxrS1f3x4gHze2I6Rl5qDhnp9c3PadZqrq8HOcHCTiXd9iHp123p2dna9ea3Iz8p9mXt1h4B/dH2EdIx9lIOPm6+tr5+rrZ7EoZubrJ2ippiiqo2AgYCLj4qOi6SwrZugnJKhsp2OkZOVqqa0q6KUkomgi4aFlIx0e4Z9hIN9082aetzr6IuQp7l40efodeSd7aewl62ftbHSwXeOjHt1gXV8gIeepYlyd9Z2eI2wlHyAlZWMoYCrs7Oio7W5vLevucfRqY+nna+4qrCfn5ucqqGnt7LDv6epqpV8foScpZ6esrjJ2tWEj3x0d4SIjoaFenDZwrayobXHpbbW0c12iIJ4d3F0bm/Mvsi1npKXq6+uqpyjjZGtl623h6udh5W5lK3Cp6m6xnNyc3h0fXFygXhub2zFroCit7bBycebra6XmZKpvY98qp+Tg4+LxoKeoZSYlLHAbWrCZGp0dHhvyYR1y7y6t5uKf4qkvMvKcmpvro6mjoSnm5x+e4uxw8VncM56e4iff3q+ccqsaa6hm6ya24+Khs+0iHZ0wa/TvMTU6umMj6mejI6ioYuPiaGWlo2NlKRsY4B4kMjSe297lKihmZeZmZKXmYChlX5+i7e8cXmBba6VnaOMjYKEj3yDoJ/Dsay+vqOghoyWim61nc50znKGiKeFiX3He8TDgYDR1JuyoXfUepmbmayuc2rJnra1p513uMl7fIty0HZ9gniReX9/gJyvspODg77C1NJ4domGc4je2YC3a8/MaXLBeHRst3KFgL5rf22rt2vPcXl+eXS4ydKtvL2wx8/adIt9ds/BtrxvyM1syMO+l7jBw7mrrLzV1dXAvsrYyd7g0nSDgn53bmZ3cMq4cnZ2btl0dXXDwW97dGx1cXNxaW50en9vc3iBl5+UoJ2KfYuMpJuNfoaCh4uOloCora1Yq56elZqfo5iKlp6fmqRUWFdXWKWVkYyWkVVXVlpYXliXetazqKypym5tcXV3d3+Di4B9dYKIkYqFc3B9b3d+1c92g3p35Mvg03Ruzm3GeOjHtLG9uM6xpq2pr8SopLevq7jNzHLaqY7+55agqa+ztJ+Vp5uqpaaTiJ+t4YDm0+bFv6WbqaSvvMd9grSasoTrdo+noH/Z0NyBe4DUeMeOqqrR2OTpdJGFeXd6dXWDdoaJiIx0dY2LjYSDbqChj6y1tbytqMeCZ23AbXFsZb9kx8epn7BpZrJqeK6ytbfDt8C6orvAuq22w7qZq5+5z7SxZGxkt62ibG7Br6ZpgICamZVXV1hVgmd9ppS0w7h0xqKP+6Orq7GXl6qvmblycHZjc2vJcHBux6WR5smBk6KVo2TJbq6hsr6Tf6CzuKqUmqmSnbhnbIhspZqvsqOqdHBwbmvIwXl5eYBzdGltaGLEZ5ikpbW6ZWSCeWtxdmlnxmloamevaqK/vbJsg2tnc4BuZ2pyZ3htfnmAhpKSl4eUlYelj4aEl4iHjoCGjXtzcnZ8fnh6d4mYloaJg3uInJWDgYGBjY6Ylo6EgnyQf3h5hX9tbXVweXl2yr+cf+ry7IuPprFvx9Tbbtaa/MTPsszG5NDctmt+fm9qdGlvdXyOlHtqbchoa4GahG92goF8jYCTnJeLjJycmJaTnqWpj3yPiZKVjZGIiIWKkouUnZeppJCSlYdvcnmKkY2Qo6i5xb9ze21pa3R2e3RzbWTCsKWkl6izlKa1tbJia2lgZWNkYV+5q7OkkoqRnaCgmI+XgoacjZ+ifZiLfY2qiJyij4+boFxdXF5gZl1cZmJbXFmmmYCPnKGqrKeLlpKJjIaRm31wlYyGfYZ+xHyPlIeLiJysXVelVVhgYmZbunVfq6iooo2Dd4GOqausX1xgmIOPfnqPh4NucH2ZpK1cZLxpaniYe3OnZLOcWZ6VlqSY34mFhNq7mY2H67vJusDP3t2AgZWPhIWQlIGCfY6IiYKEipBALIBDhLjFbmRwfYyIhIaIg36EhW+JgHBuc5WUWWJrY56Ik5V/g3l7gnZ6k4+to5elppOOe36CfWetl7ViuGd1fJF6e3G/dLO2c2/ByoKPg2bGboWDgYuVX1ighZCUi4VrtcRtcH1qw2t1d21/bHBucYSSk39xcq2zv7dqaXh2Z3bKxRZ9fn19fn59fn5+fX5+fn1+fn59fX59hX6KfYR+hH0Efn19fpZ9iX6CfYR+Bn1+fn59fad+AX+OfoV/hn6Hf4J+hn2XfoJ9hH6EfQZ+fn1+fX6VfQZ+fX19fHyefQd+fn19fX59hX4IfX19fn5+fX6IfZZ+in0Efn5+fYR+An1+hX0Ffn59fn6XfQt+fn59fX1+fn19fYV+hH+DfoV9BX59fX18in2Gfgl9fn5+fX19fHyFfQN+fX6QfYR+hn2FfoJ9in4CfX6FfYl+AX2EfgJ9foR9zn6EfYN8hH0Hfn19fX59fYl8AX2PfgF9u36Mf4x+iX+gfo1/mH4BfYh+A39/foZ/A31+f4x+g3+OfgZ/f35/f3+EfgR/fn5/hX4EfX5+foV9AXyHfZJ+Bn9/fn19fZV+hH+ZfgV9fX1+fYd+CH1+fX1+fn19hH4BfYZ+gn+HfoJ9hH4BfY9+hH2GfoJ9AgIEAICfqKaIlJn2lpKYrqeszbOzv46UlIqAyPOjlq+aiNTW7OfKjKqfjrGRkJDl4PmZk5mNjvOBgIff3r60wM3H1ueH5fX5/4CGh4mbsJKSm5P6/JGDhoehs5imtbW2mJqfrrCtnKmuraivwLWvvbi2sbW0srS+y9DMu662ztDQzdPFx4Dn39rS3t7W4vfqzubk2+bU28/T5O/x6+vr84iIj4uK/saV3ca119T6haa2m5eZmpGaj5XK2ru5la7N8tq6rquclprix9Pc6P2KgICLlJKEko2PlJWTh5eJkoeAhYqGnYiOhp6LgZuQ1NqN/3O1fsqczqy9s4yRr7GooKN3cG2MmoCzv7efhJOCnaS7guunlemE5+b/6ouclfvZ9P/U256FyLOz/OXl/O6AhqSjsK6bkfyXoIOYu8Onl6OWnu2lzsKbiI/BtbO19/yB5PPshI+UrcWTmYvi+tPQ1uXg7NfcgduH9unY6IeE/NHB7/HH4re1w/WEi6WY75zP08HLvpbDj4CarP6x44+vpv6otJvU5uTTl9u1jdWwot/IzaPJvsnd7uzn87Cjx82yoryCpanWvpSUm6vxiO7r5YDbub/egfPp2M7G1ubngoT/3I6YzPjmjKGYvpGgq5GRppyn1q+mk5mgi4L7iJ+ShfCEiouJjqGglrCd/4PSpszXhYGMqKeXroClkIGUh4eXnYTy24ypr7nLwL22tr67tNO+w6u4scLLsZOuvriyv867p6etwt7r5rqwxsbD3NPi9vHj7d3iwbKpl6CL+Obl84GFmpKM6MGMzPfs7KC5vMfJobKsr5CHipaw08/PwKyfrMe6hofyiI6ut7i6vKb9xuWmrcfOxrDDz4CtqL7N4LzN2c/n6fzv2MK/tbuywq6zrLG5qqu/u7W8uq6qqrrD08C8xbK7vMjl2t/k+o+Wk5iMm5KA1M7d1drK3dfplvL/m6PKp5KA49jc0bOuvsXKm7DtvpyvwtK1rb+vt7rTsaeCmrW6v8jU0sPb+ZuQnJiXiJakl5ejju3F34Da0r6v37yiq8qysLXG5aafr9LMu6OytLzPsLrVwq3EwszO2/mSrpaa7PeU/Yzj2szB3IWD9Lzg/YzpqJGbpaTV88uXmdHT/dXbxNzrkq2KqYm8nd603pWVnpCH8KrFoYyxdMB7k6KDl5GfjJSEzdKvmK+nmJ3Oz8Kgk/2VrK+uooCrkaCaqa2ksb29s8XFydOwl4y31ci6v4iKjo6P07i5tp2qpZWQpqOlnpi8yOrixNO2+JGjhoDQtf+J+YWalJKen7afhPS798aEkrqk9fr6mLqHm7PLzLyS0sLUzNarz5STlpuNh93oqbG+zcTDk62qqaCXmvuI9ICD/5WSl6+Zo4CLk5F4hYbdg4GGl5GTr5mfp32ChXx1uNmPhJmJe8DI2926gJmMf56CgYHPzeCJg4p+gN93dXrN0LStusK6ytN6zeHi53V5e3qKn4GDi4Tg4oN4eXyPnIeUoKCjh4uNmpyXiZWXlpGXpZ2Wop2cmZycmpqirbCtopeasLGxrLOlqoDDurawubizu8rBprq5sbyts6qrusTHvr26v25vcW9tzKGDzLywyMrod4+bhoOFhnyEfIGruKKggZWsxbeflY+EhIbRxsHI1uB4cHF7g4N7gXx/g4OFfIR7g31ydn16jXuAeo58eIaBxseC7HnEhdOj17C+t5OeuLiupKaBfHaYoYC5wbyiiqCIoKW0eeWpmeF749fu1n+LiO/S6ufByY5/u7Cw7N/Z5ORzeJWSlJmIfeCEjHWCm6iNgY2Ch8+Nv8Oah4y5r66z5uJxxdTPcnyApLqCfn/M2Ly7wMjJ0cPAbsBz08y7xXJz4bu41M61xaKpsNJ0c4Z+046zta7Hu42qd4B/jdSRs22Ffs2NoYm4x8S2fsmkgseel8myy5a/rLjFx9HLzpKNqLGXj7KAo6vDrY6LkZjLdcvNxWzBrK3Jb9PHwb6uwMjIcHjcw4aQu9fNeYV/oHyKknx6hYaHrpSKfoGEdnLddIx+c89ydnx1eIWIf5CF33G+l7XAc3B1iop8joCLeGx6c3SAiXXfzXePk52pn52WlaOZl6+doYuWj5ymj32QnZeRoKiZi4uRqbfCvZyVp6aluq65y8e+wLbCpZuTiYp249LD2HJ7joJ+1LCEv9nM1omenKKrhZeNmoF5eYOXt7O1qJaLl62gdnnWd3qWnqGgoY/brsuQlqyuq5etsoCYi6CmvJ+tt6/Gx87ItaOinJ2Uo5OZkZedlJKjnpignpOSlKKntqWkqJigoqzIvL7A03h+fIF1gnpstbK7tbyvyrnHfMrSfICcg3huxb65rpyjr7C6lKbQq46fq7WgnKqfp6O7n5Z5i5eYqK6yq6GuxHtxe3p7bnuAdnyBd8itxYDAsaSYxaCMlKqUlqOnu4+KmLGtn4yan6m0naO0qJWro6ustMl2inZ7x+OG0nS9tbKnvXJyzaG4znLBj4CGlJq1zKaCibOx0ayxobW8d5Z6l3OTfbqXt4SGjoZ/4pu8pI+xeMSBlZ58h4aOfYR2sqyZg5qQgoOnp52CetaAmpSWfYCIc4eEjo2GkZuclqSio6+UgnuYq6SXoXBucnF0sZuim4iOjoB+j4+SjYGmqcC7oKqY2X6bdW7DpN5323eFgoKMh5eKd+Ks4rl2fZqJ1uDbg5t3iY+pqZd9uauyqbOSuoF/g4Z4dMTKkJijraiof5SPjomChNl31G9z4IWAg5iGkIB7gIFueXnNdXR2f3+AlYWIkW11dm9rq8R+dYR3b7O6ys+zd4p8cop1c3O8uMl5c3pwc9RwbnO9vq2ttLuywsdvu9PY2W5xdHODlHp4gnrT1HpvcXSAjHyIj5OTe3+CiIiFeISDgoCGlouDjomMiYuKh4aLlJiSj4WImJaUkpqOkoCmo56ZpKCcn62kjaCdkpqSl5OSmqmtpZ+Ul1hYWlpYpYZ60sW7w9PgbX6HeHV2d210b3SUn46Oc4KUqZmIgoB2dHS9ubi/yNJwa2xzentydHJzenp5c3lzeHNpbXVzgnJ1coR3bnZ3wcF23Zn9lda33Le7xrG6ycbFs7akm5avuoDM1sq1pLShtLfLeeW8s+h55+Dl1HuBgejP3t7GyYV5v7q76eXf5eJxeY2KjpCAedh+hnJ8j5mDe4J6e8p7tuKbj5a9tbS63tdnvMe/Z29zpbZ2b3O9xrGytLi+xbW0Yq1lu7yrr2Zmzq6rv8CntpifpMJpZHJvw4qnrKHPy4uia4Bze8Z8k1ZmYJ92jXKmsLCpbbuefbOZlrup4Ju4o622tcO5tHh1g5KDf6uDm6KzoY2MkJC6Z726rWW0n6G5Yr2wtLGdrrO0YWvIt4SKqcm6bXNzi296fm5sa3VykX1yaW9vaWnIZ31sZbtkaW9oaXN1b3Z0yma1lKyzaGZodHVpdYBzbF9qZWhxeWnSwG19hYyWkIyFgo6GhZiFinV7dX+IfGx5hYF8ho+Ee3V9i5mgnIuDkJGQoZadqquopaGtk4iFfX1u0cK2wmtsfnZyyK2ArcTAwXiKi46TeYN8iHtzcXWHpJ+gmYqAh5mPbHDHbHCIjpCQkYHHpb1/hZeYkYmXnYCEeImXo4mVmJWtqq6pl4uNiIV/in2Ff4SLgYCOioeKi4OEipGUopaQlYqTmJ+2qautvmtybnRoc2xhpaKrn6eZsqGqaKuxZWZ7a2Ngq6igmIuYm5+pi5m6m4SRmqOQj56Ql5Sqj4dwgIiGmZ6fkYiRnF9aYGVlW2ViX2RpYaeUqIClk4eHro1+fo+DipORn36AiJeVh36IkpefjpWdk4uWkJSZma1lcmVlr9Z6sGKmoZ6YpmNfq5Ces1+nhXh6iI2fr4pzfKOesJaXjqKjYYZ0iV94a6KIo3+Bi4F92I25qpu4ifKQmaV1gHyEc3RrmJaPe4yFdnaMkYx1bMl3joaJaoBwZXd2fXhydHuAfYiKiJKEdW6BjIZ8h11dYGNjooyNhXt/enNzgYaIiHmYl6qokJWMzXSCaWa6ocZqymh0dXZ8d4J/cM2p1K1ncYJ2usXLdoJpdnuNjH5qoYOMkJl9q3BwdXhtaLe9gYOLlZKScX5+endydcNpvWJmx3Nyc4R2foZ+AX2PfoJ9hX6FfYh+g32FfgR9fn5+iX0BfoR9in6Cfcp+hX+DfoZ9mn6GfZ9+Bn19fn19fJ19AX6EfQF+hH2DfoZ9gn6IfYh+AX2LfgR9fn18iX0Mfn19fX5+fn19fn5+in0Dfn1+hH2Cfot9hH6FfQ18fH19fn5+fX5+f39/hH6EfQF+iH0BfIl9hn6LfQV+fX19foR9AX6IfYJ+h32UfgF9hH4BfYp+An1+hH2QfoJ9uH6EfYV+h32ZfgF9iH6Dfbp+iH+JfgN/fn6Gf6V+jH+nfoR/BX59fn5/hX6Cf4R+AX+Tfgd/fn5+f39/iH4CfX6FfQR8fX19lH4BfZx+hX+VfgF9hH4FfX19fn2JfoR9hH6DfYl+AX2FfgF9hn6CfY1+Bn1+fX5+fYZ+AgIEAICqxLinnYaJ9ouXraKXyt/kmqu+rY+T7ISak4HzhPGP9Nz7h5WwppGamamYlIyM5oqNm5mYgZ2I9/Xq+ImLgfmB/YqChoSGjYmRj5eQqJ+ao6nHwrm4q6i1r7fLy8m2t8i7rbywrKWcpKudqrW2xMrQ397Q0MnFudDe6+j0+vz61YDK2bi0wsO+ubvGzcGyt9P7hIHk3fjt7+Lu+vmA/NjUqs3ahYaKi4eVq7ynuLiknqKYmJiev7y4vMnExsvGxLm4rJ2WpKeClZayrpqQmPiNnIqUmZD4h4mKkJeeoayorpiptqmIiJ3zhI6Vg36VscS14uOr1c2twZuPw+zQxZvSxoCzrMSUlqGKnq7HsZKvwtSFgYyMj/qLrojm6YeenKvSxtXD4uqLhNyJ+v+yqIyal/iGifX9l4mG6Njr//mclejRyXiat7v5k5WKhOH+hoXhjImxkZ2NjIj127/PxdDlg4Hm8vjT+YmP/uTTyPOS3aaiytCGgfDT0aapzI7Ze6+u6YCakKLT3P+NmKSggOrErYrrpd2rpJ6c7LXKk4231aDH1OT6gIWEoqe8r+eZiNuAv9q/6aezxLefiM7Ny+bw897pk4Luju/sg4iLnPvX9+/w842MnZiA/6K3nJOYqabW0MWnkPWYh/mBgoulh9y0tfOQqseWgb6I/LXxgeHS2PiRk4CJk+feioeYloX10dHWh5+Tl63BqaeTqtHHr6WaoKGfoZqQlJqzqqqmtrCruMLCwri2q8nI0tLYzM7b4tHX0+nFusjJwcaJjaezmqW/05vXnrbY3ICcmqGzt73SuLitrbWxmqSnoq+xp6unoqWww52bsbq53cjEy+DBvK6xt8K6tYC9ur7Swae/yMfBxrKwqMPovL7Ax7e3tKqjkJWTn6qgn7G2s8DGu56pq7O2sLjLxsPPv8X1i5GSjfns997UxMTPz8fwgoKlu5zz4NrD1tDZxNrc0uPLv9jWyrO1x9S4oML1qLC/vKWQrLGvmp2hvryuuuj8jZqNkpejlIWPgPPF3YDblqG5r6urnJrMx7WdibSSq8fYtKmYr6e8477S2cK0ur/Ky/GMoo337s+f1onnvcDH9d3p4rKsyt2nmaiInbmsk8aXx7rRxdS9vN/Y7dfR7JOYmM24n4Pqhp7Z28KbpZm7ha3Q1YSGhu2CjqW5scWQsJe2wK6ml5iMif+iqaCXloCrqqedkJqqoLC91efO1rKut5attNjP2OvZycbAycC34ta/uLavp6mtq8W+p7q/qKCNgIaCgYOD2Y2dhZGyqZqalZyvl+uqqrfr5pSY7anCrMu4l4WTkJim0sPL1sGPxPKOjae3r5iNkYuZn5+Ug4iglICjiPGKsb3BopujqbKtooCTq5+Si3h43nyClIuBqrzBiJalmHyB03WIg3bgd9yB3M7nf4iblICIh5WHgnx/0Xx+i4mJdo564uDT4Hx+dOJ15Hp0eXd4f32DgIV+lo2Hj5SwraWimpihmqGysq+goa6jlqGXlY+GjpeJlJybqKuturivr6qona+8wsLKztHSsoCpt5yWoqSemZqhqKCUlqnKZ2i8s8e/w7nAyslnyKqukcDHdnd6eHaClqKPm5yLh4p+gICGpKKeoa2loqalp5qckYZ/jZV1hYKamYh8gt2Bh3qAg33ednh9foaIjZOQlIaTmo95fI3beYGDdICWs8W54Nyw09SxwJ2WyevSyqHQxYC3sMien6WOobHOuJy3w9F7dHl7fueApXnQ1niQjpPKw9i83NuCfMx24OKVj3uFhuR9gODmgXZ108XQ596Dgc7Gy3SXsLXkg4R8ecvedHLNhX+ZfYJ4e3Pexa/AsbrDcnbN0djA0nR93tLEtNR8yJugurRxd9O/vpyYsn3HeqGo0YCAeoOpqcRpc358Z8arln7EjcahmZqV5aS2joapupK0uMrSbXJvgoaWk82RicVwrMev7Zyhr56PerS3tszM29bJfW/Ses7EanN1g+DG2uDbzXV3iIFy4YaahXt8ioaxqaOKfdd+ctBsbHeMc8SppM95ip98b6eC7KPOb8W3u9h9fYB1ecTFdHB/fHDRvbm9dYx8gJGkjZJ9j66nl4p/g4aDh4J5gIKYjZCMnaGVmqGcnZqXkaaoq6uyp6e6va6wr8qmmqSmorN3fJOYhY+pvonMlajCx3OGgouVmJuxmZuRlp+bh5CTjJubkZSRjpGYq4eFl56fvKqmrsKjoZOZnaWemYCinqCypY6hq6ukqpeYj6bEn6Gjq52dm5GMfIB/iJGIi5idnaaqoImQk5yemZ2vqaWxpanQdXt7dtHI0LuzqKqzsqjJbG2Ekn7JvsClu7K7rL+7uMC1q7q4s6ajsrWjlKnNjpWioZGAmKCdj4qPp5+Tl7zLcHpyeXyDemtxZ8ytwYC8gIydlZKViYSrppmJeZuCla62lZOJmpOmxau3vaWZpKqrq8Z0f3TKyradtXLAo6Cpy7vLvJqVrbiRhpV+i6WYgqWFrJ+9qKyfnbOzxbe4xHZ4erKgj33kfI7T276dq5vCiqnGyXt8fNdygZSelaaAnomcpJOOfoF1dOOOkYeCg4CQkIqFeH6Lg5ebqrimspSRmoSQk7KwtcG0qqmfpaGcu7yhmpeSj4+Zlqakk5ykkIV3bnZvdXh1yXaLcnyVin6DgoWUhd2mqq7gz4KI1JKhj7CejHN8e3yOsaWttqN7rdJ6fI+dl4F9f3iDi4d/cnaLf3KQdtV5mKKmioWOkpuXjoCAlImAe21syWxyf3dujJqidoKMg25wv2t5c23Rb811ysPZc36MgnJ4fIZ3dXBxwHBxe3l6an9tzcnAy3F0as9r0G9qcG5tdnZ7eHl0ioJ8gYabmpWTjYuTi5CenpiQjpmNg4mEh4F3gYZ+houKk5ORmpmUlJGPh5mfpKOqqKu0m4CWpI2LkpGOi4uTlIx9fY2iUlSclaejp52fpqlVo42WhcTIcG5va3B7hJCBiId4d3hsbm50jo6MjZiQj5KRjIaGgHZve3xodnaMinx0ds50e3J0d3PSb3Bzc3t/gISDhnuCioRzcoDMcHh5bZShuMu/2OK70+DDybWwzezj27PSzoDLxdO1uLaiusvk1LvM1d15c3N2euJ/mHTNzHOHiIrLx+DL3918ect13OSNiXaAfdx2edzffHFwycDG1tZ2c8G75oKetbPcfX11ccHPaGrEjHWFcnNpa2vKuKezq7G0Z2m5wsWwvWhxzsC5pb5suJWWrKNmaL6vr5SUqHO4g5ypwoBxanSKiJxRV19bUqmVfm+rfLSZkZiU5JqsjomgrIqvr76+ZWllcXKAgcGPirhloLqn9JSWpJeJeaasqr27x72zbGS8briwW2VrccW1w83Js2VodnBoy3GAc2poc2+RjYt2cMNqY7phXmZ5a7ilnrxqd4NtZaCE7pe0YrWnp75wb4Bqa7CwZWRvbWbFsa6yan1wcX2Le4Nwf5SQhXpvcHFvdnBqdHaCenp3h4qBhIaFf4ODfY+Sk5SYkI6epJmalauXhY6Pj55xbXuHd4GYrYLIkqC1uWh6dn+GiIqcj4yIiZCOfoSJhI2NhYeGgoGLmnt5iY6NppeSl6WOjYOHi5OMiICOi4yckX+NlpeRloSEfI6phYeNlouJiYJ/bnBxdX54fISNj5ibj3mChoyQiZOdmJGek5e6ZmhoZLexuqOekpeem5OsW1lpdGiypauTpZ6jnKaqqbCro6mqo52XoaOZjJqxg4mQjoN4kZKQgoSEmIV6fpejWV9fZGNmYVdZU6uYrYCidHyMh4OBenmTjIN6cIZ2h5ueg4R/ioiYr5idoZCLlJWUlaNja2W0qpyioGGolJKZsaayn4eImZ+DeIZzgZSIe5B2koufkZKKi5earKKapmRnZ6SRhnjVdoLL1b+isKPEl7PCwnR1ddBvdoCHg5J3kH6IkoODd3Nqbdd+hHZ2d4B/gIB6a2l1cX97g5CNk4R8hHN6epeUm6OdmpmPj4qKnqKNhH9+gICLiZaYiYuUhHVtZ2tna2xqt2p2aW9/eHF3d3uDdcefo6XIvnNwxoCIgJSHfWpvbGl1joWPnIxspL9pb3+IhHBsb2t1enduZWh4bmZ9aLppgoiMd3V7f4SDeod+AX2OfgF9hH4HfX59fn19fYx+AX2IfoR9Bn5+fn1+fc9+gn+JfgF/hH6Cfat+AX2GfgF9kX4BfYR+pH2FfgZ9fn5+fX2EfoZ9Bn5+fX59fYV+CH1+fn19fn5+hX0Ffn59fXyFfYR+Bn19fn59fYd+h32CfoV9gn6FfQF+hX2CfoZ9AX6FfYZ+hX+EfgJ9foV9AXyLfYd+hH0Ffn19fXyOfQZ+fn1+fX2EfoZ9hX4BfYx+BH1+fn2FfoR9hX4GfX18fX1+hH2EfoJ9hX6EfcF+hX3hfoR/i36Ff6t+in+nfgl/f39+fn59fn+jfoN/hH4DfX5+i30Efn5+fZF+AX28fgF9jH6GfQN+fn2RfoJ9lH4BfYt+AgIEAICrtc3GrJeak4ac6pacq+ig+/Kgl5HgwIaktZWdmquem5SGjaqin5aM84GlrpGUjo2G84OM/KmYg6ON8Y+hoYT/iIiWmpKD9I+Fi6CZmZS3uKGqqbWyvrvBxMnJwMjDv7O5xNjYx7jR2tTSyNPw3NXm6Orr2tPb09fgz9Px+/XZ2YDh5uvc3dXH18Gsqri6vN7c2eXm5t3TztrW1riShoT27pCirK+6xruyraysr6GoscDBwLCgssfAxdm+vbqqrbGWoqWmrpSVgIqXj46Si4yinKGflYKCmIGcqKCOqbvG58SKnYSOppych52Zkf35jOyA1qjS65qQoNeNnOXB8JXRxYDD0ZGRloaTpKesgN2GkaCdiYmag4TVgYbNz+XxkNn18qzTx4H7weGQzcf1hYyHgvmUk53794bglpefs6CXmIbUmpfG3/eLiOeF9NSZ7fKOrMbWw4v/lZWF/e3y+u707+Tt+IiB7IWKk4uL59/d2ODx2tOD5cLNwL+5yd/fpcXR6YChlai20MfYkJysvZnSq7KA+veg5YrO0MaA2I7f+66qqtbzioLigY6x8OuIxfH34drS3N65tvecsri+xd3ZgY3e+IqD6vjk7vD/j+LE+ICYmIPkhJ+VhZOko4epncnJ3ca/vaKnk+PevpeQo8bBl4rW95OlkvWvlovNkoTc55SOgIDgi/HP6+Hg39m9s7bQ4/Hnj6mor7qdmqXAsbaOie3xlLSulpujq5qjpbSpvMjP08zRsJq+wtDGr6Wy1t3U2NbNuKe0v7Owu62xtazBo5CA5OTb1uSDgPHj64WSlI2KkJSQjZCQifPOzr/vhZSWgIKHhYeiopqfr6Gww8y1xcGsnICVnpWjnq+3t7qemJSXmqeomKiprMC/p52Q/pKHi4P2jqSjqambprK+uaCyp7atsKadppq25eDY5uzf7u343ubl+YTa/pCYl/vS1tjX19DN8vTXwLa+v82omfTtmZ2AuMGxnLvFlq6Zq6+Whqq5zMmossTJsNyUoaempaeN6pjxx4Cfwu+inKagnrTM28z8hOrXwJ6qoJq21MXk9M2QtOLe1c3tm6mVlpD/jYTI3eTOmLbgvLW7vbSXqLqYkZmKm6avoaqvx8KUpKSr5dnO/YTywrKyh4D9y6be9M+RoqeQv9SvrfXnysbJ5eT6j57DpqCrwYyRlqefsoKXk6ebmpmPm4CKlaGPopOittzau8SuvbnHvaWoxbfL1sTqw6ytrqO8vrfx6J+1zsnBwNa9tqaE8JSFs9ucl4r+/YmxppSdoJOZtqiXh9+2ppfM342dicWfxsKQ152njJWc59K61eHIp4uRop/Gs8XCmpmEn5iSifeygez+mo6iqp6euJGenJCoqoCUnK+ploWHgHaK1JCWqNyQ4dyPhYHKtXmRoIOLiJmLiIV4fpaPjoZ+3nORmn+Df3943nd+4pWGdJB+03+PjnPheXmFiIR434F1e42GhYOhpJCWlqGbqaWqq6+xprKrqJ2jqrq6raCzubO0p7DKubTEwsXGubC3sLG8rbDK0su2tIC6vb6zta+ispyLiZSYmbS0sbm8u7eurLayrpl8dHPe1X6Kk5ScpZuVkZGRkoWMk56dnpSGmKymqbmopZ2QjJiHiZGMmH6DdnyFfYCFe32Jh4mFf3NvinOHkYd9kZ6jv6V5iHeBko6ReI+EgeTqg9571KjM6aOXpdWBkujA65jWv4DG05SYn4yaq6uqe9d9h5GHen2MeHfDcnfHutPagcLf9qvMunXlscyByrXae4F8c9qAgJPu4HfLgIKJoI6Dh3e/lZK5y9t4eMx52cKD1NV3lqu5o3jcgIBw3dbb3c7U08rR2HlxzW51fHZ70MnGvMnlwMB1yKuxtK2mtMLHlrG4yoCEf4yXq56qbXZ/jnmyj5py39qS4YTDxrhxyIXA26mgn8HQdnTHanST0euHs9/Xwbu+u8GhsPGPnKWjr8G/bXXCz3Nzx9nKx83bdMCs1Wx9gXLJboB9cn2LiHOMh6aluKGbmYmMfcvBrJCHmaqskIW5zHqJfNOejYO3fHTGzYN6cIDEet25ycHDwbukoKS7ytjRfpSSk5yEgY2gkZh5d9DVg5qTgIKHjYKKkJiMnKGnr6qokICjoKqfjouUsbWpta2pmIyYn5SNlpGVnZOgh35yzM+/ycpycdnO0nKAhXx6f4aBfYGEede3uKnXdIOEcnR1cnWQjYaJl4mYp7CaqKWVhICBiX+OiJeenKGIg3+ChY6SgpCRlKilkYx82oB1e3XUfY+OkpKHkJqloYqckZ+VmZCGj4Wfxr63xMS9y8nWvsnF02+21XZ/ftC0urm7ubKxzM69qqGoprmXj/HmipB2n6ybja+xhpyLnZ6HeZmlsKeQlqKjja52foWDh4h1xX3HroCSwNyNiJOJi56rubHVbsu9pomWkYeiuq7FyLCFnba9sbDHf4l3enTQdWmqvryshaO+n5+koZqFkZ2AfYN3h5KZi5OSoqZ9ko6Ru7GszW7JopaWfHfywqPS3cOUpKuOut20sevixsC80NPogI2qkpSXrIKAfo6Gmm6Beo+CfYF3hIB8gYt9hnmGmbCrl5qPoJmpno2Nppips6LFqpaWlYujpJ7KwoaZqqahpbOfmY5z0H90o7+FgXjk2neSjYCGjHyDnZGHd8yrm466yXqIfb2Ln6F8wYeOeYKHw7Wds72mjHZ7jIeml6ilgoVyh4B9d9ebctLfhXyMlImIon+Ih3yQkoCChpaQgHZ2cGl0wZabsdiD0M59dnK2qm+AinN8d4Z6e3VscYaAgXpzzmiDi3N0cHJrzm10zoF1aH9wwW5/fGbQbGt2endv03drcYJ5eXeVloKHiJePmpaXl5ydlJ2Yk4yOl6CdlomYnJecjpWtpJ2pqqamm5SXk5SckZWqsauemoCfo56Wm5iLloBxb3l+gJiblp6eoKGcmaCWj4Btb27X0HF5gX6FjIiAfH19fHR5gIaFh4F2gpaSlaCTkYp+fYZ2eXt7gG5zbHJ5c3N3cnN9enp2dGxoeGp4gX90gIqMoJR0gHF1iYOCb397dtrbeNZ12b7N68Szt9l+iu7T8bXgzoDT1rC0t6y4wr3Af+p/hId8eHmGc3PFbnDHvM7VdsLi+L/RwHHbssZ8ybjbeH16b9V6eYnm3XDLeHqBlIR6eW21lZS0wc5wb8hyzLl2wsRtjaCnjmrIcnJmyMTKzb7Bxbm/xGtkvGJmbmptvbS1qrTMrrJot6SqrKihrb2+lKqvwYB1cX6DkoaMVVpeZ1qNfoZlycaJ34K0uLNtvIW2yaObmrS+amu1W2R4vP2EpcfDrquwqK2UpfSKj5uYpLGyYWawuWVnu8Cwr7nEZ7CjwmNwb2S4X21rY2l4dmRzdY2OnoiCfXN2briwpI6HlJ6lkIStuWh2b7+WhYCmbGi1vXZvZoC3a8enr7K1r6iWmZ2nscG6a32Af4V1cXmFfoRtbb3BdIF+b3JzdnB6fod8hYeOkpKQfm2Ii5KGfX2CmJqSmpaTiH2FjIJ6gH+Dh4SHfHBowMK1urxobM/Dymx3fHVxeH14dnd4cs6rqpzBant7bGtuamuBgHp8hX2Jlp2GkpSEd4B1d3B9eoWMio15c3F1d3x+c4CChZaSgHlvynJpa2bFcIGDhoN5gouVkH6LgpCKjYF5hH6Nq6SgrKmjr667o6aos16csmJqarOdoqOjo5mds7KlmZCUl6aMhOXcg4Zyl56Qg6Gdf46Ajox6coiWnYt7foeEdZNgZWdrbmxipWSnn4CBvst9eIJ2f46Zopq2XLKlkoGJg4CSqJytr5h9j5ebmJqsZ29iZWOzYlmXqKKWfJGmkpGUkYp7gYp3cXlueYCGfoN+i4xvg4GFnJOVqF+skoqMdHLmw6nJ2MGdpKaWu9O5ruPVu7q3zMTZdoSahoaGnXt4dYF5iGdza312cXBmcYBtcXpwcGNrfoaEent9iYKOiXt8jIWSm4+sm4uHh3yRkIusqHiGkY+OkpmTin5tx3BsoLJwdG/TzG5/fnN4eXNyiYB4bLuml4+zuW1zbbB8iohpsnZybG9uqI2ClKGQe2psd3aQhJCMb3JkdHBsaL+DZL/Hcmt4gHd3inBzcm1+fIp+hX0Ifn19fn5+fX2RfgF9iH4EfX5+fYV+AX2EfgF9hn4Bfdd+gn3LfgV9fX59foh9gn6QfQJ+fYl+A31+foR9AX6GfQh+fX19fn19fYR+CH1+fn59fX59iH6GfQl+fn1+fX1+fX2GfgR9fn5+in0Dfn59hX6IfQF+jX2HfoV/hH4EfX19fIR9AX6JfQh+fn1+fn59fIt9AXyHfQZ+fn19fn6GfQR+fX19hH4BfZN+jH2DfoV9CX5+fX1+fn59fo59jX6CfbB+hX0Ffn59fX2MfoV9r34BfYR+AX2ifgZ/fn5/f3+SfoJ9mn6Hfwd+f35+fn19in4Bf5R+hX8Dfn9/o34Bf4Z+ln3Efgp9fn59fX5+fn19jH6GfQR+fn59hH4BfYV+AX2VfgV9fn59fY1+AgIEAIDMw72sxZ3/jd2EjpnCxqu0p6CljoyFk5Hy/oeGh6i2p5uRk6GcqrawtKyloZKRk5SRjYHr0oHu9oOLjPaAn6Weko6IjKOWj4yPkpilqaKxub+3rrC3sb3OxLmirsDKzM+9rrTHvNnSzdbVyNHU4Nbg2t3a1uTb7vHugpOXkIWF7oDg6ery0cbG08O5utPe1d3n2cfD1s/V5Nff1cXIwa2oq6WvvsHHx7rGzMa7wdPLxdGukYyQlqmis8Cz1dO2oZuyr6Sxy9PKvcOysKufq7WTnrKMwrmBjJ6tl5qjqqvHvZWKpq6+vqSfqaO2i52g/bO5zMzbtKWLlpOK3dCrf3doe4CEfHJ4epOvsp7c7MX90eHPyPSMhf6AnZrxyL33gbPr75GAhYbkr9vZrvLa6YCGi4+og4ec/Z+FlZaqq7ehhojz//+fr5CTieXDgYHpyPX/m6qpmYvej4yA/ILr/fqg4vSIkYOD7aCclpTm5OPc1//U84SD+8KdhZ63vPXDpa7AgoD1j52RvdfwiqabrcKUgLWVx6Seq66L2Oi83ebq6Ov94MaOo5L+9ejbisDw2tDj5MnB3NrQv4bu0J6n0ZaryN7h9vjx7ujwgvvPxL6jyNf565iW8YPp+fGLjp7H5cKciIqAnJCKlKCSk+u1vcmCzqm71JWezYnixLuYxZu3kPqKmICR+Yiol4fu5sinq8CB9oGNsLSkra2N8eXxgIWfrLGWi5iVprq9xb7Ct7uopbSrm6O6u6muqqeplqy8t7fJ2requKm7v8Kfpra7ubCoo6qYqPTT74TlwpaDds3k43ePtNfx7c/S9I2+jsqq4oK41K2jhYjniZWbkpmXn5ill6e6r4CwoaWmkJeWgYOWl4/+pKfKwbOipK22tLrBs6mXoZqptbKwoaajusqspaWZmZaLkIOUkK7Dr6qsqJimvMz4gImDjISPg/DGvrrAxMy9u9DPwcG7qq+rm46BgoKdx6/SycrNzMG4sL3StZjN2+Xi3u3g09Kim73xmamgn5uKsbSGmIDoqLXbw72ptaW05Pfa3NTL68Kqw6yludjOu4znmoOE99PjiZyplIX88MO0ztK8r5qMjPOK95Scyby0npCZsp+bp7CiwMCyqrSlwrWhqLytpZXr94HAyLHu5YqtjsP1vMuW84bhlIDm6/SSiYmklrShiYqLnbCjmoCvmZb3mIeEkoCK+ImQkbLG7ebh6dvHsJ+9qbbXwuv+iYWN6tO5qqXBk5m3tKel1dnR1q6Vj5f66JOF6emBi5GO/N/g/YmZnJupkaikg8qyooyYp4mC+YCHjaOsnIaMl6TX8ujJqsbd3sb5narEvcqxjZqZmZmPk4GOoLeMipH5kKqonJ+erL+/yYCtqKWVrIrlgMh2foenqZObj4ySfn13gYHa4nh3eJOekIh/g4+LlqCYnZeTjn+AgoOAfXTXwHXV3XZ9ftxyjpGLgX96e5GFf3x9g4eSlY+bo6egmpqim6W0qqOOmqeprrGkmJytoLyyrrS0qbK0vrW+uru3tL20w8jGbHp7dm1txIC4vr7HraSksKCWmqy1sLbCs6KgsaytvbG6s6OpopKQkIyTnaCipZqjqaSanq2jo66Qe3p8gZOKnKefureei4GSlYmWqrCooaWYkYuEjpt/hJl6tqx0eoiSgYGHkIyqnYF+kpOgnYyOlIqgeYeD5q+5yMrWt6qDg4N+08aphH1vhICJhHmAfpixuqHX57rvydXFwd58eOFuhoXbwK/ffq7Z3IFzdXbbqsrGpeHQ3HV9fnyPdHyK7ot3goiUmKKPdHbY39+HmIB+d9C4dXbQttPYgZGPgXjJe3ty53LQ3t+VzdRze3Nzz4WDgH/Q0tHJuty60XBu17WVg5Gjqu67n6C0c4DVeoR8n669a4B5g5J1Z5qBtJySrK+Dwc2qws3Jy9LpybB8hX/i1NK9davLzb7Cw7StxLu5vYPozJidwY2ct7q80NHPzsLOb9q4r7Oar7/Sxn+C0m/E08p1dIGit6WDcnRvgnl0eoJ7fdOqrLKFyqy6y4mNsHTGtLGVtIKVe9l5goCA3XKOgXbRya2Tmaxsy2p2lJWKkJd/1M/Rc3SFi5F+eoV8jJmaoZufmZqNh5iOgoiZm46XlY+OgJaempiltZmQmoycnJ+BjZiblZCMipODkMy823DLtZKDd8/g3XOJpsbZ3MDB2n6lgbaYyXGht5aQdHbMeISGfoWDjYaQg5GglICYjI6QfoWCcnOFhn3ekY+wqpqMjpagnKCnm5WDjIeUnpqgjpORpa+UjpCFh4R4fXKBfpisl5aXkoWQobDUbnZwdnB4b8yrpKOnqbGiobayqairmp6aj4F4e3mPraG+tLivua6gm6q3oIuyw8vEv8fAsK+Ng6HAeIV/f312kI9vi4DbmKW5o6GSm4ubw9G+ubGv0KOTqpWJnL2vnH/gh2tsyLG+cIGHdm3Owp6Yqayel4R5ft6B3ISNs5+ciH2Fn4yJkZiJoqaUkJmPopqMkpySi4HQ23W1vKfY0nuejMbrt82I5X3Wh3HX1NuGgnqOgpeNeHl7hJuKg3OXg4HPfXBweIB31XB7epmlure0vrOekoeejZiyosXRcW5yv7Ofj42mhIaemZKNs6+sr5KGeH/XzH51zNJyd3p93MXO2niGhYmTfZGRdbalmoSPo3lv5m94eYuViHR3gYy0y8OpkaW6vKXQho+moLCYeIWChIJ6fXB8jJ15eX7ZfpOQhYmGlqWirICQjIuDknjLcrprcXmQj3+DfHyBcXFscHLGy2lraoOHfXlxc398hYyEiIOCf3Fwc3R1cmvHvG2/y2tvb8lrf4F7c3NxcYR5dHFyd3qGioONk5WOioyUjpGjmJF/hpSSl5qRiYyXiqCZlZqalJ6jpp6oo6OemZ+XoKeoWWJmYl5Zo4CdpaetmY6LloZ/gpSXlpuomY2NnJeXppufmoyRjoGBfXuAiIuOjYWJkouDg5CHiZV/bm9zdoJ5ipWMoqGKenJ9fXN9jZCKhIuDfnZ2gYd1eYdzvaprcHiBdXN2f4CTj3hzhYaQjoWChoCLcXV43rvE1Nfe0cN+gX+A1Mu+op2RoYCpoZadmq/Jyrva5MboytTQy+F6duJvf3rMvbDWdbnX1Xpvcnfet8TDrtfJ3nV5eHiDcXqE4oBweoCLkJmEbm/Kzs54g3Z2bsWubXDEqMDPdoSDdm26b3Bo1Ga+zc6HvsBlb2ppundycHLByMbAscqsvmVixq2WiZSaovjSnZ+vaoDEcXhwjZacVmVdZWtYTX5xpYuHtr6GucmmuLq8wMjas6Juc3HJur6zap+5wbavq6iftqilsoPt1pKYt4yYq6qotri5vam6YMWro6mVpK29tm9zumKwvK9nZmyGk452YmVhcWlnaG5tbcGhmqGF1r/K0IOJnWW7q6aKo3B8bMFocIByzGZ9cGe5rp+NkptYs1xofYF5f4RxwLK8ZmVvcXhsbnlxeIOGiYOIgoZ7coB7dHmFhn6Fhn58dYKKhYKMmYh+hnuHiIl0e4OGgH96fIB1gsWxxWe/tJmKhev184GQpsHR0Li3y3OXdrOWvGuUqISAaGq+bnZ4dHh2fHmDd3+NgoCCeXyAcnh3aGp1dXLLf3+alIl8gISNi42Vh4N2fHeIkIyOgYWHmqSIgoJ7fXlvdGp3doqXhoKGhXqBkJ2/Y2VfZWBmXrOakI+Xlp6Rj6KhnJqajYyLhXt0c3WFm5OwoqahqZ6Vjpqjk4Giq7arpKmjlo13a4WdXmZkZmhldHNagIDZjZOhjI6AiHyHrbWnoJmatpCGlod6hZ+ZiHLSd1pdppmjX21yZF2uo4uHkZePgnhvddZ51HyBoY6MfHN1jYGBgoN4jpN8e4GAkIp8f4yFfnXE1HKwuanQyHKklL3mwsaA23bOfGzO0NB6eHKBc4WDcm9rdI56eWyFdnXEa15jZIBjuWFpa3yFkY6PmZKBe3eHen6Ohp+uX1xfpJqOhX6OeXmEhnp4lJeZmoZ6bmy+vXBsvL9mbGxwzb7AzG54d3uEcoCAaaybk4WWpWpjz2Rna3l/dmdpcHWUqqSPe4ycnYq4dXqLhpaDbHZxdHNsbWNreYdra23DcIB8cnVzf4mIjIZ+A31+fY9+gn2Zfgl9fX59fX5+fn29foZ/036CfZl+iH2Efpl9Bn5+fX5+foR9BH59fX2Efoh9iH4BfYp+g32FfgR9fX5+hH2Ffgx9fn5+fX59fX1+fX2EfgF9hH6IfYJ+h30HfHx9fX1+fYZ+h38Hfn59fX18fIx9g36EfQF+jX2CfI59AX6JfQd+fn1+fX19kX6FfYR8BH19fX6FfQh+fn59fn5+fYR+hn0Cfn2IfoN9t34EfX19foV9g3yJfQZ+fX59fX2HfgF9mX4BfbB+h3+yfol/An59mn4HfX5/f35+foV/i34DfX59nH4DfX1+hX0BfoZ9CX59fn1+fn19fZJ+AX2FfgF9lH6Df5R+Bn19fn59fYR+hH2JfoZ9A35+fZN+AX2UfgF9in4CAgQAgLnQ4NDAn4qgo7KGpJfZmoybx9+i//iAoaqmmZL6n52Lg6e7qqjLwrOjp7euqZWXl6ShlJ2Nj/2GmpOTjI6JjoWTiZONhfaD/IKSo66ysqKvv625taSvtMPBwsfGyMe7wcjF0OP17Nbl3s7FvcvU1Nfe3urv/4DtgYLx59jc4oCBgIH14uDZwbvCz8XR5PDk1dX37enm3PHk0t/e5tvS0cjN28/O07/Uy8nRyr7BucjDtKiRpqews7TEx7vGzLGkosKrla7D0cqtwbalorHCubaZjqadlZO7v7WytL3OwNCyq5KLrpyOlZagopaahJqgpIl307alpfuml83nvIhyYG5ugIhynJl4xrO61uDw9/fdzYKKhv7b09SSn6qO8puwo6y7pOF0gYvkpPP454yM8pmZm/qRm5OnxfySkf2Sq6WRmZb39q61kqOV0ajumIODiuyN+JicgYnthoueivmAg5CJhpLxi52Xk5qdktylp+vc9uKBoKO7zOOufqyunYbAgez5gI3//4m55bi8u+6Wg6Wmh8Gt2sKu7IWHtMXfutGUk5SZjKOI6f2qi5GVjevSv8vihJaVmvOzxdqNt6KtpcTy4/jN6b+7u7HTyujsnfXU6fHU642B6e3mwIiKmbK9uoeAl7Oj4cmEm4WG37qswp+Xnox/ppbI8aSy9tzJ7qqxoIaCgKCT6PuHivrlwbauxNne3Ovi+ZaDnJ61mYWO/I6Ojpf9/Y6XmbS5sammkpedqraiiomOmaeytr6ojZ2uuL2vsqesrLO2n5CZqKSiq7bAyMmyjY2isZPNoLXP08Cse7ir0o/K39nhj4qVs6+2y9O3lpugn5SbmJOVoZaXjqCEgZGUgJ2UjpemtbCmqqGXpYiVgf+ZoZWUqpuOlaqropqRnpqknqy2pqTN2bScn5OhpZurqq2us7elmpuWo6mpo6etwLW6tKORqKqztsjFv8je3s21t7ayvKecgPiSoZjCs9zZ3+r27uzh0uXOs7fRgPaTlo2Ria3CgZ2mv7K0m5qHhOOfgNK43bvXzsC6m6TBt8TNw83G7MSuq727sJ6hwvCXloKUgviP+veHyKWXzrfFufPm4byjno6VptPT07eaqMmlk7XGyKC50NO7qpSan6Gvw62XmImut5mGgODU2tig0Z2piZ+EjoaOgouOjYPvhJGKko6Skqiep52JmpqDifH/6Iz6gIyak6SjzvL68eD41c2+sbTBrMXrgYWCi5yB1suukJC8ttbYssH766r+k7OVjKG+tZDo2/bC5O2CpqmPnpmglrOno56I0bqqnsrVgo/qwqGvsIX2q9bL0dPF5q+L+KDDvJ+uxLW8zqKpt6ecr6uyuLuknrKmn5CdmaOByYyv173zgJ+1wbSljHuNjp13kIS6hXuJrcKK3t1yjZOQhoDfi4h6dJKilZOyp5yPkp6XkoKChI+OhIp+f+R5iYOFf4B9f3eDeoR9eNx343OCkpudnpGbqZehnpCYnq2npq2rq6yfpqynscPQybXEu66ooa2zsbS8u8PF0GnCa2vIwLS3umpqgGrKurqynZedqaKrvMa9rrHLw8C+tse8rrq3vbewrqeqtqipsJ6vp6Wtqp6jmqegl4x6jIyVl5eorqSttJ2RjaaWh5igrKmUoZmLipKkm6OJfo6JgXufn5iUlZypnaiSkYR5mIp8g4SFjYGAdZOipI181bOnquiTh8jbuI57Z3l1gJR3oKF9wrO1yNXh5OjRw3Z4eebPzL+IipiD4oaUi5Sgjd13hIjQlOHk1H596YeHjuKAh4WVquR+guiFlI6AhYbs35OYgZGExKDdgnVxdsZ01oOKdHjOeHSJeNRscH14cnvQc4J9fYKHfcuhncvA0cl0iYmut9Oqe5yhnICwc9jmgIDl4XadvZWZmLl2ZoGEbp6Vw6+s7IaBprfNqbiBfXp/dIt20NyQeX5/d8zDsrTEcISCiNymv8eFqZKembHVxdW2yqurpJu8tMfJhNm7x8u5yHltz9bUrnV4hJebmXZxgZaLzL11hXF1yrWcrJmRm5KGraHX7pWj3MW905CUi3NzgImC2NpyedPLrqOirL3JwdbI2H9vhYOZg3F61Hh4dX7X1Xh/g5Obk4uMf4GEjpiMeXZ5g5GZnZ6LeIWXmKWSlo+OkJebg3iDjoeIjZagp6KTeHqJmYW3mbbBw7Ood7urzYa2ycHLf3qDnZqhsbefgYeLjYCHhYGDjYODfox2cH+BgIiDfISQnZqRk42EkXaDb9+FioGClIZ8gZSUi4Z9i4eSi5ehkpOzvJyJiYGNkImYl5ianp+QiYqEjZOTjpSWp52hm46BkpSenrGqp63BwrShoaKgqJWLeOeFkISroMK+w9DYycnBtsawmaC2btt7fHZ5eJiiZ3yAkYyOfX1ucceQgLyjyKWzsKSgiZGjoaetpKyqzqaZmaehn42Ur819fG53bMx41NFxqoyDr52poM/DuqCRi4CFj7m4sp2Ik6qRhaOprI6htLGZkIOEjIqQoZKGhHWSm4R9dtjGx8qYwo+We413gnx+dX2EhXnbeIF5en+BfIyDkIZ0hIJtdMzfxnfTgHN9bn+Bor3DvbDFrKeYkZqplaLBamxqcHtpsa2Ye3ijmq6vlJ/LwpDXgJp8eYmgmnrT1Oiyx8pwj5R6iYKKgpmQjYh1uaedkra+c33QsI2XlnLVkLKssrCku5B31IijoIaTqJ2hsIiRm46ElJKZm6CKhpmPinuJg4txsHqWt6DQgIubo5uNeG5/e4ZpfXKWc2t5lKZ4y8tnfX58dXPKe3ZsaoOOhIKck4d9foiCf3JydX9+dnxxctVwe3Z3dHV0eG52bnhyb81v1Gp3i5KQkYeOlIeOjIKIjZmTkpaUlZeMk5SSl6axrJqpn5aSjpmcmpmenqOjqlekW1moo5ycoVxZgFmvoqKYgoCDjYmPnqibkZippaKlnqqmmKKgpqGcm5WRm46Ol4aXj42YlIeNiI+Khn5ve3yCgYSUmpKZn4+Ce5CEd4KHjIp/iYN4d3+NipN+doJ3cm2GiIWBfYGOiZGHhHtziIR0dnd4gXh1bZioraSb3crAv+eLhdHdy62ciJOUgK2VrrSaysLFzN3j6ebW0HZ1eOHMz8eBgot94H+Gf4mSht6OmJrRhdjZ0np844KBgeR6gn2Lmt16fNx9ioR2e3nZ0oeHd4V6vJ3NdmhnaLdpyXl9bGq+bWp5bcJiaHJuaGu+aHJtb3V4c8GdmcCzwLtqenynsMmrgpycmYCracvkgHnX0m6MoH6Ef5NaVGVmVYR/rpub9oqBoq/AobB1bW1waX5ux9KCbXFtabiyqaiyY3d3fM6esbyDpouVlKTBtLuptp+dmpGuprO0ccWrtraqsG1ju7/HoWVnb36FhmtmcH93u61ndmZpvqyRno+IlpWMxrvi8ZObx7SpunV8emZogHd1wMVja7i1n5mZnKa3sL+5wW9jeHZ/cGVqvmloYW3HvWRpcH2FgXl7cm9yeIF8bmpudYGJiIh8cXaBiJJ/gn59eYGJdm10fHd2e4GJjo2DbW92hHivl66zvLWrhNPG6ISrvbS8cW11i4eQnKSPdXp8fnV5enV0hHd5c4BtaHNzgHp1cHiDi4qChIB3gmt1Zcl2fHR1hHlvd4OCfnh0fHuIfYmQiImjqo5+fXiDg32LioqMj5GCfn57gYaFgomKl4+QjIJ3hIeNjpqXlJquq5+PlJCPl4qCcN98hH6elLSwsMDEtLOroLCZi46jYsFrbGdnY3yIVV9hbnBxZWNaYa+IgKqYtJaWlYuQeX+JjY6Xj5Cbt5KJi5OQkIKDmq5pal9mW7VovbVglH96k42QjrWqn4yHgXp4gJ+gl4yAhpGBeo6Ul4GWnZiAfnR3fXt/i4Z8dmmEiHV3bs/BxcWYu4WHc4JweHd1bnR6e3PVcXhzc3Z2cH53gHhrcXZmabnGs2W4gGBpXWtuhZuhmYqbjouCe4SShIqZWFxXW2NXmZaFcm2MiJKQe4CkpILGboFvbHWHh3LCwNKpt79ofoFyeXJ3coV/fXdqrZ+Wj6esZm6+o3qBgGPAeJWTlZOKmXtnuHKHiXeCkImKl3h+hXx0gYCHh4h3c4J8eGt2cHVjnWiAmImtlH6CfYZ+AX2ZfgF9jn4DfX59rX4Ef35/f4V+g3/rfop9gn6XfYN+hH2EfgF9hn6FfQt+fX19fn59fn5+fYV+BH1+fn2GfoJ9hX6DfYR+A31+fYR+AX2EfgF9hn4BfYd+h32Dfop9Bn59fX59fYd+hX8Gfn59fX18h32HfoJ9hX6FfYR+l30BfoZ9gn6EfYt+gn2Efol9hHyGfYd+BH19fn6MfYh+AX2EfoJ9tH6IfYN8hX2qfgF9x34BfZN+An9+hX+Cfop/nn6FfwV+f35+f7F+hn2NfgF9kH4FfX19fn2UfoZ/jn4BfYh+hn2NfoZ9BH5+fX2EfgF9iX4BfZ1+AX2FfgICBACAsKOQm7DFkqy/np3a0Nu4tY+5zMyumZ2bpZWYopikqoeSnZ2um7HEuK6urqrAu8LDoKOnjJKTjY2B/Yv5ipaDjpGdj4X2goP32O6CmK6YiZamraasn6Kksba7yc7Ow9HRx9He7djQ1drk2e/o9vT17fn6gfiBgP6Eg4GA8feAjfyAg/Tx/ffk5dXk4uzzxeXu2NPM09/b2Ofn7+Lo6/zh3+DRx9G/2d/N2s/hycjGu7irrrm8vbCioaugnLKtqaGVo6u6w8jDu6q8l6G8qKqsr8e1ubWvt9CC4crQ69nZ4uq5pqCeqbOlnZaMi+/hwtXdsq2vy8vB74LkoqiOm5V0cVyAdpaQl46blL2+8vTzi4LlgPTjxrKx3IOEjqackJeB3Ou7hXV/gMaLqYeLg/SWiYf3mqKOnJuSlJmR84Togp6Sj4WIq7eckZSM6Y3/joiAlu/+jomImZuGl4yAk5GCh5GEjYyenJeTh47Uxcm6/IWRh87u4c7cos3ZsM3A6O+qheeAiOuMlfCEmI6JvfGQkq7Yp9/HkuuFpd3hwau6r/eYk5+qpZ6XgPGOp5qhkoHi9tvyg4jqu6/n5Le7s9+uyYCH6c3w6/Tqrq7B2s+KjYm3u7Xh9ZCDiZPB6IWNp5qqoKaiobqglsPBnpGc6Yjm0tvTmZqHnqHJy7ucmJ6mqMzEq56AjYe+1YiRiNmrzfD8kpr/hfWCj6CxpZGH8eTV5YiV/tzVgpWZma+xsqOojZ+Zn8jUs5qgqquUoLnFvbCoqLK9xNHdwr3FlZGai6rUxay3uM+lpLOUt7HBjrKLk/qJhrtynfH9lsKSmYP/+IOCjaemrq2eqbKhmJmkiJKOj5yrmJeAo6+1r7Sro5WamZy1q5aIgPCLl5iVqIycmpufoKCmus3BmY+SvKiYj4WJjqqiiJGal56snZOUm56Fhojp6PH47cHM6I+kja/Qs9a64ci/tpuhmo2ThoOBnbinysLe19fcy8nl8eHc48efx+nrhpfi1oaHkY6Rnquus53+7IOMj9qAhOOy3PfPyLi1p8G3zL/Fz9Xk8/v/hP+EiJyGnJOMopz/wdXXxKDAqOzStrjr/4HEzdHKy7CogZ7UrpWxwp6u18HHxKidrLWWjL/LlIeHgZy7pKqtwpnzxJ/jgPj4iYuGgoCO/oGAo6ioif2S6ISmmp6jtKaU+IiTgOTxzLamkbiApZnAudjk293U1+jGuszCq9bBsvCEgJibhvDIobGZi5O8x7ewr9WrkY3Hp6L8mpmRiujeiYDchIz9hoiIjfObnZSZmo6D6dCag7SK6/vh8fSFs8au1db7xfzL6O77kMPP44G5uuf008He+c/GsLGPiqOhtauwu4+M8/uzw5/j3eOAmI5+hpiogZaihoa5r7qbmHugr62UhoiJkoKGj4OPk3WBjYqXhpuonZaVk4+joKaliZCSfIKCfX1z4HzgeIV2f4CMgHfadnnhydx2iJuIeoSSmZKYi46Qm52jrrCvpbKzqLK8yK+krK22sMzBzsnKxtDOasxqadJsbGpqyMxpcc6AbMbEzsq7uq28tr3Iobi7rqyqsrq5tL++xbzBwc64trSrpKybrbOntKu5pKOjmpmOk5ydnpSJipKKiZyYlZCDj5SdpauooZOhhYqgk5KRlamXnp6NmbNruqqzwLCvucGZj4uHlJeJh4R6eNLYus3Or6ysxr+95XfToayPnJp7emKAfJyUmpOdmL243+Tmf3fVc9fSwa2pz3Nyd5CKf4F4zdy2i3qDfrh6nH9+euSFfnnehYl4i4eAhId913rOboKAfnJzi5iHeXt40n3TfHZygdLZeHp2goZ3hHxtfX5udn9yfXeJhIJ/dXzBt72s2nN8eLvU1MLFm8HKqMOz2NWReNeAfNR+gL9ofX5ymblucYKihryqgNKCmMjLtJ2pqtyCeYSRko6Gctt5i4OGfnXL27zVcXbPsqDKx6+upcymsWp0x7fX0tXInaWtvbRydXSrqKXI0n1vd4Ctz3R3h4GQh4mFg5eGgJ+hjH6KzXrLwMbChIZ8nKC3v62choaPjKOlj4eAeXauv3F+eMqaus/aeYDbctlwf4eXiHp408i4ynSF4Ma/b36AgJKOkomTeYSCh6uvlIKHkZd8h52in5qNjZmcpqyxmp+hfHuFd5ayn42XmKmPjJV+p7O9ial3fNp4drJxl/Lqiq6DiHXg33lzfJSRlpWJkpuMhIeQd3+AfYeVhIOAj5iem5yUj4KJhIeelYZ4cdN4hYSBlnmLhoaLi4uRobOnhYCBqZOEf3V5fZWOeIGIhY6aiYKCi455dnfQz9bf2LG7z3yPfpq1nbuixq2ooIqQioCFeXZ2jKKTsKfEuru/sa3FzcK+xa2MrcrDdX3BtG5ueHR2fYKGjnrNwG9ydb2AbsSfwdO0rZ6ejqefrqWnrrXDyNPTb9ducoJre3NwgXvRpLW5qYy8mMqtm56+zmqirrSusJaOdZKzlIGYrYqVt6KqqpGJlJqDfaSpf3N2boifiY6QpIbitpPKcNvjfHt2dnZ+5XR0kJqTeu+F0XSLiIeEmIp71nJ8bcHWt66We52AhXmYj6avpKijqLmak6KfjbShmcpsanh6bMCrjJiEen6co5GPlq+LeXupiIfXioF8edjPd3PAdXvidXV0edCGhX6Dg3pxzbiNgad4zebE0tJxl6iSsrPUo9Onyc3Xe6awwGqbnb7KsKO7zaqmlZV8eYyKnZKToHt72OKisorAvMGAhHxwdYCPcYCHdHOWkpyEf2yLl5N+dHh7gnN2gHV/f2h0f3iBdoqRh4J/fnqJh42LeH5/b3V0bW5qzHDMbXVqcnJ7dWzIbnHUwNR0hJJ9cHaDiYGFe3+AiYqUl5aYi5aYjpmjrpSIioqRk6yjrKmopq2pWqtaWKxaW1hYp65XW6+AXaekrqqenJShmJuliZWYk5iVnKCdnKamqKaqp62bmpmUj4+Bj5aPm5Khi4mLh4N+hYiHi358e4F7eYyKiIN4foeJj5SPi4GOd3mKg319gZKDh4h+h5ZXnZecpZuYnqiOhIB9h4l/fHhzc9DVwM/Pvby+x8nJ4Xbcsrymqa+bnYSAlrGxsayurMbE4OnwfXTRbtfZybqzz29udYeCeHdzxtm7o5eYkL13j3h5d+KCd3LTfnxyg4J8e3x40nPGaXd2c2hpe4d3bGxtxWu8b2pmccLNcHFsdntteG9lcG9la3Rrcmp5dnNxbXW8sLeqzGlzbq3Dwrm9mrrAqbyszMqIdNOAc811dqZWbHBkf5BQVWF4ZZmHbr1+lLi8qpeios91anV+g4J9achqe3t6cGm6xq7DZmzEp5nAt6ajnrucpV5luKrCv8Cyk52esKViZWWmn5u4wm1iaXGjv2prcnF6d3Vxcn53b4CNfG57umq2sbO0c3dxmZepqqOWc3R6d4WNeniAb22qsWJrbsCVpbS/ZGzAZclncXmGe21vwLqxtWNwyLewYmxucH55e3uEbnZ3eJSUg3N1gIZwdYeLjIqAfYOIj5SXg4eMcWx3boOei3+EhI6De39xoqi6ipxkbsZobbmCrvT1haN1eWjK0HFpboWChYN3gYl+c3mEa3V2dHyHeXeAg4uKiIyGgHR5eXqMhXhtZcFtdXd2hG9+eXp+fYGDkp6Vend7nYx4c2tydouDb3iAeoKNfHd4f4Jwb3HFxcvPzq+4xXF/d46jjKWQr6CZkoCEgXd8cm5yhJSKo5mzrq2spqCwt6uoqpiAm6+naG2mm1xcZV9bYmVnb2Cmo1tjZKyAYbKUs7edmYyKgZKPm5WXm6WtrbOyYLtfYm9baGJfZmi3l6SlloG3i6qThombqliIlZ6XnoaAb4icg3OHln+Hn5CYmYR9hYh6cYuQdGZoYXyPdXqAknjTq464aczWdXNtb3J11G1rhY+Ect9/yWl5fXp5in5wyGVuYrK7qaSLaYGAdGV6doiNh4aEhZJ9eX9/dpOOg6dbWmNkWp2VfId3b3CFh3p3fpF5amqHc3PHdnJwa8S8bma3aW3Pa2toa7tyc290dGtlvK2MiKJruMewubtjfox6kpatia6NsbXGbo6ToVmEhKColYyeqY+MgIFvbHh1hX9+hWtrwM2Xo3idnJ+5fgN9fn2IfgZ9fn59fX2ofgV/fn9/foR/Bn5+f39+f9V+AX+Tfox9AX6VfQR+fn1+hn2Ifoh9hX4FfX5+fn2JfgN9fn2MfgN9fn2EfoJ9l36FfYN+jX0Jfn59fn1+fn5/hX6Ff4N+in2IfgF9hn6EfYJ+i32Cfot9g36FfYR+gn2RfgJ9foR9g36GfYp+BX19fn5+hX0Ffn59fn2HfoR9BX5+fX19s36FfRF+fn1+fn19fHx8fX1+fn59faZ+AX2qfoh9qX4Ef39+fop/B35+f39/fn+UfgJ/fol/hn4BfYd+AX+nfoR9A359fYZ+AX2GfgN9fn2IfgR9fn5+hX2WfoV/k34BfYR+CH19fn59fn59hH4BfYd+hX0BfoV9in6DfYR+AX+WfoR9hH4CAgQAgOKzk4+EtKWxnuyMuMXKxNDOuqyjrbOuqKipuKmBocS4lqG/ori7sa/Dtcu1pqao18zEv7WejpehoZGOlaqtk52gqKqmp6Kemo6Fjvrc6ZCPjqCssK2ttK60xsq9ycrO0tju6NvX3Onq4/D9gImEgP38/vqDjI6OjYuB/4SHgfL7gICA/fbr5tbZ7fD/1cDHwczQzMbS5ejo59jQyt34/fqB8PuBgP72+vOA+enU1sfRu7a+r7a9vsPBusDE2MPGvc7G0M+0nqaVmZSvtraxubyWusTSxNzc076g1ufJ4Mu5sLq9qZaXnaKM9fKAz+O9prvoq8u626uvztWFcIWVo2RbgG2Nq5eovtiBgorugYuS3svpzNeK9eDInInx69v50ZZ0rMrPxs2E5YeYmuTy/4HyiqOenIWPm4iQ9ffm6fXthu/6iZSIhaOnkc+JjYPi6u+IiI+o64iWnJGgnpialoiFgebqi6+ymrW+/M601e/8k+WQxePD/dTz7+iet+vd5dTkgPyDhvuaxPLLnbDVj6m8zerJl7nQs4aMz7qird+MlaKun5mer7WckonnlYKAk4C64N29zdTMppqQxcTp/f7p+4iHgt7vhdms2oaKhvLu19LIqrbUz9aAh/WI8Yqb/YmE8eCNkpeRsqyxurWnkYPh+f7684SJiJmUi5q1t7C609jCgKjZtOKBkqKagYWB6ISJnZ+Mld71iYuY6M35lYT9i5Ocjo+R/P/t64Scn5KH84OSkJOPma+6tLSxwLywrKSwtrCpnZ6srZKXrqytjpKJgvSbqqXiu7/u44r+rcKxnpe+772msrGqvu7+lKiT4pmws6anrZ+epZG5wrSwsKagopuVgKKQjJ6rrKmfr7KcnKLu2riy4fyRm5WE7ezy4f6Bg52bmZiSlKC3k4SImJefiZHIxrrD1NC7w8S0qbqphY2ApqOQuanF6pq2o5mjvcO2oO3GkIqgkJy0wtjr94r18/376u3j3d2919ry94SSkf6D/OP39vaToIqNs6WLhJCRlYaKgPDi/PLH0v7T6u/W0sbJt7zExOCEgoOB9eTJgYHwifjP8bPTn8rRvqHpguHNiY/kgOa2x6etz5WlsLGpr5yfmaGXnI+Uhp65qpCGioqVipissLSqrKKB0uP43JOFvdH15PHxm66wjo6WipCPiKOSjZisnJuWiPPqio3F1YeCkKCFgIiIpbbDus6nydXbxdbkt5y7x8nCu7nf+vXcztDZ2sCdp7+tpqqzlPmeu/6At9zaxMWUjI2Yh4KRnomKhJT+mK6nmoj9iuWC6P3U0L2I7ZXCmr3W37qxmrTmvp64xqy6xMm8s7Kstcnf14qN87Si+oaPio2FrsWvr4TX5drtiqWrgMGYf35znI6ai9J8oKespayrnZSMlaGZko+SnpNzj6mfhI6kip6hmJanm66ajZCRua+rpJuJfIWOjoB+gZSYg4yNkpOSlI+MjH53gOLG1IB+fYuUmJWYn5iaq62irK+ys7XHxbu2vcbGvsjUanNta9XS1NBrc3R0c3Nq0GxuacbKgGhp0c3BvbCywcPSrZmno6ivqKWwv76/vbKsprPLzctpwsppY8bGyMFnyr2rr6StnJidkpueo6Gim6KluKaro6+rsbKci5OEhH+SmZmSmJiBoqGupLKyrqCKvManva6clpucjn6Ghoh639V0wtazn7jgpMWuzqOlws+JdY6aqWtjgHSTr5yuus10d33dd3qDzr/fyMt949K3i3jc1cXmxph4qb3Dvb9503iIitXf53LZd42HiHd6iXaD2OTRz93Ncc/Ud4Byb4eRgcKAfnLL19V0cnuR03WIh3yKh4aBgnZ0cdHRepWbjLK348CjxODVfMuEs8qk59Pg2M+LntbN28bSgON1dt6FnsSnhZenbYCOm7GaeZ64pHR3tqaUnsN8hIyRiYKFlZaFhHfJe29te22nwcKqur+xmZOIsLHK3N3L23V0c8XNccKfwnRzdNfPwL23oaaztLxvdtd0zHWB1nVty75zeIJ7k5CQnJaIenbH1d3U1XR2dYJ6dIKUmpSZprKlgJG/pc52fYmDcHFvyW5vgYh5gsHUdHSEyLfcgXLbe3yGent61dvW03KDiHx003B6eHx6gpWZlJWTnpqVj4uVlpWRhoeQk36Dl5CZfIB4c9SGjYq/r7LIxn7kpbytnJWv2a+cp6KbrNPkg5WBxoSXmo+OloqHj36hqZuamJGKjoiBgI19e4mWl5mLmJqKiI3Swqmdyt5+hoN21tbVxeRxc4uGhoeBgouggXR4hoeMd3+0rKOqvLajra2claaVd390o6ORrZ6204mij4iOpq2fjNq7g32PhI2hrLvO1XfU1drbyczFusGhurzP2HF8edNv0LjJysVzfG9ujYFuaXZydm1ygMW+3s6psNW0wcu3sq2tnqOoqr9vamtqyMCqa2vKcs20x57JkbC0qI7Hb8CycnO4acGcp5CWqoCRmJmMl4WKhIqBhX6DeImalYN3fHeCdYSPkpKJkop4yNvkxYl5sMTizNfai5eee3eIfIGEf5KBfYGTiYWDeNPQenu0v3hyf4lygHRzg5Scka2IpKesmbK6lISapaOmoJ27yMKxq7C1tamHkJ+Oi4ySetWKn+FylrSxpKN7d36EdG97iXZ5coHXg5OShHTXd8lxz+K9vKZ31Iyzh6O0u5uVhJnAoYeap5OgpKagmJeUnai8tnJzxZeJ2HN6d3hymaeXlnPBz8jXeY+RgJ+BbW9mg3yEeb9uiI+Si4qQhn12gYiDf31/hX9phJOMdn2PeomKhIWNhpWEenqAopaUj4N4b3d+fXNvb4KFdHx8fn9/gn5+f3VxdtK3wXVycX6GhIKEioaIlpKLlJaZmp2qpp+coKmlpKqwWmFcWrW2trFaYGFhYl9YrVlcWquqgFdYrrCjoJWYo6Szk4OTjpKYko+apKSipZqYjpOurqtYn6ZYUaGjpp9YrKGNloyXioeJgYWIjIiJhYqRoZOVjpeUmJuJe4F3dXF9h4Z/gYBxh4iRj5ecm5OEqLCZqZ2OiIuPhXp8enx13NBxw82wpbvdtM+2x6qqxM+ekaOxwJGBgJGmurjAwsxucnnadHZ8zcrm0NV438+/gXLSzcLexqmQsLrAu7x10HeDhNTb4GvNcoOAfXB1f3B50NvJw8m7Y73DaHJmZHeCcrZ4dGi7xcRpaW2Dw256eXJ7en13em5va8TAb4KPhba02Lmgu8/IdL6Cq8KS2cvUysN9i8jMz7zIgNdsbdF8h56Ic3+AU2FmdINyXH+jkGNpqZeOm7hxeHx+fXl6h4Z4em22a2Zia2ShtbOeqrGkk5OJpqa6ysi8w2poabm5Y7aZr2RgYr28sbCsmaClp6xkab5nwGRuv2phs6phZXNsfnp5gn5vam20ucLCwWRkaXFoYm99hX5+hZGLgH6vpMFtcXh0ZGZhuWBda3VpcLK8aGdxvKnDcGbIbXF3bmtrwMTKxWZsdXFqyWdvbHBucoCHg3l+hYaAgX2ChIWDfnt+gXZ3iYSJcnRvbMZ2e3i4oZe0tXHKorSuppiiyq2Xnp6VmLvQeYh4t3OEh35/hHp7f3COlomIioOAgn11gH9zbnuFiIZ7iIl7eH7CtZySs8xyeXZsw8DDttRraYB5eH11eICReW90fnyAbnigoZadpqOToaOQi5mIb3Ztrr6ospyqxoGSgXh/lpmQg8++fHOGe4CVnq25wWvBv8jEtrmxp6qNo6i2umVsbMJhrZ2mo6xeY1xZbGJWVWRdX1phgKmmvbGPlrKZrLGlm5yfkpWZl6leXF5braWZW12xX7GisI/Cf5udlISuX6maXluVVqeKkX2BjG+GjIl9hnd9eHx1enR5cXqGinpvcWx2a3J3e3h1fX1xvsvWunpup7nTxcjOgYeRcm18cnp5dIB1cneDeXt5bMS/a26osGpkbnppgGdlanqCe450fn6GeI2Sdmx/ioqQiYaXpqGQjJCXnZp/fYN5b3B3a71ygcdjfYyQh4RuaXBzaWZwfGhvZm+/cX58dWjFabdmusutsJprvoypdYqTmYN+dIGfinaDjX+IioyKhIOCh42fml9doH1zvmRoZ2ljhI59f2axwbXHbXx7iX4BfcF+g32dfoR/hH6Hfwh+f39/fn5/f51+BX9+fn9/hH4Bf79+A319fpx9B35+fn1+fn6FfQZ+fX19fn6MfQp+fX5+fn19fX59iX6GfQN+fX2Hfgd9fn5+fX19hH4BfYx+gn2Efoh9AX6EfQF+hX2CfoZ9A35+fYd+h38Ffn19fn6FfYx+AX2FfpF9DH5+fn19fn19fX5+fop9DH5+fX59fn59fn59fYx+hX2PfoN9h34BfYZ+C319fn5+fX19fn59hn6EfYV+AX2hfgZ9fn5+fX2EfpB9BH5+fn2hfoZ9hH6FfaJ+h32JfoJ9in4Bf45+BX9/f35/hX6Nf5N+hH8Hfn5+f39+f4R+AX2Gfgd/fn5/f35/pn6EfYJ+hn2TfgZ9fX5+fX2sfgR9fn59kn4BfYV+BH1+fX6FfQR+fX19mX4Gf39+fn59in6EfYN+AgIEAICJgsbwmIri0buk0c/Lwb602rSrnruut5eVmpmhlYSYmpmvopWko56boJyxtsnisLnE1dzh18ixr7Ga/r3kmrOM9/ifjJmhoJmWjpmnpJicmKKqrqWdpLu8wdbExse6x8nDwMTF1OTq5t7s6eDh8ff15vX+goiQi4+Pif7y+oT9gYD88vHj6erv7/Dy697h5dnP4tDHy9rn6vHwgoKBg4WFgPyFgeX2gO2E+uTs6NfFv7yxo7fEzMPApqutw7y7vt/Vz8avpZ2Ok6fG2Li4yuHIwrOyyrq94dOhxMWrmrqqw9Wlr6SYpZeDutXHr46jyZyahpCvmJGIr8OeoYKBjarAlYB7pau05+il54PZh47qyLWatdr4kcaxodnzgNrhg+nj54uvnc7Fxsrp54XY6OyAnqGboI2EjZ7zlYeD4ouKh+yAhYv45dOHzu/54rbj5uDj9I2L/Y6FipWhl6SRhpPT55yCiveJjf2U6uyI+pSUg+/h2Yb4iN/Fw+yA5fv62fDO/4CTg4KEgpuex8zTgpud0tTz3+Gj7KSVzJyGw9u6sNbh5auywbicoKOtiJHv7YT816++zcPw89yuvqayvtWYhuT2ioTri4ePgISNjqKRjfOGz7Omw8fL8/zvw+COkoCOjvepnN2UkKrGwbjHw82ogIH8h4CWjIePj42Q+Y+mtam1u4DCqouC/JGgpaitlvqAhJKXkIaMiv2G9IKMoZz2iZGgpJ2L9/+BgYCBhoCDgIiMhP/ygIaJjZCbnKWooo2Mo6ahsLCrqLS7qb+qsLSvv76vnIWiyb/1jeCKs8mpsJeGwqfT073PioWChrTNxtCurZijv8mpoY2Rjp6Qm56fo52KhYCblpybn6u1u7mlpIuB4oWtoOn0jJWIpaGIivuRj4T9uLjX8fKAlqCemLCnt7i9z6ier7CyydTiv5yE8YLrt77ogZKikbfT1ODX6IKAivXQi4+Hop+owPKJ8/nVg+j3iPL36+3Xt7vN64WNlIGHmI/1+uyNmJeNnJaWl5WQl4+SkYCFhvKOjIber5qzzPPju/Hb0NHQg+3yipD+9YvWk6m2wITg3uasrNPLgumSoLuZ/PLH7MvFrLSclYD1laqdm5eUoIzZ4ouYp4fyorKgkbjEvMy1uLqrmpCWkI2bluezrZP61PSftKTwgIj6gaGUl5Tvi6GHhJSViIXY2JSwkpX1hICOiZuaraLVxeHH3Pjk0LOfqs/Y1OPizsP5gPv9g9uxo7nExLy5taOks6fU3sLu/vvSnrWZh4uhs4SFm/D1g4qShOLR4oGAkaiDiInk4NuKpZ27strit7GjtLrSuqWVhpnK2NmwmKGTqs6N4vPlo5qt26mEkrXCo8GVmpCFiaGOjYB3c7LYg3O/s6OOtbKtpKGZuJeRhqGUmX+AhoSLgnaGh4aYjIKQkIuFjYianKnAlp6ptLm/uauYl56H4q/Ripx94eOOfYyRjouGgImSkYeJhoyVmZGHj6Chpbapq6qeqaumo6imscHFwrfGwr28ys/Mv8rRa3B3c3Z1cdHHzm3Oa4DSyci7wMPEx8jLxLq9vLipuq6ip7PAwcbEaWhpa2pqac1raLvIZ7xqy7e/vK+jnpqQhpyhqKCdjJCVpZ6gn721squbkol9gZGntZqcrrukoZWYp5qgtK+NpqaWhp+TqauNlYeAjIFysdO/q5ClwJ6ei5OvlIuHr7ubo4aGk6zAmoCAr7O54tqm3XjPfoTiwLOZs9Dbg8Cym8bZdM3TeNrP2nmQjL+7vMDh0XzKx8tthYyNkH92e4rWhHd4z352eMxscnrTz7p2vM/ZyqLGy8TI0Xh33npxd4CNgZF+d3nG0YZwdt91fOKB1td73oSDdtXGw3nde9S6ttZzztzfy9i/34B9cnJ0coaEoaeqZnp9oZ+0pqmCypCCt499scOqn7/QxoqTnpuGh4mPdX7RynDdwJ+nuajOzcKhr5mkrb+EdM/Tc3LOdnJ3cnV5dIl7fNR3wKmatLS31dbSsMR7fXR8e+Osmsl+eYuinJGbm6WJbG7gdG2Dd3J4eHZ5znWJlYmQloCbi3t1536GiImTfNFucoB/eXR8dddzzGx6jYPQcXiFiIJ22N9ubm9xcnBwcXp4c+nZb29zeH6Ef4qKjXZ3homKlpSRjZabkaaNlZWSoKOVhnWTxrDPcbp4nKuOlIR0rJq9waqzenRvdJmxqbKVloWNp7CSjHp+fIh9hoqKjYh5c4CIgYeFiZSeo6COkHpyyHWYjMrafoR4kZF6f96CfXPgpKS/1thyhY6LhJqSoZ6lt5SNnJyitL7GqIp323fWqrfadoWRgqO9v8rD1XRzfN/DfIN+j42VqdN40dW2cMXVdtHSyMy4nJ+uyHF4fG5zgHjJzL9xeHdvfnZ6eXl0eHN3d4Bta8l3cm22lYWYq8vGns64tbKybMDDbG/Nzm+0h6SepnPQwMeVk7avb8x6f5F5x8Wpv6WhiZeEhXHXipSDgoSAinjDyXqBjXXhkJuMgJ2jna+cl56RioSKgX6Kg9annIXiw9+KnpHZdnzjdZSHhH7RfI12coGCdXbDwoOTeYHbdoB4c4eEkYWxrbmgs8m8q5GEjK24scK9raLGZ83MbriTi6CjoJiSj4eJnJC1sKDCy8qsiJ2EdXmLnHByh9DVcXl9cL+2xW5ufJBxdXTExcF7kYahmLi8m5WMmZ2wm42CdYWruLiUg4l9j6t1vMq+ioKRuJBygJykjKmAhH50d4t8fIBnZaK+b12jlol9mpaVjYyFmoF9dYZ/g2twdXd6dG56fXiDe3N+e3h2eXaGipWhf4WOmJ2im5CBgol40KbOfYpwz9qDcoGGg395dn6Fgnp8eX6Gi4B2fYyMjp6RlJSEjpSRjpSLlaKlop6ppKChrK+voaisW2BmY2NjYLKpsFuvW4CzraugpaimqqqwrKKio52TopePk5qkpqioWFVYW1paWqxYWJ6pVpxZqZ2kpJeQioh/eouJjoqIgX+CkpSQjKKcnJqNg3hwdH2LlYOGk5qLjYOEioaJlZV+j5KLgJGHlJqDjIN9gnpxtdHCs6OvwqytoKW2pJaXr7ustp2hqbzOsYCfv8jK3Ny/4njWfX3lybuuv9XcfsS6pcPQccrNcc3IznSEfbq4ucPdzHK7u7xnfISFiHdvdoHRenJvwnNubLllZ2rCu7Brrr/Ju564u7e6wm9t03JpbXV/eIdzbW2zxHlpbtBtc9R3ycx0znd0bMm+wHLXdM27ucxtx9HLvci004ByaGhqaXV4jIuMT19fdnWDeHpjoHNvpod3pbSfmrfCuXR9iIp8en19anK+r2PKt5uboZu7vbWco5GapbR2aby9ZWe8aWZpaWtqZHdqa8FptJ+YqaerwL21oLNsamhvbMallsBzbHeHgHF6e4BvXGDGZmBzaGNjaGdntGZ6gHV6fICBe3Br0XJzcXV8brRgY29vbGdpa75ltGBqd3S+Zmlwc3JuxspjZWdoaGdnaXFrZ9XHZmJmbHB1cXl7gm1rdnl6hoeDfICHfpCBgIN/jJCHeWuStJi6Za9qgJmFhnpuqJGvrZincGdjaIiclp6FiXZ+lZ6Efm5xcX1yent8gXtvbYB7dnp3eoKMj46BgG1qumuLgbvHdX10h4Fqbcp2cGnTmJuyycZreoR+eo6HkpCXp4eEjo2UpK+2mYBx0G/KrbzRb36Lfaa3srq9x2xsctfHd3h3h4aKnb5ru7+mZbXCa8G/sq+ki4+dsGJqa15ibGatrJ5dYV5aY19hYGBbX1xhXoBXV7FhX1qchnqKmrStjrqimpmaWp2dVVmprlyggKaFiGfGp7GMi6KWXrVqaHBemaGOnI2DdIN0d2vKf4V0c3hzemy5v290fGrPgYl8coeMiZOIgId/fHmDdnJ+e82nkHzXv9mBkIPWcnbVbYt+eW7Ec4FuaXV0am+5unOAam/HaIBsZW5seG+Nj5ODjqKklX1xdo+cmaCikIWgV6+tXaSCdYaHgnJsbm53hHqKioSaoaCQeIhyaGx+imZod7m/Y2psY6+mtWJibHpiZmSxr7NwfnWKgZyfg395hIaUhHpyZ3WSnZx9c3ZqepJgmaCTcm13mHlhbYSJeo9vbmtnZ3draQZ+fn19fn+0fgh9fX1+fn59fbF+h38Gfn5+f35/mX6Hfwh+f39+fn9+f79+oX0Efn1+fod9AX6FfQp+fX1+fX19fn5+hn0Efn19fYl+EH1+fn59fn5+fX5+fn19fX6KfQN+fn2Kfhd9fX5+fn1+fn1+fX1+fX5+fn19fX59foR9AX6HfYp+iX+Dfop9in4DfX1+j30Hfn59fX5+fYp+An1+i32FfoR9jH4BfYl+AX2KfgF9hn4BfYh+A31+fYR+AX2GfoJ9i36CfaB+BX19fn5/iH6Gfal+Bn1+fn59fYd+BH1+fn6GfZZ+An1+hH2EfoZ9BX5+fn19iH4If35+fn9+fn+Jfod/g36QfwR+f39/jX4Pf35+f39+fn9+fn1+fn59hn4Cf36Ef4t+AX2IfoJ9hH4BfZN+Dn19fn59fX1+fn59fn59hX4BfYh+gn2EfgF9mn4Ef35+f55+gn2EfoN9h36DfZt+AX+WfgICBACAiPvPtoeT2MvPzdK/ueWA4sHg7eDUxsOztLunsqWls8ShuqikmJ+qnbPBu6muqcvM3M7Y0aKysrWun5yUhomkpqScmLOfnKihmY+WmqCrpqiio5ihycixtLC8v73UyNjezdjk8un+gu7q3e/08vP59P6BgpCKiYmKh4WE/ezm8e2A4eDn9vb41eLn8PTx/fXw8fTr4t3Nw87U5PDg1dTp6vb0/4Tt/vjj4/b29+zi48nVu7u4wrvs18Ha++3o7r3ewqu0sK2km6qzxLqmo6Wsxd7Qx9X309CvqcPTza6yw9DDn6u+zbD31OLo8Lms5sPOtKylo9XjlqOnt9W+zMvXt6CAtbezyZyqwba0466YlbvQ3+zO2ovcsdHv8pyAhPqSg5+C7/HV7YyVhuXqiZnLsJyOjviB94ODg4KKmPqFh4yam5eMxLuxq9nQw8DMusbKzYGG+YiWkOblkZGUjpiNj6qy052yz67Y7f6TouWUo4GHw96tipD+yL7t+4338IOcy6qAn4OMkYuunLG+2YKSs7zJzrvh7L7zg7+mobHExtv3j8mIoqmytbC6xazwhI+bgNTWyefcyOHFwPXktq7P+s/skO2T2vPojf+SjoGKpJKRle+1uK6kvNTJkoz08JqOoJOXkK67kqmZlaKcnY6Tn5Geno6Uh434+IaKgIGSjI+TmJ6AmouI+YX50feko5elvbu7q6SolJaNmY+Ekp+kko2PopCak46PgoiUlY2Dj5mBhIiml4Xi0cLAw9z18+rvh4+Wt6uUgYGctsaml66xv87CoPTlgKf4jP2khpnn7tLbjKCG5efQ0YObuaScpLGmqb65hYWNo5KZsKKjloSS+oyGhoyAh42LiqqrrputvqSUgoSPjvv2jZuJhsqD8fr2gubKq4+una+Alp6hnZuUnqSypZqwx8S/4NnFu7m6t56hieKfrLq4zsLFv66xmqSymYPw642ZnqayzeXE5enk64GGgYCTioLozMHI5urw8f72+vn2hY+YhfSTqY+GiJGLkoaGgomAkpH1gvvg3K/I9dvt2s7T+YbOyNjkm5WGg4Lk+NCxy+fb/6Hry/a8uoHnhYSZkOXIzrS3xdCjuLGinZ+WpOrVl6OrhJDkuJWDlcLsu7S9l6CZsayzrqKcpKuklYSO6+3FwtfdhIGXl5Le9YmpiKyYnoCFoJmQlJukmKGPgJWqlfmA5oCpp7i6u8PN7NPLzr+yzbWwsb3o6eHx8OrbytPEwuDi18qorpOTnLLa7JDRz8bXrJux0sKikpuLgJOqmLGfmZDt/omXhpqnur2knfPD64672525tNmpmpGrwbKgms3V8MrRobiKj4Gr4NzHtKOZn5GNioymmJSZmqCTkJKQ5NKAdtqynXV+ua2xra2lnL9swKLAxLesoaSVmKCPmY2OmauJoJKLhImUiJmko5OYkrGvvK62somam5yYiImCd3mRj46Hhp6Ni5SNh3yDhYuVkZGMjoaNra6XnJmio6C0pra6rLTDysHTa8XDt8bNycvQzNJra3ZycXJycG1s08XAzMaAurzBzcvStL/Cx8zJ1M7Ix8rGvbiroqutu8a5q62+wMfFzGq/zsS4uMjKwsG0tqOtl5yZn5XFs6K3076/xqK7pJWdnJqSh4+Zp6CSj4+Vqbywp7XNsrCUkqGuqpiWp66ghpGeq5fjytbd4baq48HMs7CnosnNlqOpus22wsDIrqGAure2zZypxrW13aiZlLXCydW/w3rRqMDTzoJ1dtp7c4l00Nm813l9edPZfnullYZ0e9dy1nBvcXF1h91wcnmBfn95s6umnLy7s6yyo7OwsXNz23WAgNHJfn6Gf4N1fJucw5quvqjK0uB/j8x8j3J7udKmfYLtyK/U4nvbzm+DqpCAi3R7e3WUg5OdtGh1i5GZno+os5bHdqmTmqG0tsjhhblyh46VlpOeoZXWc3+EcMC/rdDJtMutqdLHqKe93LXPd9GGu8/Jdtx+emx0iH99hdulqKmRqbeyeXTXz4F5hXyAgKCsfo5/foeEhHV3gn2GhXl8cnng03B0aW16dnt9doGAgXh42nbZvtaGhH+FlpecjomVf4F+hntwfIOEenl5i3uBfH1+cHN7fHdxf4lwcnaRhHXIuqqprcLczs3UdXyCmpB/dm+DmauJgZOWna+ihM7KcJfad9eIcYHM28LVgop3ysmysnCDnoyEjpyPk6ShdXd6jXyEmIyPhHSB2Xp2dnuAdX15d5aVmIeXqZCDc3Z+fN7fgI54eLFz1d/XdMu2mYOejZtwhI2NiImDjY+akIuerKymx7+soqOjoo2Se86RmqeitqusppefiJChh3Xb1n2LjJWctMipyMvIy29zbm1+dm7Cr6arxMjNzdfR0c7Nb3V7a8V3hnNrbXdxdm1sa3CAeHjObdG7vJavzrjNsa6wyWyqprDDe3toamy8xLKerMm81X/Fv+qqoG7Gbml2brGfqZaVoquGlZWNiIeDjM/HhY+Ve4LCoIV1iKXLmpmbgIaAmJSXj42Ij5ePhHWB09a5s9HLenqGiIXS5nuVfJmChW1zjYZ5fYWMg4l8coWQfdyAznKVj5qZm6WuxrGoq6GcsJqRmZ+8urnFwb6zoq6qp7mzq6KIknp5hpSwwXKqqp20koOZr6KKfoZ3bH6RgJeIg3vN3XaBc4aPnp+Nh9Ct0XyfuYefmbqQg4CXpJaJhK2yzauyiZt1fW+TvrellYeChn15eHmPgoCDg4h9e319xriAZryehWZunJOTkZGKhqVZoI2nopeMh4p+f4d7f3h5g5F4iX13c3d+d4aLi4CCf5eTnJOZlniChoWCdXZxaW1+fX15d4t7eYN7eG1ydX2GgYJ7fnZ+m5uHiYuSkIiYipydkJajqKSzXKijnKWqp6ywqa9aW2NfX2BjX11dtaqlsKqApKOos7G4nqemr7CxubKuraqppaKXj5WWoaygmJmfpqqnq1mfq6efn6arqaSWm5CYhoiFioGhm4mWqZ6fo4ujk4WKi4qCd36Ik42Dfn+Dk6CWj5qtlpSAgo6SkoaJkZyTfYGOm43ezdve38S85MjMwL60rL7Bo6y0v824v7u+tbOAyMbI3bO3z8jB3bmror3Ax87AwnXQqbfCvnVrbchxaXZpxciyw21yb8zJcXSOhHhscMhnxmVlZ2htfM1laG9wanFsqJ6Zka2urKOonqynq2xrzm91c8W9dHWAdXFrc4mKuZutvarEydB0gMJzgmtzt8uud3rew6nH1G7Iwmd2k3+AfWpwcGyCdYGJmVZhbXJycWt9gHGaZJWFjZipqbnOi7FqdYGEhICKjILHaHB0Y7KvpMC1pbienL6ymp6syKq4YriMrcC8acVubl1ldW1vec+gpaGOoqmjZ2jEu25pcmxzc5uebHlxcnd0dGdocmx1dmpsZm3HuWJkX2JsaWxtZG2AbWxtx2bFsch0cWxueXuEeXWBcHFscW9kaXB0bWpoeW5ycXBzZ2VpbWtpdH1pZmmDeG68sKWkoq/Bv8DDanBzgX90bWdxgJZ9c4KBh5aPeb2zX4LBbcmDX2q8yLXGc3prtbekomNziX53f4Z/gZWVaWxxgHB2ioOCeWt2x3BrbnGAbXJtbIiGhHeImIN4a2xwcNLJc31wbaVqxNHHab+okYGVhZNneoGFfX16gH+Ig3+Wn52Wsqyhl5iWl4aJd8yEkJSTppmal4iOgYuTe23R0XaDgYuSqrSbt7u0uWJoY2NuaWCqmpKXqqqysr+3sq2uXmJjWaNeaVxVWGJbYFlZWF2AZGSuXLahnYSar6Gxm5mVqliRlJWlYF5SVlyhn5aOl66ktGiqveaZjV2mWlNaVYmCjYN/hYVwfH+AfHd4e8G+d32Da3Oii3pwgJy1h4aIdXd3iYWEfYJ+hoeAeG96zc65rcjBc3KAgn3M3nKLc4t0dGFqfnpucnd6c3duZ3h8bcqAvmqEeIGBhJCPoJqOjoiBkIB3g4aVmZufoZ2ZipOVk5qNhn1weGhhbHeMkleTkImUfHKElYd4bnZqY257bn14dGu3yGhxaHR9hoV5dLufxG6HnHaJhJ16cW+AiH93cY6ZqpCUd39jbWF9opaGeG5rb2pnZmh3bm5ub3JpZmlqq6MDfn19i34Bf9d+AX+Kfop/p34Bf8J+rn0BfoV9BH5+fn2EfoR9BX5+fn19h34DfX59hn4BfYd+jX0Ifn59fn5+fX2Jfoh9A35+fYR+BX19fX5+hX0Dfn19jn6Kf4J+in2JfgF9hH6RfQF+hX0Cfn2Ifoh9BH5+fX2GfoJ9kX6CfY1+BX1+fX19qn6KfZN+Bn19fn5+f4R+hH2DfoR9l34BfZR+gn2EfgZ9fn19fX6HfZp+AX2PfoJ9jH6Hf41+hH8Bfo5/An5/jH4Bf4R+hX+Ifgh/fn19fn5/foR/j36CfZ5+hn2FfoJ9lX6Cfap+AX+VfoJ9iX6Dfa9+gn0CAgQAgIiP9+Ki7oXtt8DSpb3C3cDO6PiOlPTmxLWwn6jDvbOxppentMKuwcHDsrW2rMrC1+CnqLmqtK27spyKlJytrJuho6Wbpr2xtK+ik5SVpb2xu7CvmKDMzLvHvcbG0tTM2eHXxszq4uX16vj26ejo8PP8hISF8faFhImB+fv18/negPj39PL04evl5efp6fHo5dfHys/L2+Pk5uiBhIWCgP713+Lk9tPu9tuB9tbW3NSztamxxdfxgOzrvqCmu8OmwLiyxMeyoJmxtaahr6aorb7DrsXY4+C4tK64t7S7pKvRp8u11cSI8YPq+vXe8YnLj4C0svnnyKjJz/2I3YjT2rO3gJV5nZ+zraTb2/Hjg9uBlpKFmJz39vKSo46PkYmCoKGoo5KenIu0pomAgYOfpI6TgfPvg/6akoWAg5erqZ2Wm5iO9OTk+4iAvIaKpcGvla7b44X1nJ7lmf3xh4+g9P7sg+z0qYWbyImUg6X7mYqC1cuIg5CGipn8jaSj/4SqpquCgLrDluaBobKspNGEqqy8pLW7wOPlqM6S2YnqzKu4kZLrmZH1oZ6dqqSsoPaPpKKai4CChIb7/fHu78Xin8jN+oujsn67//CEg4Dv39f5gPPAoaeYnbjU0MTv2PGLk5qem5jYhoqqqZqqi4yJipaloI2DhYL2hfGDhoX7gpCOhICFgI2L6/D1/s3NuuCNiJm4vq2mq6qfpaiB/Imbn5KMlaGSl5akl5ePlouUlYWAmJugkYSHhoOD7ePmyvDm1d3lgImJhJaN65San6GQq7mwiODU7Yam2cKWjo6fqK/B1ta20M68qZ6UiY+cp6+Ym46lurS4qJOIlYOelISMjYeFh56kgJOZhY6ttKadj5WLnpuSg/SjmZWGl6noyfj52/aJ9OWArpKlr6OPg5aZurmpl6ShraWjrqqkq7ampLTNusrT7ODIwubg3drJrLytnaiymp60vKiqy/iG3tbKgf2Bl5iZi+7dzMfOyeaE9Ojf9u6D9ev05d7YhJiRlZKKjISIl4WFgPWGhf3ws6zM1+vyyPP8+OK/vtLujIyH7vS43fqz27KjteD9gru+4oCbnvn25NCaj7uovdjHsbXcvrKtntKvlJi2z8WjvK7U+eaGp8i+rLi+mKmJ7cLHxa6fltLniISA76CHi62c/PSL7vXIiZSekJiLmaqfk6ailpLCvpWMjISTgJe4t8CvqbG/vtXNw8fz7+XO18vT0uLX297z282dwdDc5vnvuPb7rsje7frV7oaI+7vItcXouKaYlqOKgYyqv7GbrZ6ijIbu8KO1pJCa57ORpLeYj66guqWwttGorq7YyMDZ0raZiaOVkKvT9NvCtZWdr42eh7CuqpSLr6/6vaP+gHZ728qLxXDJnKKxi6SkvZ6mushyeMS7opeUiY6ooJmYjYSTmaaTpqaqmpydlK6ouL6QkaGTnJShnIt5g4iVlYaNkJSIkaWcm5mLgIODj6OZoZOag4yysKGqoqiosbKot7qypKvEvL/NwM/NwsLByMrNbWxtx8ptbHFrztLMzNG5gM3LzMzOvMW+vr7Av8jDwLWmqquptLy6vbxqamtqaM/GuLi5xq3Dxq5ox6qttq2XmoyWoq7BZsDGno2Nm6OOop2cqaybjYecnpGMlpGSl6Snlai0vbyfnJWbnJeekZCzkK6btK144Xna6+XT33q8gnWysOXSu6fGxeV8znfHz7G3gJh8oaG1rqbSzubWesd2g4F7gofe2tF4hnV5endrhISOi4CFinuVkHZwc3SGjHl+cd3Wb9SAfXRyc4CKj4Z9f3x319bF1HhxtoF/la+eiZrBxXXYgIjPjOfZdXeJ0N3OddPgqn+QuHZ/b47ol4yDybt5d4J1eojfe4mM4XGRipNwgJimh9NxiZeTj7FsiYiWg4ySk62whaqAxoHRt6KlfYHQhoDWiYaHlIeQitx4iIaHd3JycXTd39jP0bXVlrOx0HGJq3+m39BzcW7Tyr7PbNiolJaOlqq7u6zWwdF2e4F7gn69dXSQjISMdHZ1dICPh3lzcHPbcM1tcXLQanl7cm5ygHl4zdve3bm4pr50coOYnJCHkI6GiY1v2XaBhXl8fIh8fn2HfX12f3WDfHVxhoSKf3F5d3FyzsfUvePSvsLIcHN1c4V7036Cho15k5mObry82HSPu6R9eIOOkpalsq+UrqygkYl/d36Hj5eChXuQoZqfkYB4hHKKgHV6enV0dYuOgICHdn6XnJGIfYV4jIeAc9eQiYZ5h5XJs93bwdl52850nYGRmpB+c4OGpKGVg5CPmJCQmpiSmqGSkqC2p7S5zsSxq8zEwMCulqiajpGahI2fp5GWr9d0wbisb9txgoKDd8q9say0rcVxzMK60cluzsLKvLazbHp1eHRucmtve2xsgMxwb9DIlZKstcbNqM3Tz7+hoK/AbWttu7matsuWsJSZo7nMaqKjwGp5esXEs6WCfKCSpbSikpaxoJSUjbeXioefr6eNoZjH6tN5kKehlZuig5F55KaoqJqJgcPYenh25JF/fZyM39d65OO3eYaLgIR2gpKEfJKMh4OooYJ8eXGCgISemp+UkZ2korewqK7PxL2xs6y0rbqutbLCr6mHqKyuu8W+mNrVlaC1vM+tw2tvz5qtnKXEmIyCf4t5bHWVpZmFl4aIeHPN046Zi3yEy6Z+j5yDfpeKoY2XmrOPlZG1p6K2rJuBdo1+e5CuyLKil3+Gl3mKdJaQkYB4l5bappHigGdovLJ4oVyqhImSd4yLnoSDkaJcX6GdioOBeXyMhYSDe3N8hI59iouPg4SFgJGMmJ59fYuBiIGLindsdXqEgnZ8gIB1e4qFg4R2cHV2gJGJi3+Gcn6hoI+Wjo6OmZiNmZuTh5Gnn6WvoK6to6SgpaSmWVlapahXVl1bsLexr7OagKqoqa2vnKKgoqGioa+qqKCUlJSTm5+gop9bWlpZV7GvoZyeqJWpq5VZq5aapJyNi4GDipCcVKGkj4KDiZCEkpCKlJiJf3iIi4B8hn+AhpCPg4+bop6LioCHhoOKfHychpmMn5p14Xbc6d/Q13e+eHXAttPKw67HxN13x3DCyLa/gKiTp6m5vLHNzd3VdMhxd3hzeXzTzcFtc2hqa2dhcXN9fXN4d3KFgm9qbWt6e25xaszHZsNxb2dpa3R6fndwa2prycG1vmxnrIJ9jqKYhpe6vW3JdXvCftfJbHF4v87GbcTPp4SPrW10aH7copyRxbZxbnpub3nOcnl90WR2eIBngISPe8JoeYeEgZtcbGx0aGhrbX+AY4ZusnS+q5ejcnLAdnPGeXl7gXaAfMxtenl4a2ZmZmrMx76/wqvEka2kuWB1pIegyb1jZWTFvK27ZMigkZKLkZ2rrp7HusVsa25ncXOwaWh/e3N6ZGpoZXF9eHFnZmbEZLVgY2S4W2lwaWJlgG5wwMjEzK+pn61hXmx8hntzfnx2d3ljvWZvdWlvbXRvcnB2bG1obWlwbmlmdXd9d2dvb2hpxLvDtdDFtbi/aWtsaXNvwm1vdnxtfYF4YqypvWF3pZhyanN+fIKOnZyCk5ONfnhxa294f4Zzd26Aj4uQhHVueGqAdWxubmxra4CFgHR1aHCHi4B9cndufHpzacuEfH1vfIu9pcbLs8t0zL5ljnaDh4R2bXt9lJKGeIWBioWGjo2HjZeIhpGmk6OpurGfmrStqqudhpWOg4SNfIKWmIWGncBmsKyeZcVidHR0Z7Wrm5ack6xjr6eitbJfsqeqnJeUWGNdXVtZWlZcYFdZgKtdXa+og4CSnaywk622raGLiJagV1dZlZKFlqKBkoOdp5qqWI2SpFhdXpqZkIBtbo6CipGEeneKgXx9f6KFe3qKlo19k43D38Zxg5GNhIqOeIRw0pGRko1+dLjOc3Ny2Yl5eJGH1cxz3+G0cX1/cXltcX95c4R9e3eOjnhvcGdugHaGg4eBgoyMkp+bk5itpqWamZadk5qOlZaWi4h2jJKOmaCYfsWzeISNkZ6PoldbrIOSh4yhg3pzb3loX2aBj4V0fnJzaGe8v3qBdmtzuJ1tfIRyboF6iHiAhJd7gX6Ui4mSjIFsZnlqZ3iPopGFeWxyf2dyZH55eGxlfn29mIrMB35+fX1+fn+MfoJ/3H4Ff39/fn6Ef59+hX+KfgF/jH4Bf69+An1+hX0Efn1+fol9A359fo99An59hn6DfZp+BH19fn2NfoR9gn6KfQ9+fX5+fX59fX5+fn19fX6GfYR+hn2GfgV9fn5+fYh+AX2Gfot/BH5+fX6EfQZ+fn1+fn2HfgF9iX6LfYJ+hX2DfoR9AX6NfYZ+AX2Rfgd9fn1+fn59iH6IfY1+AX2dfol9hn4BfYl+g32+fgF9hn6GfQN+fX22fgZ/fn5+f36Ff4d+AX+FfgF/hn6MfwN+f3+RfoN/iH4LfX1+fn9+fn5/f3+cfoN9in4BfYZ+Bn19fn5+fYV+Bn19fn19fbl+gn2HfoJ/l36CfYV+gn2tfoR9AgIEAIDR14/7tIXY3Mu2va+hwZzrjM7w2pKK8tvQ7dOqweTTqa2wtajDoNrbs6qsz6i3oIykprmkscjLtMC2u7Wpt7urorawq7/Kz+vS4bKuvb+wpqWwwsezp7HEwMbQ1+XXz87EubW/3/jp6PjxiID4497g4tLZ5PDY5+zo6/D59+6CjoCQ/u314+jn6OTc3dPa2+jS19zo09Pr8fL59vvv6On8+f7q5unS3MrPz9TQx7K6xrivwL6ywLrBq7TPyLCyrby82uHotsOvt7PGwrCwtMOuwcjKusXGs8qtxMmVo5+ivb2wvLCErMaC2e7mj5OcgY32jpOBh+XdlZGQgoD37tyxooCutML45JDv3PaKgafuhJWpsbKnr4+Mo7/IyJiQp8m9rJj7g4SKmInyjpSQhoaD/fL2kZKMm4+zltaVmuqEmo+xoJWXqP39icehgKjnjqehsuaApZDj4Ibz74WA//+X/uiWmfmN03qf34L3qq53x+qBk4GJhZKFpISm1KquucKHwYDlg4n9h56apLTPkJuq3r6kyNTS58eKyqD91uWqso39/JOPiYq3j4yTmJ6G9YGRltuu2/XQ1ujzrcjG187B2veMjqP788/L8Nnmx7DGr7jMzeDNp7mkudbClN66wcWBhZiKkJeCkaSapZHM8YWRjpiDz9WE7fHo1eXuhO/3iYjo9oDr5/GZ78iCj5SLk4qtv+uUuKimpIKPipWRn5WIl5KZlJGKjJaUiZaco5udopucnY+Q+Ojo6vP/kpnNyfeB4/iB8YCQqqGloZOUnK+4qqm3ysbAw8C5ts3T0dLGvK+hnLe4x6KQlvj1mpaVkZGOnpymsKCdmvv6h5OgpaOvs4aSnICPlazZ27+8sqSZl5OQiO/h4ePsjoGehNn2ornHt6WYl6Wrvbqzp7qxrKmbnqGWjqigpYiKipCNg5ylmZmdq66vqsDXxLvSx92yqPaEg8PP39jHzefNzuLyzeKC8PKD/Iedgt7RydLJ5YaCh4KMg4OH7/b54oL6ifWChYuUi5CJ/ID2+fPmguzi3dji0crV1s6xv9X3kIDK69rBj/TQzof+4OvH/v6bhbvw6cyy4NW7oa+5qqO7psuuwo/D3ODt1r+a17eRiZujpsKuwMqvkpu91aqRkqes6b6tk4jS3Lj7rZv7/ZCpk+WOmZfw3rzl//yBlq3Jo46IlKeWmaaPjpSpuYC+u7bCtaa6y7Cyxszn9/Ly5MnJ2sLPuZaluMjQ7t3g2bjD8cajk6K609uV98DF1KbEsrmipMm9q5uMlaqunqijr7OVuKXFsY3exZ6Qkc6294uoh+mMoruso6esjpKdrN7o09fN1LGMrqSKmaS0rsnDoqOWrra40LCRk6qpoJ7xv4C/wX/aoXa2u62aoJWJooHGd67Js3dvw7Klwa+Ro8CxkJOXnJCtiry9lpGWs4+ei3yNj56Mmqyrl6Wcn5uRnqKSipyWk6astMixvpaXoqSZkJCWp6uajZeno6iwtr+1rKujnZehvdHEwM7GcGnPvbi6u7C1vsmzwMfCwsfSzsRqdIB308bHtr69v763ubC1s8Gvs7bDsK/DxsbLytHIu8HMzM6+urmntKeusa2tqJeco5qQoJ6YoJ2ilp2zppaUlKKfuL7CnamWoZmpppebnKeWpausnaapnK2Roa2Ci4iIoKGVn5h0lq15z97WgIWReILogoV3fdfQfX58dXbj2salooCqqr3n03/jz+SDdpDKd4STmJaUkXxxgZ6hpYN4h6aelYbcbnRzgnTReICCd3Fv3N7ae3t3gXuch7h+hclwfnaQgX14jtbfe7ybfKfmjJqOo8VsjH3LvHHS03Vw3NqF5MqAg+WP3HqQxXThqLh7wdZ2gXF9eX5ziXKJsI+QnqF5toDQdXvedIaBiZepdHuDrJuEnaGisZpzs4vgxNykpXra2H56cnybgHp9gop42298g8WcxNS6u8rcm7GxwMKrv9l7d4nj2Lu3173NwKWxn6u2uc66mKaXr7qzjsilp6xucYJ0en1veoiAjXy50HOAeYZyu7dw2NvLu8jOctHTcHHJz4DXy89/18KDjpSDh32gq8Z8lYmLiW96cn18hYV2gHuAfHx0eIB7c4KEi4KEh4SGhnt/08/S1Nnbg429t9x2xtly03WAkIqOjoKAh5GWi42aq6Ogn5uVk62qqqiem5mHhJybqot6gNnUhX9/fn17iIaQl4uJiODbdoGMjoyYmnOAi4B8gJS4uaWjm5KGhICAeNTK0cvTgHKMd8DZjaGuoZOHipOVp6SclaaclpSHiouDfZSMk3h9fX9+c4yUiYqMl5ucmavArKK9rsSakc5zb6yzw7ipscexssXSscFwzNBy2HOJb7+yrq+rxnNtc255b25xyNDLu2nLcMhpanJ6cHNtzoDKzsnAbcS6t7XArqqzsq6VorPOdmupvLCeeuLKwX7t1d+t1c9/babIvaiStKyYipmYkI6hj6+Qn3yqtrfBtKSFspV5d4qUlKKTpK+ZgYSjtpN9fJqYwaKSfXm+xq7hk4Xh6YKUgdJ9jJDc0LHW6flyhZGpjnd1hZSKhIl5eoGanoCnmpmil42eppqXqazAysjLvqmsuqSulHqLlqmwxLCxrpWgvZmAdIydrbF4yaCitIqkl5uKiaSdjoJ3f5GRhY2JlJR8m42mlXnApoV7fb2m4XuTc8l5jKCUjJCUeoCHlL/Esrass5V2k4p0g42blqygiIyAlJibrZR9gJORiYnTrICrrnDClmqcnpB/g3x2g2unZJankV5bn5KMo5R/i5+We31+hHyTeZuef3p+lnqFeW97fIl9hpWQgI2Ch4R5hot7dYV8fI2VlqOSm3+AiIuCfX6DkZKCeoGPjZCVm6WakpWNhn+Ho7Okn62jXFewoZucnpmgoq2Yoaqkpaewq6BWXoBhr6KimaCbnqCdnpeamaiVmp6nm5imqqaorLWsoqapr6+ln6SVm5WYmJmYlomNlYyBj5CLkY2UjI2Zl4iHh5COoKqyk5iGjYSTj4SOiZOGkJSXio6SiZiCkJhzeHR5g4eDjoxyjJx21N/SeHyGdXzleHxyc8vCbnN1b2/Zzb+npoCtqrjXxnXazNx5cITJb3yIjIuEgnJpdoqMkHVrdoyLg3rMZWlocmnAa3R2a2NjyMXIcW1rdHCLerFxdblmbmh3a21tfsPRca6VfZ/1iJOJnLRmeXO9smfJxWxo0Mp51MJ0ddWU7YORu2zVsOOJvs5xeGt1cXJre2h6knt9iYptr4DIbG3IaXZyeoSPXmVnh3lreXl3fXJYknfJsMiYm2zHx3JtZmqJdHJxdn5v0Wh1eL6ZucWvr73LlKWjtLOissFrZ3bOvq2kvbC8t5+llqKsrbmskZ2TqK2ribmbnqJkZXVra2pka3NwfW2tumZwa3dqtqtnyc29r7vAZr7AYmW7uoDDuLlvx7eGj5SAgoGenrRvfXZ4eGNqYWptcnlqcW9wb2xoam9vZ3J2fnZzdHN3eXNzxsHBw8zHcX+vqsFps8JnxGpxe3Z6fHR0dHl+eXV9i4qLhIF9fIuPjY6EhIN6d4eKmXxvdcW9dnFxcHFuenh+hn58esvIbHR9gX6IiGh1fYBwc4WeoI2Oh393d3d1cMS7vb/FdGmBabTMf46elYl9eYWLl5eRh5aPiIh8fH55dYWBhnJ1cXl4bIOIgYSEjo+TkJ+rn5itoK6OhLBlY52hq6yboLSho7C+o7FnvLxmw2Z4YqSdmZiUq2JgY2BoYl9fqbGomlWoXKVTVFxjXFtZqoCrq6ihXKacm5ukl4+WlpOAjJerYFiOmYyBa9G/t2/VxdaWta1lVouemIl0iomCeIOAfHmFe41zhG6OlpShlYh5lX9ubX6FhYuAjpmJeXeNnYVyb4eHoox/b263uqjThHnU23iFech0gIbazafF195oeYCQfGhpdYJ8eXhra3KKiICOgoGJgnqCh4GBlZilsbCrppeYoo2Xfmp1eouUpZSNin9/i3tsY3SAjY1aoIaJlXaKf4R2coSCdm1na3x6dXp2fHtpf3iKfWuuiHNtba2dzG6BabpseYh/eHyAa3J1fZ6gkpeNkntje3RibnaCfo9/cnZte3+Ci3lrcH99dXW6nQV9fX59fYp+AX2EfoJ/1H6Cf5J+g3/mfoN9hX4BfYR+gn2Ffop9CH59fX1+fn59lH4BfYV+AX2GfoN9h34EfX5+fYh+A319foR9AXyFfR5+fn59fX59fX5+fX1+fX1+fn19fH19fX59fXx9fX2QfgV9fX5+fYZ+jH+CfoV9A359fYt+BH1+fn6QfYN+m32MfoJ9hX4DfX1+hn0Ffn19fn6FfQF+i32ifoZ9Cn5+fX19fn19fn2kfoJ9jX6CfZh+hX2EfoJ9sX4BfY9+CH9+fn9+f39/hn6If4R+BH9+f36Hf4V+AX+OfoJ/hX4MfX19fn19fX5+fn9/tH6EfQt+fn19fn5+fX5+foZ9u34Bf51+AX2Efgd9fX1+fn59qn6CfQICBACAkIWKpoCDwJiUm9G+xYGil6Wqr5XI27jMuKiZlKO7w7+xo6OsxqujsLi0qrScoKCku8qsx9vEv8bHvrmqsaOmr7W32cnRxN/dz8zP1bzDybOspKKsyL+tpMTQvc6/wLnHzs26uM7MxLGj0oiMhO7n84SJg+7n5uv09oSBhYCA/4aA/4SEiPbq7eLm++TX2dPj5dPW6ebV6IL/+IaQkZKLhvXTxcnX2uHgyM7Guru/wLu8tJCrucTM08LCvLOpu83KzcLF5t7IyK+mv7ixt9K90+/U0Li5u8Cr3cvXwb29o7bT0s2qn6WBh47ghaClnv+WroPvgf6an5CI+Y24h+r57uCA2N/OiaKJl/iLiI34obu7sLvEoLaQlrTU3b65w7ukq9G4u4ukrLiakJa0g4mXyPz6l5GLl6uUpqeNkpmBi4iLka2khMmz0NSJq43C2dPu3tPxguHZ2PvvhYmCuKzLhJOZlumUeMZ52vbhyJKs9ZCFkpSPjZiOgoCGuMK6r6b/k9CA26mTj+iV/Zu7x5WbprXi3d7u4eTVyaSKwJqvjfiBjoSioKSfmZ+XjO/XjJCUje/rxNLBusfV5faC4LWkvNOEiIqI+oOTkZWFh4Ll4Mvatqi8x9DKoanfxqvK7dXGtNbZztjxiYCJioyXh5fy6Ib+kf2t3/r4hIqUhPz136/iiNWAwuH1j4+A8rWbtNDsqpnD1YqNppyWipWKjIqinI3mlIqD/Oz5gIuMi4mIkIqL+fHwi/f5+Ova7pWXhO7s8/bVz+jz2pKbg5KuqKKViqnBzLSwpqqttq+gkI6ersusr66lp7C5n7m5zr6wr6qqsJejh5qamqKToIuJiKiysKmjprqAqJ6ZqJaunKKkm6eoj6ufkpKcs6GQ8/OWm9y/xrafn5SztcfFsZyPiI6Njpuek4KAjpGhmIaNiImPnIqHorOjt87iyL/Bu6/K1c7IwMrd3O7t2+bj6ezw+oLh8PDv8vyFh/vn0fv28ube29Tg2c/Zx7muv7fJu8yFkpuCj4mRkfqA+4eD38zp1Pv58vfmz7yw2N67ua/YxLqmqoat44a4nY2agubvsqTy0c7GzOjs4cq+8snJxa+XtLa+4ODk3cWurMnPspigyM7N0NjKoYOirsSripStkKWQlJiK+O7DiKepkLDJqo+HqJ3llLvRg5qejfvhgo2QjouWppuWhKSfqZqAv7nVvK+xtqnFwcv2gfvy6/rz7L6ZnqCxqJuqt7azv73Kvb2X+pS+yuff3Li5zoPJysC4o6vKr6CzraiqoLjDrZSdkK3Ur5uwkIunqomA5YqjjqCmxr+1uJ2Qj5+dl6CuxNPE7cq7nZ+JjZCoxLnL6ce7vbGkqae7wbPAtrOroqCAfXV6kG92q4WBg7Chtnudh5GQloWvu52rnY+Dgo+fpqKXjYuUqpKJlJyXkpuFh4qKna2RqLumoqeqo52Ql4qNlZqbvK2ypL6+rqyusZykqpiVjo6UrKSUjKayobCjpJ6or66dm62rpZaJrW5ybMS/yG5xbMW/vsDKyG1pbGdp0XCA0GxqcMnBxby/0r6xs6+9vrO0wcCxwWrOyWtzdHhxbMSrpKewtbi5pbGhnqGipZ+jmXuNmaGmr5+onZiNna6sr6Sqw7upq5aOpJ+ZnrSjtMy1tZ6goaaQuKyyoZ+ejZuxq62VipN3hJLTeY+UkO+Hm3jgd+uIjoZ+6n+bdtvg1M6AytC/e499heh+eHzgjKGbk5mpi517gpOvsaOeop6KkrWhq3iJjp6CfH6XeYeRsd3Qfnp7g5SDkJZ9eoVyeHV1dYmLbrSiu7mFsImvyrzOxsHVcNDDutTLdHVxrqKybn2KftSTf855x9jNuI6h2n91fYF8fYZ9c3B2n6KglYzhgsCAy55/ftN/4YOconR8gYuuqay3rLCknYZ1qYacg+twfHSNh42Gg4qDdtDBeHyCf9Dbt7yrpre/09dzz6aZpLZvcXZz0W58foF0dXPT0rXAqJistb64l53DrJ6vzMG3o769uL3SdW5zdHSAcn/a13zkfvKlwtrVdXiActjWv5y/crmAscvZenpu66ucrcLcpZjBwHZ8koJ+dH11dXSIh3nKgnJx3tDZbXN2d3N1e3N21dPPedXd3NLC1IKAb9TO09W7u8nXwH+GbX2QjYl+dpKkpZeXjI6Ol5CGeHmKl6uNmpSMjpaei52esaOalpKRl4OPdoaHho5/j3x6dpSdmpKNkKSAkYmEkYKXho2Ph5OTfZaOgIKMoY1/2tWFh8Kkq6CNjoKdobCtnImBeoGAfomMgXRwf4GOiXiAfX6Ainx6kJ+UpLfFraWpo5exu7OvqbDCvs7MvMjDyczP1nC/zc/P0ttzddfItNrSzsS9vbS/uK64qJ6ToZqom6ptdX5qcnB4d86A0XBstqzGsdLSzNDCrqGWt7udmpG1opmNk3ee03epjHyEeNDJkIPFs62or7/DvKucyamopJKCmZmpt7y8tZ6Tl6amlIKLqKqrsbKljnaTlKCLd3yUf41/f4N43dm8fpCQgZmlkX57lo3UirnDe4aJeuXPdXuAeXh/kYWCc5CKnouAoZm0nJeYmpKqoanMacrFuszIw6KCiIqaj4aUmZSSnZqom5d90XqcpL25tpqaqWyjqKGaipGplIeXko+OhZejkH2FeZOykYKUe3eOknZwzHqPe4yNqaKZnYV8fIqJg4yUpK+lyaeagIZ4en6QqJ2qwaSdoJWMkY6eoZaimpuTjoqAbWhre2NnkXVvcJCGqYCed3x8g3WanISRhntwb3yKi4aBeXV+jXl0eoF/e4Jxc3N0h5J8jp2LiIyQjIV5gXZ5gIOGopOSiJ6ekpCSkYKIjn9+e3t/k49/e5CYip2RjoaSlpeEhZSRjIF2lV5gXKShqV1fWqKhoaCnollWWFJTql2AqldVXKWjpp6js6GWmJafoJaYoKSZoVqxrFhhYWVfW66ejpCYnZqcj52OjpORkpOSjHJ4g4uRmI+XkYd8ipmZmZWZq6iemYF7jYyGiJ2OnrCfnYiMjpKEn5aZjYmFeIWRj5CBgIl4lqnSc4WKhumBj3LVcd9+hHx44HeMddTRzseAxczCcoF0fN13cnTWe46KiI6Xf4txdYKbmo+Nj4l8g56Rkmx3fol2cXOCboyQosnCcmtudYB2hIdwcHhoamRmZXF0Y6udsq6GzIinuqy7t7PAaMC3rbq3Z2pqqJqoZnF8c82biOOBuczCsZCeznVqcXh1dXhwaWZrjJWJgH3Od7WAvqR2ccJuyHaEhlteY2yCf3+EfIJ4cGZcjniJdNJocWx/eXlydnt3b8m8cHJ5dsXQrLGioau0xsJowZ6VnqdjYmlnw2VsbXNoaGq9wKm4opOfprKsj5i0opekuK+sm7Szq6/EaGNpaGZyZ2zFznXTc+CetcbGaWlxacbCspSqYayAprnEaGxl2aqdp7DKp52zrmluhXhybG9pamZ2d268dGZm0MLHY2VpbWhqcGlsycW/asjQy8K6vXFzZcS9v8Kxr7nIsGd1ZWl8fHlyaXuKkYWIfnx7gH13bWt5gpN9jIR9f4SMe4qJm46JhYGBg3SAaHd5e4JzeWtqaYKLioKAgo+AgHp1f3ODdnp+eIKEcoiEd3R8kIJzwsd4fqqTl5KAgXmOlaGdj391b3R0cnuBdmtpeHWCfHN2cnR4g3N0iZeNnKa4opaemoyjrKOfn6Wur7e6qq+xsba6vWSqubi4u8ZmaL6xoL24s66oqaKspZufj4iFiYKNg45bYGNWW1lhYq2AsF5am5WombCxrbCjlIqBnZyGf3qYh354fmiWv2yTe3B1cLOjb2OclZCMkpeVmIl9oIuKhXd0hIGLlp6dlIR9g4yGfHB2ipCRlpKJe2qEgIV3bGp9boFzbnFrycWxdoOAdYiQgXl2jYLPg7K6cXl7btTLbHNzbGxugXd1aoGAjn2AioKWh4OCgX6TjJOtWqilnKmrqZJ6eXqEfHOAgH2BhH2OhHZkr2WBhZCUloWAilaGiYSCeHuOfHaAfXl3coGIeWxwaX6TeWx7a2p9fWdiu2x/bXl7j4uBhXNsbHh1bnh/i4+Lo4V9a3BnaW98ioOOnYeAhH12eneAgn2Gg4N+eXaMfoN9234Jf39/fn5+f39/hn6FfwZ+f35/f3+SfgN/fn6Gf8d+g32Efgd9fn5+fX59hH4EfX5+fod9hH4FfX5+fn2ffoV9k36FfQF8iH0BfoV9Bn5+fn19fYR+BH19fXyIfZB+DX1+fX19fn59fn1+fn6Of4R+AX2LfoJ9hH6KfQF+hX2EfgF9h36ZfYh+BX19fn1+hX2EfoV9AX6EfYN+in2Nfgd9fn5+fX19iX4EfX19foZ9g36JfdJ+gn3BfgF/hn6Cf5Z+iH8Efn5/f5d+gn2IfoJ/tH6DfYt+BH1+fX2EfoJ9mn4Bf5d+AX2JfgF/n34BfbF+AgIEAICvmICFrM7xhI7VxIaViYORiuiG7IHmzbbLtYym0tjt6d68vdbCvKC52MK1rqG5qbLBwbq3rLXGxNbHzsK1stG1t6ObqrW2pbi0rLC2yb+/v6iyuLm2s7WmtdbFqcPV4OTW0M3JytPExa36npuNqdXr5+Hn4fP96ujt7Pb5goSHhoCHhYDv+//88e713dfT2unp4tvZ6OTw2fbuhouJh/3w5vXl1eLq5trWw7XPzru8w8Sut8DQ5efgraWqts7PyNXcycbaxbDFurfIzsHJ39HKvM3Zu7bM097QxrnU18inscbRxLW0s/2gu42VrKfwpr6X9Z6ogOLzyfaIkYCxiYGxy4CejvfX/Ij9gaiempWJkfKqtMW7sKy13c7Hybu2up3Lw7+4tZaolPKYtIPL8dLL8IiViIqag4GEpK6tm4ib7e/ehoLfuMr99bfbiYeIlpH96IKCjpOnw7iFpcLp5ZaBj6OTsqzDsL7yhbq10NaauIyNhfGgtZumpZG05c6ywZX4iYC9cnHRkbHlktn2pqScxdzx7vaA6uXi47+H4quWlt7X5oSPivXxhKWjtezWlZqF+tj+/Pn3vcjH0P3b59Xdw/iKn/mqg4+SoJSRh4uFio3RwKG/0LrO17/+48HM19vUh9e6zN7R5fr7ibKIkJee49HW+M2l4IT5hIiS1/z+78yBi4CRj5WguMOnrqCpnrCr6N3+iJmLiIKEg5qRj4uQjOvO/+fYw9DLz+Xw3uTb08757en8iIH65dfgv8PF4r7D5u3b6fL+l6SEjpCZnJKdsLbPxq2qv6SmpJGdiYOJjIKCmKilpqeoj5epq7+rrJ6bjomXnquhsauTp52W6IqSlIiPhoCVq5aci5CSjZmMk5iNmZGnmauyrKiskq3GtJWTxM2qsMa3rYyH84PzhIL2/Y6ek4iNhfCVpKCPgO/w7fuKlq+urbu+sLm8s6nH0s62z+Dm7t7l/v/69ID4hYWOgt3e5e3++9jQxtDM27S0uMbMrLWmpcvBzt3t84OknJKbmYuNhoCGlILb4+vU5uzny7S3wMzYvcS7h6G+uuSit8r3jZagtdLdhaaZ/f7f4832ioXXw9vTzc3N1KCbnMOxo7KnrLDd3Puxqb6XlMnutMOxvbPG2aKWpJWalIr5s6ueqN/ohq25s5fGpKKHgMLS2Y/5lbW1g+b2/Y+YlPW0yqSZkd6JvoDAvLu+ns3L0Ly8xtPS8PDk+tfUie2pzdLSxqyzsri5va3f47+lkszM1ODJ1+vs3+Xtto+TpsTQt6WamK2T5OK/p7HBusbSxqu0qpeFh4yQoO6BoL/GsJmunsjMzsWsmbrCr73XveDbrJadno6etNzpw6XMvqWfr6+Yj8Kbu6mHi4CbhXN1l7vYdYG+sHaEeHSAdcVvxWzBrpuwmnqStLfIw7qho7eloYidtaWdlYqckJinpaCflJqppLOjrqOYmLOcoY2GlZydjpyblJabq6akoo+Znp+cmZmNm7apj6WzvMCzr66qq7GjqJPbiYd7kLTHwLzBu8vQwcHCxM3PbG9wboBwbmrFzdDPxsTLtbCttMC/ubi1w7/KuNLLb21ubs3IvMq/r73Au7Wxp6Cuq5+epKeSlZ+turm5k46Tlq6yqbS5qKiypZunnZ2rsaisv7OupLK8pJ+rsrmsp5mqr6mUlKevqJmZm+mhsH+GmZXbk6aH442UdtjlveN5g3OsgniqwoCXhunG4nrrd5SFg4N1fdGQk6OelJSTtqqopKGWp4myp6ecooWMgtWDoXm12cG803SBeHiDd29yipOUjnmH4da/cnLMt7TS26zFdnVyfHzUw21te3iJopx3oLHXz4Zzfo2Dr6u5qLLQd7Wuy8uDpXl4e9WHmomNjn+Zuq+Xp4bfe4C6eHTHfZnOe7HFgoN4l6e5tbxlurKvr5hww5mFis3C1HN+edPScJCLndvDg4t248fj3+Hjvbawv9e9ybzJr9p1heKdcHh5hHt7dHZxdnvJtZ2xw6vBwavex66yvca8dsCuvdu81N3fcJFyf3yU1MTC27uXxnTXcXN8u9Xd0rdvdoB7enyEl6CGkYiLhZKOz8vbdIJ2c3Fzb4J7eHZ1ds643M69sLuzusXOvMS8tbXbz8/deHHdzsTMqaqu0au00dbJ0Nzifo5yenmBgXqFlp+rn46TooeLlH+KeXN0enB0hZOOjpCVeoGSlKmWlIiHfXaFh5aLmpR/kYqDy3l+gnZ/dYCBl4GJeXx9e4d8goh7iICWhpeglpWZgZmvnYJ/rrSVmq2hmHx62nXVd3Pc4H2MhXd9d9aGlJGBdN7Z3ON8iKGcmKanmqCkoJOvt7Ketr7Gy77D2NjW0G7WcnF6cL+/xs7a2bm0rLSvvZuboa2ukpuOja2isbfAx2yEfXN8enByboBteWuzwMmzwsTBrpqapK64n6ehdImjnseUqrTbfYOLmrK4bYV4y8ivs6jJb2myorKspKClqIWChqWZiZiJl5e6ts6Rjp9+hK7Gl6OTmZShrYR/iHyCe3vXnI+KlMvXd5eZnICnjYx8e8DQ0oTghJebeNfk532GftqcrIqJgcp8qIChmp2pi7KntKKdqKyrwb21yKuud9GRsK6trZGVkpiVm463t5+Hd6yoqK+hsMLEuL7Fl3d8jKOsmoqCgJR7v7yhjpSjm6auqI+Xjn9wdHh7jM5zjKOmlYKViKqurKeTgp2ikqC3nru4lH6Hh3mHmLjHpYuuoIyIlZWEfKaFn5F2eoCLeGVog6/GaXGupmt1bGhvZaVbpFqkkoWYhXCAl5WhnZiIjJiHg3KEmouEf3eCeX+Li4iJhIWNi5SHkYiAgpaFintzf4iKe4KEe3+Dj4uNh3qBhIiEhYN6hqCSeo6ZoaaclJKPjZSGiX3Af3twgZmqpKSlo7SxoqSjp7CwW1xcW4BeXFqora2up6OplpKRl6CimpqfpqWuo7e0XV1dYLOyqKmomaGrqJyclY+ZmZCQkpWDfoaVoaKmiH1/iZegmKClmJeknoyYi4iPmJWSppybkZukjoyTnKCUkomWmpCAgo+QioSFjOCytnh/kIvXiph+34OHcdnmvd52fHG4fXO4xoClfeDH2HPjb4F6e3pvdMqDipSRioaGmZSTk5CIlX6elpKNkHZ+c8p4i2yqxLWwvWZxbW96bWVmeYCEgXB8zcKzamjBq6fEyKS4amtnbGq7tGBhbGl1h4ZrnK7NxnprdYF5sK66q7LJb62uyMh7kXNwcst7jH6Bf3SLpJiFj3bQboC9hoTAboG9a5GaYmRic4CMh5FOkYd/e25ao4F2d7y2wml1cMTGaH5+js6zdXxrzrbIy9bYtq+qtcaxvLDBpslpdNScZ2xoc3BwaGdkZW29qpqmtqOwtKLHtKSmrbauabanrsOvx8jIYnpmbmuDw7u2yreStGbBZGZwrsPGvKZeaYBqa2x0f4Vye3Z0dIJ9xLzJanhsa2loZnNvbGxpbcKvzse5qq+trbfCs7exrabCwL/LbmjKvrjFpqKkvaSov8O+u8LLbn5qampwbmxwf4qViXx/jHl7gnV8bmhqcWpreYaAgX5/bHN/g5GBhXx6cGt1d4R8iIFwgXx5vW9ydGxxaoBzhHR7bG9ybXlvc3pxfHSHeoeOi4WKdIyhjnR3n6WLj5yRiXBwzW7LbGvH0XJ+d3BzbMl6h4N4bdPS1eN4gJKMjpiakZWZk4ugqKSSpauwtKuyv8K+umPAZGNsY62ssbfBwKijnJ2aoYiLkJmbgod/fZWLlpqeplpnX1pgX1teWoBbYliZpKyapaWhlIaFjJWdho+HZnWJhK2NoafDa3N5h5uYWWlfoZmEi4qdVVCPf4+Mg32Fg21tcoyBdH5zfIGZkqN8d4FscYqggoZ7gXqEjHBqdW5zaG3Ghn55fr3Pb4eEi3WUhIN4dsTExHrVd4aKb8za3HR5dMqJk3x6eMR1k4CNg4iTfpaLmIqHkJKNmZmVoZGPbsF8j5GRk36Ae396fnaTj4BvY4uFgIJ+kZ+hmZ6igGhsd4qPgnVubn9soJ2IfICJg4iOi3h/eW1iZGlqeLxneYeMgG98dJGSjIV1aYGCeIeWhJeVfGtyc2l1gZWjh3OPiXhxfn9wcoxxhntoboV+Bn19fn59fYd+A39+f9R+AX2Sfod/ln6Ef8h+g32Efgh9fn5+fX5+foR9D35+fn1+fn19fX59fX1+fYd+AX2XfgR9fn5+hX2OfgV9fX1+fod9hX6CfYh+hH2FfoZ9AX6EfYV+AX2MfgJ9foR9Bn5+fX5+foh/AYCGf4R+CH19fX5+fn19hH4FfX1+fn6RfQR+fn19i36QfQF+iH2Gfod9BX59fn5+hX2PfoN9jX6UfYJ+kH22fgF9q34HfX59fn59fYZ+AX2FfoR9mn4Cf36Ef5t+jH+UfoV9hn6Df4Z+gn+qfgF9hH6CfYp+BX19fX59hH4HfX19fn5+fYV+AX2WfgF9u34Bfa9+AgIEAICnrK2Qhf+9suH5g9HrjImZ1YXN9f+HkeTVg/jk7YTrgoLX6cXHzcnR4NS0pJGonbu+sKTDx7zVy7zIv72uxdbRwbeV/ZiirrO6usXVxLXPz8fGyciyyMDFwsK/s7jS5/Hu7ezw6OLt3NnHtMbPzdLs8drf6OT1gv718fWChYX14oDm9vvv4+Xl9fPm9fXi2+L18e3v/4SB9fDi2svV5d/q3t3I0+DZ6dnNzcrHr7LezrKrrKutt6iYmqemr8DKzbm5q7y0u9bU09W4vse6zdC43tfY3s/b3rvE6c65ure7u8bAqKSUlJmLlZuG8oGVjY/6hZDy8vCTg5DtyfHbg5OThoCGoYqGh4yOna6voKqhnKGzor2y1dGvwr+uoa+Uqau3zcjEpZmCj5aMpL+N9O2BoayZiOv+ip+lre+zh53jzcr1yMrgvOWC94jolJj98OTvkaOdsJ6Rm5iwq7/MoqSFmMeB6p37oom0k5R1v7KPp5OH/+mCkqmutK+iqK6sq6KjnICVvoGrpNKpvN6cz8yVtOPz/fqHi4Di29XIloa1odn2gfX7ifaDjo25uZ+Xm6+M+ISj14+pqb7R+MunvNOg0tyDmZPq9paXnoTDhJChkJTfuMe6t7bn5dDR0KKWx93o5o3byvGGgImH7Ziki6aclo706NXiiPXu47bI8P3349bfi4CPiZaPlI2Rif/q/vzo4ujc3+Hj2dDIyOrN3Pzv3MORjJaupKStlo+PjpilxrWsz9/bwrG5zLayvM3q0sW+6/rm5ej4/YOAhPnT4Ij5g4GSprSToqOQiv+Lh5CNoaGipKqptJ2ZkoiIh6OnoZmgoJ752Nnqh5GfncHHr6aJqKOE94D7+4yZlo+elamtq7PGvr+/yK6ruMPFsKurvsCvnqmvnaWXiZaRoKGno4mVmYvi3u/s/POFm/38kLavl7vAv8KlmLSvpLC5vLy22uX3hYH48/vwzNXI0cPEuri7u+bexMvY3suwqp21ocPNuqySzvrJwca+yPjk24emraeUio2E9IDp9Orh1cDaycTGw9np2L7Gq6qIm6iUoq+Wz7e+sqi5q/2EsY31xs/gwMjf1uqB4cS2tcC7zbK0pJK7m6Slw87M1s+gstmrqdq9vpqxw6yrv6/8kYyJpL3npaelhtHqiZ+grqCUiYGhideEi5qdjI6YsqOBj9rLparIvq2P7Zik44DTvqjA3MmlrMawt8vEzd7kvJuMlZ26y9O/uKvFycTAwsfFwJqYvtjQ3Mfghu2F+9CtwMmlsbSu1M/Eqbaqyaybqa3aycKwtJmyqYr6nLK8sKKejoaws5+vj5Wfq5uUlsfGz9GXuKHD5uHc0cvKxM/f4+TRvtK4yN/MmKKCtr2soICRlpZ/dN+mnsfdc7nVeHODv3Stz9RvecG1b9PEynHIbW62xaWorKixvrGajn6Uhp+imY2mqqG3r6Cqo56Vp7aypJ6A24aLl5menqWypJmtsKioqqmWq6SnpKafmJyzxczJx8LGwbvEtbSomaasrLHGzrm7vrvKac3KyM5tbm7KuoC9z9PIv8HAy8m8ysq4srfMxsDD0HBoycbAs6izvLfEsrenr7iwwrerraumlJe7qZWOkZCQmZGIipWOkKGuqZ+fkp+XnLWws7afoquhsLOfvLO2uKuxwKKcwbWYnpqhmaunlJCDgYV6gYp94HeGgYLneIHe3t2GeIHZv9/JdYKGeoB9jnh1enuAhpWXiJKJi4yfjKScs7GcpZ2WjpmCkpGesaink4pwg4Z4jKJ9081siJGBeNDgdICJlNaleY3OxMngu7fLrsRu0HTFeYHg0sXMe4eAkYF6hICjnK25ipF0gqx52ZHrmXWcgZR5t5t8kH965cxwfpGanJyPj5CQjZGgm4CYu3aWjrGTnbB4oJ56iq69w8FobGKvrKihfHKhksTmd9nbeNxwfHeco4uEgZh75HKRxIqqrLK83bWZq8KLusVvfnzQ2X99gnStc32He4HCqbampafJy7u+upiTudLNzn7DsNNxbXFyz4GHdIyBgHnQzL/FdtbLzKavyeHcw7rJd4B5d392enN3c97Q2t3FwMfAxcjLv725sdO+xuLQ07aPh4yhnJ+ijIWGiI+ctaudvMbKsqWrvbOrtcHizLKr1t7GzNni23Vvc9u/yXfRcGx+ipl8hYd8dOB9eIB5ko6MjpKRm4eEf3d3dZGTjYWMionZwL7Mdn+LiKiumJJ3lZBy24Dd2X2Fg36MgpaYlZ2uqKSlspiXoqytmZSUpaeYh5KZiZCEeIaCjpKUjnqIi37Qz9zV39h4jeXoiKOdhaaoqKqRhZ6akZqipqOevMfYcm/Tz9nNrrettqmsoZ+io8fAqrG8wLCal4qfjam1oZR9staqpaejqdbBtW6Ci4Nzb3Nsx4DAysK+t6K7qqSlpLnHuqSskpJ2hZF+i5mDvZ6jmI6ekdhukXHHp6q0nqi1rr9lt6Sbl6GaqZSbjn2dgY+In6yqsqmJn7mQlLufn4OSnImImY3Xfnd4jJvKi4iLdb3WeYiHj4uAeXeMes55eoeNhISFlpF2gMi4k5eyoZV/1IqUxYC1oZKpv66Nk6OWmqukqbO5m4N9hI6eqKyem5GlqKWfoaeenH5/oLClr6G0bMBszaiQoqiJlZeRsaynjpqQqY+CjpK2pKKTl4CYkHbYiJqjmY2HeXWXmoiXfIGIkoaBgKajq7GAnYilwbu2saqtp6y6vsGvnrGZqrysgYxyn6GSiYB+hINvZsGYk7HCZarAaWVwqGiVr69dY6SeXraqrV6pXFuaooiMjYyVn5J/dWh7coWEfnmLkIiVj4mPiYV+jZeTiYVtwHN5gICGgYeQhICOkY2Ljo+Ck4uPjY+HgYWZqKyppaCjnZqkl5KNgIqQkZirsJ+doJumWayrqK9aX1+tooCjtrivp6qqrqugq6uclpmyqaWnt2Nes7Crpp2iqKKmlpuOkp2Xrqicm5qWhYSmmYV8gIKFjIiAgoeBf4ubmY+ThIqIi52cnJqLi5OJk5iLn5qZnJabo5KPppyIioWKhZOUgH92cnZwd4J42HOAe33fdH3a0tN8dXjWwtnKcXx8dIB2gW5ucHV3doWMgYSAgYSSg5OTpZ2QlIyHhIt4iIiRnpaVhX5mc3dufYhsvblgd3twbMPTaHB7gcSjcn3Av7zMra6+qrllv2iybXHRvre5a3Rve3FwdXOcm6ixe39sfp1y1YbcoGuNeKSKuI92hndw2cVodIOOj4+BgoCEgIChpICkwXGHf5V9hIxceXdhbYOQlZRQUUqGhIB2YGGMf7PSaMTGbclmc2+Ok3x6dIdx02uEuZGkqaqxzKmSo7F8rbpmb2/ByG1qb2uhZmtwanS3oqqZlZa0vbGtsJSPrcPBu3C6qb9lY2Zqv3FzZnRtcmy8ubSwaMK2vaKkssjRuay0aoBvbG9oaWZmZsXEy8i+tLmztru+u7W1rMq9vtHHyrCZjY6emZyej4mHioyUpqCWsb6/r6aptbStq7DJuKWjwcm3t77PyGZlacuwtWe+Yl9pd4ZucnRvaMdubHBrfn98foGDinl1cWpuaoCDf3Z8fHzItKy8anJ7epOZh4RrhoJpx4DKy297e3R8d4eLg4ibmJaYnYmKkpmYjIiHlpeKfYaLfYN5b353goWIg3N+gnHHxs/Gzc1yh9vkfJaRf5ucnaKJgJSOh42YnZuRrbnGZmK5tr60nqWZoZeYj4yTlLKplZqmqJ6Pi4GOf5qfj4FxnbiWkI6MlLehkldkcWdZWF1YpICjqaGhnI+fkoqLj56qnouTgH1mdnxrfIZ5vIqNg36Gf7JbcluciYuQgomQjpdMj4Z/fYaDjXqAeXGFb3hzgYuNkYx0h5N6fZmKhHB3em9wfHS/bmxrdIC6dnd3Z6/EbnV5fnx1bm6BcMRxcX2Genl5goFwdryugYabkoZ2zX6GsICmi4OUp5h/gomChZSOj5GWhnFucHyJjo6Cg32JjouBh4t8dWVqhI59h4GRU6BYpoZ3iItzfoB9lZGQeIN9jnpweXyZi4Z8fm2AemfAdYOMg3p3a2iBhHeDbG50eXNucIeEjJJsg3KJn5uVk46Si5CdoKGUg5aCj5uNbXZkiYl9eIV+hX0Hfn19fn5+fYR+DH9/fn5/fn5+f35/f6J+AX2yfgF/hH6Df5Z+gn/UfgF9hH4JfX5+fX19fn5+hH2vfoJ9hX6CfYR+BH19fn6JfQZ+fX59fn6EfYh+hH2Gfgp9fn19fn5+fX19hX6CfYx+hH2Hfol/g4CGfwl+fn19fn19fn2KfgN9fn6LfQh+fX1+fn59fYR+AX2FfpF9BH59fX2EfgF9h36EfQF+i32Jfrx9CH5+fn19fX59in4BfZh+hH2MfoN9q36GfQR+fn19lX6Cf6l+iH+afgF9h36Df4l+AX+jfgF9hX4BfYR+gn2KfgF9i36CfYZ+AX2ufgN/fn+dfgF9tH4CAgQAgIentJmKoOO+wJ3W24WSqLam8NecpLvFy4GJ9IaMgPOAgobnyt7Sy9LStpyTorXFwLyh2tvf6vnKzs3swbmqr7rAuLWpqrbK0c3Gv7WwubvIx7/EvMayoayyu73U59TU6OTi6+XP1uHr6urX2Njj49/o7oKA9vXz+Pf8gO7t8oqMgIH05ePrgIHz7N3j3uXx7+nt6t7t2cHGx9TDzNf2hYLy9NvYz8zAvMTi16qx2dnWur+pn7C6uLPX39nW08fMqszKwLnG0dHdysm1n8PVu8Hd3s3MxNDIwdLJtLbP4Mq6u6alrIuSkMTVspiA84yQi/zj0ueMjYi+7N/kkeTrjPedgKiOm4PVgouNsY+SlKiey5STvayUmKGfuLCvq7i/u5ybtLKlk6q4pMDEvafjmKG8taD88Ieiq5+Q35p8p833goWJ+szLyNXNztWBmJf0iZStpai2js/K2eWEpqemsIe0rL6D1ovsiPmSuMWXgIugn5Wbk4KhpKqMlJC5qITj6KShgOyQ+p+uusuJvoesrLTL5eqA/4rcqeTT1de47sOvjoLp0fn5jPuD+4ydmIWCnZeKi56Ps77S0JyizNCxr9LLwODS2feIhJG9wpuctbqpsPK9oczS2OXYuODrjIuI66vlj97bgNLGttbl8viQl4ruhYvk8fb3vMKB5M2J0qS52/DvgPPy/PP34e+Fkobf48S+trm2kb7Tysvz7cyhwa6uxsaUivHyi6SgusCntcGrys3C0+H24+OJ9bzEo6aiseX97OjyiYn0hYKAh46ahPPK4+3r+IeZoJuI5v2Wk42QmYWKkoKElJWlopmHmbGYlPWMi5SD6+6A7e2Dlqy4pY2Ig4mNgOnPv/yFk/fo7f66s9KKkYvwtpqytrCfiYD0hpWqoKOWjJiSkJallZSXkJSI1rzB7tbx7/L86OmIlrO/tZ2WnJihuK2ourS8u9Le5ujj/P7j3NDY58C5wbvD2r3F0dquvbirr5iQoqaepJWrt+CC6tHh4ujt2bjmm7u9tKOWkYSEgJyP/vPc0cnH0dK6ncHXv7OozePw6NLh0a/q+tPG3emBjpuE3tvc28Xo59Tb2+DQ1tjP1dGzu7qujLHDrK6rm73G1b2hv7Gfh7Scmrrq0cfDnJqgl5eSmfSC+/7qjKyHip2P+of45ISIjdqGldyKj4qciqvBk4eDnbO5voqYj46hgMi8ivmUqpWywKaww8jOu8ewxtSPgJa02Li4tLmsuL+9vs3N0cm50dC70tDM0tzu8NPx3qq97ImD17qipL2mmrPPrI2QoLzDjZ+pk5nBq6ClnpCgt76onaym25+E6J6Bvsff2cbkybHXy6ad0+XEtd64zLysnZuZpa+akqTAwIvxgHaRnIJ4jMSpsZLFxHaBlJ+Q0cKJjaGorWxxynF2btFtbnLAqb2yrbW0mYaAj56ro6GKurm9xNStr67Lo56Slp+knJmPkZqpsK2npJuWnZ2pqKGknqqai5WZoZ6yxbOywsG9xMGtsrzGwsOvsbO+v7zDxGptzsvKzsvPacbGyXR0gGrKvLvBaWrIxbi9uL/IxcLEwr3HwaaoqbOgqrTKbGrFxbaxrKigo6a9tJGaurWynKCPhp6koZu5t7W2saWrlK+loJqjraq0qKydiqS0oaS8vaysoaqrorGpoJmtubOhopKQlnqAfaizmoZ03n6BfuXSxdl8gX+73NfYitjageiJgJd9innJdH18mn2BgJGHroV8o5WBg4yMnJiSjpimoYeElpqPgpKci52kmZTTfoOcl4bn0W+Kj4mE2J57obfYcXN32Li2sri1wb1uf4PZdXqSioiWdrKovshwjJONl3aalLOEx3zfdeGVv8uVcHWIiYCIfHCKk5B+gXmilXTM1ZKSgOKR6ouYnqJsmmqEiJKasbZjxGqui7Wnp6mWyKudhHfXxNrYeNN04HyJhHRziYN4fIt8pKzIwZWUucClo8KyrcrNwdh2cXiaoYKDlpqIj9Wwlbi6vs7KqcbQio2C3KDPesnAcriyoMPR0tF2f3XMcHLCztXRqaxt07l0tZmpvMrIgM7U19LbxstvfnPExKqwqK2xjbPJu73g2L+asqOjt7iPi+nshpqZuLikqbCaucWxwtLdytJ85LHAnaKep9fn0cXRfnfScmxqdHmJb9O3y8zL3nWDiYN2x9yAfnt+gnJ3gHJzg4OQjYh1hZuDgdV4eYJ10NRwzc1xhZigjnl1cXl7gMu6quV1hNzU19yjnLV4e3bNnoWcoZmJeHTYdIKXjJGGfImAgISTgoSIgIV9xq213MXg2uHm19p8hqCpn4qFioaNo5iToZqjpbe/xcjA2dfCvrG6x6afqaOvwKSstb6WpKGVmoZ+jpGLkYWZn8Nwx7G/v8bHt5e6e5WVjYN6d2xrgIF30s28sq6osLOdhaK1pJqOrr/LxLO+s5bF07Wlu79rdn5qtrGwr6G+v7C1sbWqtLKrq6iUl52ZepiglJGPi52gr5mJnZCFepqCg5S9p6adgYCDf4B7gc5u1+DPg5Rzd4R+4XjdznN6esh3hMx+goGGeZqsgnd5hpuboXiRe3yMgK+heeOEk4SXopGep6Klma6ZrrN9bn+YuZublpmRm5+fnaqqsKuar6ydsK+rrrbGyLLJuI6ewXBrsZmHiaCKgpexk3V5iJ2jeIaMfYWnk4qOiHyLnaKQiZeRvYd0yYhsoqa5saS7p5e0royGtcOlmb+esaCRh4aEjJWEfo6monjWgGt+iHRqeKycp4qyrGlygYp7ubV7e4aMlVtdq19jXrRaXF+fjpyWkJmYgnZveYmPg4V1mpuYnqeHj5KmiYZ3foSLhH93eoCMkpKKhoB9g4SNjIWKiJaIeoOHioeXppqZoZ+fqKOQlqGnoaGMkZOeoKGmo1Zbr6ysq6esWKmorGFggFmvoaCjWlupqp+loKasqqqqp6OrqZOXkZqLkJWqW1qrsKOcn5mRkpeqpYOHnZugjY2EeIqTkIqgoZ+cnpaYiZmYk4uQk5aalZOKeImajIadopKRjpSUi5WSioeUmpSNkoR+gnB0b4yah3puz3d6d9nNws9xeHfK2dDOftnaeuSBgIV1fHDPcHZ1i3R2eIN9l3t2k4p6fIKFjo2Hho+Ukn15hoqAeIKHfImKhH7AcHOKgHXRwWZ7e3x1z6SEnKu/ZmJpw6qnpKumsLFibnjNaW17d3V4Z6Obr7VhfIKBgm+IibaWzHPRcNuj5PCfaGt9fHV6cWh6goJzdnORhnDIzoSFgN2f24CHjYVSeVBkanF0g41LlVCKdI2GgoJ1pZWHdWnDtMbLbr9ozG13cmpufHlwc4J0nqi7tJGOq7GdmrOon7u8tMRqZmqDjHJyfoJ6f8ankqysr8S8nbe/kJCFy5m6a7uuZq6lm7rCwsJrcGm6Y2WxvL/Co6ZiwaVlrZaisrm7gMHIyb/Ht7Nlc26/vaWspKivkrG/vLbU07qaq52hr7KRj/j7hZKSs7WkpqWUqLWqtsTMvcV03bG6l56YoMPVx7G1cGrBYmNeZWl5Z76stLu2xWhxd3JstMBxcW9xc2lrdWdodHaCf3lrdYl1c8RvcHdrwLtmv7lodoWNf2xraG1xgLyvn89seM2/xMqMip1laWS2jXeNjol6bWXHa3WFgIJ6cHp1dnmBeXp8dn13vaiv1bvT0tbazMdzfpaclIJ/hX+GlI2Hko6XlaSvsLCsv8CvqZ+irZGNlpGeqpWbpKyIko+FiX50gIR+g3uLlK1frZ2mqqyvoIWTXXB2cWpjYlpYgGlhr6qgm5WUmJyNeYuXjod+laetq56kmICpspmNmp9XX2RVlYyMiYOWl46NjZCLlZWMh4h9enyCZ3+FfHh2dYGAi4B0gnZzan9ua3WRg4d/bmltbGpoabVjwMK+bn1mZ3FuzW3HvGxva7prc8J0cnN7dYiUdmpweoiIjG2AcXOBgJqUcM15hHmDjYKIjIWEfYmDjZVvYm+DmYOCgYJ8gIKDho+OkYyEj42CkpOPlJehpJKml3aDoF1alIByd4V1bX+Se2RndIWIZXF2a3ONgHl9dm56hop+eoN/n3ZltHVgiYeXkImWi4GYkXZyl6SLg6KMnop8dXRyeH5ybHyOimvEhn6GfYV+gn2Ffgp/f35/f39+f39/0H6Cf4Z+B39+fn5/f3+EfoJ/ln6Cf8x+BH1+fn6EfYN+hH0Ffn19fn2FfgF9pn4BfYV+gn2FfoZ9g36IfQR+fn59h36EfYh+C319fX59fn19fHx9kX4HfX1+fn19fYR+An9+h38DgH+Ah3+FfoR9BH59fn2LfpF9i36RfQR+fX1+h30Gfn5+fX5+hn0Efn19fo19g36XfYJ8kX0Bfox9A35+fYd+hn2FfoJ9lH4BfYR+BX19fn19in6EfYJ+hH0Gfn5+f39/iX4BfZJ+i322fgF/iX6Lf51+hH+0fgV9fn19fYZ+C31+fX1+fn59fn59ln4BfbJ+gn+kfgF9on4BfQICBACA7YCDie2YiIHb74D2/fGInKGl9YH4rJXhyNfs+ePg4IL58u+H88ekzOb8zaaXsMKbm6ncwMX5i/rVuMuutbjDyMbh2LyzwcfO3srRv77Q3dfKupyissvEv8rKubnQ0dnd09LH2eHf5Ort2Mnp7PKAh4OAgfb9/oOA7OqAgf/6gYSA9fmDjPr54Nzsgvvhye7i5uLI2t7X1KKuyvHMzcvAvLGtuMHCvLqquKi/yMXFx76prKin1uzH29uvoq+7vKi+0NO3vb63tbWxsbK91s64x8rfys/R3c/LurKPmIajm5uysqqYi6SsusSvsJilrKDWg/6Ei5qWz/aFnvuFgIDw9ICA/9X+iIeOlqWdh4uvoZ+oiqXEqJCusrW/qZ+tt6iev8eek5msz6ecvtegjoSFoKaaxLXn+a6znt6ZjKHS9Y+Thtn0+N7kgLbe7YqA4uGRm6WLmp6IjITb3cLVloWSpor6qtGJ14TG1MWkncnwobS3nqSvlfyMno7uhfqGw+KAjqKAsJiIj7zP8IyfoJqrv9zu+/6LiIjR49Pdz82g3fHKk6mBhOOB6py2y6CJgY2L7/WPn/LS4eGG+97KxMuw0tvBrtzs9YCs0eSCiIyXjpeP/9ir0env9ImJgfSnw5iemZOjs8XZr8O/3ejj6oOOm4f3jZHv8NntucHjzuXov460rr2At7+3sdS3wsXTnYiQj4CNnLKgm4WMkpmrsbSzyKOaqr70i82us8zj+5OE4trihfny/YGLg6Gcsqm/pIHUiJKGhfiRiICLgfCB+oGD8YKA+on+y7r2iYmJheL4iZyB6e7m842c+4L+/oKEh5eNl5imkJSBhYuCi4yLkKCHjILvzruAudqBicPk6rTx9OSE8sq7tKeroJ2cpLCxi5KK/vOGnY+WnpCMjI3/h5GP8fCF++n/iP//h4+JiI6B+oKFlJOKmKzBu7fH1dLt6Oro1ePSwdPXz8aoorqqn6ettpuipL+5n52N+Y+i/I+Urc7r6/Tt4/X9ioGFiZizs66dgev3iY6AoY+B9PH8hJWH+v/X4K2+2/r8iYb/+dW5kMG71Yre1PGI8f2CgPXa3Me/0+nb1d7l1sfhyba7ybKxw8m44MixxrnMxLHR28OowKfc19q2q7+gvqqgs5WigYOSoZOA84+J/o298ZaRprLqsKeKkYKkkeyNq6KZprKps6GxxLSbkKKAvL6Ik52AiIqj2LO7wMzEx7Gci9ycw+Lb18rgxs/D04Lhw8bcx9rOwd3YyuLP0oKB57TZxc7Az6nJxcLP3cuwvtCkqbWdoaCZm7zMtpehpaGkpJ2ztaSir97MrYPnmKGwvLuvws26rq+7nrjSz8DFzpuusp6nprert6S8td6ho4qA0XF0ddCDdHPB1nHa4NV2hIqJy2vTkYC/qLXE08DBvG7Rz8lxzKqMrcPSrpCCmaiIh4+7pKnSddS2nK6Tmpumq6i8t5+Xo6qvvaqxoqCwurSroYeNma+ooaqpmp6xr7S6tLGmtbu4vMXHsqTBwcVobmxqasvR0mtpw75oadHOaW2Aycxqc83NuLbBbNK/qci+wbmgsLexrHiAocKnqaulnZuVoaimoqGSnpGnrKijpZ+Rko6LtcCpvrSXj5qgn4+crK+XmpyZlZqak5Ohsqmcqqq2p66xt62pmZh6hXSOiYubnpeIe42Qn6eXm4aRlozIeed4fYeCv994j+t8d3ri5HKA5sTsfHp+hJGIeHmXjYeReoynlX+XmZ6kkoqPnZGHoKWIfoOPq4+Dm7WFfXh0ioyApZ7V3Y6WiNWViJq/0nh6cMDS28LJd6XD1Xp1ysV2fod0gYxzdnHCw6+/g3aCk3XYptmKy3i7wr2qnLnUjZiaiYyYg+B7h3rPduB4t85xfIiAmI59h6SxwG58e3eGlai2xMRram2vuaevop9/tsiwgJ50ecxwzoicq4x3bXt71dh5j867yMN13cy5sbehu862p7/Q23OTwdJwdXR9dnt11cectsvO03V5eN6as4+VlYyUo628nK2qxcvHzG54gXXWd37L0L7UqrHQuMnNsIaspKmAn6eln76nr67ElYiOjYGJma+bmYOIk5enpqmrwpyfrbjof8KqqbXF4YJ0xMLJdtfW5nWAd5CPoJqxj3G/gIBxcNWCcnJ7bclu1W9wznBv1XXYta7mfnp5c8Xdd4duzNHN1n2L3nPg3XB0dYV8g4SQe4FydHpxent3e4p1e3LTtqeApsd3eajGy5nT0sNwzK2mm5CVi4qIkpeefIF74dd4jH+Hi359fX7hd4KE3tl459Toe+zqeYB9e4Fz43V2hYN7hpitpZ+suLLMx8nGtsSzp7a3sqySjKOXj5OWo4mQkaaijYx+3YKR3HuCmLXQydHHwNHVdmxwcXyOi4t+aMbScHOAhHJqy8vXbnxz1dq1wJOiudLUc27U0rSgfKWesXO2r8duxM5qacaxt6Odq76ysLW8raS5pZOWpJCQmqGZvamUo5msoJStr5uNno22rK2Sip2Gm4uJkH2Da297hnht3Hx24X+s0oN9mqnSlot3fm+Kf9F+k4uFk5uQnI+bpZiLho+AnaV2hIhweHmOspOXn6igppOCdbuGo7y2sae8pq+ksW+7o6W5qbqvob6yqcGwsWxqwZa5o66is4+qoqOvtqiSn6+IjJWCiIWChKCvm3+LjomOkIiam4yPmb+wl3TIhIyUoJyWqLKelJShiJ6ysaWqsoOTmISNi52TnI6mm72JjXmAuGRmZ7lwZWawvWTBxLxmcnVyoFmoenCgjZikraKhnluvqadaqpJ6kqOuknxxhI1zc3mah4moXbGch5N7gYCKkY6bmIR+iI2Tn4+UgoSVnJSNiXd+hpSIho6LgIiZkJecmpSNl5ucnKarlYegn6JUWlpaW7Cxs1tap6BYWrOsWFuAqK9ZYK6wnZylWrGmkaymp6KKlqKcmGxohqOUmJuWlpGOlZmWkZKGjYSUmJOUl5aHh4N/mqqbo6WOhoiNj4OGlZqHg4WChIeHg4GJl5KLkZKdk5iWlpCOhoFsdWV7en+Ljod5bXqAjZOGiniBh4LEc+Bzdn15vdVvguF4eHjd2WyA2MDhd3h3fYR+cXCJg3+Cc4SXiniLjpOWh36Di4J6jY97dXqCk4B2iJN0bWxodHl0joXKzXuDfMWOhpWtvGprZK67xLK9aJu4wW5su7lnbXRocnlkY2G3vKy6d257h27Qq/uZw3K1u76uo7POfoiLf4CHeNB1e3PEcNRxscRqd3+Ah4ByfZebn1dhXFZjcnqGk5RRUVKKkoOMf3hdlqqSb4tnbbtnv3qJj3xtZXV1zcxxg8KrtrJtyLuspbCWrLyqnrK8xWqCt79maGhubWxnvLaarb28wGpradGUsIyRk42YnaS0mJ+jsri3vGFpcWe8aG+4v6/Kp6bAsLzBr4qinKCAm6OinbijpqWylpCUj4iKlKeen4uTmJirpqOiuZ6gqLLaecGoo6y5zXVptbGzZ8O9zWx3bIKBkZCahWmzbnFnYrtvaWVqYLJgvWBguGNku2S7q6DQc21tarjBaHRjur20xXR9yWjOz2ZoaHdyeXeDc3ZnaW1ncW5rbnxrcGrErZ+AnLZrc5uxsoq2taVerJSOin+Be3x7hImLcXZwzcZqgHV8gnNycnTacnp619Vy1M7edtvXcXp0dnhr0nFwfnt2foqdlpGapaK2s7Kyo62fmqejo5mEgZGLhIeIkHx/hZiQgn5z0XR/yW55kaCzsLmxpri9aGJgXmNsZWhkVaitXGGAalxZpqqyXWhht7qfo4CMnrO2YF21tJyLc4+Il1uWjJtWm6hVU52QkoOAjZiQj5WXiYaVh3p8iXp4fYF/mIx7gn6LgnqKin54gHmMiYx1boByfnVxeGttX11jbWdiyGtnwmqfwHVymKXBfnZucmN4ccRvg353fIR/jnyJk4R+eX6AjI9sdHpmbmp5lYF7hYqFiXpoYaZ0iZqXl46fjJOKlludio+ckZ2TiJuUjaCUl1lYn4CcjJKJlnyQhoeRlIl8iJBzdHtvcXBvcImThHB4e3d7fXmGiHt8hKWYgWW1cnmBiH99kZSFfn2JeImUl42TmHN+gHJ4d4N9hHiJhaB5d2kOfX5+fn1+fn59fX59fX2FfgF/i34Ff35+fn+SfgF/t36FfxF+fn5/f35+f39+fn9/fn5/f4V+AX/kfgN9fn2Efg59fX5+fX5+fn19fn19fa9+BX19fn5+hn2DfoV9CH59fX1+fn19iX6EfYV+Bn19fH19fod9h34KfX5+fn1+fX59fYp+in+DgId/h34DfX59iH4EfX1+foR9AX6NfQR+fn19h36HfYN+kn2EfgN9fn6wfQF+hn0Jfn59fX1+fX19in4BfYR+AX2Ffgp9fn1+fn1+fn1+hH2EfgV9fX5+foR9Bn5+fX59fZZ+hX2JfgF/j36CfYl+DX1+fn59fX59fX1+fX2GfgF9qX4EfX5+fYt+in+CfoV/Bn5+fn9/f4l+gn+Ifgl/fn5+f35+f3+4fgx9fn59fn19fn59fX2HfgF9on4BfYt+AX+OfoJ/rH4BfaN+AgIEAICXroKGt8+Ml57Z76HQ0K7Xn8DygMnWg/vmxtDLzs+Bmor83fLz18Td2vLsw7/Q1dbMtbe11NXW7djH7d/Hxc3Ktry709jI1dXYzMa2tqqspLuon7nJ0s3TzM7c1tHb0NPP19/t79vg6PHeys7GytPc3+fp8ufj+PPb8oWK/Pns9YCF+4WGguj/gIL99v/jzuHV1dDf49XQsLu5q6Cgub6yo46jpqOfq6Kkuq+ut7/AvLCkrKi5wbzQ2Nrcxae4u7i3x8emnqvJvMiystPow6i4wrOusMm5rIugj/yVkJOmxayxop6fl7O5q5+su6Gbo4GDh4Pi8fuA/vmHipCrio2xiYCIjKuxm5yfnJKLlpCUjounuK+7v6mpma6ui5SeqqG7na2jrbGetK23kpilz7O1v56aiPD9iZaKpPfWsvKimpeJh6e1gdjV3IWd4v/s3fePnJ2WrLiOktvWmJK39YSUhOCgtIqF6f37ioeH/I6nv62tooeenpKLkJ2p646hhaKSsoDLrce98IrliJWdp7fI1t2BgYeHjYjx6u3x45nB1ee5sJCOj4mpsJauqP3mjvbLgo/zp9GQ0crr6fLxurm9wdG7tKrQ4oDO2Nq/wPHax97s+uq0pfqG+I/jrZ+7qJOYhs6gyYSOjJ6tsb6/44WX++rZ0fLn0LvTq9/Vn4+uuqGil4CfvsKLuJiuuMPQ2uWNjpWl1OzWyODOyb/w5erH0cLVzM/qzcPv7+uRjNq+udLL24SChfqIl7exua+d/93nipqNjfP21ILx7d/g29zm9/317uHZho2JmY6Di4eIhJOS/IOZpre1q7KI64mClKOcj4aHn5aaj/qA//3o+5Gh//+NqoCIobW/vb3Zzs62u7Oll4aVmJidmY2MnZudkZKcmpyvqZyH2ODSxvju6oSSj5H06fP4kK6imLSnpJqep6Cyxc29s7nJ5OrP4OTq3trd5trNyM25tqehy7W4rqTFx7q2tbqyl4iBi6Grv7PPi/uChJDu+o2Hg4ajnomDlaudmp6GmoCkoKGNh/zz3K+d283GyMrSwb3BsdjDjqu67ImKjo/siJuKloLw9Nq55f3Ez8zh0rbQ0b24r7asnqGnt47vlqr+j9f417vK56qum7muprS4lqy0tdqhkZDkhq+gj4n2jPjs5LTa0c7zhIiFoIr+54CL+vb+1tyBsqKaoqumjvr3qoC4loGLn6qfrqqmsLXBo7zBiKiuoZehvtXRyLiz3/Xv//uB4tHJw7zCqLzCpIqf19DRqL7CytivuNXNpbv6yt/Q9NTDv72zwsTTvLSx0uvRt6WnnL+0o6qZtbHNp/m0zcTY1tO+xq+Zkrysu7emztHQv8XF28TXzsDN3tTByd6yloCDlnF5qbt8hInI15K6up6+iqbJbK20b9DCqLKura5sfnLTus7Ns6e+us7KqaWzt7qwm5uZtLO1ybWpy76ppq2tmqOfs7qruLa5r6qbnZKVjKKSi6CqsaqxrKu5srG7r7Ctt77Gyba6ws26qa+mqbO2vMHCyMC60cq2xm1yz8zDyYBvzm5xbb7RaGvRzNS/q7+0s6+5vK6wlaGakIyNn6CYjoOSk5OOlo6QnZCXnp6gnpKNkY6apaGwtbizoY+YopuXo6OMhpSlm6eTmau/nY+dqJmXmqaZk3yLfd6Df4GRrpeckoqNhJ6jlIqVoo6IkHV3eXfR2N505+F7foKYfHybeoB7f5SaiYuKiIF4gXuBe3uQnJWgoZCSg5WUeH6HkYWghpKLkpGIlpGcfoGGrJyTpoSGednZc4B2kNnEqNKHhX52douXc8K+w3GKxt/V0Nl6goZ8k5x2ecjFi4626XOCeNKYr4N2zenpi4F643qKn5KQiHOIiYB7e4aPzniKcod/mYCwmKulx3O+b3Z2fouapKhiZGlpbmq7t7e5snidssacnH58g3aSm4WXlOLKfdm5doDfm7+EurLLyNXWq6qquMirpJy7zHG9xr6vrtnBtcDE1c6ok9Fyz3rIn5i6n42VhtOn0n+JhJGipqinwXGA2dO9wdbQwKi5nNTHm4qiq5qgkYCSrLSLp5Cqsq23wtiMiouZwd3Jute/vLTj0dOzvL/NxMTes8Tf0dGDdb+lq8S0yntxdOF8h6GVnpGD377QdoN4e8/RunXNy8fGwL/K1NjM1dfHenhzhndzfHJyd4KB3XGIkaOjkpp0ynpwfo2IfXV3joOFetxy4OPQ24CL3eJ+l4B1i5yjpKy6sLKcoZiOhHaDhISIhnx8ioqJgYCNiYqblIh4wMi+t+bW1HaDgoTi3N3fgaSRjaaUk4mOl46crbWimaGwxMexwMLHvrq+x7yxrbGgnpONtKGpmJGvr6Khn6OdhXlyfY2XqaC4etdvcXvJ1Xhvbm+FgG5peYp+f4JugYCHgoR1cNPOvpmHu66oqquzpZ+jlbeoepefyHJzdHbCbn9vd2nBxrOVudKhqae6q5Ssrp2Yk5eUhYqPmnrPhY3Ye6vJq5eluIqKf5aMipWZgJGUnLCDfXjGcoqEeHTYetrOwp3Du73cdnh2h3PgyW552NXcvb9ymIaAjJKNeN3gj4CWgHB6iZKHlZeRmZqkiJykdJGVioGJn7OvqJyYvM3J1tBsvbSqp5+mj6Gki3WIsqutjaGhqrWRnLGsiZ7Rp7muya2jnZ2Wo6aznZuXt8evnI2OhqObipKEnpiykdubrqi4srKjqZSGfqSSn52PsrOxo6imu6W2sKWuvbSkr72Yg4BygGRomqdtcXS1w46qq5Wod4qiWZSZW62jkpeVlJJZZ12uoKyqlYqgoa+tlI2XmJuSgoF+k5SWp5aOqpyNiJGSho+HmJ6SnpuelpGChHt/eIp/eYaPlY+UkIybk5aflpSVnKKnppyeo6qajpSPlJ2do6aorKKita+YqF9hsq6rroBeqVtfXKOsVVmyrLKklaSfnZyipZuZf42JhIJ+ipCKhXmEiYaDin+AkIaNj5CQj4iCg36KlI+XoKKejoGHjI2HjY17doGOhYuDgo+jj4OKjoiFho2Mh3J8cMdzc3V/l4WLgnuAd4uPg3qEjX14gm9zcnLP09Rw3NVydnqJdnKJdoB0doeMgIGAfXdtdG90cXKCjYeUlISDd4WGcG93gHaMeYB7fYF7goCGbnB5kYWCkHh5cMXEZ3Nsfcavor9ycG9sbXl/aLetsWd4uc7Fu8ZtdHRxfoFoabe/lJi30mx2b8eguX5yxt/il3ty1XN/k4aHf2p9enRxcHl6u213Z3pzjoCdipeUq1+iXF1WXGZ0eX1HS1BSWFOYkpCPh1uEm6yHiG9zd2h+i3mLiM+8a8aybnbMh554saS3ucDCoJ2frLWdmZexv2u4urWmocC3qq+ru7adjL1mwnPBmpCsm4yVjPLG4oWNiIyYnKKfqmJyxcO1usTBtaCulMC9nYqbpZOYkICPoKuHoZSmqaexuNaTjYiSrszAs8O4t7XZxsartLXIv8DOsLfRx8BxarCcoraquW9oa9Jwdo6HjYB2yrO3aHFpbr29rGW5uLazqqqytL+zvMGya2lodGhjbGdla3RyyWd5g42PhYpos2tjcHx5b2hqf3V3bstpyM28yXR/z9R0hIBqfo2PkZalnZqJi4Z9dmh0eXd7d29tfn19dXd+e3uJg3tturqzstPJxG18fX7XztjZeo+Gf5eNi4OCi4KRpaaTipOdsLKfq6+zpqSqs6qgnZuLjYeBopKaj4qenZSSkZKSfHFucn6LmpGiaLlfYmuwuWheXV1qZFdUYG5naWtebYBwbG5kYLSxpYd3oJqVlZSdj4qKgZyQboSMq2FhXmGgWGRZXlSdn5KAlaKHioiUiXuNjYJ+eXl7cHF3gWq9c3e9aYaainqFlG5xan52cnh7bXd7g49vZmawXW5rZGjDacG2rZGuq67Ka2xqdWfGs19lu73Gra1mhHRveIJ9bsvEfoCHdmRsentygX99g4OGcoCIZHyAdG92h5WPi4WEn6ystrFbopmUkIqOfIiKdmd3lY6Pe4eIkJh6hJaQdoSlhpqSo4eEgYJ/iIqVh4SDn6iTg3h4coyGen90ioicf8mGlJGclZiLjX50cI5+h4h6lZmViY+MnIqZlIyRmpeMkZ2CcoR+BX19fn5+h30Hfn5+f35+f4d+g3/ZfoJ/hH4Jf35/f39+fn9/0H4BfZh+Bn19fX59fbp+gn2EfoR9iH4FfX19fn6FfYh+hn0Ifn5+fX19fn6EfQN+fn2OfgF9i34Cf36If4aAhn+Ofgt9fX59fX5+fX5+fpB9AX6PfQN+fX6IfYN8iX2Cfrp9gn6GfQR+fn59h36DfYR+BH19fX6NfYx+AX2IfgF9jH4CfX6EfQR+fn19pH6HfYR+hH25fgd/fn9/f35+lH+VfoR/AX6Ff5h+BH1+fn2XfgF9hX4CfX6IfYV+BH19fn6FfYh+gn2ifgF/un4BfaN+AgIEAICjuKSV4b2AgYzd0rKsrJq466TNpZe33JOX6tDVz+b0+9e5vqSqtsTjzt7s2NvV3ffg2dTY8/mE4vbqwr680OO6w9aB3ODJxuPaucLWwsS4usfB1bbPxMOqnq3Lx9rS077E0sjAy8W8zPTm5ufg0s3ArbXQ5Mvg5OPc1uDz8OTe7IDq6fmB8uDx7NjFu8C8vr3W0cu2spGSs8CtpKy8p5SIlJyLnq2QqL67nqigsa+np7rHyNva8vjp2MmnrLzNzsDe18XUv9nc0b7S1Nfuxb24vLeqsJayq/L1iZikpLSwjpCNlaOcoKy7t8rAqanAuqWNk5OFn5ubjaGbs4inkoiRlYCqmLeimaicxtTNxp2Zio7DqKCiwZSmurqotq+wpqCosbG1oa7Rzd21nbqxnrKRgZn8lpKKnaD6hoqSgJ2rjZ6f+viM7POTm5vxgIXzhpeil7mWuMOdhcqOyKDNioa/0smIgPv76YPVm4actJO6oZWLg4GYvZ+fqrmltKOdpbC4w4Cyudft2viFkJKmprWrzeGAi4qNh4vr5O3o7pThq9bqw4Xx6ZC1xpuToa+Tgfvk0NqD64rb2Ofc9oCbio2V6ZSl97nO08nE2dnev7rch/TWycmBwK7dqrq8mbKDitvbhoqzh2fCwoWnuLa0yPqC9JmZiLy0v8rg7d/MxY6wzLWntYCaptDAw7ypxuHQ08ilqKWtqqPYgvfnk4DStbiruNaE2sO1wqOt64Dz4eb83O2BkomN/5aRzcfAwru6tLaivL24qLOliZaT0tjzg4yQhoKKkYaD+6SWiIiI8feNjKeWorWRppaVoKSihPuC99vy8uHn5dHWhoqQhY3a8ILyif6XsYCqlIu92d/Lpamxr5OeqKOwn7GiooKQnZGjna6P/YyAhJaKmYmKjPTu4dLv7IGaoKS+1NnNr7TJv82lvsKyssesr6qu1+j+gYTiw7egtMbJy7CaqKSlt6q8wdK9v5SIlJOZkpuxn6ytzMe959rshoXf1d3h+pGXurGZsLCgpaupqoCilpeUiorviYWN8tPLoeTthOPnw9D28eyKn/2UoZH3hYP/69TRy93g6uHQ0se2ssDGpZ2ttpuXorKnkoWsg6XHu6DDn52QkJyTjI+IlJqpppm7vcaRkYz6qJumpoby25eD6IrgjoXvi+Kf4Jmm8+yC+I2MoJKPi4v9oK2fnZWYr4CthN+VjImLjLynsLmquLPC0MSlr7Oux8aw1NTj3Pfu+YiH8dDDyOXSnqzVvbKs1fjVpq/D2ui7p77q5svY0d7ngO2extyH17/c9+i7x+ewqIihh5rAys7GssjTyMfN0bPI6pmPheHi1Pa9tq6/vrGc0d7t3aiYsrmtrc7FoZaZjICPoI2Cxqhyc33HwKOenI2o042wjYObuHl7v6+1rsLQz7afo5CUnKbFsb7Gt7y6u9G6uba8zNBuvc/GpKOfscOhqrVut72rqsG5oae4paidnqultpmvpqWQiJSsp7iwtKGotK2kraigrM3AvcG9sq+lkpiww6rBv7y3tbrLxry4wYDBwcxqyLXDv7KknqSdoZu1sa2bmYCAmaSUi5CfkIJ7gox9kpl/laSgiZWLl5eLjpyro7u4yc+9tquOkaGqqJ23r6O0orOwqp+0tK6+opqXnJySlX+bjtzmeoSMjZyWf4J8hJKMjpaknq2kkJWnoJGAg4V3jYmJfZGLnnqSgnqBg4CXhqCQh5OGqLawqomGeXikj4iHo32Mnp6QmpOUioWKkpOag42spbqdipecgZqAcIbff4J3ho3ednp/b4mPeomN3eF71tF8gYPTb3HbdoSKgp2Blp6Gd76R0Ju7fHWyybd7cuLe1HbRmXeHmn+ZgoF6c3N/noeGjpaLl5CHlZiXpICYm7bHtMtrcnKAgIuEnKtgamtwbG63sbSyuXjDlLjDqXXbynuZq4qCkZ2Cct3Pw8Z30Xa/w8zD3G+Md3t/0oCK4qm+xru4yr3JsbLEddLAt69ytqLEm7K4k6R5fdLSfHq9j2zNyoadqaKgrddszH6GfKyossnK1cy8t4iltKiapoCLmsW6ua+jvtTFxbmVppugm5bDcd3SinzBrrCjrch2x7SjvJqk1WvbyMvcvtFyg3t95ISDta2kp5yfmJ6Gnpyej5aQe4ODu8ndcHiFb3B4fHNz5ZKEd3d70OGBepCCi5x9k4B/iouKcNJw1r3W1MXQ0rrAdnl7dH+/0XHTet+Dm4CTgneluL2vjJKXlYGMko2YiJuOj3F+jICTipp+3n10eId6iXqAguDazsTb3HeLkpaou8G4mp61q7iQqKmZmauRmZGTucjZbHHAqKCJmaqtsJmGko6RopqnqrukqIV6g36Hgoicj5qWsq+kyrrJcnG9tbm+z3d8lI57iomAhoyJjICFfXx5cnTNdG940rayi8vWd8HHrLHX18t3hdV4gnXIa2rOv62up7a5wbirrqOXlp+liYKQmn9/h5WLenOZc4yom4Kghoh/eoN6d311e36PioWhmKd7f3njkIGHiXHZx4Fz0XvGgHjUfM2YyoGL0ddv3Hl5jYSAdnfTi5CEiICEmYCVccSEe3p5eqSNmJ+Rm5SisKSIlZmRpKaTsbO7tM7EznFxzK+lq8SzhZK2oJiSs9CzjJSjssCZi6DEv6u2rrnBacaGprpwtaK6z8SfqcKVknaMc4Opq66omK2zq6uytZusyX92ccDGttGhnJSkopeJtL7Lv4+Em56Wla+mi4KFe4B9jHhvsptkZm21sZeWkoWavHySeHCBmF5gnJObkaOyqZmFi3p+hY2jlaCjm5yZma+cmZecqa9anauli4eFlaKJkJpblp6Rk6Wdh4ydjYuDg4+Mm4GRi4Z3c3+TkZ6VmYyVnZiSmJGKlq6kn6CimZaNe4aZqJGlo6KfoJ+zrKCdqICoo61aq5SenpeQjZKJi4eem5uMj3l4iZCDfH+Ph3x4eYF3g4t3hJWRfoR9i4l/f4eQjpyir7CmoJd+gomPk4eXlYeXiJGUk5GcnpOjjoiGhoWDg3WFf8jJbnR8fIiEdHV0d4CAf4SNh5WPfYiWjIR4en1ygn9/dIR9jXCEeXJ1eYCJepKHgId4lqScl3p3bWuOfXl3kHN8jY6ChoCDeHJ2f4CDcHePjZ6KfYSDd4R1anTJdHNrd3vOb292ZnqEdXyB08xswb5vc3LDZ2XIbXZ4c4dyg4V1bLyb6aG4cm+1x7JybdnWyW/UqHKAi3mPeHlybm12jX13gIV7g4J5h4uHkYCJi6CunbBYXFtgYWVicXtGTlNXU1KJhYaMkGGlgZyelmnKu3GJlXx1ho16a9bGub1wwmq0s7q2zGd6am1xump0zp+yu7Gvuq+6oqauaLiup6Rkopa1l6ywkplocMjHb26+nIDu6IeWnZqZnLxhuWx2c6agqra7ysCys4uXp56XnoCOlLm4t7Oft9DCvLiZoJiZlJGyadTJg3S5rK+io7twwKqfs5qcw2PKu7rMsLtmdnZ0ynZ1mpuRkIuKhoh3iIeIgIGDcHV4s7bCY2p2ZGFoamho0IR8bW5vxM1xbn90fo5ygnFyeXp4Yrtjv63DxLbAvK+yamxvaHOvwGbCbst4iYCFdWyRo6SXfIOEgnB6gn2DeIZ+fWd0gXaEfIh00nRobXx1fnByedLKwbbN0W+Bg4qcrbirjo+nnaWDlp+Rk6CHjYOEqbXFYmWrmJB/jZycnol8hYOFlIqVl6mXnH1zdnR+en2RgoyMpKCWsqKtYmCknqGls2NkbWlfaWZlbHJxdIBtaGZlYma4ZGFmt5+aecDGZrCumqC9wrllcLBhY1yhVFKkmoyOiZOVmpKOjoZ6fYKHcmx1fGlpcHx0Z2J8ZHeIfWt9bnRranJpZ2pkZ2t4dm+Gfodqa2XIeW9ydGXFsXBku2y3cWrMb7mPunN4wMRpx21rdXFwbGnAenpycnF2hICAZrV0bmxsa4x7f4R7gHqIjoRxfoB5hoh6kJKTlKmkrl9gsZmUm6aXdH2biYJ+l6yYeoCKlZ1+dIignY+VkpuhVZ9xjp1cloedraaJjqB/fGh6aHKPj5KPgpeclZOam4aTsGxlX6SsnrGOh4GOj4R4mKCqoXpzhoeAf5aLdXFza4R+BX19fn5+iH2GfoJ/nX4Bf4t+AX/AfgF/0n6Cfdh+AX2FfgF9iX4MfX1+fX1+fn59fn59in4SfX18fX1+fn19fX5+fX19fn19nn6Jf4aAhn+GfoJ9iX6EfQN+fX6FfYV+A31+fox9AX6EfQF+iH0Lfn59fX5+fX19fHyHfQV+fX5+fqJ9BX59fX5+hn0Bfod9AX6GfYR+AX2UfoN9iX4BfYV+gn2OfgJ9fol9hX4GfX1+fX59nn4BfYl+hn2afoJ/pX6Cf4V+kn8Efn9/f4R+A319fod9CX5+fn9/f35/f7Z+AX2FfhR9fX5+fX59fn59fn19fX5+fX1+fYd+AX2JfgF9nX6Cf55+AX+EfgF/nH6Df5t+AgIEAIDGxrqlwdacpI2qg9W459uc2u2GzdL7gqTR8ebk3deUhe3qzrCvrpCN8YvVx7vH4+vg39vEyMrl/eTGzOSA1efBu6+2ydKlvtLi666sysS9vsC5wLqtsZyhosTMzb/O3tu50Nbazc6yr7vb3Nvr1tDYyr/I092/087NzdLq49jr6oDr0LjJ06y6squyxtPIuL6+r6yplKumqq69t5eDgJSdpZKUm5qiuMSpp7HIytLQxcXY3ObY59TbxcPe3dfF0crOvMzF0rSlt7/Dxbytu5mlqJa9wry2rrConaqqoZautcGWkqqiorSkpa/Ftby1283ctIemmo+hopuhlIufrZyLlICdn4Odrr2X2begnqmcpr2so5inlrG0trLDvamnr8fh8dWsvszf36GJ3J+5wKaImrOg4PeOiJefr5OSpqHqio7m99OClYmUkKubj+Db/qmynJKprqOExIivmOammbm2zfunq4aJjqWeiu+QgYvxjJan8Y2wuKvVtqi1rNTUzZquqYCYo+rq6oOCiJejn56qvdqKkJOQkomI+O3UxZON84WA6sClkof8hoWBlJDrj6P17uDg9fCIoKGC6IGM7OyQmLyumbvE6e7ezoiKhIfv//rx6PD8oIuJhNaVzIv5ssbL8eHBhYCpmo7lic7719vT4rzk3en19vfO07i2uru+r6+bmIB5j8XHv8bElXSGo6mFj73JpYmyzeiLg4L/j5Sbk7Cxp5Kno4Lu3eqF383b84+wpJOau8zF9vT0gYiCsIfe+Y3Eu5aenYqFgv6Aivjv8IGRmoGJg4L0loePgIuhpKOmmI7d/YzzyMXs0Orv7s3r6oeaheSD8bb0hYnC3fONkr6t+4Dwhe7z7NfJzbmqvaOdq62coaKNkbOah4aUk46TmpOXmZH739+AipG4mouQh5Ciub+8xM/d1Nzxgd3c5czB08jQ5rzQ5M/s6PDt8Onk3sXDsbK+uK2hrry1qKzEpJWxmuDeh5Ssr8XGwMrAvM7QyavRvcDcgOr2mJ+tpJmYnaqhlYCJjoqClJiEhIj7qY7D3PKBnKWvx9vG0sXy/5urqpiOgoLWzObExtLb0eTlzLLBnp243OTFr6y4uq6JjI6SmK+ipq/Twu782bW0rMWrjo6hoomrsbvavJ6WpunzjPSEkMPpofuD4vXc/unc6ZWXgIDKhJOL6pmlmJKRurKghtydr4CdiKyVpJeSk7WX8dSbhrC3na3A3cXOzs/Gqsn0hv/j0vWF+8zNxsbSxbbA0NDi64jSsb/ExL3Fz9rduLzGwMTQ3smztfOK9d3S09XuwbTh0qmSz5vh0+bZxNaMgcbAsuPHz9Xq7c3H2+rUwby3tLSwk6ni7t/i476qstLNwqykq4CnqZ6Nq7yJj3mVc8Ot396hzdt3tb3dc4+wx8O+vLV6bsHAsZmYmH1703m5raCrwMe9vrynqazA1MKpr8JutciloZecq7SOo7LAyJORrKmho6acpaCXmoSLiqWsrqCxvLqcr7S3ra6XlZ+6vbrKs6y1qaGps7yhsa+trrDEv7XEwoDErpyosZCdmZadqrGpnJ+hlZWXgZWRlJalooV1dYmLkoOEiYaRnqiTlpywsbKwqaq6tcCrxK66qKO1ra2hrqKmnKmgq5GJmp6eopuOn4SOjH+boKCdkJaOiI6RkYKSoaKCfJOLjJuNjZWqnaKcvK+8nHqViH6NkIqNg32Mloh8goCJinSKmaaFwKCNjJKHjqGRi4OQfpWXmZann4+PlKe6xLGNoKKys5CGx4eYmo56gpaKzNqBc3+CkYF3iYvUdnvT4r5sfHR7eI6Ngc3D24+YhHuLkol3uIGylOCmla6rudSMk3h6fY+RgNZ9dIDWeX6RzXmVlo6vmo+Zk661uYebkoCIj8C/wWppa3V+f3yFk6Zob3BvcGpqwremlnR0yW5py6eUhHfodXVwg3zZfpHg4NDO3c9yiIlx0m990M+AfpqPhLCwzNfBuXp6dHfT397UytfkjXyBes2O0ofZlqWoxbineWufk43LebLewcXFz6zDwsjW29y/v5+fp6mupJ2RkYB6kr29tMLBk3OEoKeEjrW/oouvwdt/d3Xle32DgJydmX+VlnXgw9dzycHN3oOZjH6MoLCmx8DAZ25skXnF33ytooKGh3pzcOh1dtjQz3R/hnN4cXPjjHWAc3qQkY2ShYLC5H3Vrq7Xs8fOz7HOz3qJc8t32KPcdnqrxNV+gKSV2YDLcMjQybeusJ+TpY6Kl5yKkI98gZyHd3iFgH+FiISGiIPfycZveoGli3+CeIKPpqqnrbfDuMDRc8O9xrSouKyvyKCzxrLNxM3MzMrFwKmonJuloZWMmaOdkpaskISdh8jIeYSYmKytp7KkpLOxrZG3oqO8a8PMfIKKf3d7f4mDeYBxdXRre39xcXTWk3yxxN11iY6Wq7mnsqTK03+HhnhzZ2mvqsKiprK0rby8qZOfhISctrqhk5Cbm5N0dnh6fpGHi5KooL/KrZOMjJ6MdXaLkHiTk52xlH+AjMjZetJyf6rNjNZ3y9vF3cnE1o1/bG2zeXl4zIWNgn99o5qJdsOJmICHdpeBjYF9fp2C0LOHcpWagpOguqCtrqypjKTEbdK8sctu0Kuuqqi0ppyks7C/xnKxlKCkppymrbe5m6CmpKavuqmamct1y72xsLPHpJm9s5CAtoS/tMS3prR1baikmcGrt7jIybKruMSzo5+dmZqbgZLAy76/v6GQl7GqpJGMkoCNjoV4ma15fGp+ZbKe5fawxc5rpqzAZn6WpaSfnZhgV5WUkYKDg21rvmuZkYePnaOeo52NjY+draONkKFbmKWMiYKHk5l6i5Wiq356kZCKio6FjIeAgnJ4d4qNkoaZoJ2IlZqblpaAf42ioqCtmJKckIqSnKOPl52Xl5mspqCqqICrlYiTmn+KiYuQl5qSjIyQiImNeYSDg4iSjnpubnp9gnp3fXqAiZOHhoaZm5WTlJKen6eVpZaflIuXlJWKk46QjpSQloV6hIqHh4SBjXp8gW+ChYeJgIWCfoGDgHiDjY96cYF+fYZ6e4CUio2Fo5ejjXCFfXR+goF/eXOAiX1xdoB7fGx8jJh+qpGAf4N8fox9fHR+b3+FhoWRi359gY6apJZ9iIyVmHuNuXWAg3xwd4F4w9F1aG1zgXRpd37Ha23DzrBibWdqan13b8C2x32DdG95gXZts3avnNCmma6lrc2Ch3B0d4SIec52b3jNbnKByW+Gh3+XioGHgZWdoHmEgYB+gqWfoVdWVlthZF1kaHxMUVRWVVJRlY1/dVdeqF1ZrJCFem7UbGpoeHPMdInW08W/y7xneHZmvmZzwMNyb4F/d6imvMW0rGtsZ2q+xsa/tMPOemx2csCT74bKgpGMpqWacmOek4qzbqTCsre4vqOys7TCxM2wsZyYoqCcm5aOloCGlLW1rry/oYOKoqyOj7K9pZGmts53bm/ZdXV9eI2PiXWGinHRv8dpvrjAyXSHgHR4ipWJoZuWUVhchW22yW6Rknh5d21qaNRpasi+v2ZvcmdraGrOfG51bG2BgYCFeXK0y3HFpqG7nrO2tp+5uW9+a7ltxJfFa22ftchvdpWFuoCuX6uwrKCXmY2CkIB7hIh9goJvdY16bnB/end3fnp6gXvXw8NndXqXgnd6cHeHmqCeo6m2qK3CarOvtaGYqpqbsZCisqK4sbOxuLexqpaWio2UkYmBkJaRh4ybgnuOe73EcHuNjZqblqKTkZ6ZlIGejI2fWaKpYmVqYVpfZ3BsZIBdYGJcaGpjYWS2hHCmtspqfHx/j5yPmYqmrWVpZ19bU1OQjZyHiJCSjJmaiXqBbWyAjpOEenZ+f3ljZWZoaXhydHSCg5maiHZxcoBzY2BvdWd6eYSOeWhtcbjDaLpjap+zdb5kusa2x7ivxn5uYl+faWtou3d7cHFwjYV0aK96hYB2aoBye3BsbYVvsp18Yn19bnqJmoaOkZGNdYOcV62dlalbqpCYlJGXjIiNnJijqV6VfYeLjISMkZmahYqNi46SnY+AgqlhppmSkpmojoaglnpspXCemaadjZxhW5GPg6ORnp6sq5iSnqaYjYuKg4aEb3+jp56hnYV6gJSMh3h1fYR+gn2Ffgt9fXx8fX19fn19fYh+gn+IfgF9k34Bf/9+636CfYh+gn2JfgZ9fn59fX2IfoN9iH4CfX6JfYh+CX1+fn59fn5+fZR+in+HgIZ/A35/f4V+AX2FfgN9fn6GfYR+BX1+fn19hX6GfYR+h32EfgV9fXx9fYh+hH0Bfq19BH5+fn2LfgR9fX1+hH2Lfgd/f39+fn19iX4GfX5+fX19h34BfYt+A319fot9DX5+fn1+fX19fn59fX2GfgF/n36DfZN+AX+nfoJ9kn4Df35+k38Gfn5+fX19i36Hf7h+C319fn1+fn19fn1+h32EfgV9fn5+fYl+AX2MfoN9j34Bf4R+AX+NfgF/lX4Bf4x+AX2HfoJ/pH4CAgQAgJicmIqG9Z6qnaC9kuXMgMOjhNTihKHOt67xgcm54PLwiIvkrcfp5e3e0erYyq3Lx8vKzMiwsNDw/9fRtb3S2+Ta1MjPtqG3v9bV1MHD0djQxKu6rp+ao/+Cv8nFz8S+0s7lvsTTzsKx1La6uLS52tDSxsXW5uXFxtbY08rKsqOrgKianZWHoKKcuNPGvbS7vcCeuMXLxLOswrCsr6+8uJytusLM4NPkyMnY9Pvx9dGGkoyMg4GKjJDr3ePG2uStvsjOyZqsrt7ZyrjKur3GtraopbDIyK6rkJKenZKrqri9rbmeo8/BsbrAwrvIxcPe2uC5yM/Il5uZq7aqp5u+kKDCgKO3r7G1qJyjocejkJ6Ltq+UobKdqa7Fvsm2rKy7uLWUqamvmpScorDGn5OlrKiTnaCVgam5vK29rquPqputmKCalbyTmp3YhaWF7Jygs4q7pI+cif7koaTIwJ/M8PDr+ouNqKCNrrGDk4KJpaGftJuMqq+0r63U0tDA84O/m/+HgKee8tjWgYiRj5CNmqXLzfWHioaOh4/1z7GanoPs5vTow7CnhYual6G3+Ij/k7SG1+PWj/Hd3uve1fmC3uCHgoLVzdrKs7j6+cf2+/nr+vfYv8eMlJOA7b+J+ruAl6Hi5IjQ0+rHvbHU94yJjPXCsq7N6Ojj/ePazMvd5efo9oSDgJHmwfHr3ID66eONkqKs3I3l1aWvwMzR6oCPmZWYlaKQlaeehYWfkPzej4KNy9za1Mm6vZafn6mwztDT5+z1gOjd8N2m7YKFiIfo1eDm74KStN7CpbCW+PmH/4OclJCcmbuusLiikZGOi6SLopONkaamoZWAiYiitqqry92Bj/HZgNDc79nXyMjH37yuusHLzdXTu5WKg4+B6v6ChfLz4++M/+/g+4aVrbKRlJ6UpbOqw8fJxc+8yebh38jB5uPbu8zh08LD0OLZx9TOytTj3ubMzcy8rtHOsaqnmf/VtZy0yYOsqKOOqIqYmKvOu73C5OvTx7jD0oWFnpSMiP34jo2dgI+Oh4qM8tnKtpCQmYzuoqytsdLh6dri/5yWhoL7hO/N2+fTs8vu4tayraqouqCTuKOcqb+tmJy2wK7Eorqzo6XSqNK9tMzLtsKWnaSSq5KJrZ2Zq6ipraik+uaD/YLw8o6Y/I+Choi43YqelOWMkIGB74qHlJWMiKicmp6KioSOgJGwqIyOpqGriPHSzpXFya2wk5mwwdbJvcbn+4iQidPb5Pbf3tbUobu1rM/Dr6K63eLg7P/04+743sa5y+C5ysvZ1cjNxOT50cq1+ZPt14bdyMa+0pKG1dO1u9Xdz83E5uG4jKOx5oDY+YHFro+YpbjjsLnw6ufWt438hLWmoJSdgISGg3h33I2XiIulfcy7d7KRdLnCcouyoJXKbayhwtDKbnTCl6rHwcm9sMi4qZOtpq2sraqWl7HM2ra0naS2vMO7tKqxmoygpbi1tKOlsrewpJKflYuGkd5xpqypsqWhsq3Cnqa2sKSUs5ufnZuevbOxp6W0wb6lqbW2saitmI6VgJKHioJ5kI2Gm7GooZqgn6WGnqmuqpmTq5uYmZihoYeboqetua62q6m3zs7JyrRue3N1bWpvcXK6sbmlrreRqqqqq4KUkrmzo5uplZihmZSQj5inqJSWe3qDg4CQkJmZj56Fi7KmlpygoqOsrqa/u8Khq7Klg4iHnZ6TkIejf4ulgIyhkpWajYqOia2NgIp2mJWBiJaEjpGjnqeclpGamp59kI2Th4SDh5iijn6IkJF9iIaGcZCYoY2aj5F8j4WShIaMeJt7f42+b4t11YKNoIOmi3yJeePTi5C3uZi+1d7W4Ht8j4x3j5Rxg3d5koyKlod8lpKXl5Gqq7Chxm2vktRvgJONyrWyam14dHRzdoKgpbpoaWdvam/AopKDhm3Hw87Ko5aQdH2LhYyk2nzhhKF5xdHDf+PJxMnFu9lyz810cnG8uMm/rKro5L/b2OLN3NjDqq97fINw1raE+K1yipLExXW6ws+zrKK81HRxddWrnJ63y8nF4cvBubLC0tDU3np5gIvWtOHayHjg3umPkqGr0oHQwZ+mr73A1XN8hoCEgYh5fI2Hd3aLfN/PhHSAtre1q6KYmYCKh46RoaSvvMLNaLy+zb2W1Hp1e3fOxs3Y13qEnr6bjZuB1Ol34XGGgHyIhKGVlZ+Mf4B/eJB4i399f5KSjYJveHaOnpaXsb1tecq1gK25zLW1qaqrvqOXo6mys7y5pIJ+doB00+Z1d9jay9d85tnM5XeEmJ6AiI+GkpuUrK+vqbajsM7Fxa6pysa/o7DCt6ios8S5qLevrrbDv8ivsrGnmbm4mZWTh+fGrpSlu3aYl497kniIg5SyoKGmw8q0q5ulrW5ugnZwbcnHc3KBgHVybXJ1yrWrnH19hnzQjpSUmLO9xbS9z352amjJbMOpsrqulKfEu7GUkI+Mm4h8m4qDjqCRgIGXoJCjh52UiIqsiK6akqWkkJx+g459k3p3jIN/jouLjIuJ081x1G/O1n6D3IB1dnioy3qIgMd7fXFwy3h5gIJ3dJOEhIZ6enN7gHyZkHt9kouTd926t4GnqpWXe3+Uo7SmnaPAzG1zb622u8q3trW2iaOak7OnlIibt725w9TOvsbPu6Sbq76aqay0saaupr/SrqqY1nrGtnC4p6WjtHpxsrOZn7S6sK+mxsCie4+YxGy1z2umlnyFkJ7El6HSx8OznXnac5yMiH6KgHRzcWhmxoGGeHqLbLmrdqqCZqStZXqbioGpXZWKp7OoVVmfg5Sno6qhlqWZjn+Si5GOkI5+f5ess5mTh42cn6SdmpOWhXiGj6CcmYmMlJuVioCJf3d4hclkk5KPl4uKlZCihpCcl42AmoiMiYaIppiUi4ycpaCPk56hnJKYiIOFgIR3fHNug3x7ipmTiomOjpd7jZ2cmY2Dmo+MiIaLkH2Hj4+UnJWblZKgr7CxrZteY2FjXVheXmCglJuOk52AjpKTmXZ/gJyck4aMg4OMhIGAgIOPk4iGc290eHR8gYeHgIl8f5eQhYiLiYmWmY6ioKaPlZqVeXl5i46DgnmQdHySgIGOhIaKgX6AfJZ+cnpqgYN1doBzeHyMh42EgHyChYlwfH1/enl1dX+JeG54e3pveHt7aYCJjHmBeX5uf3aAd3h8b4RscXqyZnZov3N6l4agenB7cNHHfn6xrZi4ys3J0nN1hIFwgohqeW9xhYB7hnlyhoCFioGQk5iNoFuXf7RbgH59qpiaVlphWVpZWF12fIhNTU9VUVaSf3drcFysrra0k4aCa3N+eIGRz3LRdpJvuMCwb8m8u7y6sMNmvLtpaWmzrLixn6DT0LbLy9LCzMK0nqJwcnlvzqmG+KRkjJG6vWyytMCpnZanuWhlacOkmJaqtLayxbm3rKKuu7e+yW9xgIDLrszMu3DV0NeXkqOlwHnKwaKjp7O2zW1zfnd5dXxxcYB+cG19dM7AdWpylJmYjYh+g3J7dXl3f4SSn6aoVaOkrqOHxW1raWzDtsDFy25ygpiBdoR5ztNsy2h7dXR6eY6Dho17bW9uboFrfHNxdIKEfXZmcG6CjYeFmqVdZ6eWgJOerZqbkJKUpJGHkJWdnKeom310bnZtydhucdDSv8x53s3A1XWAkJJ3fYB6ipCKn6CinqmZpLq0sp6dt7OrkpitpJeXoKyjlqGanaSuqbKcoaGWkKalkIqEfdzFsJymu3KMh4Jyg3B6d4OcjZGVrbCelIaOkVVXaGBZVZ6hX2BqgF1dXV9gqJqXh3R0fXHDgYGAhJWeqJudoV1YUVCbVJyKj5OLe4icmJF7eHd1f3Fpf3JrdH9zaGl7g3eDcYF6cnGLc41+eIaDdX5rbHVpdmhmcG9senZydXd0vLZjvmC1wGxvyXBoa2qduG55crhubmNit2dpcXFoZn5xb3FpbGNrgG2Efm1wfn2AacGponGPkYGAamx6iJOLhomdpVhcV42WmaCWl5ubeY6FfpeNgHaDmaCZobCtoaStnYyFkZyBjZGTkImOiZ2ukYx/sGaon1+cjI2MlmJcl5eDhpebk5WLqKWKbH2ErF2UrFmOgGtzf4iog42yqKKSg2W6YoF0cm54hX4BfYZ+hH0Efn59fYZ+AX+FfoJ/tX4BfdZ+iX//fpB+Cn1+fn59fn59fX2EfgR9fX5+iH2bfgV/fn5+f4V+i3+GgIZ/jX4KfX59fn5+fX19fod9Bn59fX5+fpJ9hH4GfX19fH1+hH0Bfoh9g36SfYN+hX0Bfoh9AX6IfY9+gn2VfgF/hX4BfYR+hX2IfgR9fX59on6Cf5l+BH19fn6EfQF+hH22foZ9lX6Gf4J+iH+IfgF9in6EfwJ+f7t+Cn19fn1+fX1+fn2EfgZ9fX5+fn2EfgF9l36DfY9+g3+tfgR/fn5/hX6Cf49+BX1+fn5/j34BfYZ+AgIEAIC8y7q0vZyywL++z8+gnuyfzYS/vJyvzLzE5cmVsc6t0Njc2ciutdry1c+Bz9L1ztTc39PT29S66O3Yz8zU6bi+ydzc28zX0dvm1tDK0t/x9fnXyb6xsrOrqrq6ucrEysvW2tfX0MO7vsnM3866sr+uq8PRwszh1tnd1dXP4t3f24Dn1Ovp3MrJo4+hr6ehk5isq7/Iw8K1tbi2xMzN1tnIxMjY8eH2hYOPj4Tb+omVk5L29/v1hYWE+OHX9t/Qzs7SxbGwrq6koJGqrLWktbWqq7K9taaCkYLj+pGgqqG+vs7q39HEroydnI+Mka/Gs77EtbnErMG/wbu2mZShz+Xi24DkhPzM496iuMSxsLvHyb+tw7+vv9rBrb/an5y+tqO6gpS8r5GbreDHrJz4sLasqI2NtMOx1abI3ruujJKJiYikvdzcsKqFuI+F9cynlbWn2YHplIyGguyX68uJi5aI+JiIkbWavID2lpOHrraBq72di5uw1dbFzqvCvMP917/u8IDPu/O05ubth6iipbfAwdzo9YKAhfn69rWPhJ+M6uL1ge/sqpfm/97K4IGPgYSHlY6Vi+Dn+/rm9fvu4dHj9+7g+oOJ8ebTvM7MvqawyrTx85qWo5OlmdXwiZjnqPeMddtyhIiIn6SikZuu5YOF7cTH5vn27ezd2Or8/pDDwMDe2oDi0sWtzNiosq6l26Hgp77yg4jiubfg49TDwfnygILa1NP7mamAjpmFkq29z8awm6y+qqiqvKyYmI2npMe/l5yhyvzs9P6GhvXNppW0pJOhr6S64IOP3r7D7M6elczZ+fPt9o2Vj4GbmaCVg/Dv2OP3hYPl7/rF1d7o7YuL8+HG14C3raqmn7PAy7DEzb2wq7qztKu3rauun6CxioiPgMqz/ZSgsZuqpqGZmZ2pnMG3qqKeobq/tcrR0c66qsLVzMS+vrXFv87XwdC7vbrBxs/Lv7TLsbasnbPFu6uem5W13e/Hxs/KvtPGuLK6vcKnssbMyNbR0O2Di/2G+tDq8pCMiYD6+P/wip2Pidf5+NnMwsuC4eD9g4T549bv9uTQ0dK+wNbesq/d7Mu0wrSyjrGhobfHw6CopZ+xwsHLy8q/kqrG4+jT79yyraOso5ahmIyTs6Wu0augp6b46IiDh4bh1J+R/PeI4/mD3+aOnZeI8rmjn7aSoZKGiJizm5rW17KOpYCmnqCMhZ2Knq5/tvSo0rOuoK6ynpylzerq+NCu74SJ8tTn6suinfqTnritwLKkwOnt8f+Lgffu1c7h7tmB9Of14ufZy7zW7oH5+I6c16/RyLrg0tLWyfLiwbzC4cLSwdLVwKirhoX3sMzIxMTaqJaCrsri8b7ZuJ+X9dSWqa2lvYCfrJ2Yo4SbpKins7WLjs+OuHesqoqYraCqxqt+mbGSrri8t6qVnbjKtbBtr7LQrrW7wre2urShx8i2srC1yZ2krby5vau2sbvDtrGqsb3Mz9C1qaCVlpqSlaGfm6qnrq22ubi3sKehoaqwvqydlqOTjqCro6u8s7S1rrOrvrm6uIDEscfEvamqjHqKl5GMgISTkqOsqaqdm56bp6iosbapqKW1xLjRbmpzc2q50HF4dnbKyM3Mbmlrx7OyyLGnqKuroJWWkZGHiHmSjZiIl5SUjZKbkIxvfW/A3XyFjoWZnKfCs6+hln+JjH+AgpqvmaKomZ6jj6qhnqCWg3+Jq762t4C5a8+tu7KJo6OUkZmlqKKVoaKQorSckKC1h4uflIuYcYKflXl/iLSokY/kl5eQloR8jqCQr42espiWf39yd3aImbG3kI9vsIp13rSKhaOaxnPKfHhycdKI27J5fYZ63YJ4f6OEonfdg4R7k5pykKCNfoWRr7SjrY+hnajOsqXFxYC0ocmVvMLBbIR/g5GXmayywWRkZsbGv5J4cYR0ycLTbs/RlonH0su0wGx1bnZ2iX9+fM7T4erN3eLWzrrF1NHL2nN94c/ArbvKrp2etaDS1YmIkoKYjsfuh5XYkOSNfOV0io2GlpyVhYub0XJ01re4z9rQzdDHusjf2Xmin525toDCtqyXt8KapJ2RwpXIorXVc3nLr6fL0sSwr97icXPBw77ehpR2f4p2f5Odp52QepCbi4+NoZZ+gXSJg6OWf4OErMm6x89tb8eskomikYSTmo2jvnF3uaWkyrGGga+61MzGzHR7dmyAfYN6bsvLtcDRcW/Cy9Wntb3HxHN1ysCmuYCdlpOTiZulr5istKiZlKScn5Wgl5yZi42eenmBdr2n6YWPnoqXlpGIh4uYiamgl42Lj6ionbG1tLejlaq8saikppuqpbG7pbijo6Koq7KwpZyxmJ+WiJ2ro5aMi4SkwtOrrbSvpLqsnpmgo6mQmqivqrWwrshrcdBsyai+xXJxb4DNz9XJcYF3c7jV1LivpaxvvMDWbW7PvLDDyLmsra6dpLC2k5O4w6aWo5eYeZiJiZulooiPjIaWoZ6op6eee4+kt76sxLOPjIWOh3yIgXV8l4qSroyGj43QxnVwdHPAtoh93Np5x9xwwcyBiYJ10KKNh519jn1zdYKbhIW3uZl5kICSh4p6dIx4jp18tOKTtpaUipSXhoKMrsLEyqyPxGpvwq3Aw6mJiduAh56UopWNpMfHzdp0bM/Hsqu7ybRtyrzKub2xqJ2yxWzOznaCspWzqp69sbO1qsu9paCmvqSyprS3ppCUdXrbnLCqqqq9kIFxmK3C0qK5m4mD1L2FkpOKooCFjYOBh3KJjZCOm5t6e7uEqGeboX2HmY2XqpNthZiAlJ6dl4+Ah5mllpRakJSokZedo5qZm5iJpaWVk5aaqYeMlJ6hopCYlp2lmZaTl6Swsq+Zj4h9foJ/hIqEgY2Nk5Ocm52flY2IipGWn46CgY1+d4KNi5Ohl5aYlJeOnZ2cmoCplaqqo5WVfG2AjIV9d3qKhZWalJaLhoyNkpKQlp2RkZGcqKSxXVtgYFuhsl9kZWOtrLKwXVhbrJaVpZeRlJSWi35+fn95dm56eYN5f4GAeXqGfn5nbWOyxWxweHeDi5GioJqPjXt/gXt9f4+ZhouPhoWOhpWQjZCKd3F2kZuamICbVrSdo5+Ai42CfoGNj4uCiIl+iZWFf4ybfXmIgXaAZXKFgGtve5iQhHvKhoZ8gXFvfomCkHyEkoWBbnJobWpzg5KagXtmp5Ftyal8cJiUt2q/b2pnZ7x3x61tcHhw1Hlwd5J8km7ReHhwhYZohJGEdXt/j5WHlH6KipWqmpCnpoCai6iEoKScVmFdY2pwdICHlExNT5mdknhlYm9hq6e3YLe0hn68ub2tumNrY2tve3V2csXH0NS8x9PMwq20w729v2Vwzb+0o7G9qZucrpvBwnx5gXaLhbzKfZPGfNiYkP+BkZSMlJGQg4iQtWRqx6yru8W1u8G5rrbEwWuIj4mhoICso5qIo7GMlZCJuIXEnaXBanHAp6C6wb2wrNjYbmy+vLbRe4lvcntscX6EhoV+bniEdHx7h4ZzcmdzcoJ8cXJ1iaGZoqdYW6mahHiKgXaBiH+IoFpippCLq5p4dJykurKssWNoY11rZm1kWqetn6i2Y2KrtLqSnqOrqWJiqaCPnoCKgn+AeomQloaWnZOIg4+OkIiQiImOhIaRdHJ4b7Wn33mEkoGOioeCfICNhaGWjYWEh5aXkKKlo6aVipeooJaUlouYk6OolaGQkZKam5+elI+ejI+Ie46ZkYqEf3+csb2dn6WfkqSajoaRkZWCjpeelp2YlaVUWqxXoomdo11cWoCqsLKnXWlmZKO6uqablZdeo6OzW1yqmY+anpSNjI6DiI+Re32Zm4R9hn1+aYF1dISHhXV5dnB5g3+EiIiDaXiEkpmMm490cW50cWluaWJofnF8j3VweHW2s2NhZGKopHFrwMBpt8BksbhweXBquJZ8d4pvfW1kaHKFc3aenYZse4B7d3puZ3tseJeHu86EmoB9eYCBdXB5lZ6goYx2nlNVloycn4t2d8Ryd4mAiYB+kKutq7RhWqymk5CbpZhappmll5mQioSTo1isrWNrlIKckYmgmJeYkKqgjYiOnYyVjpuej3x+aGzGiZaTlZWlgXNph5eotYudhHdyvKlzfXpyhY5+Bn19fX59fZZ+AX/6foV/gn6Ef4R+g3+gfoJ9qH4Bf6h+AX2bfgx9fX59fX5+fX19fn2EfgR9fn19hH4BfYd+AX2gfop/g4CIfwR+fn5/hH6FfYl+j32Cfo19hn4KfX1+fX1+fX19fIt9gn6NfZB+An1+hH2Cfop9gn6EfaN+gn+MfoJ/jX6Jf4V+gn+IfoJ/oX6DfdV+BH9/fn+EfoN/hH6Ef4d+Bn9+fn5/f8J+gn2Efgx9fX5+fX1+fX1+fX2EfoJ9mX6EfZF+gn+HfgF9jH6Cf4d+AX+KfgV/fn5/f5p+AX2SfoJ9hX4CAgQAgLXBu77ZvsvCob3GlY6zo6WUhO31kpKUloSOo6uu2//fzce8uJ2asbfP5u/z69nU2Ofv3dHA0e/bvavD3dvqxcnYhIfz7drw9tz1+N67pLTRzrjP4ebn1a+4wrjBw8PX1MTKwb/Sx9zb1uTN3Mu+1d3e5+TY5NDMxsa+vsfU0srMgMjZ28vMtqm6o5iToqevqrWvwcLRyeD+687a7+7cxcnm5ICI6+f2ke2B5+jY94D9+YWF/YHk4vvv5NWhqrHB0NfUzryvsLOpwL7OtcPLwp2DnZifhoGMjpOYxrOqsrbc7MC+sLbOwsK1tqOins/TmrGzvKi9uKCLvKqEh7G41evrgPrhxsXCvcrLtsns5LO3paO4193q29TQr8axubq3uNHhv8WlqaLLxbmUjayhuc66x7W/t9eHhNLSs4S9mLGHrK6htpWGiZnp2oWKl6KMhv2D/IqplYGKj6PUu+uP0d/hg4+imsinjIOgqaS0prSxy7yvsc6A9IODgeflvbWw4+n9Hfemw8z15/P7jpy1qbTX9YWHhIaB+4j+qoSOk5qGhIGA5bL30vORgfKJkIHLxrXc1/v99d/2hYCCgvidnZXsjPCGjpOMl5CAh6CllPD6zb+OkYKbrKG2zLqulaaQqbiImJyNiL318uyVkaPp9OqSgNyKirXEoZWbpbC0zNXDxa2dxdrVu9Spt53xh5GFg4H66YGA54CGnJKj6oyD9/3S1reA5qS4wtrX1cq1rbW0tLK1vqahjoGRsKukmpOMi4+TlavAvsfGytHk2OX48ODj9/uA54WCgIeDhu3T3ODWgoz88fHy8uvrwb3O4/Pm/fz17/2Pk5uL57652tnCybistLCai/aZtLqws7mzo7PExsOxrLeltpqloqmjopmxtaG8usKAtrCrt7nD0L+xtMa/wc3Ltcju1cC7n7HK1cbTz73Ww8PEwrfQ2OjRvbbAtKqlsaafqKunr8nDqZ+qtLW2zMCvu7rL2+bq4/Xb3rigpcPH5u/sgPnu1NWHif3j9O2SiomUl4qapaqZkp2lrZjq2uSPwbyxkIPx5+G5tbyuueL68/iA48vCsbnCsKKN95eZqKzU0cLQtLzE2cfEs7aska3Pura6r8nas6ONobagqaagpJWAk6KxpI+g6Nfg5YSEhpenhIKZpZH5nZinioCkm5eInIeInrapkP2FlY6cuJ+Pm/+ov7eJlo+yi/TMguKv6oqvs7irsLair6SSt8/gyND5+5Bf8tu54MOKjv2GosbU5cfP09bYusjGyqK8pqy3trXfioTe0tnWnafA0uGL9Ojg3tPw1dCzz8+4s6bdwrjC7+LYwNva9NOev8nOycPN3eHa2M227O3kheq+nqOescyyrqiAmqShorOfraaLoq6CepuMj4F00N6GgoiId4CPk5a617ytqZ+ch4SYm67CyMzEuLa2wsq/tKKxzbyik6fAvMior7VvcczFtMnSudDRwKKQm7Kum7C8wsW1lp6nnaKlpLW0pq2lorGlure1wKu9qaGxuLe8urHBrqqoqaGiqbOyqayApra2qq6dkqaPh3+IjpiRnZippLWqu87BrLjHxLenq7u7ZW3DwMp2vmu8w7XPaNbTbm3Sarm5zcO4sISSlaSssq+nmI2QloednKeTo6afhniQf4t3c3x7fIamkY6Xmbe8m5+Um66doZefi4eIrLCJnZuhi56ZhHmjinR4nJezyMKA072jpaelrKiWqb+0lZmNjJm3vcK0r7OVq5SgmJqbq7ScpIyUhaqno397k4WTrJammqKVq2tsrKqTa66XpnKQk4iahntxgtjHc3eAinty43XdcZGCb3R8jcWyz4DH0M91fo2FrJN+doiOh5KKmZSnnpuVqGrAa3pxur2al5W1uNKA0ZOiqsa2wMhweo6FjKW6ZmhlZ2bDa8SMb3p8gm1qbW9twKDpudd/cdl8g3S4u6TGwd3j08LWcnByd9qHiYbaetR3fIB8hoBxeYyVhu3bv6x6fG+DkoSaqZiWhZiCnbR6fpR7dqrb2tyUkJ3W4NqQgMR2epuoh4OGi5CUrbCgpIyAhaazs5qwjJyFzHF+cHdy1MZwb8xzfIuCj9WFeujoxMmp05OdrMC1tqqUipSVkI2VmImLe3J6l4iLhX93dnZ7fJqdnKWio6u2qr/MwLK3xstowG9raWxnbsSutbyybHTPycnKyMLEpKGuwMy+1djQydN4eYF1xqKdt7emrZ6Sm5eAhnvWh5+hl5mim46fsLCsmpaikKSIkpGVj4+InKKQqqOtoJ2bo6Kst6mcoLKoqrS1oa/Vvammipqzu6y4tqW4qamopZ20usm1pZypmpKNmpGLkpWOmLGsk4qVnaGftaiZpqKwvczMxdW8v56JjqiqxtPJbdHJsa9rbdC5x792cHGAeXxxgoeLfHiDiJGAyLjBd6CYkHRrxsC8mpedkJi7z8jMvKihk5ykk4p304GCkY+0rKOxl56muaWilJiQeo+qmpiak6W1kod2hpqFjYmIiX1tfomTinqGx7rDwXBwc4ORcXCGj37di4KPdm+RhoN2iHV4iKCQfNtygXyGooh6id6AlaSfdoN8nHzeuHbOot54lpickpWbiJKLfJmuvaeuzsd0w7KcvqRze9t3jK25xKuxs7a2n6imqYqgjZSXlpWybmu4r7OyhY6jr791zcW+urLOs7CWra6cmo6+p5+lxcC2oLm4z7eKqbCzr6yywcG7ua6aycrAcMWfiIyJlq6XlpCAg4qKh5GDjo57jplyaYR5eGtht8d4dXl6b3Z/foSetJ6Rj4WBcXCBgo+ipaejmZuao6ahl4uWrJ6KfImjnKaNk5dcXaifl6mxoLKyp5GBiZ2UhJWdpKaZgIiOg4iJh5iSjJWNipaNnpaXno2bjYeQl5WamI+gj5COkIqKkpuVjpKAiZ2ckpmJgZOCenJ2fIWAjoiRk6KWoKynlJ6tp56UlKSkVFutqK5ipV2nqKGyW7WvXFyxXKWgr6+kmn2Fg4ySlZeQhXh4enF/hop8hoyIdWt7b3ttZXBvbXWLhH+DhZekj4+Ji5mOjYOJfHh3mpiAjIiRfY2Hd22Nf2xthoSUq6iAuKeVkpeTlIx8iZmXhYl/eoWWn6aak5eCkISLiIWEipKJjX99eI2RkHRtf3SGkIeQhY2AjltXkYl5YKuWo2l9f3uKeWxkb8K3ZmpxfW9my2bFZ31yZWVsfLayynK8xcBscn97mYNzbHp8doB9hoKSioaFlFmkVW9mk5yGhYaWmq+As4CHkaOXm59WXmpka3uJS05MTk+WUZZwWF5iZVlWW1xapJHQrsJ2Zs1vdmuxtKG8ts3Qw7fGZ2hqbMt4fXnFbbxobnJvenJnb36HftzJsqVvcGZzf3OFkn6BeYt5jLJ8dJBvbJ+8wceVi5TBx86ZhatlaoSTe3BudXl7kJiJi3uAc4WXmIWefYh6vmRuZWhow7hkaMFrcYF2hdF5dNvbwL6ivn6HkqGam5J/dn59fXh6f3d9dWhqfHd4dW9pZWVpaoKGhoqOj5KXkZulpJucpqdVo11ZV1lXWqeUmZ6ZXGKxra6uq6apj4uYprCkur20rrJmZ29iqI+JnZ6QlYqDiYSAdm7Ad4mOh4ePjH+KmZyai4mUhJZ9hYSIhYWAkZiHmZKclZKLk5acqZiOk6ScnaGkk5+9q5mXf4qirJ2mopammZeVkoqcqLKfkY+cjYiBioR/hoWAiZ+Yg36GkZCNoZqLl5OdqbG0sLqoq4t4fpSVp7CrXbGnlJNYWq2ao51fXF6AZGdfbXByZ2Ruc3purKCrZYZ8cFtToaCagH6DeX6XqqWlmo2FeoCGeXFkuWxveXqTiYeRfYCIl4iCd3t1Z3aHfXt7eomReHBjb3xsdHJycWhcanJ6dGlxr6Kpq19jZXN7Y2RzfXDLeHF3ZGR8dnNodWlweIh7bMJlbWxziXdsdsaAfoqHanJwh23JrGu9mslvhYKDfoKGd3x2a4GVnouOo55alY2FnYtnbcVqe5ehrpiamJqYho2Ki3WFdX1/e3qLVFaWk5SScHeJlKBgqqSem5OplZV/kJCHhX2jj4iJo6Kcipuar5x7mJucm5uiqamjoZaDqqilXKOJdXh1f5GAgH6SfoJ9rX6Cf95+CH9/fn5+f35/hH4Hf35+f39+f/9+A35/f4R+g32JfoJ9hn4DfX59h34HfX19fn19fZR+A39+f5J+h3+FgAJ/gIt/C35+fX19fn59fn5+in2Efgd9fn5+fX59i36EfY5+hH2Cfo19mH4BfYV+BX19fn59hX4DfX5+hn2ufgJ/foZ/hX6Cf5J+hH+NfgF9734Bf4R+gn+Efo9/g36Gf5V+AX2sfoR9in4BfZB+AX2IfgF9iH4GfX1+fX19kn4Bf4d+AX2WfoJ/iX4Bf6p+AX+KfgICBACAv67H1bm2u8rGo6e1h/iOlsPNjJiqsc6zmrfO0dni0L6uy7yTk5mbo7XM1M3sgvjd3umA6efHu9vfrpzY0uPDrLjL2/Dr7cXKzuCB/vHe7OvCw8LP1N/NwtnV0NvVutvg5uTe2NS519LV1sHc0s3a1+LY3OHT4/WF/OvX1cuwsq+Aq6u0r7a6vaq1tb64wrrQ39Xg8/Drgony39HLzb+81+iBj5WRlpaTkY2ZhouXm46D+YD69eqC05WRlpW5vby90enj2uDz6djr7PLJ0NvFsZ+xvrfEsaWlnqvRurOrq7/HwMO+3ODDsKeitI+cnbjAnYufo76toqCZw6OUq6O1wqmAgIuqrKzPrI2sxuiYsbytqbPI1Nvd0LnBtLnSztTO3c+etLKXt8zD4OHfvrqzrLWtrJvTwviDo6+a/Or1hpejsaKslP7Fj4aNpJ6TvKaH+Za1sIqZj4+uo4L4l8vYgpeSjYOO8f+Tpa+2t6ixyMLU3ta3uLLYs9bL3+nex9fH1NWAzK3Extjvio+D9Y+gu7vWhITo+e71hIbMg+2VjIH/6IWOzIrq2v+MjLTapa/u5ofJ89bY4Yn4hI+QjJ/Ej5mujuWBpsGzp6yur8DByaColc+xk6Lt4eGEqs7Vw8C8hKi/r/mur5yGo/DzucezsJKQp7iJhYyVqq60lJq/1s64y9GAzs3Avru6v7jDl4WZk6GijvyL0vaeysbJzNW/w6yxt6WQpbTF2cK5p5+M6/2Rm6CJ2daB6eL9utmTmIeioamWpr22oMmZlrO7xMbJxKKjrZuhmZyTmq++xa+0nqiawrvHytLY19e/2tfRv9LP3d/R4u7u2+Dc2Lq9vbWdns21rLiAvsm/qI2Yso2MqrvDv6qXnaKqmqSnq5yVm4yOl6a+vrzRybypqLq8rqqvtLW6tq+9xb7Bvra20tHWwcnP4NDM3+3Y2Lq1wLqji4+dsdXMxMq0tbent6Gosra2p4r9j53P0rmozfbd7/jy59jQgfLAwNnX9O/a1YyYlfz1/eOLoqKAnqGhpqOpl52il4eR2s+HmKmVj4bn79vQzc7EweXzxLGyxMu+o6aniJGgoae2oqizsLq1wbSUuLGira+oj7G0tqunssajq6mctKemxL2sqY/7lpah/La04Pfxga2Rk5iVh4eSjpmSgo+PiZKKkqWNh/77i/6JpJSRjv+rr7uwpZ2AsMujo6SLno2sjLmZvr7roZSasLChkY6bl6+urLGzweCH5vvygOn15c+8u7LZu6m1tdTAm4ilmsCtguOgsqXC4ZiA8/bc2KyrwoaF5721s6fH0dbVxcm81biPlJSmttTv0vjW3OH2ztju+vvh47ivwMHp3vLh6u7WvbrN19mmt72ApJSos6CdoLCrjpGceNp+g6mzfYeYmLCbhJ6wsrm/r6GUq59+gIWHjpuvtq3Hbc64ucduxMSqo7vAmIe8tMKlkp6tu87Iy6ivrr5s2My6xsWjpqWxs76upri0sLm2nrq5vb21srKbtK2vs6G4r6u4tL+3t76yusluz8O2s6uWl5qAkJGZlpudpZKbmqKdo6Cyv7W7zcjHa3DKvbGur5+brsBpc3Z1dXh1c3GAbnJ4em9myGjJxsJoqn+FhoGempmeuL22r7bJuK+9u8ChsLajmIqUnZ2qm5CFhpKvmpWMjqOkn6udurWglJCUm3yKhZahkHqIjaKTjIyHoIp/k4qZpY+AdXyRjpCrk3qUp8GEnZ6PjpWisa+wqZGfl5yrp62otKyMl5eBm6aguLS0mJmYjJeOjYKmpN1ugpOJ49DbcH6IlYqSgPK7fnh3i4qBoI551X6SmniAe3iTinPukMHTeYOBfXeA2/aCj5KWmouTpp2urq+boJa6lbKmtLy8qLessa2AtJCipa28bHNryXB9ko6hZGe0wr67ZWajbsB4dG3Wwm51sXzQwOaCeZq8lKPQ0He858K9xXveeH5/eo2ugoSaf9VzjqeZk5CRlKixsZacicCmj5vUzcBsiKSomqKhc5qlpeiVkoh2ktfgnqOVmHx9nat4cXh8i4+ReX+cq6aVoqWAqaiem52anpaffnKFfomOfeWCw9yPsa2trsChpJicopGCkZmotJuRi4h30Nd8h4Ryt7xvz8/srciBgHGGiJCAk5uWhax/gJGYnp6hoYiOj3+NhYl+iJihqJOahZKBpJ+rrrK4t7ahvbe0oq6uu76zv8vKur26uJ6jo5yIiLWelZ+ApLGlkHyEnXt6lKKqpJSFio2Xh4+TmIqFjX1+h5GmpqW8tKOUkqWjl5aanp2jn5ijqamvp5+hu7e6qK+0xrSxwtC6vKCcp6OQeX+Imrqxq7CcnqGQn46VnJ6fkXvgfom2uKCRsdS9zdbQybWwb82kobe20sa1sXR3d9LKz7pvgYGAfX+Bh4aIe4OEem95trBwf4p4dG29x7avra6losHKoZWXo6qgiY2Mc3yJh4+cio2Xkp2Xopd8mJSGj5GKeZeVmI+Ml6SGko2ClYuIpJyQj3fVgX+L2Z6iw9HMbZN8fX9+dHR8e4SAcXt9eH93fo54dtvZeNl2jYF+fN2Tl5+VjIiAlq+LkJF4jHybeqmPsqzPkH+GmpWLe3iBgJWSkJGUnbluvc/Fa8POwK+foZe9oZKdmbakg3SOgaKVcsiLl46luXxpysq2uJSSqHBxxqKdm5GrsLe2qa+ftpx7gYCWmbTJr9OyubvSsLXK0dTAwJ2Wp6TFucq9xs22oqCvtruPnKCAjIGSloyHipeSfICHbMNwdpmgcniGipqHc4yVl5yllYd9kYRub3J2fIKUlpGpWqqanqlepqiSj6Oig3afmaGKfIqWorSrsJSalqRdtKqbp6eMjY6VmKCVjZ2Xl52dhqGanJmVlZWCmY6TlYaZlI+al6Gal56XmaRYqaSamJaFhIWAfX2GhIaHlYOGhZGJjY+epp6isK6rW2Cwqp2Yl4qGk6VZX2RiZWViX19qXV9kZVxWp1qxrqpZnXd0dXWDg4GHmaCek5mjl4qVlZ2LlJ6PhHx9hImUi313eYGVj4d/fo6SjJSNoaGTiISGinJ7doSLgXN6fIyGf3p2h310fHeDjIGAbXB9fHuMgG+Bi512hIR7eH+KlJeXloWLg4CMjI2Ll5N8g4RwgY2Mm5qbi4WGfYKAf3WJjc1jc351yLjCZ255gXh9ctuydWxreHVzh35wx29/hGxua3CBemvaj7XCa3Fvbm500d90foCEgnl/jIWTjZGHjYieg4+HmJybjJyUm5KAlXeKg4eTVFhTpFpiamN4Sk6HmJSNS02BWpRfWlu2pV1emnLFs9N2boaig5K+xHCt1ri1t23Nb3NxcH6UdXWIdMRneo2IgYCEg5eem4WPgLikkpbDurFgdYaKgI2Oa5KRm9KBfnJrh8rGg4qBhm5umJ5rZmhreHl3aGyDjox/hYaAjY+HhIaDhoGHbmV0c3h8c9R2ucuCnZiYmqmSjIOGi4V2gYmPmod+e3xwvr9rdXRnrK1kx8DYo7JscmZwdHxyeoWCcZN6cHl/g4WKj355fHF6d3p1doOKkoGGdYJ0kImVmp6fnp6OoZ+bj5iXoqSao6ywoqKfoYyPj4h8fKKOhYyAlJ2Sg3B4jG5uhJCYlIZ3fYCHfYKHjoF8hXV3fIKWlpqqpJaJipeWjouMjo+Sj4iOlZiZlZGUqKSpmp+kraGgq7aqpY2MlY+AbXJ8i6ahmZ6Pj5KFkIKCi5KQg3PWeH+mqJOEob6qs7y5sJ6bX7COiJidtKqZl19cXrCorJtaZGSAZGVob25uZmxtZF1lnpZdZm5gXleco5mTlJGNi56dg36AhomEcnd0Ymx0cHiBc3l/e4B9h31pfHhrcXdwZXl5e3d2fYZvfHdue3Ryhn93dWO2bGtzuI+SrbexX3trbm5sZGRsbnVvZWtsaW5nbHlpZsPBacJoeG9vbMh8gIR7d3aAf5J3e3xrdWyFbKKQpqO/fG9xgH11Z2ZrbX57enp7gJVWmqeiWaarn5WLiIKgjoOKhp2Ncmd2bYd6YLF2f3eHlWJXpqSam3+Ak19epY6Jg3yRl52bk5aKmIVsdHB+g5ipmLSanZ2ylZuqrrKkpoiBkI+onKmeqLGciouYnp99h4iNfgF9n34Bf4R+AX+XfgF/rH4Bf51+gn+JfpB/Bn5/fn5+f/5+AX2EfoN9h36CfYl+AX2KfoR9hn6CfaF+BH9/f36Ff4KAhH8RgIB/f35/f39+fn9/fn59fX2GfgN9fX6FfQJ+fYp+AX2Ofod9iH6EfYV+gn2GfoJ9n34EfX59fZZ+gn2EfgN9fX6Fff9+pX4BfY9+AX+JfoN/hH6Pf4J+hn+8fgR9fn5+hn2WfgR9fX59hX4BfZB+hX2RfgV/fn5+f5V+AX2FfoJ/h36Cf7V+AgIEAIDVuJ60vNO8mbSdpa+0r4zm3N/KyrDAxuff+d3hx8iltMLgzrC9yMG1v77U4tbi7vfv1dT4+/P85PDsv9vSxeHu6cPQ6ePxhPz15v6Fgfbr5uXKuaer2Pja7uPm2t7Pz9W/zNTF0tDN2dnZ0c7GyrbB0dXQxba8xsTI27jDzNjU0IC7wMi9ubazuLGxtdLHw7/H8IDtgIzv69377ufa5/n42uLxgP6Wk4aKkpKA4oD13dfA0ejQv7qqqqu/vcG2r+Hn1MbaxeLvy9TIysPQ8tjGrrvDw9DQqbW9ycTTyLvXyLWysbO6sb3BwcGym4mKk5nxjbrFrYuFjIuMoaOlmZ2rqYCvuLC7r6mkts3M2NrHoJ7CxsvUs8/s0+PW0Nyxsc7pzrSmtK6/weLrxsrD4dG9s5iXnrHPv5efqKOsrqGfgJaZuNKP4ozIp7WSpYuezdqAirmvgZOjqaD+jJabiIqmr/f+2Z2a2pylwtnDnLbS1t/Z2pKhu7fa5tvLw+Pa2MTe7YCBwsnI84qXk4yborTF3tnp+vaAg/Dp99SO+YudlIeG9v3yzpCz+o+ekIPw4O3xlpqVi5WGkIyInLmdpr+8qrLEstXIqsnFvsHE2dHkuqWHmffU0MCt0tv1hrPLztmnm6OFkp6Yn4jb6YX91IaCmpj80s+E7OaNqKaMpaGWoo2ir4DCzcXFwsCUmKqoqrW5sKCZ+PHhzYejmKy+1Nnc6a2M+4qBgo6OlYCJ9/Xf8oKJ8fSG9u7ygfPy/IeflKatpaGHgZGKh42UnZmpsbe7rKOmnKyoo5yVkJCYmJGTrKCrpY+UqLquwLmmr7Oloo6Xr6qxtMO4r8O/vKOqqKTBvce8wYDn4r68wMfPwavCmYiZoI6VlI+Gj6K1sK2pu7qojJOSqNbfxb6ztc3g8Ni/pq6yus/IxMK2vezc0eLk1cy0sKmsp7LKt6iouKanrIq70djVy760p7C/qaedpZmfpLq5uMfBn6rA+v3j1Nnm8NXego/x7oLmgP6Coqu0k5GetKyslICXkZKaoJqPhYqPg4X7k4eEioH15u3oydDg5byamqvD4MW4uK6xuLSdrKmRha6poauTlJWhjp2kn5+tsZuHh4Khm4ykucnIsLLGqbKbmImDk4SE88fc2duElPCnsZCXo6ybjIHplZGO/aKTnp+ejouhmYabyKmDi4XBromrw6urp4CUoqy3nJGJkJPBhZjdhZOEkvC0sIKQsL/I3oSD8PaGgtTZ+fyI9evLytG8yeDyxbalroihtaqhwLH9v9qE96bP5Ozr5+TYsKynvcDHvLmwqL7r7eLS0OCfmIiWm7+4wcS/3NeGkPz8+4789Ynw1tG+vuHUp7DRyaWGm6akt56n3IC1noidobiig5qHkZecnn3Nw7yvr5elp8W707i9qauKmaO9r5akq6WcoqK1wbi/ydLKsrPS0s3Ww8rIo720p7/HxKSzycLMcNjQw9hwbM/HwsOsopGSuNW3zL/EubyusLaisLSls7Ctt7avrq2oq5ujsbOwppigqairvJ2or7i1soCgo6yjnJuYnJWWl7KspKGnyWvEa3LHxrrPxb2wvM/OsbjKa9F0d2xyc3Jjt2vIvbikssOwoaCWk5WloqWdkrq7r6KwoL2/p62jpZ+rxrOikp+ipayyjZuepKGvq6Cwo5qSkpSanp+foqWTg3d3gYDTfZ2ql3p0e3l2iIqKgIuOkICbnpqdkoyJl6elsbmiiYShn6msk7G9rbytrLGNl6/CppyMl46dmb+9oaijtamXmYOBhI2qpICAjoiOkoiNcoF7k7CAyXmjlquIlHqSyMxvc5eZb3+IjojfdoeJfHaJlNjuzYaPx4OJnbCngZSpqrGvs4GInpi2t7KpnrWwsaW9voBqqa6kwm53dm9+goyarqeyw8BjZLiyuaNzzHSGe29v0tLPtoOn3HyEe27NydnThoqEeYV6gn58i6SOj6mlmpion8atk6umnaOturXBn517hODBwLihwcbQb5KkrLmQi494foeBgHDA3HbauHhyiILbwL51zcx4iIh2jIl/h3eHkYCdp6iqpaZ8go2Jj5ugl4iD19XJvn6Php2ntLK9v4141XJpbXh8gXJ429bFzm51y9935OPgcefZ33mKfouOiYdxcnl3c3Z9g4GOj5SZkoeJhpeSi4iDfXuFh4CAloqXj3x/j6GYqJ6Nl5qOjHqDmJKYmqedlqmkooySko6mpa2ipoDIxKajpKu2qpeshniHjX2DhIB6fY+gm5qVpKSWf4OClL/HrKecnrTJ076sk5qaorOsraigpdC/tMXJurGbmZSVkpuxnZCRopGSlXaisru5sKaekJqmkpKJkoaNkaajo62oiZOm2drBtbvFzrS7b3vGyGy+a89qg4mPdnV/kIiJdIB4c3N9gHp0bHJ3bG3Lem5rcWjKwMjBqLG/wp+DhJWmwKWdnJGVnZmFko57cJeRh5F8fXuIeISLhYSRloN0dG6GfnSLnKimkJSkjJaAf3VwfXNy0KvBuL5zf82MkniCiZGEdm/LgXx62I5/iYqKeniMhnSGrJBweXWnmXiSp4+Qj4B+ipGbhH11fYCofI/OdoZ0ftGelG12lJ+pvm1sxsxwba2z0MtwzMOqqrShrcDQqJyOl3eLmY2IoZnaq8l54pOyv8jFwcG3mJaOn6GroKKakabIx7+yssGKh3mFhqedpaehvrJxeNPV1HfRz3LFtLGgobywjJe0qY11hZGOnoiRvoCYh3iLjp+McYV3gYWKiHC8qKOVloOPkaaes52hkJF1g4udkoGMkouAiYmbopqhp6+rl5ixsqy0pa2pj6SYkKGno4mZr6WtYL20qLlfW7CoqKWXkX59nbmer6Kon56UlJqOl5iOlpaVm5ePkpKRkoSMl5eWj4WKmJaXpYuTm6CfloCIjJeOhISFiIOBgpyWjouUqluqXF+trqOtp6CWobOtlZ2sXLVgZV1iYGNXo1iyqqKUmKidkZCIhYGKiYiIfpWfl4iQh5mlk5aQlY2Sp5+ThIyOjJSdg4aJjImWlo2Yk4uFf4GMjZCPkJSJdmtqc3PJcoSRgm5rb2xqdHJ2cHd7gICEhYSJgXp2f4qNlJyMeXOChoyTg5SempyXk5aGg5CYkIp3fHmAgZifk5CKlJOHhXNxcnqLhW1se3l6e3d6anFrfpBwvnGMf6Z5f3B+uMFnZ3+AZXF4e3XMZ3R4b2x1fsXZunF5unN4hpeRdX2NiYmMjHF4g4OTkZCMh5SLk5KenIBWkpCFmVVcXVtiYmlwgoGHkpFNTYqGiXVWnl5pY11dtri4pXSQzHJza2W/vMvEenl3bnlvdnJygJF9f5eShYmUkLachJiWjpOgq6avlpB1e823s62at7O6YHiHkKWDeIJxdHl1dWi0xWbMr2xndXTPua5ovLJncndmdnhvdWlweoCEjJSWkpZ1dn54f4SLioF9z8e9sm+BfoyUnaCipn9tx2phY21xd2dtyMKvumFpwcdrz8/La93Qy2p4anJ6d3VoY2pqZGhtcXJ6fH+CfXV5dYCBfXl0cnJ6fXh1iX2Jg3FzgI+HlY1+hol7e211hoCGiJSLhZWRkX6Bg4CRkZqQlICxr5ORkZajl4ebfHB7gnR4enlvd4SQjo6MmJSKdHt6iq25n5uRlae1vKuahomLkZ+cmpiOlLippK2zppyIiIeEgo2fjIGCkoSDhGiNn6WjnZWLgIyXhoZ7hn6DhJWWkJeSfoOVvr+up6mrtZ2oYmmop1iiWKxYaGxzYmNmcWxsXoBeW1xkZmJeWl9hWVeoYVpXW1anoKiejJCdoYNxcoOOm4mFg3l+h4JyeXVnYH96c3praWpyaGxxbm13eWxhYlttaGN2goqHdHmFdXlqaWJhamBfr5iwoqZmaq90dmZueH9yZ2O1cmpqxHpwdnh2aWl5dWZ1lHtkamSUjGp9iXl5doBpcnR+cW1nbW+Xf4+7anJmbbqHfF1kfIKOoFpYo6daVY+Wp6dbpaGOkJiMlqWylol+hm15f3NygoHEoMFrzn6VoammpKWeg4B8iImSi42Gf5GoqKOZmKR8emx1d5OJjYyInZhdY7OzsmSyrV6jlZKGiJyTdoCdkXpodYB7h3SAo49+AX22fgF/hH6Cf8R+BH9+f3+NfgJ/fod/An5/wn4BfdN+BX1+fn59hH6CfYl+AX2HfgZ9fX1+fn2bfgF/hH6Nf4KAhX8BfoV/hn4BfYR+hH2ifoh9jn4FfX1+fX2EfgZ9fX1+fX2bfoR9i34BfYh+hH0Mfn59fX59fX1+fX19/362fgh/f35+f35/fpd/AX6Ff8B+hX0Dfn59iX4FfX5+fn2QfoJ9j36EfYR+AX2IfgZ/f35+f3+EfgF/lH4FfX19fn2lfgl/f35+fn9+fn+UfgICBACA2ce2srmxu8LGvrW9wcWZ6+WWvbOkurzn+uDz6Lypz8TSyu3SyN7n0vfW2d7w/vSG/P344Nfu6dDP1b22u8Sxx9bq3drD5eLZ1MC7xN/i5uTY0dHI1Oru7vHm5end4c7FzcPL1Ob67tvRz9K9xNDW1cq+wdzt2tDZ3OnOvcHWu72A0sra69Xh7/nr49Xa/PLo5YOJ5+b/hoPx+Ovz/IL++YqLj5CRlJLsiYjHzba1u7e2zdfEp6fCwOLp1d3k7dHa4ujy89jf++jM1cvXxOHcyNHV7tuuuODn0vWDgPP15KO1p7OjyLykjK7ChoSJnJagm6bywLDYkpeTlrWzhu+HoJmAn9rb18DTo6zap9TNzM/W5/H+8ea73OrftKuys8XTtrvS5auJscPntNb9hIL54Kv9pMerxb6ytbO2k7WlopGjwcGjgYC6nsyQgZ2t74eUlaPBro2Wl5SHpqGdn4S5yrSolaK/zaLBj+f4/qm/ybOz0t/Qy8Lf3uDs2cjaj42334yA6NeCiYecmJyoo7Wystju8Pj/hPj65um7iuqJn56D5Nf149eOj5yxr4Lz+efLhIqpqqasoo+zuaOSlaSox7bEt7fLpKvDrJDk55OVm5CYiIj/hoyF3ors85aIj5WAlceFi/jKyJmdm66HkPr0+IaIg4CDlpORjp+GhpGempCXk5eAmrSuuqeHhoicp6qnn4SAgoLnjKXU+u/204yLkdnK9vjrw93m8fvw5Ojg+42KjJGGjbOtwLyW04SQlay4t7mnpJuPhfz29uT1/4WLmqCppruzoKPHyMHBpqCv09fc6Ozz59e4xMTRv56LnJuvrranpsG4raq1vcy3q7iss726p8WA2Nvg38GwsLe2psPUwc7l6dfY18CtssKwuMKlnbCkoKjlxq6rubbIv9DOxsG61MXH28fV9uvc1drQ2tvXusjDsK+/v8DD3bqrtMC4xbGrysW4uKiWlqKsu6q6zcPQr7Cuzc3d+MnK2evv08O9h4mNjfiSpKqkk6GivbO1paCVhYKAhI2UjIf/g4KMgvuDgumCgP/1/vTn372vlZa0y66khsHTgr3Eup2Y8oKB1vOeoYaPg5e4wq+aj6W7xb+ck52zv9fnvbu2trjivMO3r7GlqKCGhvT12IaQm4eqw9jhzMaVhIyC9v//qK3KqYP9jsCsj5+in4z8iIC/xPiNoNC0u8WAyrPav8Owq6mYheOA/9jptM+h2ZvJzM7G3Pf+8/bR1NXb1tbr6NK+r8DB3s7P39avnoSAkpKircm/qrXNxamio5uv+YPSv8233vbu5vvXvMz26MrY7+bb0pWO9auihsnWjevCwM+2scOaoLDZx8fDztnk2+bIysvSzMrKsb24scOAu62cmZuWoqmppp+hpayF1MuCo5mNoqLC0bzMwZyQsaKup8mwp7zCsNKytrnJ2M9w0tbSvrbKx7KztaSeoquXrrjIvbqpxsO6uKSgqcDAxMK4srKptcjLyc/BxMq9wK+pq6Srs7/NyLeurbGhp7C3tqqjpb7Gtq24ucetn6O1nqKAsqq4x7O7w83Auq2x0ce/uWtvwMHTbWvKzcbL0GvQx25tc3R2d3O6bW2hq5iWoJ6drKypk5Gmn8HDr7m4wKOpsLnGya210Lyqrqeyn76yobGyx7SQob+8rcpqZcDJwomekZ6Iq52Gepygcnd9jIGKhInTr6TEgIR/eI2RedNxh4WAi7O3uaSsiJa+lLOnq62vvcbOwbmfv8C7mJCTlaCslaCvvJF2laPHlbbTZ2nBtJfXhqKTn5uYl5SXe5iMjYGLpaKMb3aoiLeDcomj1nN/fImelH1/gYFwiImCkHGYqZaPgIqcpomigtfZ3pCkqJmUrLewp6O7uLW/tqq1cHOgvHOAv7RrcGx7eoCJgY+Njqi5ucDFZr/Br66Qb8pygoBrvLPQyr6CfYeZk3PW39i7dnmNj4mQinmXm42AgYiSo5immJiyio+mkYDQyX9+hXyDeHjmd3py033i54V0foJwgK9vd9S0vY6Vj6N2fuDe2Xd1cG1yf3l5eIJ0dXiDfnZ7eX6AgJSOnIp0cnWDjYuMhm5xeXnThpjD18XMrXmCi8iz2NHMrMPO1tnMyczE2nh0eXxxf5iQo5qAtXZ5gY2al56Kj4V4c9nP2cja3nN4hoeTk6SXiI2vr6aqkYyZtbi/yszSxbieraq4pYh4h4aYlp+Sj6ielJOdpLGfk6CWm6Skj62AubvDx6mZmaGgkKu4p7bIzbu+vaiZnKqZoKmQipyQjpPMr5eWo5+xp7Wxraiiuaqvv6u62My/ub+1v8K6oLCsm5akp6qowKGXnKefqpmTsqqhoZSDg4+Wo5Okt6q1l5iXsrHA3K2tucrItKigdXJ3dtB3hYmGd4KDnI6Rf393bGmAbHN6cG/UbWpzatBua8BuatPL08vCvJ6VgX+ar5SQd624bqGnn4iE0nJvtNCJjHF7cYWcpJODeY2fpaGDfoeXn7XGnJqUmJi4mqWYlZWLj4h0dc3OuHR8inOTp7W6q6mAcnlw0t3Zk5StkHLge6eWe4mMiXrjdnKur958i7OYoaeArpe9oqWUkpCCdMVy4MLUo7SLv4KuqK+nvM/RyMirsLC0rbLEv6+ckKKgu6yuu7aViXNwg4CNlKyij5aspJGMioaV0G+voK6cv8/JwNS1n7HVw6q2ycK8tYKB3JiNda65fNCppK+Yl6mFi5e4qqqmr7jDusKnp6mwq6ywmaSdmqiApJaKhYSDkZSTjYiMkpR1vrtyjIZ7i42nrpyqooR8koeQjKWUjaClla2UmZysuLNer7Kwo5mtrJaZmYmHipKDlp2nop2Qq6mfnYuKkqWhp6SclpeSm62yr66jqKufpJaQkY2SlJ+oppmUlZqPkJWamZKKjKCmlpGbnamUiI2cioyAmY+grZefoayjmpCWrqylnVdcpKKyXl2qr66vsFyxoldWYWNiY2KlWV+VlIeEjY+LlZaZhH+Oi5yglJyamYeHjZigoZGUrKiVlJKdi6SjlZqfr6GEjaCklqlaV6mvr4CMg416lIx4b4mNbG9wenR2c3bLs6jBdHRrZ3R3acRnd3OAeZudn46Uen+cg5WTkpaaoamvqaCOnqKgi319e4SOg4mSn4dseoqliZerWFmuoYfIe46EiYmHhH+CcIJ6f3R8iYd1ZmimepJzanqhwmZrbXeDf29vcnFkcnJzeWqEjoB3bneIjHmMdMfN0H6NjoGCk5uXjoufmJSZlo+VWVyInFuAmpFVVVFfYWRoZXFqcIKNi5OZTpCMfXxhVKZjcW5bo5y1r6Z5dXqJiGvFzsmvb25/hXl/e2+GiYB1dHqFlYqTiomafHyUhnrEunJxenF5b2/Wbm9qwXfa0HZocHNmdqpnbsmrtIyQi5xtctHLxWtnZGFjcmtpaHBraGhyb2hram2Ab39/h4FpamlzfH1+eWtpcXPKeoWltK2unXeOjbipx8O9obG4wsbGvcG1w2pna29pcYOAi4d4rGVqb3d/foR7enVpaMW7x7zFzWdseHuBgpKHe3yanJeagoCNpKeps7e6sKaNmJmnlnpqeHWFho6AgJGJgoSLjpiMgY2GiY6RgZqApqerrJaLjI+OhZ2pmqKwtKaoqJaLjJyOlJqEgJGGhYi4nYiHk5CelqWgmJWPpZqdq5unwrKnpamap6mmkJyaiYWQkpWXqI+EjJaPmYqEnpmRkYF0doKFkIKSpJihiIiJn5ypvpycpbawnpOOY2VpZbNjbW5vY2ptfXJ1YWFeWVaAV2BiXFuwWVZbVaxaWJ9aWa2nq6aenIV9bW+Bj395aZ2jX4SKg3FvumVfn7Z0dGJqZHeHiXttZ3aDiIRvbXWChpihhYB6fYCRgISAf391d3NkZLSrnGZqdWeAkZOWkI9uZGlku8HBgIGTfmXFbY2AbXl3dmnJZ2Ghnb1teJaBh4uAjH+YhoV7fHpvZbRoyrG8maZ4pHGPjpOMnKytp5+OlJOTkpagm5KDeoWGmo+SnJd/dWZmcnN7gI6IeXqQin15d3eBr1uUh5GEoayooa+aipawopCZqKahnXNzzYR7Z5eda7uOio1/gpByeIKdkJKPlp+nnaGJiY2UkJaYh42Eh5aPfoJ9nn4Bf+B+B39/fn5+f3+FfgN/fn6HfwN+f3+wfoJ/ln6EfYd+AX2tfgZ/f35+fn2UfgF9hX6CfZt+g32Rfgd/f35+f35+kH8BgIZ/AX6Ef4t+hH2afoJ9h34IfX5+fn1+fX2GfgN9fn6HfQV+fn19faR+AX2IfpF9i34BfYx+hn3/fqR+hH8BfpR/AX6EfwZ+f39+f3+PfoJ9hn4FfX5+fX2mfoN9jn6DfYV+AX2IfgZ9fn59fX2QfgJ9foV9sn4Bf5Z+AX2GfgF9nn4CAgQAgMe10/DkybmjoZeTnpqwq7CArbWvrrmt0unazbrY6oPusKS7o73c7f7vi/nY4OvU1djp1uTtgPvY8d7Iy9foz9n+ycXU8IKA8u7s8tbi49Db74OBgOvf6+fx/PPo6trOvc7S3cays7nO6vj+7+Dr69bV1evV0dzO0tbKx9PN0uTSgMHT0czg6OnzhoKIhIT4+oqDj6OomJOUjIDv/4Cam4uH/uj/iYPp4tWwmbq5x9u5wN7mz9Xt9vbo/v34/PTr3fiFhIXzwu3l4Lu17Ond1NnX2OnE1uDg2NXjxujJobi+scC2r6qeoqWcyKWOpKOvyMP4q92XvLrRuqWBkIeTnZqXgLbMq76Xta+yy728z8PF8e2+0ce8y8Hc6fDFzLOHx7nMyb2+rs7cuM/DiYiv0JeQna6h64mov8LWq7rMqKCkpa+w5oGKjryrhtWNnay0h66fm6KphqHY1JahprXMpaX6nKGJmamzwMLDtKOcr6W4pLyp0vLg7uDs6tbW8euW+YGGgImKgoiMnaax6Y7A08u91u3s6tTc5dvQv6mWkYONh/n8k//TmZeWgZyTvdOJhrSpjI6uq7K8npSjnrSooa+0rp6mvKqux8GpqpKAg5KEnsqxrbeurJ6N/eWInaCh4eCNid6B6/rG1qekkcbGzvr7kpmMkpSRlPaIiZGXhYCE5+v9gP+Km7GwqpydlpGYpJyPr9Xn2PiHkZP4y7uf/aGNprzS/IHx4PD+8Mvj2oCPjPuDjJWapbKgg5OYk42Qkpmiop6gnZKE/d/L0tnq2u/r9oyB9fOfo8HDsqOvq7mWh4+qn6fGu7Gkv8i6tqKWoqObraqcjOHRzNzzjaCkmoyKhY2XgJylxNnAuquhlaq6zc2ptsjMzsWrrqmtp6ajkJCfw/LmxZuYl7O5u7DAwqGyyLG3uMHG3Nfg1M/Ty7erwMy9zbKjv8vR0LexsK+rqbrIyqqgtcKus8LHvKmbrKSoq83Mytbk8vLt3+XVyLC81vvn+NLD9KGhjp6xtLGoop6XgoGTgJOSjIaQlpH+gvz35+rq4/Tw2dGrtbXFvcr1/NC7rKHRqeTcv6CdofeBoY2RkZWWn6aWssugoK6zo6CinJ6hpMO2tM7W0uXk79fGxqy6vKerpPn+9veVkL7Ntu/j29Som/v17emEsLSlsK2lrZ6frImVm42OkISZqaKQpcrAs6mggLGtqKKgqLzAxtbUwZmCwaKw25Sto8bC6I+D79XE5eDRydjmyM7Pt8vRwtvY1cS4rMaglcy4usrm1cnG4+ff5tjFv9nr7s/Lxd3+84Hq49zggfrlyunszdTpmdSOo6u8sZ+tnYyRma3Ms52svLy5mejC89O+z7jN8t25oZvKya64gKuctcm/qp6MjYOBjIWYk5htl5uVk56UtMG2rZy0wWvHk4uhip+6xtLGddK1u8OusrXJt8TJatG0zruqrLfGr7jbq6m2zW9sy8nI0LnCxLS7yG1sbMq9xMLN1MzCxrewn6+xvKmXmJ6yxNHRyLvDwbGysci1sLirsberpq+qr7+ugKK0say9wMLHb2tubWzOy3BpcYCGfnl5cmfF0Wh9fHFv0b/Ubmm/vLGVi6Seqbifpb7FqrXHzcW10dLKz83EscxraG3IoMnAtJmfyL+1sbi0tsCnsrazrLC5or6ojKejnKSYlJGFjY6JpYl6kIqUqaTfpc+FmZqjmYtweXZ9h4d+gJCijqaCnpKbrqKfsKalycOdraWcqKW6w8imqJd1s6C1qJumkq+2nLClcGyYsYN6hpSQ026Gm5uylJmriouKi5CUznN8f6KOeMh7hZCddpaQi4qTcYnNunyEhpirjJHff4d2hoyRn6WimpCGk4ybjaaPr8m0wbe9wq+1xbx3zGppgG1uZWtwfYCOw3SZp6OUpru3t6SqsaackYh5eG11b8jRedvAiYeEcouDtLt3dJ2SenmSj5WkiICMhpuUkZaZkoeQnY+TrauYpIF3doByj66Yl5+UkIqA6919i4yT1NB+eb9y0Oq6zp+dibOoutTSeoR4e4V6gNBzcXuAcHFzz9TqgON6ipqXkomJf3uDjoOGorvIudtwdnXKpqST8aGPoK++7WzPz9Hl3rjEunCBeNZzdn+Hi5OCcIKAfHJ5fYOKhIWFgX5z5Mm/wdDZy+LT4Hlv2tiOkKqqm46blaGCdXyTiZCqoJeNpa6ioIqCj5GHmpOIe8W4tcLVfY6PiX57eH+FgIePqLympZWNg5Wjs7aVoK6ytK2VmpSXlJGPgH6Mqt3KqYeEg5ygopemqI2espqhoKmtwrrEurO3rpyUp7Cgs5mMp621tJ6bmpeWk6Ovr5WKoa+Wn6usoZSFlI6Sk7exrLrF0c/NvsS3q5ejttjE0q6iyIKCcYGQk4uCf3t5aWl4gHd3cGx4fXXNa9DNv8TEvszJtK+Rm5mon67N066hko+7lcO4o4mIitRwint+fIF/iI5/mKqGhpGZiYWMhoiKiqWamLC0r728x7KnqpCcoYySjdXX29CAeKCulsy7srGPhdbV0chylpuPlpOPlYaJk3WChXl7fnWGkYx8jqykmpKLgJeVkIuHkJ+gprO1o4RyrZqlxIGVhKKXwHlsx7elxLqvprW/p6ytm6qvn7a1sKSckKqJga+cnavDsKSjv8C3v7enpLrGyrCrprzYzWrDwLvAbtHBrMfIrLTJhr57jpahmoqWiXqChpaxnYmWpKWji8+o0riltJ6uzLqci4axrZWggJOGmamik4p+f3FveXWCf4FjhIZ+fIV+mqOWkoSXoFimfXWHeIabpqyhXq2Um56NkZWnnKesWKuXrZqJkJqlkJy6k5ObsF9aq6yqrJqjp56hqVxcW6qgpaOrsK2kppuWipSUnZGDhouXoK2wqZ2ioJWWl6eal5qTm56Uj5GPlqKTgImWlpCfp6epYFlbW1utp1tWXWhva2dlYFeor1RmZVxds6u4X12rpaWOfY6OlaGSlKGolZmiqqSZqKuhp6qfkaFTUlmpiaenoo2Lp6Gdm5ybmJ+OkpWXl5eelamZgpWWj5GHhIF6fXx3jH9yeHd+kJHZp7pufX6AfnJhaGhudHNtgH2LfY52iIWJlY2Llo6MpaWJlZKLkI+bo6eTkoltkYuak4eNgpOWiJaNYl+EoXhvd4R+wGF0hIuYg4SQenh7e4B9umdqcIV5bbdtcnh7aICAfHx6ZXy+rWhubYOSen/Cb3hsdnN6h4qEg4N3gX2LfY1+lqeZnI+WnpGUnaBgrFpVgFZWT1BVYGJtp2N5fXtyfpGOiXuBhHx0ZWFcXltkWJ+tY7yjeX16a313rLBrZoqDcG2CfYSSenV+fIyGg4eKg3qDj3+Bm5yLlHhvbXZpgpyNi46Dfnx12spye3+KzcJycbdpwt+ywJmahq2kqLq+anBra3Ztcr1mZGpwZ2ZrxMfSgMtueISBgHl4cXJ3gnx9kKa2qMBkZ2W3l5CJ56mUm6SrzF7CvsLQy62xsWdybslpa254fIF2Z3FxbGZpbG12d3Jzb3Bs17+0uMfVxNPP0m5q1M6DhpycjYWNh5J1a3CBeYGWjYh+lJmNint3gIF7iIJ4b7ispLHEdIKDf3Vza3J3gHmAmqeTkId/eIiToJ+GkJ2ioJmIi4mNiISFeXSBmsW3lnt3d4yOjoSVl4CNnY6OkJicqqWso6CimIuFlJuPoYuAkZeen5GOiIaGhZObm4Z+kpqKjZiZkIV5h4GBg5yemaawtra0qK6mm4iSpbupt5aKpGprYGx3eG1kYFxeVldigGJfWlliZVykV6yonKKin6igkI58goGKiJevrZCIf3ysgqOWiXR0dLxmeGtubnJvdHdvho5ydH2BdXB0cHR1eImBhJaZk5yeo5SMjHuBinl9eLi6wbttaoePgKebk5R5c7+5trNlgIN7gn55fnJ2fWhxc2lqcGp4gXpwe5GNg4J7gIGBfnl1fIaGiI2RgnBlnZmftnJ8boeCo2VXppqLoZmRiZWfi5GSgoyPgZKTj4eEfY92b5KEhpGjk4iJoKKZoZyOjJukqpiVj560qlegoqGkXbGkl6ypkJmsdq5wfYKLhXZ/dmpxd4OVhXqFj5OPfMCVuqGSn4uXrZ+HenaZmIWOnn4Bf4p+AX+LfgF/j36Cf4p+g3+0foV/gn6Kf4J+hX8Ffn5+f3+bfoN/rX6Dfb9+AX2OfgF9hn4BfYx+gn2HfgF9nX4Cf36KfwF+lX8Dfn5/iH6Cfat+gn2EfgZ9fX5+fX6MfYd+AX2HfoR9kn6Df4R+h30Bfoh9BH5+fn2Wfop9BH5+fX2gfoV9+36VfwJ+f5Z+AX2HfgF9qX6EfYt+hH2qfoR9hn6Cf7F+AX+EfgF/iX4BfZR+AX2QfgICBACA5efY3ufq4b+rw6CXqLObjLeYpayszt/M1Lags83Nqamqz8zFuuXLgIaE2vDr4e329+PT4ffp2Nrb3vL2+v3w4OPWzLzS4uyA/IPZyOLj8oLj6+2IgYKA+f/1+fbg6O30g9bWgZD8gO/f1N/y8uuC/+De297I0dra5Nzx9fH1/OWA3dHS4OP7+Of1+f3h4tDJ3bilvuL8h/LZ9ebW4uHRz97Y387Kz9fEsMLLz8jQv9Lnxra65e/8gPr/gf+AiYmFiYPp2fL44uXh6euGh+Tw9Ovl4PDw3fz+hePI69eoq+jYo6vP39rlzrawz7uelJOtso+Q8KKlmJOSlbDDsKO8r5WAr6z3ifuYp7fFv72zztG/n5WLlrCpxbnIoJmfvrjByKqyy9ft27CFiYqbqbaXjO6eqaWxnLrBq7y0vcjK5L+omqKrmJultKC9wIebn7CojYCYpc+h5POPm6ub4MuloZfu9aCnp7vEt66ytbnJvcnExc/W2Pnn6f7u6LDk/oOb8daAhJmdk5CF9t/yhZ2pzq+2yfHppqezmr2nu6yI1+/bs7z16bL4y5m0kq+hhoOFhvuGi5KwwsfBuayXjo3e5KuijaCxnJ67wq2yuq3BxrXTusq3oKysxrCupo2Oh4aP8+fj2cuts8vzj4zqp6XKxuWBlImVl46D8umOhvrymqmps7mA6/eLi4LH2MvQzsfb4dbqgfmCiPmRkv3/3Kucl+723IOljp6V+oeV5v/r3NTO7oDX4Yj78YGFhfz65PDjgoDu+tbC0uDw6JSsrK6uorKutMfQxsO4ucDCx7Ksk5eriJqerK6pn4upr8K4tqWivLulivT7pqOWkb63hpW2vbuqj4GAg5iem5KgsKmpuKSfn73Nysixop+Hh4ydqZCyr93qubmsn6qwrrm1vbeuo6DDyrDEycG7vLS6sbe0q8GhrtHU37mss72xv7mpsa6poK2yr7m4usHCy8ayzcTeysa/yMzUydT35dTGvLW5ucrWgJefioeD+pWlqaOR/OPO7/mCj6eAn5WUkJCLjYOBgfWAgoj67uG4kZzIxsm/w9fLxb60oKmomaKfie7g6f6rjJCAh56xn6CitL/AvbWhn7yswJuwxMXL29O7r7DJw6SWvr/Rzbqss5qSkZ2/yM23t7KjiZKend+Apric/IWjkorukpmpm5yY84Wbj6a0sMWem6ymnp6AqpqcpMzDycPT1cfDvruUhY32hZmvqMjfyc7Q4Ibq3NnSubPd3dTe7dPF4t/NzdXVw8OwtrikuL3c5erSwKvF1fHew5SlwtXn5f/458f07eTi9O7j7P3f5evOt9favLmzvLW4n42dr8fAwuLFwsjaubWQh/e3t8vez9bc1eTgxsiAwcKytb7Au6CQpYmDkZuFeZ6Ai5KQrb6tuJqJm7Gwj5COsq+onsGqa29ts8bCu8bMzcCyvtDDt7e6vs3S1dTJv8K4rqG1wcpu1W64qcDCzG7Ax8lybG1q0tbM0c64wMTKbrCwa3fOase6sbjMy8Noz7q6t7qosLu2vbTIycbJz7yAtq2vurvNy8HK0NW8vq6qvJqGnb7Tcca3z8Gwvruvq7uzv6+rs72pnK60sbSzpLjCop2hwMPSZ8zNactna2ppb2m9ts3Lvrq9wL9vbLXEyry2uMnKvNXSbbyswa2RnMO0ipSxs7S8pZiZtp+Lg4WXmnt+3ZCJg3yBfZGgj4acmHqAjZDPe9qAi5ipop6Wqq6gh4J6fpaOppujhICNo52krJGXrrHEtpR2eXWDjpmCe9GJj42Xg5egjJiToKagu6GPi4uQg4GHk4+vrXeDhI+Of2+FirCO29J5gpCBt6yTjYPR1omPjpyglZKTlp2roKujpKivq8m8wNHFyZq802mDzbCAaXmDdnVqy7jFcH6GoIWRn764gYmQfZ2FkIhws8i/nZ7RxJvfu4umgJqQfXl3dt11eoOSn6qlm5GCgXzNzJOLeYiUgIScr5SeppakrqG2oayeiZmZrZecnIN+dHSB49bUzMKipLjUfHDMnJ22scVteXB9fHVt0NF7eeXbiZCSmqOAztN2c22ttrK2s7HBvrnKa9BtcdB7d87WtY+HhdHfxnqZe4p703WAxOTIxri80nPAzXzZzmtvdePaytvGdG/U2b23zNbi2oubnJufk6KborC2r6igo6ioq5yZgISXd4iKlpeVjHiUlqafnY+KpKaSetnfk5OGf6igdoSjqKaXgHGAc4iNioKOnJaUoZOMiaezra6dkY95eHuMl4CnncTOn52Vi5WZmaGdpqCXj4qrrpmqrqikpp2imp+cla+NmLe4xqSZnKWap6aTmpWUi5mdmKKgoqqnsKycs6zFraykrbC4rrTVxLKon5qhn6y6bICIc3Br0H2GiYJ1yb2mwchsdomAgXd3dXZwc2ppa8hqbXDLxbubfYiuqqykpLGqp6GZh5GPgYuKdtLFyuCXeX9vdoiXhYiKm6Okop2JhaGQpYKapqesurCakpSrpIt/op6wqZyQloJ8e4ekqquXmZmJdH2Iib5vjZuG2XONfXbPfoGQhISB0XSGe5KbmKmJhZKPh4iAkoWGja+lraaztaemoJ6AdXzWcIGZkay/qaysum/As7OwmpS5u7a7yq+lw7qqrLS0qKSUm6CNnqK8wMWroI+msc27on2NprbEwdXLwafQx8K+z8rByta+xMWunbi7oaCapJudiHuJl6ylpsSoqqu+paB/et2koa7AsbW7t8XBqquAo6WUk5+gn4l8iXRzfoZ0a4Zudnt6kZ6RnIN1hZeWeXp4lpaPhp6NVllZlaKdlqWopJiSoa6fmZmcn6mws7KnpKSelYqdpaxctl2ajqGkrFuhpqpgWlpXqbGrsKyXoaOkWJOTWmOrVqSWk5usrqZWrp6cnZqNlZ6ZoJenp6anrJ6AmpOQmJyqqKOxtrqho5iWo4Vziaa2X6ier6SWnpuSkqGbp5uVoKiXi5mZmpmUjZmhlIyMoaasV62vWalVWFVVW1egmaqtpp+goJ9dXp+lraKZmaeuoa+uW6ibppuGiKKegYCUmpmZkYaHlop9dHN9g2tww3l5c29xbnuEfniAfmqAc3vBb8Btd4KQiYWAjpOMd3NtbX98joiMeXN9iouQlX2BkZOinIRsbGdxe4R2bL51e3iAdIKGfoCFj4+ImYd5d3d8c3F1enaio2tzdX18cmh0eo55w7locHt0lox+eW69vXJ5eoKDgH6EhYiQio6LhYqUjaOboaulqoebq1hsqpSAUltjWFZUo5+lXWdqeWl2gZSNaXN3aYJlZ2FXlKeii4y3r4/UtIKXd4uDcXBwbs9tcXmCjZeRh4J2eXbEvoR8bHV/cXKCmIOJlIWRloqdjp2PgI2Mmo2OkHt1bW141M/JwbmenqnCcmG7mpqqobRja2Rsa2hiurpta9TEdnp7gomAqrNhXl2Ym5mamp6mpqezX7lhab9qabS6oYd6ecbNs2iFbHNwwWdyt8C5saywv2u4v3DLv2BkZ9DDtL6zZGS7xLOrvczYz36Oj46QiZOQkaKqoJyVlZ2eno2IcneIbHp8iIiDem+FhZKOi355kJKFcMXTi4d/d5KQbnyXmpOJcmeAanp9end/joyHk4SBe5Senp6RhIBwcXSAinaVj7G2ioqFfIKFipGRlY+JgH2am4eXm5SSlY2Oho6Mhpd8iKCgrpGNjJWKlpSIjYWFgIqOi5aVlJWXnp2Qopuym5eRm5ufmJ+8rp6Vi4qSlJqlYnB3Yl1Xsmlvb2ddop6LmaBZYG6AaF5fXF9cW1RUVqdYXFukn5mAbXuYkJGKiZGNiYaBdHt6bnV1Zbexs8aAaWtfZ3qBdHh8i46Oi4Z3dYp+i3ODjI+SnJOCfH+Qi3lwiIaTj4J7fnJta3KLkY19gH9zZGx0cqpie4NwvmV4bWe5cXB6cXJvumd0bHuHh5J3dH58d3WAfXV0epOPko6ZmI2Kg4NtZ2y8Y2+CgJOij42Ol1mek5ORgX6XmJaZpJGKo5yQkpmakYp+iIp8i42eoaSPiHqKl6qahm56jJ6np6+noo6uraakrq6orrSjp6aUh5+eioiFjYaCdG13hZeRlauVlZWklZB0bsqRlJmqnp6koaunlpOnfoN/nX4Df35/hX4Ef35+foR/iX4Hf35+f39+f4d+AX+mfgF/oH4Ff35+f36Gf4l+gn+LfgF/mn4BfY9+A31+fal+AX2YfoJ9i36CfYl+gn2bfgR/f35+hn+DfpJ/iH6CfYl+AX2MfoJ9oH6JfYJ+hn2HfgZ9fX5+fX2HfoN/in4Hf35/f35/f4Z+g32FfgN9fn6HfQl+fX1+fX1+fn6FfYJ+iH2qfoJ9+n6GfwF+hX+Ffo1/BH5/f3+XfoR9uH4BfYR+AX2EfgF9hn4BfZ5+AX2KfgF/1n4BfYx+AgIEAIDZ1srF2drDy9HJ0dTSrLK0wN3e7/bw6tLVxMq+7OvMrKHK36/c9ZKG8dOGjO3K5fLnw8jN4tPc+oP4//L+hNzwgvDuh4mA6/qEhIiLk5eTioqbn5CXl5maiYaNh/mCgImNh4OEhfr5iIqC9vn28e/v79/g6oT89/yNg4GD/u/1goDo3fL7hYuHievXzNHp7OHLz9HJwMjhgoOKmJeA8uTZ9ILs6+nqztru84SC7eeD+9rT9vHt6YKBnKCCgf+BgP2B++nfz+zf2fX86Ozn5OHt+vLu6Nrt3M68xL3Fxs/e17+su7rO4q6QpdLVj5XEwqfFs4OGqLK0rs/l49rIqNTNnICriISVlqynpqq/sK3Gx8GnvKi3vKuysbaorrDEt7bJ1c2yu7nAray5q7GboaegwMLItLe8r869tsbO39StzMCWv5qisLCqhN6VpPSjn5WRnKC7xpynwKGww7i3ysiyqqqmranc1NTV8sK55Oq72ufh9eSAvKquq6D4jbz/i4jGroDL+P6amY+Kloebxcziwtne/YHt4M+9t6iPhoeA8+rXx8zP3MCooZuTjpqb6teLm4LwlajPzLq7wMHFwqiPhISPpJutrri+u9be2+z/weDVxseupa64n5TDqpuYpsjErf/Tl6S0u5zthdXY4b223NjS1O2Joais/oGpop+lpNTr/oCD+vuNl4SA+4SR/oKJ8+/6konxwbaUobmmmJ2GiouQoaKnoY2Eio2K4Yiap6GUm9+8v9rp6Ybq3YWJ5vXr6JbFw7KakIiMlpWlxbq8sdvX3827wtLcvq+bl5WSp6OrmqGOjo32gfySoKe4tqeZqqSMh62u1Ly5l8rOws+7x7KhqICTh52ZnbWnn6y3s6+bp6izu72vq5qSrI+Do+L73LuzsbHBxsvXuNLV4NfNwcO6v669u7jGvr7Ar6ypr9be9uO9rbe6qI2Qlaa/wtDDvsC7wrzF4tnVw9jOxdDPy7a+0L/O1e736/LwwI2TqNPo99/V/oH3iJSbi/nu3MvmgPKEnoCkiof8+ISJ+/yA/eTk69DGt6vAxsXFyM25vL2zp5+jl4rm1MHNi42Gmpmal5uvvMPI2sHa0MXE1uXLuaOjx8u8wMnJvbO3p7ewo6y9z7G04N7KusK0rJyartWkhe33jo+DjI33hpSHoJWBgIaErZ+rqKejlrCzsLGngvjs3PmHioCWsMO+zZn26efmyrGtvKqon5+uycvEuMS8tdHT2dnj5YSFioKA9uTi2MawxMnT29/Kwd/X0tfKw6u0vdzV4+Td1srQxbPFxdjV6Li1ydjQycjb6u3m6/fk6+XKv7Oxq8+wvqqpjIKS9JGXiYSVmsja09u2zLrLzNC8p664yNHp0IC5t6umurumsLGosbO1k5aXoLy7yM3Kx7S2pKifycSskoutwJO8zHlwyLJwc8KnwsnDoaitvLC62G3P2crZcLbGbsvGcXNtxdJub3FxeHx4cnF/hHZ9fH1+cW90bs9sanBxcGtsbtDPcnNrzM/KwsXDxrm8xG3SzNF1a2tt08bMbYDBtsjObHJvcsS0qK/Fx7mrrq+qoKm9bWxud3tox7uvzW/Hx8TDq7fGy29syMBs0bWvzMW/vmtugoBpaNdpZ8xn1Lq5qcS6sMzNvcO9yrnIy8bFw7XGuKebp6SsqK65sqGRoaGnvJF+krCveoeln4ullnF3j5WVmK+3tq+gjramhICXcXCCfZGLjoyhk4yhpKKOoZGen5GYl5uPlpSkmpint6uVm5afko+ckJaEiZCGoKKml5ibk6uak6WotLGMqKZ/pYmJk5CPecqAkuKPhIJ7hYKZpISLnoiVopmUpKSVkJCMko68tKyrxqabtb+es7y7xr5mn4iSkojffaPWcHGqlYCxzMp5eHVxe3GAn6O0nqqtw2W+sKOTkIRyb29t0cq8sLCzxLGXlYmDfoqQ4sF5hXbjhJGusZ6ZoKCqq5SFdnB5jIWTlJyjnbG2tcHXoLa0rK6TkZ6fioKvlomLi6yol+G+kqGtsZPKc8bHx66ox8TDu9Rzh5GS2nKRhoiMj6/Dz4BszcxwdGtszGtzzmpvy8vPeG/Iop16hZiFeoFvdXh2hYOHiXdydHV5yHiKlpSLi865vdPY0nXOy3R6zN3K0pa0rZyIf3x/hIOVrqGom8K9xbWjqrrAp5qLhoSClY+Yho96e37Wcdt/ipCfno+ElpF8dpmZuqSjhrW2p7WlsJ+Nl4CDd4uGiqGRjJehnJqIlJOdpaiamIeBm350kMncwaSbmpuoq7G7oLu5w7qxqKigpZeko6CtpKSllpWSmb3E2sejlaGkkn6BhJClp7WloamjqqOrxby5qb2ysLeysJ6ktqWyuMzUx8zNpnp/j7jI0r2x1WnLcHl9ctHGuae5Z8RtgICEb23OzGxtys1p1b28wq2mnZOkqamoqa2coZ+WjYeNhXnJvKy4fHp1iIOEhIeXoqaqvKO6sKqqtcStnIuLqqyfoquqnpeYi52WiZKfsJWavbypm6WakoeEkrWKcc7SenxyeXnUcn9yin9tbnRwloeTkI6LgZaal5iQb9bJvtd2doCAl6ijsYHVwsC+rZWRoZCQiYaRp6ymmqafl7Gys7S6u2xtc2lqy7+7tKaUpKiyvL2qpcG4s7uuqpWeo8C3wsa8ta20qJmoqrizyp+cq7axq628x8jEyNTCycWspJiWlLOWpZSSeXqH1oGIfHeDhrDAuMCcsqGws7WjkpmgrLLHsoCfn5aQoqWRmJaOl5uafXx8hp2ap6qoppiXiYqHqJ+OfXiUn3ucqmJbo5RcXKCMoamliImRnZKctVuvuKq6X5qmW6ymXl9bp65cXVxcYWJgXFxmamFmZWhoW1tfW69bWVxcW1dYXK2qWl5Wqqmoo6qkoZuhp1qyrrBiWltdsKSxXYCjmKiuW2FgYaickJaqpZuUlJaViJKgW1hbYGJSpaGWtV+uq6momaCssF1bqaRcsZ6Top2XmlpdZmZaWLBXV7FWsaOckaSglainoqqnraWrsKymp5+so5iMlJWXlZqdnpKFi4qRood3gJWadHaKiHiLhGdrdHh8gZCUk5KLfJWWeIB/aWVubXl4dniGeXOCiod4in+Ki3+Fg4Z9goCNhoGOl5B+gH6DfHqEfIJ2dnt0iIqOhIOGgpKEgouOlpN/kI10iHV5fHp7arxzfNB+d3NscXR/hnJ0fXB+iH97hIl/fXl2fHedkYSIo4+Fk5WFlJKWoJtQf3R7fHrMboqoXF2Qg4CWq6lgW1tbYV1idHWFeYCKl0+OgnZlaGBVWFdZrrGkmp2erp6Jhn94dYCJ07lxemzSeYOamoyMkZCbmoZ6bWZtfHmFhY2TjJqhoae+kaChoJ6Jg46TgHqbjH17eZSYjtG2k5ymrY63ZLa1t6Sas7aysLtlcnqCyGR5eHh8e5KiqoBeubheYV1ft11luF5lvL27amSzkY51doN5bW9gY2Znb3N2eWxlY2dvuWd5f4V+fcO0uMfOw2vAt2lywMrAwYCSkop9eHNyd3qHmJSWjq+utaaYoKyvl5GCfHt4iIKLen9ucHHFZ8dxeICLjH50g4NwbIuLqZmWeqKlmaaYppaFiIB6cH95fI6DfoaOi4p9hIWPlJqQiX58jnRshLLFq5GGiIqWmJ+qkqWmrKSemJaPkIaSjo+YlJeXhoWFjayuvrGShpSYhHJ3doCUk6KTkZiWm5SZsammm6mfnaOemoyToJOdorK3r7K0lW5yfZmsuKGVrlanWmFlX7GpnY2XUJ5ZaIBqWleoqVlWo6lWrp6boI+IgHuKj46Rj4+Fi4J9eXV6c2mzqqKpamxqd3R4dXWGjpCUpJKmmpeZnqeThXd5kZSIipGOg4GAeIaBeH6JlICGnJuOhYuCe3Nyf5h0Yri7aGpiaGi7Ymtid21fYGZif3V9fnt4cn+FgIN8Yb+5rb5oZ4Byg5CLknC3pp6akX97hnp5cnB5i46Kg4iEf5SWlpaVlVdYXVVTo5yYk4l9hoqVoJ+Ujqeim6GZkoWKj6SfqaifmZGbjoSPk6Ceq4qKlpqXk5eiq6qpq7WorqmVjoKBf5iEjYJ+a2l2zHp6cG54epynoauOnY6bnKKVhouOlJusm6Z+Bn9/fn5/f4x+AX+Efgt/fn5/fn5/f39+fpR/AX6IfwV+fn9/f4p+BH9+fn6EfwR+fn5/hH6Ef45+hn+EfgF/iH4Ff39+fn+HfoZ/BX5/f35//36IfgR9fn59p34Bf4V+Bn1+fn5/f4V+jn8BgIp/j34GfX1+fn59rn6IfQF+in2EfgF9iX4Df35+hH8Lfn9/fn9/fn5+f3+WfgF9hn6GfQV+fX1+foR9pX4DfX59/36MfgJ/foR/hX4Cf36Ffwd+fn9/fn5/l36Efbd+gn2FfgF9ln6EfaJ+hX/CfgF9mH4CAgQAgLbJ0MzLq7O11dTq+Ouvt8q/xc3N4Ir/hP3fgeKnycWmhpyqyNje9YHG1L7ex7q7y9bF4dXm3NTH2/2AiJGThu3Xz/SRlaWsrqmrnomCiYqMlJCWnqejq66foqGbhPKA4oKUiYiOjYb98peVjpCOh4uNi4+Ghf7h4uTk7oaKg/f6gIWBg+/18Prn8oKD8P/35Ov3+f//iY6Qi5GK/vmD+eTt74OSiPzthoiTgvno+YCHj4Xv+IKNi4iUlJWB+fqGhoKDjPj/hYSCg4D6hoPk4/Dy6MnFrLTU0M3XztjFydy4pLW0wKu4sqizxKnDrra2t76woLnYtsrUu7fI0dXFi7nKgLi9rrCtq7bFtbWxuL2/x8bH0NO8rLe9yb+6u66jtbfLw83i1KSjsbDOt7LDqp/A29WyobfM6NyzvOrPuNGtwrivhI2ozJKMutO+udG0y7fEydTFoqOatr2+ra2uy8zI//Li1ePq7fHV14OB2OK06+O834CLwtbj+IeIgYyeiISSgImKkI+fobvG2dPVyeS3kdDo74HjyrWpo/f4//3vyLWmg7bO3MfP44Prq5SM1df6i4Sdl5OvvJGEgf6iqbCB6YiHhJWaoZihw8vH1f/mxbm+w6msp7a1tbG2vr68wMux49D8/tLmydiQh77n5PHYwL/g7JOii4KJ8YWOjJely+TygICL5rS50MuxsLGywdHCqY+ltbC8u7+wyLGenJSDiufh6oeQlpqUnp2Tn7bAvKzO262H4rvR4N7c5OiBhY2iyP6IifjltJmNj4mJjY6YttPQybLIsau6zdjVzrW9tcuiko+Vg+DC1fCDjISG9Ir1+YyFgovplLWor7/St7bDvsWzgK6ijYWCi4uaoZqfoK+loqemnpSLrMKzp6bL27+el6KvraGlxtjZ0b/Q1s3IzsXMw7XA9PrZ0dXaw8KztLe4saquyt3c1d7gyKCfu6iam6S7wKqur7TEz7y/r7m7q5motNrIw82ymevRg7bu9vKC9uPw8tr2zNbb8djihOPR8obwgPKOl52RkYeK/ObY5e3S4eG/1tjO4sCan4+cs9WlhJHYpMa43dmHiYmempiVqpmlrqe1qKyyubS8sqm6srTDx7vl0damocPLysKysK260eS9tbyvtY+KgoDW2pDk0/n8vPiUhpm0opagnZmYsK+/u9nIsLCkpbuvn4r/jJKdkJGlgLzEycTU64Dq9Ono2My9pazTxbbGttP92dTNvdHl7fGH+Pju+Pvmz8HhzenYzOLO5+2A6enMu7O8zNvh2e/8gfPz5tLb0MuyqKGSk7vZzt/Mytb9iqSVgNO6qrWckqiywazIuZ6yqr3UyZiTlrilkcG40fT30sW0w8DEt7SnyMa9gJ6rsa2vk5uXs7DCzsaTnK+iqa6wuXPVcNW8a7+OraeQdIeSq7i/0G+lsqC8p5mapKyiu7LEu7WrvNhrcXZ6b8m0r815fIiNkIqMgXFqbnFyenZ6gIiFio2BhoSBasdruWt5b291dG3Ox3x7dHZybXNzcnVtcNS4vL6+xnFybczNgG9rbsbOy9bDzW1tydTOur/LztDOb3R1cXZvzsps0b/FyG16ctLCb256bM690mtxdmrGyGpzb21zdnhmy8tvbGppd8XNam1pa2fPbGy6u8nGvKWrlp+sqa+2rLKkprmYjqGToI2bloqSo4uqj5WWlpeUiZ60lqmqnpenrq6oeqOngJmekpSQi5ShlpeTlpqYnJukqLCelZeep6Ccn5OIl5inoam5r4uKl5Osl5Sjj4OdsquUiZupvbWWnL6unbWUn5eUen2QrId1oLSfnLSfrZynpK+nio2Dmp6mkpCQpbSkzczBsru+ur2urmtosLyawr6atmp2p7i/0HBsa3GAcGx6gG9udnN+fpKcrKSqobKWeKW3vGSwoJCCgcvW19rQrJ6Reau1wbCzzHbJlYSCyL3eeHCIhn+Uon10dNuNkZp11ndxcoGCioKPq7GosdW9pJyhpo+XkKKYoJWbpZ+hp6uUwL3i777RuMR+dbTVyeHLtrHE0H+JdHJ30nF5eoGOrbnGgGlxyaOmuK2Wl5mXoK+ikHiIkpGcnKKcrpaKgnxqes3NzXJ7f4R6hIN9j6KlpZi4xJp40q7Iy8PCzNJwd3uUsNhtbcnBl4SBgXp7gYCGobi2sZ2ym5imtcG+tp+on7WPgX6Idcasu9VzfHN11XzX23x0cn/ShqOTm6e4nqCopa6agJePe3V1gX6IjoiMjJqRjpKTjIN7l6mckpGwwaqLho6amYyQrLq8taW0urKssauxqJ2m1t69tri/qayfnqOinZWXsMPBucTFsYuJoZGGiJCjppWYmJ2pt6Glm6GjlYaRm76sqLOehM+8dZ3G0s1u0b/KzLbPpq6yx7G8bbesxm7EgMhzfIJ3eG9xzb+xwMetvbyhubiwwaSEiXuHm7eLcX+8krmoxrt2eHWJhomBk4GMlZCcjpSZn5yjnZKgmZmkqZ7Er7KLh6arqqKUlJGcrbybmZ2Smnl0bW62uX7Fu9rYoNaBc4GZh36IhoGBlpWlnrqqlpaNjaKWinfdeXyGe32OgKOmqqSyyWy8wbu9sqqejI+yqZqombDWt6+rnrLDxctwzM/Dzc69rZ+9qsKzqr2pxMZrxcern5yjsbzCvM/Ubc7Nw7C4q6ublZGDg6O7r76uq7XVc4p6aa+ekZ2FfY+YppKtn4udlae6soSAg6STga2es9LWuK6dq6epnp2RsK2nb4uWmJaYgYaBlZCco557hJKLkJWUnl6uXLGaV518kYx6ZnV8lKGjrl2Kkoidi4CBiYyHmZelnpmRobdZXWBkXKWWk6lkZ3Fzc25waVxUWl5fY2BiZmtocHFobmxqWKJYnVpkXV1hXlirqGdlX2JcWIRfgFpcspieoqClYGBbrapdXF+sta66pq9cW6u3sZyeqK2xrFpeX1xeWKenW7Kmqq1dZmGwoFtdZVutnqxXWlpVqKtWW1paX2BlWK2pWVdVV2ClqFhbWFlXq1lcpaWtq6qZnY2Kl5ianZedl5Ghin+MgomChoZ7fouAkoCBgn6AfXmEgJSFjo6JgpKUkpNwj5CEhoF9e3aBiH9+e3t9fHp+h4+Vg3qBiYyIhIl/dX+AiomMnZZ4doN/j4J+iXtyhZaUgXiFj56agoeilIiWhYuCgWtvfY9za4iWhoqYjJuMkI2PiHZ5cICGinx6eYyTjaWmoZqgoZufkY9QUpCXh6OchZxagGORoaOvW1lYXGhdWWNbWF1YYmBtdIB6hX2KeGiEjZNMiX1nXlygsrW3qZCJgnGapbKfpbVpsId8dry2z25qfH16i5Nxa2zNgYKLbclta2p2enx6gpuemp66qZCMj5ODiYeSjpGKjJSQlJmdib2y09uzw7G0b26qxr7Lva+ourxxgHhpZmzBZWxucoCXnqRYYriYnKmjkpCRjZOemIpyeYB+hYqPiJWFdm9qX2u+t7llbHFzb3NycH6TnJuOpLGObcSruLq4s7q7YWx1hpy4X1usrI59eHl1c3d3fpKnpqWPloqJlqSwrqeTmZKihn12d2q9o667aHBqbMNxy8luamlwgMF4kIaMmKKOkpqWm4yGf29qa3FwfH96gH+KgYKEhH11dYubjoWFoa2XfnqEjYd+gZmmpqORoKSdl5uZnpeLlLzDpp+hqpmZjIuPjYmGiJyurKuurp19eI2CeXuGlZWFiomNmKCRlYiQk4V8h5CrnJOejHjItmmIp7GyX7alra2ZgKeLkpekk5pXlI6gV6SkXGRnX2FcWKOZkJ6kkpuZi52blaKMdHZrdIWZd2RwrYqio7msaGtqd3l6dYN0e4F9ioGEhomJjoyEioODjJCJo5WVeHSLkY6Jfnx6hJCWf3+Ce39nY19dn6hqrKa/vJK7a2Rug3NtdHRwcICBiIWekIGAgHp7in94acJrbnNrbn6Kj5KLnK9dmpWWlJONgHR0ko6AiIGQqpiVkIiaqKOmWaqnn6ShlY6DmIuckoyXkaWmWainkomGjZmip6Gwtl6zsKeXlpGWjIiDeHaOn5SilZKatWByY1WQhYCFcm17got/k4p9jIaSopp3dXWTineZjp+2Dbynmo6YlZSNjYWalpOVfgZ/fn9+fn+MfgF/kn6Ff4R+mn8Dfn9+h3+Cfox/hn4If39/fn5/f3+GfoJ/iX6GfwN+fn+EfgV/f39+foR/g36Ef4J+iH+CfoV/gn6FfwN+f3//fp5+gn+HfoJ/hH6afwGAhX+PfgF/hH6DfYp+AX2EfgF9oH6IfYJ+iX2FfgF9iH6Cf5x+g32Rfoh9hn6Cf6F+hH2EfgR9fn19hH4BffJ+gn2FfgF/jH4Hf35+fn9+fod/l36GfbN+A319foZ9mH4BfYx+AX+YfgF/kX4Bf4x+AX+UfoR/qX4CAgQAgLy83v7sz9zVysHRupeUrbbDz8Da2cvKwKfE3fPOvtTOtqeSuL650uDl2P2I0LeoysnJtZ25v+Hgw+aHh4mJn6eqmYaRkJ2SiI6QgIP5jJqNqJyVj4yPiYujm6WXk5CMjouOiaalmZuOk5uWlouJkomLlp6ZlY6OjPn28Pv1g/P7gPr45/WD/+ni7IDzhIaHiIiJiI2Kio6Dgfv4+4Dr6POJkIOAiobz9vT97eX8h4j9/YH/gvTu9P71hIeDg4yPiImG+PTwhIb/94Dr7eDV/fbL0tXI1tXm6ebc9OfU0ce+vZypz8zIyKmo0NDEv7rZ8NezwqybtbDQ2+HO3My8s6+1gMvd1dW0sMe2tLy4p8PA4uDD4dHXz8LJzd+ck6K7yrG+xsHbv7Otpq2sxK20vcG1wMyxwKzI4NTO0sK4t5ufn7HZpKm937SjzMGvq8WwjbCnyuG9rIqZvMatubOrsrHYwsyH7cqnvsLK2eX47d7356fH2Inmkpbq+Z2Ggo35/oWSgJSFi5SctLy7xOmA0d/n18nVzu7xyJuP//3w+POA9uu68tzuoKmtxK3GvL+WkufL9YCFgY+1sImF++iUopTylZiHlqOUjJSVp5uKo6uo28O/tsKakYyAjpykl4nyhKCbh/iR7dv409mIi5CGgYzY7uPTsuL78ZKmiYyViJSTipvHgLKYtr3j3eKnmons2PGGiIyNkomImImGjoOJ++3B2oH17vH+gI+enI6JjaGsr7/Kxqm4lO3z8vDa+pKV8uiKnLm7ttjS2dO7qMatq6miiZ6ksJ2Kk56sv9nGx83v4tnZ1sa0samP69L0+ff88uiA+5CelJ+pr7WplJejuLawxsSogJquuaT/9oaOmaSzub2tnpuJna2qq52vysW8uL27tM/l2dC5uLy31M24wdDb2NfQxr/J4ebgwbGzx+j1rtbkv7/p+e7r0+zc0M3BzrKxxtHRv8yto5qQm6iun6GxnY+apIyJ7eP+9KGw4PuQg/Dh1eH6hfnk3tzl58DI6NXf+pGSgI+U/fzW4uPo6/Te2e7a2MvGqKi+wa6krK2lnL6pmIbqucLkjbyooMW1lZ+ErNG1u6uqq5zCxKXExufTsqqsqaellZ2krrS0r6y2xNfDwsLBxK+hpqidmp2N7NHGhf6RmJC9ude8yc+lsZGJmKqiu8vFsZOfn6C0tJiToaSiq7qygK28v8jP+vLx2fHz1bnFv7nD2trDxcC21cTagunmzdHb5sn03vP+1cvL08u3wb7L3NHU0sS8xtrVyNfaycvW4/WF7O3p4NO9xq+Lmujy0MCqvKXC8oeRi966trKumpuerZylwMipp6alquXTqNLLiZTPwLnA08eXq8jZyL/V0uDLgKOgvdrKsry0rqSyoYN/l5ulsqa8u66uppKru82qnq+tnJGBoqagssDDtdVyrpuMqaWqmYSepMC/pcFwcHFwgoiLfnB8eIN6cXh4amzMc35xi4F5dXN3cXGHf4Z+eXh0dXJzcIiFfYF1eIF7enFxe29ve4J+e3V0dM/Nx9DMbMrQgM/Qv8ps1sO9xGvMbnBycG9vb3NwcXRsasvLz2rIvshvd2xocm7GysvPw7nPbm7Kz2fRasPDxtPLbW5qaXBzbWxrzMzJa2vZ0Wq6w7S2zs2ptLWutrXBu8W30b2srqabooaRqaWkoI6RqqmdnJqyw6uVpJKFnJKyub2tuaidl5uagKK3sLCbi6WYlp2hiJuWs7mft6+stKCpr7iHf4mcqZWhpp+2n5aVjpCPpZOZnqKaoK6To5KkvLOvsKOZnIWJiZW3i5KduJ2HpZyUkKibfJ+OpbummHiBmqWTop6PlpmynqRxx6+OnJ6or7jJxrbRxpOpsnG7eX7F0INvaXTU2Gx3gIFvc3p9jpKUmq5lqrK1qJ2lnrm6m3lyyMrJ0NNu1sGn59LYjJKRqZWyoLKEg9/C5HB1cnuflXZ53s2Bi4HSgYF0fYp9eH6CkIR1jYuMvKOkmJ+Af3VseIGJfXXPb4qFd+GC0cfgucp8d3pzcHrM2NXBo87fzoCPdXd+dICCeImsgJqDoanCvsGWhnzfxdl2en9/g3ZzgnV3fnd53c6tzXzd3tjhbX2CfXNwdoaSlaipo4+qgdXe1NLD5ICC3OmFiJ2alLqyubijlLSXlpWSeo2Sno5+hpCYqMGvrbTQxb68u6yfm5R+0r3d4d3j2s5x3H6Mg42VmZ+Wg4SPoZ6YrK2VgIaYopLf2XZ/iI+foaWWi4p4i5qXl4ubsKukn6Wjn7XJvbahoKWeurGfqLS+urm0q6Otw8nBppmcrcrTlrvJp6XH08bHtMu9tbOotZmbrby3qLOZj4h+iJKbiYydjX+Jknt51Mvg04qZu9B3bMi7tb/Rbsy/u7u8vZ+qw662y3R1gHJ3ztCwurvBws66tsm1tamokJCjo5WMk5SPhKSPgnbPqrjRfaaRiK+cgo11lLicopKUk4Sqr46rqca1l5CTkZCNfoeNlJmVkJCYoLKeoKGfoJCGjI2GgoZ4zLWpctl9gHmlnbecqrOMl3l4hJCJoqyilH2JiImam4R+iouJk6GagJOhoqqw08jAr8jIsZunoZehuLmipaCZtKO2bMC/qa+4vqXKssbOq6eqrqmbpp+qt6yysqagqL22q7q7rrO7xNJyxcfDurWkrZt7hcjMsqSSo4+oznB1cLmdmpeUhoiJloiRq66Tk5WRmMa0kLmweYS5qqOou6+EmLK+raO7tcCvgJKQpbqtnKCYlYuXiG9xgoGLlo+iopSWjH2Um6aNg5KQhoF0jJGKl6OlmrBdkoJ4jIiPgHCHj6OjjqNdXlxaZ21wal9pZm5nYmZkWFinXWZbcWdiX19iXVttaG1oZWZhYl5hXnJwaWtjZGllZV9faF1bZmxqaWFeX66pqbGrV6qvgLCyo6xatKejqV2wXWBhXlxbWl5dX2BaVqmosVuuo6ldY1lWX1ykqKupoZmpXFupq1WoVKOloayqWFlWVlphXFtarqyjV1u7tFymqaGcrLSamZuZnZqkpqilsaOYk4uIjHh8jpCNjH15iIyEgH+SnZKCkIR3goKRnJ+Um46IgYiJgI+Yl5aGfIqCf4WId3x7jI+ImI+OjYSTlZx6b3eGkoCIioaXh4CAfH16jYGDiYmCh5OAjX+Im5uVl4uEh3V4d4KbeHuHl4N2ioF/fpGEcYuAjpaMg2pxgoqAjYd+f4aRiIpYpZV+h4OKlZijn5SooXqOlVmgZGWgs21bWmK0vVpkgGleYmZmcHJ0eoZLhpCOhIGBe5CNc2FboqSls7RetaOPzsPQhIaCmYqekqN6d9W21mhsbXONh3Bv08B2gHjCdnZob3lvbXN1gHVpfYCDppORio51c25la3R8c2/EZ4F/cs56xbrLsbZvbG5paHC+zsu9oLzPunCAaWdtaG50b32ZgI59kJasp66Lf3jaws9wcnd3eHBrdnBtcm5vz8epvXLTz8zRY250cWhla3qBhpWem4mZfM/OxcK2xm1yxdZ7fYiIgp6hqaiWhpmJioaCcYCDkIFwdX6Km66hoKa/trCwrKCTkox2wrDMztHUzsNox3B7d36Gi5CHd3Z+j4+LmZ2FgHqJk4TOxWx0fYWSlJaJf39wgIyJi4KNnpeVj5STkae5q6STkZSPqZ+NlqGlo6GfmJGZrrCpkIaOnri5h6iukpGstKyto7Gpo6GYooeOnKammaOJgnp0fIWLe4GThHV9gnBuv7PCu3qGoLNkXaqfnaWzXK2kn5ybm4ePoZGVolxdgFpfpqiQlpmgn6aamqWWlJGOfH2KiX13fXx3cYl6cWm+prPCcJOCeZmPeHtrh6KNjoCEgHWUmYGSlqiZhHt9fn15bXR6f4B+eXqBh5ODhoWFg3lydndxbnBlsaCaY7xqbWmOh5eDjZJ3fWdmcXt1ipCGfG11d3iFhHFsdnV0gId+gH2Mj5Wct6yVkKOhjYKNhn6FmZmHiIWAlYmbWp+cj5ScmYuikp2gioWKjYuEjIWOkoySlIuKlKKclaCllpykrLZhq6mmnpyTmYpxeq2tmY1/inqUsF5eWpeDgX19dHl4gXeCl5WBhYSEhqycg6egc3yhmJWbq556iZylmpSnoqeaq34Bf45+kn8Bfqt/hX4Bf4Z+AX+EfgJ/fo1/B35+fn9+fn6Gf4d+B39/fn5/fn+Ffol/CH5+fn9/fn5//36ZfgF/kH4Gf35/f35+hH+Cfox/AYCMf4V+B39+fn59fX2KfoN9iH4GfX1+fn59nX4BfYR+An1+hX2Gfoh9lX6DfY1+hH0BfoR9kH6GfQR+fn19qH6IfQJ+fZV+gn3cfoR9hH6Cf4V+AX+MfoR/nX6EfbZ+BX19fX59vH4Bf6V+AX+TfoN/qX4CAgQAgNne29zSytr2joTiv63RxeP2gO/a2a+tsr7G8PWEherbhYHbsrG3s7ScoLa+yMXSvs7VxsbPvrzD9uX5itT6iZebnqKIh46aioqRkJOTiIyMkqGfipGiqJqhoYqBj6KU8/Dp8O2Khf6FhoGFi/6H+uv2jIOYh5CknZuamZeL+ubggPOMkYeMkID8ioblhJeEgI+Mh4uGg4GD/oWLhYSBg4uFhoaF/urxg4eQifiGi4OChI2Mg/2AiZGIioqPhuyC9PyQiIOEjZL95ODv6Nvdzb/g4t/J0NTDyN7a6PX0gere3L3q8N3kz8vUyK+9yd7snqW9vaafr8vN0+Tf59fVutPJgLO8trKZvKWVnMi3tcjB3tO2x9bLrrC1tZv6msLPqq2tsqrG1N3Mw7OXr6u1ydHZuJWMv52avqvRwraZvZnK0dPkq6/Cv8XQt6uf9q2zuITlnOj+vbeSlZWz0Jaqus7Q29/I0d6vzNu8xLvn5vLlrL2+7oXl5Ozz+/uWjI+llomOgKWAkKy6rpWGgqCsxerVxre8tsXaw6KLhezh/4Dm9/722cPUwrnEzdHJo5Ci6P7A5Ojux4euv663sZaB14WJoLSvpLTCs7+wpqKSnbKfnJOc6piUkJyssrumsKWZlqKQ4f2OiJ32i4nn/Z+qmoeN942H/NfAyuHhhvOBioyehpe6gK+xt5ypyLi8sLSjlqe2z+nMxcG7q6KBhob1k6CambCbgOjO3MvE7IOOjoiFh4OHhIKGiPXygO7h5ICQmq2Lh5ieppil4eixj4ydnIaJ/paeob/Axcy+wuDI3PuD++jMv7jEzMSbopqgmZqKkvHWgZeci6e4tqiim6KloLi9s921gLmyqqGZna2qq7PBsLGimaqQn7u7sLbQxtLHxMnEwtHVv7m3w8W/xdXh0dLEwcauuMbTzMO7w9DIy9ffy8LCzMXIzrjEucTE1L26077Ctb+mpJ2flIaSlffj+PaVrsfk29HQ1vbc2vLv//7z+t/X1MjT3un98uH06tLk5viOqrGygKOkkon77Oj8+tnW7e7Z08jIyOPDlueYj56TnbC0no+Tl4OaoqCmt7apo6Obnb+5o5mRi52qrbGzuZ+io7CjkYX+j4aVm5X/s9DM19XRrqeysbygnq+nk6if5LukzM66rLqXlaSyvLawr7m+uLm4sKuWjJWTnreqvdHA0sfg37/NgOqFgMK1wuXi2Nfe08XP28Cw4t/ay7u+1svEws7qxKqflaOsztj57evr49zh+vzx5+Lkxq/P0dTbwq+ry/6LkI7u6tbF1s/Nwpaht+Dht6e3u8C10dTMzKyfmaGzvrWvoKrLuqyvrsSogK6orqipo6CiuNG7s83GsbzNvcDP4NDXgLW+vLuxqrnPd3DBo5azpb/Obcu7u5WXlpyqz81tbsG2b2y5mZmfmpqHiZyhqaizoa60qaixoKGkzbzSd7LTcnx/g4dwbnN/cnB2dnp6b3Jzd4OCcneFin2Eg3FqdoV9zcrFy8Nxb9JucGttdNFw0sXNd2p9bnSFf3t9e3xy0L68gMt0eW9zd2rRc2++bHxsaXZzb3NubGts0G1zbW1rbXFsbW1r0sPGbG51bchscGxsbHFxasxocHhtc3N4bsZrxNZ1a2dscHbJvbzIv7e6q5+5urOlrrGjrbixucTHar60tKPGwLq5qaexnZGfqr7Eh5ajnYyGlaWos7Suv6qxnbmmgJOkmpmBoZWDhKyalqebt7KdprSrl5WVlYPahaGvj5CSlo6nr7WppJaAlZKYqbK2nIB4oYODoo6wo52BooCqq6/EkZagnJ6ympSM5qGmr3zQgbrPpKB/gX+Vt4SUoKqus7umqLaSq7aZpZu6u8G+m6ecv2vDvrnHzMx6cHWHe3B1gIdrc4mWi3pybn6Gnbipn42XjpepmYJzcMm71GjD19rRu6a5qqKsr7W2kH+T2Piz3d3Uu3yRopShmX58wXV6ipmRi5eglKSXjYuCi52Nh4CHyoWFeYSWmKCPmI6JhpB7zd96dYjVeX/P5Y+UhHh91IR769KzvNDDctNvdXeHdYiigJKdpI+XsJ6jm5uSi5eitsSwqqWqlpF1fHzdhIuHiZ2Gc9a+w7eqzW54dnNzeHV3c29yc83WdNbJy217g5Fzc4GLkoePwseZfXiIiXV324SKiqWlrrOkq8eywdtx2MuyqaKrtK6IkYiOhop8hte8cYaMeZShnpKNho6SjKWkmMiegKSclouHiZaVlZypmZ2MhZZ+jKammp61rLitqq6rqbm6pKGgrK6nrLnEsbWnpqyXoK25saqjqratsLjCsqmnsq6ts52rn6upuqShuKOpnKiRkYqMhnqDhdjH0cd3l67IvrOwt9O3t8vM2tPGz7q2tqu1vcPYzLnIwa6/v9F1iIyLgICEdXDTyMPTz7W0xsa2saqsqsClgsmMfYt9h5acinyChHOIjYuOn6KRj5KHhqahjIZ+eImTlZeWnYiPjJyNgHPce3R+goHemq+ptLOwkYqYlJ+FhJKLe46GxKOQr7KfkZ5/fomZn5yUl5+gmp2flpF/doF/i6KQoLGhtqe9upyqgMJwaqCXo8TAs661qqCsuKCUubWxqZufs6WfoqjBpY+DgIyQrq/Kw8TFvLa5zc/Dub/CqZWytbS9qJeXs+J4fHrMy7ipuLCyqoWPn8HBoJCgoqmetratr5OIh4yaopqZiZSwn5WYma2WcZ2RmZWWkI6PobakmrKpmqOzo6a1w7G3gJ+kn56WkZ2vY16gin+Wi5+qW6qgn399f4KSs7NbWqKYWVecg4SIhoVzdoqMkIyWipSYjYqRiIaJppusX5euX2ZmaGtaWl9pX1xfXmNhWlxdYWtpXGJrbmVqaVxYZHForq+prqVfX7FbXVlcYbBetKStYlhlW2BuZ2JkZGZdr5yagKtiZV1gY1muYl+iWmdaWGFeWl9cWltZrlxhXFlXWV9bW1tZs6qkWVtfV6RWWVlXV1pbVaZTWmFZW15jX6lYq69gWldZX2OzpaSqpaGjlIqcopyRmZySlJqUnqWqWqSdm42ioqGglJOUjYaKkpageH+GhHdzgIuRl52XoZWYipyLgIGOhYJ0i4BvdpKCf4eEk5GCjJSNf35+f3LFdYqUfHx+f3qNkJWRjIJzgoCBj5eah29ph3R0inyTj4t0iHGQkZekgIKIiIyXhIV6z5yltXTMe6KqjopzdnKHmnV/iZSWmJ6OkJN+kpWEjoaYmpqZgo+Kn1agoZqiqKdgWWBwaV5hgG1XXmp2cGRhXWtxhZSHe3F3b3R/d2ddWqKgs1qmur22oY6ViYeSlZyahHeFy+it0c7LtniKloeRjXdxuWtvf4uBfYqNgYyJg3x1e41/e3Z8u3d5b3qJjpGGi4SAeoNzxtN0bYHLbnLF1X6CeG9yx3Zw2MeurcK3aMFja2t4bXePgIyNk4eMopKWj5GKf4uToK+jnJadkIlyd3jZf4SAgZGAcdC1ua6fs2BqbWxucW5samhoaby+ZcG3uWFrcHxrZ3N7gHmBrK6DbGp5eWlrx3V7e5OVnJ6Umq+dqMBkxLmln5ikqqWBgn6FfH9zdMSxZ3d8cIORjoN/eH9/fJKWiq+PgJGNiIB6fYaGhoyXjYx/fIt5gZWUjY+jnKacmJ2blqSjkI+OmJmVmqOrmqCUkpeJkJuqnpiRlqKbnqiwoZqZnJqdoIyTjJicqJaSqJebk5yIhYGBe3N9fsy4sahjg5WuppuaoLOenaqut6+or6Ccn5KVoKSxqpuioJWhoKxdaGxqgGJmXFmtp6aooJWYoaGXlZGRjp2LbbZ1b3tudoSFeHBzdm19fXyBjY6Dg4B4eJWPfndvbHd/gYKEh3h7eIV9cGPCaGZsb2/LiJWQmJeTenWBfoBtcnx1aXdwq5Z+lpWEeoVtbHWBhoJ+gYeGgoOEgHpuZm5weYd7h5SKmI2goYWSgKZeWoh+jqqjloyNh4ONloJ6k42LiYKEkIeFhoqeiXVtbnZ4joqgoZ2fmJSUop+amJ2dkISanJmikIeKpc1ucm64tqOYoJqYknOAkKeojICMkZKLoKKYk3x1dXeEjIaDeoOZi4OFiZyGaIuDjYaIhYOCkKKVjJuTipCekZWjqZqeiH6Cf4d+AX+KfgZ/f35+f3+ZfgN/fn6hf4V+A39/foV/BX5/fn5+jH+EfoZ/BH5/f36MfwF+i3+DfoR/AX6IfwF+iH8Efn9+foZ/ln4Bf7x+AX2wfoR9An59on4Bf4Z+n38Efn5+f5B+h32IfgF9lH4BfY5+Cn19fn5+fX5+fX2FfgN9fn6GfQJ+faB+AX2HfoZ9jH4GfX1+fX19lH4BfY1+AX+QfoJ96X6EfaF+iH+RfgF9qn4BfYV+AX2SfoJ9pn6Cf7p+g3/AfgICBACAsJWwo8zO0cO559PZ39LMpayttcTfx8e44cbZ6/zzw8jJ1drKw6/Ozrabw9yzx+KDiof+ybXY4NrY4NC5rsTT8YaElp6dj5GgnZGXkpqdnp6amqCXjYiLh+7ihpGYmJ+bk4jy5fKDgfqDlqKho5adlIWIg4GCj5iSj4aAiJCHgeeA7e3ygOLW7ePzgYGC+/6FlZmLhP6E+vPsgIiIiZCI/4iC/fDz5dfxhomChYuFioD2+4qIhoeKhYCK/uTyhYD98YSBgvv88PDfxeP23O/r9djOubHK2vWB94n5ge3azt29xtvhyb6wurC5y8PGztbnr5WgtMjD5O3Uy8u4tcO1xqmAqLSfo4OXr6OorLOy2tTV1NK+psLW1a2TnbOnvKS1tLi0tanX0tG2ppaQmouzs7O0vMipuKOnuNLIxNfS496esMCcm/K0vtPj36n53NDns6aAzbvLrIKI756zrNLI89rr9+zv8+fByrWrgr/LwKLFzcbZ9sf/i5WVkYPtkYry8YuAm5yjo8Kii5rgnrDV6uO2oaSwuMzJsKKYhPn33t/g2sm9rsOBv6OXoe3MuL2N6tyEqpHp1oCkmZaF1IqanY2asbiwmp+mmKmrmZWbpp2Tq5j8jqnAq6GUoI+PlZqqraeCj6y5tpuTsZGJlpmmoKCRiaSO/IOgjdzg/YKBlIqN+eOA/6GypJCUnqGrr9DpgYHy28re39PIqqmyoI+uyuro7frfwrWQhNrR1+TbvcfX7oaJ/uzniIqOlqGnj4+itKSR9o2bnqebh/3mkZSeoa2jjZGmwc/Az+/dp52RjYOijZikq7q1usrS3PDrvqeZoJSNhIH19IeUjZ2OmaCnnrPH5cmAv5ipq5uXmJWYo7O0ubm2yLikiIaEh5CToaumtcC6sK24s7C7urC2vb20tLe/vaavx9bCucbUwMnBxL6trsO/s7emnY+OjZOep7Svq6OXuMG+r42gtqypq+X8687S1N7H9e7i59u1uOTc7Ozn9vb/guL0i/ba5OmBiJyq0sqwopmAjYqJj42HhIeD8oWIiYTkwMTJs7uyqaGEp8PGxbuomq+rno6anLO/u6Cruaeuo7XDw8K5o7mzjPSjl5KAhJWbjIf8iP+IkI2bmp+ptq21y+W/0NHKvMHDppSThqu2rp231MeSh5eQmsva5NzLrriwl5aclYX1jZrIwubgzuTmgYqAk4+J/9nT0cra5c6/1MjCweDi09m3yKrLx7OUpbqkiaCI9ZXg9uO4zeLp1LvL0/f+4ObK18jRy//hyOjsw6zE0s/S8vTgvsSijZi0vsqdq7C6ucO6xLKajIaIkZKQkPSTpZD7oMHGyK2inr63srGuwcK2sKSUpMnTtsK9uLvOtrqAmIKajbCytqmdybS6w7Wvj5KUm6rBqaqfx6q9y9jQpqyttLqtp5Ozs5yGpbuYqMNvc3DUq5e4vLezvbGdk6iyzXBvfIKCdXWBenR6dn2Bf4J+f4V7c3FybsK7cHh9f4R/d23Ht8JpaMtpdoGChXl+eW9xbGpsdXt2dW5pcXlvbL6AxsbGa7+zx7vLbGlr0NNve35xbNRvzsrFa3NxcXZv0m5p0MbItqbDbW1obG9rcmjGzXJvbm9ybWlw0b3KbWfNxm1nbMfIv8G5qM3Otcm/y7avnJaptchox3DFar2vq7udrb68q6OXmJOcpJ+frLHCkX+Gl6GdxL+sp6mZlKOVpo+Ag5aIk3B9lYqKjZqSuK6ss6ykip+vs5N/hZqPoIiWmJqZnI2xrq+Xj4N8hXeYmZuYo6qRoI6QmrGopLWrubuIlK2FjtKVnK+3u5Le1dDeu6Nsraexm3iA0IWXkK+ly7e9x8DAx8egrpmYdKCppZCirKqz0qTQb3h4d2nAc3HTzXCAe4CDgJuFdoC8gZCpvLSVgoSKj56cjIJ7bM7MvLm7uaqmlaNrrpOFi8mwqKiC2tB8l4bfxnaQhIZ6v3+HjHaAlpiRhYiMf46WfoCDkYR6j33Zeo6fl5OBh3x6gIWRkpJyfpmmpImCpoJ4g4OOioh8d4x74XOQesbG4HNzfnt93MqA54yej36Ejo2TmbPDamrEtau3uKyvkpefkX+csMTIz9C4qZyEeMjJytrQtLrI1nh/5tbPdHp4eoOJdXqFmIh+13qHipGHdePCfIGJi5WLen6PqLKnsM2/kIp+f3WSfYuSl6KgpLG4wdHNp5eFjYN9cnLb2XqGfo18h46TipyszK+ArYWWl4mIiYODjJyfo6KgsqKRd3d2d3+AjZeSoKqhl5Wim5qlpJqepqacnaCoppCYrLiooK23pa6nrKeYmaypnJ6Pin58eoKLlaCbmJKGpKynnH2Mn5aUlcHUx6+1tr+r1MvCxr2bm8S5xMbC0tLUbrnNc8q1wMNscYGMrJ6KgHqAc3BwdXNvbnFvyHBwcW7Bo6qrmqGck4xzkq6qq6GViJqTiXuFiJumo4iUopCbi5umpqihjaCceNGOg4BvcoCGeXbddt11fXiEgYaPmpKarsijsK+pnaOjjH19cpWcl4SctKx6cYF7hK63w7mskJqTfn+FfnTRfIGsn8S+rsG8a3KAeHRvz7Kur6mytqWcrKSgnrm7q7CSpYqko5R8h5mKc4lz1H+/z76crrq/r5qrsc3St8Kpt6m2stnBq8nNqpmtvbi80tTEpKyOfoihp7KLlpukoqyirZ2GeHZ4gIB+f9SAkHzYj6mvsZSNiKefmZqXqqmdl5CAjKy0maaenqO1n6KAhHSFe5iXm5GHp5mdoZmTen1+hZKjkY6Kq5Wlr7q0kZWYm56UjX+ZmYd4jpyDjpxaX1qokIKZnJiXm5WGf4+Wq1xcZWloXl5lX1tiX2RoaWlmZmxlXl1dV5ydXWJoa25qY1qjlZpUVKVWX2ZqbmRnZl1dW1lcYWdkZF5aYWddWpuApaWkW6WZqZyuXllbr69bZmhdXbRdrayqW2JgXmBasl1YrKelkIOgWVdVWFZWXFSjq2BdXF1hXVhcsKKoWlWsqltZW6mwqaumlqqzn6qpsKOaioGKl6FUp12qWaGcl52NlKGglJGCf3x/hYWGj5Oggm9yeYODnJ6XkZKFgIqGjX2AeIR/fmZsfnZyeX1+l5OTlI6He4iSl4FwdIN+inaAgYOGiHmSlJWDfnVvc2mCiIiGkpiAjn5+hpeTjZiUnp14g5R7fMB+gJKWl33JxMXTuKFolpCcim90wHaAhJmWp5yeo5+hoaCJlIOBaYyQjoGOlZGdrYusW2JkY1ekX162r2GAaWtqaHxpYmmfanaMmo94Z21sb3t7bGZhVauno56fnZCLgIZOiod1fLSckpR2zsZyjnvSvXGHfX1yuHh/gHF6iYiEeXp9cn+KdXh6hnZwgXTJcYGPiYl4fnVweHuFhYRmc4uZmIB6l3psd3mDfnhwa3xx02x9cLm3y2ZjbG9zzsOA1oGOhXx9iYeMjp+uXmC4raGppZ2giYyRhXWNmqiss7eonZN+dMXDxNHKs7W/x2523cO4ZmtraWxyamlxgHhwxm58f4Z8ab6sbHB4e4J6a3B+k56UnLCjgHx0dW2FdnqBiJKQlKCkr76+nIx8g3p0bGrMzHF3cX1ye36CfYuas6CAmXmLiX53end5fouOkJKSn5SIb2trbXR3goqGk5qQh4aRjYyUlY2Mk5WNj4+YlYOLmaSYj5mjmJ6WmpaLj6OdkZKAfnBycXZ+h5KQkIt9mJeSjHWCkYaGhp+wrZmfoKeYvLKurKSKiKWep6imr7O2Xp6vYKaYnqJcYWtxf3NnYmCAXVtaXVlZW1taqFxaWlmfio6PgYWCfnlmgJaTlIyEfoqCeG14fI+YkHuJj4GGeoaRj46Ke4uGa79/dXBlZ29za2zHZsZobmpxcHN4gn2Ck6SMlZCNh4qHd2xrYXyGgHKHmpFnY21nb5KcpJyQfYF5amxwbmW4anKTjKGjlqWjW2CAZGFcq5ORj4uMi4J+ioWDg5OSh4h5hHKDhHlpbXlvX21ftW2eqZyDkJWYjYCLkKOlmKKPmpGcnbinma2ymoyer62wvLisk5eCdnyRl559iI+Qj5aQmIp2bWlsdXFwb8NveWvEfJWbmIR/fJWNiIiIl5GJhH9ye5OYgoyGiY+Yio6vfoN/jn6Yf4J+iH8Gfn5+f39+l3+EfgF/hX4Ff39/fn6FfwV+f35+foZ/A35/f4Z+iH+Cfoh/Cn5+fn9/fn5/f3+TfgV/fn9+f+h+AX2GfoZ9h34BfZ1+hX8Ffn9/fn6JfwF+kH+KfgV/fn5/f4V+B319fn5+fX2FfgF9ln4BfaF+B31+fn59fX2FfoN9i36Cf5d+iX0Ffn59fX2MfgF9hn6Cfal+gn38fgR/fn5/hH6SfwF+hH+pfgF9iX4DfX59sH4BfYl+hX+efgF9vH4FfX5+fn2dfgICBACA2bu21oDx1Nbd1Lafg5alqq/FubLy3eXO0rbGvsbF0OWG+unjv8vUzMPb086uqM3L0PuA6Ob+h/T8h+rh2t/Bvt7k4Pj+goaEgIOFkqCggYeKgoONlomC8vP8kZKVnamrpaS1sLGkkouUkIWGiIPu8d/o4+Dcy8bU4Orv/Yn68P2A8IeHhInx7Ozp8unt5+PW7vr3+4iIhYaSg4H//4br7YWMi4L28+3X7oOKi4mEguPz4NXt6/KDiefi2fGEiIGC9vH34PDp+ob79vH61t/G2NLh/P/Y6uLDwc/V6evMy+Lf8One1aHKs4W22qTKtsnDsJSp19fgst/5i/6M/tq/rJqAoKWnobnEweO3k4CysrDY29HBtcCzopKRjJq7ut7OoL+tzNLKuKfBt7DL0cipoI2hraudjJSPl8jhz9PSybuwm6GfssTm9ebBtKmmkruys4C/pd6Bj9D4mJ+vxdfY+trm4NnV38bd4Pi9g6uy5u/vy8PE39n7ieGHl4SLifiD7YaAi+yRjJacoaC0pbHM6eLT0c/Ix8y3q46Jn6eXjdviyL+8uteGgdrIzfvM1ue/ifGNp5uQ3Kmv69PC86K2y7WVpZiKlZmerLmf9PL25fry5u+IgvyIoIeRoJSipZqkoJORj56yvrSxn4yYjO305ouamIz2hIyXjYiIjpecooONg/qA+I2gpLesmYeZnqSwucDd18q0tce/qqKhr7/Fxrqov6mwoaOumoD+jZWahfjey666zsS3yd/T2M7V2ejrgKqzzLSprJusifnTgpuqoaa5u7OdoLDBw8ivsLa4sqeqqaeyn5yMhP2Kwbmyv7auqJ2ptra+2tO/sKSXhoidk4+SqciA0L3V1sXt/JStlaS3o6KvtLzP0sGjocawraGjn52UkIKMj6KcocCvr6igpaChqbe5rsbm6+Xb0MvH2cesrKesoKKhm7qusZ6vtbeTkqSqu7S1ornP5urhhYXw4eDg6ebf3ePT3uTYz8ba9vTby9D6hICJ+/HvhI+YqrPRu6ygl5eAkZSZkfjZ2tz4goqK9O+A8+Hr0sO8raSvpamSlaGIlp3AsqWWlaysna28vaiim52gmJiYmZ6rn4Wmt7KAn5+cqpePp6mTpq642PrJv7SwqaSov8bDr6yZkpy9sqSrp7S336+vn7XUyri2vsbqz7Wds6CwqIPno7XH4/jp7929zuKA4fLo7fn6zbfG0s7l0cfVy9a6raentLOS6qGemcDKn6ypvdTZx7rP+5yfj+H87+jd1Ma+wMzI0erDu+Dv7MTIwo2VutW8pquLpLm5r5qJmJKboLHI1KuhtI6dkZiGheT2m7HEnK+yx7i9ycfL0LSnp5mkn52mt7qqvdHdxtDD4tCAup+btGrItLm+tp2IcIKRlJapnJfRvMOyuJqroqqpscFx1MXDoq+1rqa9srOZkrGstNZqwMPTcczSccW9uryjoLq+udPWbHBsZ2ttdoCEanNzbG90eXBqyMjPeHh6gIuJhIGNh4qBdXF5dWxvcG7IyrrEvry9rqu2vMPH03XUztmAynJwbnLMx8bDzcHGwMO5x9DOzm9vb252amvUz26+wmlycWjDwsOuv2pvcW9ra7jLua/Fw8htc8K5tchsb2lqysnOuMzBz3LQzMrIrruita7C0cmsvruen6mzyMOnrrq8wbqzs4qrlnKkupCwk6ajk3uVsLi7mb7Occhwx6yfj4SAi4uPh5yhncaghXGklpC0sq+nmKWaj35/e4ein76wiaOTrLKpnIminJOpsKuRi3yLlZSLfIF8gqbCsbiurJiag4+Dkp63wLygko6PfJ+Sm3i1nM50h8Hag4SRo6+xx7G8tLGrt6aztsmmd5GVwMLFq6irxrfOdLlteGtyc9Bvy3CAcsBzbnV9foCSgo6hubWoqKOcmKGSinZwfoZ7d7zCq5yam7hubbujrNqvvsqjfuKBmY2F1Z6q4sS315CcrKGAkYF2gISMkZaN6dvZxNjTyNN4cdZxiXOAiICJj4aRkYKAf4mXo52ei3iFec3VzXyGhHnYd3mCeXZ6gIiLiHWCdOOA4nyLip+ahnqNjJKZm5+5tLCeo6qkkouMk6Cmo5mOoY+bipCUhnPme4SQeOfSzqmvxbOktMC1uq2zvcnQcJedtp2QlIecddi3cYaUjY6gn5qHi5mopayWmJ6gm5KTkoyaiIl5c+F7rKOeq6OdlY2Xo6OovrimnJKFdneMhIGClK2AtaK6uq3O24GZgpCgjo6ZnaS0uKiPjLGcmY6PjIuCfnN8f4+Jjquam5WNj4uNk6ChlKzIysa+s7Cqva6XlJGYio6PiKiYmomboKGBgpGWp56ej6G0ycnBcnLMv7/Ax8PCvsW1v8S5saW30Mq2rbLQbWl00snJb3iAjpKok4d/eHqAdXl+dsq0uLbMbHJyzMlt0cDJtKiilI2WipN9gY13homrnJF/gJWXh5Sjo4+Ph4eKhYODgoiUi3KRoZxujYqFlYV9lZJ/lJifutanoZiWj4yOoaajkZKAeoajmo2Qi5uYv5GXhp63rJmXoqbIrJWCmYaUjnDHj5ypvtDB0rygsL+Auce/w8/LpZelq6i/q6Oup7KZj4qKl5J5xYuIgaGphZGPpLO2pJ6t0H6Ac7fPxMC3rqOfpK+qr8Oin73MzqmtqnuCp7mjkZd7kqOkmYh4hoSMjpyxuZWOo32Mg4d2dsbbjJywiZqbrJ+jrKqutJyTk4WRioeRoKKSpbG6prGpxLCAmIWCllalmZygmYV1Ym99fn+QhIKrn6iWm4SPi4+PlaJitqeki5ibmZGhmJWDfZSUmLJYoKStW6qsXqWhn5+KhZydm7CzWVtXU1VZYWVoV15eW1xfYl1Xo6SvZGRmbHFuaWVuZmljW1tgYFxeX12prKKqo6SmmJWepqqssWK4trqAqF5eX2GwrKmlq6amp6eep66vrltdXVldVlewrlqboFZdW1Scn6OPmVZaXVtXWJ2unZWnqapdYqebmapcXFtcr62xnq6ksGCwr62umqGOnZacp6mWoaOUkJqcq6yXlZmfoZqZmnyTimuGnIGTg46PhnN8j5qhh5yqXKxbrpqMf3SAeXd6eYaGjKKIc2iMf36Tjo6KhI2HgXBwbXeKiqSZe4qBlJqSh3iKh3+QmJOBfHF3gYB5bnNudZmqnZ6XkoeHdX50foaRm5mCf357couGhW6wocprdrjMcXeBjZaZqJWcnJWWnpGUl6eNa3+HpKOhkpOXqaG2YKFaYVlhYLNfrl2AXp9fWWBnZWZuY3F+kY2Hg392eIF0bl9fY2ldXZ6olYaBhZpYW52Pl8SbpbWRdNR4joV6yaGn1cKzzYWSoJN2g3lwd35/goWA3NPTvsrEvMVpZshofGtzfnZ9hX2CgnhzcX+LlZCThHN7dcjFv3J3d3PKbGpyb21ydHd8e252bNGAz296e42Mf3N/gIaOkperqqWVkZqWiYKCh5CWlI2FkISJgIOLgXHbdH2JdNzPyaaiubSkpLGtrqOnsbK6aIiPoY2Ag3iFasWkZHWBenuLi4d2eoWSj5WFipCSioGDgoCKfX1ybdRynpmTnZmSi4SPl5SZqqaYkop/bW+BeHR2g5mAnpCnqJ2+x3SHdYWTgX+MjpakpZeCf56OjYKGf393dGlydoR6fpiOjIWBhX5+goyQhZmwsq6on5+aqpuGhIOJgYWCf5aMj36OlZV7e4WLmpGOgZGjtLGrX12qpKSnqamppaugq6uhl46cr6qZk5WuXFlgsamqXWVsd3l/bWhkYWCAXWBlXqKUlpSiV1tbqKZYq6OolY2Jf3uBdXxucnxteH+ci39zdISFfIaRjn9/d3h5c3JycnV9d2aDjYhmenl4gXd2hYJxfoaQobiQiIJ/e3l6iouEeXlra3KJgHd8eISGn3x7cIScjHx7h42kkHxtfnJ7dGCxfIaUo62jr5+Hl6OAnaOdoqqhhn2GioubjYmMiJCBd3JxeXRlrXZ1c4mOc3x6jJqYiYSQp2FjV5GhnpmTi4eGi5SRk6CLjKStrpSXk3N3k6GNfodvg5OUiXpxfHyCgY6eo4N+jnR/d3tuarPEfomVeImMl4qLkpOYm4qBgnaAfHiCjox/iZOaiJGNpZSEfgF/m34Bf5F+CH9+fn5/fn5/i36Sf4N+lH+OfgF/hH6Ef45+h38Ffn5/fn6Ef4V+hn+HfoJ/hH6Ef4d+AX+xfgN/fn/Vfgd9fX1+fn19nn4Cf36FfwZ+f35/f36af4d+gn+JfgF9hH6HfY5+iH0Dfn59l36DfYR+AX2NfoJ9pX4BfYR+kX2KfoJ9nH4BfaB+gn3QfoJ/ln4Gf39/fn5+j3+FfgZ/f39+fn/lfgF9o34BfY9+g3+zfoJ9oH4CAgQAgNjWubO1zs/m4cattcK7vqawwq3Ex7zJsqa3nqKyxc7FqKHA1Pj24NjEwtbNvaCj0NXP4tHSzc7k6P/++fDy6Nrd9Orw/IqHlq2ioKaO/ez/h46NlpaL9/WFhIGNiJepm5eknZmK7O3z5NfQ49G+spqYqcLO0uyA9OPa9Ozl2sSxgMXO3uXg+v35+/DgzvH/8+ru54L9+4SEhPv8hf39gfX25u7g5+nihfDk4uL4/Pn/gPfz8uPOydjf6vfv8Pjn3vHe1+Tfxc/a6dq8sbzW5evr7tPj5sCuurXMxsLSv7S+482Si5yqu7TKwrqo2cXN0eLu4rTjyrecqLPh0LmphvKagLq/oKCgt7zF1cOTrr63mcTHuK6XrJiVm4mOu9nSvbauubq+saXBx+LYvKCKpsXW4+3mxK6606W0xtXCzsLGvsjbx8GxtcPEu6mzhNGZsaaYz6L6oIml5Kupg6zC1ODT5smpodjLveC2nr6uvcXs9ISUgevzgf6NifH+9YSMiI+JgJegipeWl568rsbU9+LS0cXY3dXTxqqim6GPiYHn0N3k78e9rMPj49Tg7LzaobWn8tv3+pSBgtvUvujv29+Hpaejk+a505SCi4TX8fSY8//n94n2koKE3rz2hYTyh5GZpaSfo7SgrIyWpLuwoZeasqGYg4GSnIiWlqOurraijIWUgIiFmaKxtKqqrrG3j4mC7oGDhoqZmqKc7euHkIuhmf/7+ICH4OHz7f2D/I2rvKiZgO2N/pOQoK6r95igqa/P18/LnJmFiZCHiZKnnpuVnqinmZugpqqtnJ2trJmNi/+VlZ+yqamVlqjDxMa1l5+8wqqnrLnU0Nne28bDyqqPg4GRgJSZpqqxhZKhrKmttrCqqbzOs6CnoKOjpK2/wK6Zl6Wrp56VkZmfnKCosLausr6kn6u9vLuxqaWsu7/KyaWYkrLUz8us3/rUu7+nxNvJ3c/fyNTw4+vn9oL+/9zk3PHZr5urr6uqpLe7q6CZmcz1kpScl4yPmJmXobO2urahpYjPgMnC2O/oioySipOdoYDy8tndy66lrbapt7HL0NfVuKaemb7iwbChm7PP38LBw6qpnay1uJ+dspGMmpyfmIuToaCCgPigqrmnsbu5xdXQwre2zbK6na+7qp+5q6ez1srUy8PGtMKvvrywraqvuLKwqLOsvr+4qZ3J0+fw7NDWzeK9gJq739K8vrG52+bj1sfFvLW/0MW8o5WwrsPTz63c3rmQ1qPAv8zd/4ONm6eP+fDL2cHE1tPMzM/X9uDw88/Ducm4tbHBuLGnnJanorDCt6ihm42NkIyaoKqV4e7R3Oja2/mXoa+sqJ2Ji6KZtayplJWMmprGsJycq6y7noqbwcXAgLe3oJqbsrDDwKiSm6mhpI2ZqpWpqp6tmIyeiY2crbGrj4qks9HLvLipprmxoYuOsbKsvbCxr67DxtnRy8LFvbK1yb3EzHFtd4t/gIZz0sPWb3NxfH51yslubGt0cHyNf3iHfnxxwcPLv7i0xLKmm4aCkaiwsshs0L+20MbCu6aWgKivvcC70dXRz8y/r8vVycDHvmrQzmpsbdDRbMvPacfHusS3vMO4bcW+wbjIzszRasnHx7ysp7a7wczFxMnBvsy8tb++p622wbahl56yvcDCxLG+wKGUn5muqKOyo5yewKx9dYaSopStpKCMvqWwrr/HvpTDqZx9hJe/qZWPec1+gJajjIuDl5mgsbKGl6Sfh6ysoJqFmYeDiHd7obW0pJ6VoKKkmpCnqsC6oox7kKu1wMrDqJahtY2YnrCfpKSln6O0qqKUkpucpJCdebh+mY2RzqThjoKj0pCXcI6dqrSmva6QhLOrm7Sdi6KSmaG7xmx5bcvPa9N4c8nSzGxyb3FwgH2Fcnl6fX6ViZ+lv7OmqKCsr6imnYeCfH9zbmm/qrjBz7CmkaO/wLbGy5/Dk7OU2cvg4oN0dszPudnXu8J4kZOPgdesuH93fHO92NmF3OjS3XbUhHh7y63gdnTMen2BiYyFhJKDknuDi6WTi4GDmY2BcHOEhnWFg42YlZiPfHeAgHN0h4WQmo6SmJeceoF203d1dnmHh5GI0NV7gHuKg+bj1XF7xtHX1Ot64n+ZoZCKc91/44V/jpmb3omPlZayt7Gxh4Zyd311dX6Uh4R/iZCRgoWKkJWXh4eWlIV6ed6CgYuclZeFhZWtq6yghY2nrJOUmaS8uMDBv66qs5iAdnaEgIOGlZafdYCLlJaXoZiVlKa1nIyUjJCRkpanqJiGhpOXk4yEf4aLiY2SmJ6ZnKiRipeloqOXko6VoaaxsI+Ff5+5tLKWxdm4pK2TscKwxLXKrrnNwMzH13Ld2LzHvNC6loiYnJOTipufk4eEg7HOeHmBe3F1fXt6hJCUk5B/hW+rgKqhtcnBcnR3cHuBhWjKzre6rZWOk5+SopuvtLq7n5CLh6fCpJiMiJuzw6qorJOUh5WbnoiImXt5hoaHhHl+jotvcNiMlaKRnKGfq7mxopmZrZSegJedkYigko6WvKq0rqanmaaTo52Tj46TmJOTjpeOoaGajYOrs8LKxK+2qbyegIGevK2en5Odt7u3r6Kjm5eirqKbiX2WkaWwsZG7uZ5/w5epoKi20mpxfIh1zcipuKSmtLGrrK+10rrEz6yln6+enpuooaCWiYSSjZion5OOin19gXyKjJWDzNnAzM/Dyd+Jj52WkYh5e4+FnZSTf394hoeul4eIlJShiXiHpqikgJiZh4OElJWinYx9go+KiXmDkIGPkYaQgHiGeHmJlpiUfHqPlq6qnp2Qj5mUiHZ8lpOMl5CTkpSkq7SspaGelpCVo5qfoFlXXW1lZ2lbq56vWl5cZWZeqKpaWFVfXWhzZV9taGVdoaOrpKKfqp2QiXhufJCbmqpbrJ+bsa+rpI+BgIuSn5+Yq7GusK+nmKmxp56jn1arrFdXWK6sVqWvWKaimqOWmKGYWqefoZyor6muV6iop56Uj5yhoqyno6ijoqqlnKWjj5GZpJ6MhYeZoqOio5enpYyDi4aalI2ckYeKopdyaneAi4SWkIl7no2UkqCmnoGik4Vqc4mlmYmDbsR1gIeOfntzgISMmZd4hI+MepaYjIR1h3l2e2xuipiaj4iFi4+QiX+SlKWgjX5yfpKcpaukk4eQn4CJjpuQkY2Pi5KbkImCgYeHh3yFba90hYCBw6XXfnemy4B9ZYCKk5eQnI9+d5aRipmId4h9hYyhqlxlX7C1XrpmYayzsl5gXF1agGhqXWBhZWZ0bn2AkoyHiIOIioWEdmhnZWVdXVqilJ6kr5iRfo6in5ilsI2uh5yIz8XQ2X5tbLrArsvQuL1whYeIec6rtXVtdGu7z858zNnGz2nAd2ttvqjVcGzDcXJ0eXx0dIF2gnJ1fZGEgHZ3h4J3aGd2fG12dX+GhYmDdHB1gG5od3iBi4SCioiOc3dxynBwcXB7fYeAy8l0eHF+ftnUz2pxusPMzdhw03OIlIaBcM1313l6ho2L04CBiYmdpaCgfXVnam9paXCAd3dyeYCDeHd6gYWIenqJiHtvbc13d36Lhol5fYudnJ6Sfoedn4mIjJivqbCzr6GepZB+cG56gHx8hYyTbXR+hYiKkoqGhJSkjoGGgIaHiImYl4t7fYeKh4F6cnl/fYKHi42KjpaCfYmRj5SIgYGIlJWfnH53d5Knop+JsManlp+Noqmhs6S0oKm5rbWxv2PBuaSnpLWjhHqHi4KBeIWIfXVzcpqtYmJnYFpbYWJganRzcm9la1qOgI2HlqWfWlxeW2RlaFSlqJqZj356f4p/ioaVnKOejIOAeJSljoN7eoubqJWSk4N/d4KIh3V1gWxpcXR2cWlvfXpkZch8gol6gYmLlZyZiIGEj4CEbICCeHWFeniAnZGblI6Mgop+ioR6d3R5fHZ5d3x4hIOBd3KUmaSqopGXj5uCgHCHmYyBgnqCmZiRi4OEf3uFjYN8cWp7e4uSjnuYk4Nts4CQjJCarlVaYWZaoaGMmouMlpaMipCdsZ6jq5GNjZeNjIqTkI2FfHeCfoiUjYOBfHBxdnJ8fIR0usy3wMC3usp4f4mHg3prb393iIGAbWtoc3aSfnR2f3yGdGd0iY2IxX6If4N+hn+Cfo1/kX4Bf5t+DH9+fn9/f35+f35+f4h+AX+IfgF/zn4Bfcx+AX2Efgd9fX1+fn19mH4Mf39/fn5/fn9/fn5+oX+TfoR9g36HfYV+g32EfgR9fX1+hH0Lfn1+fn59fX1+fn2yfgF9iH6CfYV+BX19fX5+hX0Cfn2GfgN9fn2FfgF9pH4Bffl+AX+WfpF/hn6If7V+AX3dfgF9hn6Ff61+iH2ffgICBACAwL/Uy820z9Xiv7PB39zJu7rH3u3exO3Rw6ax6PXSvbzOzc3T4erT3uvGzMLM0crZ1NLDxNifqbvQ7Nnsz8bHyr7K1ezU44WCh5STlaSSjJGNl4OboJ2OiI6K8Ovc4OfIz9z259vj3NTb6tzv8/P6hPfz5Oro8eP0+Obh5NrYyNaAztXa3djh3uLn4Ov39eSFi4mDgv+CgID6hImTj/7+hIDv8P323+TW3efq+eDb+e7W5ufUydzw28u6w9Xh2NfUyczX1+XcvbS9ws/e187szca7tMy8mYyclZaZnri7tZyAmLi0ysm7yM3fwLOsx9bPuKKW+ZCTq6K4nq6Qh6ubqJqAguyKmKuto67X4NvK4Oje48SkoquhqvOHlKa7uNXIt6OyrpqoqaO7tcOr0NPM09yuw8C9vs3DuaCw2czY1sLAzN3YyLWnra7kwKOnsb69s62TyJzMuILysLGSkLilrsfI072auNPX2OCD8oLTx9KA7YmChYWBi42amZuCgMj/lYyAnbKgqLS4wLi/r6Df69He3vDs5O333re3sK6UhIHt8ubNyb/f4M3C09/a7uKzy8rMtrGe6dfu5IeRiPLY9bW+qqOKj5bMuf/h+N/2jov5hvrbiZilj4WDjPzokvHz94qPlYD0/o6Cl5aUnKeUjJOXn6Cpno6dl4yKjoyUnrCkoKWAkfGLk4ulqZeXlZCKk43/8/n+85KsmJyflp2rq5mcjILa+I+ZlOvM1d7i84SEg4uFjo6ZnYugiZSFhouTi7Wypp+VmY+YopurmKW8qZ+VqbStoaOdkJyRg5OcmJmDgISLjqConKGklZCfmpmXmKuUg4atwrSgl6HC07+2t662sKeAmJansrCgoIbh8/iGlJ2jp6i0urmgnpmdoJqTkY6Gh4iLkKqXhIP+kZqahZGomrq3raiZucGhsbmpnZ6cpqe3t6mkpqi6z8azrcm8rrrY3enf9IKHhoGEiZiYlpWG9uzV4NjKz9fU08/Bxuf/jZyqrqmnpZmFiZGYk4mNmY6KgoSAh4GHjYWGiYSDhoOA7tLb6vnVy62mus6omKHiyMe5nKnGyKrMvYCHo7quqLCvs83MwZ+bpKGYq57AzcqooKfBs5erramsxK6yvbmqorrExt7F5reprcHFvtDEs7LNu7Lev8TAtbvG54Hf7tfbzuHl5e3k0cLO29Lb0+DPxNG/qrKArba1p7OwmJqgv7Sqn6Sxz9vz+NnDws/lhIHp7uzv4O3Co7GvqKq42PT7gPDh3Mroy8TGudjS0tjH3/DXytrf0c3jz8HJydfFpK+1qLKto5eTmpuUo6CLhIr6gIXnlZ+3mqS5w76dl5GFi4X7+pOHlp6wt6SjqbO63rXZxqi8xrqApZ+3q6yXr7K+oZijvLupn52nuMS4o8muo4uXw9Gyo5+zrq+xu8OuvsqkrKOss6myrq+jpLeHkJ6uwrDCq6SjpZ+ps8euumxqbnp1eId2cXZxemp/g4BxbXJvw8K4vMWosLnMuri/u7K4xbnKzMjRbsvLvMHCybvMzsa/w7q6qreArra9vre7u8LEv8fSzr5vcXBsbNNpZ2bIam52c8/Qa2e+ws3GtruwtLu8zbWyz8Swvr+wprjHt6ycobS+ubi2q6iytMC5opegpa+7tK3IrKWdna+ihnmGfn+Ch5mZmYVxgpuWqaidpqzBnZaOo7KumoiE3Hx8k4eaiJeBdpKFkYuAdsdkbouTiIyvtcOxv8bAxauPjpaJldh4gYqdm7OrnY+cm4iSkoyjnKiUsLKvsb2Wp6ChorGnn4qRsa61sqChobGxp5qNmY+6m4mKk5qbkpiJuoauon3XkJWDfJqKlK2krKaGla+1trVqwm2vpqdnvG1oaGtpeHF8fINubqjNe3GAe46EiZCTnpObjX+tu6e2rrizr7S/s5GSi453aWnFxb6qqqO/vameqrCxxL+btLOxpJ+N2crgy3uEge7b7qqnnZd/gYTFq+jW7NHkg4DpdePHgImTfHd0euHOf8re2nh3fmvN13p2ioR/iIuAeIB/jI2PhXuMfnRxfnh9g5SMh4yAgtJ6fXiRin6Efnp1hnrh3uXe24KUgYaMiI2dloiFenTQ7YGJitG5yc7P6HR2dnt0fX2EineMd4J0dHiBd6Cbj4l+g3uDjoaUgI+hkYp/laWWi4+Kfo2CcYCKhox1cXR6fY6XipCQhX+PiYmGhpmDd3iZq52MhI+puqiko5agm5OAhoeTnJyOknbI2d13hIyRlZSgpKOPj4yRk4qDg4J6eXh5gJuEc3XhgoeIdoCViaajmJGGoqiMmqOUiYqJlZOhoI+OkJGjt62dlrCkmaS9ws7D1nJ2dW9xdoOCgH1x08+7xLutsLWvsbKmqcPTc4CLioeGhXxsb3V7dm1wenFuaGyAcWtvdWtrcW9scG1rxa+5yNWyq5SNo7OQg4rEqqygiJStsZSwpG50j6KVkZaWnLGtpYiIkIuClImmrq6PipGlmYGUlZKUqpOZo5+Rip+qqLylyZmPkKSon7CmmJi2nJTFoamlmp6ownC7xLG5rcDAusK8rJ6ot663rbenoK2fjZaAkZuajp2XgoaGopSQh4qUs7jJyrOhoKq9ami7wr7DucSjipuXlJSeuM3NasC3tKjDp6GlmLOusLGiucixq7u/tK3AsaatrbinjZackZmUjIN/h4iCkIx7cnvccnnNhYyih5GiqqeIhoB2e3Xi24J2gomYnYyMkZuevpm6qZKfp5+AhoaZko9+j5Kch4KKn5yRh4eMl6KciKOOiXeBo62XjYqYkJWUnaGPnqWKkIuSl42Tj5GJiJh0eYSNnI+aioWAhoONlqGOk1ZSV2NfYm5fWVxaYFZobGZaV1pan6KYnaiSmJ+vnp+jn5WbpJ2nqqevWKaonKChraCssa6prqOjlJyAkJuhpZ6hoaWmoKOtrKBbXFpZWK5VU1KmV1tgXaqsWFOZnKOflJqTlpqZp5iZsaaVoKKXkZ6pm5OHipqjnpybkpCXmqKfjYOJjZSgmJCmlZCIiJeSenF3cXRzdoCBhXVlcIN+kJGHjJGghH56iJWXiXl1yG1sf3iGfYh3bYJ3gXuAa65XZn1/dXyWm6KYpqilqpmBgYN6gMpscniHhp6Vi4CKinqCf3+PjJOBl5qYmqKGj4uKipiSj36InJmfnpGQkpqclIh9h4SZgXZyeIOFgIV4s3aTjHLNgX90c4Z5gZKOkYl1hpKXmZtVoFeZkZZVplxXWVtZZ2Joa21cW5OtZV2AaHVtdHl5g3t9c26RloqWjpOIhYmPiXBxbXJhV1ilpaGUkY+gnJCHkZeXp6aKopyflY6BzL3QwXN0c93I1ZaVjod1d3q6p9vK3sDSeHbWa9W/c3aDc29ucdLEc7vOym5sdGW+w29tfHh2e3x2cXN1hYSFfXF+dWxqcW5xdYWAfICAeshucmx+f3R1cm9td3LW09fS0HiJfIF9fYGLi357c23Dzm97fMm0vsLG0WxtbXBrdHR4fGx+bHNqam11bI6LgHhuc251fneDc4COgHlxhI2HfoB6dH96a3d9en5raW1vcX6If4SEeXaEgYB/fot4b3OOoJKCfIacq52amY+Xj4eAfn2IkI+Bh2+8ydFxen+EiImSlpKDiISFhIN7e3p0cm5vdIp8bWzUe358a3yOfpaRh4F7lZd+jJGDe3t5g4KQjoKChISQpaGPiZ6Wjpior7iuw2dsaWRlZ3Fxbmtit7GmraSXl5WRkpiPkqOxX2lwamdnaGNXWF1iXVVWXldVUlaAXVhbXFNUWlpWWVpYnJCcpayWj356i5l9cnqikpCIeIOUlYKUimJpg42DfoKBhpiTjHV3fnp1gHyOl5V/eX+Og3J+gIGFj3+CjIt9eYqTk56Op394eYmNhJONgH+YhH6hjJCMg4KNpVqcnZCWkKCdmp+Yi4GLlY+WjpOIhJKHd36AeoB+eIOBbnBwhXp3b3N8lZegoI6EhYuYUlGVmZmclp2GdIB+f4GImqeiUpWQkImbiX+Efo+OjpCIm6eTj5+kmpelmZOWl5+Pe4WGgoiDe3RzeHhzfnhqZWvLa3C8eH6Oe4KQk412d3Rrb2zKxW5mcXaAgHV1d4GEmoCViXeAiIPGfpR/lX4Bf55+hX8Ffn9/f36EfwR+fn9/0n4BfY5+AX2UfgF9un4BfYR+AX2Rfgh/fn9+fn5/fox/gn6ff5Z+hH0Gfn5+fX19h36HfQZ+fn1+fX2HfgZ9fX59fX2EfoJ9nX4BfYx+hX2NfgV9fX5+foZ93X6DfZt+AX2rfot/j36gf9t+AX+wfoJ/kH4Bf65+BH1+fn2OfoJ9k34CAgQAgODt57jC1b2WvLjA3eTh9/ji1rfIvM3z0sDKu8XDs6q3w8Hp5dHN0N7a8OHXsqSjpa+sqK2ijazYzbS3rKSYq9Tg4Lm5tcG04s3P54yOmJycmobgg4aKgOXv28zu5tzDyMbP29Lm29ji7PeAhYGDhOro4/Dy8efMz9bi2Nfn4tLKgNnh8+vg697n9P6IgoqNg/6GioOB/4L1gY6KgfnzhYX774OIj/367fDa6+7u2s7MydLC0c25wNbb2+vx8OLk1sG51cfVzvP49PTj6ujp29Dbuaamsa2ip7jVtJeinLKhsbvAsqepray01MjDzN/QvKC8uKC8s7Wlq5yRnaC3uq+0gMC8xce2w9HIztzAqKykjp+kq7GzupKonYy5pai8rLigoKKtxrCZua/HxaybvNLb39jHva2trbLIy87w5drCz9zfw7qkwLzm5tu9krO6xsu3wIXQnJiznrGdjrmqkMGAup7bu6O83dTu3oaD7oSB2OT+gYuOgZKTjJSMkJSPjZ30gIaHl6almoeiuqaMtMO+zNnj5tPd8ejEtJyWno2H+IDsio6CioPamZedj4uYw6/S07u2usOy18rd19bOzdneuMW4y7j47NOHramymKSJ7oWFk5qyrqGpjZbzl/3o9fTeg/3V7t6H8+T34PiOh/aPkZyikoD/gvf0hOqSnaCnp7vDgKqoi4+HgouIh5SEiPuDkYKIlZGLno+CmaKiur2wn5yJhov8jo7w4vL5xrDO3oP0h4CMkpeppJmPjI2J4viB9uTmipmVnZqWj4qLhpqnnZKml5OBiqepsZ6F/P2D8/qQj4iLkoqMioeKl4n39P78gaatrrKspqShpaetrLKXi5+jgKmgu8jY1NWuj5ONoJ6UpZ+UjpGalqWiqKChmpGRpbSakZOFhYiRh4SLioSBkJmakI2PiYeKlJGcnZmZmJCTub7G0OLi2M3DxsW0rLjBqd3/lKGbipGVmZqznZOKgfDx+fHo4vb76OPO1viQo6GmtKqkm6qelpWPjZOXkZGXjIyTgJKZl4f1/ISAh+fs5vfj4NPEvL29t7+zr6220L2wxriupKawvM2XqbbCwtnXx62iwbajoZWunpWcq7rH2bvAwLSopbO6uNXFuMC7ysm5srPP2ujc4OTh5OTN0si2sKKrusa5v8vAzOXbzNCpmqTp7uzs9MjOwb6jt8fPz8W1kpfegOjNqqi2yeLg0MjZ8vDs8PDq3NjhhYyVlZuSmZ2GiPyHgfjbuKrj7ID9hf3n1sHT1OTW1Mq6u7+wzd7Wz9HYzMHF1MfXvsvTs7W7vM+ztMTMs7m+w6yVrqW/t6GXpb7EtIn9kqK9qJiQhOuM4NeMsMnRvc/Wu7apm6TAvZ2pv9LUgLfAu5ahs597n5qiur+7zdC7sZipnKvOr6GrnammmZOap6XFvbCtrrmyyLiykYuIiZSQjZOLeI+3rJielYx/kbe9v5ubmaWaxa+xwXV1fYF/gG64bW5yarvHuqrMxbunramuubLDvLe9yNBqcG1rbsHDvcrLyMGsrbO9trTDvrCpgLe9zcK9yr7BzNJwbXBzatBucmxqz2rJaXRwac7Fa2vLv2ptc8vLv8OwvsDGsaiqqrKgr62ZoLS2tMLFxL3DtaSdtam1rcvKxsu/xL/DuLC6nYyMlpSMjZqyl4KKhJeIlJyilouPkJGVsaafp7iwoImfoYyhl5uLkIZ+hoqbnJSWgJ2cp6WYmqijp7emj5aRf42SlpydpoKWi3qij5KllqGLjI2Tq5mHpZipqpWGobO5vrquo5aWl5iqrqfGvrWeqLbCpZ6Mn5q9vrisgo+ZrqmWpXu6iH6di5aId5yXgKBppIy3oo2dsa/KtWxrvmprs7rIZW91bHV1cXZxdnl1c4HUgG5seYWEfm6Ck4Vwj5uXpKywtKWtt7GYjX14gHNtx2q9bHFpcG66gYiGfHd7pJGwsJuWnqOWvbLBtbSrrrzCobCitp/p38J6mJCZgJJ4zXV6g4mYlJWQdIHRhtTH0+DIdPG7zMJz08bTw9l6ceZ9foeMgG7jctvgfdqIg4uLjZyigI+Od39zb3hydYFxd9ZzgW5+hYF8jX52iI+PnZuWi4RydHncfnnQy9zhsKHAxXTUeHF5fYKSj4R8e3x6w91y2sTHeYJ/iYWAfHd4dIWQiX6Rg4JxdpKQmol34Odz1dyBfXZ6gnl6d3d6hnna2+fid5admp6XlJSQkpWZm6OGfZeRgJaNqLC9uLmZfoN9jo+ClY6EgIGJhpOQlY2PiYGCk6GJg4V1d3iBdXR4eHRxgIiIgICDeHh6gX+JioWFh36Ao6WrtcHBu7WsrKqcmKGqk8LdgYuFdX2AgoOYhXx3bc7R183HxdTXxsSwtdF4iYSHkoiDe4h+endzcXd7dHR5cXN5gHd9em/J0mxqcr3Ev869vq+knKChmaGYl5ahtqKXqaCZkJGXoraDkp6qp768rZWKpp2MjICaiH+Gkp6qup2mo5mQjJigmbSknKSfrKmbl5awucW7vsK9vb6rrKWXlIqRnqedoq6iq8S5qq6MgI3Oy8bByaSrn56Hm6WrqpyQeX+9gMOsjIyZrb65q6a3y8bDyMjBtbbBb3F5eHx2fX9tcM9vac21mY/CxmjObc++s6C3sb2xsqicoaOQprm2r7C2q6Kqt6m6oa62mZ2hobaZnauymqKkqJSCmpConYyGk6msmnfjgY6mkoF7dNR/ycJ9nK60obC3np6ThoymoYOPoK+vgJKYlHuIloNpgn2Im56ap6iXk4KOhZKsk4iRh4+NhX2Ej4ujnJKOkJiTppmSenVyc3t5d3p0ZXiZkIKHgHdte5egn4F9foeBo5OWoWFgZ2toaFuaWFVZVZqjnpCrqaKRkpGUnJiln5yip69XXVxaWp6koKysqaOTlJifmpeooZaQgJ2iraWjrKGjrLFdXV1eV6hcYVhWr1enVl5dV6ieVVelnFdYWqqpoqGUnZ+llpGSkJaLlI+AhpiemZ+koJ2hmYuGl5Cclqunp62gpqOkn5egiHp7gYB7eoiahXN3cn93gISLgnh5ent/lIqFjJmWh3SJi3uLg4R6fXdvdHiDhYCBgIWFjo2FiI6MkpqLe4N/cn+FiIyNk3iDe26NgISThox6fH2Ck4Z7j4SQm4Z5jZigpqGXjoSFiIeSlpatpZ+OlaKnkY1+iYeempmQcX2DlYyGkG+zeHGGen14boaFcY5WiHibjH2JlZSjl1lZoVhXmZupVl1gXGJhXGFgZ2VhX2uvgF9ebG9xbWBxfWxeen54iY+Qi3+Fi4JuaGJhZlxXoFaZUVpXW1yjdHZycWprjoOfmomLkJGGn5afmZ6cm6mtjZqQoYrY07pwi4SMeIh2xG9ueHmFgoJ+YXLCesO6w8q8bNqzvrZqxrnIusxvbNFydHl/d2jRbNPTcsp5en59gI6RgISFbnJraW5naHVqa8drd2xxd3h2gHVtfoSDj46Lfn1ua3DSdHPIvcvRqpyutWnGbGlwcHF/fXhybW5uuMVmxbO2a3R0fHh0b2traXiBe3OEeXhoboaDi31u0dFrw852dnJ1eW9vb3FxeW/Pztndb4qSjZCNiIyJjpKTkJV8dIWEgImAl6Cup6eKdHd0hYR6i4V6enyEe4iEh4GDf3h7iZB9en1vbXF3bW9sbGtpd4B+dnR5cG1udHR7fXd5e3FzkJKXoaipp5+bmpeQiZSdibLJc3x3a3Fxb2yBcWpmX7S1vLGrrLe4qqmanbJmcW1wdWtmYmpiYF5dW11gXFxfWltfgF9iYFekrFZWV5acm6SZmo2IgoWFgIZ/gICHmIqEkYiEfoGGjpl1gYyVkqOglIJ6jIZ3eXKCeHB3foiToIqPiYJ9eoSKhZWLhYuKlJCCfYGaoKWgoqKio56Sj4p/fXd9hZCGjZKKkaKajY50bXitraSanomNhYJzf4uLh3x1aHGkgKqRdnR/jZeSioeSoZ6hop+blJehXVtfX2JfYmBYWadXUqKOfXufolGiU56UjYSVj5aUlomDhoZ3iJeXj5GUjYWMmZCZiZSZg4eKiZeGipiah4uNjoF0iYCWin52g5WXiWzMdn+PfnBvaLttuLJthpKVgZKXg4N8dHaJhnB2g4yNy36HfwF+hH+TfoV/m36FfwF+hH8Dfn9+hH8Jfn5/f35+f39//36vfgF9i34Bf4p+CH9/fn9/fn5+jn8Bfp1/A35/foV/nn6DfYd+AX2KfgJ9foV9AX6EfQF+hX0Dfn59hn4GfX59fX59k34BfZV+A31+foh9An59jH4GfX1+fX19mH4FfX1+fX2MfoR94n6Nf41+mn8Ffn5/f3//fox+in8Dfn9/hn4Df35/t34BfYd+BH1+fX2TfgICBACAws/L3OLwwJaetLDIz/Xi2dzd0M7K2d/IvMHCyLigs8S62tfT39nh0KmmmbG/ssGomZSTwr22pqCnusK+tK3H0su00+vX0M3x4c7LurGZqrjO7oCA0snF4OPay8rK2t3hxb7V+vHbytXO3fLr4tnhzdXN08/F2NzV0+3aybnJ3uSA2u/a2OfrgPfv+IKAg4aD9vXp6vn08vP58/Lw4/mDhoiB7vz9+fv77/Tw2ODBzdXt5+fu9PuDhOri5+3h6+Ln1tbW18rJ5url7+3g5dzr3LbCs8W5vKqPk6OP/ZyhssLLwam9ur+vrMjt3+bTu7TmlKjExK2n1eTa39G4weDRyr6AtMXVup2XnJ3y4u3fhv6Ki5vIr7OiuJqUqqb0maizuLCzy824squou8C+wM/a7+rWsrfQ5da71czJ4ebd1buws9nQoce+sM2h0d7Rys3Zq7Kbi4u6xbawnIKUx7vMvbDAm62tt7fb7LvI9PeCif/6jZCA+vyRlqyrpoiI7pCli4CAg/Hw4sna1uqL8PSPpaq+scrV1c/i3sPCraaiiIv+94GH94CbleW6p5aVh9Kvxvj2hOyGnpX3jsTZ6PSE4djZ+N+biOeLn7m6qLO3qp6lkoyooJ6T6JWjlZ2ajYHt2IrkqI2ZxMK7u+zr2OOBh4D25fOFjJqVhf3yk5qZmISFh6SAloiJ7/aG7PTu5/Dpg5+Z+oKWlpGDh/nu+OL1+I+bioKGjv+LnrCskIOhh4eF+/v7k4aI/O6Bh4+Jho+E9Pf5kJCLjYyP/YWLj5OYhYSbk/+FjoeMoZOAoKShoZ+Zq52DlZWmjv7u74mK842hq6KzsrKmrbnBubG+trK4nJeZnpuAk5ehsLO1uKuxv7KsrqGqqKympqWWmp+RjJCQi5WhpKXFr9PIz8Gglf6DjJKG9YycrLeXi5qppaGimrWwl5ustsGuqrG2wLuys6+ywtbWzOLo29HT4fLp2vHIwr++urXBwM/nioqE8vCIkJeGj6imspmPhoSHiYiKk42bmoqKiIKAg5KK8dz/+fbm7ffu58XExbqdjLLky8W8x7uqztPa0dDEwsLCx9vUv7mpma+mwKunoaagr5isrrm4naaojIibp5mxp66m27qwtaCqm7fI4Ofg1MPS2szj7tDCv7zExMjD2M60t8Dl5bzBzsKytNHT0dDOyrCwvq/A0ub6hezI0eiAgPT139zrgoH+997Y4tv0g4mEiYSEhfzk5oqN/4KAgvLj4vTb5uuE6OTz/vbo1drUx8XA0sbAxrivtMzJtbKessivuMTEsKe3qq+0p6SsrKy6v8u4s7zQr6KcipeXucS3rqmzuL+10r6Io72jrIi+0MPIwcvjwMTIv6iiutLIxcOAo6upuL3LoH2FmZSts9C+ura8r6+ot7ylm6KiqJuFlKeburOtta25rI6NfpGflKCPg315pZyZjIWOnaKfl5GrsayUsce0r6/Qv6+uoZuGmJ6vy2tssaymvsO8raysub3EpqG008m1prWtu87Hvba+rbSts7Oltbmzr8e2q5yqu8CAuc+7uMXFa87Kz29rbG9ryszFwM/JysnNycbFusxrbW9ov8/Nzc/OwcXEt8Ciqq/Evr7Gyc9sbsO9wsW8xsHBs7W2t6upw8W8xsS8wbnGu5unmamdpJV/gY1934iLmaatoY6enaOXkKTEtL2unZrKgo+oppONuMG2v7Oapb6xrKCAk6SznoaBhYjTxtPFdt94eYmwmJ2Oo4qClZXXhpSdoZiara6dl5WRoqakprG7zMe6naC0xLmhua2ks7q4uqSTk7CxjK6lkLKEqLWqqay6kpiFfXqep5yTjHZ+pp6spZSsiZean5u3yZmkwsJmbMzNcnRny811dIuKiHBzxnKHcmWAaMXFtaKxq7t0xsp0g4aXjJ2mp6OtqpSViIB/a3DMxmhwzW2HfcWmlo6Og8muw/bfetx2joDZeaK2vM5vv7W0yLiGd8uAkKWmkJ2gl4iXhX6TiIWIy36QgYuIeG/Vw37UpIyVtrKktNnPxM9ze3HbydJzeoF/dOHPgoGDhnBxeJSAgXV4z9N20d3R09naeZGH4XF/gYBzeNbP2MXY3H2DdXR7geR+k56Zf3SOdXZ02d7agHR32cpvdXt2c31x1tzXfn98e3p+2nN3e3+DdXSJgt50fHV4kopykJGMkI2GmIxygoOTfuPT04J914CRnJCem52PlKmuo52pnp2ojIWGi4mAgYqNmJydnpSdp5uYmo6XlJmTlJOCiY+DfYCBfISPkJKxmL2xtquKhdxze4J1136KmaOEeYeVkIyOhp6bhoeWoKiVkpugqaSdnJmaq727ssnOwbW3xNPSvNKtqKaopZuopLK/c3Vvysdyen5ud4qHkHlxbGtvb25veXF+fHBwbWuAa3Vxw7TVzcu9w9DFwqakp6GIepzEraahqp2RtbW7sLOop6ilp722paCRg5mPqJSPiY+ImYGTlZ6ehI+PdneHk4GYjJWNu5uTnYiUgZ+qvsK8sqSyuq7DyqumoaCkpKmlua6XnqPFxZ2kr6OXmLCxraytqJKXpZOlscDPcMSlrsOAbMzNt7XDa2rTzbi0vrHHbHJscGpsbs24vnN10WppbMS4us21w8Ruvb3I0cq+sbezqKmjtamiqJuVma6qmpeFmKmUnairl5CekZaYkJCXlpaipa6dnaS2lo2He4eEo6ufmJKboaact6V2kKaNmHaltKatpq3FpKeroY+JnrOsqKWAhoyLmJ2mhWhxf3+Tl6mdnJaalJCPnZ+KgomJjX9xfIiBmJKLkoyYjXVzZ3iDeoZ5bmligICCdG91hIeCfnqPlY99laaal5iwppWUjId2hYmYsV1bmI+Kn6eik5WWnaCljYeWsKWTi5mQnLCmnJmgkZmVmpuLl56amauclYeRn6KAorSenKSkWqipqlhXWF1aqKenpqymrKqrqKSjoatZXF1Xn7CurK2uoqinnqCKjJGknZylqa5aXaKfo6OcpaCjnJqdnJGQqKuiqKejpp+qpIiNgo2IjoNzc3pwyXh6hpCWinuEiI2De4ihl6CXiYy+cnyQkoJ9namepZiGj6CXlIqAgIucjHhzc3a/tcOxZ8xrbXqYiIiAkX11hIbKdoKIi4SGlZaJgoWDjpGPkZihsbCljo6dqaGMnZaRn6OkopGHhJmVgpSNh5h6k5qQjpeegoV4d3CGjIeAe2pzjYiUjYSReomHh4WapoWQpZ9WW66vYWFYrrFgY3Fzcl5gq2VvXFSAU6KomJGYlKBgqrBgam57dHt/fnqDfmtrY2BiVlWhoFZesGB2bK2Qgn9/ecKuwOPTctNwgHbNcZSiqbtkr6ieq6V7bbxyhZWWh5WUjYGOfnWGeHZ9v3F7cnx8cGXBtnTOp5SWrquirczCvsNpcW3VwsRobXR1a9bFdHN2e2Zka4WAfXFzx8lsxce9w8zKboF+1WVwdHBobc7Dy7rEynJ8cGxvddZxgpCLdmp+aGppwsfGc2hpxLplaW1qaG9lvsbIcXBvbm5wxmpqbXN3amZ3csppcmtyhHtqhIaBf4B8iYJufHqEc9XMynVzzHqHj4aXkJCFiZiemJKVko6PfXx9gH10dnl/io2Nj4aMmZCIi4OIio+JiIh6foZ6dnZ3dHuChIigjamipZp+ec1obnZvzHWBjZF2bniHhIGAeYuKe3yGjZKDgYiNlZGLi4aImamno7e9tKmqtsC2p7aalZWVkIqTjZiiX2NfrKlfZmddZHJucV1ZVlWEWYBfW2dkW1hXV1dcWp2XrKWimZ2ln56KiIqEdG2Eno6Lh41/fJiZoJaZkZCQjJCmnpCKfnOCfpB/eXR4dIFxf4KIhnF4eWdpdX9zgneAe5mDfYJ0e3KJlqCgm5KLmJySo6iTjImKjo2Rj56Vg4WOqKWHjJSKf4SWlY+Njop7gIl9ioCXpbNgpoqTpVmnqJWWo1ZVqaWUj5mNn1dcV1dSVVWekJ1cW6ZUVVWZkJSjlKGiVpiWoKadk5KYlIqLipaQioyAfYGPin97bn6Me4OMjoJ6hn+Cg35+hIOEjo6VhYeRnYB8dm93do+XjYV+hY6QhpqQaX+Oe4Bpj5eMko+Zp4yMjQiFdnKElZCLidJ+gn+yfgR/fn5+hX+OfoR/lH6Cf6N+AX2TfgF9mX6EfQJ+fYx+AX3Qfgl/f35+f39/fn6HfwF+hX+HfgN/fn6Sfwh+fn9/fn9/f4Z+hX0Gfn1+fn59hX4Bf4d+AX2QfgF9h34DfX1+jH0Gfn5+fX19hX6CfYt+A319foZ9BH5+fn2GfoZ9hn4BfYp+CH19fX5+fn19h36DfYZ+AX2JfgF9lH4GfX19fn59vn4BfYR+AX21fgV/f39+fpt/+H4Bf4R+AX+FfoJ/h36Hfwl+fn5/f35/f3+HfgF/2X4CAgQAgMa/6Pf+gci+1eLZy+Tu8cLv8NXP2sK9xtPz6sPv7cy+wbmwnbO2wsCppJ6nsLHFt5+Mkr7L1vLW17itr7WxutLn+IXzweCA+OSKku3shP3a3vLc6OHj8Pn38eXy8/+GhYb/5u/59erk6fOB8uT8+ODQ1NPM0sfTy8G9yOnq8e3mgN3V3+De28zh79vM2uHS1d7h79vH0NLs8uno3urg7uft8erp6unh6Obh4+Th1djl4tnXxc3XvsW1v9vr8tvp4+D949jh2+rp99rMtZuOio2KiYiimbKRkZSHjqnWyMnas6y7usne0La5srygmLqkpI2RsLuty9LUx7Glt5uZqqWhgLLAvqyeo7esjIaRn5qvn8XCxdCcmImQopaYnqGOosGroqWprsjBu9fLtcPh2dLb27W+3OXg1cvf3My7wcvFrcbb6tXPtLjKrsPRv7DMs6DN1KOwvKyAjIGiq+nYkfeqwqXhkurgttLs+ImOjIru14eB8ouJnY+bnpKHm6qqrKKMgILoyJS2lpSS1/HC2eTpmZuoury81tjNyLijkPzyhvqTl4aFjJLom6iAmZnKkaKSjIGxqbe3lMXmkp+x1LiE4oaPh5iSoqy3yL+0s62flZuemKOho5GWh4KKl5mhlPX4gejptK/Jxbu1uNTtgf6K8ueFgILwiYaI28nzhoCN6/eAgOmA983J94X4hvv09PDv2+aK8f+hoqCYidSBm6Cok5OdpbCooKGtm4yEhvSMj4yF5vaJ74+I6oKHgoTxgJikm5iVoaKqm4iLnJqvx6+oo66or7fAtqeSjJehp7aRlZOIjpeInZSKjKKzqsTeybDM07GgnpmNlqqpopOHkJymo6ydgJmeo52Rk5ObhYqXhY2cn6vD0cjWzbOjpKCrqaKWl4aEiJ2grrOqppaPoJymmJajnKyamY+UkZyqpKCelau4wcSxn4WG9PD4hI2SjJamj4eEnKi92vTt/ub06Orz8c/s4dK9wc7e+enj5fOE6/eG7Ovb29P174ahnoWBioSIh4aGgIuI+PTwgfXH0dDY2NfDucK8zMLDtL3M0My/u768x9TGz7u8wcfTz8XYysTYxLSupa2doa+crJicoZSFiJ+RjIymr7q+xqmYrre00cvO1ubh1OHXytLh5OHBt8TR0sbBw7rDybnH29ayuKemsbHZ2sXS4/bYwK27yKPFx+LbwMHZgN7p+9Xx383M5uz69OHj94SPj4fs5fqA+IWG6dDX9vfs+oD26uvs/+ri3NjV1OLz7M3Qw7CppsHJs6jVzMrDrqehs8DSwNPz0cSwur2vqpSUl6TS0q2osLLBw7Oai5uxmZ+htszousK5pI2gzujKu8fh3end9d3Qx8rZtqihuaLIgKafwsvQbaihtL24qsDIy6LHxK2qsqCcpa/IxqHGxKmfoZ6Vg5iZo6KOjIiKj5KmloN0eZ2or8yytZ2QkpeSnq7Bzm7Lob9t0cByeMLAasy0u8+6w7q8yM3Mx73Jx9Rxb27SvcfOyL+/xNBtzb7TzrirsK2psae1rKOhpMHEx8TBgLqyubm5tKm8x7Oms7WssLi5xLOjrK7Cx8O/tMG3w73DycG8v8C4wLy6u7u+srXBurK1qau0oaiZobfJzLjEvr7XwbW+ucTD0ryvnoh8eXx4eXiQh56AgYJ1e5G2qqy9mpOfn6q7sJeckZ2IgJyNjnl8lZ+WrbW3qpaMoYaEk4+IgJelopSIjp6Te3V/i4WXiaylqbOIiHuAjoWGjpF+jamVjIyQla2morivnabAurW6v52ku8K9say4sq2cm6OplaSvwrGtmJeplZusoY6nm4eotoySnZZ0hXOSkcHEhNuYqZjXfcO+m7G+xG1wb3DCrmxowW9tfnF6fXdteoeHiYR0gGq6p36jhXZ4sNWptb/De3uEkpeVp6ihm46BdM/FctF3fXByeHu+g3lahoOog56Hg3mwpbKykLXGgoyXs594ynR9eIaDkZWfp52bmY+HgIeHgZCLkHx/cm93hISLgOLjcc/fsKm8x7iuqcXYdOB92cp3dHbYend6zLnWcXB+0d50gMx14bez23LgeN7d4NfRwcx7096Ti46GeLl3iJGWgIWNj5mVjIuXh3p1eNJ8fXpzxNZ40X91zHJ1cXPRb4WOhYJ9jIqVh3d4hYSVrpaRjZeRl52pn5GAeoKMlJ9/gYB3fIV1iYF5eY2jlq7Ltpmzup6Ni4d9hZqVj4B2f4mSjpiIgIeKkox/g4OLeH6Mdn6OjJasu6+9t6GOlY6YlpCGhXV1e42Om56Vk4Z+jYiSiIWRi52Ih32FgIuWkI+Pg5aiqqyYi3R109LcdX+JfYiWgXt6jpmqv9jP4cjYysnQ0rLLwraioau52cPBv8xvxc5wxMS1ta3NxGyDf21rdGtxcG1ugHJvy8nHasmisa+0srWlm6SfraWml6CwsqygnKOfqbSosaCjo6q2sKe7rae5p52WjpWJjJmGlYKHioB2dIl8eHmSl6GhqpCBl56ct62ttMjAsr+0qLXCwr6inKe1tamho5ymqZynureTm4uLmJS2t6Owu8+zno+cq4mlpsC4nJu1gLnC1LDKtqurxsnSyLi8ym14dm3AvtBsz3Bzw660zc3CzmrKwsfC07++t7Sxsb7Jw6uxppWPiqOtmo+3raiklZGKmaO2pbPSsqWUoaSVkn+BhIuysJGQlpaorJyFeImbhoqMoLHKnqmgjnqJr8Wpn6q/ucW5z7uuqKq3mpKKooqrgI2GoKSqWZKLl5yWjZ+mpoekn5CRl4mEi5SnpIekoYyDhoV8b3+AiIV0dXFydnqIe3FjY4CKkKmWlIB3eXt0gpGhrFqpiqJbsKJbX56dV6iWm62eo5qbpaenpJ2oprFfW1qrmaOqpJueprJdr52rqJOOko2Kk4uYk4eIiaKkpaKigJ+YmpialYuZopGGjpKLj5KVpJSEj4+ao6eck5ybopqhqqGanaKdpJ+an56im5ignJaYjpKWio+FiJmrrZ+opqa6pZqfmaOjsaSaj3pyb25raWp9eIl0dXVrbn2ckJOjh4KIipOgmYKIfoZ4coR7e2ptgYyElJ+hlYN7iXd0gnx2gIOPjoJ3fImAbmdveHeEfZGOj5l6enF0fXZ3gINzfZGBeHh+gZWRjZ+aipCmoZ2gpoqPn6OhmJWWlZeLjpCSho6VoZeUgoKPho2SiH2Kg3qRln6EioZqc2qDgaakdM6LkonNc6OjjZqgqltcXFqinl1YqVxcaWFmZ2VcZWpsbWZagFaeim2Jc2NomK2TmZ+xamptcnVygYV9cmliWqKgXq1ha2Jka2ukeW1MfH2VdYl3enaxqri7mrTEe4GEpJV1y292b316hYWJlIyMiIJ8c3l4eIOAiXZ1a2luenp/edfUbsbSqqe5yL+tp73LbtV1zbxsbHHNcnB1x7bKa2pyxM1pgMBs07Kow2rNcNPU087ItbpwwceAfoF8dLNreoKKe3mAgY2Lg4SOfnFsbsFxcm9ptMRrvW1qwGltaGq/YnV+dnZxe3yHfGtsdXOClYOCfYaDhpCYkIR1cXmCho90d3ZvdXtrenRvc4WSi6K4ooyjq5KCgH5xeY+JgXhudHyEgot+gHx+hIBzeHd+cHB+cnR+gI6bp5ypo46Ch4SJhoN7fGxscICDi5GJhXpyfnyFfXuDfYh+fXR3c36IhH5/dIWSmZqHe2tqwsDLbHR3cX2JenV1hI6cscS6xbPAtLK4uJ6yqp6LiZOcsaOhoKpbqK9do6CWk4+knFdmZFlYXlhbW1dXgFpZqKWkVZ+Gj4+SkZOHf4iEjoiJeoGQk46Df4eFj5iPlImMjJGZl5KelY+bjYaCe353eIJ0f3F0dWtkZnVqaGp/hYuIjHpwgISHnZGTmKuilp+akJqmqKCLiJKamY6Hh4WPkYOPoJl/g3Z2fX2WmImSm6mVhXmFkHeJjKCZgoGRgJeerJSjlpCOp6usopiXn1lfXVaXmKlZqltanIuToqCaolSinaCeqZqak5KQkpykm4qRi392dIiQhHyWj4mEenhyf4qWipetlIl/iY6Df3Jzc3mVkHp6e4CNj4N0a3eFdHh6h5uvipOJeGl2k6SNh5GhnaOerJqPi42Ygnt2h3aPhX4Bf7x+DH9+fn5/fn5/f35+f5B+g3+JfgF//37zfgV9fn5+fYd+hH8Ffn5/f36Pf41+jX8Efn5/foZ/BH5+fn+Ifod9hn4BfZ5+A319fot9F359fn19fn5+fX5+fn19fX5+fn19fn1+hH0Dfn1+h30Dfn19hX4BfZF+AX2Efgd9fX59fn59hH4Bff9+in6DfaN+BH9+fn+Hfo1/BH5+fn//fop+hH8Hfn5+f35/f4d+AX/efgICBACAzc/E3vjz1c3W0M3EzM24rqnJxNnFkrfhwbm6283NpZ2IqbizqamwwMPKsrWwqqm3v7avpePv5NTOzsSuucK6xeOA38LK34T+6N3Wu77lgJuJjYn99Pby8/KMiPnp9IL2+f/i7ILv7v30//Xi1uDu+/Po7t/h3MzU6fH3gfzn7YGAg4D88ejvgoT289PS2ujx9OTg3dvo6OTk3+Tf4/fr8Ozx9/LH193c4dbMyNnl5eDFxbazu8HF1tnT6d7j4ePnw6+spam7tbunmri1rpespKCNlJ+MgYiYo6e11NjNqJ+yrqe4w6+/t8Xe2sW7zc61s6yOmZmntaWHqbKPkZ3IoKCAm7u2q8jhxtLGvbS0ma6iuL7V0rq5xMCzk6q0pK+816+5wZ6ps7DF37K7y93CwcG/17rHtMnWzuPIrs/Oxt734eGA1MPEwMbKy8LRoZ2mpbfOxLCdhoafoM/lvq2qnISzzMXSs5iBu+PY8YaXkuvk/O7+gJCJkZibjY+enJKRipSA9bKawqWdpbi+2/z0g+n+i7G3tc7r+vXiwqeMh4yGhIOfkoT99s3A37WthNO+vs+gpqunjOPhg/aEiID7kPCGjZidhpyJosnNudHAtLiplKiqnpCNl5KW/NyDkpmdk+L65ZmP+fzttZuusMvX2L7K1/DvgvDY1+PF0dLZ0NPtg4mAi5GHmZCShZKXp6i0t5+AhPGGh+3S/fDqhIeEjaaojYyTo6CA+IX9+efSiIz3gfaYnJuumJyfmKa4mIiFk5+chYmYnaquoJ63rqe4vcTEwLW81smxpqi6vqa1nIiMmpm1v6iunZiZpbe6ztbr89jY1LG1ysjN3M27qLGqsay2sZiAnp21tLG7x8i5prevmKKkmI2cmKSguMrHt6qjkJWSjpy5oYmIiY6UlZiVmJmer5SapaSwsq+voJyYk52TiouYq5yLj4uFhpKGjIj5iI6SrszVzKmwssHK0N/j583Hw9XZ393a4M7CoJWbxOHv/vT4hJeaoKCgm5qViof43+Xh4+eA8+rX1+7z8unStLi7vLTCwL3Hv8bDp77ZyLu5wrnCxMLEx7a5xc7Oxs7YxtnDm565pqOblZOpwMvNtrW4xs28ucy+xb7Qyd3LusjCy9/Wwszj4Nm7xLnG09TM0te7vr/Fyt3z/Ni6wLTW6d7O0tvPz93fy8y5qKm1u9Hc6+Ls/euAjPTX5fT63t7N7v7vhYDp7YCCgfXp3Ofb39bm8fTw4tXe4eHt6dXe0MLKxLnDy+z20MCrp6/Ot7CMn8nDwdLAws7Vz9rAx8O3uLjBuLWgkZeDmcu8uMvIvKi5r6OhosnS3LepwdW3u8/Nw7TM5uHn17W2tbewuKCWp9P44M2wrK2AsbGnudTPs662r6unq6mZko6rpbqmfJ2/pJ6et6eui4Vzj5qXj4uSoaWpk5eUj4+XnpiSisHKvK6rrKKRmqSepb5uvKKptG/XwriznaDAaYBwdG/LxcfFw8d0ccy8yW3Mz9W6xW3HxdTN18u7s73Fz8a9xLu9uqmwv8fLa86+w2wUbWrSy8HHbm/Myq6ttMHGy725t7SEvoC9v7W1xr7DwcnMyaKytrS6tquktr+8u6WrmJeeoaW2tq6/ub26vsipl5SRk6Oco5KIoJ2WgpKJiHqCinpydoSIjZuztK+SipuWkZ+pl6eeqL26qZ2urpuclHuFhJGcjXSXmn5/h66NjoWgm5Kpv6i0p6KcnoaYi5+jtLShn6ilmoCBlJuPmaK7lZ2mi5OamKm/mKOsvKiqpaS4nqyarbavwq6TrK+lucy8smq8oqmksKasorKQh4+QmKmokIl5eoqJrMShlJeSdJazrL6ljXmfvbPBanl3wLjIv9ZlcW1ydnlwcnl5cnRwes+UgKqKg4eanLrNxG3F2XCPk5CguMS+sICWg3F1enF1c4N7cNrRsqnCc3VpqKShsY+UmZSB0c966Xh5ceSL6Xx/h4t4jHiMo6SWq52dno+Bj5GKfHmCgIjnzn6JhpKK2OvSjIbn69y2ma2ovcbIsrjC1Nhz1cfFzrm6v8zAwdN0eYGFeI+Ag3SDhZqTn56LcnnUdHfWutnJzIBxc3Z8k5Z9e4CQkHLfddzYybZ6etZw1IaHhZmCiIuEkJ6CdHKAjIhxdYSJlZaKh52UjZugpqelmZ+5rpmPkKCmjp2Jd3qHhaGrlJqIhoaRoaCzutLVu7y6mJuxq7HAsqOUnJKXlKCchYyJo6CbpLGypJGknIaQkYd+jIaQjqe0roCglZR/hoN+iqqQd3l5foKFhoGEh4ubgYiSkZ6bmJiNiYeCiIB3eYaXiHt/fXZ2hHZ7eN15goObuL21k5yerLG2xcfLsK2ru7zEwLrDr6SHgISovsjYy9BtfnyDgoN9fHlybs26wsHCwsrCsbDGysi+sZidnaCYp6ShrKGop42huYCon56knaSkp6Wqm56pr6+lrbSluKaFiaONi4aBgpOmqq+bm56qs6GdsKKporGrwK6crKiturKkq8K9t5umn6q1ta2ytZqeoaeqvM3SspeflbLDuquvt6qsuLqmrZ+NjpqgsrjHvsXTwnnOscHL0Le8qcrUw25qv8RsbGvLvrK7tWi6ssDDx8a7sLa7ucXDsLmto6qkm6WqxM2sopCQlbGalHeJq6Sit6Ghq7Kuu6Ksp5ucmaKamomBhnOHtKSgsa6kkaKWjY2OsLK8nZKnvJ2jtLGmnK3CusK1mZyanJWei4KRs9K5q5SSlYCUk4yZsK6ZkpqTjoqPi3x3eY+MnI1rhaCMhoeYjI93cGJ4gn95cHiBhYt+gHx6eX+Be3Z0n6WYjYqMhnuCi4aLnVuhi42ZXLail5KEiaVZaF1gW6agop6coV5bopelWqmrsZumW6Wgr625rZ+ZnaGnnpmgnKCdjJCcpalZqJ2jW4BZU6ijnaJcWqanjo+WnKCnnJqXkpmanJ2gnpOOmZOcnaaqqoqUl5aZmI+Ll5ydno2RgoCFhYmbmJKcnKKhpK+Tg4N/gY2IiHt4h4qCc390d2xxd2tnanV3fIWXnJmBeIeEgYyWhpCLk6GgkYiXmImJgm92cn6HfGmEiXFweZiBeoB1iYR+kKKUmZGOiIl4hn6MkZudko6Ukop2gYZ+hoydgoeQeoCFgo+ghYyTnZGSjIuaiZKDjZiWpJV/kZKOnaiallSdj5KRmZORjJB6en+AiI+Ng3pwbXd2l6aLiIuHb4ucm6CWhHWRopyiVmFfpJ2lpLZYXVpeYGFcXmJfV15eY4Ckd2uXfHFwfYKbqaJdqrhfcnR0gJCSj4FtXlddZ2BkY3JrZLqyk5S4W19Xi4yNnICDiod2xclz33Fzb+CE33R3fX9ugXKDko+ElYqLjH5xfX98c3B0c3vavXN7e4iGzN3Nhn7d3tW1nKmjtL3GsLC1zNFw0sK6xba6usS6vMxuc4B5f3SBdnlud3qJho2PfmhsxmluzLTIwcFpaWx0h4hyc3iEg2nKa8jHuKhsbshmxXh9fIh3foF6hZB1a2lyfntnaXZ7hIZ7dYmDe4mMk5SSiZClnIuChZOXhJJ+bXF9fZSchol9fX6IkpOkpbTAraypjIudmJ2poJKEiIKFg4+Jd4B8fJSQj5SdoJiGk4t8hIR6doB6g4KWoZ+ThYN3e3x2fpaEbm5vdHl7e3Z1en2KdHuChI+MiYZ8e3lzenJrb3uKfHJ0c25uem9xbs1vdXqOoquniY6OmJyir7GxnJ2apqmwqqGnlox0bnSNoamyrbFaZWRqamdiYV5bWaiYnp+en4Cimo6Qn6GgmpKChYOEgYiEg4qCiYh2hJSKhYSFhoqLjIuNhIeRlpWNkpWOm4tzd4h2dnJucYSRj5SEiIqTmIqFlYyOipWVn5KHkJCVm5WKk6OdmYWMiZOam5SXmIGDiY6RorCxkn2DfpOinZKTlIqQlpWIjIN3eIGKlpuoo6qxpYBiqZWep6eVmYykqp1WU5uhWVZWo5eLk5WYkpiZm5qVj5GSk52dj5aLhIeCfYWJnaKNhHh4fo+BemV0j4mGkoWCh4+RmYaOjIWDgIV/fnRxdmh5m5CMmJmQgYh/eHh6k5abhH2OnIeMmJOJgpGfm6CVfoOBg36Ccmx7m7Gaj317f8F+AX+EfgF/h36Ff4Z+Bn9/fn5+f4V+AX+Wfgd/fn5+f39/hH6Cf/9+un4Bf6h+g3+Ffo5/jH4Df35+lH+EfgF9jH4KfX1+fX5+fn1+fZl+gn2FfgV9fX1+fo99AX6LfZJ+A31+foV9jH4CfX6EfQV+fn1+ff9+nH4BfaR+i3//fod+AX+Lfgd/f35+f39/7X4CAgQAgLzErbC1ooGbpLjFycfIsbG6vb+5p62z4cO+ysfg5MGssbjR5eCxxsOpw8/Ttq+xw7Welq/T2fv/9/Xz69zKwNbUzsXIwNbQw+OCg4by7P2EifXd193m8OuB5M/F+YeUlPz/9+jV3tri2tbb8fb04O/y+vXz9YGCg4Dp+PP5+fHsgPTx6OfX0u7q+Pfu9+3bz9ju59LNw8rSy9nc4cnQxszO2+XyhYD+gejk6eTUwtPbzNjg6OLc2++Fg4OB6s7EwbO0q9LAwb2vsr/Jvaiur6KJo4yWjqCqrriywLO1uaixt5Syo6apv6/Vwbmxoa21vNnW5+XZxauwsaSNpKu2sa7SgNfF0cq5ztnHoYyYqajPpsG8tbu0t6Sfv6GWvLSrvb++xMe9wL+zqcesn727t5egqMLYyLq8wMffvc+9wcfP0NvNxK210M/40ZCfwdbXv6+ku8aeoMbM17ukybCnotXJvZGJxeiZw7+vy4L+49bk7YLx6YH7+/GLpa+cnKausK2XgJH47cS5sNvX4dLk5777kJ65x8nS9fT87riZhfaTprGUl4yH9fHs0Kr93b/N1rO+vKOL4+PS64mJo5GE3ODCgfeivqOXo6ajqLPHuaScpKmipq6kga6uqJWIrKuUkqHDo4yQhuiF9Oe5xfTg1MrY5sXKusrU9fbz1+bR9oaKioGJgIHRxLvZkfzvkpWXmZCIjfv9j5b/iZKRg/2A29+GgPLr/++Fi5q3sI2MhoWessSzw8u9prX/lZeYmJ6hl5qeoZ+ysqGWoZedo6WhlJafmay/xcSvr83o1764vty1qrOmoLC9vaWwrrWzxd3CyLiboaCxraydrr7NyMW9yMvFtaakgKGhnqWqt7u2vLrAvMzTx7nAvLCxq6q4r7fDtrKupamtqaWgo6CdmKu/nKSXo5ehm5ufl+yQi5KNiI+Um6WXg/jygPrz+YCCgfrv5fz4iI+MioaepLazl4eNw7yZqr2st8zdxcjM3tvWta3F0+n2m66eio2lp6yYifWAgviDjZCUgIH2g/r978jX5t/Qx77H2M3Av7vNytG4zseqvb24sLaytbKspKO3yce2q66ulJSxubevq6+rqri3ur7OzrS8v8DF2Nbp7/rl1tnl7NfT08W1xNa309vazri8u7S8v87S2+f/7d/k79TL59rexcva4tXJ1+/mysvOxL3KxNzny9rtgPb57v+NkJiVhoKA7/P+6fX29I+YjIqGgvPwgpWTheXU5fOC8fXy48u4xcvCz9fCzbOqwq+an5qel7DNxdTPwNDe9/Xc4tHO0c/R2u3Xs5qRhaO6u8q1zKqTorO7ub/H0d3g0a22uZOOsaiqlqO70uDVwLarv7K+uZ2s0MLhsry8gJ+nkJGXiGuCipqlqKaolpWcoKKcjpeWvaOfrKG8v6COlZquwr2QpKSOo6uzmJKXp5qFfJG1ttLWzMzLxbipobi1r6Wto7a0pL1qa3DMxdFrcMi1s7vByMJtvqulz3B6ec7T0MW0u7jCu7W3zc7MucTJ0crLy2tramm8y8XQz8jFgMvJwsS0rMTEzszCzMO0rLLIwbCroqevqbW4uaawo6mrt77EbGnQaL64wL+xoK+4qrW8wMC5t8Zuamxsxq+op56flbakp6SZnKOvpJCXmJB3knyEe4qSlZ6ZqJmcoJKcoYOdjo+Sppa2pp+YjZmboLu0xsC4rJaZmY15jZOempWxgLajsauZp7mqjH2FlJO2j6Wel6KeoY+KpoiBp52Uo6Shp6ujpqKakK2Wi6ShnoOLkKK3qZ6goqbApLGfqKuurbOpo4+RsK3MuICDoby2p5SLl6eKiKSsuJ6JtZ6bjLmurIV4qNaPra6cqGrUt7DHyWzSv2jT1sBvgIx6eICEioh2gHfPzKWika6uuKq8xaHSdn6Sn6CmwsDFu5F7a8d6iZF6f3Vzys7KsZzKgnecs5Wgo415zdDB13R2k395zMm2eNmQn4t/i4uJi5SjnIyCh46HkJWQdp2bnYN3l5qFhoixk4CCe9SA7OO2xOfWycLN2b7AqLi+3dvb0N3I6Ht9hHN/gHvCsqrBgNvPgoCBgn16fOfnhoXge4KFd+Jzxc54cdTO5dN1eYahm3x8dXSImqqZqLCjjpzag4KCgIiMgoSIjIiZmomBi4KEiouIfH6Hf5GlpqeVlbDGtqOeosCelJ6Ripekp5Ccm6Obq8OnrKGFjIuYl5iJl6a0r6ujsLKqnZCPgI6Pi5KUn6Ofo6Goo7W9r6OqpZuel5Wjm6OqnJqWkJOXk5CLj4yMhpiri5OFkIaSiomNhs+BfIR9d3yCipSGcdzZcuHa33R1c+Dc0urefH9+fnqQlKSjiHuAsKaFlq2Zn7XArK2wv727mZSqr8TPgpSCcXGEhYx7cMtqbMxtdnd5gGnObtLSyKmvvbuxp6GquK2loputqLOZtaqOo6Cdk52XnZiUjIucraaYj5WVfoGam5uWkpOQkp+bnqKsrpWfoaSpu7jJyc/BtLS+xLS0s6aXpbWbtbm1rpufmpaeoaytuMDWw7m7yLGrxLO5pKy4v7KmtcrFrrGxpKCtqL7Kq7vMgM3NxtV1d318bm1sxcfRv8rLx3Z9cm9tacbHbHx4bLyuv8ZqxMrGu6eap6mfqrSjr5eQp5WCiIWLhJq1p7WsobC6zMm2vK+wsrGyuMu7nYd+dpGhnqycr5KAjJednKCnsLy+sZWeo4B7mpGUgY2gsru1pZ2UpZemoYiVs6HClKSigISJd3l8cl1vdICJi4yOfnuEiIiDeoCCoIyIkYacnYd5f4KRopx5h4l7iI+Re3l/jIJwaHmXmq+ypKOnoZiOipqWlo2TipqYippVVFqpoqtaWaOVmJuiqKFYno2Mq1tiYamwrqiYmZegm5edq6qml6GmraeoqFhXVVWZpaKsqqWhgKOkoKCSi6Cgp6Wdo5yTjZanoZOPhoeOjJSVlIqVipCTmZqgWVasVZyYoaOSiJSek5mbn6KcmaVaV1xdrZmUlo2JgpWMjY6EhomSjYCFhYFqgHB0bnh/gYmJk4iJjIKLkHaJfX+DkoaekImFfoeGiqCbp6Sak4OHiH5sfISLhoOYgJuPmpaCi6CUgHB3hoSbf42Igo+MjoF5j3x0kod/io6LkJSPjoqFfpODe4yKind6e4eZkoqKiY2mkpOHjJGSlJWSinyDl5SjlnN5kKCYkYN9hot4epCTkol8nImMf5yVmH52mLSEnZiNl1ewo56qqVmroliztaRbZm5hYGVlZ2ZegFqdnIR5dIeJk46cpY+yX2VzfHyFm5eai2RXT6ZpdHtobWVjuLi0oI+zYFeAmoWJjn9wvMG6xm1sh3Vwxsiscc+BkoN1eHt5fX+Kh351eHp5fIODbY2MjHZuh45/fn+diHh7dsx529Css9rNxsPJzre2pa+3zM/VydTE3HR1c2t4gHa/rqOzdtbBdHN1eXNxdNXRdXvRb3Z5bdZsurhvasfDzMBsbnuTjHByamd4iZmOmZuRgIrIdHV0cnp+dXZ5fn2Ki3xzfHN2fH13bnB2cYCPkpSDg5uvopKPlKuOhoqCfouTloSPkZaOnK2Ym5F6fHuEg4N7hpGdmJWSnZyWjoSCgH5+foSFjZGOk5KVk56onZOXk4uPjYqUi5GdjIuIgoSKiIaChICBe4ubfoR2gX2AfX5/er9ycnZwam51f4h4Z8jFaM7L021ua9HJwdjPcXRyc26Ch5OWf3d3oZV7hpeNlaOsmpycpqWhhn6NkKKvandqW1hkaGxgWqVUVqVXYGBhgFitWq2rpI6OmZiQiYaLlo+Fgn+OipCAkYt7ioeBe4OAgoB9d3aFkYyAeX19bG+FhIN/fHt8fYaEhYmPj36HiImOnJ6opqeflpeeoZWXl4t/i5iFmpyYkoSFgH6FiI+Pl6GvoJ2copSTopeYjJCanpOMmqijkpmXjYePi5ylkJyrgKmqrLhiZGhnW1lYoqGjmKGhn1xiW1dWU56iWGJeVZaNmZ5Um5+ak4d+hIiBiZSFjoB8iHttcXF4c4KUjJSNhI+XpJ+OlI+TlpSUnqufinZvaYGNiJKFkntqdH2DgIKIkJmclYCHi3FshX1+b3qJlJyZjYd/jIGLiXV/lougfoiIyX4If39/fn5+f3+HfgF/hH6Df5V+hH+qfgR/f35/kH6Ef/9+r34Bf4V+B39+fn9+fn6Lf41+jX8Bfod/hX4BfYl+hH2FfgV9fX1+faN+An1+ln2GfoR9A359fYd+BX19fn59hH4GfX59fX5+hH2SfgF9/n4BfYt+CX19fn19fX5+foV9oX6KfwR+f39+hX8Cfn//foJ+h3+HfoZ/gn6Ef4R+AX/dfgICBACAkaG5nbitrrK7s7fYu8HAqsGzmYSMkZuXrr7EqLzW2cmgk4+10M62q5q+zPSC/evnxMi1kPOAtNnVzszhx77C6fHqvcXCvLfAwb/CwsTFw73L3uLYy7e40uvUz+2DgeXd2MrOys7Y19nR3Nvf58zM4svP09Tdz8fO0u/o4ebp8fOA/IGJgPLn6eTo++bj6vf55tnRxMrXy8Pf39HEuLnHz9nZ2tfW5vDq5vLkzbS2vcPZ2eLl0sTAvsWurauvwLqtu7WHhJi1qraKhqKvv6qWlJyQlJSamZytpamjqKmptbC6u66dsbjAwr+5wdu/2tnDr9e+xbbLuMDWr6az3c2/zsWAx7Wnu7vTzb6eiJegn6iYua+SkbCxu9Kzmp2rrrezwsm5u6qVl6GnlpSfvMvPqrG9sJ62ysrAtbW1ydPG2uLX3tLLxMzh3ujSs7HC28C2s8nLr8u63MGzqKzT57K2u7jHs7jF29fYvcPhkoHn7f6J8OyGooqIkZqdlO2WnKWqpL+AvsDO08Gc6+Dx+ICDg5aarc/I0dTc5vry0pDrhaCikYn98/T/9vjN+7iOmNerqpmWhPX2lKKDiKaWpZSTn56Rh5qb+YKdkpKct8TFvaSyr7a90qWsosS0s763zLqep6Cmo5Crj42cj5OG/4TS5+n3h73Uxb3vjv3u796ryomzq5+Amo73v77Zz8rEgf3uhICLpJKDjor4jpWbpK+ViOz48IaP7v6G+IaSl56A//n+iJWjmKO/rKiB6u39ip+tqqObnqWpoKabnZqMi4mPm6Kenq6ro6mnwczMwc7AraqjmJWkuLazv7/LzsPM0MLHu8e4oZezv7mpsKCZq7u4v6mqo6aAr7C1q6mXkJmao5mPm6SqtMqxoKWpq7i6sK2jqqSRi5mosrCqnKSyrryssKmhi5GWoJ2lpZmypp6NjoTw7O+D4eHd6Pfq9+nf3/WCnaCrlYuCi4qcop+fr521oJKcnZSRm4mDrKOrxcHEutzV1eiMiZOboquompWGi477g4aLi4aAgoGC5/r9g4iU+Nze5+Ll1OLw3tDDzcOyvby4oaqpl6O2o5OVnZuQo5+uoaeknZOVu7GolamVp6a6yMTR493WwMvizsrOzMCsp8raz8/Iu625xc7S09vN1dbM0d/o29Tk7+7b4+Xc6evk2tfu9vnu8fDu7e/WtcDn6/z36fj2+Y2AiubpgI6KhfuF/9Pl3ISSjIWGlIuA9IKB/4SChf73/PTmz/Dw6Nrg49ezv9XIxMTP07/GuqqtvrSzv9u9oJnD0dTqgI/qzujm3s7Ny8OjkKaQh6zBqaimopuxusGzyMTA0sGci5m1xrK+oaq4pK23q5uWm8HFrra5zrukp5+pi5OAfo6fg5+SlJecmJe4nJ6gjaWXgHF5f4iBlaGkjZ+yt6qJf3ucs6+bkYCgrc1s0cLFoquaes9ul7u1srDEq6KjxcvEnqinoJykpqOppaSmpZ6ruru0qpibr8SwrMlwbsG5t6ywrbC0tLSuubm7x6ytwKqvsbG8r6qurcnDvcPCyMuA02tyasrAv77C08C9ws3OvrOwoKe1q6G6u7GlmZikp7G0tbOyvMnDwc7BrZmanqOytr3BtKampKiUlZKWpqCPoaF3dIiflqR7dY2XppaFg4uCh4OGhYmXkpWQk5ORnJedoJmLnJ+lqKafpLyiubmol7WeqJqwoaW4lZCavbChsKeAsJ2RpKKzsKWLeoWMiZKBoZmCfpaUnbObh4mWlZyZpK2eoZKAg4qPgX2HnamvkJeiloSarKmjnJqXpayktbi2t6uoqam3tLu3n5yhtqigmKaxk7ObtJ+XkJW0y5acoJuxoKGowba2oqK0dmu9zM90x8BthHNvdXt/eMB4e4SDf5KAlZShq5yAwrzM2Gtvb3p+jKafpKettsK9o3G8aYCDc2/JyMnYysy78KpiVaWUl4KGd+Tlj593fZ2Mkn+DkJGCfYuM4HCGe3eEmaemno6dlZ2hwoqSiKubmKegtKGEkYqhj3+df32Jf4d763nJ1NDphLLLsrDdgdrb8tWkvn2gmpCAi3vcr7fSyby3dd/Od216kH91f3vZfIOGj5uEec/f1XmDz+R323aChItw5NvcdoGNhI6mlJJyzdDadomYkouFiY2SiY6Fh4d5d3N5hYyIiZaQi5KPqK6wo7Ook5SNhYKNoZ2bqaKotKmvs6esobCkjIOepJ+Sm4uFlaKhp5KVjpGAmpqflZOGfoeHkoaAjZKWnbGbi5CTlqOjmZeNlox/eoaUnZqVipGcmKSUm5WQe4GFkIySkYWck4t9fnbZ1th4yszK1OPS4tXOzOF2j46dg3tzfXqNkY6On42kjIGLioJ/i3l0mY6Wrqmvor2ys8F2cHl9gomGfHhtcXPKa21yc2+AbWxtwNHRbW96zba7wbrAqbvNvLCmraGVoqCbiZOSf46binx/iIZ5joaUh46JhX1+n5WOgZF/ko6gqKWuvbayn6q8qqutq6CPi6u3sLCsopOhqq+0s7qstLWtsb7Etq+9xsS1vby0w8S9urLGy9HJzsnGxcm2mqXGydfRv83LzXWAcru/anRxbcps07DBtm13cWxtenJpx2to0WxpbM/J0Ma9rMfEvbG6urOTnK+ioqOus6GmnZCUpZmbpb+jiIGnsrPJa3jCqcS/uq2traSMfJF7dJWojo6Pi4SaoKiZqaiktqaIeoahr5unipCgjJWhk4aAhaWpkZmesKKKkImTeICAbHiJcoV7fX6Bfn+YgIODdYV6aV9mbXNtgIiJeYeYmY50b2yIm5WDe2+IlKtZqp+hhIx/Z7Vhg6GZmJakkYmJpaafgYuOiYaMjY2QjIqLjIWPmZiVjoGGlKKSjqheXKKYmZOVkJKUlZWQmpqdqpKSoI+SlZSelpKUlKumoKajq6uAr1lfWaeem5qgsKSgo6ionZiUhIiUioSWmJKIfHmFio+SlZeUm6alpK6ikoWDg4aTmZ6imY2OjI5+gHyEk459jIxrZ3iKhIxsaHiBjoR2dX14e3V4eHuFg4aCgH99iIaHi4h/hoeOlZOKj6KOn6GRhpuJj4aXjY+fhIGFopqPmJKAmYqDj46cmo96b3Z9e4F0i4Z2cn+AiZiEd3mDg4aGkJSJiX1xc3d7b2xyh5CVfoGJfnCBj5GLhIOCjJGKmJuYmI+OkJOYmJeXhYSNlY6JhImRf5aKm46Kf4egrYiQj4mWhYqToZ+gkJWlX1Wbqq5ep6Vbal1aX2BnY6dhYGdmYXGAdHV9gXVhnKiws1hcWmVoeIJ2eX+Gi5KSelKNUF5mXl2mrKeto6qd4KBOOYiAg3Z8cNPVf41ydI1/iHp6iIp8doGE2ml1b2p1iJGVlH+KgoiJp4CEeZqMhZSRpJmAhoCLgneRd3R+eHxw13PBy8jee6u7rKjJd9jS386itXKTkIaAh3fWq6/CwLuxbM7CbGlzh3RrdHLHb3V3gI16ccPQyHB1vc9uyWx3fINozsrIaXJ8eIKXh4FnwbzEbH2JiIJ6fYCFfH95enpubGhseIB8fYmEgYKAlp2bkZ2VhoV/eHV+joyMlJGXopmeoJSbk5qPfneQlZCFi397h5KRloWHhIaAjIyPhoV7dHp7g3p1f4WJj5yKfICFh5GTioqBh35xb3qFkI6IfYWNiZOFjIqBb3B3goCHgneKgX9yc2vJx8hsur69xNLH0si/wtVwgoGJd3FqcnGDg4GEkYSWg3p+fXd0gnJri4OImJCYiqGVlKFiXWBkaGxnYFpVV1qkV1hdXVuAWltao62uWlpepJabn52djJmklY+Ji4N9hYSBdXt4bHaBdGptdHJsenR8cnd0b2twiH53cHtvenqKjo6SmZSQho2bjo6PjIR5d4+alpaRioCKkpaYmZ6VmZqSk52fkpGcoKCWnJ2WoqSbmZWkp6uoq6ekpaeYhpCprrawoqemql6AWpeZVltZWKVXqpSfmVhcWFVWXlhRnlVSolNSVaSipZ2Yjp2ZlY6Tk4x3fIl9gISOk4iHhHx/i4CEiZuGc2+KlZWiV1+ejJuVl5CPj4h1aXZnYXyLeXh3c3CAho2CjY+Ll4t1aXaLlYWNd3yHeIGKfnJscIqJdn+Fkod1enh+anCsfgF/h34Bfad+gn+jfoN//37mfgh/f35+fn9+foh/AX6Mf4R+kH8BfoV/h34EfX1+f4Z+gn2PfgF9pn4CfX6EfQF+hX0BfoZ9hn6HfQN+fX2IfgF9h34JfX19fn59fX59hX6DfYl+g33/fgd+fn59fX1+i32kfox/AX6IfwZ+fn5/f3/2fgR/f35+hH8Cfn+Efoh/B35/f35/f3+mfoJ/vH4CAgQAgJuqv7y3mJqMhvj4i5ykoJKWmYH4hvDG6ouHtrykp8PNuLHQ5cC5w9LA9+bD4dqC4efX1NzK28vDvcfPyMDKx8fBz8LT4ODRwce1uKeur8u/0t/Y2ueBiO/uh5GHgfHR0LvB2uTJ2c/Fvay4zdPn2tfTxbrAtLjMwb7Tt5+lmbO/gMfBxuTdzMO4ucbO2+bv+4aNh+7j2M3K4OTe4vDq4+3b283NzNTNvbbEzdfc1MjNwsXZ4djY4NW+s7uxmaP1gY+Hi4qam4+Tn7DK06qlpqqfjJukqbKzv8K7sa+9rruuqqqmtcK8q7Omutje8M/bz8qzv7i0ub3E1cjLvrXByt/NgMfKu7jB3NvX0NLNnrS8p6O2lrDNxMe1sq6Pqby/zuHfu8m1vNO3psPNyO/t2u7i4p6p4u/U4vaCgezgyr/G0cqexLqso7q61YKG4uTfzaO+yMfW05als8G5npugsKGl1tbL5oDcgfOA9feE/oyfi9jW9pOXiYiHlYaGnaiqorfHgL3A2NrQuImFlrLBwdLQv76+usTW2Ofz7Lv+jKjcovTYg4uUivnjtYyLmc7cvZygv7Ssrpefq7S2sYyEhZHigomYjouYnqynpLSwp6/JvNbgm6urqaqRk569uqaxubesyPTF27HA2uW9oZCXnIvoh5iK+vja8LDxzOrfwtL31cTegOjQ0uzsz+j7/uz1hPiH8O3f09X48uTs/YWVmo74/4eam6iliYj/hYaSlqCXi4edo7KgkJukl4yKgoOJo56TkpGTkJeSlayzpJOenp6xt7OptLyoq7DCwL20rKauqqWtopujn5mGlKa4ra+/vbu0p66praGfp6u0rrXAw6+xvqulgLall6KrlouE/Y6bs5+Yj5Cit6CYnaCepbO1qp+hoqujo6atq6+dkYyLkpGOoqCPlp2cpImA9dbU1ePj4+7ng/uP+fSAg4eDgPPkkfP+mYeBgfmik5aKjKKyt6GZp9DRz7vCwdPM1sa1xOPr7eHI+JCUj5akkpKRloqC/oWFgevwgO2Cgvj17O32h4Pn49PCuLO1spmou76xrKearK6boqiTp5ucqaK5tri5qqGgt6uanJumv66us6+9xdrb4r+/yMjPuayut82/trvHvbWvv7W2qrG10sPR3tjl5NvO5PLo+Irw+/by5fPy3NjHydfm8u7r7Ne7pMDT5vb938vj8ImUgIj3g/Xs1en6gIqdkIeF/oqC94qSh4D2hfb77dfc5/rw/uvz6PDl9OvkzsnTz9jQ3drr5c7MzuPNw8rDrc+/x9no9+fF0rfb3tLc4srDvbHGrZqapau6k7O/rrSq0Mq/pquio4uPvMe9ub3G1dvNvamzpq7KxKe4x9zSw7ecjpyPgIeTpqGegYZ4ctPceIWOin6CgnDcddSx0X10oKSNjaaumZWywqKepbOi0b+evrZuvcS0rriouaynoaiwpqCppqqgq6GvvL2voqqXnIyWlKufsbu1tsBsc8bFcHlwbcyzs6ClucKpu7CmoZWesbXEubeyqJujmJitoZuxnIqSg5ylgKymq8W+tKyhoqqvuMPJ0HB1b8i9t6qlu8C4uMTEv8m5t6+vqq+toJWkrbS6tKuxoqa3wbe5wrekmqCYf4PceIN7f36LioCCjpipuJSSkpWOfYePk5qYpaqkmpmmlqSYlJOPnqehlJuQoLm7zLC8srCaop+coKCpuK2tpJ2nrr6wgKyxp6GnvL+8s7ayi5+mko+hgpeupqqbmpl5kZ6ercDAorGborefjaaro8XFt87DwoWQvcixvcpsa8e+ppumsq6EoZ+SiJqVq2ltwsS1ro6jq6GssYOWm6ajjo2Nm4+NsrWoumqzbchszsluz2x7cL22yXN8bnVugHBtfoeKf5ObgJaXp6qnmXRvfJWenKqrn5mbmJ2rrLS4t5PMdomwhNCyb3N6c868o4N/fqG7o4qJpZ+Zo42SnqWkm394eIjZeHqNgH6KiJaRkqCdkpq2mrO+h5mVj5GCgoqkn5GXn6OWsdKpxpeot8aikoSQkX3Te4Z64+LM5bLbwubKs8XgwbHGgM2/wdbSutHf5NXded151dXIubre18nP3nOCiH7Y33eNiJWUe3jedHSCg42EeXSJjJyLfYaNg3h4cXN5kIl/fn6AfYR+gJeekX6HiYmWnJqPmaKOkpano6KblZGZlY+VjoeOi4V0f4+flJamo6KdkpeVmIuJkpWemqCpq5mZpZaRgKWVh5GXhnpz4H+Kn4yGfX+QpY6FjIyLlKGgl42Mj5iQj5KampyKgHx8g4N9j5B8hY2KkXl04sTAwtHT0tzVeeaB491xdXt1dd/TiuHokX10deKWg4d+fZCdoo+Ikrm4t6Sopbexva6eqsXHyMGo0XZ5cnaCc3V1e3Br029wacDIgMZra8zKw8jLcGzBwrKgmpialoGOn6GWkY+CkpWDiJF5joCCjoafm52dkYiGnpCDhIKOpJGQmJOkq725vp6iqKWumpCWnbCimZ+poJyQoZuckZeYt6Ovu7S/v7Stv8vC0XPHzszNwMzOt7WlqLbAx8bFxrWdh6Oyws7Vuqi/yHJ6gG/Hbs/FsMLNanF+dG5tznFpxm50a2nIbcrQw7O5wNHDzsDMwMi+yb28qaivp7OrtrPCvKirr8CtoqankbChqbjC0cWms5i6uK65wKejoJirk4SEjpGhfpykl5yUtrCljpWMkHh9pauinqKptbmtpY6akZWro4qcq72ypZyEeIZ7gHZ/j4yJcXJlYLfAaXR7dm5xb2G7ZbicuG5qiIl2eYuOf36ToIiFjJSEqZyGn5pan6SXj5WLmpCKiY6RiISMi46BioOSnp2Rh46Ag3h/fo6GlJqXlJ1ZX6imX2VfXrCcmYaMnKGSoJeMiIKKlpmhnJyYioGLgX6NhoCUh3Z/dYySgJWQl6ulnZeLjJKUmqKpsFxfW6ebloyNnKGZmJ+joqaalJWXj5KRin6JkpaZlY+TiIybqJyepJyLgomEcHHIbHdvcXF6fHZ1fYOTnoSEg4SAcHh+gYeFkZaTiYmQho6EgIKCjZSPhImAjqCgrpujnJeFjIuLjY6UnJmYkIuTm6KagJmclI2Soqqlm56df46RgH2NdoSUkJaLhoRte4aIlaWmjZqMj5yMfo2Pi6Wmnq+no3V8n6aaoqxbWameiYOOmpRyiId/d4J8kllZoqOXk36KkImQjHKCh42MgYCAhnmAmZeSoVecWahYqqRXq1tjW5yeql5gXGFcZltbaG5rZHB6gHl7hImEeWBfan+Be4iIgHp5eXyFg4iJinGeU2KDZqWTWF9jW6eglHZsaoegk397kYyFlIWKj5eUkHhxbX3Nb3SBenV8f4eDiZKPh4abhpqke5CJgoR6eX6Tk4GFipGMpMGesouZp7SXh3eBg3XKcn522NzEzJXMvN3KsbrVvbK+gMS2vMrJt8fR1sbMcNR1zMS8r6/Jxrq6yWp2enTMzmx7fYiJcW3Lamt1d4J3b2t6fol+cnZ9dGtraWhsf3t1dXV2dnx2doqShnR9f3yFjIqCiY+Bg4eVlJOMhYCJhH6CfXmCfnpqcn+NhYWTlJSPhIeGin16gIaMi5SbnY2OlIeDgJKHfYSLe25q13eCj4GAdXSFmIJ7gYSBho+TiYB/gop/gIWMiot9dHFwdnd1gIBzeX58gnBnzLSxssTJyNHLcNZ10ctqbnFxbdHJftPaf3Btbc6Ad3txcoWPk4J9h6SnqJeVkZydqJyQl6qrraWRrV5gWltgVFlaX1lWqVZYU5uggKJUVaWloKOnWlegoZSGgICAem12g4R9eXdue31vcndnd2xud3ODgoWEd3FyhHpxcnB5i3t7gnyJkKGfnIOHi4iOgHyAhpSKgIKLh4R+iIOCeoCBmYuQmpefnZaSoKmnsF6op6epoaipmpaIipegpaSioZN/dYuUo62smI2cqF1ggFijWKegkJ6lVVphWlVVolZTm1NUUlKeVKChlo6WnqacoJafnJ+aoJeVioaKhYyIjI+cloyOkZuLhYmGeY6FjZqhqZ+Kkn+Xk5CbnYmEgn6IeG1sdXiEbH+HfYN/mZWKen11d2hti5CIhYmOl5qSiXqCen6MiXWFkZ2Vh4BwaHFriX6CfYh+BX1+fX19ln4Bf6Z+BH9/fn6Ef7J+g3+rfgF9+X6Cf49+gn+Zfg9/fn9+f35+f35/f39+fn6nfwF+hH+CfoR/mX4Bfa9+BH1+fn6EfQF+lX0Dfn1+in2EfoJ9h34BfeJ+AX2sfol9BX59fn19hX4FfX1+fX2EfgF9nX6Lfwl+f39/fn5+f3+FfoJ/1n4Bf51+BX9/f35/hX6GfwR+f39+hH8Cfn/ofgICBACAsrzFwJGgtJuRtcCJjo2zrZyRnqCim7K0oKGlmaSnloSFjp2tnKiHgbrBv97TxNnQrr3Du+HqxbG6uruqrbKyuMLa2ejy5urmxMu6zcKxueL5/ubV0+nc2+bK0Mi/wce/wdHNwrasr6uzx8LT4OnY4t3Hv7LG3dHh2/jnuaeckpKAk6CR5PmbnKzJ3ca6xr7CycW5xMjQzMG+yM7OztLT3+vc3+jm3tje4d3p0s27sa2upqu5ucTDnZ+jtJ+km56qsbyzsLK5tcLBx6+SkIuZnJ+an6yusbq7vaG6w7q5pJ6uzMm+2/PhztPm2crFusbX18W1uby9ycbO4sTAxLy9lcGA2dbKvszG0r7LyrzRyKKgpbKhn6GbkZywvLa90M3Mzs7J0cS7rLXLw7jE0Njy4OHr2+nq1+bh3ejrhoHK1Kmem62zxdb32+Hh4cfQ5bq8ws7WrpGMpqmuwL6wu8mwv7PJws3M5PeEheXziYqBiJOUnqOjq5SToJuTnaqon7DM4NKAy9PJ1MikjK22wdHt5Ni/sdXi2snh9fLduImIg5OdlIyGiIKAgvDnztTU1vH12MrS1OHRy73gvbjSvZaYiZSImZebrNvj4MWyutTCsKvI7vLg0b/A1rWqpMrBv8vQ5cvUz7mw5ebv/uPQ4tSsuL6tk72nqqSuxs+W66CLh/Xg9YOA0rrl1cTX197s8+rb94uMif7OwNT6/oaF/PiHp6yelKOGjoSFl5SUpJyRmK+snoeZn4GGk5qfn5KUjJymkZCapru3paaaoaOwqpGJgv2YmJmVmpulrKaMgIOEhoD/ipCYnKqxlIb1gYuPkpKRm5efl4j69vjv8oOPo5+gp7GvqK2AqKSxubKmp62vuMjLzNKzpJ+hnqyup62zurmukoqRnJuamJOYkI6K9oiPj5OWnpSclpaWq6m9trjGuqiov8nHvrGtnZn28oP5+oWnsaWksLawp6GpsLaah/mDlKemppKopbW9w83J3NHO2OPo09Da4OTLztH3i4eHhvmH/YWNg4iAiIb22+SA7urh0bS8tZyTl6HMw7O1tMO7pa+eoJ2kkI+Ul6unnquzvLWkq6Grs768tKywqr7AxLvAuqypqLCwvrGUkaCjuba5t8nLxLasrr7Lva3H4uLh69jn5ebt6+vv6tnW3NnS1Oz9hPHo4IH9iPzXvMixvdPN1OD13cO8yuuAz8rZ8fqE+/iGiPaIgPb8gIOUlImJg/75gIOA8v3y6fLl74X+/YDb9P/tgILv59rz5uLh6dDB5OHWwMW9wbLD1NzohoPc5Nz7ytDL0+n39MeptcC9ucmytp6cwcW+rr67nqu+2dfU2MzIsrCSwbHE2ti30dDAtret2ePIosX739CAmKOppHuLnoV8m6Z0e3eblYl/homLg5yciImOf4yPgHJ2eoSUhpR0bp6gocCyo7OvkJ6onr/Hppegnp6QlpmVnKG2s8PIwMPCpK6br6OVnsPU1sC0ssm6rr2rtq6mp6ylpbOuqJ2UlpOWpqCywMSyvruooZOluKm7ttPDm5GIhYOAg4+F0d6Ih5Kpu6mfq5+msK2gp6mwrKOepq6vraytt8S3uLu+trK1uLXEsLCfmZWYj5CeoqysjIuOnIySjYuVnKSbm5ujoKinsZuFfXiHiYuGjZWVmqOjpIugpqChjoaXsK2iutDAsbbDurCspK25ua2eoqSip6ivw6emqqKig6iAvLivpLOsuKmxsaS5so6NkZ2OjYyGf4ibopyfr66trrGrtKeilpyupZylrbTLv8DHs8DFs8PBu8LBb2ymtJKJhZWUoq/MtLu5u6qpwZ+coKi7mH97lZSRnqGYmrSaqpmoo6yqu9Jucb/LcXJpcHV3foZ/h3h2gYF2f4qIgoyfsaSAoKqgpqOLdpWUmqi7tbCakKy4sZ+0wL2slnFxaneDend1dW5sbczKtbq0ttLVvbi3r7+ztqbCoqvGpYqLfIJ4jI6Om77Axa+Zm7Olm5ayzc7EsaqyvJqQjLKpp6ywxKm2tqCcxc3U38Kww76gpaaWh62PmIuesLSI2ZiEf+bR6HqAwa/UwLDFxsrU3dHB3Hx9euO5rrzd4nh23th0k5iKg5V5gXR0hIKCkYd+hJ2YinaGjXB3gYeMin+CeYuSe32FkKOhj5CHjY+clH53cd2FhoWBhYeQlpB5cnVzdnLieoCIipadg3nccHl7f399iYWMhXjd2NvS1HN+k4+NkpqalpuAlJCdpZ2Rk5ufo7CytLmdkIyQi5iZkZmgpKGZf3qAi4uHhoOIf3992nl/foKFjoKLhIWEmpeto6KypZWTqLSyrZ2ejYzY2Xje5HiVoZSTnaOemZOZn6KJd91zhJSSlIKWkqKnrbWtwbu0wMLGs7G7u8CssazHcW9wb8xz025zam+Ab2/LtsFqxcO9r5eemYR/gomqopWZmKWciZWChoSLeHl/fpCOho+TnZaJkYaRlp6blo6TjZ6fpJ2hmo6Mi5KUpJd9fImLoJicnauvpJeRlKOtoI+pwL68xrXDwcLFw8TJxLWytbOtsMbUbsW+um3Rb82wmqiToLarsLzQuaKdqsaAq6e0y9Bv0M9xcMVtZ8fPamt4eG1uatHNaWxqxNDGvcS4w23OzWmwxs2+aGvDvbDHuru7xbGgwLqwoKWdo5WlsrjEcW24xbnUqrKwtcTOyqaPm6Wgna2YnomHqKqml6Shh5Wkt7i5vK6sl5h9qpamt7adtrCkm5qVucGpiqnavraAhIyRjGt2hXFpgopma2aDf3Ntc3h7dYSGd3V3bHV2a2BkaXB9b3plX4KHiaWZipGPeoSNhqGnjIGHhoN4foJ/g4aUlaGjm5yfjI+CjoZ+haKwr5+XlaqglqSXn5qUkJWPjJiVk4qDgX6BiYaXn6KYoJmLh3uLlYybm7SjhH13dnaAdoB6yMt1dHuNnZGJjoWPmpiNjouRjoeFjZSUkJGRmqKWlJmemZSTk5Khk5WLg4KCenuKkZiYf3p9iH2BgH6EjJCKiYWPjI6Qm4l4bmt5fXt2f4ODiY+Skn6Lj4yNgXiDlpaMn7Olmp6ppp2bkpehopeJi5CNj5GZqZmTlY6Md5KAo6Obk56XoZednJWkoIN/gYqBgX53c3yOjYmLlJeVmpiSmpKMhYmWjoSMlJmqoqSqm6GkmaWfm6GeW1mQl353dX5+hZOpl52cmY2Mm4SBg4+bhHBug3+AiYmEhpKCioSOjZeWpbJcW6evYGBbXVxfZGVmaWJhZ2dgZWtta3B7hX6AfYJ+hoFwZnt4fIeSjY2BeJKRiXiLkpOBcFZcWF9jYV5gY1pZXLGwn6WhoLS3op6fm6ihopayl5uymH+BdXtxg4KChqSqs6CMiZeQiIqcr7SumZKYo4mBepyVk5ibrJWfopCNrbm8wq2erq2QlJaLeZeEin6NnaR/zYx4d9bC1XKAvKfHs6u/uMDFysS4zHR1ctaxoqnEy2lpxcFohIqCfYVtcWhpdnZ0gnpxd4qKfWt4g2Zpdnx/f3Z5cHyDcHJ9iJeSgoN8g4WPiXVuast4eXp1d3iBhoBuam1pbGfQbnJ5f4uNdGvBZW1ucXNxfXuAfHDOycm+xGt1h4SEh46PiYuAiIaRlY+DhY2Plp+cpqmOhIKFgY+NhIiMlJSJcm5yfXt6eXd5cnFvxm90cnR3gXZ6eXt5i4qYkZGak4mHmqCfnJKSg3zLy23O0nCIj4aIkZiTjIWJj5F4bstqeIeEg3aLiJWZnKGYpZ+bpaWqnZienKGPjoqbVlRXWKZcrVdZVVqAWFiklp5UnqGbkX+Cf3JsbnSKg3x8foaAdHpsbW9zZGdsa3h2cHh6gHt2eXJ5foN/fXl7eISGioaEf3Z1dHh6hn9sbHV4iH9/go6RiH98f4yShXiNn56eopehn6KjoaCmopeWmJKNk6OuW6Odm1msWaWQgYl7hpaPk5unlomGkJ2AjIyTpataq6taWp1TTpiiVFRbW1RVU6akUlRSmaCbl5iSm1akpFOSoKWZUFKZlY6dl5mXnpCDm5WPhYaCiX+MlZmmXFeZopinjpSVmqasp4p5gYmJhY+Ag3ZzipCMgoiFdIKNm5ycnZSSgX9ukYOMlpaGl5GLgoB+mp2Nd4+1o5v/foR+gn3/frV+gn+qfgR/f35+vH/Tfgh9fn5+fX19fo19g36GfQR+fn19sn4BfY9+AX2IfgF9i36FfbF+AX2cfgV9fX59fY9+AX2cfoR/A35/foZ/BH5+fn/jfgd/fn5+f35/lX4Kf35+f39+f39+fod/BX5+f39/h34Ef35+f4R+gn+WfoJ/vH4CAgQAgLDDzcGnuNW6pfWqwp2C6+Hj2vKNn5mM4oGPoZqBnuzGuoeO59Kt5933qOTXwsTFuMW2s7LOz9DW8+Dn4tjk++7V1dDH1d3czL7A3N7m38/c9IWSguHTvMjK0ca/xcfIzODR1+Hhz8/Y1N3a4dDAyNXKnvT2j4qH9vPr2r3Xiqy0gKqhwc7Cw8rFyMW5wrmpn6S6ytPL18Pf8ef3/oOB+fjv19Lj0+vh29jPxbmvtbCwsrrHwrfDv6y4wri9wKe6q7ayr6C5uZmlrr/W4cTAubWjqbvN19Pu2fTtzseqvMHHytfRw8XR0tfay7CuxdfY9eTZ2fDLx7XAx9Pj8t3o2MbFgMGtrLCwo5i0maWsr5utqZ6Ulau0xsHA09XI0+vT3dXW98u+wMHN1snZ3dnvhvba5+Tn5trg6cDR9ePo9cehrbSxuLzb6c3j4bHJ19/VztfcxrSru/DCsLu7srCu1/e6tN3p2N78jIn2hPX1+fOEj5qitrejmbvBoqieg4qzw9TPgNzb3ce31O3bvMrW0N7jz8zd6dbM5/T159a9oIqNiIiZmYyAg+L+jeHn9PGGjYb5/v/lxtL69P66z6ivmJWxrbC47s3B39fdw8LTzb/HxL6/xM7Xy8eul563r7bArcjMxMTj1MjPvbPMytTFqr+0r8PAsMK/qr23xte7rJyEguvxgMy4/83/1MzUxrOmufSXmpWOqqiRiIP+9oCCkpWShoyZi4mMhIKQk4uA9pihpJiNi5OFh5GcmaWamJGjlo7l7d30/YaUmqiutbuspKaij4mPkpnz9ZOYmq2/y6ukmKikqrOvqbq1op2VlZWRlqKrlpyVhoiPmpidrZyUlaKvo6iigJ2jpa2VipeT/f/7jbGrrK+gnZ6qnpaVhYywxK6fp6OViYqDiYqJj5OPkpiXi4yLj5ugn5SakYmD7/H4jI+Hi5iT5OP05/eD9vHv5PH36oSXpaOdmaaqxMLFycC3uaemqJqRnrzXyNq/q8jnzvDZyMHT+PrW6uz6jJ6M/en3iYWNgIeC/unt49na6N7g1rOmvtDs1sm7r5qpn5OY9PHVucPc95OUgI6Sm6ejlIqwr7CbmaS/wrnDw8XJ1Mejo7ClqqKShoaDnsC7xsO6s6eutbSwucXB0dvNs8G7197V3djPxb+90bev1bjD1c/O3fCI+/Tn2+bQ1NLe5ID89eba4vyAgPmKifuA8oSA8/WDg/Do5vDvgoL/+ISH+vHix8fW2M7M4dPx9OT5jP35hIPm5/bu2cLm/t7b493y3MXe1c24yrSjvcLrg+/c6+HDyczSwNHJxrK7w8zS2cvNpKOhpJiqztHC7eHr+/Dn07uwucq9qcPLtqqmpL6lsK+zycjAspatgJehq6SOnbedjtSVp4Vwy8TGwdV8iod/w3B8i4VtjdKxqHuAzL6Z0sbXkMO0n6OklqOXk5GrqaywybW/u7K70seysaunsba2qp+eubrBua26zG5+b76zn6urtqujp6qprcOyucHAr6u2sbi2vrCjrLu0iNDYgXt53trVyrbOfJacgJOLpK2eoqqlqaado6CSh4ufqLCpt6S8ybvJy2lqy8/Fs6u6rMG7tLeup5uRmpWVl5umpJqqppagqp2kp5OjlJ6ZmIulpIWQlqa7w6ulop+Pl6Gvt7XNudDJsayTo6qpq7exqKWztbm7sZuXqLm408G5uMyvsJqjq7S+zbrJu62sgKmYmZ2cj4amh5OYmoealo2Fg5abq6Sks7Ortsmzv7a43LKlpqSutq26urTGcNe6wL2/wrm8wqCuz77C0auLlJuWnJy1w6e9vZKlsLyzrbO2r56WmdOul6GcmpaUstaml7fCtbHNcXTOa8jIzs9udHt/kJSIe5OahYmFcHKQnamigK+tsaOVqsC1m6SrorK1paOvuKuitb/AtqiXgnV4cHB+gHVnbLzad7/O2cxxdnHR2NbEra/Z092kwpagiIKfnJmjz7KpyLvDrqu3taWpqJ6hqrC2q6iThoqekqWolqy1qqjFsLOum5WnqLOjk6qZlaGglqmnkqWir8Cmmot0ddbdgLuq9Lztv7a/s6aXqNqFiIJ8lpOBfXbn2HJzg4N/dHuIenp7dXR/gnpx1YSMkYeAe4N2dX6KhZGGhoGUhX7K1cPa43eEh5WXnaOSi4+NfXh8f4jT0oCDh5amspOQg5OPl56YlaWfjYiBhoWDhZOahIyEdXl+iIaKmYmBg42Yj5SNgImPkZiFfImG5ebgfp6bn5uNiomYjISFdX2gtJ6NmJWFfHtzenp7goV/gomLe3x+gYuOjIOJgHh01trbfYB3e4iCy9Df1OR549/Zz9rf03eMl5KNh5KZrq6wtauhpJOSlYuCjaa/sMCnkKnFsM+6qaSzzdGwv77Jb35x0sPRc21zgG9q1MHDwre0wru+uJiLo6zFsKeakYCMgnmAycq6oa3C1nx+bXt8f4qKf3aWlJaBgoecoJiioqSlr6WHiJaJkop9cnNxjKehqKWblpCXmJiVnqqisLmul6edtLivt7KtpaCgtpyTvJmks6yruMdx0sm+tcCttLK8umnPyb63vc9qgMxycs9ow25pxspsbcW9wMrHbW3Uymxvzca3oqWytKupuqvGx7rPcs3La2y8u8nDtaPB07e3vLjNuKa+sq2crZeKoqHGbsm4xLqiqquzorOrq5igp66yuKqwi46Mj4GTs7Gmzb7H1crCsZuWoLKnkaqvnZOMjKSPl5earKikmn+XgICIjYl5hJaDdrh+jXFgrbCzqrpteHNtrWBod3Jedbmfmm9xvKqNtau9e6SUgYaGeoV6dniMiIuOoZGbmJOZqaGRkIyIj5STiYKDmJmclo+Zql5qXp+VhZCPlo+LjY6QlaiYnqWjlY6ZlZiXn5WNkqCZdrjBdXJy08/Nwa7AboGHgIB3i5KDhIqIjoyEhIR6cnWGjJCLloaYoZignlJWqKqhlYyTjZ6ZlJWSjYJ6gHt+gYONjYWSkoWKlImRk4GNgoiFhH2OjXWAg5ChqJeRjot+g4yZnZ2woa+qmZeEj5STlJ6aj4uYnKCkm4mGkZ6gt6qjpq6XmomPlJmgrKWvo5iYgJmLi5CMgX6PeIWJin6Ni4N5eISKlo6Qm5qXnqqgqKKiuZ6Sko+XnpehoJupXa2bn56hop6bm4iRqaKmrZJ6f4WAhISYoo+bnHyDjZiRjI6TkYeFja2RhImHiYmGobKPhZiblp+wX1+sWaioqrJcXWJlcHVsZnV5amxnWV91fYaCgIuIiX98ipOLfYeLgYqLgYCKi4F7iIySi3pnXFdZV1ZjbmFVWZ65Y6e0uLBjZ2O3u7qumJu8ucOVrZCQeneNi4eSuqGYsaevopmjoJCXm5KQmp+lm5qLfHuMgY+XhJqfl5eonp2hjIiYl6GWiZiOiJKRiJiWiJGQnaqWi4BrasjVgLig1azStbC0qqGUoMt4eXZyhYN0b2nTx2VlcXRwaG57b25va2t1d29mwnV+hHtycXVnanB4doN6eneIe3a8w7TN2XJ9f4qNj5OGfn9+cnBzd33Av3N2eIaTnoSCd4aDiZOOiZmVgnpxc3JzdYGKeIB4bHB1f3t/jn5ycnyIfoSAgH2ChYh8dYF+2dnQdJGLi46AgoGLgnx6bnWOm4x9hoZ4cnJrcHBxdnh0dnx9cHF0dn5/fXd8dHBsycrPdHNvcH15wcfTyNRv0MzMw9HVyHKFj42HfYWOpKOhoZqTloeGh4B5gpalmqeQfJGlmK6ckY2YqqqRmpqeVF1ZpqCpW1dcgFpWraGhoJmZn5qbmYF3iY+hkYmAeG1za2ZrrKukkpqsumlqYGlpaW9vamd9fX5xcHJ/hH+Gh4uKjIVxc3t0enVqY2RleI6Ji4eCfXuBgoF+hY6JkZiSgouHlJaTlpOPi4iLlYN+nISLl5CQmqVcraSemJ+SmJifm1SlnpuXm6VVgKdbWqVSmVZToaJWVZyWnaaeVlaooFVYpJ+ShYSMkIuHjomdn5ioWaCjVVSSkpybkYigqJWXmpiklImcl5KDjn92h4ehWKKUnJSGj4+UiJSQkYWIjpGTmI6Qdnl3eHF/l5WPq6KosqeekYF8hpWLfY6ThX16d4p7gH+DkpCMg2+AiX4BfYR+hX2EfgF9hn4FfX19fn6Gfah+g3+efgV9fX5+foZ9nn6Cf/9+kH4Bf7h+BH9/fn+Efrd/A35+f4R+g3/Qfo99iX6CfZF+AX2TfoV9kH6CfbR+g32tfoN9hn6FfQF+h32pfgZ/f39+fn6Ff5h+h33MfgF/in4Bf4Z+DX9+f39+f35/f35+f3+FfgZ/f35+f3+PfgV/fn5/f5l+AX+7fgICBACAiIy1laOyusfOt7XZsJSKjaL+8tzKxrabmpqHrKilj9Xl0t/rzMmQ9o2ppsOXtMPk8fLjwr3s8uHm6N3RyMLJ0s/U0MnGxsi3ua+vtteEkpSNkIeB4eDQvcDEycjQycrKyOHk2ejjzsvW2+rdzcC0sMrMysCuuKejo6imtL7DxMyAucrMwMG/xMjD3PbaztrKxc7d9ebe1dvs6urzgvny4tXT0M7Zw8La3uPe0MbOws3UxsiurLnBuNrOzbKlv8bHu93Wx8q/wM7M7ufLy8i7r7TFws7M0sHK0+Dbu7TKteDo9frw0snY4uHq5urg2oCA6eL18sitprrO2LetlpKrlJ+Am7SyrrG7mpy2so6lxKupuriytKy0r7K56PPu6qrK17CysNTGsMKptr716/b66dnd0/HeurXN3e/Sz8KxoK2eycWnp7ff29ry0+Tk5N/Nv8ju7dvJvbeamLzD27qamcbb3/jh0OPk4Or19/mB6/yOnKOqkoOSpae0x7a2wszOwbCAw8Pi4LXA5+zjzsHGz+Xw9vDZzOHW4/b27NfQs8CuoaaVmoSJivWDj4eEm5mJ9/+A8OHW6NG8pKqXutiyo7+/zsDDzMbNxtjI+ObOycalydrQsp+jl6e9ucXFvLSpv6y7083YxsHPzL3Ru724ube1wbXLyM3D0uDm18DLz8SmloqA5tjWybez9aSZju/UhKCWhvD7j5aHqaKHiIj75e2KiIiLgqWqk/rx9On1iYyKio2QioCCjpOetqq4k5yboaKnusGowrCGjo2Dh4H6gJSZnqainqSiqKOwr7mxr7G5tr29zLesubSqmaKbk5acopeKjq2fpKOVm42UjoD2gYWKkImAg4eQjpOuvsfGyL+ilIuUk42MhYiNnJmtqLGpqY6MhJqemaGerpmSlJaanI6RlomXhZOYmpOLh4yHhJaQhe35hYGHi4uboYiFgoiRlYWMh/X2gJKgmramg4GPj4yckJyas8HJzMe5ztvu+uni5vnk5u6Kg+7/kqCuq5uLgYGA8IaAk43s8oOA9O7m7/He3NTn5d3QrZWQmZKcoJSE85OakoyZop6orayvtZOyvcXEtsjT38i+zsu8ydrQycfU0syytr29qrPN1ePTsrjGxaypysvt1Lagr8HO4efc8uXr18rCo6Wnr7nt2d7jwMfq8f7+/+7Zt9TYys/WxbS+08jI4v+Agfv49eyA9enq1vb96eDd5drM1N7Qx9vd0t7d4Oj12MXe7PKEgfL26IT42dDe2fP38/bl9vD09dbw793Svrmluc7KvdXy9MfJ29vUytHO1uXv0MC5tLHA3+vb27emtpqNpMPp1fHt1ujo9uLC5tCgl8nWwKuxrMe2xKOdwrOnjpKAenmff42aoa2xnpy9ln13eozc2cO4tqmTlJB6mJOSfrfJucPPtbeF6oiakamGmaK+xsa8nJXAxrS5vbasp6Glq6atqqWmqq6dnpSTmbdvent0dnFuwMK2paSlqqmxq62rqsLFucXBsa25ucW8q6CYlaiqqaSWopOQkJWQm6Glpq2AnKqqoKCdnqOds8yzqbaopKm3zby3sbLExMHKbdHJvbKxqaq5pqS3uL+9s6qxpK+2qa2Xl6Cnnbyysp2Npqurn7u1q66lpLCsyMavsrCimp2rqLOstKWqsr27o5uvnMHE0NLNtay4wb/Iw8i9umxsx8HOzamWkqKyvqKbh4GYhI6Aip6bmJ6oioyinn6UrZWUoqOcnpeemJqgyM/GxpKwvZqcmLarl6qPmZ7QxNDSxLO6sc+7nJqttsaur6GUhpOEqqaNjJm8t7bKs8C7v7qzpKfIy7qtpp6JgaOlu6SHgae+vdC+sL2/ur7Hx89sw9ByfYOOemh0gYeOoZCPl6Olm5GAnpmztZGZs7e0opyfo7W+wsCroLWpscC+uKqnkJ6Qgox9hG90edJvfHJthIBy0Nhs1cG6zq2jjJiDnrmXiqCfu6mjrKm0srmp3MLFuaySuLu0lY6Rgo6fmqajoJqOo5Kdrau1paWxrqO1naCeop6bqZ6xrbOptsDJu6WvtKyShXyA1MzOwaml4JSJgNS8dY2GedThfoZ4l5J2eHrdzNB7enp9cpWWgtzW2c/Ye3t6en1/enN0fYGKoJWjg42Ij5CQoKmQq5lyfH10d3HecIOEh4+NiY6Nk5Cel6CZmJuinqeks6CUo5uShY2IgISKkYV6f56PkpGEinyCf3DXc3d8g3mAcnaBfIOgq7OysqqRhX2FhX+BeHt/i4Wbk5+Uln18doyOiI+LnoiBg4eKi3+BhnuMd4SHioJ7dn95dYaBdtHfenZ7gH2NmH55dHqFinl+etzccoSSiaGVeHF/fn2Mgo+Inqmwta6gtL3P3MvDxdnBwsZzbcbQdX6Ointxa2ppwW2AeHPDym1qyMTBxci5u7LBvraqjn15fneDiH5vz3+GfXeDjYeQlY+QlXuVn6allaSwuqiesK2dqLetp6axr6uVmaSikJmws8O1l5uqqpSPsarIsZuIl6WuvsW50cHIs6mkh42Ql5vItLnAn6bEydTQ08a1lbK2qKqzppSdsaakv9iAas3Ly8JrycLGr87UwLi6wbSosrqtpLW3rLeyuL3KsqW5w8ptaMbQv27Ns668ssbExc2/zsbKy7DKx7qxoJyNnbCsobXJzKWpuLuzqbKvtsDLraOemJemwcq6vJyQood7jqjKsMrHtMbDzsCjwq6GgKy2opCWkquZqIuIqJqTeICAa2mFbXiEipSZioWYfmxnZnW+uq+sppqIjIptiIF+cKq3o664pKJ62n2Jg5RygoqdoaGagX6fpJKXmZGJgn+DjIaOkIuOk5eDhX6Ah59fZ2lkZmFfpaebjImJj4+WkZGSk6eqoKqnmpegoKackIWDf42OjYl/i4B/fX97gYWLj5SAgouMhYaBgoOBkqSSiJGHhomUppqaj42foZ6jV6ifnZSPhY6ejYmXmqChnZSZjJObkJKGhImPiZ6cmYh+j5KSiZ6akpSPjZiWqaydnZyPiYmUlpyTmpGRmKKikYybiaSns7Oum5KepKKpp6qioFpZp6OusJSDgY6apoyFeniGeIKAf42Kio6Vfn+Oi3OBmIeIk5OKjYWJhIiKp6+qqICapIyIhZuTgo9+houupKyupZWbmKyeiYSRlqCTkoh+dn5xi4p4d4Gam5ull6Can52Wioyko5qQjId6eI6QnI17epKho6mcmKCenqClqK5YprBgaG5yZVpiaG1yfXFtcnuAe3iAfXqNinOBjYmHfn5/hI6QjI6EfouDhZGNiXdzbn52bnVpblxhZ7pibGVicm5kuL1ev6+ntKKZho55kKqNgJSQn5WZoZ2ppa6fy7WtqJ6HnqShi4ODd36KiI+Li4Z5joGLmZeikpKbm5Ggj5GNkpGRnJCfnp6YoamxppaeoJqFe3WAy8nMw7GgzYV6ccSxb4J/csbOcHdshoJsbXDPvsNxbm5xaoSIdsrBwrrAbG9vcHJ1cWpocHN5ioSPdn19goKAkJmEnYxpcXRrb2rKZ3h4e4KBgIN+g4SKhI2GhYiPio6OmYuDkoyCeHt5c3d/g3dxdYyBiIN3e3B2c2fEaG1vdnCAa25zcXWLmqWkpJiCenZ9fnVzbnB4gn6Nho6EhnFyb4OGfoB/jnx2eX18e3V4eW57b3p7fHdybXRta3l2bsnWcm5zdnWAhnd1bXN8gXR2ctLXb3+KgpKGbGp2dHWCeIN9kJicoZ2PmqKvua2mprekoqlgW6atXmZxamFbVlZWn1iAX1ygpFdUoaGfoKCWl5GZmpaLd2pkaGVucWthuW5zbWhweHR7fn57emh9h42MgIeRl4uFkZKGi5aOioyTj4p8fYaGeoSWmaCTgIeRkIB9lpCik4F1gIuTnKCaq6Omlo6Kc3d6gIanmJmdhY2kpKqqq6CVfpKXioqRiHuBj4eHnK2AVKOfopxTnZyekKWllZKWm5GLk5iOh5GRipGOkpaejImUmZ5UUqCpnVimkY+ZkZ6cnqWapaGjpJWlo5uUiYR5hZGPh5WjpImOl5yWkZmXm6Gnk4uFhIOOo6uen4R7iXRseo+omailmaSkqaGJm4xwbY2UhHh8e4+FkHl1j4R7Zm6Rfol9hX6IfQF8hH2hfod/x34Bf9F+gn/8fgN/fn63fwF+h38Dfn5/0H6HfQV+fn59fYR+gn2IfoN9iH6FfaB+AX2vfgF9wn6CfZB+gn2gfgR/f35+iX8Ifn9/f35+f3+VfgF95H4Bf4R+AX+dfgZ/f35+fn/XfgICBACAnY2HqqWgnPSRhIH+jon74eaNnKGKgZid9d3HzrymruiEhNC+6OKnjJmGkYmQkMab0dfygoDcyMrriNfk+4Lu/vnr3aWNjZ61sMfo94D/9fyHg4fpwK+zuLytqrvIzdLW29Da5+fX0NLF6YOHivbOudfmg/vlwsO0sbS1ubq2uciAz9DZ19TSvLOsuMvX6+rb3dze08LM1eff4uTu8uvl7e/t4N/m5djItru2wcrQysLDxszN0MfYz8bAyNvq59iux9LT3u3u2dbS1M3N1NW9s8fH0MvN0Njh6tK7uLm4ucnN1dzW3Nfr//rv3+jvyaSupqabi5Hw3I/QvofM3oirmJuAzciupq6nt5uXna6ph/2doLS7ta21qtbcycrOx7Gooq7UydHX1M3a6NXb3t3o4tenkJ/B0L3F39q5ttXk4MDLt5CfyNvu4MCuydLx5O7+3M7HvKqWvc3W0LKuxcfEvc7Cuc/j1tbKzdjfzej4/YOLmoKFkpqqqKaZrbC0yMTCwr+A1769tb6+1vLRwLfA09/m9uzswcLW7+/m4drAmZCUmJmdmpCEiJiEg4r3/YaHgfz+jYDz6+bItKivn5+0q5++zuPHwLevocTU1cjB7dW0vsirp7C3yLamnKKlx72wsbaup6ivxb7K2dbD18S3uZ6vta++vb675tj489vh19Lo6e+A2daoitG/wqCXs7qVlsW3op2Dmp2qs6Wao6mkj4WflaGoo6GP/Pn139TE2+nhy67W18z8gNrm+/aRjpWL/Ovp6ICFmZj/1vqD/+/r/P/f5/eKl5OA/v3364aPiY+elJKfo6unrq+onqSqm5yWnqalsrCrq4748oH79+rw7tb3hIKAgIP8jYGDiJCfm5GTnIbz/4j52cbP2M7Mv9nf34aboKOjpaWhnqqolpWQgoyOhJaTi5uaoZ2aioOA7f6CkJSWkpGRlaOriYmYlZenmaezrKast7/MvcLQwrrUvbTGyc/RsMvDwMTIwt3s6d/hg4P9gPr85ouVl665w7innIyE+oeAk4r88N/Q1djQ1OHLv7PCzcCmoqCopp2sr5mglImNlJuhop+dv8TM5+La0sa3vLKmr5Olp7bGyb3KytfSyK+jp77S1dLc4tTJwdHHxL2istPb08/GzNPRz+K5tsvdzL/Y39bU2+Dm3O3Y1+z0gfbx7Of727mmtNzn3/WAgYKEhoSAhfeIkYv967mwxvWH7+X09+zj5/bvgvzh5erl5dzl2c3E0er85uGB5uTk5enLxvX+goHq79Pf4O/pvMawyMq7qZqJjM7Z8oT97+/v7djY1Mi5n7Ossb7LwcO4raWspI+HlJjA0tPDv+3j2NXI2PXUyt3Uwc7Nz+Ha4dOzq4/xh5SAjHx3l5CKiteCdHHafHfcyct9iox3coeM3cu4vqyWm9R1drmly8uVf4x4hn+HhbCHs7POcGy7p6rFeLO+027F0dLMv4dvcYSXkafBzm3czth2cXLHo5abn6OXkqGssLi6v7K/ysu6sbSnx25wcsyrl7PAb9TEp6aZmJqZnJ2WlaSAq6+2tLGvnJiPmqq0yci4uLm7sqetscC5u73GzsnByMjJvL7CwLipm6CYoquvp6KkqK6tsKm4r6ekqrrHw7iWqrCwt8bItLa0tbCzuLmjmKqqsqutsLS9x7CfnZ+dnayvtsG5vrXF19HNvMbLqYuYkJKKfoXh0oO7pni9z3qXhYeAt7GakpmTo4qIh5mYed6LjJ6mnZWekbW5pKuvqZqVjpi4rbW4tK63xrW5urrAvrqPfYujrZ2juraamLLCv6OsmH2JqrXJvKOSqrHOwcnVt6yroJF/oa21tJaPqLKso7OmmrPItbaipbC8qbvKzmtxgW5ueX6Lg4Z7jI6Nn6CcnpaArpyYjpuYqceqnZuaqbG1w73Am5Wov722sauZeXN2fICBfnlvcoVwbXTNy21xcuDaenXUxcKsnpKbj4ubmpSsscGsqZuWirG3taiq0Lqfpa2VlJudrpyQho2PsaGYmZ2VjpGVqqCtvbulvayeoIeYnZimo6Ki0rvXz77CubXOytGAvb6Ve7urtZSNp6mFhLCgjo12iomSnZKHj5aTf3eSg4yUkpB/4ODcxr+tx9XOu57FwrjkeMTP39aBfIV849LRzXN5jYnkut105dbX4+PFzdt6hoRz4uLezXd/d32Lf4CMjZSQmJqUiZGXh42Gi5GPm5yXmn3e2XXk4NTZ2b3fdnSAc3jignV3eoCOi4OFj3re73/nybTAysC+rcjKx3iJj5GRkpSOjJiVhIaCc36BdoaEfo2Jj4mJfHh12OV1gIaHg4OBhZScenyLhoWXiZWfmZGYo6q2qKu9raHErp6tsbW3l7OopqmtqL7LyL/CcnDWbtDQvnR7eoyQmZGEfXNtzG+AenHLw7etsbStsLmooJalraGMioWOkIeTlYGIfXN4f4SJiYSFqKmsw7mwqaSZnpOLlnuNkJ2srZ+tqrSwppOKjaGyr7C4u7CnobKopaCJl7K4rq6orLO1q8Kdmay8rKG6vriyur3At8e1tcTNbcrJxsDRtpyMmbm+tcxsamlsbmyAbMhwdnHLwZuVqM5xwbzLy7+4vcrBasy3u768vrS+tamirsPSvbhtv76+vsCops7Ramq9xay6ucjEnaqVrq6fkYR5ebC2zXLTwsTExLK1s6qgiJyUlqGvpKedlIyTj3x0goOos7Kkosm/tLOrtc6zqbuzoa+usb+3v7WZk33XeoOAenFpgn16dr9wZ2K9amfBtbZvendnY3N5x7yssaKOkcdtaaqatbGFc4Bzf3d8faZ5nZy0Yl+kk5OmYpymtl6qs7WvoXVhY3KCgpGmtGDFuL5lYmOtjoOGiYuAfYuWmp6fppymsbGimJiQpltdXqqSgZKfXrakjIyFhH+Ag4N8fIaAjJCVkJCSg4B5gY2Wq62Xj5SZk42PjpyYmp6mr6uip6ammpuipJ6QhIiBiZCSjoyKjZOVl5CdlI6NkZ2qqZ+EkZaTmKapnJubm5aanp+QhJGSnJaUmpyiqpuMiYmGipecoamgoZqnsKqupqyvkXuCfoB6c3rVy3Sfk3C3yHCGd3aAnJqJfoaFkX15eIeJcM55fIqNiIKIgJucjZOWkImGe4Kclp6jnZieqJuen56joZuAb3eJkYmKmpaDgZamoo6QgG52kJqpoI2BkZeso6ixnJWRiX5wiJKWlYWBkJSMipeNi5ilmJOGi5WZj6GssFldZ1xeZGdqZmhmcm5tfoF+e3mAiX17dnx9i5mFfn6AiImLlZOVe3uGlZGEgHhsWVleZGlta2ZgYmtdXmOwrVpfYsO/amK3p6ifkISLgXyLiIWboq6bm42MhKKkppuZvKuQmKCJhouMnI+Een6BmJCKh4uFfoGCkYuWpaOToJiPjnyLj4qVlJCNsqi8tqiroaC0s7qAq6qJdLCmrpOJnZ12dpmOfnxoeHmDioN5gYmEc2yBeH+Gh4Z0zsnGuLKmu8bDs5e0sa3Ubbm/zcZ0cXZvz8TFxm1xfn3UsM1rz8HBy8uyvM1yfnhp0M3Gt2hwa3J9cnB6foWDiYyGfH+HeX55eoCBioqIiHLNyGvWz8jMxK3JbW+AbXDUeG9ucXaCgHp7gnHS3Xfdw7G5v7Wun7W+u298goWAgYWAgIqEeHt4bXV5b31/doJ+gH5/dHBtyNVudnx7enp3fYqPdXeDfn2JgImTkIeNl5yomZuqm5GmmJGdn6Khip2UlZmZlaSurKanXVy1XLGxomBjZHR2d29kX1tYo1eAYFmglpCOkJGPkJSJhX2HjoR1dHF3eXR+fG91a2Noa251c3Fzi4+TnZOMiIV+gXlzeml2eYOQkYeTkZWQh3pzd4aTkZGUk42IhpOMiYZ3gJCVj46MjZGUk6CEg5SekYmYnJqXnJ6fmaSYmKiuWaanpaGrl4F3g5mdlqhXVVNUVlaAVaFaXVidlX58jqZYmpignpiSlZ2aU52PlJeXl5KXj4mFjpyjlJVWnJeVlpiMjqqqVVOXnoyUmKKdhIx+jpCFenBoaZafsFypnqGgnpKUlI+HdYN+goqVjI+Hf3d7d2tmcXKMl5aOjqehm5qTl6mTj5mUiZSSlaCboJaAfWvBa3SHfgp9fn5+fX5+fX19h36IfYJ+jX2EfoJ/hH4Ff35+fn+Ofgd/fn5+f39/l36Df4V+AX//fgR+fn19hH6CfZF+AX3ffrx/CX5+f39/fn5/f9J+h32Zfo99AX6EfYR+hH2EfgR9fX1+iH2EfoR9nH4DfX1+h32EfgF9i34DfX1+i32dfoJ9sX4Hf39+f35+fot/BH5/f3/qfgF/jX6HfwR+f39/hn4Bf4l+AX+QfgF/iX6Cf5R+AX+2fgN9fn4CAgQAgIeLmKGOj5iYytKTnaaok/75ge3+/oT55/aBhe7iwq6KpMrCqaK5oYquq9PbvLy2uu7M6dja4+Tm4OXz393o4fvq5+rb5N3r6Nj9+fX3gYyO9vffyr7Gvrets668vr6xxM/Sx9Pb0MXU1dfP2Ozs8PDw5dmwpq23zObp39DKyse2gLS6vq62wL65xNba0tno/dPG0d3R09LZ2N3a5urx19XU09TY3NLa4N7W3+Ho897TztTXz9rY/u3y9ejP4uP5/4P+goiF/N/l/YT22MPE1NzP0dLIxNC9wKq6tcCqobbL6+DM1crMz9XMuLytk+Str4eJg3t8l9bnjqaKg7Wp85KMgJH99Ij95IuRp5GPn52dl5CltrynpqasrqvBzsCl19K6o5W9z9nt6fTNxam20tHIuLbIssfh+4D20+zW7vDDt5iGw97Qy8+1ttC3qNfOwsj32/7m2bzS7NG1w7/Qvbzd3tbZw8jH38vW293k6YGK/e2QmpansLC0u7rDz7HAwMrCgLSgg5ChstHk59/b0c3T5Nvj2uH89+Hk7uXk1a2Nl52ho5GcqaGcrKWPio6Rra2QkY3l6ffp4fHu4e/w7tG3wezcysS4w7bd2ru8ztTh1djezsS7q720u8q619K9wsXLx7Cvr7m9v8/R3MzU8dzu5O305uPe7dXe5NPx8IDu9e/qXOrW6MGmtaqklv7OhLLi+dna6YG974Oto6KklJ6yubGnm7aur7S5rqGY5dvp2MGMl4mGlJ2Zlbe30Nno4eXt8PWFmf3P6efCzczDtbO3zuz3gu/t3cjW0NW36/2BhYyAnZWLobKml7aypZuO/4aG/oqTmaWjrqmVkZadmZOWkJObiYmMnJ+I8/L55uuDkYeSqqqvqa2nqLGpiPX7+4Xh29bX9IP8kY6QobzowKqqqri2p6KXip+urLrMs7Wmn42NnJSpvqilu+LW1tmsrJ+ajqCyt8bey768yqysoqW6yb+Axca3vbyitMfMyMfU5vT+hYyDhpu2ysa4m6ilppyTkpKN/O7h3dvSz9TUz7Ojr66qra+yvK6uuLairK2rxcXExquwtLKsqaK807ixt7ewq6ykopWmt7/Y5djTzNPW4drb5PTr49ve2eLf3NrOsbTS39W81cHIvs3V0b7UxcLAuLuAyL+/0e7iz+bk7OPm8//EwMmkirna3fOKi4j449rx/4GNjIXz6oOM9Nbi493R6vL84+r48Pr3hYr+8+rk6ejm69vo7un04rfS9YWLgd7Y2drk7efb5PT338jHwbO1u7LR6+zm69jg+efg4L+8yaaxtsDBqMG5zcHEvaCiqZ6VnosfiaK12tOvvbXGz9W4x8be0Nng1MC5yMOrqaSyl4P9/oB2eoWMfXyFiLO7g4qTk33b2nPP3uF33s/ccnnXzLKggJm4s5+XqpV8n5i5waOnoKTRs8i0t8LDw7/E08C9xrzWxcXHuMfByMCz2NTKzm95e9LRuKqirKedkZuVpKSml6iusqWwubKmr7Gzq7XGw8vLysK+mZGRmae+wbiqpqakloCUm56QmqOgmqSzs6y1wtaxpa+4rbCvtrS9ucLGy7S0s7Oxtbuwtbu4s7u6v828sq61s622r9O/w8rEsMK+ztNt0mxvbtK6wdNuzrapqLK4rrCzqaiyoqSSopyqlIubqsnBrraurq6xrZ6kl4PSqq+Jjop/gJbP1n+SfHytpdqBfoCG5t995s1+f5J/f4yNjYWAj52mkZCPkpSRprOkjry0oY2ApLK4ycTQsa6SnLCuqZuXqZWks8lp0K7Ls8zKopuCdKy9sa21nJ21m4q7r6Os4bjWwLqfsMezmqaes5+evryzt6GmpLyosLa3vsBpcM7AeoV/h4+OjpaVnKaMmpqjnoCRg2t3gYufr7axsKinqbettKyyyMWxtL21s6mMb3h9gYd0f42GgZCLd3F1dpGXe3t6xMfSw73Pyb7R0c+3pKjNwKyqn6ubvbqeobe6w7i6wbOrpJKimaCvnru3oqanrq+ZlpagpKWysruutdC4zMHNz8TEwNG1wMe20cxvzNXQyoDNts2pkJ6Vjofkv3ukzeDExdR0qddynJKSk4KLnqWdk4WimJmfpJuMis/G2MS0hJGCgI2UkYeko7zF1c7Q1eDgd4zmts/NrLa2saWjpbnU3HXW1Mazv77CodLecnx9fHp5ioR4jp6Rg6GelIqA4XZ23XmBhpCPmpWCf4WOh4KIf4CBinp7e4uOet3e6tXWdYJ6g5uXmZaclpadlnvc4uF5zsjDxOB24YWBgo+o0KmVlZmmopWQh3qOnJqktJygl5B+fo6GmauWk6TJv73ClZiLhnuNoqSvxLOppLacmo6PorWorKygqamPm6yxra24xtTbcXhub32Uo6GbfIeFhH12eIB3dM/Hu7W3r62zsaqShpKSjo+PlaGTk5uYhpGQjqilp7CSlpSTj4+In7SYlp2cl5CTjYp9j5yhtsO0sKqysby0tsHOw7y5urS6u723q5WVsr63n7qhqZ+yu7WjuKajo5ygsKakscW8rsG7yLy+yNikoa2MdaC6tMdxcG7Jt7PH0YBpdHBtxr1pccWwvb24qsTHzbrDzMXOzG1xzca+uL7AvcS2wcXAyrqYs8ltc2q4tra0ucXBtL3K0LulpqaYmqKVtMbGwcezutHBvL2gnauMlpumppConrCjqKKIi5SKgo17d5CewLmSpJ2psbaZqqi/rrrBtKOeraeQkIybf3Db3YBqbXJ1bW10dKKscnl/fWzDw2a/x8hpxL/KaW3Et6SXfpKqopOMnY14lIugqY+RjJS5n7Khoqyvr6+wuayprafAsK6vpLGvs6acvry0tmNrbbi0n5SLkY2GfYWBio2Qg5CWmY2UnZSKkZGSj5empa2sr6mohnx9g5CdnpqRiomFfIB7goR5goqGhYuYl5KapbaUiJCWjpKRl5ifnKOlqJmZl5qVmJuTl5uem6Ccn62jmpeYmZWbla2dn6ipm6mls7ZdsVhaXLOgoq9dr5uOj5eclZaZkZCZjI6DjYmSgXuHk6unmZyWlJWYlYmRiHnMrrqVm5mLi53FzXWCc3Orpsp0dYB42NF02MNydIBycXuAf3p1f4qOfnt6fYB+kJqRf6CbjXxwjJyiqai0m5aBhZOTkIeDjICHkKBUq5WtmaqqjYVyaY+fl5SYh4mXhXmemI6Vtp+unJiIl6eYhIuGlYiFm52YloSJi5mMkZKVn6FXXa6oZWplam9vbnJ0eH90eXh/eoB2Z1djaHB8iY2Jh4SDgoyHioWHmZiLjI6HgnpsV11hZG1ka3ZxbHl1ZWFkZXx/a2plq661rqq2sKm5u7WhkZe1qpuakZmNqKaRkZ+hrKamqp+aj4GMho2ZjaShjpCTmpmKiIqQlJScnaOYn7ehsaq0ua6vqbaiqq+is7Vgtry5tIC4o7CZhZCJg3/ctHicus2ztL5pn8NoiIOEhHd/jZKMhHmQiIuQlImBf8S3yb6tgI+EhIyQjIOdnbC4wr3Axs/TcIPbrb+9oq2po5ycna2+xmnHxriotbGxmL/KaGxtbmxse3RsgIqAd5GRiH10zmpqx2pxdoGAhoV1c3l/eXR5c4B1fnJzdIKGd9bU2MbMb3tzeYmGh4KLiYiPinHN1tRxwLy8vNlz1nt5c3+UtpuFho2bmY6JfnWHkZCXp4+Oh4F1c4F7j56Lipi7sK2uiol8enGBk5ehsKWblp+Ki4GBkp+XmZmPlZOBipibmZmfpq+2X2VcXGh6hYF6ZWppZmJcXYBdWqSckZGUkJCRj4d5cXh5dnV4fIN6fH98cnt8e42MjpN8fXt6d3dzhZOAfYCCfnh7eHdwfIKElqGWko+UkZiWmJ+on5eUlZOWmpuXj4CBlp6ZiZqIkIqVn5yMl4qJiYWHlY6LlKGdkJ6dopieo6qIi5F4aIidl6JXVlSekZKeqIBVWldWnJhTWJ+QlpaTi5qcnpSan52loVRXnpqXlJiYlpiTm52YnZWBkKRYW1OSkZKRkZWUkJigo5WJjI6EhYiAmKOloqaVna2hnZyHh5F5gYWMi3qKhpKLj4lzeX94dXpraXyJpZt9jISNk5eBjY2dk56lm4qIko18eHaAbWLAyoh+gn2Ffgx9fX59fX1+fX19fn6WfZx+g3/vfgV/fn9/f4R+AX+jfot9hH4LfX19fn5+fX1+fX2wfgF/tX4Ef39+fsF/yn4Bf41+iX0Dfn19lH6XfYJ+jn0Bfop9kn4EfX5+fZd+hX2OfgR9fX1+hX0Cfn3KfpJ/9n6Df4V+hH8Efn5/f49+gn+RfoN/0X6CfQICBACAr5qJm5aNm4aKgpebmaihnpyjp/uCm56WnKGek5aOhvzt6peMh+XegoD8/qX7hLawprauucrm5tze0c7b3d71le34hImD6OLn4uXW9YHb2s/r9oD56cK8u7K7xsS/xdDN0eyC7eXxiPvm0M/a4OPWuqmvur7f08bf4+Lk4tDY29CAvbGxur6808LE1dzWxci6xMXMv8nKxM3Fx8/Kxb3T3ujo5N778uTz5/z249zggYeMhZKSh4OH+ePw6uDj3+Lt/4GDipONgYWI6s2uu7DGvq21vMC0vrG9tLbCz+Tt5uXo193V4Nm8s6eghfy9lZaXq8XT0I2Ynp+cpomJl52XmJyAm6aXlbGpj4aUmcO4maWyucrNrqu5rJqhsLewtNXlzLXEvdjizMvWw8rZ0LW7zcnH4dfS6uO1qr/j1tXe/vXcwbPBysWipLnX0qqwwcW/04GG6dDy6+Pn08vBwMfZ8fDo5fv+283pzdje3u307fSLnZ+ysqusr7fK0ba20c/RyrGAmYGam7q1yufm5d/S0tfa4u38/fT6//Tc0N7vxqWboKSXh4qZm5GKmpWVloz0h4CG79K8xMXhzMvb9ujh3+fy4urcwMPg6uDK1NPl5dXWxM/ZzcS3trG2xtfPqqS/1NjYw9Dayc7PytbS0tzhzuTu+IP36uzm9Onw3djp8vuHg96Aydvp0M3I1MGzu7WiqrGsl5urr72NnJeSg4OJiY6gp5mZn5KSlamimqmvqK+upebo076yprCuvOPs6/Xj4P+DjPzo49PU0s/OzsWzwNXa3MjM4oSXrKP518vZ6fb29PaCh//3hfWCmKKisa+0ya2SmY+Hioru3d3S0+jmgY6MjoyAiYb7+oyFiZWWp623tbCwqp+Rk56npaSqr5mXn4iEi4eBiZaOmqKYkJeQlJKJh4yPrbO7ycPIu8OvlaKttLfExL+2vK+os7zB5N3O49rc487Lz9q7vd/RvsDMzNjAw7PD1d7O2M/Rzcjl8YOAgPbw4vWFiPjt/vuAhoSnn6aelJKAi4j97tzk2tnk18zS08G+vtDP4s++xrm6tsTGq6auqqqwwcrEv7CqnaWonZ6jnKnEzczBwdLp9YLy/OvQv8rOzevj19vf9u/r9Oz55crN2u/w2cvazsnFt8ndtrnDv9bNxaabqaL+5/WUr8HE54L/7+Xf6vCA9+TIx9TpgYmNl5WAkIaLkYb5gZCI++3q7+/z4d/r5djIvMXj4tr0/omOh4uJ/P2DgIuG7N/R2tnV4YPlxcnAztPD0vny6O3lyLrFx8bq8uTPyKyvv8TEwsPBwLS2t7LX/+nRzbqstsCytaCZpK22uMnH6/X02dvl3NjOztDJzbWzx8fbzaiSqruroreAk4R2h4J6ind8dIiIhpONiYiOk9xyiYuFiouJgYR+deHV2o+HhNvPeXbj4pLec52VjJyQna/Ixrq/s7K8u7vTgsfWcnVyy8XCwMm613K8urHR13HYxqOhopqhqqijqLCtschvx7/LdNG/rq65v8O5oZKWn6LFtqa7v7q+v661t6+AnpWWnaKftKKmtbu6qqyeqaqvoKytp66nqK2urKOwusXGv7fVzsHOwdXQv7i8bW5zbnl4bm1xzrvIxr6+u73F02htcXh1bHB2ybGapZmspJefpKacppqkm5umssHJw8jJu765wbumn5OQe/O/nJubrb7IvYKJio6Mk3p7iY2Dh4uAiJOGgpyUe3aDhqykhpCdoK6ylpWgloiMmp2WmrbErJ2torXBr7O6pq66s5ufsaunwLayx8Gaj5/BsrC61cq5p5ulqqiKjZ+3tZSXpqefsmpvw63Mw7vCsrCkn6e4z8rBvtLVtqvJqrW6uMbJwcZ0gYCTkIyLipCgqZGTqKWnoZCAfmqBfpiPo7i1trKpqa6xtr3JycPEyMGvpbO/noV8gIF6bXB+f3ZxgXt7fXbLdWpwx7aiqabHsrG+1cbAv8LNvMa8pKjCzcKtt7XFw7a5pra/saqenZedrLq0k4yisrW4pbG9qq+yrrm2s7nErsLM03HVycrE0cfSvLrIz9VzcL+ArL3LsbKuuKeZo5+NkpmWhoqVma19ioV/c3V6d3yLkYWFjH+BgpeQhpedk5uclM/TwbKlmaKeqcrT1ePNy+52f+LQ08G+w7+/vbSir8PJzbi+y3yMm5bkxLS+0dzZ19dyeODad9t0h46PnpqetJqBjIF5fH3Wxsm9u9DNdIF+f3uAeHfh4n52e4eGlpujoZ+im5CEho+WlZGVnYiIjnh4gX11e4d9i5WJgIqBgoB4dnt+mp2ksay0pqyagpCan6OwraifppuTm6ipysS0zMXDyraxtsKio8W3pqi0s8Gpq5mou7+vvLG1s6nBz3JvcdbRwtJxc83I19Jqc22Jf4SAeXeAb2vIvbS8s7S7sKWoq5+dnKymuaqZopealqOoj4yVj5GWn6mkoZSThoyPhomMg46nrq2io7LFzmzL1MeunayvrMS8rrS3z8fAyMLOwaistsbKtaq8rqmmnKu+mp+ooLesp4yCjobOvdOBlqSgv2zSxr65yctszb6lo66+aXF0eniAdm1ydnDRaXhwzcHCxMXJt7bCubGnn6W9wLTK0XF1bHJx0NFtZ3JvxLmsurSvvG/Cp6qhr7Gir9DGvsTAqZ2pq6bHyburqJSWpKekpKehoJacm5i52cStq5uQm6SXnYqFjpWfn6+pyM3QtLzDurewrrOprZeWpqa6r458k6GSjZ2AgHFndXRwd2ptZ3h1dH55d3Z7fcFidHdyd3l6dXZxbMvDyIV8d9HEcGzNz4PDZYR+fY6Fj56zsqmppKCmp6e7ca69ZmhmtrGqprOpwWSnpZy4vWO+q46Mi4aJj4+MjZSRl6teqaSsX6yej5Obp6qhjX5/iIulmY+coZ6ioZKWl5KAh4CBhIiGlYuMmp+ekpSHkJKVh42OiI2Mj5OZl4uUnamooZ23tKe0qrWvoZyhXFxgW2JhXVtfr6CsrqWjoKGnsVdcXmZlXmFlrZ2GkYmWk4yRkJKLkoePhoeOmKKpqrCupaaipaSVkYiCdOvMsKqlrLvDt3V3eoSAgnJye352eX2AeoJ5domDbWl3eZONeH2HipSWg4CIgXh8hoiChJqklomVjpqglpmdjpOamIiKlI6Mn5qap6OGfYegl5edrKSZjYWIjY56eoebmoKDjY6HklVZo5Onp52il5KGg46bqqegoK2vm5Kij5WZmKKinqFeaGhzc29taW56gHF0goGCe3KAZldnZ3hxfYyMjouGhYWHjJObmpSWmZSGfIOJe25lZWZhWVxkYlxdaWdpaWSwYlteq6CTl5SrnZ+quq2oqKy0pauikpWpsqqaoKCsrKKllJ6mnZaNjYmLl6WdgX6Nl5idk52ml5icmqKhnaOqmKuxumO9trSvubC3pKGvt7tmY6iAl6Swm5uaopOIkY19gYmGeHuHiZZwe3dyaWtvbHJ9gnl5fXN1d4aBeoiNhY6Oh8bLuKyglZ6an7vGxs/BvtVtdtXGxLm2tri6tq+fqbnDybKzwG16jYjRtauwv8bGyMVpbc7HbMlqeIGBjIiKm4t2fHRwdXTKuLewr8G+anZ0dnGAbmvLzHJucXt+jI6Zl5OUkId6eYCIiIWHj35/hXFyeHJrbnl1gYmCeX52dXJtbHJ2jY+TnZyglpuNeYSNkZOcmZSMkYmDi5eZtrCht7GsrqKip62QkLSqmpmkoaiZmYqXpqufo5qbmZKmtGFgYbeyqLNfYK2nsK5XXVlsZmhhXFuAVlOelYuSkpOXkImGiIGEhI+JlIl+hn6AfoeLeXV5dnl9hoyIh317cXV3cHJ0cXqKkI+JjJelqlenrKGQhI6QkJ+ZjpSWpZ6Wn5+nn4+SmaGilo6YkI6MhpCbhIeNiJaNiXVvdWyto7RsfYmInVWnop6dpqhYpZyKhYubVlxeYF6AXVhbX1usVV1YpJqYmZufl5WbkouFgomYl5Gfo1dbVllZpqhXVFtYoJiPmpmVnVuhjY2HkI+Fj6agmqGdjYSMkY6ioZqOiXx9iYyKiY6JhoCEgX6csqCNioB5gYmBh3h0eX+Ki5aQqKqrmZ+kn5yVk5eQkX+AjIuZlHtsfYd9eYaTfgF9i36GfQh8fH19fHx9fZJ+Bn9+fn9/f4d+AX+FfgF/j34Ff35+fn/Gfol/in6If6J+iX3cfoJ/nX6+fwR+f39/wH4Bf4x+gn+vfpB9gn6SfYR+iX0Gfn59fX59j36HfYd+gn3mfoN/hH6Cf4R+i3+1fgF/rX6DfYV+AX+GfgF/hn6KfwR+f39/k36Ff4J+hH+HfgF/0X4CAgQAgLTHqZuqpZeZkIyckYiYobLEtq2Pj5mhi4COg/+tsJqJgIOV9eDBrpeYn7h2tP+SsM3Wv9Xl0NLl1cvWzNDJrrPQyrzi4dnIuc7j7fHu7P3h4NvCv8vV19W9t7Gko7XHwsjMx9DGvcnYz8vGs6aYk6ezvazAu9Xd5d7LyNvv8uLPgNLHt7i3x7ipuL/DuL7Az9LGvbmwuM/X18jB4OHa09Ph7fju4dnl7uTc79jv8uXn4+Xj5OX8lJqVj5GRiJGktrmcgtL6kI6E9vXAzciqv7Wroq6wu9PTuq61wra4xMy8ubuop6icl4uLgYfk3/X2iamgrcK0raWopqy1y9CjjKCigKjCl5u8vKyQ+5eilaK1oJ+moqrBuZeavr26pavJ2LufsMTKwLmSk6q1wNXX0LesxMO9w9C6uc7FwcDP6Onh7P3iu6y6sqvFxszK3oDoxeHv68XM5PKI/PeDgtzd2rm5yM3i8OPN1uWJmImGiOT3iZilrp6grbTEvZ+pzt3kzL6+gMC8s6fC3tPJ09ze4u3u6OnTzNvr+f/y6u7t6+XNm4afoJKXmpKPjJaZn5CYlI+dh97j8uKxw9itiJeYsLuxt9HLxtPdz7m1xZWArtnRzcivtaWqvbS1oaK5zLyyvNPGxtDByeDqyebVrrG5zLy6x7uzwsPA0cSgnKWYm6W/y93TgMPMrJexsJ+bl56rssXq/Ofa8MOxk5CT9/GHk4X4io6FgY2VguHU04GThIGYmJSSkZGWgurb28/BxLLC0djIzsq40Oz+gPqD+paRiIf/2tzf54Tyge/GwMbGy8DG4OfhwMrR8f+G6M/bzs3T6oeOmaOXlZ+wsuC5q6idnJ+cnKKXgJOJ/vrw+YL7+4WOiYmUnYiSs6izurmvpZuYmJ6ztpeXm5GRlaCxuaqjo5udnJyfopuMioKUrKuakZiloqOjmY+gmY2GjJeQm6aqsL24v8zSs8Pp0N7FwfbJ1M3H1tLR5fPpxcXo7N2+ucro7u7x6eDVxrmmqcrrhZysqZuIhYaDgIyMi4eCgfrj2uvV29jm3unT3tzb0M3AxtLItbS3xbeppo2JgJKX/omRqqicqMjh7YGB7djJv8rZ1sa+qafM2eP59uHr6vbz59zX7+bY6fHbzdbNxsDHop+WobGin7ejlPSJtLy819DEo6S1xOLf0cXQ3dC0uL/h7dX6kJ+ZjY6DgPyA4u+C9oL394eFlaCP/uG/trOmjKnW4P2HhoaRn56cm4njyMTdy9n//M7M09jr5MyyuLnIta2+0/aNi/DQyNLO2NXx4Nrp7t7VxcTGwebI1r/Dx8DFxcvDwL7W27a6zMjVy9Tczd7bua6httXyzbeou6KUqrKtt8HAssS0oL3JgJ6zl4iYkoeHf3iGfXaGkZurnph8foaOeHKBduKcnYh4cXiI7t3BrZaZor16tfGCmbG9prjKuLzSvrC9srStkZm1r6HExsCsnbXEytLLydq/wbieobC0t7mkn5mMjJ2vp6yvqLOso6y3sq+rmpOEf5KeppSpnbO4wr2rqbrKyb2vgLGmmpubqJqOnaKonqOlrrGpoqGWm7C5u6ymw8O6sq6+ytPJvre/x8TAzrHMz8bCusC9vr/Pen16dXd3cHiEkpiBa6LKeHdu09qoubKVpp6YjZiXoLe4o5mdp5yeq7OlpKOVlpaNi4B+d37X0uLhe5iMl6ucmJOVkJSbsLePe4+PgJSshYqkpJaB4IaJfYycjoqPi4+no4SEpaSjj5OuvKSKm6mvpqF+fZGcoLO1spuUqqSdo7Gfnq6mpqWuwsK+yNm/oJWfl5KnoqqouWvCo7rGx6Orv8hyz85tbre6uJqdqau8xr2ossBwfW9ucLnKcX2FjYCDjY+bln+HprC2opqagJmXkIOes6miqbCwtLu7uLqnoq26xMm+ur66uramgWyCg3l8gHh1c3x+gnN8fHeGcrrD1cuXqL2XdIGBl6CVnbWsqre/sp+gs4ZxmL+5s7CXn4+TqJydiYmfsqGYnbSqp7Khp77JrMm6lJiguaafrZ+YqKqltq+LiJOEho+lrb6zgKiwlH6bmoqIg4iTmKnG1se80qmdgn+D3tV5gnfde391cnyFdtDCwXSGdnWKiYeChIWMedTGyb2xt6SyvsS2vLmnu9Xkct104I6Henrpw8TI0HjaeNywrLO0vK+0zdbSsbu+4Ol50rvJuLm90Xl9hpGEgo6hoc2mmZaOjJGLjJSHgIV75uHW33bj4niCfn6IkHuFpJagpKSdlYyJio6jqYmJjYSAhZCip5iQk4qLi4uPjod8fXeFnJiKgomVj5CQiH2NiHx0eoeAiZSYnaeiqbW6nKzSt8atqN6vu7mxvLe2ydXPrKrHzL6ln6/Lzs3Qy8C2qp6MkazEb4GMh4Bva25rgHFwb2tmZ8u2scWvtK+8tMOvuba4r62iprKqmZmcqZyQkHh3bn+F2nd9k5SFkay9xGxsxLSonqm3taWgjo2wt7/SzbvGw8zJvrawx76vwcm0prOqp6KqiIqDipiJh52LgdZ3nqKfuLOpiYicpL66rqOwvLCYn6fFy6zMdYF9c3VqgMtousZty2zLyXFseYJxyLecmpiPepS5u9ZxcG95hYGAfm+7paG8qLPS0KmttrXGwqqSnZ+tmpOjssx0c8qxqq6qt7LKvLbGyruzpaSppcOltJ6iqKGmpq2mo6O6vJ2ksqy6rbW7rry6m5OKmbXQrZyRoo1/l5+Wn6Sgl6qbjKuzgIeUgniCfnV4cGp0bGh1e4aQiINucHZ6bGdzbtCJh3puZ2yE9OPKtKKns9OFu+h7jqCnlaa1pqm4qaGmoaWahIuinpWztq+djqGvtby0tsWurKGMkZ6jo6OQi4d6d4WXk5aalpqSjJSZlpSThoB0b3yGi36NhZebo6GSk6Csp52SgJONhIOCi4B6iIuTi4yKkpeTkI6Eh5qjppmTqKWfmpWkr7Stpp+mrammsZmwtaunoaSipKOvZGRhX2NjXGNrd3prWoSoZWVhubmUoJuIlIuGfoaFjZ+ilIuKjoqOmJ6UlZWHh4WDgnd1bnbUy9bWcoV/iJaOjIeGgoWJm6SEdH+BgISTd3uSkYR10Xh5bXmIfnl8enqLjXl0ioqNgIKXoI98hpGVkY91cX2EiJeal4eCjYmGi5WIho+Ji4uUoaOhqbWgh36EfXuMiY+OnFeii5qhoYuRn6heraxaWpeXloOCiIqYoZ2NlZtXYFlYWZukWmNnbGVnbm93cmRrf4WJfnl4gHd1cWx+iYOAhYqKi5OUjo2BfoOJkZaSjI2KjIqBaFhmZl5fYl5cW2JkamBnZ2VwYaKptK+LlaOHa3NwgYyEipyZl6Kmm46KmHdqiaSgoJ2MkYSIl46Of36Rn5GJjZyWlpuPk6WtmKuggoWMmo+Ml46KkpSRnJZ7eYB2eH2PlaafgJOag3KIiH15dnuDhpOrua2nuZiOdHR2ycNudmzNcXRuaXF5b8e5umt6cG58fXt6fH2Ec8zBxrmrr5yotbyxtbKisMbWbNdw0nx8cnPbvb28xXHKbc+ppKamrKWqwMK+p6+20ttyx7G3ra6wv29yeYB4eIKSkriYj4uEg4WCg4iAgH5229fK1G/X2XJ9enqDhHF7k4yXmZaSi4GAg4qanIF/gHl5foSQmY2HiH+BgH+CgXtzdHB9jYt8eH+Kg4CAenJ9enBqb3l1gIaHjJSRlaCljpm7pbKcmL+epaGaoqKjr7WznJuysKCMiJSrrrCzraWZkId3e5OmWmpwbGRYVFZVgFlYWFVRUqKUkaGUlpKZkZqNlpWXkpKLjZGMgICDjIN8fGlmYWxtwGZrenpzfZSgolZWnpKKgoeQkYaEeHmTmp+tq52ioaajm5SRnpiRnaGSiZOMiYeMd3dxdYB3d4V4br9piYuJnJWNd3aDjJuWkImRmZSDiI2mqI2hW2RiWVlSgJ9SmKFYqlekpl1YXWFXm49+fn53an+dn65cXFtjaWdkYleZh4OUiJGopouTmpejnot8goKLf3yIlKhdXKaVjpWSm5ennZupqp6Vh4WKip6JlYOGjoiKjI+MioqanYiOmZWhlJeclaCehXx1gJeqkod9inlugYiDiYqHgpGFfJWam34BfYZ+AX2IfIN9/36Ifo1/BX5+f39/o36EfZp+AX3CfgF/iX4Ff35+f3+NfoV/gn7Cf+d+Bn19fn5+fYd+g32MfpF9BH59fn2EfoV9A359fpB9AX6HfZZ+hH0Dfn197n6Pf6B+AX2JfoJ/rn4BfZl+hn8Jfn9+fn9+f35+hX+Lfol/mH6Cf8R+AgIEAIChnefhgfTt8q2ntcrP2v79moGZq62fnpmTjv2DhovmipT8zLOwqKSH1eTcgKrA0Ie84eDAzMrv6/Lx8Ovc59XM0M7NzsvNycLDzLuz097o39/QrbmssK+9ubTA18Hb2+PohfHbrZmiu5+UuMbN0NXa0+XQytHg0MPKxbfP3d3c6YDeytbq2MW2rZ6dnKS0qKiXn7Sysqi6vbi7tLfBz+Xv4uXl4NLDysnJssLP0NTm4fDr7ebX4Nzl7fL14MSmwNLS1dPW3cumnYmgs62yvbfU5t3q29DW2dzg1ePq7+ayqpWIjpyVnbCyq5OYqbKomJedi4aUqbzIxbC0v5yfo6qtr4C42cDIxbalppeVorWtoaTQxdDa89zLuqOkvLqxsLmsp7XGxMa8ra2nn6a30M7X4OTays/Esq67tLq1ra6vusrS5s/TtLbwycvc4sfH7/D61ujIyenw/Yf28eDL5c6uzt744e7axNDr+fX2kIrh7omKio2gpq2urK3D3tWhh5Gs1IC2pM3j29u4tba/yeTz6dbY2dvc8Pr+hIH89uvaw8O3w7qvv8O2rJiXlJaZp52Sj4z/+eL05tz60ruxt6mrp8DNzcrFydHY2LmesaeotLm1rsG7oaapprW7xtHj5drftejZ19rY1MrIyby1t62orq2ytLW3tqujpqmqs6+qt766xYDT2tDKys3Nv5aYk6abmKGsqsK/wLa2t52eoJmIlrOchoavu7GuoaOkvMCpp6eupZ+xqqK5rqOyoZn/gZuLkIL16vrn94ycloSEgIXy9tfSwcW3r6qspJKH6OOJk6iyytLh1dHY0NXl+vf19oaIh4KGlJGCgviHkY2SmaKmoqCmq4C0qKm3op2rqKqrtLKqraCenJiUj4+RlKWurbe7urLDtJ+Um6GpsaCfqauwtq+rq6aWmp6juMa5vce7s6u8vra2u6icmIf+gZWcn6OmqJyUnKecxMXIysTN1OC+x9XYys3DxsnVzsXFpZeUpZyxr6vK1M3b/PLJ5fD149HQztfV3IDZhYuToZmH8/GKgIaI/4Hy3M/VyMre1cfa1N/NwrqvppajrKiqprGpp6KgprfLyNHX1c/M08zBv7Sgj6K0usGovMfIvaa1vK6tqLfDy9DJxM3QvrCfk6akj5iaoqSaio6Rnqyjxc27x93+4N3p6ffh5d/d2Lavu7zF//jo5O+E8oDp79nfw92AjZCJ/4CE/4GJgOLg1cfEy87j6evj1uCC/tTPz9Xk9d7p9Pvj4cvW3fzz2c3F0c7Q0dDu8eTGv9HHtMLM2uPi28fKxcrK39KA+/HgyqmQiKTC3/DMwOy9orW80uWCh+/W08/QyM7k5tbDvK20lJmhqLGtuMe2urewuICLi8rIc9fV4Z6Vpri9wuTjjXCHlpeLioeBfdt0dnzMeYLftaGdl5V8xtrOeZ2sunemw8Kkrq3Wz9XSz82+y7ats66pqaenn5eWoJqavMLJwcawjJuNkY6fmZGcs5q6uL3DcdC/lIiTp4l+oKuusba5sMSwrLLAsqevqZuwu7m3xYC4prPKt6icmI2KiY6dkJSDiJucm5GjpKGknJyjrsPLv8PEwLOosbGqlaWysK7Au87My8KwuLS9wMHJuKKFoLS2ure5wK+Pjn2RopeepZ+1xrrIurG3vb7As8HIzcqbmIh8f4mEiJ2dmIKIl6CWhoeOfXmDlKatqp2fqouQkpWamoCgxKetq56Tl4WBjJyVjY6zqrW80rywo4+Po56Yl56SjZumpKiilJaRiY2bsq61vsK5qrSrm5ail56blJaWnqu0yrG2nJrRqq23vKWkxcbTsMeopsHH0nLNy7yowq6QsLvVvsy4oKq/zsjIeHK7yHJxcnKDh4yOjY2etK+DbnaMrYCShKW0r7KVk5OZobfCuaqtr7GwwMXGaGXDwrusmZyRoJaLnJ+Vjn19enx+ioJ5dnXTy7jQxLrctaKbpJSUkaixsq+qrLS7u6OJn5STn6Ggl6ymi5CUjp6hqLDEwbrBms28ube0s6usq6CboJaRlpSam52gn5SOj5CTm5iRnaOdqIC0vLKrrbCxpYGFgZWGgYuVj6mkpp+doYiLjIV4hJ+Md3efp5mYjI6PpquSkpibkYublI2km5GgkIrkdo58gnTc0uTM2X+LhHR0cXfb48bAsLipoZ2emYyG5+OIj6GovMDNwbzEvcDN3tzf3Xp9fHV3hIFzc9x4gX2CiJGTjYyTmoChmJmojoualpuco5+Xmo2KiYeEfn+Bg5aemaOnqKCzo4yBho6Xno6NmJmeo5ybmpWFiI2Up7Glp7ClnpWnp56iqZWLi3njcoSLjZGVlouDi5WKsq6vtKu1usWjqri8r7Sqra+/tamvkYR/koWclpKxuK6929Gpw83RwK6urLWttICubG51gXtuyMhzaHBy02vJuK60qam9s6W4sbyso56Vjn+Lk5CUjZiQjYiIjJqrp7C2tbCrsKyloJeIdomcn6iPoaeqoImZn4+QjZmjp6ynoquxoZOGfI+NeoOCio+FdHp8iJaJqrGgq7vbvLfCw9G8vLa1spWRnZ+h2M2/u8ZvxYC+xrC1n7pqdXVw0mpry2pxabq6tKenra3AwsK6sbht2K6urbG/0bjCzNO+vaq0uNnPsqiirq6wrKnExLykoLOqlqertLq7uqirpampwLZu0ce6qo97dY+qwM2to8iji5yhs8Jtcceysa6wqa7BxbampJqegoaOlJuWnqycoaCWn4B6d7W1Y765vY+NnKqqrMfEeWR3g4N7eXZyb8RmamyzanHEo5aSjIlyw9LPdI6brHCZsK+WnaPEvcTEv7mwuKScn5uXl5SWjYSCjYuOq7G1rq2cfYd8f32MiH+Ek4SeoKqxZLqpg3uHl3xwiJGTlZebl6SVk5qkmo6TkIWVn5yao4CZipesnZCHg3p7fYCHfoN4e4mIh36OkpCRioqOl6qup6qtqp6XnpyTgY+Zl5WgnbGwrKaYm5aenqOroY53jJ6hpqWkqZqBgnOCkIiLkoufrKSrn5mfpqWmn6eus7SPiX1zdXt3eIqNjHp/i5GMfn2DdnF3hJSZmY+Ol4KGhIaNjICQqpaXlo2Gi3dxeYN9enuXkpuhsqefkX9/jYiCgod9e4OKjI+MgYJ8dHJ+kZCWnqSdkZiUh4GHgYWBfX19gImSo5OVhIOpkZCVmIuIn6CqlaSQjp6krVuop5uPnJF9lJyunqWXh42bo6OkXlqdpFtbXF1oa29ycHF9jYpqWWJyhoB0a4GJh4p3dXV5f42VjoSGiYmGj5OXUE2TkIuDdnd0fndueXt4dGhnZmdpc25qaGW2r6OvqaW8oZOMj4GDgpKcoZ+YmJ6jpZN+jYaFj5CQiJaUgIKEgIuPl52trqasjbOoo6GenpmYmI+KjoeBhYOHioyOjYR/f3+BhoR/iYuHkoCbopmWmZybkHR2dIB1c3yBfpOQk4+OkHx8fXlsdIt+bm+LlJCOhYSHmJ+IhYiIhX+MhYKVjIaSgXvWbYF1fW7RyNS+yXWAeGpraW3P17m1qaufnJeblo2L/P6PkJyhrbPCtbG4sra8zs7S1XFyc3BvdnRnaMttdnN3fH2CgoKHi4CRiIuXhIKNiYmKkZGLjoKBf3t5dXR2eYeRjpWZl5Cel4N2eYGKkIGDjo+Rko2MjYd6foKHl6SZnKKWkoyZlY6PlIV3dmzQand8fn+ChoB4foZ+n5aan52io66SlaCjl5mTlpmkmpSVenJxfXWDfn6ZnpaitK+UoKSnmY2Qj5WMkICOV1dbYl9XqKdcVVpbrFaklo6RjI6blImUkZaNiYV9eG10enl8d396dnJzdoGPjJWZmJKNkI6Jg3pxZXSBhIx8h4yLhXR/gXV4dX6GiIuMhYmOhHpxbHd0anFvdXZvZmhqdH96lZyPlqK2nZeeoKqcmpWWknt5g4SGpZ6XmJ9Wm4CVmYmPgplVW1tXqVVUo1VaVJaYloyMkZKenJqTjpRVrZCPkJOdqZeaoqiZmo2TmK2mkIeCio6RkI6empSFhZKLfoyPl5ubnJCRjY6Qn5laq6GXi3hqZ3uOoamSh6GGc3+FlaFaXKaSkI+TkJWipJiNi4GDbnR7gYaEi5OGiYaBigV+fn19fot9in4HfX5+fn1+fod9g3yEfbJ+AX//fvV+AX+TfgR/f35+qH+CgJh//36KfgF9hX6FfYd+jX2CfJF9iX4BfdB+AX27foZ/gn6EfwJ+f+9+AX+HfoR/B35/f35/f3+NfgF/r34Bf5R+gn+bfgICBACArY+ZlILV3/Xj0MyAh+Xc7s+2xubqxbu3t+L97c23tbvygvjB0f+C4PP3mpeUp6/Azcnb5MXbtL/Ly9HSxNLh18PT5tHd4Ofe5djM3+bl+uTRydfNt63CwbGsoJOQk5Hv/+yEgY2hqq23qKGmppLv2eXv9/34g4uBhYeHjJeks7WAtb2zsq22tLKvtrzFx8m7u7+7ury1raOywsrRyMbX09XUzMHOxLfS08TDw8XHyMjS3NG9xcWov7OTl6KwlqGfqqK6qrW0u7i/y9ja49TM19vv6OLwzLvHy8nFvKygnIyAi7u+p62WjOPyi5CH8YiNiY+YmpGruLGelqC2t6+voqCAtcanraSYoJmouqCvt7LL5M+1r76xoqa/ybjG4u7TnJ2ryL+srbmtobji39/U5+/22sWxhvmTr7zgzrv3kf7ayOXgw6WFmNXXyMu7qba829rd5NfshuHj5fHn4unj1eaCguz18fD6hYqBkI2GhIiGjouUpqqtt73ErKa2vsW+zNWA3uLr4cO0ra29xM7r7urc2NDR3evo64CChoeCgO/LvKems7a7w7uvqqKqpaGuqpyYmqGmlZaSj4L48OrSxMnW4tz/gczo8dez4//FsJ+ehqLCwr+6p665xtXq3uXd18LO4vLNp7etoq/MyL/D2c/GzLOkr7qxwMTOvLecrLG60r+AwbGuu768try7vKWkqKOkraWqp5iQo5iapa2qqsS/ubi4y+DI09TOzq+ku6aUjZShioSBgJKRkKiYqLWonY6Eg4aE9+PY8Orn5dX0j/+F2ay4t7m8xPD+iPrv8sKDdoWJfoaepLa1r73A2pGRgvzzgIWChYuUlI6Ih4P/io6VmZaApaWgnKWmmpOblZSWjpWHj5iUlaCdkpWVoaKjqKS0uL+4wsK1wsK+xcG4sbS2uLi5s6+np6u5r7Oko6mtrbC8r6CklqGxsqefmZigkI2Vnqa/uqOhorK9yMLGu7m7zcmppLDY1L63wK6hqa6+rqapuKu3vK/D6MWqk5+ppZulxvyAnrq9v7GkopOJkpGG99zV1dDJyKSborGhrcLY4d7n2tbQwcO0qrjDz9De3ca1pq62uLjEzb6/vaqqrJuGlo6YxvGGhoOH3MXKzdvW3NHYy7q6ubLC0OT0/uHu4r63qqitpZah5IrIncPfyc7Gz8fhz7m4y9LX7Pr72tzngomLhPyAg/fTycbf/oiNi4eLiO2LmJWam4eQkob06uzi2dfIwcrk4+Hh1N/hnqCuv87O3t3P7/DX6PLt9fvz2sTJxMnV9Ozt+Prw3NLLu7m1q6CsxM7d29jZx5+Wqb7CvszO0eTtzNfszt7f0NTb8OzMxt3Zz8PAzbW5uKKjj5Gwno6Woq6AmX6Jg3O/yeLNvrdxeczC17iis9DQq6ajoMvm1LWgoqbXdNuptuJ0wdPTh4R8kJuqt7HAya/HoKmyr7W2orLDuqixuKOzuMXByby0yMzG2ca3s8C4o5mvr6CajoJ+hITZ69t5dH6QlZmjkYuTlYXbxc/V4OPhd3tyeXp2foaPm5aAl6Oam5mhnpqXnaGqrLCio6aioKSdlYyYpKmyq6q7tra4rqa0qp+3tqenpqahn6ezvrKhqqqPpp1/hY6ago6Ll42mlJ6ao6Kor7m6wbOut7rNw77NrJ2vr6+uppmPkoR3f6enk5qIgtTff4J6231/e4CHh3+XopmKhI6fn5qZjomAn7CRl5KEjIaSoYuYnZuvxrOamKWYi46hq52pv8i2h4iUrqKVk56TiZy9ubqxxcvTuqeZdt2BlqC+rZzOedS1ocC9ppF0g7i3prCfjJiZtrO2v7DAbrq8usm/vcS/ssFub8bMysfRbnJodndxbnFudXJ7iYqLlZqgi4WSmaCZpa2AtLW/tp2Sjo2bn6W9v76xr6epsr64umdnaWlkZLyhlIKEkJCZoZuQj4WMiIWRjoN8f4aOgH55em7S0Myypqq3vrffcq7Fzrqayuarl4mKc46pp6WgjpWfq7fKvMbAuqWuwtSykJ6UiZWwqqGmvLKnsJeLlqCTpKizop2Hk5eet6SAq5uVn6Cem6Gfoo2NkIuNlY2SkoR7j4GFkJeVk62on5+cqsKttri0tpiNpJOCfIWTfXh2coF/gJqFk5+Tin50dXd13cu/2tXR0cXjg+V5yqCurq6wuOPofObe4LN9c4OKen+Xmqqso7CxyYWEduLbdHZ0d36JiIF7e3jjfH2Eh4KAkZGPjJSViIKMhoSFf4l5fomFg4+LgYWDjY+QlpGhqKyfpqmdraynr6ujm5+ioaChnJmRkpikm5+Qj5aamJ2pnIyPhI+hoJeOiIWNf32Gj5OsqpKPj52lr6uxpqGjtrWTjpm/vKehqZaMlpupl42ToJOgpJamy6iOfYqTjYGKpNGAgpeYmo+FhHhxeXVtzLiys7Ksro2GjZiFjqC0vLbAtrKuo6iakp2kr625uKOXjJOam5ulqp6ioY+Rl4Z2i36Cqspvbm1zuKStrr23vq+3rpyenZajrLzH1brGv56akY6Vj4CJwXmpg6vCrLGmrqfErZqarLS2xtXYtbS9bnJ0bc+AbdGuq6i81XJ1c250cr9yfHd8gW52eGzFvsO7s7OjnKfAvLu5rb7GhomWoq6svLqtzs21wsjDyNDMtKKpoqexzcXG0NDEta6pmZybkoeWrLC7trS4q4iAkKOmnqyvs8TMrLfLrb27r7O6zcqvpru5sqemr5Wen4yRfH+diXyDjZuAg25ycWeus8S3q6dja7ixwKWWpL27nZiYlbfKvaSSkpbAZr+Xn8Jkqrm+dXNxhY6cqaWyuqOxkp6ko6inmKOup5meopGcp7Kus6iluLu3xLWopK+mko2gopeQhHJzeHvQ3cxsaG9+hIiSgn2HiXrGtb/Aw8nJaWtkam5qcXZ9hH+Ago2Fh4WMi4mGi42TlZiMi4+OjY+Jg3qBjJGYl5ejop+gmZKfmpChn5STlI+IhpCcpZiNk5F8jINwdoCKdn1+h36RhpCLkI2RmaKgpJyXnZ+tpaOymIuXmZmXkoqEhnpvdpmZiI2Ae9LZdXdy0XR2cnd7eXOHkIuAe36LjIiHgH2AipWAhYJ6fnh/in2EhoeWqpyLiJKHe3uGjYaQnqOYc3J8komBgYp9dIOcm5yaq7S7ppaJbclwf4qekYaoYK2XjKCcj35ocpeXj5SEdn2AlJOWnJKcV5icnaeenaCdlqBYWaSnpqWsWVtWX19cWFpZYF5lbm1udnh8b2tzdnx7goeAjY2UjX52c3N8f4KTlJSMioaIjZKPkU1MTEtISIt5b2Rmb3B4goB4d3F2dXN7enFrbXN4bGxpaWG8tbGdkZWgq6S8YJmts6GIrMObjX57aoCXlI+Mf4OMlqGxqbCtq5mhrbqfgo2HfoSZmJCUo5uUmYR9h46FkJKbjoh4gYeNn5GAkoaCiouKiY2LjX1+gX58gn2AgHRufXV3f4SEhJSSjo6Pl6mbpamkpYuElIV4cnaEdG1saXd0c4R3hZCHfnNqamxqy72zxb+8vbbJdthvupegpq2yt9Xfeefi5LyJgImQh4uenqmlmqOqunh6bM7IbG5scHaBgHt0dHDXdHV6fHaAgoSEgYiKgXh+e3t9dn1wdn97e4N9dnl4gYSGiYWTmZ6SlZeRn56YnpuVj5GRkpGUj4yEh4+XjpKFgoeJjZObj4KEeIKNioWAenl+dnV7g4eZloWCgYqRmZabk4+RnZyCfIakoI6KkYF5gIONg3yCioCIjYOQrI57bXd+d2twgqGAZnZ2d2xkZV9ZXFpVopiWl5WRknl2eYBwdH6NlZOclpKQiouBfISJkZKZloZ/eHyBgYGHi4WHhXl5e3JldG1ykadYWFdamo6VlqGfopSYk4SBgX6GjJecqJihnIeFe3h8eXB6p2SSeJWllpmPlI+ikIOCkZaaqbOyko+WV1tdV6WAVqmSjo2crlxeXFlfXJ5aYF9jZ1teXlWcl5qZk5KIhIyclpaVjpmfcnN7hI+NlpWNpaKTnaGfo6mllIeLhouUp6Ckraqhl5GLf4B+eHN+jJOdmpiaj3Vte4iLho+SlqSqkpuplZ+gl5ueqqiUkJ6bmI+Ok4CIhnl9bnCGeW50fYWFfoZ9gn6UfQF+hH0Efn19fbV+g32Mfod98n4GfX1+fn59x34BfYd+AX+XfgF/in6Cf4V+sH+GgJx/in4Bf/9+iX0Dfn1+iX0BfpJ9BX5+fn19i34Bff9+hn6Mf7V+hH+ffgF/ln6EfwJ+f4Z+hn8Bfol/6X4CAgQAgPDyg/ThtLK61Ma32djAsq/JxMWnxsPc4IiN8tLUo7/AtLazko6YpL7L/ZGNjpCop6mdoqWjrqqqxbuuqrOsr6+gmJKim/X7g4WH4urwenzK0c3Ct7OgoJmdlYWEjZGSnZGXnKq2wNLY38vEz+nygI2WpKGhlpSdrLC6wsPByc3FgMHJtrOwsqy0sa65wMzLx8DAvry5uLfCv7jDxcO7rbjCzMOlk5iWmZOiu7u5rqqjnKissq6qtq2lp6OipKelpMLFybO+yMvQwsbQy8XY3fSAhIWG9OXp6OflzbCf8uu3w9j/hI+dsKGLn7W0xLCpucvVztu6x9PV0MrK3Orl17y4gMuxtMKztaWkpKqwvM3i0tvj5uPnw8fd283Mr6GPueTBl6/I17mzr6WsrLWzlYOaudfXx8G1o6nAw7q9ytm+w7vL3tC+1Oj69u/au83X1dze5e+D/PiB/OnS17OpvPWEjpWD4OiImaGWgJSdpaKdo6Onr7a9oaKxsKq0ztjSwra8gMDU6OndxcDAv9Dd5d3WtbXLu8vUztrs9feBgoCB+dm8q6OmtLOcoqysp56cnJiZkI+P/oCLj4j7/vzz8O3j2dzr+Pjcxae5xa+Tj4D1ncC5rbW2qqe5xc7Sy9Hb++7ftKzHxsrIzNTi8eravK6npK2gq8C+uJeRsbOnnLG3urqzgLC5tKawwby4ppaTlomGj5enm6Wkq6abo62spZuhucLc48/Myr69qM7c1+Tn19uwhImroY+nh4SOmYyHjpWVlqCXiI2PkIeHjIaUqp+51MO1o6ejoJCEjaCYm6KqioD//NK4na2rmaKhqZqImba5sKW94+X9hZCVmKCmnJOKhIjugO/z7Pn3i46NjZOZmpyeqKSuqaqsqK26uqaisa+lqLLFzsjOwby4rrK+t6uqqJ2Ii5GcloeSkY6VmJKJi5WnqKmppJycrKidk5aQgYaAiYGKl5GL/4GQhYSIk5WRk6GrqqSkrr3Jw9PGvbTIvrrA7si11cHP1tzJ1tza5/zi5oGEgOuKkpmSk6CfkouKgfDugIL//YL48IKB+Ork2dLY1NDFyrq6ub/F1dbX5+LZ4+T69eTb1cis0ODXwLzV5cq9zdrs3Nvy/YPgzaL7/put0eby4sSyuLjK5eW/tsDEy+TMzs7qwLvJ3dXazd3u8ZKjl/zJ0N/e3938/d7d6O/v8NvzgPyA8fCAjpShlYSF9/WOkImLhYD/6tHI0tjg2unw4+ro1NPExsbHy9HVxMO2vtjs28PIr7C80e+E88/C0KqhtsrIy8PIs6utxLynrsHa07K1zOHx4dLNytfc18e/z9vq5cCrtrm8zc/GpZ270dbb293OycLEwJicvK+Vk5KTpZOCgNXbetzOpqKqwbSixca1p564sbSZvbfMxnh828PHlK2wpKeoiYWSo7q/7oiFhoOYmJuRlpaSnJiXsqiblqKbn6CTkYmWkOfzgISJ4+rwen3O19DFurunqKWpo5COlZicpZqgoKyytsbP2MS8xt3hdX+EkpGPhoGKl5uiqaqpr7OrgKevnpuYnZmfnJagqLKyrqiopqSgnJ6opqCqqaiik56puLCSgoiFhoGQpaSgl5KLg5CVnZmUoZaRkI2Li4uIiqSkqpOboqaroqu0r6q6utJucHJyzcHFxcPFs5mS7+65xNbzeYSOnZF8jJ+drpmWprC4sr+hrbe6trGuvcjIvKWggLabnKmZnY+NjJOYorDBsrvCw8HIp6u/uq+0mY18ocimf5aquZubmJCXkp6bhXKDm7e5qqecjJCkp52frbyhppurvK+fsL/U0c27nK20s7i5wMNrz8pqzsKxupeOnc9tdX1vvMBxfoN8aHl+hYSAhoaKkZefhoeWk4uUqbGun5WZgJqsvr62oZ6dm6u1vLWylJOol6aroq68wMFmZ2Rnx6uUhoKFkJF9g42Ni4N/f3+CeXh50mhzd3TQ09PLx8jCuLvI0dS8qY6irZqBfnLWiKihlZmckY+fqK+yrLG92szBmZStq6yqrrbC0Mm6oZeTjJSIkaShnn96l5iQhJWZnZ2XgJiimo2Xp6OfkoJ+gXZzfIWViJCOmJSIjpiYkYeLoKS9xK+vraKklLe+vMzLucCZb3WYjHuVd3aBinx2fYOCg42Gd3uAgnh6f3iDmYukvq6fkJaSj4J2fY+IjJKXeXTu7MOslKSikJyboJODlrO1p5iw1NDhdYGHiY+WjYV6eoPbgNvc1uTefX59fYKLioyNmJKdmJiblZunppSRoJuSlJyvt7W+raekmZyqo5eWlIp3eoGKhHqEgn+Hi4N5e4SVkpSYk4qKm5iNg4eEdHhze3V9ioSB53SCd3Z6hYeAg5Sal5GSmaazqr6wp5yxq6Gh06+bu6aws7ysub28xt2+vGptgL9xdn53d4KAdnBwa8XIbW7Y1m3OxW1qy8C8ta2zsa2krZycnqGlsLO1xb+zvL7Ry763samQs7u0oJqwwKmbrLzLu7fO0Wy6sY7Y3YeTsb/LvKGSmpqpwcKfmaaoq8Strq7MoZ2qu7O9rrvFxnuIftWqsMDAw77Z2Le1wMbFxrPKgNFsysRoc3eFe2xwz8l2eHJzbmzYxa2kr7K7tL/IvsbBrLCipKKlqK60pKWYoLfGt6GplJSescty0LCiso+Im6qnqaCnlJGUp6CMk6W+tZacscHPvrGqq7e7tqeitL/KxaSRmp2hsLCqjYeitLe7urywqqSop4KFo5Z9gH+BkH9xgLzEbMK2mZecraOXr7CknJWvqaeMq66/umxwwauuiJ6hmJuehoOSornB8IqHg4OVlZaNj4qGko2NpZuUkpyWmpuSkYmVjOj3goiN8vT+g4be5eDVycm1uLq8tqKcn6Srsausp7K2tL3Eybu3u8TManF1gYKAd3R7hYeNk5STmJqVgJOZioSFjoqOjImQlp2dnJWQjY2LiIiQkIyUkpWPgYuVoZyDdXd0dXF9jIuKg392cYGHjIiEjISBfnx/f3l2eY6Ok4OGjZCRjZSfmpWgna9dXmBfraarq6isoIyI8fDBy9fkb3mBjoZ0gI2PmYuEkp2loKmTmaClo52bpK2xqZaTgKKJh5CGioF9en2EjZeimqCkp6eqlJejnpeahnxtiqWLcICQnIeGg3t+foiIeGlyhpqckI2Fe3yFioWHkpyKioWPm5GGlJ+xrqmchZGWlZSTm5xUpqNVp5+Sln94gadYYGVbnqFcZGhjVmJlamhma2xuc3h8bW12dXB4iI2KgHl7gH2LlZWQgYGAf4mOko6NeHeDeoWFf4aNj5FLS0lKk35sYl9ibXBjaXFxbmlpamhpZmZnt1pjZmO1ubiwq6qloKOwuLelloGMl4l2cmbHeZSQiIaEgX+LlZmYlp2mv7WqioaZmJeVmqOsubWnj4aEfYJ5gI+NinFtg4N9dIKDhIaDgISNh3yFkpKQhHdycmtpcHaFfYKCh4R9goqKg3t/jpGjq56enpaVg6Crq7q4qrCLZ2yHf3KHbm12e3Bscnh2dn56bXB1eXFwdHB7jIGYq5+UgoWCgnhwc4F9gYaLcW/f3sGulKGglKGho5mLl6yroZanwsHQbHZ6foSIgHlybW/KgM7Rz93Vd3l0c3h+f4CBioaQjY6QiY2ZloeHlZKHiJChq6apnpmVjJKcl46MiH5tb3Z/eW93d3d+fXVwdHyIh4iHg35+ioaAeHh0a3Bsc211gH1212x0amhud3hyc4CIhX+AiJOblJ+TjYiXko6Nt5mHoI+amqCWo6ajrbyglFBTgJpaX2NeXWNiW1hYVKGiWVu0sVmspVhVoZuZk46Qj42HjIGDgoSIkZeYpJ+Wnp2loZiSjol7lJePg36LloqAipuonpurqlaZkXfAxHaBkZqflIV7gYCNnJyFhIuNkaKSk5SoiYaOmJOdk5mgpGNrZbCQlaKipKCwrZeVnJ+eoJSigKZWop1SWV5oYlhaq6dgYl5dW1iwpJOJkJCUkZWZlp6cjJCEhIOHio2Rh4iAhJSdlYaKfX2Ek6Rer5WHj3p3hI2KjIaIe3p+jId5gJCgmICElaKroJSOj5qcmZCMmaGqpYt8hIWIlJOQe3mOm52foKGYlJCRjnByiIFvcG9yfG9lA319fpV9gn6QfZt+Cn19fn5+fX19fn6ffeF+hH+JfoZ98H4Ef35+f4h+hH+CfrV/hICVfwF+hH+VfgF9/36SfpZ9i36Gfc5+AX2qfgN/f36Lfwt+fn9/fn5/fn5/f65+Bn9+fn59faF+g3+SfgN/fn6Hf4J+hn+kfgF/yH4CAgQAgMfQ3PH56P7p4ujO2/mQnK2roqSPgcuvvsmm4bayqsNmYmNpvbfFtb23aW9rdXN2f4qCg3qBjoiWmZOSmY2Nf3R8gIOEenZzcHd2c6urus1tZcd2mZ2lqJWfpJmSpLrDt6u31tbygurX3O358fD384KF+fiHi/PvgZmnt7+3s62zgLCgkZqbnKKvuau8s7OhmLG4vr+ttc7U0cLKubfFw8q2ube2rKm5v8XEysfGxbzLv62qrrOusqCRlZ6cj5H8i56mpJqjpJ6psLq6zN/d4M233urInZbphILdzZuKiYugvsjk0fiSqa2+yb2ol6+0pKywp5ykmZy30fHg1rasr7i2gKq/wq6mqrKqkYqjvMzf1M7AurajncPAr5CftbKsu8OqqbrQ1cvVxrjV4r+2yePVzejf8cPE3Ojj0MK6zcm/zOHs79zQ0efsz83T0t3g5u74gf71g5eQ9fLs4PL37uvyhYGDkI2OoZqRi5e4tLO7wbiS/o6fuuHHlc20iqq7u9LQgNXz69PW49vFw8Ld4+nj4MfCy8nExc/c5OPk4O/y7Ozgzb+5sKWfk5SdoaelmqGckpKajYaDgvj5+O77+Njz49bZzufy+NrKpo/OyuL/kb+1lpWbk5yuuMXL0M/Iy9vcz83Mwayzrbi7sLSvw9TPurGttayWlJqXoKOirqmcorm0gLLBuqzAxNna5c7R2drQxcDMz9C6raOks7OvpJ+nsbjI4unu/Obe39ze7PfW1tbg69PMyLWroaKelYqLko6Bgpykl5u0vcfB29rXzrakt8XQzbzEsa22srCmtca+ssG5lY3m9/2BhID+7t7N0OrnzdXJxs3E0MbY6ebl4Pn/gv+RgJ2OjZKKjZmYjpeiqKmki4GNkY6Mjp+rq7K6tLKtsba8wrippaGipJ+lqJ+gpKXAo4z/iY6ss5OOlI+Zj5SgnJCZk/2KkZaRl5eTnKSYmqO3qpKqssHY0rCjrru3pLi81cm9qKikscLJr6ytnrzIua+uyfPqhYaJhvrzgoSHg+ffgOrygYP4kY2PgvjXy9f48/Hk9PP+9/XrxqiWjZ+imamakZSZpaellpmhsrrG2MGvtsnb4dHS4dTc4+fygPDu6tHhgfvgyMDEyaaL3bPwvdXP3uXUzba41eLGvtDexLnI1+r0/Pf9jI2G8N/N1N3bxMTF09rj9oWQlJucg+zcu56EgOTpgaLTgJimqZT9+/746vSA8uzUz9DO2NrAtrrAwsjQ3uHa1ublgf3w49jLt7LJ3dvGzuDc0NjdztvDt7rK4uHQy8/BxbnDwbuxsK2rsq+nrLGfsbTFzL6ro7CyvMe4r6axpZ6DkbKyyb7FwbCYq7y1l5qC4oqrtaegnZyT/f3mgKq4w9fhzePOxdK1v9p+ipyWjZF/dreitcGh4Lu/t9FwbWx11MvYw9LLc354g39+iZeQkoeNlo2boZycopeajYCJjZKVioJ/eoGBe7O2yN53b9R6mpykp5KepZiOoLO6sqWv0Mzjed3Mzdjl3tje2XZ54d95ftnScIeUoaminZiegJ2MgImHiI2YopOmnJyMg5qgpKaXnbO4t6qvoZ+pqLKeo5+gmZWhpqqosKurrKW3qZiVmJyXnI1+hI6JfoDge4uQjYOLjYePlp+crb67wa6ZvsitiYHEcG3Kzp+SkpKpxs3lxeWElJSntKaWh6CjkpqdlouTioqiuNXDtp2Wm6WjgJarrJiSlZyVgXmMoq/DuLGkoJ6Oh62ml36LnpyXpKmTkaCztKq4rJ66xaObrsO0r8W5zKSktr+9rqSarquiqrvIzbywq7zErbC0r7e8wsXMatPLbH93xsjGvMzRysfKcGxsd3RzhX52cXuYk5GZn5l403eCmLqlf6yVdpCbmaypgKrFvaistrGen5yzt723t6CepaOfn6atsK+zsb6/ubyyoZiVjISBeHiBgomHfYWAd3eBdnBtbc3PzcXU07PQv7O5sMXL1b21k362rsPaeqWcgYGIgYiWnKqtsbGprLy7sK+upJGXlZ6flZqUprSyn5iSmZWBfoSCioyLlo+Di6KbgJmqoZOoqbu7ybC0vLuwpaOss7ajlIuNmpqYjomNl5moxMrO3se/wb3BzNW0t7W+y7axrp6Wi46LhXt7gH1ydI2ThYefqK+pxMG9tqGRoa+5t6eqmZiinp2To7WsnLCsiYTU5uZ3e3Xp3cy5v9rZw8m7t761wrXG2dXTz+TqdeKDgI9+foR5fYqJfoeUm5yaf3N+gX57fY6amJ6nn56anqOmq6OXk5CRkoySlYyOk5SuloDlfICdo4aBhYKNgYiTjH+Jgd57gYaBh4aBiZKIiZCjmIGXn6q7tp2SmqejkaWmvrOokpWRna20mpeYi6SonJaWrtHEcHR3dNbPb3Bzb8C3gL/Ga2zJdnJzac2zprDNxsa8y8XPy8fApI6AeYuLhJWFe36Djo6LfYGIlZ2muaOUmqq6wa2vva+2wL7Ia8bIx67AcNK6p6Ckqo55w6HXp7irs7utqpWZtL+jn7K+pJuqtMPN1M/UdHVyzr+vtLy8paamsrjAzW53eH6AbMK1nIVygMfJboeuaH2IjHrOy9HMvcpqx8Wvq7CutLSelZqeoaiturm0ssK6adDDuLCmmZWpu7qlq7q2rbS3p7imnaGtwLuuq7CkqZympKGYl5OSmJeNkZiGmp2prqCPipaXoqueloyYjopwgJ6WqqGppJaClaKbgYZwwXiVmoyHiId9297JgJefrsDJuMi3r7amscd0f4yHgIR0bbGer7md69LZ1vOCgICJ/PL45PTuiJWSn5iVobKtrZ+kqqCttLKzu7G1p5mkpauwo5mRiZCQhs7V6P6JgfKCn6OmpZSeo5ePpLO3r6SrxsXZccq8vMbUy8XNymtuz8pucsrEZnqFjpWQjYiPgJCBdX19eXyGkIKPiId5coWKkJSEiZugoJabj5CWkJmKj46MhoSRk5WVm5aXmpOakYSChYmGi35zeX95b3LNbnl/enB2eHd9gYuNlqSio5SFoKiWfHK1ZmG8zq6jpaS50tPhxNd6hoWVopiOgpSYjJCTioKGfYGTobqtoI6MkZmXgIyamIyHiYuGdW18jZqln5qQjox9eZSNhHF8jIuHjZCAf4iUlpGbk4ufp46HkqCWkaGbqI6NmJ6ck4uEj42Fi5iiqJ6UjZmdkZOXkpWanaSnVaqmWGNeoaGhnaqvqaWqXFlZYF9dZ2RgXWR1cnN4fHhhrmBoeY9/ZZWGZHZ9fIuKgImVjoSHj4yAgH6NkZWPjoGAhYOAf4OFiIWFhY+NiIqCd3RxaWRkX2BmZmlqaG9sZWVsZGFeXa+xsa63uJ+1qZ2glqevt6WcgnKrp7XHb5GLeHZ6dXyIjJaWmZmTl6enn52akH6DhY2LhIaDk5+djoeBhIJ0cXVyd3t7hH92e42IgIaRi4KUmKqpsaCjqaadlpeeo6SUhX5/iIeJgHl+houar7S1wrGsr6muu8Opq6iutqWgnI6GfYB9eHJucXFoa3+Ge3+VnaSgs7GtoZCEkqCqpZmekIuTkZCIkqCdkJyagHvH0dpydG7czsO3u9DWxMe4tbuvvLO/z8vNy9zecNx+gIl6eHtyd4GAd32JkJGKc2x0d3Ryc4OOjJKWjo6KjpGTmJKLiIOBg4CHioKFioqeh3TWcniRk3t4fHl/d36Hgnh8dc5yd3t5fXx4gIN6fISViXqNk5mkoo2DipKPf46VppyTgoWAiZaahYSCeI6Qh4GBmrquX2JmZLu2X19iX5+OgJKeV1mkXVlaU6OOiZGmoKGbo6CmoZ2aiXduaHR2cnxvaGxvd3V0a25xeoCGkoZ9g42Ym4+QmY+UmZujV6OmpZShWqWUiYWHinRmr5rHj5SIjJOKin6CkpmIh5SciYOOlKKrsKyvXV1cp5uQlZydjY2Mk5ihplheX2JiU5iPf3BjgLGzX3GMUWFqbWGpqaigmaBToZ2OjZGNkY+Benp8gYiLlZaSkZmTT52VjYqDfXqJlZeHiJCOiY+RhpGDgomToJ2RkJKIjYSMioaAgn58f395en9zf4OOkYZ6dnx9h5CGgXuEe3djb4WAkImOiIFxf4mCbXBgrmh+gXZ1dnVqu7yrjX2IfoV9hXyEfYZ8on2EfAN9fXyTfQF+iX0Ifn59fX5+fX3GfgF9l34DfX5+jH3sfgZ/fn5/f3+JfpJ/AX6Gf4J+vH+TfoR9/36VfgZ9fX1+fn6WfQJ+fbJ+AX2QfgF9sX6Ef4J+hH+EfgN/f36Ef7J+AX+FfgF/iH6DfZh+g3+NfoZ/hX4FfX1+fn6Ff4Z+AX+VfgF/zX4BfYh+g30CAgQAgLavo5WG5u7l6paNiI7qy8rXzPjk6t/X0dnSuJ2vm4uA5tx8zLe5q8HFwnN3gIiZlp2lnqKLf42PlYt6e3yHfc3Zh5KLj3uBl56bop2YlqecjoGSn6qeorHL4fTs6Ojw/5CYl52Wlp2jj42OiI6VlpONi/nl3IaXn7K/rL+4s7KtgKqgm5OPlpaXoKqWiouYp6Shm42aoK2opZiUmaasppuMkIqBl6i5vKyenYyLkP2Kh4yimIeUk4ydlouEhYqFg5ehoaSak6urnZyul4P29Nzn4r2VioyXlo2NiYeFipGDhJ+73vv9kpOIlJL86ePQ4piZiomYtsS7q6+hio2aqqCigJunpZmjo4ybra/F0c3S3N3a0rmpsKy0p7G+v7mhqsGvtLSwucfEv8bxgv+HhoL25c3g0NeAgerg7ujs3+vx7/uB9Ovd5ezw5eX1hPDm5N3ugo6RiIH++eTh9YCHgfOCiJOSlZyjnYaLqbW0qKKUoairkJOopbXGv6igmqGuxNPVgM3R2tvW2NjR0NbUztTY4dzY3dXT1tbWz9fYzsjW5Ojo3tDGr5ygprK1oqCrpKWopKCmoJWfl42FhYybmY35gPLW3eiD/+Lq3cq/oZaYlqCU+IHk6ZWkhtXnkLfGusnH0cCsucS9u7y7sbrAubm3t7K1sJ39hY2bmJqaoZifsbGxgKarraW03efp4Nvq/ufe5urj3Nnk4N7H4+zf0ODbxMC5u72+3e3pzsDD0d3XzdDSzNDQxLi+r52ttsTBr8DN4vry9Pjp6t3g6dvs2eLf2tPX0s3Nx9fL0NbP2Oray8HG1uDYwba4sKq2up+aj5SOgvH4hYiQj4uFk5yUlpils6ijgJeZnpiXm5uhrMirl5WiuLOgr7jFydK+yeLf7oT9/tTm4snDsba1qpybtM3NycrKvbiqrJ2ooqGkpKaitrSenaa7tqulmLaunpKbr6mnp8HAs8nX1NPLwdPt48/D18bL0cG90MjDubzCws7f5cu10O72hZWqq52LhYyOi42IgYCAgO/l3efwiJCbsbGlj4P57OLn1MXC4MnDz8i6sqOQmJOOkpGR/+buj5SNlrHCvr/f94X99vD57/b86fj76+fPycvLxtDU0sGtsLHKur7UysK+wMPU3dnCwbC319XV4Nzj1vmK+un2+/329fPcvsjd6O3hzdvwhISTmp+ahoLw2NTZgNfX6OPi4vOHg+3q9OjT3+ng3cvP3uPm193v7evs7+zx48m9vby8urTBv6WUl57A0+Xfvq2xwM3m8/Dk2dbT2OXUyd7e08u8taqYpaKGioiRl5WUlYuKhe6MsrCil4OEhYWFgPfsz73HgJGRh/iYtq2Vio6ZqJ2Xno+jqrO/tLq3gKCakYd71NvT1oqDf4jau73RxO3X2s7EwMrGr5SlkoV75eB/08TItcvNyHl9hI6enKKnnaCLgY+RmpF+gICHfdLhi5WNk3+IoaKbn5uYlqSbjoOapaydoq7B0eLY1tPX4oKKipOHhpCVgX6DfYCEhoSBgN7KwnmGjJyplaymoJyYgJqSjoaBhoSGk56JeH6IlpKPi4CNkJ2Xk4qIipOZmIx9hIB2ipWgp5mKiXp7guR7dnySiXiDg4CSinx3eoB7d4iNi4qBfJOUiISVg3Lh58zU1bSWi46dnZGTkpGNlJ2LjKrB2e3ohYZ7h4Tm3NPAz42MfXqIpa+ml56RfYGMl4yOgIiUk4mTlXyHmJiqsq2zvMC9tqGTmpafkJijo5+JlKiUmZeUnKikn6PJbdVycGzPwqu/rbFsbMS8y8bLvsfLyNFqzMm6v8PIv77MbsfCwbzIbHV4cWvT0b64yGlxbMttcnt4en+Igm1zjZSUiYZ5g4qOd3qOhpamn4uFgoiSoqusgKSps7Gsra2oqKyppKuvtrKus6urra2qoamsoZuptLa3r6WfjX2BhZCWg4CMhYWKh4OMhX2IgXVubnWEf3bRb9O2uL9t0rrIv66miYGEhI+C1nTLz4eUd7vJe5ypnaups6SQn6qkoqWjmKCnn6Cfnpidm4rYc3mHg4WFjoOKnJybgI+Vlo2bvcPHvLjH28W7w8jAubfCvb2mvsrAscK8pqWfo6amxNHOtKWotcO8sLW4srS2raComoqXnqypm6mzxt3Q0NbJzsHGzr/OusTBvrW0sLKyscSzt8C2v86+s6yxwcq/pp2inZahpY6Lg4mDd9jlenqCg352hI6EiImVpZaQgIiNjoqKjYuPmrebhoSRqaePnaOus7+msMnD0nXf47vNyK+qmp+gmo2LoLa0r7K1qKKWmoqalY+Qk5SPo6KPjpasoZiSgqCcjYOMopuYlbGsnrPCvLmzqbnUyLSqwa2xuaaitq6tpaatrLbFya+dudHUcoCRkYV1cHh6dnl0bGxtgMa9tb/HcXd/kpKIdGrLvbe/sqSfuKWfrKedmIt8hIB4fX2A38TJe355g5yooJ690G/SzcXOxczSwM7SwsGsqqyrqLSzsaSTlpOvoqS1qaCeoqKwuLilpJOauLOzvrjBrs11z7/R1NfQ0tG+n6zCx8q+qrXJbWp1eX59b27KtbG4gLa5xLu8uchwbcK+yL+su8W6uqqqu7/CsbTIxMLEyMXPv6afoaCen5ehoox7gYmjsMK+n42Sn6rBzcq8tLSxtMKwpru5r6mfm5KCkY9ydnZ9goF/gXp7dsp2mZeMhnBxdHV0cNnVuaSvcX+DedaFoZqBd32HlYqGjH+Rk5ikmKGggJCKgntyydLLzoF7eHzQtbnQwd7M0Mq/t763pZWkk4iA8veK7ubo1OTi4IaKkZqppKitoaCQiZOSmpKGiISFgOPykpqUmYyWramdn5uZlqCYkY6jsLahoqy6w8/HxsfKz3V+fIF4d3+Dc3Fyb3F3fHl2dM64s211e42ZiZmTkJGNgIyEf3dze3t+h45+b3R7h4WBfnR9gI2Ig3x9fYSMjYN2fHptfYONlYp7eGxtc9Bva25/eWx1d3WFgXNvc3Zzb31+endvbYB/dnOBcmja6dLV172jm6W3s6WqraegprKgnbXJ2OPgfnt0fn3b0sy6xIKDdXF9lJ2Xi4+GdHd9hn6AgHyFhYCHiXR6h4ePlpeZoqWlnYyFi4eMgYWKioh7got7f358gYmJh4ilW7ZgXlyyqJSdkJVXWKWhqqaroKWqq65XqaabmZufm5ymWKCdn56lWF5hXFitq6Cao1VaV6VYW2BgYmNnZFddcHV2bmxjam5vYGNwa3aDf3JtbHB2gIaGgIGEiomHiImGhYWEgISFjIuKjIaGiYeEe35/eXV/g4ODfnZxaF5kanR5bmtzcHJ2c291cmtya2RfX2Rua2a3X7Sgo6Zcr6CrppqQfHZ3eIB4yWvCw3eDbbG6bomUjJSUm4+Ai5WSkJOSiY+WkZKRjouQi3zHam13dXd3fHV5h4mMgIKFhH6Jo6eqo6Gsuamkq6+sp6OrqayXqrStoa6ol5aSk5KVrrm2o5qdprCpoKOlo6OjnJGXi3yIjpqYjZmjs8O7vsS5u6+0u7LArLCysqqnoqOjn66lqq+psLqvpZ+jr7uulpCVkIqRl4OAeHx5b83VcXR8fXZvfYiAgYOLlo6LA4KEhIR+gIWNo4x8eoeZk4CPmqOlq5mmvLfAa8/Qr7q1op2MkJKKg4KUqaaioKKdmIqLfYmGhIWFhoKTkIKCiZ2ViYR3j4yBeHuKiouMn56SorCtqaOapbisnpqunJ6klI6dl5aSlZybo66vm4yku79lcH18cmZiaGpnaGVeXVqgk5CboFlfgGZycWldVaCXlJqPiIaVhYSLhYF+dGpxcGlqaWi5q65maWdtfYR/f5OYUJ+fmqGdo6ecp6eZmo6OkJCOlJKQiX1+fJCHiZOLh4OEhpCWlomHfYWYlJOdmZ6Qpl2roa+xs6yurZ6Jk6KlpZ2PlJ5UUlpbX19XWKKUk5mZmJ+anZmgeVZVnJuglouYoJubj4+Xl5qOjJmamp6hnqSciIKEg4GCen+CdGlsc4aQnJqCc3Z/gpKenZaSk5SXnpCLmJaPjYaCe254dWJoaWxtbm5xaWhmtGeCgHhzZGRmZWZjvbunmJ9kb3FpwXWNhnNpbXR+eXh8b36BgoyDjY+FfoR9hH6TfQN8fH2HfJV9gnyffZJ+g324fgF9nn6ZfYV+hX26fgV/fn9/f4Z+gn+KfgF/iX4Bf4V+hX+FfgR/f39+338Cfn+EfgF/jH4JfX59fX5+fn19mn4Bfft+gn2qfgF/1X6Pf4V+iH+WfoN9in4Bf7B+AX+Sfoh/i36Cf85+AX2LfoV9hH4BfZN+AgIEAIDmgOPngIL++c7W+YaQgtnz8/jyhPzvy8bN3MKpl6Cjl6K53PDt2behsJeJoLrEzqaNtcjtgYL7gvuA+tPR2dfX0s/j6vbrzcC2p6WzztDg9PP0+ISaoYb7ifuF9+7r5N7g1Nz01OX4hYiDhImPoKmopqWemJekqburno6QlYyKjYCIk5OF/vLq1dTSy8nQ2NXIzeH09NvUz7y63ez/hYaSn6mxpKmor6CstayopJ6doautpJuVlpaM+/Tw/I2KjI2PjomCgP/++/3Sw5+IiYCCiYV9gHt+f4SIio6nxsnM3+/q9PiNlKekj/7a6Oj8oqqjnpuZkZibk6KjkZynrKmioICjlpevu7Wzx8DDyLmxu8PR0c3OxbavwbG2tbO0rZydzdrQytPUzszV5fiGhpOakIPhwMng6+338viFhunj5fP539nq7/iHjImFk4nZrqrIy+b04Ofw9e7viZaM7eb+hvmKlI+Lk5SVkJCNho+WoKqysLK0uq+2qbK0sbSwvc3V2oDa1srD0OTRybi1rq23uLG3ytnc19jc0tPj8Ojp5uDY4/Tl1MK1raOksKyfmJ6rq6WgpqOYlpublZCHiIOHi42GhISBgoX88/n75P78287Frpu3pIGNkIOLiYuRiqWynv+brJ+2x9DX7e/h07e3v7S4v8i8p6Kir8C6u8K/wsy/soCksK+svNLZy87Oztzm3dnZ3dzk2Oj+9d3i4/Ln2ebu6NvJy9re29/o3+Hn2djm6Ong3tXSycvX2fCEgvTu58/EusvWzcfKytTFxMrFubTF1s/T09DQyuDe1t7y18za4uXq4+Xt1dbi2eLXzMTOycbOxLa+1M69y8rA4e/y8enf4IDZ0si/ubW6x9jo7vvu5tzf5N3o2Nbg39XW5/P8jY6J++DW3PD87Obz7fHp9v+PmJiSmZKI+/Lrv8HRx9vRxMPCu73FxczJw8O6wr/Ax9zIwtTa09rSw8nS0dXOz9vr5PGChIOD9vSGjI+Kg4iGhICKjJOZm5aUkpCRkZSG+/WA+IDmxtDthIaWrLm2sLSyo4/05erj9v7s2tTQvbzAv8Ta39G9xueA8fj++fXmz83P4+6CkIuJjImGhP/q69W4sr26qaiytcvUx8XPwKuiramaq8LZ39rS0ebp6OPf6uPWs7fU4NnP3ez7/vqHg4Dxg5CV//qBhZGTlZGPh4KHivry8YDk1c/T2MPDvbO0vLWors7b2s/V0LOer7/e9uvY+YPu39O4wsG0trOumpqnn6Srw8vI1d/Rzcy9vqawydnKusS/xsLBwLeum4D1i4D60dSriqTvnrrOx6qB/4qIoLeppPnX1YC3r9DSw9+eo5KB/P7m3NzVxYuMgvfRttTd6tzs5YDWeNTUdHbn5r3G53yGdsPe4ebfeuTbvrrE1buik56fkp2wzuDj0K+arJWHoLe+yaWNs8PgeHnreOd368LAzMfLyMfb2+ffwrauoKCwxsHT6eDe4nmNk3jgfuZ85NvX0svSyM/nwtHoe3x2eXyBkJiXlJOKg4SSlqeZjX6DiYB/gIB6hYd56+DZyMfGxcHI0c2/xtnm5s7Jybaxz9rqeXqDi5aekJaVm4yWn5iUkYyMj5mck4mEh4mB6N/Y4H55fHx/f3l0c+Lh4OO+tZiIioGHjod/hX+DhYqLjJCmwsLB1OTi6+2FiJmXhu/K2NfkkZiTjY2KgYWIg5GUg4yXm5aQjoCRg4GZpZ6brqanq5uVoai2trKzrZ6XqJqcnJybl4eErLmvq7OyrKewvMttbXqAd23Ao6u9xsfQysxuccW/v8zRuLXEx8xvc3BsenK4lZKsq8TQucDJzsXFcnx0xb/ScMxye3Zyenp6dXZ0bnZ6goqRkpSUmY2Vi5OUj5OPm6ersYCxrqOeqrysqJeXjo2Xl46To7Cyrqyvpqe1wLa2tbGossK1p5mOiYKDj42Ce4KQkIiEiol+fYOBfHlxc2xwdndybm5rbHDTzdHXvdbUtq6rloOgkXB/g3R8enuBeJKdi+CJl4ecq7K40M29s5mbpJqdo66jkI2MmKiipKumqbOnnICNl5eUore7rbCxsbzFvbq6v7/Ft8jf1L7Bw9LGt8bNyb+usMTFvcHJvcHHvLvHyMm/v7e2sbC6uM50ctLPy7espbS/tK2xs72tqrCsn5qrubG1uba2r8XBusHWu7G+xMnMw8fQt7jHvsW9tKy2sK26r5+nu6+asbGmydfY2M/ExIDAubCopKGnr7zK0N7QxL/GysPQwMHJxrq6ydHVeXt228O6wtTdy8jX0tXM2dx7hIR/hn1z1NLSpKW4rcC6sLKupqiwr7azr66jq6iqrsGtqL3FvcK6q7G7uruytMTTxdByc3J02dd2enx3b3ZzcW13eH6EhYB+fXx7eX9x0c1t0IC/oqrBbXB8jJWSi4+Qg3TIvsW/0NTAsrGwoqSopKe7vq6fpsVwyszSzc3Bra6wwsdrdnJwdHFubtO/w7WZk6ChjYuYmK23qqaypJOKl5KCkaS3uLKsrMDAwL26x8G3lJm5xLmwvcrY19R0bm3Lbnh+1c1qbHh5eXZ1bWpvccrFx4C+sq+zt6Oln5abn5eNlLK5tqyxrpmIlaK7z8Sw0W7FuK6WpqeWmpuXg4KQiI6TqLKqtL2vrKyfoImSqLitnqejq6ako5yVhm7VeXHevcKbfJPUiqC0rpVy53p3kamZluK+wnWloMDCtMuRlYN16era0dLKuIWFeuTEqsnL2c7f2oDEbMHDa2zUz7G71nN6bLfR09fOb9HKtbG4yLKfkJ2glqGuxtTWxaubq5ePqLzBxKaStMDVc3XfcdVt0ba7wLi+wcTW1N7VurOsoKGsubbF2dHO0G59gGzNcdNvzMfHxsPOxsbWtsbadHFrbXF4gomHhYV9eHiEipiMf3N5fnl4doBze31x29rXxsHAwcDJ1tG/xNPb28jFxbmwv8TUcHF4f4aMgoaDiXyDi4aDgn58gYmLhHx4ent42dHL0HNtbm5ydG5pZ8vKxMatq5eMjYmSl5SOmJKVl5mcnZyrwMPE0+Dh6OZ/go6OfuTFzMzUh42LhoOCe3t7d4SHeICIi4iDgoCBeXeJko+Kl5OUlIiEjpSdnp2em5CJlIuLiIaEgHRwjZeRkJaWj4uSm6VYWWNnZF6pk5WfpqatqqlZXKeioqutnJmipKZXW1pYYVyagH+Qj6CqmpymqaOkW2Bco6CrWqZcYV5cYF9gXl5dWl9jam90dHZ3e3N4cnZ2dHZze4KEhoCHiIB8h5WKhnp7dnR3dW1we4WIhoaJgoGMlY2NioaAhpOKfnRtaWZnb29pZm14eXRxdXNta29ta2ljYl5hZWZiXl1cXmC4srS6qLq2oJuVgneKf2pyd291cXB1cISNgNB5hXuKlp2jtbKlnImLkYmKj5iOfn1+hpOOkZeUlp6VjYB/h4aDkKKmmpmbnaSqpqWkqqmupbHGv66wsr22q7S4r6ianKyuqayzrK6yp6WvsLWuraemoqGoqL1paMLAu6aemKOqoZuhnqWamZ6aj42eqqOmq6mqo7WxqbLFr6SssLa7t73Drq23sLaspZ+ppaKtppaarKOQoaOaucbExsG6uICwqaScl5WWn6y7w8zAtbO5vLrIubK5vLOwub6/bG5ryLarsMbNvb7NxMjBxspwd3dzeXBowLy8l5iooaujmZmYlJSZnaWjnZuSl5SVmaiZlqWtpqiimqKqqKijp7S+tL5oZ2Zpx8Zrb29pZGlnZWBqam9zdHFwbmxra25juLFds4CliomWVFhjbnRxbXBuZ16mnqSfp6eZjo6Ph4mLjZKenJGIkahdqKSqqKiejpOUnp5RWFZWWlhVVqeam5J/e4WFeHiAgI+VjouTioF7gHpueoiUko2JiZeanp2aoZyYgoWZoJqUnqiytLNhXFutXWRnsqtXWF9dXVxdV1ZZWqKfn4CblpWXmYqKg3uAhX55f5SWk42Pi4B3goiZpqGVqFadlpGCjY2BgoR/cG95dHp9i5SQlZmQkJGEgXB6iZOLhIuJkIyIhYB8cF+9aWPBp62Lc4a8epGgmYVoymtsgJSJgsqxs2eYm7y6rryDiHlt1tfLx83DrnZ2b9O2o72+z8TRyAZ9fn19fn6FfYN+hX0BfqB9Bn5+fX59fpl9hH4EfX59fox9nX6YfZt+hH2Jfp99hX6Ffb1+hn+JfoJ/in6Gf41+CH9/f35+fn9+5X+afgF92X6Cf+F+g3+Ofod/rH6Ef4J+ln8Dfn5/hX6Lf5V+AX+Lfoh/sX4Jf39/fn9/f35+i3+gfgF/qn4DfX5+h32GfgF9hn4EfX19foZ9hH6HfYN+iX0CAgQAgI6E+ePq4ueGh46cr6qwsa63vbGhk5OakJOco5eX8t/m5cSjo4OVtMfe7oX01fP7hP3Xy9jshI+ZhZGrrauomY6UlJais6KbpamZmKe4sqGimJuWkoCHlZaNjpCEhI+hn5ibpKWpq6++wcG9z8e0p5iVnZeeop2Zjojx8oOBkZ6YgJqTiZKWjoqLiY2HhImLg4OLjoWHhIaLkY+ip6OcmpySl52irbCptrm3qqCysKehn42PiYKEkpWOh5udi4eNj5afnaOtrZ6Tj46IlJWimIyK58+Bg/Tgj5mOguDWurPY/4uThIb4+PzY15GekZmYk5OZn52rv7q7rbbAvJyOpb60gMG5uMi/yNXMwruxqbfX3unYzMHf6uXLzM6/vcLJ1tPCudHj5YL7goGFj4OJhYKQlpCHhOzw59DMx72/0OX58MTi+P6IhYyYloiQjYT684Dw5vP0/vT4ioTu6t7u7u6IioaB8e6Fkp+Ohpujp6GgqKyutLa9vMG5wM/KwMa8vsPPgMe0rb/NvbLCwrOys7S6wcC9yNjj4uLn5t/j7vv37NnW3eXy9+3n18G1sbCwq6Wsr62fmpiamZ2fo56enJiVl5eOjYOIhIWFgYGChYmA2O6Agvz449zOwNXMwMnNxrC7y9TNyr6jlpaZs7e3w8nFx83Q29rOxsS/v8Xj9P379/72gO3Y6YD94trX2+nu7Oj9gvuGhoD1+IL65dHX5eve2oKBgujO2ff+g4by9Ov38+/s8Pr39fHr+oL7/v+A/4CB9P/06/z49f3z9YKC8+r8goOA9ID+9/Ls9YHr6+vw5t3g5OXj1ujg39nb9/+ChPjw8/3u5eLi/fr55+vj6vj6hf33gIaE+fj37Ofk3+P2gYSRkpKI7ePZ6vD5gYGKioSMh/j6/OHz8eTk1crGy7nQ4OXl2ci/3O+CkJublJWJgPzO3+S/udXUtqu2yNLPztLKsq2tssm6tMPI1+nq94D6+PL7hvfs8OHa5O+JjpKPi5CSgPaEjo6ToaugjpGWlpuE7PSIgIqAg5WTmKu4xM7HwbywnpCLiYuMhID36ejq5/79+u3s8NrO4/H4gJGamJiQhYyYkYWEiZKUj4Pk2c/f3uHy6dfFztHX6eLWzM3P2N7Lu6/L2eSFjISB9uDg7OP28dvV5u/n6OLlgIuL/vX8/YWC+f2Bgvf07uLe2OLy+oDx9v/zgOzlz8jX4e3k2eLu8Ors7Ovg5N/g2cW+sLSxpqOnqLGyr7+5tLbGvLapmJGNjJ2nlffQvuWJm6/H4OLd08/CpZmRq8W2mJWQidnDtZqTqICisLGzoY2M7O/viZqKhPrwjpOE8e7z+/zo8o6cmJGC9vL6/YiMk/T+59npgoyNiJKUgIB54c3W09l/fYGQnpidnpujp5uNgoOLf4KMk4aI3c3X3L6hoYSYucjY4Xzkxt/neu7NwM3ceIOOeIKenpqYiX+Gh4eRn42HlJaGh5Wlno+Sh4uIg3F6iIh/gH1ydICTj4iMlJWWlpmnqqmhs6+flIiFjIeMkIuKgHjR1nZ1hJKMgIyFfISGfnp7eH14d3x8dXV9f3d7dnZ9gn6QlY6IiIuBhYyPmZyZpqekloucnJKPjn6AfHV5hIiDeoyMeXZ7fYWNiY6ZmIuCf396hoaTiH9/2Mp6fOLMhIuBeNTQt7HT8YGHen3q7PPPz4qThIyKiIaMkIqVpqOmmJ6opYh7kqecgKign6+krLiupqCZkpy3u8i8saS8yMausbKmpKasuLWlm7G/v23QbWpvd2xyb2t4fnlycMjNxbGtqZ+fr8PY0aO/1NVxbnR/fG53dXDTym3MwcrO183PdW7Hx7vMyMRycnBuzcdteYZ0bYCEiIODi4uOkpWbmZ2UnqynnKKZmZyogKOTjJypnJGho5SRkpKXnZyZoa64t7e5trK1wMnCvK2qr7bCxr24q5qSkI+OioWLj46BfX2Af4OHi4WDgoB9f4F2dWxzcG9vbG1rbnRussdvctTQvryxpbqvpKuxq5ejsrmxsKmQhYSGnZycqrCrrbG0wL6zq6ijoqfC0tjW09rRgMy6ym/dwrq3vMvRzsfdcdVydG7T0nHYxLO6xszCwHNxcsmxv9vacHXT1czW1M/K0tvX1dDH1nHV1tht225w0tvRx9nW0trR0XBx0MbacXFw1G/c19HM1XDKycvRx77Bx8zHucrBv7u91+BxcdPO0dvLwL292tfWx83DydnbddjQgHRz2NnZz8vHwMPVb3F8foB3z8W9zc/YcXB4eHF5eNjZ3sPU1snIvLSus6O4yMrJwK6lw9NweYGCfoBzbduxwsupor6/opagr7q4tbqyn5qYnrekna6xvM3N2XHc2NHcd9rLz8K8xct2e396eH6BbdBxeXp8iZWKeHt/gIVwxtFzgHNoant6fouSnKahm5iPgXZwcHN0bWjKwcPEvtPT0cTDybevwczRbXuBfoB5bnWAeW1scXp7dWy9tKu6t7bJxLWmsLO5ysC0rK+vucGun5Ouub5xdWtpyra6x7zNyravvca9vbm7anR0zsnT0m5qydFrbMrIwre2srnH0GvIzNXIgMK+ram1vcjAtbnFycLExMS6vri4s6WilpiYjouNkJeWlKWcl5msopyPgn55doiUg9Wypc57iZeovLu3rq2ljYV7kamdgoJ+ecCsoouHmHOQnZ2hjnt90dnZeoh4deLZgYR01NLZ3d7Q24GPiYF029vk43qAhtzn08XZeYGBe4WHgHJrzL/Hxst1cHKAjYiOkIySlIqAd3d6cnZ9g3h6yr/I0LyjpJCmxc7X3Xjav9bddObJvsjUcnqEcHmQkY6Mf3R5enuCjoF8hod6eoWRjIGCeXt5dGVueXhyc3FoaXOBfnt/hIKEiImSlJaPnpuNhn17gHyBhIKBdm7CyG5ue4WAgH94c3p9dHBxbnFtbnV2bm1xdG1ybWtwdHKChoF8e3tyd32BjI+NlpSOg3yMj4aCgHV3cmxvd3l2cXx7a2lvcHmAe36Ghn54dHNud3mEfXd4z8V0c9i/dHx1b87PubTP5Xl9dXnn5u7OyX+GfIOBf36Dh4CDkI+VjJCYl4B1gpCJgJCMi5eRl56Xj4qGg4qfoaujnJChrKmXmJuRj5CTmZWKhJSfn1iqWVhbX1ZbXFhiaWljX62vqJmWkImLlqKtqYygra9cWmBmZFtgXlqtqFmpn6Wpr6mnXlumpZ2ppqFbXFtZp6NZYWleWmZoaWZobm1uc3d8e355gIiDfoF6enl/gH13cnyFfXiDhHp2dXV3fHt7gYqPjo6OjIqMl5+blIiDhouUlo2Hf3RxcHJ0cm1wcnFoZ2hsa25xdnNxcG5sbW5mZF1iYF9eXFtbXmJena1eYbm2p6aelaWel5+ln4yVoaiinJOCe3h5jo2Ol5mYmZ6hqaacl5WRkZSquL++ur63gLOjsF+/q6SipLC2t7PDZL9lZ2K+v2XAsaOnsbarqmJiZLKgpbjAZGe8wbnDwLy5wcnEwbu3xGfFx8plymVnwca/tsXDwcjAvWRlv7jJaGdlwmbMyMO/xme+vb7Fvra3vcG+s8C1sKuuw8llZb63usO3r6qqv7/Ctru1vMnPbce9gGlqysjFvbm3srXBZGVucXVvxLyzv8HLaGZtbGZtasrN0LTDxru8r6iiqZyvu72/s6OYrrxja3JzcnRpY8Kfr7OYlqqqk4qRm6SioKSdjYqKjqGUkZudprS1wGTBwb3EZ7+1tq2orrVpbnFsbG9xYrxkaWpteIF4bG1vbnFgrrNggGFXVl1bX210fYJ9d3RuZV5bW11dV1OknaCinauqqZ+coJeUoKmwW2VpZmdiW2FnY1pXWFxdW1aakomVlJSfnJWLk5abpqGXkZSUmJyPhn6OlJpZXFZVo5aWnpmjoJaSm6CYlpaYU1pbq6qurVpXp6hVVqSjnZOPi5GbpFSeoqiggJyXi4mSmaGclJadoZubm5yWmJOUkYeFfX9+d3R3eX+Cf4qCf4CMhIN3bmtpaHR7cL2hlbZreISNmpiWkI+LeXRtfI6GcnFuarChloKAkGh+iYmKfG9wvr67andraM7GcnNovbvGysrE0XmCfHJoxcPHx2xwdsrSxr/PcXV1cXd3gn6FfZZ+jX0BfoR9AX6FfcR+gn3VfgZ9fX5+fX2EfoZ9hH6Ffbt+An9+jX+Qfol/A35+f4d+gn+GfoR/gn7pfwR+fn9/sn4Bf4p+CH9+f39/fn5/iH6Df4V+gn+Ofgh/fn5+f35/f4p+Cn9/fn5+f39/fn+FfgF/kn6Cf5F+BX9+fn9/iX6Gf4Z+h3+Wfoh/nn4Bf4R+AX+Hfoh/AX6Nf4J+l3+QfpF/m36Ef49+g3+EfgZ/f35+f3+JfgF/tH6EfZR+hn2IfoN9hH4FfX1+fn6HfYV+hH2DfoV9hn4CAgQAgKChpq2jmZyZm5OUjo6UoaabpaiekY2BgpKenJSimJOG/P3p5+/y/of56N3eysbU39m8nqTchYqao6qto5ajsK2zsrGmo6SmrZ6fjIGVnKOuoJmTlYaGip2knqSkmJyPm5yfo5qhooPx6fX7ioaGiYaDlJeRkZOWm5adqLi6saOYgJeXmpqjnZiZmaawp66pnJCWi4+SmKKgmZSbqKWlppmSjI2B9fOFk4jv8PzvgI2RjoCVrLSwsKito4+Hj5qUkpeqnJORjoaMkIyFg/+IioiE8PKBmpmKh4qUlYWeoqGz2uvnxMGxq52I6/WSn6ermpGepKOqs727tb3Er6aotcLIgNHDvb7EzNHFqbnf6vPy7OXWys/Oz8nX1M3S0sjR5e/e4/P+iImIiY6MhI6Ul5eI3cW/wtTK08W/0uHa2+yFl4T354Kcj4TjxuuFio2Agfbd2u37/4iOjvje4vSCh/77k56SjJ2iqLCgmJyhqq6flaarq6eyvb/Cxsy/srTDwse/gLO1r6+0t7vDycm8tLa2wLi6vrvFzdjk4ePp7evq6vPs6vH5++3g5eHf6N/Nu6iqrauoq62mpKSmq7CxrrCtppyVmJiPjoyNiImNkI2Lh4P/5fSHi4X68PyF+/Lm4NjMvbDEwbzHz9bg2cPEyM+7xcfO19HOyL7G0MrU1tLk2tTVgNbSzNv1g4eAg4P4gIWDgP/78O74+f3x7YGLj4uC/4GBgPqHkYqAgI6RiomRlpGIhY2SmY/98oeOjImHhISB/vL26unp5e7x6eXf4d7a0tfs8PLg4efl4u7t7PGCh4P+/omIg4WIiYr664L68YqZjpiglZWYjYP18vLj3OLk7vXtgOjX3eLk5vH67trDw8OzuLvA2uTk5tjCsKmvnI6VlZqir9zp7+be2tzi+fz79fqA/vbr6vHq4Nza29/c4NvAsdrb183a8dvTuMbOyr3AxsO+wsXE0uLs6+Pm3tzixr/J4NjQ2+j17vn9ivfk7On4+IGPhPnu9oKOhI2NlJGBhoqUgJyeoquxvMLFw7yyrKqjm5yWlZeWmoyEgYWGiZSOh/rj2dji7vyGiYT364KEhoePlZH55t/0hfTp8IGJg/LbwL2wo6y9w9HK3uTIydfd6dvwiYWKmZiI9tzd3ePf2M3T2dTTwMrCxNLk39LG0uDp0c7U6vX7h/La7fbp2Nrp+IuHgICIi4mG69rX5v/138fG0dTPy8a7t8TFxriwt8vZ3M6umbTL74T76tvDwK2psaqwq6C0raKdo6m6u7G8yMO7oqa0w7ayr6GOlKCN7/KEn7PByMe8samikYDahI6PkIOCi5+ekZe+zs3NvLW9ta+zsa64zNDStLrBw8C3p6ytop+igI2NkJeRiYyKi4KDfn+Hk5eLlJeNg4B1doSOioORiYV75+XS09zg74Dp2dDNvL7L1tK4mZzRfn+LkZick4eTnZqhoZ+TkpOUnY6Qf3aJjpSdjoaAhHh5fY6Tio+Qh4x/iouQlYqQknbZ1ebrf3p6fHl1hYiDgoSHjIaJlKGjnY+EgIWGiYiTjIaFhpObk5yYjICFen2AhY+Nh4WMlZGTlIiDfH104eF6h37b2+fcdH+EgXGFmp6YlZGbkX10fYqGhYiYioKAfnd8f3pycNZydnp33eJ2jo9/fX6Hh3mPj46gxdPLqaqgnJF91+KFjpSXiH+MkI+UnaalnaSsm5CQmqWpgLOoo6SprLGpkp2/x8/OycS2rLCwsq+5ta+0s6ivwMi4vcvWc3JwcXZ0bXR3eXxyu6akqbqvuKqgsr+1tcNugHHSwm6GeG+/pMhwc3ZpbM+3tMjW1HB3eNC6wM9vc9XRfYd7dIKDh5OFfYGFjJGDe4qMi4eRmZmcoaqfkpSin6WegJKWj4+UlpieoqWclZWWoZeXmpaeo625tLa9wLy7vMO7t73FyL2ws6+uurammImMj4yJjI6HhIWHjJGSjpGQi4F7gH94dnR1cHN3enh1cW/Yvs10d3HYy9Rx187DwLmvoZGlpaGwuL7Ev6mpr7ahq62yurS0saets6q0uLXGvbe4gLmzrr3RcXRtcXDSbHFxbtrWysjU1trMyHF7fnlu121tbdV1fndsbXt/d3R8gX1zcHl/hXvTynJ5d3VzcnBv28/UyMjIx9LUysTAxcO9tbrP0tLBwcfFw87Ny89wdnHZ2Xd2b3B0d3jTxXLZ0HqJeoGIfn+EenHTz9HCvsXG0NXOgMq6wcXIydLb08GqrK+hpaerw8zIzMCrmpWdjYGIiIySm8LP1s/HwcLI3N7b1Npx4NjLytPOxMC/wcS/xsWsmsDCvbXA18C6nq63sqaqsa2lqKypt8XMycHGwMDEpp6sxb+0v8zWztfcedXBysfU1HB9cNDI0G96cHh4fnxtcnV9gIOEh42QmaCgm5ePiYiDfH56e357f3RtbHFxcHl0b866trfBzNdycm3NxG5vbm53fnvSwbnMccm9xGpxa8aznp+ViZGgorCpv8mopbS9x7fLdG9yfnttzLq5t7u7tqqwt7O0oKqho7TGvayir73Gr6uyxs7UdcqzyNDBr7PC0XhzgGp0dnNwwrOyw9jPvKSlsLKsqamemqqtqpyUm663uLKWgp6x0XPYxrqlpZSSmpaalIyhmo2JjY+foJWeqaegiY2ap5yYl4x8gpB90NZ2i52qr6+jm5WPfm++doGAgHRyfJKOf4SlsrGwoZ2mnZaamZegsbS3nKSrqaegkZeajoyOgH19foOAfH17fnZ4cXN6g4d+g4N+dG9naXV+fnmEe3dx1tjIydPY5Hfd0sjDsrK/y8m1naDOeHd/hYyOhnyEjIuRkZCJhoWEi4GCdGx9g4iOgXt3enBvb3uBfYCCe391goCEiYGIiXHRydzgdnBwcnBsdnd2dnp8gXx+ho+SjoJ3gHZ4fX+HgHh3eYOIg4qGfXR2bXB0eIB/eXuBh4SFhXl0bW9ozNBtdW/JytLMbHN2c2ZygomFg3+FfnJrcHx6d3mGenRycmxvcGxlYblhaG1w1ttwgoN7eXh+fnKFhYKMq7aym52Tj4d5z9V5gIaJfXR8gH+Ei5OTkJSZioF/hY6RgJiPi4uQk5WPfYehqbCvq6iclZmam5ebmJSWl5CUnaGXm6axXl1cXmFhXGBgYGNdoJSSkZ2VnJKIlJ+bnaNZZVytoVloYFqciqJaXF9WWKiamqmyrltfX6ueo65cX7WxZ21lYWprbnZtZ2lrbnBoZW5ubWtyd3h6foR+eHmDgoWAgHZ5dXR4eXt+gIN9eXh4gHp7fXqAgoiPjI2PkZCSk5iTj5KWl4+DhIODiouFe3F0dnNwcXNvbW5yd3t7eXt5dG1pbW1nZGNjYGNoaWdjYV+4oq9iZWG5r7ZgurWuqKKZjoGRko6boKWsrJyanKGUmJqfpaCdm5SVmpeen52qpKKhgKOhnKm5Y2ZhY2O7YGRkYsK7sbC9vr60s2Vsb2tkwWFiYr9nb2lhYWptaWhtcm5nZWtxdWy+t2hvbWtnZmVjw7u+tre5t72+trOxtLKuqKy8wsKztLi4tr69u75mambExWxrZmZpbGzAtmfDu2x3bnN5cnN3b2fCwMC0s7u7wsnFgMOzuLvAwsbJwLKhoqOXnqKlur65vLSkk4+Th36Df4KIjrHBysW9tbm9zdHOyc1ozse+u8C9tbGurrGwt7WgkLGvrKSrvKqnkZ2in5eam5iTk5aVnqmzs6yvq6mnkY+br6qgqLW7tr7CaLaosLC9u2FqYbevuGFpYmhnamheYmNpgGxqamxvd31+eXRuampnYWNiY2VjZl5bWVxbWl9aVqOTlZujrbVeXFmppVtbW1pgZWOvo5ynWaGanlRYVJ2PgoN7dHmDhI+LmJ6KiZGXoZmmXVpbYmBYqJyZlJeVlY+QlJSXh42IipOdmI6HkZuiko+UpKuuXqaXoaadkZKdqmBdgFhdX11boZiYpLOrnIqIkZSPiomBf4yNjYR+g5GVlZF/c4iUq1yvo5mLjYKAgX6Df3uKhH14eXqFh4GIjo2IdniAiYKCgHVpb3hqvcBmeYmTl5WKhH57cGSsaXFxcWdocIB8c3SNmJaWjYqQi4WHh4eOmZmciY+VkpGMgIOCenh9oH6HfQF+jX2yfoR9uH4FfX1+fn6EfZ9+AX2EfoJ9ln6Cfbl+jH+OfgV/f39+foR/g36Ff4Z+g3+EfgR/f35+8H8Kfn5+f39/fn5+f6x+hX8BfoR/iX6FfwV+f39/fpJ/gn6If51+BX9/f35+h38Ffn5/fn6Kf7h+AX+5fgF/hn4Gf39/fn5+qX+HfgV/f39+fod/hH4Hf35+fn9/f5R+hn+efgF/iX6Hf59+AX+lfoJ9jH4Bfad+AgIEAICsr7a7wq2qraGjoZ2fr66dmZmemp2enZiSkpydlpqFjJmPipKlpJekv82vpKGfn6StsL2yqpmPiYHog5WfkJSeoaajn6SVkaCnoJCLjJqdpq+sppeF8Ort+fiCgPSBjZOPmJWLkpaWn6epqqumnZucpKKaoaurpquwqZqYpbO2roCsoJ2YnZ6coZyQi4iKkJaak42QlaGhqKuqrKmhm5WUm5aXrbi4rLvBvsW4ubrDv9HHvLO0vKSZpaOYmpKC8vuHiIT4go2Rj5SNhZSei+vk4uTl/YD5hIygp6CiqamqqJCQnZyYk4mB7oqPiY2PmaWpqKeclJifnJqlr7i6wbS1s4DB0dfZzNPTwNHb3+DQxLq8u8nG2OHUyr+6wszN19ng6+6CiYWCg4mGho2Ph4L05M3U2+Di5NDKz93x8PL5/4qD+9DH6vvu1dj8gfHtjJmVh4ePlpCHho+Ylp2Xj5OFgYqQoKerrbW8wbSvrqWipaywtLKvsbrCxsfMz8i1pq2yuIC8tbWsqa/CycK8q6Kvur69xMe/wc7g5uvy7erw9vDn6+/x8Pf4/YSGgfv48+XRvK+yrquwsa6qtLWinJ6dn6Cop52Un5yUlZaTj4+Pl5eR+/yCger1gYCCkpqK9eDa3uXp6fP5/Ov5hICFgv/85NKzprPL0s/BxMfV0LK9zsq8zYDd1MzQ6vaAifrk6e6Fh4eE/IKLhf/18vT67fX+hZCQkpeNio6G7NXDzYqfo6GZjIuFhYuFhomChYyMhf6Bj5+nt7GipKqppKSemZudnZyXkY2PioWGh42LjZCGhY6KipSblJCSl5qYkYWJj5KUj4uEgoD394SFioyKioDv5eLb44Dm39bgz9HM3+roysXIyb+/xb7M4OPt6Ojr6tja6+be2tPJz+Di3tnW4d7i4unt8vr9/4GFiZKYoaaoqJmcpZLota+94vLf+fz12sbIuMy/xNXU3t7d0cna4djSzNHS1drr5eP0gIWD/4ODgvfl29LG19nxgIyXkZKHiouHjZacpIC3vLnCyb21u7WytK6ppqWinp2al4qMjY6IipCPiID4goaC/ISKjon99oaHiof7hIaDgomLg4eRkY+Liv3u+OLW1tre4Oj1/YmPhv732Njr7+38gvDc8O3i4+ba6N+3pKy4vLmsxePo7Ovs28/R2cjM08zO2+bm2sPGzLqtqrvdhYCOlo+C+O/v89iqrsTFwbrI0s3T0c3CtMS5srC9zt3l9oDr6ePg3tTNx7CTk5ykq6utsbi7y7qsprWrp6GfpqKhoYX7kZWOjJW61+D7gO3m59e+qqGenKispqempr68t7u0sbKrnKewqq+2t7S1vaWRnrDJzcTHt7C8wcG7ubTAvICTlZ2krJiWmY2Qj4qKmpyLh4iOiIqMi4eBgImNiYx2e4h+e4OUkIGQrbqakY+MjZCWlqefl4mCfnbUdomUg4SNkZaRjJOFgpCYjn55e4qLk52ak4d31dLZ5eF2dNlzgYeCioV7g4iIkJmYlpaRiIiJkY+JkJmWkZeclYWFkp+floCXjoqGjIuJjoqAfHl6foSJg36BhY+OlJeWmZaPiYODiYOEmKOfkqCppqyfnaCqqrywpZ2epo+GlZKIi4N02uB5e3XddH1/foN8dIGLfdfT0tXU7HffdXqMk4yOlZSXmIKDkI2HhHt12H6BeXp9hY6Tk5OJgoWLhoSQl52fp52fmoCms7q5q7S2pLW+wsOzqJ+ioKqltr+0rqSfprCvtLW6w8VscW5qbHJvbnV4cG3Pwq62vr/CxLGrrrnNysvN03Vu1q+lx9THsbTZb8vEdX98b3B5f3lwb3d9eoB7d35wbXV6hoqMj5edopWPkIiEiI2RlJCNkZifoqOpramXiZCVm4CgmJmPjJGjppyajISOmJuaoKObnau5u73BvbrCx8C5vcDCwMTCw2ZoZMPDwbWnlo2SjoqQko6KlJeGgoKChIaNjYV9h4V+fX99eXl3f39609ZvbsTPb2xtfoV20cG5vcLHytLX2MnYdHB0cN3bxrWakJuxtrOnqKq4sZajtLCjtoDGurG0y9NueNfBx8x0dHJv0252cdrSzc/XydHbc3x8fYJ4dXlyybamq3WHi4mDd3VwcHdydHZvdHl4c9hteoiPnpeIi5GQi4uGgYOGh4aAend6dnFwcXZ0eHxycnx2dX+Ffnl9gYWFf3R4fX+AenVvcHDZ2XR1d3l5enHRyMXByYDMxr/ItreyxtTRsq6zs6morKWzx8nSzcvPzr3A0MnBwLmvtcbLyL+8xcDExc3Q09vc3G9zd32AiY2OkIGBiXrFmpeoydjA2NzVvqytoLapq7e3wsTBta29xb+4trq5t7nKxMDSb3Nv129wcNbFvbWotrnMbHd/eXlvdHVwdX6Ch4CWmpehp5qRl5GQk4+JhYSEgYB+fHF0dndxc3h3cGnLa3Bs0W1zeHTTzXFxdHHObnFubHN0bHB6eHRwcM7AzLetsbW4ub/HznB1bczJrrHFycbTbsi2y8e6u8C0xMCZh5Gdn5qQp8TFxcPGtqyxuKSnsKqtusbFuqKlrp+Sjpm0bIBye3drz8nJz7iLkaippaCssquzsa+klqedl5airre/z23Fw767t7CqqJd9fYiRlZKTlqCltKGSip2UjIiHj4yOjnXegoV9eoCgucHabsjCybujkYqHiJOYkZOSj6WloKKbmZqViJGYlJedn5yepJF/iZisr6iun5ahqKeioJyopICAg4iNlYeFhn1+end4g4R6eXuAent9fHl1dn1+eXxrbnZwcnuJhXeAkpuEf359fYGFhZGKhXx3dm/JcH+GeXuBgoWBfoJ3c3yDfXFubnp7goyJg3hsxMPN1tJvbchseoB5fXp0e318goiHhYaCenh6goB6foWEgYaKg3V4go2OiYCIgYB9gX17f352cnByd3p6dXN3eYGAhomIiYeBe3Z0d3R2ho2JgI6YlpeLioqTlaOclIuIkIB5gn94fHRpx81sa2jFZm9xbnJuanZ/dMzJxcXE2GzKZ2x8gn18goOIinl6hYOAfXZuynF3bW5vdXyAgIJ/eXh8eHV9gYaIjoeJhYCMl56flZibjZuhpaWakoyMiJCMlpyWlI2Ii5OQlZiboqRZXVlVV11bWV1hXVuvp5ean5+foZSRkZejpKiqrF5ZrpSNpaylmp2zW6mkX2ViW1xiZWBbXGJnZWplYmhgXWJmcHN0dX2Bg3p4eHFubnJ1d3RzeH2AgoOIi4h9c3Z6f4CBe3t0c3aBgn17cm53fX58gYJ8fYaOkZWYlZKVl5OPkJKRjo+OjkpLSpKQjomDd3N4dnN3eXZ1fH5ybm5wcXN4eHFrc3FtbW5tampqb25qu71gXqqxXVtdbHJntaegpauxs7i6vLG+ZmBkYcHAr6CKgYiboZ+Wl5efmYiToJ6SnoCpoJqdrrhgacGusrVlZWNhu2JoZMG7uru/trvFZ3FycXVsaWxls6KXmGZ2enp1bGllZWtnamtkZ2trZ8RjbXh+iYR3eX6AfXx3cnR3enl0bmxtaGVkZGhna25mZWxqaHF3cW1wdnh1cGZpbW9xbmpmZ2jLymtrb3BwcmvHwcK9xoDIwbm/sbGtwMzEqKWsrKKipp+qu8LIwsDCwLK2xcC5tauiqLm/vrazurW6usDBxMnIyWZoa3B0eXp6e3FyeWuzjYyYsb+qwsXArZ6cjqCVmKGgqaupoJmjqaikoaWlpKaxrau5YWVhvmNhX7Wnn5iQm56sW2VsaGdgYmFeYGNlaYB2d3R/hX10dnJydHBsaWdlZGNhYlxfYWJeX2JgW1anV1pYrllcYF6uql1eX1ynWVxZWF1eWFtjYVxYWaefpZKMjZGWl5qeo1dZVKOklJWipaSuWaWXo5+ZnJ+VnZp/c3mBgn95ip2fn5udlY6RloeJj42PmJ+dmIiNk4Z5dn2OVIBaYF1Xq6Wjppd2eomLi4iTlY2Uk5GLgImDf32FjZScqVihnpqYlpOQjoBtbXR7fnx8foeLlYh8dIF8enh2e3l5e2jGcHNta26Hm6GyWqejppuJenNxdH6CgYGBfo+Pi4yGhoiEeH2Df4KFhoWGi3xyeoSSk46Th4GJjouIiYaOi7l+AX2bfoV9A35+feB+Bn19fn5+fYp+hn0Cfn2SfgF9uX6Mf5F+gn+JfgN/fn7af4OApn8Gfn5/f35+hn+MfoR/m36Cf4R+hH8Efn9/f4h+iX+EfpJ/AX62f4J+h3+3fo1/pX4Hf39/fn9/f4h+q38Ffn9/f36Ef4J+hH8Bfo1/jH6Df4h+AX+sfoV/nH4Bf6F+AX2JfgF/s34CAgQAgNPMxcPCrqehlZmfsLy5uaWZp6KdqLK+v7KnpaijnI795dXQ6viVqKOkn5SRg4aUk5ykppqOkaKtraqrnJCJjpONj5CPk6C5zMnQ0MLBwLKimJujsLjAubCwrq2vsamzqKuzqamfoaa2xsXCv8bAvrCenaChn6enoJuaqaufoZ2fgKCkqayppaiur7G0s7SuoqGoq6ioqq2zsraysLSrrre6vb6ytLSgmpuXoJ+jpKGlm46PmJaPl56bl5GQlpKQnZqLipCUl52em5edqqurta6mmJuaoKyqp6OejIKBhI2nraurrKSgqr3MycXJx8vHw7iinaiqqsXPz9C7rrS+x8m/gNDS0MW5tKqxxcrU0MjRzLzE0M+6ssrLzMfG1tPN0c3V6PP6/YD3+YaJiI2Yl4PXwK6lm7bX6Ojk1+uFkIiA8d7Y0tLS5ubX2fOOj4WGiYmMkZeboKiuucC/vr2vpp+P9uSElKGvtbSropqhqaqenZ6qvcS3q7i9vbWnrLqvpaitgKqopqOfn6ClqauzuLW0urq3tr3I0M7S1tjc1Nrp8vjr3dXY8oD58e7zgYP7+P307OPWxbm7w7zBvbW3vcLHwr++urW1sa+vqbGpnJieoJ6go5aRn6qgjYCFhfn6iJCSjYf36+3q5PH+ho+D/+rZ4Onv29fay8S/2vTs5+jxg4mGgIT+7ezz+fj5+fDY0tTY5NvT6Pr39PmEjY2Fi4qCg4Dz8fyPje7Jq6m044mZn6GfmpmZlJGTlpeUj4mAgYWKhP6Gh4WKh42YlJiXi4SEgouOjpOUl6Omsr/Cua6opJyTjpCKhIKHiISLiIH78ePg8/j2goyWmp+QiIyNg+Dd8O3igN7h6Oru8uXj7u7m5ubb2c/X69/LxcXJu9z26+Tk7u3x7ejh3urg0N3a2uyC/ICIi42D++PMwbS6rI6B9fGJnrS97N7S5/n2g5CUkZCQlJuYlIX8i4mLiIf99+vy+/v1/YWIjY+VmZKD+ffXyczf/4eLkJSNh4OHjpSdo6uzu8TJgMzS0crFvLm2uruvrrStn5qempibkYqKho+K+PGAhYqQiIH++oWbnJSKhYT47ff60MHV6oaZnp+chfqDjJObnJqVhYqPiIGFiIqamY+IiImCg4SB8+Lb5Pft5/P7gvXv/pOZmJKFh5CMi4Hz9P2DhYKFhoCA8t3b7evi8PHl4+ftgIOOjYDNqqKlrsnZ5uvr6d7h6enz/fDw7ezr59zg6vHf39jQ2NfTx7Sut7i4vL+8xNrX19na4Milq7K1pYWDsLaWgfuGjJWhop+hs7eqtsDIx7i8vce6w8XLzszY7P/x1s/HurvEx9f3g/rd2OXVu7/R1djRw7u4yOXk0dDM3N/XgLmxqaenlo+NgYSKmqWhoY+EkY2JkpumppuSj5CMiH3hzsG90t6FlpGRioF+cnWCgYiPkoZ7f4+Zl5KUh352fIB6fH58f4uis7G3tainqZ2NhImPm6SrpZybmJibm5Sek5aelJSMi4+drqyopq2oqJuKiY6QkJeVjYqJlpiMjomLgIuPlZmXkZKVlZibnZ6ZjouRlZKSlJWcnZ6ampyRlJueo6ebnp+NiouIkI+SkI2RiX+AiId/ho6KhX5+hIB+iod5dnt/gYmLh4OLlpWWop2UiIqJjpiWk5CMe3Jyc3iQlpSXmI+Kk6ezrqqsq7Cuq6GOipKQjqevsrWjlZylrq2igLK2tKuimY+Vp6y1saqyq5uirq+el6yurqektbOsrqmtvsbLz2rN0HBycHR+gG+2pJWLg564xMTAssRweXJsy7WwsbS0xMK0tsp2dm9vcHB0d3x/hIuOmJ6cm5yQiod70L1ufIeUmJaOhX2DjY6Bf4CMnaKViZWbnJaIjp6SiIySgJCNi4uIh4eMjY6Wm5iXnZuYlp2mq6iqrq6xqay6wce+sqqtxWbEvLm9ZWfFw8a+uraun5aZoJuhnpOUm6CkoZ6dmZWXlJKSjJSPg4CGh4WHin14hZGLeW10ddPTdX1/enXSyMvJw9DZcnxy3ce2vsvRvb6/sKqlv9XLw8TQc3d1gHTdzMvT2NjZ2tG7tbS2wbqzyNrSzNBweHhxd3Zvb2zNy9J7fM2pkpKZwXSBh4qHgoGCfnx+gYJ/eXNsbnF2cdZxcGxycniBfYKEeHJyb3d5eX1+gYyNlKCknJGNi4V+e353cHB1dnJ5dm/Z0cTB1trUcHiAhIl5cnl8db+80c/FgMHGzM/R1MbE0tXOzMvAvra808myrK6yo8ffzsbH0tLV0MjCwc/JuMbEv89z2293eXty3cq3raGnnIR43th7jqSv2se5zNnVc32AfXx+gYWBfnLYe3l4dnXY08jP2NjR23R1eXt/g35x1te9sLLA23N2eH12b2twdXiAhoqPl6CigKatq6WgmJSTmJmNi5GMgX6AfHp9dnByb3Zzzchrb3R6cWvWzW2CgXlwbG3Nw8/Sqp2ww299gYaGb81sdXp/fn17bXF2bmdsb3B+fnVub3FsbG5ry760uszDvsvSbMzG03yBgHprbnd0dGvHydJtbmptbmlpx7O0ysm9ysu8ubzAgGp0dWytkYiLlKy3wsfHxru8xMXQ283Kx8bIxbi7xMm3ubWwurezqZiUnZ2eoqSeprqzsbS2v6qJkpicjXBxn6SDb9h0fISNjYiKnaGSmqSurJyhpa2dpaisrqu0x9nLtK6pnqCprLvXcte7uci3n6Oztry2qKCercbGs7OvvMG8gJ6XkI2Nf3p4cXN3hIyIiH52fXp4gYaNjYV/fX16d2/It6yqvcl6iIGAenNvZmlzcnh+gHduc3+Egn1+dXBqbXFsbW1scHyQn5ygoJeUkol9d32CipKWj4eHhoeJjIaPhoeNg4F6fH+Jl5iXlpuXlYp7en1/gIaGf3t6hIiAg319gHt/homGgYOFhoeKioyHfXt/gYCChYeMjI6KiId+gYiNk5aMj5GDf358goOEgYCEfHFyent1e4F+eXJxd3Vye3lsaWtwdHl5eHV6gYSHkYuEenx7foaGhIB7bWdkYmd5f3+Eh4F8gpGYl5eal5qYlY59eXt5eIySlJmPhYiOlZePgJqcm5SKg3yCkJOZlY6SkISIjo6Df4+Qko+LlZKOj46RnJ+jp1WnrV1fXmFoaFyZjYF6coSYn52akKFcYV5brJiRk5mapqWcm6dfX1tbXFtcXWJmam9xeX59fH11cG1ms6RdaHB4e3pzbWltcXFoZ2lyfX93b3d6fHhvc353c3R3gHd2dHJwcHF1dnd7fXx7fn58en6Eh4SGiYmNhoaMj5WRiYaKmU+Xj4yPTE2Tjo6KioqGgXt8g3+Df3l6f4KGg4KCgH5/fn18dnx5cW5yc3Jzdm1pcnhzZ15kZby9Z2xtaWa5rrCvrbW7YmtjwrSnrLW5qKipnpqXrLyzrK63ZGlngGXBtLW8wMHDxb6poaGkrqefrry4t7pjamljaWdjY2C2tbpqarKYhoWLrmZxdXh3c3N0cG5xdHRybWhiY2ZqZ8RmZGBlZ252cnV2bWloZ21tbnJydHx8hI2PiYF+fHhybnBsaGhsbWlwbWfKwrm3xsvGZ252enxwZ2hoZK2wxse+gLi7wMDBw7i4w8TAvr+2s6qwxLqnn6KonLXJwLu9yMjLxLu1tb+4qre3s79owWFmaWxmxLOlnpScl4R42Mxyg5ebvbCpvMXBZWxwbm5wcXZycWbCbG1ta2rFwba8xcK7xWdnaWtvcW1ju7qmnp+qu2JjZGZeWVZYWlxhZmpscXh6gHyBgX58eHZ1eHpwbXFvZ2RlY2FiXVlaWV9drapaXF9jXVqzq1hlZGBaV1aln6iqjoaToFhiZWdoWqhYXmBiYmJhV1haVVFUVlZfX1pWV1lVVVdWpJqSlaOenqerWaqnr2NlZWBWV15cXFWgoahXWVdYV1RTnJGSoqOco6KamJubgFRbXViQenV6gZKXn6SnqKGipaWstKmopqWmopeYnqGWmJeUnJmWjoKAhYOEh4qFipiUlZeWno93fH+BeWVkgoVwYL1lanB4eHZ4h4x/hIqQj4eJiI+Gi4+TlZGYpLKqmpeRiIqRlKC0XbGenaaaiIyXmZyYjomIk6OllpaVn6Kgn36Gff9+/34Efn9+fod/jH6Ef4t+ln+CfsN/AYCEf4KAr3+CfoV/h36Df5J+hH+Vfol/BX5+fn9/hn6VfwF+qn+Hfop/sH4Cf36Ff4l+gn2Kfot/AX6Ff4h+iH+Hfqt/gn6Gf4J+h3+IfoZ/AX6Zf4l+BH9+fn6Kf4N+h3+MfoR/vn4BfaV+AX+XfgICBACAy9Ll7ebi493Durmxu8nLxcK4rLGys6yuq6esr7KusLK7ubG0qJ+ts6Seo6qppZ6YmqKrrqqhlZiVl52kqK6uoJ6ns8fJsZ6Qmaaooai3wNHHtrCqqLi5sqmfnLC0qquqraentsG1pKGcpKerpKSutLiztr23rKSZk56aoaizw8qAwry0uLGmmpKOjY+QmZ2jqLW8v8DAwri8u66cl5OKgvb4iI6Xj46MioeOn5+kqrOtpZmDkqOnpq6loqKss7vDvMHQyMLBxMW6oaWsvsG9sr+/sqy2r52VlJ6mpKejl6GtrL3BtLi2tsLGysTKxr/Fy8LGxcC7u8O4ramfnrrHwLyAwLi8wMTV29nKx83Gxc7Gs7bFzdPe5vLx4NLOwsTT3+bg3NPP1efg7YCIi4CAgffo3uLm6Ov2+/H0/IKUoJOD/IaMgfHbyNPm5tvmgJCUlqOmpqaopau2v8G/taiblI6FipafrL/FvK6wtq6jn6Ozva6xuLW5wMLEwri3wcXAvL+AvK6ajYulurmsqa25wcTCwMLBx9HS0dTQ0djd19PY4Ozq4uXy8u3x8fP4/P388uTl8fnz59fLwb3J09PKvbSttMDFyMjFv7qzqKmwrqiooqGioJyfoJWNk5GPj4P28fn95+Le29ra4vHs7Ovm7oaI8Ors5+rn6eHRz9nk4+De0MGAveL68fHc74aG9t/Uz97p0cvj3drkgpCG9en5jIqAgPv4/YOHhIaRmZSGiIz+5eri3djYzsPExcXb08nL1efezNbphI6TkpCPkpOPhefL0uXewrC0wcTV6/2EhoyQlJiipqKopZmOhoWFjI2QlY2LhYKEhoiNkI2HiIySlpaWmZOAiIiJhYKAhoGCgomIiZCWmZKIhYGChIKGjIuLkZSMhYeFg4GA9+rr8/Dt7uzs5e7u5t/OxtPX4Onr6On5gYGC/+Ta1sbDvtLj8P+D+oSPjoKEhYSCgYH8/Pz9/oWIg4GJkJGetbusoo7huMD0iZafqKOQ/OP7j52suMPGwcDHxL+AvLKur7O7uri1rqeio6CeoKGjn5GIh4qVmJiTkZGUlpOPlJ2bj4iCiJamr6ukpKSlpqmmoJeTiYKDiImIiIiGiIL3/IX/g5majYaA9+zz/YGFhPTu9ezo7YKJiYaHhIOCgfrx6OXv+4D/6uXm+O/Nz+f9+ufY3dPa6c2zvdvn5ueA28/Ly8/czr6+x9PZ5uvd3Ovv3tPO0OPi4eTn29fa3OD18+rp4NfSz9LPw8bUzsvNxrvP4da/t7GlioOmsLO/zef+9+Tj597b4OHX1NnPzNXx9evi1sbHyNDZzsDO4N7azcPT3ubTvs3h5d7U0N7g4Ov58+DW08nFy8u6wd3WyMqAr7TBycO/wb6mn56Wn62wq6mhk5ibm5WXlJCUmJqUlJagnpeakouVm4yGiZCRj4mDhIyUlpKLgYSBhImRlJqfkImQnbK2n4p8hpOSiZGeqLmvn5eUlaanoJaKh5qdlJaYm5OSoqygjouIkZWZkI2XnaCbn6eimJGIf4mGjJKcqq2ApqKcopuPhX56eHx+hIeLkp6mqKmpqJyio5iKhYF5ctndd32Gfnx5dnN7jImLkJuXkYZwfo+Tk5qQiYeQmKGpo6e1rKWlqauii5CYp6mmnammmJKdl4Z/gYqQjY+KgYyUk6Snm5yXlqOorKitqaOprqaqqqaioamflZKIh5+rqaWApZyen6KzurisrLKrqrWsmJqkqq+6wMrMwLazpaSvucG8trCus8C1wWlxc2lpa9DEu76/v8TS1snJzWp7hnlsz292a8u7q7fIxrnCbXp7fIiJiYmLh4uWnZ6ckoh/e3ZudH+Fj6Glm42RmZKHgYWWn4yNlZOXnJ+ioJWVnqKdm6CAnZKAdXOMn5yPioyXoKKgnZ6eoqyrqaunqK6yramss7y6s7bBv7u9vLzAxMbEvbO2v8O+t6uhmZejra2mmpGLkZqdnp+dmZiVi4yTkIyNh4WHhoOHh312fXx6eW7Py9XZxcG8ubm4w9HMycnDy3V40MjMx8nFxsCwq7PAwsHAs6WApczg1tO7zXR01L61scDKsazDwLvEdIB10cXafXpvb9jS1nBzb3F8hIB0d3rZwcnHw7+/taysrK3Duq+0v9LItLzLcnt/fnx7foB9csWst87Jq5mgrq27z9tyc3l9f4KMj4qQjoR6dXNzeXp9gHl3cnBzc3Z8f3x1dXl+g4KBhYGAdnZ3dHFvdXBwcXh1dXyDhX51cm5vcnF0enl4f4F4cnVzcXBv2MzP19TR0c/OydHPy8i3rrvAxszOysrYb3By4ce9u6qnorPAy9xx1nF8fHBzdXJwb2/X1tna2nN2cGxzenqEl5yPiXnCm6PTdH2FjIh2yrTKdYCNl56gmZienJiAlo+Ki46VlZSSjIaChIJ/gIGEgXZvcHN7fn54dXZ5fHl0eIGAd3BqcH6LkYyGh4eFhouIg3x4b2lpcHFubnBucW3Mz27RbIKCc21pzsPJ0WpubcjDy8K8wGpwcG1ubGppaszEvb3H0mrTwLu+0cioqMDW1L+zt6+4y7GXoLzEwcOAuq+qqK6/sqKhqbS5xMa4ucjKua2sr8C+u77DubW3uLrNzMHAtq2rrLKxpKi4sq+xqZ6xwbajnpqPdnCUn6Sstcna0L6/xbu2uby0sbatq7HIzMK6saOnqbK8sqOwv7q1qqOzvcSznKzAwrmwrrzAwMrV0L2zsqqnr7Cgp8K6rK6Alpehp6KgoJ2LhoeCiZCQjY6KgIKEhYCAf32Bg4N/foCIhX+CfHeBhXhzdXp7eXRyc3h9fnx4cHNwcnh/gYaIfHh9hpWZinptdYGCeYGNlKGajoiFhJCRi4V8eYeKhYWGiIGCkJiNgH58goaIgYCIjY+MkJeTiIF6c3p5fICIkJKAjouHioN7c25sbHFzdnh7gImQkpSUk4iNjod6dnJtaMbGaW93cm9sa2pvenh8gIiGgHlncn2BgYeAfHl/ho2UjpCalZCPk5WQf4OIk5ORipKOg36Gg3dyc3l8eXp3b3d+fImNhYeEgoqOko2SkIyQlY+RkIyHhYqDfX53dYWOjoqAjYSGh4eUmZqTkpaSkpmSgYGHi5CYnaWooZqXjY2Tl5yZl5KQk5+WnVVaXFZWV6uinJ6dm56orKKgoVNfaGBYqltgWauimJ+ppZ2kWmNkZW5ubG1vbXF4e3p3cGhiYmBbYWhtdH9/eXFzeHRtaWx3fnBvdXR5fX5/fnd3fX98fH6AfXVpYWBygH52c3V8gH99ent8f4eHh4mGiIuMioeJjZKPi46Vk46Qj5GSkZGQi4WIjpKQjIZ/e3qEi4mEe3Vvcnh5e319foB/d3Z7eXZ2cW9xcnBycWpkaGZnaGC2sbW5q6mjnp2epbCurrCttGVoubS2sK+usq6cl52orKupnJKAka68tbamtWVmvaqgnauypJ+xrKiuZG5nurTDbGliY8PAwWRkYWRtdXFnaGzEsra0sbCzqqGenp6vrKSnrry2qLG9anFycW9vc3Vzabegprezn5GTnJ6qvMhpbHJ0dXd+gHyBfnZvamhnbW1tb2traGZpamxwcnBqa25ydnZ3eXUebGxsaWdlamZoaG1ra3F3eXVtamZmaWlrcG5vdHVuhGiAZ2bFvsDGxsbEvby4v8C7t6qirK+ztri1tL9iYmPDr6ailJSRn6qywGO+ZGxsY2doZ2ZkY8TFxsTFZ2llYmhsanKBhXt1aayOlLllbHB0cGGnk51XX2hvdHZzdHp5dnVua2xucnJycWxoZmdlZGVlZ2dgW1xdYmRmYmFgYmRiYGKAZ2dgXFhcZW1wbGhpa2prbm1pZGBaVldbW1lZWVhZV6apW7BZZ2ZcWFSnoKSoVVZVnpuhnJiaUldXVFVUU1NUpaCcm6CoVKaYl5mmn4uMmaamm5WYkJSgjn+Im6CdnZSLiIiNmZCHiI6WmaGil5eho5eQkZKcm5mcn5eWl5eZpaNem5qTj46PkZCJjZiUkpOOh5SdlIiFgnpnYn6Gi46VpbCpnqCjnZmbnJeVmZCOkqGinJeSio2OlZyVjZaempaPi5eeo5aFk6CgmpWTn6GhqbGrnZaVkY+UlYqQo5+Vlv9+oH6Cff9+iH6Gf4x+hX8Efn9/f4h+/3+Sf5F+gn+YfoJ/jH4Gf39/fn5+hH+Dfop/ln6Kf41+y3+YfoN/i34Cf36Kf4V+jX+EfoZ/g37MfwR+fn9+hn+EfoN/hn6Jf4Z+AX//fpl+AgIEAIDf2trY1M7HxMW8uL/ExtHW1dnYzMC4vsvR1ci1u8zOxcnP0tfQwrm1vMjLyb21qp2YobC/xsrW4d/Qt6WdoKSqtbnAwL7BxL6ztLu0qKKipqiyubzI0NbZ0s2/vcG3ubm6vLq3sayssKessq+zq56cn56crLa7trSyraehn52hnYCanaenpqansKimpKeopaGps7a0rqahqa6wusXIxM7Tzc7PzcS9uLzBtrPCw8XDwr+7ur68u83V2N3Qx9DX1c3N0MevoJ+prbPJwba+xcHEy9Xa5+Lc5eXX2dbT0dLk9e/w+vDe6/fr2czR0M/sgoeA9OTe3s/I0MzKzNHa2tHNw4DG44SG9+7fxL/J0M/R2uDf3+Hd0Nfj4MrG0tHa7enn29DX3Ojw8PL67e2CjYb99Pbs4+jj2tTp94KLiYWDho2Khe/rhpuajYeGiI6RlZWbpKajqbCwqqeloaeono6LlKKmq7Cwq6Kjrbm9sqakrrG1w8rHvbaupKKksbi0q5+WmYCirLe8urW2squsqaq6w8C/wcXR3NzQ0d7l4uHa1dre7fr57uz8hIWB/v77/4CDh4aEhIDz5uTl39zc183Du77H1OTl28/PzsfAt7CoqKikoKSmnJGVnKKkpp+Nh4mMhvnx/4yRh4aGiYqHi4SEjI+VlYyD8/qGjIaFhoOAgf6Bg4CGioiFjIiCgfDk6en0++3a0tLQx8bW6YCEhP3o3t7j59rHu6+3xNLEvL/ShqCssKuprausqpqPlIiAhIeA/IaD+oSHh5CaoaappKOglpaUi5CZlITz8N/Q2uzw8/z++vfz9PH3//+CiIiFgoSA/f+BgP2Dg4SIkZSLh4mKjImQlYCTjIb24uDygIKChoaFhoeGg4eF9PD0+4KC/vn4/f+Eh4SCgf31/oWCgYKCgYGBhICFhfv9//nx6ejp5tXSz9HOwbe2yM7g7urh5Onk5O/q5viDhoqOkJGQjYyOkpGTl6KosLSwqZ6Tg/uKoaqyvLyxnYTt/YuOn6+1uL7FyMvQ0IDMxcDAvbu9wLmvp6Gen5yco6KbmZiQi5KVmZqZmZSRjYmKjI6YnqSpqqOZkIf9/Pr6goKChIqYk4yOhoKD+fHm4fuDgPDp7d3e5dzUyL6+wcbd7vyDi46F9OXV0ur+g4X87u3u6d7W19fYzNHj5uTb08W7x9HO4/z78Ofk7vXf3IDm7fv1/pCXlJOUjoaHi4yIgOvr8v+B+PDy94SMiYf86d3X4Ojt8fT3/Prv4OPo39C0mpmz0d7a0tXh6Oz3gf3+/e3X2dnX2uPn0MPL083Bu7i4sbnR5/PhycTDw8fJx8XFv7KrsLbK29jO0Nnb1tPSyb+/vbvDxL2yrKervMnR3oC+t7m4tK6koqafm6Clp6+zsra2raSdpLC0tqeVnK+xqKy0tbmypZ2aoKqsrKKakoeCiZaiqa67xsO2nouEiY6VnZ+lpaOkqKKXmJ+Zj4qLjY6ZoKGss7e5s6+jo6menqCio6GfnJmZnJGWnJiblYuKjIqHlqGkn52cmJGLiISKiYCFiI+QkI6QmZKRj5KTkIyTnaCel46Jk5qaoKisqK+ysLK0s6mhm5+mnZuop6elpaGdnqOgn7C3ub6xp7K4ta6yuK6YiomVl5qqoZifp6Wnrre9ycG5wcK1trSyrq2/zcbK1su3xM/Ds6qwrqzGbXBqzL+9vrGqtK+pq6+4ubKto4CkwHFyzcW8p6Orsa+wuL28vb+6rrXBvqintK+3ysjGua60usbKx8nRxMJsdnDTztHGvMK8s67AzGtzcW1rbnVybcTBcYWCdXBwcXd5fHp/h4iFipCQi4mHhIuOhHVyeoWIi5CSjoaGjpqflYqIkJGVoaekm5aPhoSHlJqWj4V7fYCGkJmbl5OVlI+QjIuYoJyam6CrtrSnqLa9u7iwrLC0ws3JvbvLa2pmyMfFyWVna2poaGW/s7S2s7GyrqWdlpifq7m7s6mrq6aelpGJh4aDgIiNg3h6gIaIi4Z2cXR4c9HJ13l9c3BxdXd0d29vd3p/f3hwz9h3enNxc3BubtZtcIBzdnRxeXdxcdHExsfU3My7t7m3rq67ym90dN7Ivb7Fyb2qoJSdrbqqoJ+xcoiSlI+NkY6QkYN7gnhtcnZu2XVx1XN4d3+Hi4+RjIqJgIB/eH2Gg3TU1cW1wNLV19/c2NbU1dHW3d1wdXZ0cXNv3OFyb9pxcXJ3gIJ5dXZ4eHN6gIB+d3LPurrNbnBwdHV0dnV0c3h208/V3XNy3drb3dxydHNxcNvT3HVxb29wcHBxc290dNrb3tfQyMnKx7W0tLa0qJ6brLPDz8m+wsfEwszIwtNwc3d7fH18eXd6f35+gIiNlpmWj4Z+cNV1iY+RmZuTfmSuxnJ1goyQk5eeoKKlpjGjnpqbmZeZnJWLhoOAgH+AhoV+e3p1c3l7f4GAfnl3dXJzdnd/g4aKiYR8dW7R0tHPhGyAcn55c3Vua23Qyr650m9ryMPHuLe+tK6knaCip7rGz2lwdW/LvrCtxdZub9DExca/tKytrq+mrr/AvrexpJupsazB2dbJwL3I0ryzuL/PydJ4fXh3eHNsbXJ0cGnBwsrWbdHKyclqcXBv0sO3sbrDx8nJzNHRyLq8xMC1m4KDnbdLv7uztcHIydBs0tTWyLKxsK+zvsKtoKuzrqCal5iTnbDD0L+noqWnra6rp6Wek5CWnLC/uKyvur63tbOqn5+fnqepopiSjpOhrLO9gKCZm5qVkIqJjIaChomJkpWTl5eQioWJkpSYjoCFkpSPkpiZnJmQiIOIkpOUi4WAdnJ1fYePlJ+no5iHenV4e4GHiI2OjYyOioGCiIR8eXl6e4OIiJGXm52VkoqMkYmLjpCPjIqHhYSFfYGGg4aDfXx8eniDi46KiYmFfnh1cnd3gHV2fX99fX+HgoF+gIB+e4GJi4mEfnuCh4iKkJSQlpmXmZmYkYuFhouDg42NjYyLiYeHjYqIlJueo5eQl5qYlJmfloV6eIGCg5CKg4iOjY+VnaKuqKCnp5qZlpSSkqCrpaeuppiiqqGWj5SSkKNXWVWqpKCflI6WkoyMkJiZlJGKgIygW1uoo5uNi5CVk5SZnJydnpyUl52bjI2ZlJmmpKWckpaYoKSjpaykpFlfWqumqKKbnpmSjpynV1xbWFdZXlxapKFaZ2VeXFxdYmNmZGZqa2puc3Jwb21rbm5oX11ka21vcXJwamxyen12cG90dHV9gH53c29paWx2eXdxa2ZngG92fH16dnh4dnZ1dHx/fHt7fYSKiYOFjpSUk4+Mj5CZoZ+XlJ1RUlCenJiZTE1QTkxLSo6HhoeFhIaGgX97fYWOl5eRjIyMiYV/enNwb21tcnZvZ2ltc3V3c2ZhY2Zisqy0YmZgYGBjZWRmYGFmam5tZmCzu2dqZWRlY2NjwWJkgGVoZ2NoZmFiubCys73CtqmkpKGcn6y4Zmtryrqwr7K1q5yUiY+aoZSNj51kdoCDf32Afn5+cmpwZ2BnamTHamfDZmlqcHd8gYN/fXx0c3JrcHZzaL+/tKm1xsnL0NDNy8nJxsrQ0GlucG5sbWnP0Wloy2lqam52eXFub3BwbXN3gHZvaLumpLhjZmVoaGdoaGdlaGe8ur7CZWTFwsLEx2dqaGdmysTNbGloaWloZ2doZmppx8rNycK6ubm3qKenqqWXjYyboK24tKytr66utrGsu2RmaW1ub29samtvbm9wdnp/gn54c25hvGh4enuBgXpqUpChV1hhaGxucnl7fYCBMX99eXl3dXd5c2tnZWRlZGVpaGNhYl5cYWNmZ2ZkYWBgX19iY2hqa2xrZmFcWauvsa+EWIBaY19bXFhYWqymnJmpWVejoaSXk5WOioN/goWKlp2kU1ZaVZ+Yj4yao1NVo5ubmZWQi4yNj4iNmJiXko+HgYuUkaG0s6minqKml5KUlqSkrGBjYF5eWldZXF1aVqGipaxYqaSiolZbWlmropqUmaCipKKkp6mkm52hnZWDcXOGmjyfnZmao6enrVmtrq2ikpGRkJObn5CIkJaSiIJ/gH2HlKCom4uKjI2QkY+Mi4d/fYGGlKCbkZScnpmXlY6EhQuLjIiAenl+ipKYoP9+7n6Df5J+gn+mfoN/i36Jf4J+4n+DgIR/h4Csf4N+kX+Cfoh/AX6Kf49+g3+RfpJ/BH5/f36Tf5J+h38Ffn5/f36Rf4R+jH+EfoJ/hX6Ff4N+jH+ffpd/AX6Jf4J+uX+Efox/hX6Cf5B+hH+GfoJ/pX6Mf4R+AX+EfoR/n34Bf8J+AgIEAICYqKuwtqubkY6Cgo+mxd/exbzCtayom5ilp5uYorPAxMC3r6uinJyruLy+vsXJzce8wcG6srW0rLfG0MOwqKupq6+wrqqprLO+wr68srK2t7u6qqSwtrq8wcC/vLOroaCgr8DDv77AxcKwo6anqKqknqKlqrW2qaeoqqGlsri4uoC9vKqXjpWbnpqVkpKOkJeamJqhoKKzv7esqK+2qqCjnpWhsKugnqSipaupscDL3eDd18m/xdPg3tDGyr+4tr7HysrEv7y9wb66wNbs5e3z7Orq7+vYxbvDyMvS0NXg4trW6/L6+Ojy9+3l4ejs7PH2+4WIhYuSlZSKhouPlJOSkYCSlpOLgoGG/uTl94SEhP/48eLl4t/n5uTq4trb2dfb2+6Dg/Hp5uXc09ri6+3Z1uDa19/l+oD59PTu5+6ChoSLmZuRj5CYo6OenJmVkY+VlJOVmqSsqZ2drLzAtZ2PkZucn6OkpqirsKqjprG8w8THzsu3q6uvuritp6SotL/J2IDf1byyr7jJycXIzs3HxMHFy8vLztTW2Nrf4uDX1NXY2tzd4enw8fHz9vqBhoeDg4KChISA/YGEhYaHgvnx8fDu5tfR09TUzcrMycC8v7++vby+w8bKxr21t7yzp6CdoqywqaGcm6CWj5GSj4mEho+ShoKUnZeNg4CLk4yHh4WA8YD6jY+KkJeSjYX7/ezNye+LkJKboaSknZidmY+KgPyAhIWA+OfX28qtorPLys/c3OLz/YSIjZefoKGjnZOIhoLv3MO2y9/3jpOM/fyPnJqdo5+ak46Mg/aAiYmB+PLr5ujj4eXj4N3c5e7z8vn/gYH88u339+7s7/P58/GDjIqBiICSj4uC6drg6fX77+zlzsbKy8vL0NDR0dDM0d/q5eXl3+Lq7ejp8fH5hIaDgIKC/4SHiYmA/4aJi4yLhYGJjYyKhoKBgf+Ag4WGipWbnqOlp62xr66on5WE28v1lqarsbm7vr+5rqWqtrOsraytqqSfnJugqa+2u8DGxMPGxb+6uoC6taumpaWkoKKmqKinnpKPlJ2gn52am5aQi4uXlYT9+IOHi5qblYyD+oGKi46NhPz7+P/8/YWJiYuKi5GMhYL9//z08vPy8fX9+fSAgomPj4jx4d/l7u3x/oaJhICBgfv4gYybnIz7587FzdLV5v2BgIaG9eLj39DQ2ubo5+zw9YCBhYOCgPz5/4SFg4OFiIuI/uzk84KC/4aLkJaVjYX46uTr+YOGio6KgunV08m8vMDDzNDCtbvR29nd2sa+zdDQzsbEx8vJydXh3Mq7xM3Jw8HCv7u2v8zMxcjEv8bGxcnGyNDZ1dDX3dfT0M7Mx8KskoKGk5KNkZWSjoqPlpWRi4CDkpWanpSGfn10cn2Sr8fEq6Gon5eShYKRlYeEjJynq6egmJSKhoiWpKiopqyxs6ugpaahmZ6dk5yqtKmXj5GRk5aWlZKRkpigpKKimpmcn6Ojko2Zn6SmrKysqJ6Yjo6PnKytp6WmramXiYyOkJCLiIyOk5+hlI+QkYmOmqCfoICjo5SDfIOJioV/fn15fIOIhYWKh4qcqKCUj5WbkYqQi4ONnJaLio6MkJaTl6Ksvb+8t6yjp7O/vrGoq6KdnKOqrq+ooZudpKKbnbDCuMDGwL/Cx8Ozo5uipqmvq665vLaxwcrU0b/Izsa+ur7BwcbJz25xb3V7fXtzcXR5fHp5eIB6fntzbGxw0ry+zm5vb9bSzb/Ewr7Fwr7FwLi4trO2tslvbsbBwMG5srm9xsi1sbq3tbvA0mzSzczGvsRrbmxzf4F2c3V/iomDgn98eHZ8enh5foeNiX19ipuhl4J2eIGDhYiIioqNko2Fh5GcoaCjqqiWjIyRm5mPiIWKlZ2ms4C7s56TkJipp6GlrKqloZ6hpqeoq7Cys7O4uriwra2vsbS0t73DxMPEx8lnbG1qamlpamhkxmZoZ2hraMW+vsDAuaqlq66vqaepp5+ampiYmJmdpKeopZyVlpqSioOBiJSYkIiEg4d9dXh6enVwcXp9b2t9iIN5bm14gHdycXBryIDQd3p1fIN/e3LY28utqs95fXyDiIyNhoGGgXl1btxvcnNv1cS5wLGTiJqysbW/u73N13FydXyDhYeLhXx0c3DPwKicsMbcfIF62NZ6hoSIjYmEfnp5cNJveHlx1tDLyMrEwcXGw7++x9DV09jecHDa0s/Z2c/M0NTWzcpueHZudRN/fHlwwKywvtDYzc3ItKuwtLWzhLiAt7S3xdDKyMe/wsrMycvS0dp1dnNucG/ZcXR2dmzYcnZ4eHdwbXV4eHdyb29u2W1wcnJ0foOGjI2NkpWSkYyHgHK7q9CAi4+UnJ6hop2UjJCZlY6PjY2LhoKAfH+GjJGVmaCdm56fnJeXl5KKhoiHhYKChYeIh391dHuEhoSAfYCAfHZydIKCcNDMbXBzgIF8dWzMaXFzdXZu0tLP1M7NbXBydXR1enZvbdXTz8fGysnJzdXQymtvdXl4csi5ub/GwsTRb3FsaGts0s5rd4eFdc69qKGprrDA1WxqcHHNuru4qqq0wMLByMjJaW5sa2nNytBra2ppa3BzcdLAu8tubM5pa290ent0bc7Ev8bRbW9ydXJrwbGxp5yfpqqxs6WZoLW8uLy6pJ2rrq6vqKWnqqmns764ppqjrKijoKGgm5eeq6+qqaOepqenrKipr7izrrS4s7CsqqimpZN7bHF+f3l9gn56d3yCg3x3gHJ+gYWIgHVubGVjaXqVqqeWkJaNhoJ2cnt/d3N7iZGSkImCf3d1doCKjI2Nk5WWkYiLi4eChYR9hY+XjoF7fn5/gIGAf39+gIiLiIiDhIeJi4t+foiLj5CVlpaTjYh+fX6IlpiTkJGVkIF4ent8fHh1eXuAioyBfH1+eHyGiYiJgI2OgnRtcnd5dnJubGlscXV1dnt5eoaPioN/g4h/eX15cnqGgXl5fHp7gYCEj5ajpKKelo2QmaKimZKTi4iIjJGSko2IhIWLioWGlKGXm6GdnaCkopaKhIiKi46NkJicl5SkqbCwpausopyanJ2doKWqW1xbYGVlZmFgYmRmZGRkgGVpZmBbWlurnJ+rW1xdtbGtoqWjnaCfnKOhm5mWk5iZp1tZop6dnpqWm52jppmUmZeXm5yoVaupp6CaoFZXV11mZl5dX2ZubmppZ2ViYGVjYmNkaGppY2Vvenx2aGFjaWpsbm1vb3N3dG1vdXl9foGGhXlycnR6eXJtbG92fIONgJKNgHt4fIeGgoSHhoKAgIKGhoaJjI6OjpGSko6MjI2Oj46QlZqbmZucnVBSUk9PT1BRUE2YTk9PT1BOlY+Njo6OhYSJjZCOjI6Kg39/foCBgoSJjI2Mh4KCg312cXF1foJ8dnJwc2tlZ2lnY19gZmtiX210cWpjYGhwaWNjZGC1gLlnamZrcW1qYr3BtZ2ZtmlsbHJ3fHtzcHVxamZhxGNlZWLBs6iqmoR8i56eoqqoq7nCZGdqb3JydXd0bWhoZbqunJGcq71scW3GxW95d3p9enZybm1mwWZubmjIwr68v7m2urq4t7a+xcrKz9Rras7IxMzMwr7AwsS7uGRsamRpgHFva2Kolpqot7+4t7OjnqSmpaKjpaeopaKmsbq0tLWwtLm6uLvBwMZqbGpnZ2bIaGpsbGTIaWxtbWxmY2lsbGtnZGRlxmJjZWVnbnBydnh4fH59fXh0b2SmmbhveHt/hYaIioZ/eHuCfnl5dXJvamZhXFxhZWtvdHp6eXx+e3d2gHZzbWlpZ2ZkZGZnZmZiXl9jamtqZ2RmZGBeX2loXLCrWlxfaGhlYFmpVVpZW1xZra6rrKenWFpbXl5gY19cWrOxrqWhpKWmqa+tq1lZXV9gXKWZmJuemp2nWVpWU1RWqKdWXmhnXKaajIWJjI+cqlZTV1igkpORiIqRmZyeo6SlgFVYVlRTo6GnVVZVVFVXWVimm5mjVlaoVlhaXl9bV6agnKOsWltdXltXn5SUjoeIjI6Ul46FiZmfm52cjISOkpKTjYqMkI+Nk5uYjYWNkIyIhYaFg36Ei42KjIiGjIyMkY6PlZuWj5OWkpCOjImIh3poXmJrbGZqbmxpZmpwcW1o/37yfpZ/hH6Df5N+gn+SfgF/hn7uf4qAAX+GgMR/gn6If4Z+jn8BfoR/kH6Nf4d+BX9/f35+i38BfoR/kn6Cf4x+iX+kfoZ/AX6FfwF+j38BfpN/g37Df4J+iH8BfoZ/hn6Kf4x+hn+IfoZ/gn6Ff4l+hH+NfoV/g36If4R+A39/fod/hX6Gf9d+AgIEAIDFxr+2sK+tpZSE/YOSm52nrrWxrKypoqWtrKyppq2ztKyjobK9vripnp+fm52gq7O0qqKrtba4u7i4ws3Q0tHSzs/PysPEzc/Ly9DOvq+0uK+jm5GRmZ+eoKSlsr3FzMfDxs3Z5e7x7urt7+Pa2tnX0MzQz8zQ09PQ0dja0cfAvYC6uL3CxMPHzc7M0NbMwcjV0szMysPDwLy7tbG5v8HGxb2+t6+tsbm8uri0rrTI2+fx8ObYzMfFzcvK2ebk29zg2+Hj4d3d4d/a2tnM0t/c1M3DxdDFtqiqu8nHv8LR5/b8iIr++Pn5gYWFgv/8/oWHhYKAgf3p0M3e5eby/oGCh4CRk5CNjoyNlpqWlI6Hgv/9693h29ns9PD3//n4gImQi4Dr7PuLlJCGg4iJh4aEgPv8hpWcmpmdm46HiI6XnqKinpubm5qZkouIi5ahpZ+ZmqCjoaOqtbm1rqOblZWZoKOdlJOZpauvtrewrLG6v7q7wbyyra60uKucl5igp6elroC2tK+vsqugoquzr7K+w7++wcLFycvLyMnW39zRyMPDxczV3ufy+PTx8/iAgfjx7PL7+/b2/YKDgYCBg4SFhYL56eHk6efj4uLg29fSzMbFxsbM0tbTy8fHysi/urq7uLO1urmzsLGspZ+gpKGboqupqqyoo6ixsqmem5iTlZOOj4CPi4aA+4GDgYGAho2N/ODb5fOEl62zrq6xrKmqq6uon5mampCIipGO8ODp3c3Iz9jg9IGEjJahpamwsa2oqausq6uqpqWlo56Wiv706d3b4eTtgZOfmpaVlpedoqaim5WVm6GlpKCdmpGIhoaGio+Oj5GH8N7f5eTi9oaJgPP094D1+oP55drW3un4gYeSl5iip6Wjn52YlpuXioiIiIeLi4eDgPvz9ICHiYqMjo6RlZmanKClqLG5v76+vLOmnZqUjouG+vuJjouKi4uGhYaDgP+DiY6Un625xMfJyMK6s6ykoaKgnJiZmJKNjZCWoKiqqrC4trGyuL7DxL+2r66trICwsrGzsaminJ2ipKCcmpeYnp6cmpebqK6ws66lpKKakoyHhIWKiYmPlpWRjIaB/oGDiJCRj5KOi4+PjIqHhYeLjIuJi4Lr3tba6vf/goiOi4qPlJebmpeSjIT/hZSVj46TkY2HgPj15tHN093h3uTx4c3T74SHhPrv39ro+IKFjoCQioaIhIGCh5KgpqGXko+KhPzu3tnl7ube5/P9hISB+/yAhYiC9Ozn4+fw7NrW3uDe1MSwpaq+y8nT39rU2eHf2dbVzMjR5vT49/fy7O3v7N3MwLm0sq+tsbi8wL66xcu9s7zGvrvDyMPEy8zN0tXO0NPQ0srAwcnHurCytrW2voCrrqedmJaWj4By3XWDi42WnaGdl5aSjJGZmZeTj5Wbm5SMipumqKKUioqJhoiLlp6flo2UnJ6eoJ2ep7GztbW2srKzrqamr7CtrbKwo5aboZqPh39/iY+MjJCRnqmwta+np6y2v8bJxcHEx7yytLSyrKmtrauwtbWwsbi5sKWdnICamZ2foJ6jqqyrr7SpnqW0sq2uq6Ojop+emJaeo6SoqKKinpaTl5+ioJ6alJmsvcbPzsS3rKipsa+uu8bDuru/vMDAvbi5wMC8vLqvtcG+uLCqrbetoJOVprOtoaCswNDVc3TTz9DQa25ua9DNz21ubWxrbNPArKq5vb3Gzmhpb4B4eXVzc3Fze4B8e3dybdjYybvAu7fGzczU29XSbHR5dGvExNJ2fHdubHBycXFvas/PbnqAfn6CgXZwcXZ/hIaFgX5+gIGBe3Rwc3yGiYR+foKEgoSMl5uYkYh/eXl+homCeHV7houRmpuTjpOcoJubop2Uj5GYnZKCe3yFjY2LlICcmJGQlI6FhY6Uj5CanpqZnZ2fo6WkoaOvuLeupqCgoqattLvEysbDwcVnaMjBvMHKyMPEy2hqZ2ZnaGpqamjFuLG0t7aztri2sq6ppKGho6OorbGwqKOkp6Wempmal5OUmZqVlJaSi4WHi4eAho6MjY2IhIuWl4+FhIJ8fnx4eYB5dXFs1G9wbm5tc3t62L66xdFwgZOXkZGTkI2Ojo+NhoGEhXx0dX97zL3HwLGssrjB1XFyeICJjJGYmJKOj5KSkZCQjY2OjIiBd9nQx7y7wsPGa3yIhICAgYGGi46Kg359g4qOi4mHhX1ybnByeH17fYB3z7u8xMTB1HR4b83N0IDO1G/Twba1vsnWcHV/g4OMkI2LiIeCgYaCdXJ0dXR3eHRxbtjQz21zdnd5enp7gIOEhIeKjpebnZ6fnpeMhYJ9enhz1NR0eHV0dndzcnNwbttwdHd9hY+ZoqWnpqGalI+IhoeGgHx9e3dzc3Z6gYaHiI2UkoyNk5men5qSjIyMi4CNjo6QkIqDfX6Dh4WCf3t9g4J/fXl9iIyMkIyFhoV+d3JubG1xcG91e3t2cm1ozGlrcHl5d3hzcHV2dHFta2xwc3NydW3EubG0xNLXbXJ2c3J3enyAgHx3cmvPbnx+d3Z7endwa8/Nv66rsry/u8PQwKuvyW9xbdHJubXD0mxudYB3cW1vbGhobHeDiYR5dHJva8u/s6+8xsC4vsjRbW1qz9BpbnFsyMG+u77GwrOyvL+9s6SRh42grKq0vLWvtb+9t7Wzq6evws7QzszFvr/DwrapoJyZl5WVmJ6go6Kgqq2fl5+poZ2kqaaor7Gyt7ivrrCws6uho6ysn5WWmpuco4CSlo+IgYCAem5kw2dzen2FjI2IhIOAe3yAgIB+fIGEg395eIaOj4qAd3Z1c3R3gIaGgXp/hYaHiomKkZiZm5ubl5aWkoyNk5SSkZSTioGEiYN6dW9veHx6fH+Bi5OYnJeQj5CVmqCjo6Gkpp2Wl5WTj46RkY+RlZWUlZqblY6Ih4CFgoSGh4iMk5OSk5WMhIuXmJOUkYyMioeHgoGHjI6RkYyMiYOBg4eIh4eFgoaUoaevrqeclJGQl5aVoKqooqOmoqWloZucoqKjpKKXm6WjoZyUlJqQhXx9ipWQhYOLm6mvX2Cwr7CuWFpZV6uqq1hYV1ZVVaidj4yanp+lq1VVWYBgYmBfYF9gZmhmZWNfXLa3rJ+inpmlrKuzubSvWl9iX1qoqLBgY19bWl1cWlpaWK2tW2RnZmVoaGBdXl9kaGtqZ2RkZGVnZGBfYGVrbGhlZGZoZ2lvdnh3dG9qZWRlaWtnYV9iaW1yen15dnh/gn9/g354dXV5fHZsZ2ZtdHRydoB7eXRzdXFra3F2cnN7fXp3eXh5e35/foCHjY+KhYKDhYmNkJSZnJmXlphPT5iTkZWbmpaWmk9QUE9QUVJRUE2RiYSGiYmIi42OjoyKiYeIiouPkpSUj4yMjoyHg4KCgHx+goN/fX58d3NzdXFtcnZ1dnh1c3iBgnx0c3JtbmxoaoBpZ2NfumFiYWJiZmtouqemsbtjcH6Bfn+Afnx9fX17dHByc21oaG5st6uxq56boaWsvGRmanB4fICGhoJ+foCCgoKBfn5+fHl0bMe+t66rsK+zYG94d3NzdHR5fH98dnJydXt/fXt5d3BmYmNlanBvcXJqvKmqsrOwwGhsZbu7vYC8wWS+rqWjqbK/Y2dvcnJ5fHt5dXRxcXZ0amhoaGltbmlmYsC7vGRpa21vb25vcnV1dXd4eoGFh4eIh4F5dHJvbWpmvLhkaGZkZWZkZGRhYL9iZmltc3uBh4mLi4eCfXhyb29uaGJgX1pWVVhaYGVlZmtxbWlpb3V5e3dybWxsa4BsbW1vcG1pZmdsb25samdmamdlYmFka21ucGxnaGhjX11ZV1dbWVhcX15bWVVRoFJTWF5fXmBdW19fXVtXVVZZXFxbXFijnJWYpa+xWFxfXFtfY2NlZGFdWVSkV2JkYGBiYmBbV6mon5SRlp2fm56nnZKVpllaV6eimZehqldXXIBdWVZYVlNTVl1maWZeW1pYVaKbk5Gaop6YnaWqWFhWqahVWFpWop2alpecmpGSmZqYkol8dHiFjo2UmpWSl56bl5aWkIyRnqaopqWhm5yen5eLhYOBgICAgoaHioqIkJOIgIaMh4aKjYyOlJWVl5eRkpSSlI6IiY2NhHx+gICAiIp+AX3/ftd+gn+EfoR/g36Gf4l+kX+OfoV/g36Lf4J++X+CgIl/ioDFfwF+iH+FfpZ/in6Yf4h+oX+HfoN/hX4Bf4d+mX+Dfp1/gn6LfwF+3X8BfpZ/h36OfwF+in+PfoN/hn6Uf4t+BX9/f35+hH/bfgICBACA+fLb0dng3tbOwry6vsTHxbu8ycvDsKetsauotbmqnKS1t7e7wb65sKajp6qimJ6wureys7Sys7SyraSeoaquramloZyco6iinJierr/P2t/XyMDEztXX3t7X1dLKwb67vMLHzNHW2NrZ2N7q8fDj1tLOz87Q2ePl3NbX4ebl5umA5uHm7e3j4NzX1tzk38/J0dXW1tPP0dng5uff2N3s7OPe08OxpaCtt7a0s7Gzr7C4t6+mnaGvuLWsr7a7wcTMzczN0dfZ0MW8uLa6wMC5t7q5ubq7wMbS4/H1/oOBgYWFhYDv6OPU0dnf2dnd3N/u+Pj8/vDc2uby+vr7/ICEhYaAh4eE/OTJv8XLyrebi4ju28u1ssXY6fyEk6i3wszU6P367+vj5PeD++/2/PP1hZOksbe3trWvp5ySkpebl4+KiY2Tl5SLgfyEjJehopuYnKOnpaSkpKCWjoiFhZGepaqur6umpaalpqytr7KyqKKorqukoaampKq1vsPFyMrJv7Y7rKOenaCio6CgrLvDwLy+v7+8uLm8wsTFyMvNztLV0snBv8PL0tne4uPi4uTn6fD5/fz9/vfo3tzh8PuEgSWA//z69vTy8O/r5+fn49nR09ja2tjX19na2tfW19XPycnMz83JhcaAxcC6t7i5ta6qrK+tqqinpKCfn6CipqefmpqcnpyWlZecpamjnZmNgPD4/f+Ch4qKjJSfqK+0uL/Fx8W/t6yfm5qTifzp2MjGyMG5uLi7vcbU5/iBhoqQmZ2fn6ChoJiSkIqCgYWGhYD48ezm7fTz+oOMlJmZmp+lpqWmpaKgoKFUm5ecoaGdnKKinpiYoaeqqqalpqWnqq2sqqyxsamgn6GgprG0sa2rsbaup6aprbGwsLCurLG1s6+tra61u7q3ub27tKuts6+ln6CmqqyqpqSmqq6yhLaAuLzByM7S0NDV2tjW2t7f3dra297d29vc0rugj4mD9vWAhouOlqGprrCzu8XM0M3JxcC7u7y4t7e0rqelpaSjop+foJqTk5SPiomJi4+Tl5uampubnqSqr66rp6Odm5ydoKappJmTlZqgoaChpKWin5ydoqGcm5uYk5KTjouG+vUa/4aLjZGVmp+io52Tj5CVn6Oem56hn5uXkY2EjICLioqKi5CTk5GMiYiKjIuIjJGOgvLz/4T/7uDd3+Pl3c3Fv8XR2+Hk5eDZ0c3MztXc3ufv6uTo9oKEhYiIg/zz7+3r6urj29jW2NXc6ezu7+ve3uTf3evz7trKxsLH1tvd2c7FzNvs9fHl5uzn2tjVycPJzs3MxsXIxcC/yd/p5SHf3NvW0tXe3dXW5fTv4tzX0M/KxcTHxsTAvcTN3+zp4uyA1s+5r7jAv7mxpJ6eo6mrqJ+isLKpl5CWmpWSnaOXiI2cnZ2gp6agl4+Nk5iPhImbpKGcnZ2anJ2cl46IjJWamZSQi4eKkJWNhoKGlKSzvsO8rKSnr7e6wcC5trSspaKgoqerrrO3uru5t73J0M/CtrGtraustsHBurW2v8K/wMOAvrm/x8i+vLq1tbm+t6ejrbW4trKtr7a+x8m/uLzMz8fDu66ekYyYo6KgnpycmJujopqOhImXn5uUlZqeoqauraytsbi7s6qin5ygpKGbnKCfnp2cn6Swv8zP1GtoaW1tbmrFwr6yrrS5s7O2s7O+xsbKy72rqrjEysnKymdpaWqAbW5rzbmkoKmys6GHeHfYyLijobTG1eR5hZWgqK60x9nVyca9vc5t0cbL0cjIbXmHkpaUk5OPioJ6eoCDfnVvbnJ6gH1zac1tdH2GhoB+gYiLiIiJiYZ+eHNwcHmEi4+RkY2HhoiGh4uMjpGRiYOKkI2HhIeIhYuVn6OmqKqroZmAkIiCgoWIiISFkJ6koJyeoJ+blpaanp+foqepq62wrqWem6Cor7O2ubq5uLm7vcLKz9DS1My9s7C1w85paGlpaM/MycfFxMLAvLe2trOrpaitr66ura6vsbGvrrCuqaWlqKyrpqKjpKWmpqGbl5mal5CMj5GPi4qJh4OCgoSIjY6Ah4GAgYKBfHt+g4qNiIWCeW7Q19zccHR2dHV7hY2Tl5mgpqmopJ2RhoODfHTYybmsrK6onpyeo6WrtsbVbnJ1eYCDhIWHioh+d3VuaGlucG9qzcjGxMnOzdJvd3+DgoKGjI6NjYuJh4eGf3uAiImFhImKhX9/iI+SkIuKi4qKjI6AjY2QlZaQh4aJh4uUl5SSkZeak4yLj5KWlZWUkpGXm5iUk5KSmJ6enZ6gnZePkZaTi4WHjZGRj4uJio2QlZmYmJianaKnrK6rrLK2tLK0uLi2tLW2uLe0s7WtmoN1cGvJxmhtcnN5gIeLjZGXn6aopaKfmpWVlpOTlJOOh4WGhoWAg4CAgn14eXt3c3FycnZ6fX9+fX59gYWKjo6MioaAfn9/goaJhHt3eX+Fh4WEhYWCf3t9goJ+fX58eHh5dnNuy8bRb3N1eHyAhYmJgXZyc3mDh4B9gIKBfnp0cXFycnNzcnJxcXR4eXdzcG9xdHNwdXx6bsvL1W/Xx7q3u8LFvq6ApZ+kr7e8v8G8tKynqa2zt7rBx8C5vMttb3BxcGzOxcPDwcDAvLa0srOwuMXJycrGu7vBvbzK0s66qqWiqLe8vrqvpqq3xs/Kvb3CvrOxrqajqa+wr6qpqaaioqu9xsK+vLu2srW8ubCzxNLOwbu2r6+sqKeop6WgnKSvwM3JwsqAsKublJygnpqUi4eHipCTkIiJkpGMgHuBg39/h4p/dXmEhISIjo2Jgnt6f4B5c3mIjouIioqGh4eGgnt3e4KFg356d3R1eX55cm5xfYuYoaWekoyPlpudpKOenJqUj4yLjJCTlZmcn5+cmp+or66kmZWSkpCQmKCfmpeZoaShoaKAnpqepKafnpyZmJ2inI+Mk5mbmpiVmJyirLCooqa1ubGup5uOg3+JkY+NioiIhYiNjYiAdneBiIaAgYSFioyTk5OVmZ+gmZCKiIWIi4mEhIeGhYSDhIiRnaeoqlZUVFdYWVakpKGXk5eZk5OWk5KYnp2gopmOkJqjpaKhoFFSU1SAVVZUoJGDhIyRkod0amzJva+dmqi4v8trdICKkJabp7WyqKWenadYqaKnrqioWmJrcnNxcHFubWljYmZnZF5aWFtiZmVfWa9cYmhubmpoam9xb29wb2xlYV5dXWRrcHN0dHBtbG5tbnBwcHJya2ZrcW5qaGttbXN7g4aIiYuKg32AdW9ra21ubmxsc3x/fHp8fX17eHd4enp6fYCBg4WHhoF8e3+EiYyNjo+PkJCSkpWanZ6gop2Ujo6SnKJRUFBPT5yamZiXlpWTkI2NjoqEgIGEhoaHiImMjo+PkJKSjoyMj5GQjYqKi4uMjIiDgYKDgHp3eXt6d3Z1c3Bvb3F0eXqAdHBub29uamptcHd6dnRxamG5v8LDY2dpaGhsc3l+goSKkJORjoh/dnV0bme/sqWcnaCakpKSlpiepbK+YmZobHByc3R2eHZtZ2VgW1tgYmFet7KwrrK3uL9lbHF0c3J1enx6fHt5d3Z1b2twd3l3dXh3c25tdHt+fXh3eHd3eXs9e3p9goN/eHd6eHqChIGAgIWIgn18f4KFhIOCgH+Dh4SBf35/g4eHhoeKh4N9foJ/eHN1e35+fHl5enx+gYSEgIWHio6SlJGRlpqZl5qdnZqYmZqcmpeWl5B/a1xVUZaUTlRYWl1iZmlrb3R7gYKAfXt3c3N2dnZ3dnJtamppamloaGllYWJkYV9eXV1fYWNlZWZnZmhrbnFxb21qZWNjYmNmaGVeXF1hZWZlZGVlYmBeX2NjYGFjYmBgYV5dWqikgKpZXF5gY2ZrbWxmX11eYGZoY2FiY2JgXVpZWltbW1xcXFtbXF1dXFpaW11fXVteY2JZpaKmVqedlZOYn6SdlJCKjZOWl5qbl5GLiIuMkJKTmJ6ZlJagVVdYWlpXp6CgoJ2dnZqVlJOVkpafoqSmpZyanZmapq2qm4+NjJCanJ2bP5SMjpSfp6SbnKCdlJOSjIuQlJSUkZGRj4yMlKKnpKGgnpmXmqCdlpmjrKignZqXmJaSkJGPjYmIj5eiqqagpv9+3H6Hf5p+h3+Lfol9j34Bf4Z+mX8BfvR/hYDRf4R+l3+QfpV/iH7/f4d/gn7ef4N+sX8Efn5+f6B+hn/jfgICBACAxM3a4OHd2tjU1NTSzsfBwcHEy9ff39vY3eXk4eDg393b1M7Kxb/E0NfW197e1srBvb/EyM3U1tTV2dnQwra2t7a2u7/CxcvPw7a0vtDYzcTDxcTGwresq6qmoZ2fpaSempmYmZeVlJifo6Kfn6rByMPI1uTfy725ubq0r7K9w8OAxcnDvbmxsbq+vMLO0dPV19POy83PzsjAubWztK+gloqIjZKZp6mkqauoqamprrS8v8HGzdHR09jX09ba2NXU0M/S2t7Vx7qyuMLCwcrIv8PU4OTn7O3v9PX0+YCB+/j39vT18ufa09Te6O/v8PX3/P748vHy7+zt6d3R0N3m4dyA3NbBrKaqr7K5xdXWyL21rq25xMnHxsjM0Nfm+oaQlpSRkY6IhYSDhIP88viBh42Sk46KjZCOjo+Oio2TlZeVjoaA+/Xx8PX6gYiUnJiQi4yOjYyKi5Shp6ajoqKlqa6xsrKvra+xtrayrKKThfuCjpeaoqywrqiinJqdo6yxtLaAt7Sxs7e6vL/DxL62tLKxsbGuopWSmqWusLW4urq2trq9v8PL09ne4d7b3N/e2dne4uPk5uTg4er09vTy9fb19fb5+/r18vHx9PTs5N/d3t/g3drd4ur1/4OFhID7+vn28uzl4N3b2djX2NjY19TRzsnEw8XJy8jDwsTJzs7LyMeAzNLQyb+4srCws7rBxMO/wsnLy8rKy8zGuqykm5OOioeIiYyNkJedpKy0usDBv763rqelo5+bmJWRjIT16uXb09TY3eLv+oKKlJ2hpq20u8HIy83W3+Li493Wz8fGx8bCu7Suq6yws7W1tLGvra2xtLGwsK+trK61ur+/vbq3sKqAqa6zs7KytLO1uri2vcfJyc3T1dTSzcrJx8K7vL/Avby8ubq/xMK+t7W2tba6vb++vsLHzNHRzczP0MvGwcLExcXExcfO1NTQzc3OzcnDurKvsbW2trW4vb22rqikn56gpKissba3t7azsrOzs7Grp6OhoqWoqa2xs7Gqo6CgnZqAmpygo6OhoKausK2sra6rp6mxuLmyq6qrqqmss77IxryyqKOlo5+coKepqKiprK6tq6mqsK+qqKyurrCwraqmnZeYoayuqqWjoZ6eoJ2UjIuKjI+SkY2KiIuUmpiQh4OGiYWCgPr09PyDi5KSiPjl2dHLxMHAvLm7vMDI0Njc2NmA6PuHjpKSjYWBhY2QkIuE9drGwcDDxMzk+IOE++vb1tXV2+by+/7/hIuPk5aUj4mC8eLd2dXZ29TS1NDIw8PBwMHAvrm4uL27tLjD0dHNzc7S19nc5e3u5+Lj5+bm6Ovo4d7i5urt7Onn4eHq7d7LxcvZ393a2Nzh5ePc09HTzsaAo6u4v8C7t7a0tre2sq6pqaeorbe+vrq3u8TCvr2+vb28ta6rpqGlsri5ub6/t6uinp+jp620tbW1ubmxpJqbnp2coaaqrbS3rJ+bpLW8sqmpq6qrqZ+WlJOPiYWIjo6HhIWGhoN/foKJjYuHhpCmrKaotsXBsKOhoqOemJulq6qAqq+oop2Wl6Cko6mztri8vLayr7CysKmhnZ2fo5+Rhnp2en6GlJaRlJaRkpKSmJ6lpqapr7Oztrm3tbe5uLa0sa+zvMG4qp6XnKSjo6qpoKKvubzAxcXFx8fHy2pqz8zLy8nMy8O4srC3vsLCw8fJzc/LxsXHxsTFv7OoqLO8t7OAtbGhkIqNkZWdqrq7rKGak5Kdqa6sqamqq7C8zW93e3p3dnRvbGxsbWzRyM1rb3R4eXRxc3V0dHZ1cXZ8fn99d29q0MvIx8zRbHN+hIB3c3V3eHdzc3qGjIqHhISHi4+Sk5KPjY6QlJWRjYV5bMxrdn2Aho+Sj4uGgX+Ch46SlJWAlpSRk5ibnJ6hopyXlJKSlJWSh3t5gYyUlZibnZyYl5mbnKCnrbG2uLe1t7m3srG0uLi5uriztLzExcTExsfEw8TIysnGw8LDxsa+trGvsbO1s6+xt7/I0WtsaWXGxcbEwLy4tbSzsa+trKurrayrqaSfnZ6jpaKenJ+kqaqnpKOAqK2spJyXk5GRlJqhpaOfn6SnqKeoqqqmnJGLg315dnR0dXd3eX+EipGXnKGjoqGbk4yKiISCf317d3DPx8O6sbCzub7L13B1fIKDiI+WnKKmqKu0vb/AwLy2r6elp6eln5mTkJCUl5mZl5WUkpGUl5STk5KQjpCWm6Chn52Zk42AjZGWl5aXmJiYnJyZn6aoqKuwsbGvq6inpaGcnKChnpycmpqfo6KemJWXl5eanZ6dnqGlqa6uqairraqkoaGjpaSjo6SrsK+sqamqqqijmpKPkZWVlJSXnZ2Xj4iDfnx+goaKjpKTk5GPjpCQkY+Lh4SEhYeIiYuQkpCJg4OEgn+Af4KFh4aEg4iPkY+Njo6LhoiQl5iRi4mKioqNlJ6mo5qRiISFhH99gYaIh4eIi42NioiKkI+Kh4qMi4+PjYqGfnh6gouNiIOBgYCBhYN7dHJxcnV5eHRwb3J7gn94cG1wcm9tas/JydJudn5+dNC+s62opKGgnZqdnqGosLm7t7aAwtJyeX19d21obXV5endwz7ajn6CkpqzA0m9x1sa2srGxtb/K09bWbnN2eHp5dnFryLq3srC0t7Kws7GqpKOgoaOlo56cnKOhmp2ns7Svrq6xtri7xMzMxL6+wMHBwsXCu7a3ur/DxL+8uLvHy76ro6m1u7m2tbi9wsC5sK6vrKaAi5Gbn6CcmZiXmJqZl5OQkJCSlpyipKGdn6Sjn56enZ2blZGPjImOmJ6dnJ+el46IhoaIio+VlpeYnJyVioKEiIeFiIuNj5SVjoaFi5eclY+Qk5KTkomCgYF9eHR1eXhycXJzc3JvbnB2eHd0dHuNlI+QmqakloyLjY+Mh4mRlJOAlJiTkY6JiY+Qj5SbnaCjpqKem5ucmZONi4yOko6CeW1rb3N5g4SBhIaDhIODh4yQkZCTmJqanJ+fnZ6fn56cmZman6OckYiChYqHhIqMhomTmpueoaGhpKWlqFdWqaipqqmppqCYlJOYnaCgoKKjp6imoaCfnpyem5SNjJOXkY1XkJCFenV2eHp/h5OUi4SAfXuCjJCPjY6PjpCZpVheYmFgYF5bWVlYWVmtpqlXWVxeX1tZW1xaW15eXGFmZ2dlYVtWqaWjpKmtWV5lamdiX2BiYmFeXWJphW2Abm9ydHV1c3FxcnR1cm9qYVipWWFnZ2twcW9samhnam1xc3R0dnZ1d3t8fX6BgXx4d3Z3eXl3b2Zla3N4eXp8fn57eXt9f4KHi4+SlJKPj5COi4qNkJGRkpCNjJGXl5aWmJmYmJiZmpqZmJeXmZiSjImIiYqLiYaIjJKYnlBQT0wKlZaXmJeWlJKRkYWQgJGRkI+NioaEhYeJiIWFh4yPkI6Li4+Tko2Hg39+fYCDiIyLiImOj5CQkJGSjoZ9eHNtamdlZWZnZ2lvc3h9gYWKi4qJhH55eHZzcW9ubGljurOyqaGeoKWpsrtgZGtwcnZ7gIWIjY+SmZ+hoqOhnJeRkJGQjYmEgH1+goSFhoWDgIKBgIKDgoGBgH17fYKHi4yLiYeCfXx/g4ODhIaFhYiHhYuRk5OVmJmZmJSRkI+NiYqNjYqJiIaGiYyMioWDg4KChYiJiIiKjY+TlJCPkpORjYqKjI2Mi4uMkZWVk5GQkJCNiIF7eXp8e3l4en59dm5oY19dXmFkaGxvb25tbG5xPXN0dHFvbm5vcHBucHJ0cm5ra2xraGhpbG1samltc3RycXJycW9wdnt7dnFwcXFxcnZ9gn95cmhkZmdlY2WEaIBpbG5ubWtscG9saWtsbG1ubGpoY19gZm1ua2hmZWRmaWljXl1bW11fYF5dXF5kaGZgW1lcXVpZV6uoqa9aXmJiW6aYkY6MiYeHhYOFhomPlJuem5ykrVxgYmNgW1hcYGFhXlmol4qGh4qKjp6tXF2ypZmWlpeboqisrKxYW1xeYFRgXVpWoZmYlZKUlpOTlpWPiYeGiIuNi4iGhouLhYaMlpeTk5WYnJ2epKqqpKChpKOioqOgmZWXmp2gn5yamJujpZuNiIuVmZeUkpWanp2YkpGSkIz/ftx+gn+/fo1/g36Wf4Z+pX8Bfup/hIDff4t+/3//f6B/hH6Ff5V+jX+KfoJ/jH6Jf9B+AgIEAICAgPjs5+bp7O/w8PDt5dvSzc3NysnKzM7Nz9nk84GKjo6KhYH48vDx+oGA+PDx9/jx7O3y9vf18Ovo7PH09Oze0cjDwcDCyc7LysvR2Nzd29jRzc3Py8rJx8G7t7m7u7e2trm8ubjAy8u5qKGdnZ+en6Oqr6qpr7a9vr/Cw8LEx4DM0NDT2NTNxr/BxcfBubW1uL7Bu7Swq6afl5WTjIP0+4OJjZGVmqOoq6+2vL6/vbu5t7e4uru7u7/GztLT09DLyc3W3t/a2d/k5uz1+4GChoyRkYyHhISHiYmC9evp5tzNxc3Y2tLJyM7Z4+Le2tPMztLW3urw8Ork3eLzgIOCgoCDhISIjpOQhvrr5ef3gP/4+YKHiIiIhfzz8vT4+/fx8f2HiYX++Pj8//748fDy8u7w94CFh4mKjJOZn6CcmJmamJWWl5aTkZCOjI2NiYWFiIiE9+je2+Dn6/KBiZCXmpmYnaKkpqObl5iepKqqpqOkq7a8urCopqWjoKGhn52dpICxubu7u7m1srGys7O0s7Gtqaemp6inp6Wkop+dnaGrt8LIycO1qKCepK62vLu0r7G5xdPd4eHf3+Hl6ezu8fPy8O7u9Pv++/j18vPz8u3p6Ojo5+jo6ejo6urr7O3u7e3u6+fk6fDz9PDs5uDa2Nzk6ero6ezw8u/r5uHa09HR0lbT1NTT0s7Jys/W29zc2dHIvri4u8PL0NPY29zZ1dHMyMTCwcHDv7eto5iSkY+Rl5yhoqautbe1t7/FycvJx8XDv7itoZuXlZOSkI+Ni46UlpmfqLC6wITCgMG+v8HEyMzO0NbY2NbU1dbV09TU0s3Ix8bHyMjJyMS/v8PHycrIxsXDw8PFx8jKysjGxsTCxcnNzsvIx8jHx8rMzMvN09XV1dbY2dve39/f3t/h4+Li4+Ph4ODe3dzd3t/e29bRzMnIyMbBvLu6uLa1t7m7v8PCw8TGxsK7tbGxAq+phKaAqKmssLCvraytr7K2tra0sKysrKusraysq6uqqqmoqaqpp6amp6qqqKepqaqqrbG2ur7Cwr64sauoqKahm5aSk5Wan6Okn5eUlpiZmZiXlJKQjpCVmp+enJqYlJSTkI6MiomIhYD6+4KHhf74/ISKiIL38vP3/4KCgv/8gISIjI6AkZSanZyWj4+TlZSRj42LhoD18vDr5ujs7Ozq5uPm6Onr7Ozs7vLu497l7u/q5+jt8vT2+fr69/f5/oKEhoaB9OXc1M/Oz9XX09HU19XLwr+/urCttMHT29vc4eXc1tvi4dvX2NfT09TS0dLV1NPV2+Lm6Obh3t/h4uPj4tjW3+4g9PT2+4GBgICChoaFhoaC//6Bgf307/Hz8/X3/4WHhIGAamrMwr29wMXIy8zMycG3ramoqKalp6mtrK22wM9udnl5dW9rz8rJy9RvbdPMzdPTz8rKztLT0MrHxcnO0NDIu66moZ6foqiura2vs7i7u7ezrqqsr66uramknZmbn6GenJydoZ6fqLS1o5KJhIWJiouQlpiVlJmgpqenqamoqKuAr7O0t7q2sKqlqK6wqaGfoKKrr6mhnJmVjoeFhX512Nx0e3+DhYiOkZOXnqSlp6akop6dnJ2enp2fpq6ytLOxq6istr6+uLe8wL/CyM1qa290eHdybWtscHR0bs7GxcS7rqevubmyqKWptL69ubSuqKiqrrbCx8W/ubK2xGhqaWiAaWlqbnR6eG/Nv7m9zmvUy8pqbm9ubmvLxcXIy8vHw8XQcHJt0MzN0dTTzcfGycnFxs1rbnBxcXJ3fYKCfnt7fHt5e319e3h3dHNzc3BtbnFybs/Buba7wMTJa3J5f398e4CGiYqGf3p7gomNi4aDhIyYoJ6UjImIhoSEhIOBgIdYk5mamJeVkpCQkZKTlJORjIiHiImKiomHhYOAfn6Bi5agpaWglImCgYeRmJuZkoyOlqCttri2s7O1ub2/wcTFxcPBwcbLzsvHxMHCwsG9urq8vLu8vL28vIS9gL+/wMDBvbm2usDExcLAu7axr7K5vLy6ur3Bw8K/vLizrKqrrK2vrq2rp6OkqK+ztbWzraWblpaZoKerrrK1tbSwq6ain52dnp+clo+IgHt7eHp+goWFho2Tk4+Qlpygo6KhoaGemI+FgX57e3p5d3VzdXl8f4WMk5yho6Kio6KfgJ+ipairrK6ytbSysLCxsK+wsK6ppaSjpKanqKeinZ2hpaanpaOioKCho6Wlp6elo6Ohn6Knq6yppaOioaKnqqqoqq6vr6+wsbKztba2tbW1t7m4uLm4trSzsbCwsbK0tLKtqKOhoaGfm5aUk5KSkpSXmJudnJucnp6alJCOj46JGYWDhIWHiY2QkI6Mi4yPkpWVlJKOioqKiYmJiICJiomHhoaGiImIh4iIiIeJjJGUmJubmJSPioeHh4N/eXV1eHuAg4SAeXV4ent8e3p4dnNxcnd8gIB/fHl2dnV0cnFwb25saMvObHFv0svPbXR0btHLys7VbG1s09BqbXBzdHZ5f4OBe3Rzdnd2dHJycW5pysjHwr7BxMTDwb27vYDAwcTGxsXGycW8ucDKy8fDw8fLzM3Q0dDMzdDVbnFzcm7Nv7avq6mrsbKwrrC0sqqioJ+bko6UobO8vb3Bxb64usHAu7a2tbKys7CvsLKzsrS6wMXGxMC+v8LCxMPAtrO8yM3LzNBrampqbG9vbm5tac7OaWrPx8LEx8fJy9VwcgJva4BXV6ignZ2go6aoqKimoJmRj4+Qj46QkZOTlJujrlxhY2NgW1mtq6qss15ds62tsbGsp6aprKyqp6Sjp6usqqSbkoyHhYSEiY2NjpCUmJqZl5SPjY+SkZGRj4qGgoSGhoSCg4WIhoaMlZaJfnl2d3l7fYGGiYWDhouQj46PkZCRk32WmJiZm5mWko+SmJuXkpGSlpyemZKOjImDfHp5c2rEyWtwcnR1d31/f4KHi42Pj42LiIaHiImIh4qQlZiZmpmVk5SZn5+amJ6hoKKnqldXWV1gYV1bWltdYGBcrqipp5+Vj5Wbm5WOi42Um5qYlpKMjIuMkJicnJmXk5afU4ZUD1ZaXl1XpZ2ZnKhXraWjVYRYelenoaCho6Ogm5uiV1lWpKGjpqusqKWjpaWio6lXWVpaWVpdYGNkYWBhYWBfYGJiYV9eXFtbW1hVVlhaWKigmpibn6GlWFteYWFfYGRoamtpZGJkaGxubWtoaW92fHp0bmxraWdoZ2dlZWtzeXl3dnRyb25ub3BxcXFvhmw8a2loZmVjY2ZtdXx/f3t0bWlpbXR5e3t3c3R5gImOjoyKioyPkpSVlpeVlJOUl5udnJmWk5SVlJGPj5GRhY+AkJKTk5OUlZaWl5SRkJSYmZqZmJWSj4+QlJeYl5ianZ+dm5iVkYyKioqLjY6NjYqHh4qPk5SUk46HgHx9f4WLj5CTlpaWko6Kh4WEhISFg354cmtnZ2Znam5wcHF2enp3eHyChomJiIeHhH94cG5samlpaGdlY2VqbG90eoGIjY1HjYyNjIuKi46QkpOVmZubmZeXl5aUlJSTkI2MjI2Oj5CPi4eGiYyMjIuKiYiJioyNjY6OjIqKiYiKjpGRj4yLi4qLjpGRj5CFlC6VlpeZmpqamZmam5uampmWlJORkJCRkZKRj4uHg4CAf357d3V1c3NzdXd5e3x6hHkldnJwcHJxbWtrbG1vcHJ0dHNycnJzdnh4eHZzcHBvbm1sa2trbYZvgG5tbGxtb3Bua2xra2prbXBzdXh4dnRxbmxsa2hlYV1dX2FjZWZjXlxfYGFhYGBfXVxbW15hZWVkY2FeXl1cW1pZWVhWVKSmVlpZqqaqWV1dWa2pqKmtWFlYratWWVtdXV9hZWdmYVxcXl9eXFtaWVdToJ2bl5WXmZmZmJaWmJqbgJ2goaGipaKbmaCnqKajoqWnqKmsrq6tra+yWlxdXVmpn5mTj4yMkJCNjI6RkYuGhIWDfXp+hpOZmZqdoZyYmqCgnpqamZaXmJaVlpiYl5mdoqWmpaOjo6Wlpqajm5mfqKqnpqlWVVRUVVdXVlZWU6KhUlOinZudoKGjpq1bXVlXgn+bfod/hX6Cf/N+gn2tfo5/oX6Mf4V+BH9+fn6Gf4p+g3+OfqB/iH7/f/9//3/ufwh+fn9/f35+foR/hX4Ff39/fn6Wf6l+hX/Ffot/BH5+f3+JfoR/AgIEAICA/vr18vP1+v3//PTq5N7e3d7e29ne6e3o3tbS2ePq6+709/f5/YGA+vX8goWIiYiIh4aEg4OB+vTy8O7o4dvc4u75//76+vz+/v+Bg4SDgYGCgYOEg4D78+rh3uXz/oKCgf/89/P08+/t7O3p4djU2ufv7+vm4Nzb3NzX09HS0zzRzczKycbCvsHEx8nIxMPFyc3Ozc/T1tPKwsDByM7Pzs3KxsXGyMzOy8e/u73DyMfBvL/I0dfZ19TS0dCE0YDU1dXZ2dvd3t3d29fJvLjAztrd1dHS1dXTzszN0dTZ3uPo7PDs59zb3+jt7/T9g4iKi4qLi4qKiYuMkJadoJqNgPj8hImKioiHh4qPkJCQkZSWlY+HgYKFhYODiZSepKShm5SOiP/o1MnM1Nnh6Ons8Pb8gIGAgIGChIeKi4qKjEqNjo+TmJ2io6GfoKOjoZ+YjoiHiY2RlJKPjIyNkJSYmpuZl5iZmZaQjo+UmqGlpqittLq6tq+nnZWQkJOXnqizur29u7Wvq6uqqYaogKmtt8DHycbBuLOztLKurK2ws7W3urm1sLCxt8HIzNLX29/l6u/x8/X29/f3+Pj28evn4+Pl6u7v8PH09/v8+vfz8e/u7Ovs7/Hv6uPd2tnY2NbU09PW29/j4+He2tfV0tHR19rZ1tLW2+Pp7vDw7urn4+Lj5Obm5OLg3NrZ29vbD9ra3d/i5ebl5eXk5Ofp6oTsFOvq6ufi3djV09DMysnLzs/NysvMhMskzc/Q0NDR0M/P0NHS0tPU1tjY1M7KyMjIy8vKysvMzc3Ly83PhNBU0tPRzMjHyc3Q0tPS0c/OzMzNz9DQz9DT1dTU09HPzMzLysnKzM3NzMzNz9HR0dDP0NHS0dHR0M/OzczKycnJysvIxMLBwb+8urq7vL27uLW0tLKvhK6Ar7Cxs7OxsK+rp6ShnJSOi4qKjI6Qk5OUlJKRkZKUlZSUkpKUlpmdoaeqqqioqKmqq6qpp6Win5uYlpeanqCjqK60ub7Dyc7Py8W+u73CxcXCvrqzsLG0tbSxrKehn6Ckp6mqq7C3vb++vLm0q6KcmJWTk5ebnZuWk46H/O3n5+qA7fD2gIOCgPv4+f2DiZKYmpmWj4yPlpqcn6eusa6us7i9vru4tbKtqKWjn5qVkY6Lh4OCgoWLkJKQioaEhIWIh4WDgYGA//+BgoOEhIODhYiKiIT/+fj7gYKB+vPt6ebm6O3y8+7p6O309PL0+/nz7/Dw7ejf1tXa5vaBg4KEiI5FkI6Kh4P/+vPu6OHVz87Y4ubk4uTu+YCCgf/7/YD/9und0snDvb3Ay9fk7/b17+ji29bS1trc2t3tgImMi4aC+PLx+4CCgGzUz8nHycvR1djUzcO9ubm4ubi2tbjCxsK5sq+zvMHDxcvNzc7Sa2vRztRucXR1dXRzcG1sbGvRzMvJxr+4s7S6xtHX1dHQ0dPT02ttb25sbGxrbG1sac3Gvbazu8jUbW1t2NXRz8/NycbFxsK7s6+0wMfHxL+6tra4uLWxr7CxgLGvrq6urKijpamqq6mko6SnrK6vs7i6t66mo6OrsbOysK6pp6eorK2qpqCbnaSqqqOdn6eus7SysK2trK2urq+xsrK1tLa6vLy9u7eqn5yjrri5sq+ws7WzsK6vsrS4ur3BxMfFwbe2usHExcjOam5wcG9wcHBvb3BydnyChH5zgGnLz21xcnFwbm1wc3R1dXd7fn12b2lrcG9sa3B6hImJhn96dXDRv66mq7O3vMC/wsbM0mtsamlqa2xucHBvb3BxcnR3e3+ChIKBg4eIh4V/dnFwcnV6fHt3dHR0d3t+gIB+fX5/gHx4dXZ6foOFhomOlZydmZOLgnt3dnl8gouVgJudnJmUjouLi4qKiYmIh4WGipKco6WinZaRkpORjYuNkJOWl5iWkYyKi5GZnqKmq66ytru+wcLDxcbGx8jHxMG9ure3ubzAwcHBw8fLzcvIw8G/v72+v8LEwr63sq+vr66sqaenq7C1uLi1s6+sqaalp62wsK2prLG4vcHCwr+7Dbi2tba4ubm3tbOwrq2EroCvsbS3ubi3tbSztLa3ubu8vb28u7u5trKvrayppqWkpqiqp6WmqKinp6eoqqqqqaqqqKenp6ioqqyusbGtqKWjo6SlpaSlpqeop6amqKurq6qrrK2qpqKhoqaprK2sqqimpaSlp6moqKqtr6+vrqyqqKempaSlpqempaWnqaqqqQ2oqKmqqqmoqKmoqKemhKSApaWjn56enpyZmJiZmZmXk5CPjo2LiouLjI2PkpSVk5KQjYmGhIB5c3Bub3Fzdnh5eXl4dnd4enx7eXd3eHl8f4OIioqIh4eIiYmJiIeFg4B9eXh5e3+Bg4iOk5icoKSoqKSemJSVmZycm5iVkI2NkJGRjomFf31/goWHh4iLkZaAmZmZlpKJgXx4dnV3e3+AfXl3dG7Mv7q5vMDDympubWvRzMvOa3F5f4GAfXd0d3yAgYSKkJKQj5OYm5yZlpOQjImGhIF8eHVyb2toZ2htdHp8eXJtamprbGxqaGZmZszMaGlpaWhnaGtucXBt0s3M0GttbNLMyMTBwcPHzM3Iw8JeyM7OzM/T0szJy8zLxryysLO+zGtta21xdXh2c29r0s/KxsG7sKustb/CwL2+xc5qbGzU0NNr18/EubCoop2doKmzv8nQ0MvFv7mzsLS4ube3xWt0d3Zxbc7JydJrbYBZr6ynpKSlqKuurKegnJeYmJqZl5WXn6Gdl5OSlpyfoKKmqKioq1dWqqqvWlxeXl1cW1lXV1dWqaWko6GemZWWm6SssK+rq6ysrK1YWltaWFhYV1dYV1aopJ6Yl52osFpaWbKyr62sq6impqeln5mVmqOpqKainpuanJyZlpSVlICSkZGSk5KOioqMjYyLiImLjpKUlZibm5eRjIuMkpeYlpWUkY+NjY+QjoqFgYGHjY6JhYaMkpWWlJKQkJCRk5SVlZOSlZSWmpydn56ckomGi5Oam5WSlJeYl5WVlZianJ2dnZ+ioZ6XlZidn5+hpVVYWVpZWltbWllZWVpeYmVjXIBVpqhYW1taWVlZW11dXFxcXmFhXFdUV1taWFdbYmdpZ2RfW1lXppqPiY2Tl5qdnZ6hpalWVlZVVVVWVldYV1dYWVpbXV9iZGZlZGZpaWhnZV9cXF1fYWNhXlxcXV9iZGVlZGNjZGViXl1eYWRnamtsb3R4eHZyb2pmY2RlZ2pxdoB7fHx8eHRycnJxb25ubGxra21yeH1/fXp0cnN0c3BvcHFzdHV2dHBtbG1xd3l7foGDhoiKjI6PkZOUlZWWlpWUkpCOjo+RkpOTlJaZnJ2dnJqYl5aUk5OUlZOQi4iGhoaFg4GAgYOGio2OjIqHhYOBgIGGiYqIhYeKj5KVlpaUkTyOi4uLjI2NjIqJhoWEhISDg4OEhoiKi4uKioqMjpCRk5OTkpGQkZCPjYyLiomGhYSFhoiHhoaHiIeHiIiHioKJhIoPi42Oj4yJhoWGhoeHhoaHhYg6ioyNjIuLjIyLiIaFhYiKjI2NjIuKiYiIiouKiouNjo6OjYyKiIeFhIOEhoeIiIiJioqJiIeHh4mJiIaJSYiIh4aFhYaFgoCAf317eXl6enl4dXNzc3Fvbm5vb3BxdHd4eHd2dHFua2hjX1xcXV9gYmNkZGVkY2RlZ2dmZGJhYmNkZ2pucG+EbYBub29ubWtpZ2VjYWJjZmdobXF1eXt+goSFgXx2c3J0dnZ1dHJubGxub3Bua2hkY2RmZ2hnZ2pucXNzcnFvaWNgXl1dXmFkZWNhX11Zp5+dnZ6hoqZXWlpYraurrVhbYGRlZWRgX2JmaGlrb3R1cnJ0d3l5d3RycG1qaWdkYV5cWxtZV1RTVFZbYGFfWlVUU1NUU1JRUFBRo6RSU1OEUndUVlhYVqemp6tYWlmtqaajoaGipqqppaCeoqWloqOmpaKipKWlpJ2WlJefqllZWFlcX2FfXVpYraunpKCakY2MkZibmpman6VVVlWno6ZUqqSdlY+KhoKChY2Um6KoqKSgnZqWk5aZm5iZpVlgY2JfXLCsq7FZWgF/pX4Ff39+fn6Mf5R+jH+IfoN//36NfpN/gn6if45+/3//f/9//3+Hf4h+hH+Efrp/gn6Mf4R+g3+gfot/kX4Hf39/fn5+f5x+hn+EfoJ/AgIEAIDJyczT3ur0/oGDgv/46trMxcnS2d3g4uLi5vL7/oD/+vX09vj7+vn6/Pv5+/6BgoKCgP78+/2AgoOC/vn08/X3+fn7gYODgoD+/v+BgoH9+fj7+/j08O3q5t/Z1tbX1c/JxMLFzdvs9fHt6+zv8fHu7e7w8fDv7+/u7vDx8vX3+XP6+/+ChIOB/Pn39vPx7eno5uLf3t/k6vL39/Pv7ezs6eLc19PPy8rLz9fe4uPi4eDg4uTo6uro5ePi4d/Z0srFxMfO1djZ2dvg5+708+/s7e/0+f+Bg4WDgf/+gYSHiYqKiYiHhoOB/vv6+vv59/b3+v6AhYEYgICAgoWIi42NjY6PkpSWmZual5KNiIaGhIcziIqLi4yMi4mJiouKi46Sl5iWko+NiYWB+vby8vX5+/yAhYyUm5yYko6MioiGhYaJjI+ShJUslpeYmJmco6qxs7KvrKmnpaSkpqqusLGxr62qp6GcmJaWl5aVk5KVmqCor7KEswuxramjoKCipKWlpISjgKaqra+wr62sra+ytbrAwsHAvLiyrqmkoaCip66xsKqkoqSqr7S6v8PJzc/P0M7MysnJyMfGxcTDxMbIys3P0tbb3uDi5ens7u7w8vX4+/39//7+/Pv7+vn5+vr8/Pz9/f3+/vv6+fv+gIGA/Pf08vLw7+3v7e/u6ejk4eDf4ePlgOXk4+Li4d7c2tnZ2dfX19jZ2tnY19XS0tPU19rc2dXRzsvLzM7R1NfZ29rZ1tTT0c/Ozc3MzMvKyMbGx8jKycjGw8G+vLq5ubq6u7u8u7q4uLq8vr6/wMHCw8XGyMrMzc7LyMO/vLi2uL3FycvKysrLzM3Oz9DR09TU0tDNy8fDGL68vb7AwL67uLW0s7S1tbW0tbi9wMC8tYSxgK+trKyvtLi5uLW0tbe3trOvrKqqqqmpp6eoqqurqqmop6Wjo6SmqamoqKqsrauopKGgoqOlpqeqsbi6u7azsrO0tbSyrqmmoqCfoKOlqKqtsLGzs7KxrqumoJ6eoaOjoJ2cnqGmqq2ws7S1tLKxsbK1ubzAwsLBwL++vb28ubazL7CxsrS0srCsqaalqayvsbGtqKSjpampp6SgnZmVkpGSlJeYlZGOjY6Oj4+Rk5eZhJoYmZiXl5mcnp2bmZianZ6fn6Cgn52ZlpWVhJSAlZWVlJOTlJSTkZKVm6CgnpuWko2IhoWFg4GB//ft5+Pd19PS0tXa3t/g4eLk5+vw+YGHi4yNjIuKjZKYnaCioJ6cmpmZmZeVlZSUlZWVk5KRj46MioiHhoaGhIH79Ovk5Onw9/j48+vl3NHIw8bK0NLW2dzg5urp5+Lg4OHk5+oL7vT7gYL+9OfYzsiApqapsLnG0NlvcG/Z08e6raWnsLW6vb/AwcXQ19pt2dTPz9DS1NLQ0dPS0NLVbG1tbGvS0NDSa21ubdbQy8nKzM/Q02xvb21q0tLSamtr09DR1NXT0MzKx8O8trS1tbSwqaSipa26ytHMxsTEx8nIxsXGyMnJyMjJycnLy8vMzcxzy8vPaWtratDOzMvJx8TBwL66trW2usHJzs7LyMbHyMXAuraxrqqpqKyzub29vLu6ury/wsXGxcPBwb+9uLCppKOmrrS3uLq8v8XKzcvGwsHDxszSa2xtbGrQ0GpucXNzc3JxcG9tbNXT0tLS0c7OztHWbIRtCGxra2psb3J0hHWAd3l7foCCgn96dnFvcHFycXJzdHV0dHNycG5vcHBxdHl8fXt4dXNwbGjKxsPDxcnLy2htc3uCgn54c3FwbmxsbW9zdXl7e3t6ent7fH2Ah46TlZOQjoqIhoWEhomNkJKSkY+NiYR/fHt7fXx6d3Z4fIKKkZSTk5KSkI6KhYODhYaAh4aFhYSDg4WIi42OjIqJi42Qk5ebnp2cmpeTj4uHhIOFi5OWlY+Hg4WJjpKXmp6ipqenpqSioJ+fn56dnJuampudn6CipKesr7Gytbi6vLu8v8HFyMrLzMvKycfIx8fIyMjJyMjIycnKysjGxsjLZmdlx8TCwcHAwL/AwMG/u7kTtLKxsbK0tre2trW1tLGvrq2trYSsXK2ura2sqqioqauusrSyr6qmo6GipKaprK+wsK6sqqmopqampaSjo6GfnZ2eoKKioaCenJqYlpWVlpeXmJiWlZSVlpiZmpqbnJ2foKGipKWmp6WinpqWkpCSl5+jhaUBpoWnS6ipqKelo6KfnJmZmpydnp2al5WUlJSVlJSSkpWanZ2Zk5CPkJCOjYuLjpOWl5WSkZGTlJSSj4uJiYmIiIeHiIuNjYyLiomHhYSFh4SJgIqMjYyJhoOChISGh4iKkJaYmJWSkZGSk5ORjomGgn99foCChYeKjY+RkJCOjImEf35/goWFg4B/goWJjY+SlJWVlJKRkZGTlZianJybmpmZmJiXlZKQjo+Rk5ORj4qGgoGEh4uOjouHhISHjI2NiYaCf3t4d3d6fX17d3RycnJzJnN1d3p8fXx8e3p5eHh6fH5+fHp6e36AgYKDhISBfnt6eXl4eHh5hXiAeXl4d3d7gISFg397eHRvbW1tbGtr1c/Hwb23sq6trrG3vL2/wMHCw8bK0W1ydXZ2dnRzdXl+g4aHhYKAfn19fXx7enl5e3t7enl4d3Z0c3FxcHBwb23UzcXAv8PJz9DRzMXBubCno6Smqq2wtLi7wMPCwb27vLy+wMLFyc9qatEFysC0qqV4iYmLkJehqK9ZWlqyraWck42PlpqeoaKioaOqsLFZsKypqaqsrayqq6yrqaqtWFlYV1aopqaoVVdYWKyppqWmqKqrrllbW1pYr6+wWFlZr6urrrCurKqopqOemZiXmJeVkY2Ki5CZpaqmoqGipKenpqaoqaqop6amhqUJpKKgnqBRUlNThKZSpaWkoqCem5mWlpicoqampKOio6SjnpqXk5GOjYyOlJmcm5qZmZmbnaCioaGfn56enJiSjIiIipCUlpeYmZygpaino6Cfn6KlqVVXWFZVqqtXWoVcMFtbW1pZsK+urq6sqamqrbFZWlpZWVlYWFdYWlxfYF9fYGFjZWZoaWhnZGFeXV5eXoVdhFssWVlZWlpaXWBiYmFeXVtYVlOhn52cnZ+holJWW2FmZmRfW1taWVhXWFlbXV+FYWdiYmNkZmpvcnNycG5tbWxramxucHFycXBvbmxpZmRjY2RjYmBgYWVpbnN1dXRzc3JwbmtpaGlra2ppaWloaGlrbG5ubWxsbnByc3V4enp5d3VycG1qZ2Vma3F0c29pZ2hsb3J1d3l8hH8ufXt5d3d3dnZ1dHNzdHV2d3h6fH+BgoOFh4mKioyOkZSVl5eYmJiXlZSUk5WWloSYhJkKl5aVlpdLS0uUkoSRIJKRkpKSkY6NioiHhoaIiouKiomJiIaFhISEhYSEhYWGhocxiImKjY+Rj4yIhYF/gIGDhYeIiYmIh4WEg4KCgoGAgH9+fXx8fX5/f39+fXt6eHd2doR3Pnh3d3Z3eHp6ent7fH1+gIGCg4WFhoSAfXp3dHJzd32BgoKDg4SFhoaHh4eGhoaEgoGAfnx6ent8fn59e3p4hHeAdnV0dHZ5e3t3c3BvcHFwb25ucHR3d3VzcnN0dXRzcW5tbW5tbWxtbnBxcHBvbm5sa2tsbnBwb29wcnJycG5sbG1tbm5ucHR4eXl2dXV1dnZ1dHJubGhmZGVmZ2lqbG5vcXBvb21rZ2VkZmlrbGpoaGxvc3d5e3x8fHp4dnV0dXYHeHl6enp5eYR4gHZ0c3JzdHR0cW9raGVkZmhrbW1raGZnaWxtbGtpZ2ViYF9fYGJiYF1bWVlaWlpcXV9hYWBgYF9eXFxdXl9fXl1eYGJkZWdpaWlnZWNiYWFhYGFhYGBgX2BhYmFgYGFlZ2dlZGJgXVpZWVhWVVWrpqCdmpWRj4+PkpeanJ6goaOkBaaprlpdhGBUXl5fYmVpamtpaGdmZWVkYmFgYGBhYmJhYWBfXl1dW1taW1tbWa2oop2bnqGlpaShnZuWkImGh4iMjY+Rk5WYmpqZlpWVlpeZmp2go1RVp6KakYuIiH6Df5J+AX+PfoV/hH6Ef4l+hX8Gfn5+f39/tX6Ef81+hX+Cfox/i366f4h+/3+/f4OA/3//f/9/nn+Wfqt/p36Cf4Z+AgIEAFP3/4GCgoODg4WHiYqLi4uMi4uLjIuKiYeGhoeHiImKiomIhYWEhIKBgP///4D++fXw6+rs8PP2+fr7/P3+/fz7+/z8+fj39fPx7+3u7/Dx8vX4+oT8Zvv7/YGEh4iIiIeGhID79vT09fX09PPy8/T3+vz9/Pz7/P6AgYGA/fv59/Tw7evp5+Xj4eHi5OXn6uvt8fb7/4GBgPz38/Dv8PT5/P38+PLs5uTj5OTk4t/e3+Xt94CDg4OBgIGCg4SEUYWHiImHhYH9+fPv6+fl5ujr8PT2+Pn5+vj08vDt7e3s6ufk4d/g4ePk5+ns7/L3+oCDhYeJiYiIhoWFhoeIiYmIiIeGhYSDgoD//v+ChIeJioSLgIyMjY2Oj4+Rk5icn6Kjo6GfnZ2eoKOlp6mpqKempqanqamnpaKfnp6foqaqr7O1t7e2tLOysrO1uLzAw8TEwr+8uLe3ubq8vb7BxMfKy8rIxsTCvrq2s7CurayppqSjo6KioZ+enp6foqSmp6iop6ipq66vsK+urKupqKakpKKhRaKjpaepq66xs7W1tbOzsrCuq6impaSmqKuusbS4vL/AwcC/vry6uLazsrGwr66ur7Cys7S2uLu+w8nO09fY2dra2djX1obXHtjY2drc3uDj5ejp6Ofl5OHe29jU09PU19vf4+fp6oTrgOrn5OHd3Nzc3uHi5Obn6Onq6eXi39za2djW1NHNycfFxMTDwsHBv728u7u8v8TJzc/Pzs3LysvNzc3KxsLAvbq3tLCtqqmopqShoKOnq66xtLe5ube2tbW0tLOysbCxtLa4ury9vby6ubq8vb6/v7++vby6ubi3tra1tri6vb+/bL68urq6u7u6ube1sq+sqKampqeoqKenqKqtr7CuqqaioaCfnpyamJSQjYuLioiGhYSDg4SFhoaHiImMjpGTlJaYmZmZmp6lq66vsLKztbe8wMPHyszNzc7P0NDS09bb3dzZ1tLOzMrIxsTDw4bEOMbHxsTBv768ube0sK2sq6qqqqmqrK2trauopJ+bl5WVlZeZmpqamZiWlZSUlpqgpairra2usLGyhLMQtLSysbCvrq2rqqqqq66xs4S0D7Kxr6yopKGenJuampudn4WgWaKkpqampaSioJ+enZ2cm5qamJaTkpKRkZKTlZaYmZmZmJaSjoqHhYSGiIqMjY6OjIiFgf749vb4+Pj39PDq5OLl6/H19/n59/Xz8O7t8PX7gIOHi42PkJGRhpJIk5aYmJiXlZGMiIWDg4GBgf78+fPr4tfKvK2fkYT15NjT0dHU3N7f4uDd29fY29/l7PP4g4uTn6epq6yvs7vEycvKx8nO1N/rP8/VbGxsbWxtbnBydXZ2d3h4d3h4d3Z0c3FxcnN1dnd3d3Z0c3Jwbm1s19bXa9TQzMfDwsTIzNDS1NXW1tbV1ITTJtHQzszKx8TDxMXGx8nLzdDR0dLR0dHTbG9yc3R0c3JwbNLOy8rLhcyAzc7Q1NXU09HQ0NJpampp0dDOzMnGxMPDwsG/vb29vr6+v7/BxcrP1Gxsa9LNyMXExcnP09TTz8nDvry8vb29vLm3uLzEzGpsbGtqaWprbW5vb3BydHV2dXJv2NTOyMO/vb6/wsfLzM/Pzs/MyMbEwsPDw8K/vbm3t7i6u73AwsQpx8vOaWttbnBvb25sa2ttbm9wcG9vbm1tbGppaM/P0GpsbnBwcXFwcHCFcVhyc3Z6f4KEhYSCf318fX+ChYeIh4aEg4ODhIaGhoSCgH5+f4KFiY2QkpOTkZCPjo6QkpaZnZ+gnpyZlJCPkJKUlpianaCkpqempKOhn5yYlZKQjo2NioeFhYRjg4KCgoSGiImKioqJiYqMj5CQkI6MiomHhYSEg4KCg4SGiIuNkJKUlZWUk5KRj4yJh4aGh4mMj5KUl5udnp6dnJyamZeVk5KQkI+Ojo6Pj5CQkZGTlJeanqGkpaaoqampqqqrhqx3ra6vsLK1t7i6uri3tbOxrqyppqanqKqusbW5u7u8vLu7ube0sq+tra6vsbO1tre4ubq4trOxr66trayqqKWhn52cnJybm5qYl5WUk5OWmp+jpaWlpKSjpaenp6SgnZqXlJKQjYqIh4aFg4GAgoWIio2QkpSTkpKEkROQj46PkJOVl5qbm5uZl5WVlpeYhJkSmJeWlZSTkpGRkZOVmJqbmpiXhZYKlJORj4yKiIaGhoWHaYiKjY+Qj4uHg4GBgH9+fnx5dnNycnFwbm1tbGxtbm5vb29wcnN1dnd5e3t8fH6Bh4yPkZKTlJSWmZyeoaOjo6SkpaamqKqtsrSzsa2ppaOhnp2bmZqbm5ydnZ6goaGgnZycmpeVkY6LiYWIJIqMjY6PjYuIg398enp7fX+AgYF/fnx7enp8gISIi42Ojo+QkIiPH46NjIyLiomJiYqNkJKSk5KSkY+Oi4iFg4B/fn18fX+EgVqAgIGDhIWEg4KAf359fn5+fX5+fHp3dnV0dHV2eHp8fn5+fXt4dHBtbGxtcHJ0dXZ2dHBtatDMy8zOzs7NysW/urm8w8rP0tXV1NLPzMjGyMzSa25xdHZ3eHiGd0l4eXt9fn59fHh0cG1sbGtrbNbV1M/JwrmuopaLfnTWx7y4tre8xcrN0s/Kx8G/wcTIztbcdH2Ej5WWl5eanKOrrq+sqKissbrFAquvhldgWFpbXV5eX2BgX19fXl1cWllZWltcXV5eXl1cXFtaWVdXra2uV66sqaajo6Woqqytrq6vrq2trKurrKyqqaempaOgn5+goaKjpaeoqampqKinqFZYWVpbWlpZWFaopaSkhqZPp6eprK2traysra5YWFhXrayqqKWjoaCfnpyamZiYmZmZmpqbnaGlqVZWVaejoJ6eoKOnqamopaGcmJaXmpudnZycnaGmrFlaW1pZWFlaW4RcUV1eX2BfXFqxrqqmop6bm5ydoaOkpaWkpKKfnp2dnp+goJ6dmpmYmZqam5ydn6CipFRWV1hZWFhXVVRUVVZXWFhXV1ZVVVRTU1Kko6RTVFZXV4VYhVlZWlpcX2JlZmdnZmVjY2NlZmhpaWhnZWRjY2NlZWVkZGNiY2RlaGttb3BwcG9vbm1tbW9ydHd4eXl4dnNxcHFydHV2d3l7fX9/fn18e3p5d3VzcnJycXBubGuEbBtramtrbW5vcHBvb25ubnBxcnJxcG9ubGtqaWmEaCtpa2xucHJ0dnZ1dHRzc3JxcG9ubm9wcnN1dnh7fX19fHt6eXh3dXNycXBvhG6EbwpwcXJ0dnh6fHx9hH4GfX5/f4CBhYIQg4OFh4iJioqJiYiHhYOCf4R9BX+BhIeLhY0kjIuJiIaFhIWFh4iJiouMjI2NjIuJiIaFhYWEg4J/fXt6eXl5hHgud3d2dXZ3e3+DhISEg4GBgoSEg4J+fHl4dnRycG5sbGpqaGZmZ2lrbW5xc3RzcoVxEnBvb29wcXN1d3h4eHZ0cnJzc4Z0BXNzcnFxhHAJcXN1d3h3dnV0hHUZdHNycW9ubGtra2xtbGxrbG5wcnJxbmpnZoRlG2RjYV5dXV1cW1pZWFdXV1hYWFlZWltcXl5fYIViDmVpbnBxcnN0dHZ4enx+hYAngYGBgoOFiYuLiYeDgX99enh3d3d4eHh5eHl7fHx7enl5d3V0cW9thmwQbW9wcXFwb21qZ2VkZGVnaIRqCmloZmVkZWhsb3GEczB0dHNzc3JxcnFwb29ubm1sa2tqa2xub3BwcG9vbm1samlnZmVkY2NjZWZmZmVkZGWEZgdl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m5qZmZiYl5aVlZSFkwWSkZGQj4SOII2MjIuLioqJiIaFhISEhYeIioyOj5GSk5OTkpKSkZCQhI8Djo+QhZECkI+FjgKPkISRKZCPjo2MjIuLioiHhoaFhYeIiYqKioiHhIKBgICAgYKDhIWFhoaGhYOChIEMg4SFhYaGhoWDgoB+hX0FfHt6eXiEdwJ4eoR7JXp4d3Z2dnd4eXp7fHx7e3p6eXl4eHd2dHNycnN0dnp9gIKEhISJgxCCgH58enl4d3Z1dnZ3eXp6hnmFeh57fH19fn5+fXx8fX5/gH99e3l2c3Fwb25tbGtqaWmFahpp09HPzMrIxMG+vby8vsHFyczP02psbW9wcoR0QHNxcG5satLQ0NHUa2xucXN1dXNwbdbRzczKysrLzMrJysrKy83S125vcXJ0c3FvbtjV0dDPztDSaWpsbW5tbm4GW1tbXFxbhVwPXV1dW1qvqaOdm5qbnJ+ihaQcoqCdm5iVkY6NjY+QkpSXmpyeoKOmqVZXWVtdXoRfiV4RXV1cXF1dXl9hYmNjZWVmZmeEaAVnZmVkY4ViB2FgXlxbWlqEWYRYBVlaWltbhFwDXVxch1sGXFxdXVxchFs4WlpaWVhXVqqnpaWmqausrKuqqamop6iop6WjoZ+enZ2foaKio6RTVFVWV1dXVlZVVVVWVldYWVqGW4JahFsKXF1dXFtbWlhYV4VWFldYWVpaW1tbXFxdXl9gYmNkY2NkZGWEZgNlZGSFYxNkZGNiYmFgYF9fX2FiYmNjY2JihGEEYmNlZYdmI2dpamtsbGtramprbG1ub3Bxc3R1d3l7fH5/gYKCgH99e3l4hXcXeHh5enp6e3t8fX5/f39+fHt6eXh3dXSFcwxycnFwbmxqaGZkY2KFYRxiY2RnaWttcHN2eHl4eHd1c3FvbWtpaWlqa2xshW0Vbm9wcnV3eXp6eHZycG5sbGtramlphGgkZ2doaGlqamttb3Bxc3R1dXRzcnFvbm5tbW5vb3BwcXFyc3N1hnaEdxR4eXp7fH19fn5+fXx7e3p6ent7fIR9BXx7enp6i3kbent8fX18fHt5d3Z0c3NzdHR1dHNxb21raGZlhGQDZWdohWkKamtsbnFzdnh5e4d8OX1+f3+AgIB/fn58end0cnFxcXJyc3R1dXV0dHRzc3JycXFycnN1dnl7fX5+fn18e3p5eHd1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hIODhoKJgw2EhIaHiIqLjI2Ojo+PhpALkZGRkpKTlJSVlZWElguVlZSTkpCPjYyMi4aKDYuMjo+RkpOUlZWWlpaHlwmWlJKRj46Ni4uFihiLjI2Oj5CTlZeWlpWUk5GOioeFg4GAf36Ff4OAhX+IfgF/hYADgYGCiYOEgoWBiIIFgYGAgICGf4aABH9/fn6EfQh+f3+AgIGBgoSBEYCAf39+fn59fXx7enh4d3Z2hXUPdnd4eXt8fX5+f39/fn18hnsGfHx9fXx8hHsnfH19fn59fXx7enl4d3Z0cnBvbWvU0s/MysnIx8fHxsXEw8TExcbHhsg2x8fHxsbFxcTEw8LCwcDAv8DBwsTFxcTDwsLCw8XGyczP0dLR0dLT1NTT09PU1tdsbW9wcXJyhHGDcIZvgm6DWohZC1pbXF1eXl9gYWFihWGFYIRfB15eXVxbW1uGWohZCFhXV1ZVVFRUiVUaqqqrVVZWV1hZWltcXV5fYGFiYmNjY2RkZWaEZ4VoIGlpampra2tsbGxra2pqaWloaGhnZ2ZkZGJhYGBfXl5ehV0LXFxbW1taWllYWFiIVwNWV1eGVgZVVVVUVFSKVQFUhFUPVldYWFlaW1xdXl9gYWJjhmQSY2JiYWFgYF9eXl1cW1pZWVpZhFohW1tcXFtbWllaWllZWFhYWVlaWltcXV9gYWFiY2RlZWRkhGOIYgZjZGVlZmaEZwdmZWRjYmJhi2AOYWFiY2RmZ2lqbG1ubm+EcIZxBnJyc3N0dIR1C3RzcnBvbWxramhohmc/ZmZmZWRjYV9eXLa0s7OzsrO0tba3uLpdXV1cXFxbtbSysa+vrq+wsbO1tltcXFxdXl9hYmNlZmdoaWprbW1uhG+LcA1vb25ubW1tbGxsbWxshW2NbgRtbWxsh2sFbGxsbW2EbIRtDW5vcHJzdHR1dXZ2dXWFdIdzg3KGcYJwhW8Nbm5tbGxsa2pqaWloaIlng2iEaQVqamtrbIZtBmxramloaIRng2iEaQloaGdmZmVlZGSEY4RiCWNjZGVlZmZnZ4ZoAWeFaAdnZ2ZmZWVliGSHZQ5mZmdoaWprbG1ub3BwcIpxBXJycnNzhHSEdQd0dHNzcnFwhG8BboRvC3BxcnN0dXZ2d3d3h3YKdXV0c3Fvbm1saodpGGpra2xtb3BxcXFwcG9ta2lnZWRjY2JiYoZjAWSFY4diBmNjY2RkZIRlhGYBZ4hmg2WFZoZnhGaGZYdmD2VlZGRkY2NkZGRlZWVmZoRlg2SEYxdiYmFhYGBfXl5dXVxdXFxdXV5fYGBhYoRjCmJiYWFhYGFhYmKEY4ZiGGNjY2RjY2JiYWBgX15dXFpZWFesqqmnpoalAaSFowSkpaWmhaULpKSjoqKhoaGgn5+FniifoKGhoaCfn56foKGipKapqquqq6usrKyrqqqqq6xWV1hYWVlaWlpZhFoDWVpZhVrKf4N+/3//f6l/jX6Hf41+/3//f/9//3+Rf8h+ln8CAgQAGI6Pj5CRkZGSkpOTlJWVlpeXmJiZmZmamoSbkZwLnZ2dnp6fn6CgoaGEooWjhaSDpYikA6OjpIujgqKOo4Wig6GNoAahoaChoKGEoISfhJ6EnYqchJ0Gnp6en5+fjKAOn5+fnp2dnJybmpqZmZmGmIWZCZqbm5ucnZ2enoSfGaCgoKGhoaKioqOjpKSlpaamp6enqKioqamEqgWrq6ysrIWtCq6urq+wsLCxsbGEsoSxJrCwr66trayrqqqpqKempaSjoqGgn5+enZybmpmZmJeWlZWUk5OThZKHkYSSgpOFlIaVh5aElQqUlJOTk5KSkZGRhJCGj4iOgo2EjoWNDIyMi4uKiYmIiIiHh4eGGoeHiIiJiouMjY2Oj5CRkpOTlJWWlpeXmJiYhJkCmpmFmoSZhpqFm4ecg52Ino+fg6CJn4mgiJ+EnoadgpyInYmeAZ+GnpCdCZ6enp+foKChoYWihqOTpI2jAaSEo4WkBKWkpKSFpYamhaeGqIypCKioqKenp6amhaWGpIWlgqaEpwWoqKmpqY2qBampqaiohKeGpomljaQEpaWkpI+lA6SlpYakh6OLooShD6CgoJ+fnp6enZ2cnJubm5yahZmDmIqXg5iFmYWaiJuGnIedhJ6En4WgAaGHoDKfn5+enp2cnJubmpmZmJiXlpWVlJOTkpGRkI+Pjo2MjIuLioqJiYiIh4eGhoWFhYSEhIuDhoQEhYWGhoSHhIgLiYqKiouLi4yMjY0YdXV2dnZ3d3h4eHl5enp7e3x8fH19fX5+hH+SgAqBgYGCgoODg4SEhIWDhoeHAYiHh4eGAoWGiIWShIaDiYKIgwSEhIOEhYOEgoaBioCFgYWCioMNgoKBgYCAf35+fX18fIR7BXp6ent6hHsffHx8fX1+fn9/f4CAgIGBgYKCgoODhISFhYWGh4eIiISJCYqKiouLi4yMjIaNCY6Ojo+Pj5CQkIqRJ5CQj4+Ojo2MjIuLioqJiIeHhoWEg4KCgYB/fn59fHt7enl5eHd3d492BHd3eHiEeYZ6h3sJenp6eXl5eHh4hHeFdph1DXR0dHNzcnJxcXBwb2+HbhVvb29wcXFyc3N0dXZ3eHh5enp7fHyEfYR+hH+Nfod/AYCEf4eAhYGIgo6DjYKEgYeAhX+Jfol/h4ACf4CGfwh+f39+f35+foV/goCEgYKChIOGhJKFiISXg4iEhIWDhoWHhIgGiYiIiYiJhYgEh4eGhoSFi4SEhYOGhIeHiIWJC4qJiYmIiIeHhoaGhYUFhISEg4SLgwGCj4MBhIaDhIQDg4SEkIOHhIWDEIKCgoGBgYCAgH9+fn59fX2ZfIV7g3qFeYt4hHmGeoR7iHyEfYR+Bn9/f4CAgISBg4KJg4SCKIGBgYCAf35+fn18fHt7enp5eHh3d3Z2dXR0c3NycnFxcHBvb25ubW2EbIVrg2qHa4Rsgm2Fbg9vb29wcHBxcXFycnJzc3QRXl5fX2BgYGFhYWJiY2NkZGSEZYVmh2cGaGhnZ2doiGeDaIRphWqOa4ZqiGkEamppaYxqhmuIapFphmqGaYNohGeSZghnZ2doaGhnZ4doDGdnZmZmZWVkZGNjY4RihGGEYoRjBWRkZWVlhmaEZ4RoC2lpaWpqa2trbGxshW2DbohvhnCFcQJycYRyBHFycXGEcB9vb25ubW1sbGxra2pqaWhoZ2dmZmVlZGRjYmJiYWBghF+OXoRfg2CGYYhihWGDYIZfh16NXYhehl0KXFxcW1tbWlpaWYVaFVtbW1xcXV5eX19gYGFhYmJjY2NkZIRlimaFZZNmimeZaItnhGaFZYpkgmOKZI1lAmRljWSGZYRmiWeLaARnZ2hoiGeLZpVlA2ZlZYdmiWeHaIZnkmaEZ4Zoh2kNamppaWpqamlpaWhoaIRnmGYIZ2dnZmZnZ2aFZ4hmBWdnZ2ZnhmYFZWZmZmWPZoVlhGSDY4RihWGEYJdhiGCGX4pgh2GGYohjhGSFZYVmj2eEZoRlFWRkZGNjYmJhYWFgYGBfXl5dXV1cXIRbBFpaWVmEWINXh1YBVYlWhVeFWAZZWVlaWlqEWwVcXFxdXf9//3//f/9//3//f/9//3+Ifw==");

/***/ }),

/***/ "./src/assets/images/backgrounds/About.svg":
/*!*************************************************!*\
  !*** ./src/assets/images/backgrounds/About.svg ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "About.svg";

/***/ }),

/***/ "./src/assets/images/backgrounds/Lab.svg":
/*!***********************************************!*\
  !*** ./src/assets/images/backgrounds/Lab.svg ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "Lab.svg";

/***/ }),

/***/ "./src/assets/images/backgrounds/PiotrBania.svg":
/*!******************************************************!*\
  !*** ./src/assets/images/backgrounds/PiotrBania.svg ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "PiotrBania.svg";

/***/ }),

/***/ "./src/assets/images/backgrounds/Portfolio.svg":
/*!*****************************************************!*\
  !*** ./src/assets/images/backgrounds/Portfolio.svg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "Portfolio.svg";

/***/ }),

/***/ "./src/assets/images/backgrounds/Skills.svg":
/*!**************************************************!*\
  !*** ./src/assets/images/backgrounds/Skills.svg ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "Skills.svg";

/***/ }),

/***/ "./src/assets/images/backgrounds/contact.svg":
/*!***************************************************!*\
  !*** ./src/assets/images/backgrounds/contact.svg ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "contact.svg";

/***/ }),

/***/ "./src/assets/fonts/Arkitech/Arkitech-Light.ttf":
/*!******************************************************!*\
  !*** ./src/assets/fonts/Arkitech/Arkitech-Light.ttf ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "Arkitech-Light.ttf";

/***/ }),

/***/ "./src/assets/fonts/Arkitech/Arkitech-Medium.ttf":
/*!*******************************************************!*\
  !*** ./src/assets/fonts/Arkitech/Arkitech-Medium.ttf ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "Arkitech-Medium.ttf";

/***/ }),

/***/ "./src/assets/fonts/Expansiva/Expansiva.otf":
/*!**************************************************!*\
  !*** ./src/assets/fonts/Expansiva/Expansiva.otf ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "Expansiva.otf";

/***/ }),

/***/ "./src/assets/fonts/expansiva/Expansiva-bold.otf":
/*!*******************************************************!*\
  !*** ./src/assets/fonts/expansiva/Expansiva-bold.otf ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "Expansiva-bold.otf";

/***/ }),

/***/ "./node_modules/three/build/three.module.js":
/*!**************************************************!*\
  !*** ./node_modules/three/build/three.module.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ACESFilmicToneMapping": () => (/* binding */ ACESFilmicToneMapping),
/* harmony export */   "AddEquation": () => (/* binding */ AddEquation),
/* harmony export */   "AddOperation": () => (/* binding */ AddOperation),
/* harmony export */   "AdditiveAnimationBlendMode": () => (/* binding */ AdditiveAnimationBlendMode),
/* harmony export */   "AdditiveBlending": () => (/* binding */ AdditiveBlending),
/* harmony export */   "AlphaFormat": () => (/* binding */ AlphaFormat),
/* harmony export */   "AlwaysDepth": () => (/* binding */ AlwaysDepth),
/* harmony export */   "AlwaysStencilFunc": () => (/* binding */ AlwaysStencilFunc),
/* harmony export */   "AmbientLight": () => (/* binding */ AmbientLight),
/* harmony export */   "AmbientLightProbe": () => (/* binding */ AmbientLightProbe),
/* harmony export */   "AnimationClip": () => (/* binding */ AnimationClip),
/* harmony export */   "AnimationLoader": () => (/* binding */ AnimationLoader),
/* harmony export */   "AnimationMixer": () => (/* binding */ AnimationMixer),
/* harmony export */   "AnimationObjectGroup": () => (/* binding */ AnimationObjectGroup),
/* harmony export */   "AnimationUtils": () => (/* binding */ AnimationUtils),
/* harmony export */   "ArcCurve": () => (/* binding */ ArcCurve),
/* harmony export */   "ArrayCamera": () => (/* binding */ ArrayCamera),
/* harmony export */   "ArrowHelper": () => (/* binding */ ArrowHelper),
/* harmony export */   "Audio": () => (/* binding */ Audio),
/* harmony export */   "AudioAnalyser": () => (/* binding */ AudioAnalyser),
/* harmony export */   "AudioContext": () => (/* binding */ AudioContext),
/* harmony export */   "AudioListener": () => (/* binding */ AudioListener),
/* harmony export */   "AudioLoader": () => (/* binding */ AudioLoader),
/* harmony export */   "AxesHelper": () => (/* binding */ AxesHelper),
/* harmony export */   "AxisHelper": () => (/* binding */ AxisHelper),
/* harmony export */   "BackSide": () => (/* binding */ BackSide),
/* harmony export */   "BasicDepthPacking": () => (/* binding */ BasicDepthPacking),
/* harmony export */   "BasicShadowMap": () => (/* binding */ BasicShadowMap),
/* harmony export */   "BinaryTextureLoader": () => (/* binding */ BinaryTextureLoader),
/* harmony export */   "Bone": () => (/* binding */ Bone),
/* harmony export */   "BooleanKeyframeTrack": () => (/* binding */ BooleanKeyframeTrack),
/* harmony export */   "BoundingBoxHelper": () => (/* binding */ BoundingBoxHelper),
/* harmony export */   "Box2": () => (/* binding */ Box2),
/* harmony export */   "Box3": () => (/* binding */ Box3),
/* harmony export */   "Box3Helper": () => (/* binding */ Box3Helper),
/* harmony export */   "BoxBufferGeometry": () => (/* binding */ BoxGeometry),
/* harmony export */   "BoxGeometry": () => (/* binding */ BoxGeometry),
/* harmony export */   "BoxHelper": () => (/* binding */ BoxHelper),
/* harmony export */   "BufferAttribute": () => (/* binding */ BufferAttribute),
/* harmony export */   "BufferGeometry": () => (/* binding */ BufferGeometry),
/* harmony export */   "BufferGeometryLoader": () => (/* binding */ BufferGeometryLoader),
/* harmony export */   "ByteType": () => (/* binding */ ByteType),
/* harmony export */   "Cache": () => (/* binding */ Cache),
/* harmony export */   "Camera": () => (/* binding */ Camera),
/* harmony export */   "CameraHelper": () => (/* binding */ CameraHelper),
/* harmony export */   "CanvasRenderer": () => (/* binding */ CanvasRenderer),
/* harmony export */   "CanvasTexture": () => (/* binding */ CanvasTexture),
/* harmony export */   "CapsuleBufferGeometry": () => (/* binding */ CapsuleGeometry),
/* harmony export */   "CapsuleGeometry": () => (/* binding */ CapsuleGeometry),
/* harmony export */   "CatmullRomCurve3": () => (/* binding */ CatmullRomCurve3),
/* harmony export */   "CineonToneMapping": () => (/* binding */ CineonToneMapping),
/* harmony export */   "CircleBufferGeometry": () => (/* binding */ CircleGeometry),
/* harmony export */   "CircleGeometry": () => (/* binding */ CircleGeometry),
/* harmony export */   "ClampToEdgeWrapping": () => (/* binding */ ClampToEdgeWrapping),
/* harmony export */   "Clock": () => (/* binding */ Clock),
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "ColorKeyframeTrack": () => (/* binding */ ColorKeyframeTrack),
/* harmony export */   "ColorManagement": () => (/* binding */ ColorManagement),
/* harmony export */   "CompressedTexture": () => (/* binding */ CompressedTexture),
/* harmony export */   "CompressedTextureLoader": () => (/* binding */ CompressedTextureLoader),
/* harmony export */   "ConeBufferGeometry": () => (/* binding */ ConeGeometry),
/* harmony export */   "ConeGeometry": () => (/* binding */ ConeGeometry),
/* harmony export */   "CubeCamera": () => (/* binding */ CubeCamera),
/* harmony export */   "CubeReflectionMapping": () => (/* binding */ CubeReflectionMapping),
/* harmony export */   "CubeRefractionMapping": () => (/* binding */ CubeRefractionMapping),
/* harmony export */   "CubeTexture": () => (/* binding */ CubeTexture),
/* harmony export */   "CubeTextureLoader": () => (/* binding */ CubeTextureLoader),
/* harmony export */   "CubeUVReflectionMapping": () => (/* binding */ CubeUVReflectionMapping),
/* harmony export */   "CubicBezierCurve": () => (/* binding */ CubicBezierCurve),
/* harmony export */   "CubicBezierCurve3": () => (/* binding */ CubicBezierCurve3),
/* harmony export */   "CubicInterpolant": () => (/* binding */ CubicInterpolant),
/* harmony export */   "CullFaceBack": () => (/* binding */ CullFaceBack),
/* harmony export */   "CullFaceFront": () => (/* binding */ CullFaceFront),
/* harmony export */   "CullFaceFrontBack": () => (/* binding */ CullFaceFrontBack),
/* harmony export */   "CullFaceNone": () => (/* binding */ CullFaceNone),
/* harmony export */   "Curve": () => (/* binding */ Curve),
/* harmony export */   "CurvePath": () => (/* binding */ CurvePath),
/* harmony export */   "CustomBlending": () => (/* binding */ CustomBlending),
/* harmony export */   "CustomToneMapping": () => (/* binding */ CustomToneMapping),
/* harmony export */   "CylinderBufferGeometry": () => (/* binding */ CylinderGeometry),
/* harmony export */   "CylinderGeometry": () => (/* binding */ CylinderGeometry),
/* harmony export */   "Cylindrical": () => (/* binding */ Cylindrical),
/* harmony export */   "Data3DTexture": () => (/* binding */ Data3DTexture),
/* harmony export */   "DataArrayTexture": () => (/* binding */ DataArrayTexture),
/* harmony export */   "DataTexture": () => (/* binding */ DataTexture),
/* harmony export */   "DataTexture2DArray": () => (/* binding */ DataTexture2DArray),
/* harmony export */   "DataTexture3D": () => (/* binding */ DataTexture3D),
/* harmony export */   "DataTextureLoader": () => (/* binding */ DataTextureLoader),
/* harmony export */   "DataUtils": () => (/* binding */ DataUtils),
/* harmony export */   "DecrementStencilOp": () => (/* binding */ DecrementStencilOp),
/* harmony export */   "DecrementWrapStencilOp": () => (/* binding */ DecrementWrapStencilOp),
/* harmony export */   "DefaultLoadingManager": () => (/* binding */ DefaultLoadingManager),
/* harmony export */   "DepthFormat": () => (/* binding */ DepthFormat),
/* harmony export */   "DepthStencilFormat": () => (/* binding */ DepthStencilFormat),
/* harmony export */   "DepthTexture": () => (/* binding */ DepthTexture),
/* harmony export */   "DirectionalLight": () => (/* binding */ DirectionalLight),
/* harmony export */   "DirectionalLightHelper": () => (/* binding */ DirectionalLightHelper),
/* harmony export */   "DiscreteInterpolant": () => (/* binding */ DiscreteInterpolant),
/* harmony export */   "DodecahedronBufferGeometry": () => (/* binding */ DodecahedronGeometry),
/* harmony export */   "DodecahedronGeometry": () => (/* binding */ DodecahedronGeometry),
/* harmony export */   "DoubleSide": () => (/* binding */ DoubleSide),
/* harmony export */   "DstAlphaFactor": () => (/* binding */ DstAlphaFactor),
/* harmony export */   "DstColorFactor": () => (/* binding */ DstColorFactor),
/* harmony export */   "DynamicBufferAttribute": () => (/* binding */ DynamicBufferAttribute),
/* harmony export */   "DynamicCopyUsage": () => (/* binding */ DynamicCopyUsage),
/* harmony export */   "DynamicDrawUsage": () => (/* binding */ DynamicDrawUsage),
/* harmony export */   "DynamicReadUsage": () => (/* binding */ DynamicReadUsage),
/* harmony export */   "EdgesGeometry": () => (/* binding */ EdgesGeometry),
/* harmony export */   "EdgesHelper": () => (/* binding */ EdgesHelper),
/* harmony export */   "EllipseCurve": () => (/* binding */ EllipseCurve),
/* harmony export */   "EqualDepth": () => (/* binding */ EqualDepth),
/* harmony export */   "EqualStencilFunc": () => (/* binding */ EqualStencilFunc),
/* harmony export */   "EquirectangularReflectionMapping": () => (/* binding */ EquirectangularReflectionMapping),
/* harmony export */   "EquirectangularRefractionMapping": () => (/* binding */ EquirectangularRefractionMapping),
/* harmony export */   "Euler": () => (/* binding */ Euler),
/* harmony export */   "EventDispatcher": () => (/* binding */ EventDispatcher),
/* harmony export */   "ExtrudeBufferGeometry": () => (/* binding */ ExtrudeGeometry),
/* harmony export */   "ExtrudeGeometry": () => (/* binding */ ExtrudeGeometry),
/* harmony export */   "FaceColors": () => (/* binding */ FaceColors),
/* harmony export */   "FileLoader": () => (/* binding */ FileLoader),
/* harmony export */   "FlatShading": () => (/* binding */ FlatShading),
/* harmony export */   "Float16BufferAttribute": () => (/* binding */ Float16BufferAttribute),
/* harmony export */   "Float32Attribute": () => (/* binding */ Float32Attribute),
/* harmony export */   "Float32BufferAttribute": () => (/* binding */ Float32BufferAttribute),
/* harmony export */   "Float64Attribute": () => (/* binding */ Float64Attribute),
/* harmony export */   "Float64BufferAttribute": () => (/* binding */ Float64BufferAttribute),
/* harmony export */   "FloatType": () => (/* binding */ FloatType),
/* harmony export */   "Fog": () => (/* binding */ Fog),
/* harmony export */   "FogExp2": () => (/* binding */ FogExp2),
/* harmony export */   "Font": () => (/* binding */ Font),
/* harmony export */   "FontLoader": () => (/* binding */ FontLoader),
/* harmony export */   "FramebufferTexture": () => (/* binding */ FramebufferTexture),
/* harmony export */   "FrontSide": () => (/* binding */ FrontSide),
/* harmony export */   "Frustum": () => (/* binding */ Frustum),
/* harmony export */   "GLBufferAttribute": () => (/* binding */ GLBufferAttribute),
/* harmony export */   "GLSL1": () => (/* binding */ GLSL1),
/* harmony export */   "GLSL3": () => (/* binding */ GLSL3),
/* harmony export */   "GreaterDepth": () => (/* binding */ GreaterDepth),
/* harmony export */   "GreaterEqualDepth": () => (/* binding */ GreaterEqualDepth),
/* harmony export */   "GreaterEqualStencilFunc": () => (/* binding */ GreaterEqualStencilFunc),
/* harmony export */   "GreaterStencilFunc": () => (/* binding */ GreaterStencilFunc),
/* harmony export */   "GridHelper": () => (/* binding */ GridHelper),
/* harmony export */   "Group": () => (/* binding */ Group),
/* harmony export */   "HalfFloatType": () => (/* binding */ HalfFloatType),
/* harmony export */   "HemisphereLight": () => (/* binding */ HemisphereLight),
/* harmony export */   "HemisphereLightHelper": () => (/* binding */ HemisphereLightHelper),
/* harmony export */   "HemisphereLightProbe": () => (/* binding */ HemisphereLightProbe),
/* harmony export */   "IcosahedronBufferGeometry": () => (/* binding */ IcosahedronGeometry),
/* harmony export */   "IcosahedronGeometry": () => (/* binding */ IcosahedronGeometry),
/* harmony export */   "ImageBitmapLoader": () => (/* binding */ ImageBitmapLoader),
/* harmony export */   "ImageLoader": () => (/* binding */ ImageLoader),
/* harmony export */   "ImageUtils": () => (/* binding */ ImageUtils),
/* harmony export */   "ImmediateRenderObject": () => (/* binding */ ImmediateRenderObject),
/* harmony export */   "IncrementStencilOp": () => (/* binding */ IncrementStencilOp),
/* harmony export */   "IncrementWrapStencilOp": () => (/* binding */ IncrementWrapStencilOp),
/* harmony export */   "InstancedBufferAttribute": () => (/* binding */ InstancedBufferAttribute),
/* harmony export */   "InstancedBufferGeometry": () => (/* binding */ InstancedBufferGeometry),
/* harmony export */   "InstancedInterleavedBuffer": () => (/* binding */ InstancedInterleavedBuffer),
/* harmony export */   "InstancedMesh": () => (/* binding */ InstancedMesh),
/* harmony export */   "Int16Attribute": () => (/* binding */ Int16Attribute),
/* harmony export */   "Int16BufferAttribute": () => (/* binding */ Int16BufferAttribute),
/* harmony export */   "Int32Attribute": () => (/* binding */ Int32Attribute),
/* harmony export */   "Int32BufferAttribute": () => (/* binding */ Int32BufferAttribute),
/* harmony export */   "Int8Attribute": () => (/* binding */ Int8Attribute),
/* harmony export */   "Int8BufferAttribute": () => (/* binding */ Int8BufferAttribute),
/* harmony export */   "IntType": () => (/* binding */ IntType),
/* harmony export */   "InterleavedBuffer": () => (/* binding */ InterleavedBuffer),
/* harmony export */   "InterleavedBufferAttribute": () => (/* binding */ InterleavedBufferAttribute),
/* harmony export */   "Interpolant": () => (/* binding */ Interpolant),
/* harmony export */   "InterpolateDiscrete": () => (/* binding */ InterpolateDiscrete),
/* harmony export */   "InterpolateLinear": () => (/* binding */ InterpolateLinear),
/* harmony export */   "InterpolateSmooth": () => (/* binding */ InterpolateSmooth),
/* harmony export */   "InvertStencilOp": () => (/* binding */ InvertStencilOp),
/* harmony export */   "JSONLoader": () => (/* binding */ JSONLoader),
/* harmony export */   "KeepStencilOp": () => (/* binding */ KeepStencilOp),
/* harmony export */   "KeyframeTrack": () => (/* binding */ KeyframeTrack),
/* harmony export */   "LOD": () => (/* binding */ LOD),
/* harmony export */   "LatheBufferGeometry": () => (/* binding */ LatheGeometry),
/* harmony export */   "LatheGeometry": () => (/* binding */ LatheGeometry),
/* harmony export */   "Layers": () => (/* binding */ Layers),
/* harmony export */   "LensFlare": () => (/* binding */ LensFlare),
/* harmony export */   "LessDepth": () => (/* binding */ LessDepth),
/* harmony export */   "LessEqualDepth": () => (/* binding */ LessEqualDepth),
/* harmony export */   "LessEqualStencilFunc": () => (/* binding */ LessEqualStencilFunc),
/* harmony export */   "LessStencilFunc": () => (/* binding */ LessStencilFunc),
/* harmony export */   "Light": () => (/* binding */ Light),
/* harmony export */   "LightProbe": () => (/* binding */ LightProbe),
/* harmony export */   "Line": () => (/* binding */ Line),
/* harmony export */   "Line3": () => (/* binding */ Line3),
/* harmony export */   "LineBasicMaterial": () => (/* binding */ LineBasicMaterial),
/* harmony export */   "LineCurve": () => (/* binding */ LineCurve),
/* harmony export */   "LineCurve3": () => (/* binding */ LineCurve3),
/* harmony export */   "LineDashedMaterial": () => (/* binding */ LineDashedMaterial),
/* harmony export */   "LineLoop": () => (/* binding */ LineLoop),
/* harmony export */   "LinePieces": () => (/* binding */ LinePieces),
/* harmony export */   "LineSegments": () => (/* binding */ LineSegments),
/* harmony export */   "LineStrip": () => (/* binding */ LineStrip),
/* harmony export */   "LinearEncoding": () => (/* binding */ LinearEncoding),
/* harmony export */   "LinearFilter": () => (/* binding */ LinearFilter),
/* harmony export */   "LinearInterpolant": () => (/* binding */ LinearInterpolant),
/* harmony export */   "LinearMipMapLinearFilter": () => (/* binding */ LinearMipMapLinearFilter),
/* harmony export */   "LinearMipMapNearestFilter": () => (/* binding */ LinearMipMapNearestFilter),
/* harmony export */   "LinearMipmapLinearFilter": () => (/* binding */ LinearMipmapLinearFilter),
/* harmony export */   "LinearMipmapNearestFilter": () => (/* binding */ LinearMipmapNearestFilter),
/* harmony export */   "LinearSRGBColorSpace": () => (/* binding */ LinearSRGBColorSpace),
/* harmony export */   "LinearToneMapping": () => (/* binding */ LinearToneMapping),
/* harmony export */   "Loader": () => (/* binding */ Loader),
/* harmony export */   "LoaderUtils": () => (/* binding */ LoaderUtils),
/* harmony export */   "LoadingManager": () => (/* binding */ LoadingManager),
/* harmony export */   "LoopOnce": () => (/* binding */ LoopOnce),
/* harmony export */   "LoopPingPong": () => (/* binding */ LoopPingPong),
/* harmony export */   "LoopRepeat": () => (/* binding */ LoopRepeat),
/* harmony export */   "LuminanceAlphaFormat": () => (/* binding */ LuminanceAlphaFormat),
/* harmony export */   "LuminanceFormat": () => (/* binding */ LuminanceFormat),
/* harmony export */   "MOUSE": () => (/* binding */ MOUSE),
/* harmony export */   "Material": () => (/* binding */ Material),
/* harmony export */   "MaterialLoader": () => (/* binding */ MaterialLoader),
/* harmony export */   "Math": () => (/* binding */ MathUtils),
/* harmony export */   "MathUtils": () => (/* binding */ MathUtils),
/* harmony export */   "Matrix3": () => (/* binding */ Matrix3),
/* harmony export */   "Matrix4": () => (/* binding */ Matrix4),
/* harmony export */   "MaxEquation": () => (/* binding */ MaxEquation),
/* harmony export */   "Mesh": () => (/* binding */ Mesh),
/* harmony export */   "MeshBasicMaterial": () => (/* binding */ MeshBasicMaterial),
/* harmony export */   "MeshDepthMaterial": () => (/* binding */ MeshDepthMaterial),
/* harmony export */   "MeshDistanceMaterial": () => (/* binding */ MeshDistanceMaterial),
/* harmony export */   "MeshFaceMaterial": () => (/* binding */ MeshFaceMaterial),
/* harmony export */   "MeshLambertMaterial": () => (/* binding */ MeshLambertMaterial),
/* harmony export */   "MeshMatcapMaterial": () => (/* binding */ MeshMatcapMaterial),
/* harmony export */   "MeshNormalMaterial": () => (/* binding */ MeshNormalMaterial),
/* harmony export */   "MeshPhongMaterial": () => (/* binding */ MeshPhongMaterial),
/* harmony export */   "MeshPhysicalMaterial": () => (/* binding */ MeshPhysicalMaterial),
/* harmony export */   "MeshStandardMaterial": () => (/* binding */ MeshStandardMaterial),
/* harmony export */   "MeshToonMaterial": () => (/* binding */ MeshToonMaterial),
/* harmony export */   "MinEquation": () => (/* binding */ MinEquation),
/* harmony export */   "MirroredRepeatWrapping": () => (/* binding */ MirroredRepeatWrapping),
/* harmony export */   "MixOperation": () => (/* binding */ MixOperation),
/* harmony export */   "MultiMaterial": () => (/* binding */ MultiMaterial),
/* harmony export */   "MultiplyBlending": () => (/* binding */ MultiplyBlending),
/* harmony export */   "MultiplyOperation": () => (/* binding */ MultiplyOperation),
/* harmony export */   "NearestFilter": () => (/* binding */ NearestFilter),
/* harmony export */   "NearestMipMapLinearFilter": () => (/* binding */ NearestMipMapLinearFilter),
/* harmony export */   "NearestMipMapNearestFilter": () => (/* binding */ NearestMipMapNearestFilter),
/* harmony export */   "NearestMipmapLinearFilter": () => (/* binding */ NearestMipmapLinearFilter),
/* harmony export */   "NearestMipmapNearestFilter": () => (/* binding */ NearestMipmapNearestFilter),
/* harmony export */   "NeverDepth": () => (/* binding */ NeverDepth),
/* harmony export */   "NeverStencilFunc": () => (/* binding */ NeverStencilFunc),
/* harmony export */   "NoBlending": () => (/* binding */ NoBlending),
/* harmony export */   "NoColorSpace": () => (/* binding */ NoColorSpace),
/* harmony export */   "NoColors": () => (/* binding */ NoColors),
/* harmony export */   "NoToneMapping": () => (/* binding */ NoToneMapping),
/* harmony export */   "NormalAnimationBlendMode": () => (/* binding */ NormalAnimationBlendMode),
/* harmony export */   "NormalBlending": () => (/* binding */ NormalBlending),
/* harmony export */   "NotEqualDepth": () => (/* binding */ NotEqualDepth),
/* harmony export */   "NotEqualStencilFunc": () => (/* binding */ NotEqualStencilFunc),
/* harmony export */   "NumberKeyframeTrack": () => (/* binding */ NumberKeyframeTrack),
/* harmony export */   "Object3D": () => (/* binding */ Object3D),
/* harmony export */   "ObjectLoader": () => (/* binding */ ObjectLoader),
/* harmony export */   "ObjectSpaceNormalMap": () => (/* binding */ ObjectSpaceNormalMap),
/* harmony export */   "OctahedronBufferGeometry": () => (/* binding */ OctahedronGeometry),
/* harmony export */   "OctahedronGeometry": () => (/* binding */ OctahedronGeometry),
/* harmony export */   "OneFactor": () => (/* binding */ OneFactor),
/* harmony export */   "OneMinusDstAlphaFactor": () => (/* binding */ OneMinusDstAlphaFactor),
/* harmony export */   "OneMinusDstColorFactor": () => (/* binding */ OneMinusDstColorFactor),
/* harmony export */   "OneMinusSrcAlphaFactor": () => (/* binding */ OneMinusSrcAlphaFactor),
/* harmony export */   "OneMinusSrcColorFactor": () => (/* binding */ OneMinusSrcColorFactor),
/* harmony export */   "OrthographicCamera": () => (/* binding */ OrthographicCamera),
/* harmony export */   "PCFShadowMap": () => (/* binding */ PCFShadowMap),
/* harmony export */   "PCFSoftShadowMap": () => (/* binding */ PCFSoftShadowMap),
/* harmony export */   "PMREMGenerator": () => (/* binding */ PMREMGenerator),
/* harmony export */   "ParametricGeometry": () => (/* binding */ ParametricGeometry),
/* harmony export */   "Particle": () => (/* binding */ Particle),
/* harmony export */   "ParticleBasicMaterial": () => (/* binding */ ParticleBasicMaterial),
/* harmony export */   "ParticleSystem": () => (/* binding */ ParticleSystem),
/* harmony export */   "ParticleSystemMaterial": () => (/* binding */ ParticleSystemMaterial),
/* harmony export */   "Path": () => (/* binding */ Path),
/* harmony export */   "PerspectiveCamera": () => (/* binding */ PerspectiveCamera),
/* harmony export */   "Plane": () => (/* binding */ Plane),
/* harmony export */   "PlaneBufferGeometry": () => (/* binding */ PlaneGeometry),
/* harmony export */   "PlaneGeometry": () => (/* binding */ PlaneGeometry),
/* harmony export */   "PlaneHelper": () => (/* binding */ PlaneHelper),
/* harmony export */   "PointCloud": () => (/* binding */ PointCloud),
/* harmony export */   "PointCloudMaterial": () => (/* binding */ PointCloudMaterial),
/* harmony export */   "PointLight": () => (/* binding */ PointLight),
/* harmony export */   "PointLightHelper": () => (/* binding */ PointLightHelper),
/* harmony export */   "Points": () => (/* binding */ Points),
/* harmony export */   "PointsMaterial": () => (/* binding */ PointsMaterial),
/* harmony export */   "PolarGridHelper": () => (/* binding */ PolarGridHelper),
/* harmony export */   "PolyhedronBufferGeometry": () => (/* binding */ PolyhedronGeometry),
/* harmony export */   "PolyhedronGeometry": () => (/* binding */ PolyhedronGeometry),
/* harmony export */   "PositionalAudio": () => (/* binding */ PositionalAudio),
/* harmony export */   "PropertyBinding": () => (/* binding */ PropertyBinding),
/* harmony export */   "PropertyMixer": () => (/* binding */ PropertyMixer),
/* harmony export */   "QuadraticBezierCurve": () => (/* binding */ QuadraticBezierCurve),
/* harmony export */   "QuadraticBezierCurve3": () => (/* binding */ QuadraticBezierCurve3),
/* harmony export */   "Quaternion": () => (/* binding */ Quaternion),
/* harmony export */   "QuaternionKeyframeTrack": () => (/* binding */ QuaternionKeyframeTrack),
/* harmony export */   "QuaternionLinearInterpolant": () => (/* binding */ QuaternionLinearInterpolant),
/* harmony export */   "REVISION": () => (/* binding */ REVISION),
/* harmony export */   "RGBADepthPacking": () => (/* binding */ RGBADepthPacking),
/* harmony export */   "RGBAFormat": () => (/* binding */ RGBAFormat),
/* harmony export */   "RGBAIntegerFormat": () => (/* binding */ RGBAIntegerFormat),
/* harmony export */   "RGBA_ASTC_10x10_Format": () => (/* binding */ RGBA_ASTC_10x10_Format),
/* harmony export */   "RGBA_ASTC_10x5_Format": () => (/* binding */ RGBA_ASTC_10x5_Format),
/* harmony export */   "RGBA_ASTC_10x6_Format": () => (/* binding */ RGBA_ASTC_10x6_Format),
/* harmony export */   "RGBA_ASTC_10x8_Format": () => (/* binding */ RGBA_ASTC_10x8_Format),
/* harmony export */   "RGBA_ASTC_12x10_Format": () => (/* binding */ RGBA_ASTC_12x10_Format),
/* harmony export */   "RGBA_ASTC_12x12_Format": () => (/* binding */ RGBA_ASTC_12x12_Format),
/* harmony export */   "RGBA_ASTC_4x4_Format": () => (/* binding */ RGBA_ASTC_4x4_Format),
/* harmony export */   "RGBA_ASTC_5x4_Format": () => (/* binding */ RGBA_ASTC_5x4_Format),
/* harmony export */   "RGBA_ASTC_5x5_Format": () => (/* binding */ RGBA_ASTC_5x5_Format),
/* harmony export */   "RGBA_ASTC_6x5_Format": () => (/* binding */ RGBA_ASTC_6x5_Format),
/* harmony export */   "RGBA_ASTC_6x6_Format": () => (/* binding */ RGBA_ASTC_6x6_Format),
/* harmony export */   "RGBA_ASTC_8x5_Format": () => (/* binding */ RGBA_ASTC_8x5_Format),
/* harmony export */   "RGBA_ASTC_8x6_Format": () => (/* binding */ RGBA_ASTC_8x6_Format),
/* harmony export */   "RGBA_ASTC_8x8_Format": () => (/* binding */ RGBA_ASTC_8x8_Format),
/* harmony export */   "RGBA_BPTC_Format": () => (/* binding */ RGBA_BPTC_Format),
/* harmony export */   "RGBA_ETC2_EAC_Format": () => (/* binding */ RGBA_ETC2_EAC_Format),
/* harmony export */   "RGBA_PVRTC_2BPPV1_Format": () => (/* binding */ RGBA_PVRTC_2BPPV1_Format),
/* harmony export */   "RGBA_PVRTC_4BPPV1_Format": () => (/* binding */ RGBA_PVRTC_4BPPV1_Format),
/* harmony export */   "RGBA_S3TC_DXT1_Format": () => (/* binding */ RGBA_S3TC_DXT1_Format),
/* harmony export */   "RGBA_S3TC_DXT3_Format": () => (/* binding */ RGBA_S3TC_DXT3_Format),
/* harmony export */   "RGBA_S3TC_DXT5_Format": () => (/* binding */ RGBA_S3TC_DXT5_Format),
/* harmony export */   "RGBFormat": () => (/* binding */ RGBFormat),
/* harmony export */   "RGB_ETC1_Format": () => (/* binding */ RGB_ETC1_Format),
/* harmony export */   "RGB_ETC2_Format": () => (/* binding */ RGB_ETC2_Format),
/* harmony export */   "RGB_PVRTC_2BPPV1_Format": () => (/* binding */ RGB_PVRTC_2BPPV1_Format),
/* harmony export */   "RGB_PVRTC_4BPPV1_Format": () => (/* binding */ RGB_PVRTC_4BPPV1_Format),
/* harmony export */   "RGB_S3TC_DXT1_Format": () => (/* binding */ RGB_S3TC_DXT1_Format),
/* harmony export */   "RGFormat": () => (/* binding */ RGFormat),
/* harmony export */   "RGIntegerFormat": () => (/* binding */ RGIntegerFormat),
/* harmony export */   "RawShaderMaterial": () => (/* binding */ RawShaderMaterial),
/* harmony export */   "Ray": () => (/* binding */ Ray),
/* harmony export */   "Raycaster": () => (/* binding */ Raycaster),
/* harmony export */   "RectAreaLight": () => (/* binding */ RectAreaLight),
/* harmony export */   "RedFormat": () => (/* binding */ RedFormat),
/* harmony export */   "RedIntegerFormat": () => (/* binding */ RedIntegerFormat),
/* harmony export */   "ReinhardToneMapping": () => (/* binding */ ReinhardToneMapping),
/* harmony export */   "RepeatWrapping": () => (/* binding */ RepeatWrapping),
/* harmony export */   "ReplaceStencilOp": () => (/* binding */ ReplaceStencilOp),
/* harmony export */   "ReverseSubtractEquation": () => (/* binding */ ReverseSubtractEquation),
/* harmony export */   "RingBufferGeometry": () => (/* binding */ RingGeometry),
/* harmony export */   "RingGeometry": () => (/* binding */ RingGeometry),
/* harmony export */   "SRGBColorSpace": () => (/* binding */ SRGBColorSpace),
/* harmony export */   "Scene": () => (/* binding */ Scene),
/* harmony export */   "SceneUtils": () => (/* binding */ SceneUtils),
/* harmony export */   "ShaderChunk": () => (/* binding */ ShaderChunk),
/* harmony export */   "ShaderLib": () => (/* binding */ ShaderLib),
/* harmony export */   "ShaderMaterial": () => (/* binding */ ShaderMaterial),
/* harmony export */   "ShadowMaterial": () => (/* binding */ ShadowMaterial),
/* harmony export */   "Shape": () => (/* binding */ Shape),
/* harmony export */   "ShapeBufferGeometry": () => (/* binding */ ShapeGeometry),
/* harmony export */   "ShapeGeometry": () => (/* binding */ ShapeGeometry),
/* harmony export */   "ShapePath": () => (/* binding */ ShapePath),
/* harmony export */   "ShapeUtils": () => (/* binding */ ShapeUtils),
/* harmony export */   "ShortType": () => (/* binding */ ShortType),
/* harmony export */   "Skeleton": () => (/* binding */ Skeleton),
/* harmony export */   "SkeletonHelper": () => (/* binding */ SkeletonHelper),
/* harmony export */   "SkinnedMesh": () => (/* binding */ SkinnedMesh),
/* harmony export */   "SmoothShading": () => (/* binding */ SmoothShading),
/* harmony export */   "Source": () => (/* binding */ Source),
/* harmony export */   "Sphere": () => (/* binding */ Sphere),
/* harmony export */   "SphereBufferGeometry": () => (/* binding */ SphereGeometry),
/* harmony export */   "SphereGeometry": () => (/* binding */ SphereGeometry),
/* harmony export */   "Spherical": () => (/* binding */ Spherical),
/* harmony export */   "SphericalHarmonics3": () => (/* binding */ SphericalHarmonics3),
/* harmony export */   "SplineCurve": () => (/* binding */ SplineCurve),
/* harmony export */   "SpotLight": () => (/* binding */ SpotLight),
/* harmony export */   "SpotLightHelper": () => (/* binding */ SpotLightHelper),
/* harmony export */   "Sprite": () => (/* binding */ Sprite),
/* harmony export */   "SpriteMaterial": () => (/* binding */ SpriteMaterial),
/* harmony export */   "SrcAlphaFactor": () => (/* binding */ SrcAlphaFactor),
/* harmony export */   "SrcAlphaSaturateFactor": () => (/* binding */ SrcAlphaSaturateFactor),
/* harmony export */   "SrcColorFactor": () => (/* binding */ SrcColorFactor),
/* harmony export */   "StaticCopyUsage": () => (/* binding */ StaticCopyUsage),
/* harmony export */   "StaticDrawUsage": () => (/* binding */ StaticDrawUsage),
/* harmony export */   "StaticReadUsage": () => (/* binding */ StaticReadUsage),
/* harmony export */   "StereoCamera": () => (/* binding */ StereoCamera),
/* harmony export */   "StreamCopyUsage": () => (/* binding */ StreamCopyUsage),
/* harmony export */   "StreamDrawUsage": () => (/* binding */ StreamDrawUsage),
/* harmony export */   "StreamReadUsage": () => (/* binding */ StreamReadUsage),
/* harmony export */   "StringKeyframeTrack": () => (/* binding */ StringKeyframeTrack),
/* harmony export */   "SubtractEquation": () => (/* binding */ SubtractEquation),
/* harmony export */   "SubtractiveBlending": () => (/* binding */ SubtractiveBlending),
/* harmony export */   "TOUCH": () => (/* binding */ TOUCH),
/* harmony export */   "TangentSpaceNormalMap": () => (/* binding */ TangentSpaceNormalMap),
/* harmony export */   "TetrahedronBufferGeometry": () => (/* binding */ TetrahedronGeometry),
/* harmony export */   "TetrahedronGeometry": () => (/* binding */ TetrahedronGeometry),
/* harmony export */   "TextGeometry": () => (/* binding */ TextGeometry),
/* harmony export */   "Texture": () => (/* binding */ Texture),
/* harmony export */   "TextureLoader": () => (/* binding */ TextureLoader),
/* harmony export */   "TorusBufferGeometry": () => (/* binding */ TorusGeometry),
/* harmony export */   "TorusGeometry": () => (/* binding */ TorusGeometry),
/* harmony export */   "TorusKnotBufferGeometry": () => (/* binding */ TorusKnotGeometry),
/* harmony export */   "TorusKnotGeometry": () => (/* binding */ TorusKnotGeometry),
/* harmony export */   "Triangle": () => (/* binding */ Triangle),
/* harmony export */   "TriangleFanDrawMode": () => (/* binding */ TriangleFanDrawMode),
/* harmony export */   "TriangleStripDrawMode": () => (/* binding */ TriangleStripDrawMode),
/* harmony export */   "TrianglesDrawMode": () => (/* binding */ TrianglesDrawMode),
/* harmony export */   "TubeBufferGeometry": () => (/* binding */ TubeGeometry),
/* harmony export */   "TubeGeometry": () => (/* binding */ TubeGeometry),
/* harmony export */   "UVMapping": () => (/* binding */ UVMapping),
/* harmony export */   "Uint16Attribute": () => (/* binding */ Uint16Attribute),
/* harmony export */   "Uint16BufferAttribute": () => (/* binding */ Uint16BufferAttribute),
/* harmony export */   "Uint32Attribute": () => (/* binding */ Uint32Attribute),
/* harmony export */   "Uint32BufferAttribute": () => (/* binding */ Uint32BufferAttribute),
/* harmony export */   "Uint8Attribute": () => (/* binding */ Uint8Attribute),
/* harmony export */   "Uint8BufferAttribute": () => (/* binding */ Uint8BufferAttribute),
/* harmony export */   "Uint8ClampedAttribute": () => (/* binding */ Uint8ClampedAttribute),
/* harmony export */   "Uint8ClampedBufferAttribute": () => (/* binding */ Uint8ClampedBufferAttribute),
/* harmony export */   "Uniform": () => (/* binding */ Uniform),
/* harmony export */   "UniformsLib": () => (/* binding */ UniformsLib),
/* harmony export */   "UniformsUtils": () => (/* binding */ UniformsUtils),
/* harmony export */   "UnsignedByteType": () => (/* binding */ UnsignedByteType),
/* harmony export */   "UnsignedInt248Type": () => (/* binding */ UnsignedInt248Type),
/* harmony export */   "UnsignedIntType": () => (/* binding */ UnsignedIntType),
/* harmony export */   "UnsignedShort4444Type": () => (/* binding */ UnsignedShort4444Type),
/* harmony export */   "UnsignedShort5551Type": () => (/* binding */ UnsignedShort5551Type),
/* harmony export */   "UnsignedShortType": () => (/* binding */ UnsignedShortType),
/* harmony export */   "VSMShadowMap": () => (/* binding */ VSMShadowMap),
/* harmony export */   "Vector2": () => (/* binding */ Vector2),
/* harmony export */   "Vector3": () => (/* binding */ Vector3),
/* harmony export */   "Vector4": () => (/* binding */ Vector4),
/* harmony export */   "VectorKeyframeTrack": () => (/* binding */ VectorKeyframeTrack),
/* harmony export */   "Vertex": () => (/* binding */ Vertex),
/* harmony export */   "VertexColors": () => (/* binding */ VertexColors),
/* harmony export */   "VideoTexture": () => (/* binding */ VideoTexture),
/* harmony export */   "WebGL1Renderer": () => (/* binding */ WebGL1Renderer),
/* harmony export */   "WebGL3DRenderTarget": () => (/* binding */ WebGL3DRenderTarget),
/* harmony export */   "WebGLArrayRenderTarget": () => (/* binding */ WebGLArrayRenderTarget),
/* harmony export */   "WebGLCubeRenderTarget": () => (/* binding */ WebGLCubeRenderTarget),
/* harmony export */   "WebGLMultipleRenderTargets": () => (/* binding */ WebGLMultipleRenderTargets),
/* harmony export */   "WebGLMultisampleRenderTarget": () => (/* binding */ WebGLMultisampleRenderTarget),
/* harmony export */   "WebGLRenderTarget": () => (/* binding */ WebGLRenderTarget),
/* harmony export */   "WebGLRenderTargetCube": () => (/* binding */ WebGLRenderTargetCube),
/* harmony export */   "WebGLRenderer": () => (/* binding */ WebGLRenderer),
/* harmony export */   "WebGLUtils": () => (/* binding */ WebGLUtils),
/* harmony export */   "WireframeGeometry": () => (/* binding */ WireframeGeometry),
/* harmony export */   "WireframeHelper": () => (/* binding */ WireframeHelper),
/* harmony export */   "WrapAroundEnding": () => (/* binding */ WrapAroundEnding),
/* harmony export */   "XHRLoader": () => (/* binding */ XHRLoader),
/* harmony export */   "ZeroCurvatureEnding": () => (/* binding */ ZeroCurvatureEnding),
/* harmony export */   "ZeroFactor": () => (/* binding */ ZeroFactor),
/* harmony export */   "ZeroSlopeEnding": () => (/* binding */ ZeroSlopeEnding),
/* harmony export */   "ZeroStencilOp": () => (/* binding */ ZeroStencilOp),
/* harmony export */   "_SRGBAFormat": () => (/* binding */ _SRGBAFormat),
/* harmony export */   "sRGBEncoding": () => (/* binding */ sRGBEncoding)
/* harmony export */ });
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '139';
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const SmoothShading = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;

const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;

const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;

// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
const NoColorSpace = '';
const SRGBColorSpace = 'srgb';
const LinearSRGBColorSpace = 'srgb-linear';

const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;

const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;

const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;

const GLSL1 = '100';
const GLSL3 = '300 es';

const _SRGBAFormat = 1035; // fallback for WebGL 1

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

class EventDispatcher {

	addEventListener( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	}

	hasEventListener( type, listener ) {

		if ( this._listeners === undefined ) return false;

		const listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	}

	removeEventListener( type, listener ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	}

	dispatchEvent( event ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

			event.target = null;

		}

	}

}

const _lut = [];

for ( let i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

let _seed = 1234567;


const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();

}

function clamp( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo( n, m ) {

	return ( ( n % m ) + m ) % m;

}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear( x, a1, a2, b1, b2 ) {

	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp( x, y, value ) {

	if ( x !== y ) {

		return ( value - x ) / ( y - x );

	} else {

		return 0;

	}

}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp( x, y, lambda, dt ) {

	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong( x, length = 1 ) {

	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * ( 3 - 2 * x );

}

function smootherstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

}

// Random integer from <low, high> interval
function randInt( low, high ) {

	return low + Math.floor( Math.random() * ( high - low + 1 ) );

}

// Random float from <low, high> interval
function randFloat( low, high ) {

	return low + Math.random() * ( high - low );

}

// Random float from <-range/2, range/2> interval
function randFloatSpread( range ) {

	return range * ( 0.5 - Math.random() );

}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom( s ) {

	if ( s !== undefined ) _seed = s;

	// Mulberry32 generator

	let t = _seed += 0x6D2B79F5;

	t = Math.imul( t ^ t >>> 15, t | 1 );

	t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

	return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

}

function degToRad( degrees ) {

	return degrees * DEG2RAD;

}

function radToDeg( radians ) {

	return radians * RAD2DEG;

}

function isPowerOfTwo( value ) {

	return ( value & ( value - 1 ) ) === 0 && value !== 0;

}

function ceilPowerOfTwo( value ) {

	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

}

function floorPowerOfTwo( value ) {

	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

}

function setQuaternionFromProperEuler( q, a, b, c, order ) {

	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians

	const cos = Math.cos;
	const sin = Math.sin;

	const c2 = cos( b / 2 );
	const s2 = sin( b / 2 );

	const c13 = cos( ( a + c ) / 2 );
	const s13 = sin( ( a + c ) / 2 );

	const c1_3 = cos( ( a - c ) / 2 );
	const s1_3 = sin( ( a - c ) / 2 );

	const c3_1 = cos( ( c - a ) / 2 );
	const s3_1 = sin( ( c - a ) / 2 );

	switch ( order ) {

		case 'XYX':
			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
			break;

		case 'YZY':
			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
			break;

		case 'ZXZ':
			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
			break;

		case 'XZX':
			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
			break;

		case 'YXY':
			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
			break;

		case 'ZYZ':
			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
			break;

		default:
			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

	}

}

function denormalize$1( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint16Array:

			return value / 65535.0;

		case Uint8Array:

			return value / 255.0;

		case Int16Array:

			return Math.max( value / 32767.0, - 1.0 );

		case Int8Array:

			return Math.max( value / 127.0, - 1.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

function normalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint16Array:

			return Math.round( value * 65535.0 );

		case Uint8Array:

			return Math.round( value * 255.0 );

		case Int16Array:

			return Math.round( value * 32767.0 );

		case Int8Array:

			return Math.round( value * 127.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

var MathUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DEG2RAD: DEG2RAD,
	RAD2DEG: RAD2DEG,
	generateUUID: generateUUID,
	clamp: clamp,
	euclideanModulo: euclideanModulo,
	mapLinear: mapLinear,
	inverseLerp: inverseLerp,
	lerp: lerp,
	damp: damp,
	pingpong: pingpong,
	smoothstep: smoothstep,
	smootherstep: smootherstep,
	randInt: randInt,
	randFloat: randFloat,
	randFloatSpread: randFloatSpread,
	seededRandom: seededRandom,
	degToRad: degToRad,
	radToDeg: radToDeg,
	isPowerOfTwo: isPowerOfTwo,
	ceilPowerOfTwo: ceilPowerOfTwo,
	floorPowerOfTwo: floorPowerOfTwo,
	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
	normalize: normalize,
	denormalize: denormalize$1
});

class Vector2 {

	constructor( x = 0, y = 0 ) {

		this.x = x;
		this.y = y;

	}

	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	angle() {

		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;

	}

}

Vector2.prototype.isVector2 = true;

class Matrix3 {

	constructor() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	scale( sx, sy ) {

		const te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	}

	rotate( theta ) {

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		const te = this.elements;

		const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	}

	translate( tx, ty ) {

		const te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

Matrix3.prototype.isMatrix3 = true;

function arrayNeedsUint32( array ) {

	// assumes larger values usually on last

	for ( let i = array.length - 1; i >= 0; -- i ) {

		if ( array[ i ] > 65535 ) return true;

	}

	return false;

}

const TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	Uint8ClampedArray: Uint8ClampedArray,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};

function getTypedArray( type, buffer ) {

	return new TYPED_ARRAYS[ type ]( buffer );

}

function createElementNS( name ) {

	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

}

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

// JavaScript RGB-to-RGB transforms, defined as
// FN[InputColorSpace][OutputColorSpace] callback functions.
const FN = {
	[ SRGBColorSpace ]: { [ LinearSRGBColorSpace ]: SRGBToLinear },
	[ LinearSRGBColorSpace ]: { [ SRGBColorSpace ]: LinearToSRGB },
};

const ColorManagement = {

	legacyMode: true,

	get workingColorSpace() {

		return LinearSRGBColorSpace;

	},

	set workingColorSpace( colorSpace ) {

		console.warn( 'THREE.ColorManagement: .workingColorSpace is readonly.' );

	},

	convert: function ( color, sourceColorSpace, targetColorSpace ) {

		if ( this.legacyMode || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

			return color;

		}

		if ( FN[ sourceColorSpace ] && FN[ sourceColorSpace ][ targetColorSpace ] !== undefined ) {

			const fn = FN[ sourceColorSpace ][ targetColorSpace ];

			color.r = fn( color.r );
			color.g = fn( color.g );
			color.b = fn( color.b );

			return color;

		}

		throw new Error( 'Unsupported color space conversion.' );

	},

	fromWorkingColorSpace: function ( color, targetColorSpace ) {

		return this.convert( color, this.workingColorSpace, targetColorSpace );

	},

	toWorkingColorSpace: function ( color, sourceColorSpace ) {

		return this.convert( color, sourceColorSpace, this.workingColorSpace );

	},

};

const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _rgb = { r: 0, g: 0, b: 0 };
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

function toComponents( source, target ) {

	target.r = source.r;
	target.g = source.g;
	target.b = source.b;

	return target;

}

class Color {

	constructor( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	set( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	}

	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	setHex( hex, colorSpace = SRGBColorSpace ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setRGB( r, g, b, colorSpace = LinearSRGBColorSpace ) {

		this.r = r;
		this.g = g;
		this.b = b;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setHSL( h, s, l, colorSpace = LinearSRGBColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = euclideanModulo( h, 1 );
		s = clamp( s, 0, 1 );
		l = clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setStyle( style, colorSpace = SRGBColorSpace ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						ColorManagement.toWorkingColorSpace( this, colorSpace );

						handleAlpha( color[ 4 ] );

						return this;

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						ColorManagement.toWorkingColorSpace( this, colorSpace );

						handleAlpha( color[ 4 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						const h = parseFloat( color[ 1 ] ) / 360;
						const s = parseInt( color[ 2 ], 10 ) / 100;
						const l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 4 ] );

						return this.setHSL( h, s, l, colorSpace );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				ColorManagement.toWorkingColorSpace( this, colorSpace );

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				ColorManagement.toWorkingColorSpace( this, colorSpace );

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			return this.setColorName( style, colorSpace );

		}

		return this;

	}

	setColorName( style, colorSpace = SRGBColorSpace ) {

		// color keywords
		const hex = _colorKeywords[ style.toLowerCase() ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex, colorSpace );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	getHex( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

		return clamp( _rgb.r * 255, 0, 255 ) << 16 ^ clamp( _rgb.g * 255, 0, 255 ) << 8 ^ clamp( _rgb.b * 255, 0, 255 ) << 0;

	}

	getHexString( colorSpace = SRGBColorSpace ) {

		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );

	}

	getHSL( target, colorSpace = LinearSRGBColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

		const r = _rgb.r, g = _rgb.g, b = _rgb.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	getRGB( target, colorSpace = LinearSRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

		target.r = _rgb.r;
		target.g = _rgb.g;
		target.b = _rgb.b;

		return target;

	}

	getStyle( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

		if ( colorSpace !== SRGBColorSpace ) {

			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
			return `color(${ colorSpace } ${ _rgb.r } ${ _rgb.g } ${ _rgb.b })`;

		}

		return `rgb(${( _rgb.r * 255 ) | 0},${( _rgb.g * 255 ) | 0},${( _rgb.b * 255 ) | 0})`;

	}

	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		_hslA.h += h; _hslA.s += s; _hslA.l += l;

		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

		return this;

	}

	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	lerpColors( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	}

	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = lerp( _hslA.h, _hslB.h, alpha );
		const s = lerp( _hslA.s, _hslB.s, alpha );
		const l = lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		if ( attribute.normalized === true ) {

			// assuming Uint8Array

			this.r /= 255;
			this.g /= 255;
			this.b /= 255;

		}

		return this;

	}

	toJSON() {

		return this.getHex();

	}

}

Color.NAMES = _colorKeywords;

Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;

let _canvas;

class ImageUtils {

	static getDataURL( image ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement == 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

	static sRGBToLinear( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			const canvas = createElementNS( 'canvas' );

			canvas.width = image.width;
			canvas.height = image.height;

			const context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height );

			const imageData = context.getImageData( 0, 0, image.width, image.height );
			const data = imageData.data;

			for ( let i = 0; i < data.length; i ++ ) {

				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		} else if ( image.data ) {

			const data = image.data.slice( 0 );

			for ( let i = 0; i < data.length; i ++ ) {

				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

				} else {

					// assuming float

					data[ i ] = SRGBToLinear( data[ i ] );

				}

			}

			return {
				data: data,
				width: image.width,
				height: image.height
			};

		} else {

			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
			return image;

		}

	}

}

class Source {

	constructor( data = null ) {

		this.uuid = generateUUID();

		this.data = data;

		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

			return meta.images[ this.uuid ];

		}

		const output = {
			uuid: this.uuid,
			url: ''
		};

		const data = this.data;

		if ( data !== null ) {

			let url;

			if ( Array.isArray( data ) ) {

				// cube texture

				url = [];

				for ( let i = 0, l = data.length; i < l; i ++ ) {

					if ( data[ i ].isDataTexture ) {

						url.push( serializeImage( data[ i ].image ) );

					} else {

						url.push( serializeImage( data[ i ] ) );

					}

				}

			} else {

				// texture

				url = serializeImage( data );

			}

			output.url = url;

		}

		if ( ! isRootObject ) {

			meta.images[ this.uuid ] = output;

		}

		return output;

	}

}

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return ImageUtils.getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.prototype.slice.call( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}

Source.prototype.isSource = true;

let textureId = 0;

class Texture extends EventDispatcher {

	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {

		super();

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = generateUUID();

		this.name = '';

		this.source = new Source( image );
		this.mipmaps = [];

		this.mapping = mapping;

		this.wrapS = wrapS;
		this.wrapT = wrapT;

		this.magFilter = magFilter;
		this.minFilter = minFilter;

		this.anisotropy = anisotropy;

		this.format = format;
		this.internalFormat = null;
		this.type = type;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding;

		this.userData = {};

		this.version = 0;
		this.onUpdate = null;

		this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
		this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

	}

	get image() {

		return this.source.data;

	}

	set image( value ) {

		this.source.data = value;

	}

	updateMatrix() {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.source = source.source;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		this.needsUpdate = true;

		return this;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			image: this.source.toJSON( meta ).uuid,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( JSON.stringify( this.userData ) !== '{}' ) output.userData = this.userData;

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	transformUv( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

	set needsUpdate( value ) {

		if ( value === true ) {

			this.version ++;
			this.source.needsUpdate = true;

		}

	}

}

Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;

Texture.prototype.isTexture = true;

class Vector4 {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

	}

	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setW( w ) {

		this.w = w;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;
		yield this.w;

	}

}

Vector4.prototype.isVector4 = true;

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
class WebGLRenderTarget extends EventDispatcher {

	constructor( width, height, options = {} ) {

		super();

		this.width = width;
		this.height = height;
		this.depth = 1;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		const image = { width: width, height: height, depth: 1 };

		this.texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
		this.texture.isRenderTargetTexture = true;

		this.texture.flipY = false;
		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;

		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

		this.samples = options.samples !== undefined ? options.samples : 0;

	}

	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			this.texture.image.width = width;
			this.texture.image.height = height;
			this.texture.image.depth = depth;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();
		this.texture.isRenderTargetTexture = true;

		// ensure image object is not shared, see #20328

		this.texture.image = Object.assign( {}, source.texture.image );

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;

		if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

		this.samples = source.samples;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

class DataArrayTexture extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		super( null );

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

DataArrayTexture.prototype.isDataArrayTexture = true;

class WebGLArrayRenderTarget extends WebGLRenderTarget {

	constructor( width, height, depth ) {

		super( width, height );

		this.depth = depth;

		this.texture = new DataArrayTexture( null, width, height, depth );

		this.texture.isRenderTargetTexture = true;

	}

}

WebGLArrayRenderTarget.prototype.isWebGLArrayRenderTarget = true;

class Data3DTexture extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		super( null );

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

Data3DTexture.prototype.isData3DTexture = true;

class WebGL3DRenderTarget extends WebGLRenderTarget {

	constructor( width, height, depth ) {

		super( width, height );

		this.depth = depth;

		this.texture = new Data3DTexture( null, width, height, depth );

		this.texture.isRenderTargetTexture = true;

	}

}

WebGL3DRenderTarget.prototype.isWebGL3DRenderTarget = true;

class WebGLMultipleRenderTargets extends WebGLRenderTarget {

	constructor( width, height, count, options = {} ) {

		super( width, height, options );

		const texture = this.texture;

		this.texture = [];

		for ( let i = 0; i < count; i ++ ) {

			this.texture[ i ] = texture.clone();
			this.texture[ i ].isRenderTargetTexture = true;

		}

	}

	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			for ( let i = 0, il = this.texture.length; i < il; i ++ ) {

				this.texture[ i ].image.width = width;
				this.texture[ i ].image.height = height;
				this.texture[ i ].image.depth = depth;

			}

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

		return this;

	}

	copy( source ) {

		this.dispose();

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.viewport.set( 0, 0, this.width, this.height );
		this.scissor.set( 0, 0, this.width, this.height );

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		this.texture.length = 0;

		for ( let i = 0, il = source.texture.length; i < il; i ++ ) {

			this.texture[ i ] = source.texture[ i ].clone();

		}

		return this;

	}

}

WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;

class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerp( qa, qb, qm, t ) {

		console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
		return qm.slerpQuaternions( qa, qb, t );

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		return this.copy( qa ).slerp( qb, t );

	}

	random() {

		// Derived from http://planning.cs.uiuc.edu/node198.html
		// Note, this source uses w, x, y, z ordering,
		// so we swap the order below.

		const u1 = Math.random();
		const sqrt1u1 = Math.sqrt( 1 - u1 );
		const sqrtu1 = Math.sqrt( u1 );

		const u2 = 2 * Math.PI * Math.random();

		const u3 = 2 * Math.PI * Math.random();

		return this.set(
			sqrt1u1 * Math.cos( u2 ),
			sqrtu1 * Math.sin( u3 ),
			sqrtu1 * Math.cos( u3 ),
			sqrt1u1 * Math.sin( u2 ),
		);

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Quaternion.prototype.isQuaternion = true;

class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		const x = this.x, y = this.y, z = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector$c.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector$c );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	setFromEuler( e ) {

		this.x = e._x;
		this.y = e._y;
		this.z = e._z;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

	randomDirection() {

		// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

		const u = ( Math.random() - 0.5 ) * 2;
		const t = Math.random() * Math.PI * 2;
		const f = Math.sqrt( 1 - u ** 2 );

		this.x = f * Math.cos( t );
		this.y = f * Math.sin( t );
		this.z = u;

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;

	}

}

Vector3.prototype.isVector3 = true;

const _vector$c = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();

class Box3 {

	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromArray( array ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = array.length; i < l; i += 3 ) {

			const x = array[ i ];
			const y = array[ i + 1 ];
			const z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromBufferAttribute( attribute ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = attribute.count; i < l; i ++ ) {

			const x = attribute.getX( i );
			const y = attribute.getY( i );
			const z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	setFromObject( object, precise = false ) {

		this.makeEmpty();

		return this.expandByObject( object, precise );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	expandByObject( object, precise = false ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			if ( precise && geometry.attributes != undefined && geometry.attributes.position !== undefined ) {

				const position = geometry.attributes.position;
				for ( let i = 0, l = position.count; i < l; i ++ ) {

					_vector$b.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );
					this.expandByPoint( _vector$b );

				}

			} else {

				if ( geometry.boundingBox === null ) {

					geometry.computeBoundingBox();

				}

				_box$3.copy( geometry.boundingBox );
				_box$3.applyMatrix4( object.matrixWorld );

				this.union( _box$3 );

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ], precise );

		}

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	}

	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$b );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0$2.subVectors( triangle.a, _center );
		_v1$7.subVectors( triangle.b, _center );
		_v2$3.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$7, _v0$2 );
		_f1.subVectors( _v2$3, _v1$7 );
		_f2.subVectors( _v0$2, _v2$3 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents );

	}

	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector$b.copy( point ).clamp( this.min, this.max );

		return clampedPoint.sub( point ).length();

	}

	getBoundingSphere( target ) {

		this.getCenter( target.center );

		target.radius = this.getSize( _vector$b ).length() * 0.5;

		return target;

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

Box3.prototype.isBox3 = true;

const _points = [
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3()
];

const _vector$b = /*@__PURE__*/ new Vector3();

const _box$3 = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0$2 = /*@__PURE__*/ new Vector3();
const _v1$7 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();

const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the separating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the separating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is separating and we can exit
			return false;

		}

	}

	return true;

}

const _box$2 = /*@__PURE__*/ new Box3();
const _v1$6 = /*@__PURE__*/ new Vector3();
const _toFarthestPoint = /*@__PURE__*/ new Vector3();
const _toPoint = /*@__PURE__*/ new Vector3();

class Sphere {

	constructor( center = new Vector3(), radius = - 1 ) {

		this.center = center;
		this.radius = radius;

	}

	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$2.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	isEmpty() {

		return ( this.radius < 0 );

	}

	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = - 1;

		return this;

	}

	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	getBoundingBox( target ) {

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	expandByPoint( point ) {

		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671

		_toPoint.subVectors( point, this.center );

		const lengthSq = _toPoint.lengthSq();

		if ( lengthSq > ( this.radius * this.radius ) ) {

			const length = Math.sqrt( lengthSq );
			const missingRadiusHalf = ( length - this.radius ) * 0.5;

			// Nudge this sphere towards the target point. Add half the missing distance to radius,
			// and the other half to position. This gives a tighter enclosure, instead of if
			// the whole missing distance were just added to radius.

			this.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );
			this.radius += missingRadiusHalf;

		}

		return this;

	}

	union( sphere ) {

		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769

		// To enclose another sphere into this sphere, we only need to enclose two points:
		// 1) Enclose the farthest point on the other sphere into this sphere.
		// 2) Enclose the opposite point of the farthest point into this sphere.

		 if ( this.center.equals( sphere.center ) === true ) {

			 _toFarthestPoint.set( 0, 0, 1 ).multiplyScalar( sphere.radius );


		} else {

			_toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );

		}

		this.expandByPoint( _v1$6.copy( sphere.center ).add( _toFarthestPoint ) );
		this.expandByPoint( _v1$6.copy( sphere.center ).sub( _toFarthestPoint ) );

		return this;

	}

	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$a = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();

const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal$1 = /*@__PURE__*/ new Vector3();

class Ray {

	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

		this.origin = origin;
		this.direction = direction;

	}

	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	at( t, target ) {

		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	}

	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	recast( t ) {

		this.origin.copy( this.at( t, _vector$a ) );

		return this;

	}

	closestPointToPoint( point, target ) {

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	}

	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	distanceSqToPoint( point ) {

		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$a.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		return _vector$a.distanceToSquared( point );

	}

	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

		}

		return sqrDist;

	}

	intersectSphere( sphere, target ) {

		_vector$a.subVectors( sphere.center, this.origin );
		const tca = _vector$a.dot( this.direction );
		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if both t0 and t1 are behind the ray - if so, return null
		if ( t0 < 0 && t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	intersectsSphere( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	intersectsBox( box ) {

		return this.intersectBox( box, _vector$a ) !== null;

	}

	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal$1.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal$1 );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal$1 );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class Matrix4 {

	constructor() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( xy, xz, yx, yz, zx, zy ) {

		this.set(

			1, yx, zx, 0,
			xy, 1, zy, 0,
			xz, yz, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1$2.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1$2.elements[ 0 ] *= invSX;
		_m1$2.elements[ 1 ] *= invSX;
		_m1$2.elements[ 2 ] *= invSX;

		_m1$2.elements[ 4 ] *= invSY;
		_m1$2.elements[ 5 ] *= invSY;
		_m1$2.elements[ 6 ] *= invSY;

		_m1$2.elements[ 8 ] *= invSZ;
		_m1$2.elements[ 9 ] *= invSZ;
		_m1$2.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1$2 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );
		const c = - ( far + near ) / ( far - near );
		const d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;
		const z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

Matrix4.prototype.isMatrix4 = true;

const _v1$5 = /*@__PURE__*/ new Vector3();
const _m1$2 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();

const _matrix$1 = /*@__PURE__*/ new Matrix4();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order = this._order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order = this._order, update = true ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix$1.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix$1, order, update );

	}

	setFromVector3( v, order = this._order ) {

		return this.set( v.x, v.y, v.z, order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$3.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$3, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Euler.prototype.isEuler = true;

Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

class Layers {

	constructor() {

		this.mask = 1 | 0;

	}

	set( channel ) {

		this.mask = ( 1 << channel | 0 ) >>> 0;

	}

	enable( channel ) {

		this.mask |= 1 << channel | 0;

	}

	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	toggle( channel ) {

		this.mask ^= 1 << channel | 0;

	}

	disable( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	}

	disableAll() {

		this.mask = 0;

	}

	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

	isEnabled( channel ) {

		return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

	}

}

let _object3DId = 0;

const _v1$4 = /*@__PURE__*/ new Vector3();
const _q1 = /*@__PURE__*/ new Quaternion();
const _m1$1 = /*@__PURE__*/ new Matrix4();
const _target = /*@__PURE__*/ new Vector3();

const _position$3 = /*@__PURE__*/ new Vector3();
const _scale$2 = /*@__PURE__*/ new Vector3();
const _quaternion$2 = /*@__PURE__*/ new Quaternion();

const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

class Object3D extends EventDispatcher {

	constructor() {

		super();

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.animations = [];

		this.userData = {};

	}

	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	applyMatrix4( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	}

	applyQuaternion( q ) {

		this.quaternion.premultiply( q );

		return this;

	}

	setRotationFromAxisAngle( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	}

	setRotationFromEuler( euler ) {

		this.quaternion.setFromEuler( euler, true );

	}

	setRotationFromMatrix( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	}

	setRotationFromQuaternion( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	}

	rotateOnAxis( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	}

	rotateOnWorldAxis( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	}

	rotateX( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	}

	rotateY( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	}

	rotateZ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	}

	translateOnAxis( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$4.multiplyScalar( distance ) );

		return this;

	}

	translateX( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	}

	translateY( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	}

	translateZ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	}

	localToWorld( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	}

	worldToLocal( vector ) {

		return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

	}

	lookAt( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position$3.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$1.lookAt( _position$3, _target, this.up );

		} else {

			_m1$1.lookAt( _target, _position$3, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$1 );

		if ( parent ) {

			_m1$1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	}

	add( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	}

	remove( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	}

	removeFromParent() {

		const parent = this.parent;

		if ( parent !== null ) {

			parent.remove( this );

		}

		return this;

	}

	clear() {

		for ( let i = 0; i < this.children.length; i ++ ) {

			const object = this.children[ i ];

			object.parent = null;

			object.dispatchEvent( _removedEvent );

		}

		this.children.length = 0;

		return this;


	}

	attach( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

		this.updateWorldMatrix( true, false );

		_m1$1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$1 );

		this.add( object );

		object.updateWorldMatrix( false, true );

		return this;

	}

	getObjectById( id ) {

		return this.getObjectByProperty( 'id', id );

	}

	getObjectByName( name ) {

		return this.getObjectByProperty( 'name', name );

	}

	getObjectByProperty( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	}

	getWorldPosition( target ) {

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	}

	getWorldQuaternion( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, target, _scale$2 );

		return target;

	}

	getWorldScale( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

		return target;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	}

	raycast( /* raycaster, intersects */ ) {}

	traverse( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	}

	traverseVisible( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	}

	traverseAncestors( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	}

	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	}

	updateMatrixWorld( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	}

	toJSON( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {},
				nodes: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isScene ) {

			if ( this.background ) {

				if ( this.background.isColor ) {

					object.background = this.background.toJSON();

				} else if ( this.background.isTexture ) {

					object.background = this.background.toJSON( meta ).uuid;

				}

			}

			if ( this.environment && this.environment.isTexture ) {

				object.environment = this.environment.toJSON( meta ).uuid;

			}

		} else if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );
			const nodes = extractFromCache( meta.nodes );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;
			if ( nodes.length > 0 ) output.nodes = nodes;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	}

	clone( recursive ) {

		return new this.constructor().copy( this, recursive );

	}

	copy( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

}

Object3D.DefaultUp = new Vector3( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

Object3D.prototype.isObject3D = true;

const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$2 = /*@__PURE__*/ new Vector3();
const _v3$1 = /*@__PURE__*/ new Vector3();

const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();

class Triangle {

	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

		this.a = a;
		this.b = b;
		this.c = c;

	}

	static getNormal( a, b, c, target ) {

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$2.subVectors( point, a );

		const dot00 = _v0$1.dot( _v0$1 );
		const dot01 = _v0$1.dot( _v1$3 );
		const dot02 = _v0$1.dot( _v2$2 );
		const dot11 = _v1$3.dot( _v1$3 );
		const dot12 = _v1$3.dot( _v2$2 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set( - 2, - 1, - 1 );

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	static containsPoint( point, a, b, c ) {

		this.getBarycoord( point, a, b, c, _v3$1 );

		return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

	}

	static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		this.getBarycoord( point, p1, p2, p3, _v3$1 );

		target.set( 0, 0 );
		target.addScaledVector( uv1, _v3$1.x );
		target.addScaledVector( uv2, _v3$1.y );
		target.addScaledVector( uv3, _v3$1.z );

		return target;

	}

	static isFrontFacing( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

		this.a.fromBufferAttribute( attribute, i0 );
		this.b.fromBufferAttribute( attribute, i1 );
		this.c.fromBufferAttribute( attribute, i2 );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	getArea() {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	}

	getMidpoint( target ) {

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	getPlane( target ) {

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	getUV( point, uv1, uv2, uv3, target ) {

		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	}

	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	closestPointToPoint( p, target ) {

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}

let materialId = 0;

class Material extends EventDispatcher {

	constructor() {

		super();

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Material';

		this.fog = true;

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.vertexColors = false;

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaToCoverage = false;
		this.premultipliedAlpha = false;

		this.visible = true;

		this.toneMapped = true;

		this.userData = {};

		this.version = 0;

		this._alphaTest = 0;

	}

	get alphaTest() {

		return this._alphaTest;

	}

	set alphaTest( value ) {

		if ( this._alphaTest > 0 !== value > 0 ) {

			this.version ++;

		}

		this._alphaTest = value;

	}

	onBuild( /* shaderobject, renderer */ ) {}

	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

	onBeforeCompile( /* shaderobject, renderer */ ) {}

	customProgramCacheKey() {

		return this.onBeforeCompile.toString();

	}

	setValues( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				continue;

			}

			// for backward compatibility if shading is set in the constructor
			if ( key === 'shading' ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( newValue === FlatShading ) ? true : false;
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( isRootObject ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen !== undefined ) data.sheen = this.sheen;
		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		if ( this.lightMap && this.lightMap.isTexture ) {

			data.lightMap = this.lightMap.toJSON( meta ).uuid;
			data.lightMapIntensity = this.lightMapIntensity;

		}

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;

			if ( this.combine !== undefined ) data.combine = this.combine;

		}

		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.transmission !== undefined ) data.transmission = this.transmission;
		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
		if ( this.thickness !== undefined ) data.thickness = this.thickness;
		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
		if ( this.attenuationDistance !== undefined ) data.attenuationDistance = this.attenuationDistance;
		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;
		data.colorWrite = this.colorWrite;

		data.stencilWrite = this.stencilWrite;
		data.stencilWriteMask = this.stencilWriteMask;
		data.stencilFunc = this.stencilFunc;
		data.stencilRef = this.stencilRef;
		data.stencilFuncMask = this.stencilFuncMask;
		data.stencilFail = this.stencilFail;
		data.stencilZFail = this.stencilZFail;
		data.stencilZPass = this.stencilZPass;

		// rotation (SpriteMaterial)
		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.flatShading === true ) data.flatShading = this.flatShading;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRootObject ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.fog = source.fog;

		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

Material.prototype.isMaterial = true;

Material.fromType = function ( /*type*/ ) {

	// TODO: Behavior added in Materials.js

	return null;

};

class MeshBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		return this;

	}

}

MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

const _vector$9 = /*@__PURE__*/ new Vector3();
const _vector2$1 = /*@__PURE__*/ new Vector2();

class BufferAttribute {

	constructor( array, itemSize, normalized ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	copy( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	copyArray( array ) {

		this.array.set( array );

		return this;

	}

	copyColorsArray( colors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = colors.length; i < l; i ++ ) {

			let color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	}

	copyVector2sArray( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	}

	copyVector3sArray( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	}

	copyVector4sArray( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	}

	applyMatrix3( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2$1.fromBufferAttribute( this, i );
				_vector2$1.applyMatrix3( m );

				this.setXY( i, _vector2$1.x, _vector2$1.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );
				_vector$9.applyMatrix3( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

		}

		return this;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyMatrix4( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyNormalMatrix( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.transformDirection( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	set( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	}

	getX( index ) {

		return this.array[ index * this.itemSize ];

	}

	setX( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	}

	getY( index ) {

		return this.array[ index * this.itemSize + 1 ];

	}

	setY( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	}

	getZ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	}

	setZ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	}

	getW( index ) {

		return this.array[ index * this.itemSize + 3 ];

	}

	setW( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	}

	setXY( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	clone() {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	}

	toJSON() {

		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.prototype.slice.call( this.array ),
			normalized: this.normalized
		};

		if ( this.name !== '' ) data.name = this.name;
		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
		if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

		return data;

	}

}

BufferAttribute.prototype.isBufferAttribute = true;

//

class Int8BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int8Array( array ), itemSize, normalized );

	}

}

class Uint8BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint8Array( array ), itemSize, normalized );

	}

}

class Uint8ClampedBufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint8ClampedArray( array ), itemSize, normalized );

	}

}

class Int16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int16Array( array ), itemSize, normalized );

	}

}

class Uint16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

	}

}

class Int32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int32Array( array ), itemSize, normalized );

	}

}

class Uint32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint32Array( array ), itemSize, normalized );

	}

}

class Float16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

	}

}

Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

class Float32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Float32Array( array ), itemSize, normalized );

	}

}

class Float64BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Float64Array( array ), itemSize, normalized );

	}

}

let _id$1 = 0;

const _m1 = /*@__PURE__*/ new Matrix4();
const _obj = /*@__PURE__*/ new Object3D();
const _offset = /*@__PURE__*/ new Vector3();
const _box$1 = /*@__PURE__*/ new Box3();
const _boxMorphTargets = /*@__PURE__*/ new Box3();
const _vector$8 = /*@__PURE__*/ new Vector3();

class BufferGeometry extends EventDispatcher {

	constructor() {

		super();

		Object.defineProperty( this, 'id', { value: _id$1 ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};
		this.morphTargetsRelative = false;

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	getIndex() {

		return this.index;

	}

	setIndex( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	}

	getAttribute( name ) {

		return this.attributes[ name ];

	}

	setAttribute( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	}

	deleteAttribute( name ) {

		delete this.attributes[ name ];

		return this;

	}

	hasAttribute( name ) {

		return this.attributes[ name ] !== undefined;

	}

	addGroup( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	}

	clearGroups() {

		this.groups = [];

	}

	setDrawRange( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	}

	applyMatrix4( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	}

	applyQuaternion( q ) {

		_m1.makeRotationFromQuaternion( q );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateX( angle ) {

		// rotate geometry around world x-axis

		_m1.makeRotationX( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateY( angle ) {

		// rotate geometry around world y-axis

		_m1.makeRotationY( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateZ( angle ) {

		// rotate geometry around world z-axis

		_m1.makeRotationZ( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	translate( x, y, z ) {

		// translate geometry

		_m1.makeTranslation( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	}

	scale( x, y, z ) {

		// scale geometry

		_m1.makeScale( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	}

	lookAt( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	}

	center() {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	}

	setFromPoints( points ) {

		const position = [];

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		return this;

	}

	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingBox.set(
				new Vector3( - Infinity, - Infinity, - Infinity ),
				new Vector3( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box$1.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( this.boundingBox.min, _box$1.min );
						this.boundingBox.expandByPoint( _vector$8 );

						_vector$8.addVectors( this.boundingBox.max, _box$1.max );
						this.boundingBox.expandByPoint( _vector$8 );

					} else {

						this.boundingBox.expandByPoint( _box$1.min );
						this.boundingBox.expandByPoint( _box$1.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	}

	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingSphere.set( new Vector3(), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box$1.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( _box$1.min, _boxMorphTargets.min );
						_box$1.expandByPoint( _vector$8 );

						_vector$8.addVectors( _box$1.max, _boxMorphTargets.max );
						_box$1.expandByPoint( _vector$8 );

					} else {

						_box$1.expandByPoint( _boxMorphTargets.min );
						_box$1.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$1.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector$8.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$8.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$8.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	}

	computeTangents() {

		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( index === null ||
			 attributes.position === undefined ||
			 attributes.normal === undefined ||
			 attributes.uv === undefined ) {

			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			return;

		}

		const indices = index.array;
		const positions = attributes.position.array;
		const normals = attributes.normal.array;
		const uvs = attributes.uv.array;

		const nVertices = positions.length / 3;

		if ( this.hasAttribute( 'tangent' ) === false ) {

			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

		}

		const tangents = this.getAttribute( 'tangent' ).array;

		const tan1 = [], tan2 = [];

		for ( let i = 0; i < nVertices; i ++ ) {

			tan1[ i ] = new Vector3();
			tan2[ i ] = new Vector3();

		}

		const vA = new Vector3(),
			vB = new Vector3(),
			vC = new Vector3(),

			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),

			sdir = new Vector3(),
			tdir = new Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			uvA.fromArray( uvs, a * 2 );
			uvB.fromArray( uvs, b * 2 );
			uvC.fromArray( uvs, c * 2 );

			vB.sub( vA );
			vC.sub( vA );

			uvB.sub( uvA );
			uvC.sub( uvA );

			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if ( ! isFinite( r ) ) return;

			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		let groups = this.groups;

		if ( groups.length === 0 ) {

			groups = [ {
				start: 0,
				count: indices.length
			} ];

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleTriangle(
					indices[ j + 0 ],
					indices[ j + 1 ],
					indices[ j + 2 ]
				);

			}

		}

		const tmp = new Vector3(), tmp2 = new Vector3();
		const n = new Vector3(), n2 = new Vector3();

		function handleVertex( v ) {

			n.fromArray( normals, v * 3 );
			n2.copy( n );

			const t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			const test = tmp2.dot( tan2[ v ] );
			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangents[ v * 4 ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleVertex( indices[ j + 0 ] );
				handleVertex( indices[ j + 1 ] );
				handleVertex( indices[ j + 2 ] );

			}

		}

	}

	computeVertexNormals() {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			const cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	}

	merge( geometry, offset ) {

		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) {

			offset = 0;

			console.warn(
				'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
				+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
			);

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			const attribute1 = attributes[ key ];
			const attributeArray1 = attribute1.array;

			const attribute2 = geometry.attributes[ key ];
			const attributeArray2 = attribute2.array;

			const attributeOffset = attribute2.itemSize * offset;
			const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

			for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	}

	normalizeNormals() {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector$8.fromBufferAttribute( normals, i );

			_vector$8.normalize();

			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

		}

	}

	toNonIndexed() {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					index = indices[ i ] * attribute.data.stride + attribute.offset;

				} else {

					index = indices[ i ] * itemSize;

				}

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			data.data.attributes[ key ] = attribute.toJSON( data.data );

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				array.push( attribute.toJSON( data.data ) );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	}

	clone() {

		 return new this.constructor().copy( this );

	}

	copy( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone( data ) );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		// geometry generator parameters

		if ( source.parameters !== undefined ) this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

BufferGeometry.prototype.isBufferGeometry = true;

const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
const _ray$2 = /*@__PURE__*/ new Ray();
const _sphere$3 = /*@__PURE__*/ new Sphere();

const _vA$1 = /*@__PURE__*/ new Vector3();
const _vB$1 = /*@__PURE__*/ new Vector3();
const _vC$1 = /*@__PURE__*/ new Vector3();

const _tempA = /*@__PURE__*/ new Vector3();
const _tempB = /*@__PURE__*/ new Vector3();
const _tempC = /*@__PURE__*/ new Vector3();

const _morphA = /*@__PURE__*/ new Vector3();
const _morphB = /*@__PURE__*/ new Vector3();
const _morphC = /*@__PURE__*/ new Vector3();

const _uvA$1 = /*@__PURE__*/ new Vector2();
const _uvB$1 = /*@__PURE__*/ new Vector2();
const _uvC$1 = /*@__PURE__*/ new Vector2();

const _intersectionPoint = /*@__PURE__*/ new Vector3();
const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

class Mesh extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

		super();

		this.type = 'Mesh';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source ) {

		super.copy( source );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$3.copy( geometry.boundingSphere );
		_sphere$3.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

		//

		_inverseMatrix$2.copy( matrixWorld ).invert();
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		let intersection;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const position = geometry.attributes.position;
			const morphPosition = geometry.morphAttributes.position;
			const morphTargetsRelative = geometry.morphTargetsRelative;
			const uv = geometry.attributes.uv;
			const uv2 = geometry.attributes.uv2;
			const groups = geometry.groups;
			const drawRange = geometry.drawRange;

			if ( index !== null ) {

				// indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = index.getX( j );
							const b = index.getX( j + 1 );
							const c = index.getX( j + 2 );

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = index.getX( i );
						const b = index.getX( i + 1 );
						const c = index.getX( i + 2 );

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( position !== undefined ) {

				// non-indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = j;
							const b = j + 1;
							const c = j + 2;

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = i;
						const b = i + 1;
						const c = i + 2;

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	}

}

Mesh.prototype.isMesh = true;

function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

	_vA$1.fromBufferAttribute( position, a );
	_vB$1.fromBufferAttribute( position, b );
	_vC$1.fromBufferAttribute( position, c );

	const morphInfluences = object.morphTargetInfluences;

	if ( morphPosition && morphInfluences ) {

		_morphA.set( 0, 0, 0 );
		_morphB.set( 0, 0, 0 );
		_morphC.set( 0, 0, 0 );

		for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

			const influence = morphInfluences[ i ];
			const morphAttribute = morphPosition[ i ];

			if ( influence === 0 ) continue;

			_tempA.fromBufferAttribute( morphAttribute, a );
			_tempB.fromBufferAttribute( morphAttribute, b );
			_tempC.fromBufferAttribute( morphAttribute, c );

			if ( morphTargetsRelative ) {

				_morphA.addScaledVector( _tempA, influence );
				_morphB.addScaledVector( _tempB, influence );
				_morphC.addScaledVector( _tempC, influence );

			} else {

				_morphA.addScaledVector( _tempA.sub( _vA$1 ), influence );
				_morphB.addScaledVector( _tempB.sub( _vB$1 ), influence );
				_morphC.addScaledVector( _tempC.sub( _vC$1 ), influence );

			}

		}

		_vA$1.add( _morphA );
		_vB$1.add( _morphB );
		_vC$1.add( _morphC );

	}

	if ( object.isSkinnedMesh ) {

		object.boneTransform( a, _vA$1 );
		object.boneTransform( b, _vB$1 );
		object.boneTransform( c, _vC$1 );

	}

	const intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

	if ( intersection ) {

		if ( uv ) {

			_uvA$1.fromBufferAttribute( uv, a );
			_uvB$1.fromBufferAttribute( uv, b );
			_uvC$1.fromBufferAttribute( uv, c );

			intersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		if ( uv2 ) {

			_uvA$1.fromBufferAttribute( uv2, a );
			_uvB$1.fromBufferAttribute( uv2, b );
			_uvC$1.fromBufferAttribute( uv2, c );

			intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};

		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

		intersection.face = face;

	}

	return intersection;

}

class BoxGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		super();

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	static fromJSON( data ) {

		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

	}

}

/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	const dst = {};

	for ( const u in src ) {

		dst[ u ] = {};

		for ( const p in src[ u ] ) {

			const property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture || property.isQuaternion ) ) {

				dst[ u ][ p ] = property.clone();

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	const merged = {};

	for ( let u = 0; u < uniforms.length; u ++ ) {

		const tmp = cloneUniforms( uniforms[ u ] );

		for ( const p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

// Legacy

const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

class ShaderMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		this.glslVersion = null;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	}

	copy( source ) {

		super.copy( source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.lights = source.lights;
		this.clipping = source.clipping;

		this.extensions = Object.assign( {}, source.extensions );

		this.glslVersion = source.glslVersion;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.glslVersion = this.glslVersion;
		data.uniforms = {};

		for ( const name in this.uniforms ) {

			const uniform = this.uniforms[ name ];
			const value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		const extensions = {};

		for ( const key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	}

}

ShaderMaterial.prototype.isShaderMaterial = true;

class Camera extends Object3D {

	constructor() {

		super();

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		return this;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		super.updateWorldMatrix( updateParents, updateChildren );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

Camera.prototype.isCamera = true;

class PerspectiveCamera extends Camera {

	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

		super();

		this.type = 'PerspectiveCamera';

		this.fov = fov;
		this.zoom = 1;

		this.near = near;
		this.far = far;
		this.focus = 10;

		this.aspect = aspect;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	}

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength( focalLength ) {

		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	}

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength() {

		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	}

	getEffectiveFOV() {

		return RAD2DEG * 2 * Math.atan(
			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

	}

	getFilmWidth() {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	}

	getFilmHeight() {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	}

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const near = this.near;
		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = - 0.5 * width;
		const view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		const skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

}

PerspectiveCamera.prototype.isPerspectiveCamera = true;

const fov = 90, aspect = 1;

class CubeCamera extends Object3D {

	constructor( near, far, renderTarget ) {

		super();

		this.type = 'CubeCamera';

		if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

			console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
			return;

		}

		this.renderTarget = renderTarget;

		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.layers = this.layers;
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.layers = this.layers;
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.layers = this.layers;
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.layers = this.layers;
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.layers = this.layers;
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.layers = this.layers;
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

	}

	update( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		const renderTarget = this.renderTarget;

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

		const currentRenderTarget = renderer.getRenderTarget();

		const currentOutputEncoding = renderer.outputEncoding;
		const currentToneMapping = renderer.toneMapping;
		const currentXrEnabled = renderer.xr.enabled;

		renderer.outputEncoding = LinearEncoding;
		renderer.toneMapping = NoToneMapping;
		renderer.xr.enabled = false;

		const generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0 );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1 );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2 );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3 );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4 );
		renderer.render( scene, cameraPZ );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5 );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget );

		renderer.outputEncoding = currentOutputEncoding;
		renderer.toneMapping = currentToneMapping;
		renderer.xr.enabled = currentXrEnabled;

		renderTarget.texture.needsPMREMUpdate = true;

	}

}

class CubeTexture extends Texture {

	constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.flipY = false;

	}

	get images() {

		return this.image;

	}

	set images( value ) {

		this.image = value;

	}

}

CubeTexture.prototype.isCubeTexture = true;

class WebGLCubeRenderTarget extends WebGLRenderTarget {

	constructor( size, options = {} ) {

		super( size, size, options );

		const image = { width: size, height: size, depth: 1 };
		const images = [ image, image, image, image, image, image ];

		this.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

		this.texture.isRenderTargetTexture = true;

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

	}

	fromEquirectangularTexture( renderer, texture ) {

		this.texture.type = texture.type;
		this.texture.encoding = texture.encoding;

		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;

		const shader = {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};

		const geometry = new BoxGeometry( 5, 5, 5 );

		const material = new ShaderMaterial( {

			name: 'CubemapFromEquirect',

			uniforms: cloneUniforms( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending

		} );

		material.uniforms.tEquirect.value = texture;

		const mesh = new Mesh( geometry, material );

		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );
		camera.update( renderer, mesh );

		texture.minFilter = currentMinFilter;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

	clear( renderer, color, depth, stencil ) {

		const currentRenderTarget = renderer.getRenderTarget();

		for ( let i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( this, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	}

}

WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

const _vector1 = /*@__PURE__*/ new Vector3();
const _vector2 = /*@__PURE__*/ new Vector3();
const _normalMatrix = /*@__PURE__*/ new Matrix3();

class Plane {

	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

		// normal is assumed to be normalized

		this.normal = normal;
		this.constant = constant;

	}

	set( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	}

	setComponents( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	}

	setFromNormalAndCoplanarPoint( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	}

	setFromCoplanarPoints( a, b, c ) {

		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	}

	copy( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	}

	normalize() {

		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	}

	negate() {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	}

	distanceToPoint( point ) {

		return this.normal.dot( point ) + this.constant;

	}

	distanceToSphere( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	}

	projectPoint( point, target ) {

		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

	}

	intersectLine( line, target ) {

		const direction = line.delta( _vector1 );

		const denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return null;

		}

		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return null;

		}

		return target.copy( direction ).multiplyScalar( t ).add( line.start );

	}

	intersectsLine( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint( line.start );
		const endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	}

	intersectsBox( box ) {

		return box.intersectsPlane( this );

	}

	intersectsSphere( sphere ) {

		return sphere.intersectsPlane( this );

	}

	coplanarPoint( target ) {

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	}

	applyMatrix4( matrix, optionalNormalMatrix ) {

		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	}

	translate( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	}

	equals( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

Plane.prototype.isPlane = true;

const _sphere$2 = /*@__PURE__*/ new Sphere();
const _vector$7 = /*@__PURE__*/ new Vector3();

class Frustum {

	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

		this.planes = [ p0, p1, p2, p3, p4, p5 ];

	}

	set( p0, p1, p2, p3, p4, p5 ) {

		const planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	}

	copy( frustum ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	}

	setFromProjectionMatrix( m ) {

		const planes = this.planes;
		const me = m.elements;
		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	}

	intersectsObject( object ) {

		const geometry = object.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		return this.intersectsSphere( _sphere$2 );

	}

	intersectsSprite( sprite ) {

		_sphere$2.center.set( 0, 0, 0 );
		_sphere$2.radius = 0.7071067811865476;
		_sphere$2.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$2 );

	}

	intersectsSphere( sphere ) {

		const planes = this.planes;
		const center = sphere.center;
		const negRadius = - sphere.radius;

		for ( let i = 0; i < 6; i ++ ) {

			const distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	}

	intersectsBox( box ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			const plane = planes[ i ];

			// corner at max distance

			_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	containsPoint( point ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

function WebGLAnimation() {

	let context = null;
	let isAnimating = false;
	let animationLoop = null;
	let requestId = null;

	function onAnimationFrame( time, frame ) {

		animationLoop( time, frame );

		requestId = context.requestAnimationFrame( onAnimationFrame );

	}

	return {

		start: function () {

			if ( isAnimating === true ) return;
			if ( animationLoop === null ) return;

			requestId = context.requestAnimationFrame( onAnimationFrame );

			isAnimating = true;

		},

		stop: function () {

			context.cancelAnimationFrame( requestId );

			isAnimating = false;

		},

		setAnimationLoop: function ( callback ) {

			animationLoop = callback;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

}

function WebGLAttributes( gl, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	const buffers = new WeakMap();

	function createBuffer( attribute, bufferType ) {

		const array = attribute.array;
		const usage = attribute.usage;

		const buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		let type;

		if ( array instanceof Float32Array ) {

			type = 5126;

		} else if ( array instanceof Uint16Array ) {

			if ( attribute.isFloat16BufferAttribute ) {

				if ( isWebGL2 ) {

					type = 5131;

				} else {

					throw new Error( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

				}

			} else {

				type = 5123;

			}

		} else if ( array instanceof Int16Array ) {

			type = 5122;

		} else if ( array instanceof Uint32Array ) {

			type = 5125;

		} else if ( array instanceof Int32Array ) {

			type = 5124;

		} else if ( array instanceof Int8Array ) {

			type = 5120;

		} else if ( array instanceof Uint8Array ) {

			type = 5121;

		} else if ( array instanceof Uint8ClampedArray ) {

			type = 5121;

		} else {

			throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		const array = attribute.array;
		const updateRange = attribute.updateRange;

		gl.bindBuffer( bufferType, buffer );

		if ( updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else {

			if ( isWebGL2 ) {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array, updateRange.offset, updateRange.count );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

			}

			updateRange.count = - 1; // reset range

		}

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return buffers.get( attribute );

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			buffers.delete( attribute );

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isGLBufferAttribute ) {

			const cached = buffers.get( attribute );

			if ( ! cached || cached.version < attribute.version ) {

				buffers.set( attribute, {
					buffer: attribute.buffer,
					type: attribute.type,
					bytesPerElement: attribute.elementSize,
					version: attribute.version
				} );

			}

			return;

		}

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data === undefined ) {

			buffers.set( attribute, createBuffer( attribute, bufferType ) );

		} else if ( data.version < attribute.version ) {

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}

class PlaneGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		super();
		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor( widthSegments );
		const gridY = Math.floor( heightSegments );

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		for ( let iy = 0; iy < gridY1; iy ++ ) {

			const y = iy * segment_height - height_half;

			for ( let ix = 0; ix < gridX1; ix ++ ) {

				const x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		for ( let iy = 0; iy < gridY; iy ++ ) {

			for ( let ix = 0; ix < gridX; ix ++ ) {

				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * ( iy + 1 );
				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				const d = ( ix + 1 ) + gridX1 * iy;

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	static fromJSON( data ) {

		return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

	}

}

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";

var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";

var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";

var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

const vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

const fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

const fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

const ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	alphatest_pars_fragment: alphatest_pars_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_vertex: lights_lambert_vertex,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphcolor_vertex: morphcolor_vertex,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normal_pars_fragment: normal_pars_fragment,
	normal_pars_vertex: normal_pars_vertex,
	normal_vertex: normal_vertex,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	output_fragment: output_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	transmission_fragment: transmission_fragment,
	transmission_pars_fragment: transmission_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,

	background_vert: vertex$g,
	background_frag: fragment$g,
	cube_vert: vertex$f,
	cube_frag: fragment$f,
	depth_vert: vertex$e,
	depth_frag: fragment$e,
	distanceRGBA_vert: vertex$d,
	distanceRGBA_frag: fragment$d,
	equirect_vert: vertex$c,
	equirect_frag: fragment$c,
	linedashed_vert: vertex$b,
	linedashed_frag: fragment$b,
	meshbasic_vert: vertex$a,
	meshbasic_frag: fragment$a,
	meshlambert_vert: vertex$9,
	meshlambert_frag: fragment$9,
	meshmatcap_vert: vertex$8,
	meshmatcap_frag: fragment$8,
	meshnormal_vert: vertex$7,
	meshnormal_frag: fragment$7,
	meshphong_vert: vertex$6,
	meshphong_frag: fragment$6,
	meshphysical_vert: vertex$5,
	meshphysical_frag: fragment$5,
	meshtoon_vert: vertex$4,
	meshtoon_frag: fragment$4,
	points_vert: vertex$3,
	points_frag: fragment$3,
	shadow_vert: vertex$2,
	shadow_frag: fragment$2,
	sprite_vert: vertex$1,
	sprite_frag: fragment$1
};

/**
 * Uniforms library for shared webgl shaders
 */

const UniformsLib = {

	common: {

		diffuse: { value: new Color( 0xffffff ) },
		opacity: { value: 1.0 },

		map: { value: null },
		uvTransform: { value: new Matrix3() },
		uv2Transform: { value: new Matrix3() },

		alphaMap: { value: null },
		alphaTest: { value: 0 }

	},

	specularmap: {

		specularMap: { value: null },

	},

	envmap: {

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 }, // basic, lambert, phong
		ior: { value: 1.5 }, // physical
		refractionRatio: { value: 0.98 } // basic, lambert, phong

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {}
		} },

		directionalLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {}
		} },

		spotLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {}
		} },

		pointLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} },

		ltc_1: { value: null },
		ltc_2: { value: null }

	},

	points: {

		diffuse: { value: new Color( 0xffffff ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		alphaMap: { value: null },
		alphaTest: { value: 0 },
		uvTransform: { value: new Matrix3() }

	},

	sprite: {

		diffuse: { value: new Color( 0xffffff ) },
		opacity: { value: 1.0 },
		center: { value: new Vector2( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		alphaMap: { value: null },
		alphaTest: { value: 0 },
		uvTransform: { value: new Matrix3() }

	}

};

const ShaderLib = {

	basic: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				roughness: { value: 1.0 },
				metalness: { value: 0.0 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	toon: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag

	},

	matcap: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag

	},

	points: {

		uniforms: mergeUniforms( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.meshnormal_vert,
		fragmentShader: ShaderChunk.meshnormal_frag

	},

	sprite: {

		uniforms: mergeUniforms( [
			UniformsLib.sprite,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: new Matrix3() },
			t2D: { value: null },
		},

		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag

	},
	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	cube: {

		uniforms: mergeUniforms( [
			UniformsLib.envmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	},

	shadow: {

		uniforms: mergeUniforms( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: new Color( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),

		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: mergeUniforms( [
		ShaderLib.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
			clearcoatNormalMap: { value: null },
			sheen: { value: 0 },
			sheenColor: { value: new Color( 0x000000 ) },
			sheenColorMap: { value: null },
			sheenRoughness: { value: 1 },
			sheenRoughnessMap: { value: null },
			transmission: { value: 0 },
			transmissionMap: { value: null },
			transmissionSamplerSize: { value: new Vector2() },
			transmissionSamplerMap: { value: null },
			thickness: { value: 0 },
			thicknessMap: { value: null },
			attenuationDistance: { value: 0 },
			attenuationColor: { value: new Color( 0x000000 ) },
			specularIntensity: { value: 1 },
			specularIntensityMap: { value: null },
			specularColor: { value: new Color( 1, 1, 1 ) },
			specularColorMap: { value: null },
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

function WebGLBackground( renderer, cubemaps, state, objects, alpha, premultipliedAlpha ) {

	const clearColor = new Color( 0x000000 );
	let clearAlpha = alpha === true ? 0 : 1;

	let planeMesh;
	let boxMesh;

	let currentBackground = null;
	let currentBackgroundVersion = 0;
	let currentTonemapping = null;

	function render( renderList, scene ) {

		let forceClear = false;
		let background = scene.isScene === true ? scene.background : null;

		if ( background && background.isTexture ) {

			background = cubemaps.get( background );

		}

		// Ignore background in AR
		// TODO: Reconsider this.

		const xr = renderer.xr;
		const session = xr.getSession && xr.getSession();

		if ( session && session.environmentBlendMode === 'additive' ) {

			background = null;

		}

		if ( background === null ) {

			setClear( clearColor, clearAlpha );

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;

		}

		if ( renderer.autoClear || forceClear ) {

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

		if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

			if ( boxMesh === undefined ) {

				boxMesh = new Mesh(
					new BoxGeometry( 1, 1, 1 ),
					new ShaderMaterial( {
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				boxMesh.geometry.deleteAttribute( 'normal' );
				boxMesh.geometry.deleteAttribute( 'uv' );

				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

				// enable code injection for non-built-in material
				Object.defineProperty( boxMesh.material, 'envMap', {

					get: function () {

						return this.uniforms.envMap.value;

					}

				} );

				objects.update( boxMesh );

			}

			boxMesh.material.uniforms.envMap.value = background;
			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				boxMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			// push to the pre-sorted opaque render list
			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		} else if ( background && background.isTexture ) {

			if ( planeMesh === undefined ) {

				planeMesh = new Mesh(
					new PlaneGeometry( 2, 2 ),
					new ShaderMaterial( {
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				planeMesh.geometry.deleteAttribute( 'normal' );

				// enable code injection for non-built-in material
				Object.defineProperty( planeMesh.material, 'map', {

					get: function () {

						return this.uniforms.t2D.value;

					}

				} );

				objects.update( planeMesh );

			}

			planeMesh.material.uniforms.t2D.value = background;

			if ( background.matrixAutoUpdate === true ) {

				background.updateMatrix();

			}

			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				planeMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}


			// push to the pre-sorted opaque render list
			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		}

	}

	function setClear( color, alpha ) {

		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha = 1 ) {

			clearColor.set( color );
			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render

	};

}

function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

	const maxVertexAttributes = gl.getParameter( 34921 );

	const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
	const vaoAvailable = capabilities.isWebGL2 || extension !== null;

	const bindingStates = {};

	const defaultState = createBindingState( null );
	let currentState = defaultState;
	let forceUpdate = false;

	function setup( object, material, program, geometry, index ) {

		let updateBuffers = false;

		if ( vaoAvailable ) {

			const state = getBindingState( geometry, program, material );

			if ( currentState !== state ) {

				currentState = state;
				bindVertexArrayObject( currentState.object );

			}

			updateBuffers = needsUpdate( geometry, index );

			if ( updateBuffers ) saveCache( geometry, index );

		} else {

			const wireframe = ( material.wireframe === true );

			if ( currentState.geometry !== geometry.id ||
				currentState.program !== program.id ||
				currentState.wireframe !== wireframe ) {

				currentState.geometry = geometry.id;
				currentState.program = program.id;
				currentState.wireframe = wireframe;

				updateBuffers = true;

			}

		}

		if ( object.isInstancedMesh === true ) {

			updateBuffers = true;

		}

		if ( index !== null ) {

			attributes.update( index, 34963 );

		}

		if ( updateBuffers || forceUpdate ) {

			forceUpdate = false;

			setupVertexAttributes( object, material, program, geometry );

			if ( index !== null ) {

				gl.bindBuffer( 34963, attributes.get( index ).buffer );

			}

		}

	}

	function createVertexArrayObject() {

		if ( capabilities.isWebGL2 ) return gl.createVertexArray();

		return extension.createVertexArrayOES();

	}

	function bindVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

		return extension.bindVertexArrayOES( vao );

	}

	function deleteVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

		return extension.deleteVertexArrayOES( vao );

	}

	function getBindingState( geometry, program, material ) {

		const wireframe = ( material.wireframe === true );

		let programMap = bindingStates[ geometry.id ];

		if ( programMap === undefined ) {

			programMap = {};
			bindingStates[ geometry.id ] = programMap;

		}

		let stateMap = programMap[ program.id ];

		if ( stateMap === undefined ) {

			stateMap = {};
			programMap[ program.id ] = stateMap;

		}

		let state = stateMap[ wireframe ];

		if ( state === undefined ) {

			state = createBindingState( createVertexArrayObject() );
			stateMap[ wireframe ] = state;

		}

		return state;

	}

	function createBindingState( vao ) {

		const newAttributes = [];
		const enabledAttributes = [];
		const attributeDivisors = [];

		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

			newAttributes[ i ] = 0;
			enabledAttributes[ i ] = 0;
			attributeDivisors[ i ] = 0;

		}

		return {

			// for backward compatibility on non-VAO support browser
			geometry: null,
			program: null,
			wireframe: false,

			newAttributes: newAttributes,
			enabledAttributes: enabledAttributes,
			attributeDivisors: attributeDivisors,
			object: vao,
			attributes: {},
			index: null

		};

	}

	function needsUpdate( geometry, index ) {

		const cachedAttributes = currentState.attributes;
		const geometryAttributes = geometry.attributes;

		let attributesNum = 0;

		for ( const key in geometryAttributes ) {

			const cachedAttribute = cachedAttributes[ key ];
			const geometryAttribute = geometryAttributes[ key ];

			if ( cachedAttribute === undefined ) return true;

			if ( cachedAttribute.attribute !== geometryAttribute ) return true;

			if ( cachedAttribute.data !== geometryAttribute.data ) return true;

			attributesNum ++;

		}

		if ( currentState.attributesNum !== attributesNum ) return true;

		if ( currentState.index !== index ) return true;

		return false;

	}

	function saveCache( geometry, index ) {

		const cache = {};
		const attributes = geometry.attributes;
		let attributesNum = 0;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			const data = {};
			data.attribute = attribute;

			if ( attribute.data ) {

				data.data = attribute.data;

			}

			cache[ key ] = data;

			attributesNum ++;

		}

		currentState.attributes = cache;
		currentState.attributesNum = attributesNum;

		currentState.index = index;

	}

	function initAttributes() {

		const newAttributes = currentState.newAttributes;

		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		enableAttributeAndDivisor( attribute, 0 );

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		const attributeDivisors = currentState.attributeDivisors;

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

			extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;

		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

		if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

			gl.vertexAttribIPointer( index, size, type, stride, offset );

		} else {

			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

		}

	}

	function setupVertexAttributes( object, material, program, geometry ) {

		if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

		}

		initAttributes();

		const geometryAttributes = geometry.attributes;

		const programAttributes = program.getAttributes();

		const materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				let geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

				}

				if ( geometryAttribute !== undefined ) {

					const normalized = geometryAttribute.normalized;
					const size = geometryAttribute.itemSize;

					const attribute = attributes.get( geometryAttribute );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;
					const bytesPerElement = attribute.bytesPerElement;

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						const data = geometryAttribute.data;
						const stride = data.stride;
						const offset = geometryAttribute.offset;

						if ( data.isInstancedInterleavedBuffer ) {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

							}

							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

							}

						} else {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttribute( programAttribute.location + i );

							}

						}

						gl.bindBuffer( 34962, buffer );

						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

							vertexAttribPointer(
								programAttribute.location + i,
								size / programAttribute.locationSize,
								type,
								normalized,
								stride * bytesPerElement,
								( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement
							);

						}

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

							}

							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttribute( programAttribute.location + i );

							}

						}

						gl.bindBuffer( 34962, buffer );

						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

							vertexAttribPointer(
								programAttribute.location + i,
								size / programAttribute.locationSize,
								type,
								normalized,
								size * bytesPerElement,
								( size / programAttribute.locationSize ) * i * bytesPerElement
							);

						}

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					const value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								gl.vertexAttrib2fv( programAttribute.location, value );
								break;

							case 3:
								gl.vertexAttrib3fv( programAttribute.location, value );
								break;

							case 4:
								gl.vertexAttrib4fv( programAttribute.location, value );
								break;

							default:
								gl.vertexAttrib1fv( programAttribute.location, value );

						}

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	function dispose() {

		reset();

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometryId ];

		}

	}

	function releaseStatesOfGeometry( geometry ) {

		if ( bindingStates[ geometry.id ] === undefined ) return;

		const programMap = bindingStates[ geometry.id ];

		for ( const programId in programMap ) {

			const stateMap = programMap[ programId ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ programId ];

		}

		delete bindingStates[ geometry.id ];

	}

	function releaseStatesOfProgram( program ) {

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			if ( programMap[ program.id ] === undefined ) continue;

			const stateMap = programMap[ program.id ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ program.id ];

		}

	}

	function reset() {

		resetDefaultState();
		forceUpdate = true;

		if ( currentState === defaultState ) return;

		currentState = defaultState;
		bindVertexArrayObject( currentState.object );

	}

	// for backward-compatibility

	function resetDefaultState() {

		defaultState.geometry = null;
		defaultState.program = null;
		defaultState.wireframe = false;

	}

	return {

		setup: setup,
		reset: reset,
		resetDefaultState: resetDefaultState,
		dispose: dispose,
		releaseStatesOfGeometry: releaseStatesOfGeometry,
		releaseStatesOfProgram: releaseStatesOfProgram,

		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		disableUnusedAttributes: disableUnusedAttributes

	};

}

function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawArraysInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawArraysInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, start, count, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

}

function WebGLCapabilities( gl, extensions, parameters ) {

	let maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
		( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );

	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	const maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	const drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );

	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	const maxTextures = gl.getParameter( 34930 );
	const maxVertexTextures = gl.getParameter( 35660 );
	const maxTextureSize = gl.getParameter( 3379 );
	const maxCubemapSize = gl.getParameter( 34076 );

	const maxAttributes = gl.getParameter( 34921 );
	const maxVertexUniforms = gl.getParameter( 36347 );
	const maxVaryings = gl.getParameter( 36348 );
	const maxFragmentUniforms = gl.getParameter( 36349 );

	const vertexTextures = maxVertexTextures > 0;
	const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
	const floatVertexTextures = vertexTextures && floatFragmentTextures;

	const maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

	return {

		isWebGL2: isWebGL2,

		drawBuffers: drawBuffers,

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures,

		maxSamples: maxSamples

	};

}

function WebGLClipping( properties ) {

	const scope = this;

	let globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false;

	const plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function ( planes, enableLocalClipping, camera ) {

		const enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function () {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function () {

		renderingShadows = false;
		resetGlobalState();

	};

	this.setState = function ( material, camera, useCache ) {

		const planes = material.clippingPlanes,
			clipIntersection = material.clipIntersection,
			clipShadows = material.clipShadows;

		const materialProperties = properties.get( material );

		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			// there's no local clipping

			if ( renderingShadows ) {

				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();

			}

		} else {

			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4;

			let dstArray = materialProperties.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

			for ( let i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			materialProperties.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		const nPlanes = planes !== null ? planes.length : 0;
		let dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				const flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;

		return dstArray;

	}

}

function WebGLCubeMaps( renderer ) {

	let cubemaps = new WeakMap();

	function mapTextureMapping( texture, mapping ) {

		if ( mapping === EquirectangularReflectionMapping ) {

			texture.mapping = CubeReflectionMapping;

		} else if ( mapping === EquirectangularRefractionMapping ) {

			texture.mapping = CubeRefractionMapping;

		}

		return texture;

	}

	function get( texture ) {

		if ( texture && texture.isTexture && texture.isRenderTargetTexture === false ) {

			const mapping = texture.mapping;

			if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

				if ( cubemaps.has( texture ) ) {

					const cubemap = cubemaps.get( texture ).texture;
					return mapTextureMapping( cubemap, texture.mapping );

				} else {

					const image = texture.image;

					if ( image && image.height > 0 ) {

						const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
						renderTarget.fromEquirectangularTexture( renderer, texture );
						cubemaps.set( texture, renderTarget );

						texture.addEventListener( 'dispose', onTextureDispose );

						return mapTextureMapping( renderTarget.texture, texture.mapping );

					} else {

						// image not yet ready. try the conversion next frame

						return null;

					}

				}

			}

		}

		return texture;

	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemap = cubemaps.get( texture );

		if ( cubemap !== undefined ) {

			cubemaps.delete( texture );
			cubemap.dispose();

		}

	}

	function dispose() {

		cubemaps = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

class OrthographicCamera extends Camera {

	constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

		super();

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = near;
		this.far = far;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	}

	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		const cx = ( this.right + this.left ) / 2;
		const cy = ( this.top + this.bottom ) / 2;

		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

}

OrthographicCamera.prototype.isOrthographicCamera = true;

const LOD_MIN = 4;

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;

const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
const _clearColor = /*@__PURE__*/ new Color();
let _oldTarget = null;

// Golden Ratio
const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
	/*@__PURE__*/ new Vector3( 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

class PMREMGenerator {

	constructor( renderer ) {

		this._renderer = renderer;
		this._pingPongRenderTarget = null;

		this._lodMax = 0;
		this._cubeSize = 0;
		this._lodPlanes = [];
		this._sizeLods = [];
		this._sigmas = [];

		this._blurMaterial = null;
		this._cubemapMaterial = null;
		this._equirectMaterial = null;

		this._compileMaterial( this._blurMaterial );

	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

		_oldTarget = this._renderer.getRenderTarget();

		this._setSize( 256 );

		const cubeUVRenderTarget = this._allocateTargets();
		cubeUVRenderTarget.depthBuffer = true;

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * or HDR. The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromEquirectangular( equirectangular, renderTarget = null ) {

		return this._fromTexture( equirectangular, renderTarget );

	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * or HDR. The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromCubemap( cubemap, renderTarget = null ) {

		return this._fromTexture( cubemap, renderTarget );

	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader() {

		if ( this._cubemapMaterial === null ) {

			this._cubemapMaterial = _getCubemapMaterial();
			this._compileMaterial( this._cubemapMaterial );

		}

	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader() {

		if ( this._equirectMaterial === null ) {

			this._equirectMaterial = _getEquirectMaterial();
			this._compileMaterial( this._equirectMaterial );

		}

	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {

		this._dispose();

		if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
		if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();

	}

	// private interface

	_setSize( cubeSize ) {

		this._lodMax = Math.floor( Math.log2( cubeSize ) );
		this._cubeSize = Math.pow( 2, this._lodMax );

	}

	_dispose() {

		if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

		if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

		for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

			this._lodPlanes[ i ].dispose();

		}

	}

	_cleanup( outputTarget ) {

		this._renderer.setRenderTarget( _oldTarget );
		outputTarget.scissorTest = false;
		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

	}

	_fromTexture( texture, renderTarget ) {

		if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

			this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

		} else { // Equirectangular

			this._setSize( texture.image.width / 4 );

		}

		_oldTarget = this._renderer.getRenderTarget();

		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		this._textureToCubeUV( texture, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	_allocateTargets() {

		const width = 3 * Math.max( this._cubeSize, 16 * 7 );
		const height = 4 * this._cubeSize - 32;

		const params = {
			magFilter: LinearFilter,
			minFilter: LinearFilter,
			generateMipmaps: false,
			type: HalfFloatType,
			format: RGBAFormat,
			encoding: LinearEncoding,
			depthBuffer: false
		};

		const cubeUVRenderTarget = _createRenderTarget( width, height, params );

		if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width ) {

			if ( this._pingPongRenderTarget !== null ) {

				this._dispose();

			}

			this._pingPongRenderTarget = _createRenderTarget( width, height, params );

			const { _lodMax } = this;
			( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );

			this._blurMaterial = _getBlurShader( _lodMax, width, height );

		}

		return cubeUVRenderTarget;

	}

	_compileMaterial( material ) {

		const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
		this._renderer.compile( tmpMesh, _flatCamera );

	}

	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

		const fov = 90;
		const aspect = 1;
		const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
		const upSign = [ 1, - 1, 1, 1, 1, 1 ];
		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
		const renderer = this._renderer;

		const originalAutoClear = renderer.autoClear;
		const toneMapping = renderer.toneMapping;
		renderer.getClearColor( _clearColor );

		renderer.toneMapping = NoToneMapping;
		renderer.autoClear = false;

		const backgroundMaterial = new MeshBasicMaterial( {
			name: 'PMREM.Background',
			side: BackSide,
			depthWrite: false,
			depthTest: false,
		} );

		const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

		let useSolidColor = false;
		const background = scene.background;

		if ( background ) {

			if ( background.isColor ) {

				backgroundMaterial.color.copy( background );
				scene.background = null;
				useSolidColor = true;

			}

		} else {

			backgroundMaterial.color.copy( _clearColor );
			useSolidColor = true;

		}

		for ( let i = 0; i < 6; i ++ ) {

			const col = i % 3;

			if ( col === 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

			} else if ( col === 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

			}

			const size = this._cubeSize;

			_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

			renderer.setRenderTarget( cubeUVRenderTarget );

			if ( useSolidColor ) {

				renderer.render( backgroundBox, cubeCamera );

			}

			renderer.render( scene, cubeCamera );

		}

		backgroundBox.geometry.dispose();
		backgroundBox.material.dispose();

		renderer.toneMapping = toneMapping;
		renderer.autoClear = originalAutoClear;
		scene.background = background;

	}

	_textureToCubeUV( texture, cubeUVRenderTarget ) {

		const renderer = this._renderer;

		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

		if ( isCubeTexture ) {

			if ( this._cubemapMaterial === null ) {

				this._cubemapMaterial = _getCubemapMaterial();

			}

			this._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;

		} else {

			if ( this._equirectMaterial === null ) {

				this._equirectMaterial = _getEquirectMaterial();

			}

		}

		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
		const mesh = new Mesh( this._lodPlanes[ 0 ], material );

		const uniforms = material.uniforms;

		uniforms[ 'envMap' ].value = texture;

		const size = this._cubeSize;

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	}

	_applyPMREM( cubeUVRenderTarget ) {

		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;

		for ( let i = 1; i < this._lodPlanes.length; i ++ ) {

			const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

			const poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

		}

		renderer.autoClear = autoClear;

	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		const pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	}

	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			console.error(
				'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;

		const blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );
		const blurUniforms = blurMaterial.uniforms;

		const pixels = this._sizeLods[ lodIn ] - 1;
		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		const weights = [];
		let sum = 0;

		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

			const x = i / sigmaPixels;
			const weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i === 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( let i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		blurUniforms[ 'envMap' ].value = targetIn.texture;
		blurUniforms[ 'samples' ].value = samples;
		blurUniforms[ 'weights' ].value = weights;
		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

		if ( poleAxis ) {

			blurUniforms[ 'poleAxis' ].value = poleAxis;

		}

		const { _lodMax } = this;
		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
		blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;

		const outputSize = this._sizeLods[ lodOut ];
		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
		const y = 4 * ( this._cubeSize - outputSize );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

}



function _createPlanes( lodMax ) {

	const lodPlanes = [];
	const sizeLods = [];
	const sigmas = [];

	let lod = lodMax;

	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

	for ( let i = 0; i < totalLods; i ++ ) {

		const sizeLod = Math.pow( 2, lod );
		sizeLods.push( sizeLod );
		let sigma = 1.0 / sizeLod;

		if ( i > lodMax - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

		} else if ( i === 0 ) {

			sigma = 0;

		}

		sigmas.push( sigma );

		const texelSize = 1.0 / ( sizeLod - 1 );
		const min = - texelSize / 2;
		const max = 1 + texelSize / 2;
		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;

		const position = new Float32Array( positionSize * vertices * cubeFaces );
		const uv = new Float32Array( uvSize * vertices * cubeFaces );
		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( let face = 0; face < cubeFaces; face ++ ) {

			const x = ( face % 3 ) * 2 / 3 - 1;
			const y = face > 2 ? 0 : - 1;
			const coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];
			position.set( coordinates, positionSize * vertices * face );
			uv.set( uv1, uvSize * vertices * face );
			const fill = [ face, face, face, face, face, face ];
			faceIndex.set( fill, faceIndexSize * vertices * face );

		}

		const planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		lodPlanes.push( planes );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { lodPlanes, sizeLods, sigmas };

}

function _createRenderTarget( width, height, params ) {

	const cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getBlurShader( lodMax, width, height ) {

	const weights = new Float32Array( MAX_SAMPLES );
	const poleAxis = new Vector3( 0, 1, 0 );
	const shaderMaterial = new ShaderMaterial( {

		name: 'SphericalGaussianBlur',

		defines: {
			'n': MAX_SAMPLES,
			'CUBEUV_TEXEL_WIDTH': 1.0 / width,
			'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
			'CUBEUV_MAX_MIP': `${lodMax}.0`,
		},

		uniforms: {
			'envMap': { value: null },
			'samples': { value: 1 },
			'weights': { value: weights },
			'latitudinal': { value: false },
			'dTheta': { value: 0 },
			'mipInt': { value: 0 },
			'poleAxis': { value: poleAxis }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getEquirectMaterial() {

	return new ShaderMaterial( {

		name: 'EquirectangularToCubeUV',

		uniforms: {
			'envMap': { value: null }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

}

function _getCubemapMaterial() {

	return new ShaderMaterial( {

		name: 'CubemapToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'flipEnvMap': { value: - 1 }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

}

function _getCommonVertexShader() {

	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

}

function WebGLCubeUVMaps( renderer ) {

	let cubeUVmaps = new WeakMap();

	let pmremGenerator = null;

	function get( texture ) {

		if ( texture && texture.isTexture ) {

			const mapping = texture.mapping;

			const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
			const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

			// equirect/cube map to cubeUV conversion

			if ( isEquirectMap || isCubeMap ) {

				if ( texture.isRenderTargetTexture && texture.needsPMREMUpdate === true ) {

					texture.needsPMREMUpdate = false;

					let renderTarget = cubeUVmaps.get( texture );

					if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

					renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
					cubeUVmaps.set( texture, renderTarget );

					return renderTarget.texture;

				} else {

					if ( cubeUVmaps.has( texture ) ) {

						return cubeUVmaps.get( texture ).texture;

					} else {

						const image = texture.image;

						if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

							if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

							const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
							cubeUVmaps.set( texture, renderTarget );

							texture.addEventListener( 'dispose', onTextureDispose );

							return renderTarget.texture;

						} else {

							// image not yet ready. try the conversion next frame

							return null;

						}

					}

				}

			}

		}

		return texture;

	}

	function isCubeTextureComplete( image ) {

		let count = 0;
		const length = 6;

		for ( let i = 0; i < length; i ++ ) {

			if ( image[ i ] !== undefined ) count ++;

		}

		return count === length;


	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemapUV = cubeUVmaps.get( texture );

		if ( cubemapUV !== undefined ) {

			cubeUVmaps.delete( texture );
			cubemapUV.dispose();

		}

	}

	function dispose() {

		cubeUVmaps = new WeakMap();

		if ( pmremGenerator !== null ) {

			pmremGenerator.dispose();
			pmremGenerator = null;

		}

	}

	return {
		get: get,
		dispose: dispose
	};

}

function WebGLExtensions( gl ) {

	const extensions = {};

	function getExtension( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		let extension;

		switch ( name ) {

			case 'WEBGL_depth_texture':
				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
				break;

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		extensions[ name ] = extension;

		return extension;

	}

	return {

		has: function ( name ) {

			return getExtension( name ) !== null;

		},

		init: function ( capabilities ) {

			if ( capabilities.isWebGL2 ) {

				getExtension( 'EXT_color_buffer_float' );

			} else {

				getExtension( 'WEBGL_depth_texture' );
				getExtension( 'OES_texture_float' );
				getExtension( 'OES_texture_half_float' );
				getExtension( 'OES_texture_half_float_linear' );
				getExtension( 'OES_standard_derivatives' );
				getExtension( 'OES_element_index_uint' );
				getExtension( 'OES_vertex_array_object' );
				getExtension( 'ANGLE_instanced_arrays' );

			}

			getExtension( 'OES_texture_float_linear' );
			getExtension( 'EXT_color_buffer_half_float' );
			getExtension( 'WEBGL_multisampled_render_to_texture' );

		},

		get: function ( name ) {

			const extension = getExtension( name );

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			return extension;

		}

	};

}

function WebGLGeometries( gl, attributes, info, bindingStates ) {

	const geometries = {};
	const wireframeAttributes = new WeakMap();

	function onGeometryDispose( event ) {

		const geometry = event.target;

		if ( geometry.index !== null ) {

			attributes.remove( geometry.index );

		}

		for ( const name in geometry.attributes ) {

			attributes.remove( geometry.attributes[ name ] );

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		const attribute = wireframeAttributes.get( geometry );

		if ( attribute ) {

			attributes.remove( attribute );
			wireframeAttributes.delete( geometry );

		}

		bindingStates.releaseStatesOfGeometry( geometry );

		if ( geometry.isInstancedBufferGeometry === true ) {

			delete geometry._maxInstanceCount;

		}

		//

		info.memory.geometries --;

	}

	function get( object, geometry ) {

		if ( geometries[ geometry.id ] === true ) return geometry;

		geometry.addEventListener( 'dispose', onGeometryDispose );

		geometries[ geometry.id ] = true;

		info.memory.geometries ++;

		return geometry;

	}

	function update( geometry ) {

		const geometryAttributes = geometry.attributes;

		// Updating index buffer in VAO now. See WebGLBindingStates.

		for ( const name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], 34962 );

		}

		// morph targets

		const morphAttributes = geometry.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = morphAttributes[ name ];

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				attributes.update( array[ i ], 34962 );

			}

		}

	}

	function updateWireframeAttribute( geometry ) {

		const indices = [];

		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;
		let version = 0;

		if ( geometryIndex !== null ) {

			const array = geometryIndex.array;
			version = geometryIndex.version;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const a = array[ i + 0 ];
				const b = array[ i + 1 ];
				const c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			const array = geometryPosition.array;
			version = geometryPosition.version;

			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				const a = i + 0;
				const b = i + 1;
				const c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		attribute.version = version;

		// Updating index buffer in VAO now. See WebGLBindingStates

		//

		const previousAttribute = wireframeAttributes.get( geometry );

		if ( previousAttribute ) attributes.remove( previousAttribute );

		//

		wireframeAttributes.set( geometry, attribute );

	}

	function getWireframeAttribute( geometry ) {

		const currentAttribute = wireframeAttributes.get( geometry );

		if ( currentAttribute ) {

			const geometryIndex = geometry.index;

			if ( geometryIndex !== null ) {

				// if the attribute is obsolete, create a new one

				if ( currentAttribute.version < geometryIndex.version ) {

					updateWireframeAttribute( geometry );

				}

			}

		} else {

			updateWireframeAttribute( geometry );

		}

		return wireframeAttributes.get( geometry );

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}

function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	let type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawElementsInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawElementsInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

}

function WebGLInfo( gl ) {

	const memory = {
		geometries: 0,
		textures: 0
	};

	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		render.calls ++;

		switch ( mode ) {

			case 4:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case 1:
				render.lines += instanceCount * ( count / 2 );
				break;

			case 3:
				render.lines += instanceCount * ( count - 1 );
				break;

			case 2:
				render.lines += instanceCount * count;
				break;

			case 0:
				render.points += instanceCount * count;
				break;

			default:
				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.frame ++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}

function numericalSort( a, b ) {

	return a[ 0 ] - b[ 0 ];

}

function absNumericalSort( a, b ) {

	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

}

function denormalize( morph, attribute ) {

	let denominator = 1;
	const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;

	if ( array instanceof Int8Array ) denominator = 127;
	else if ( array instanceof Int16Array ) denominator = 32767;
	else if ( array instanceof Int32Array ) denominator = 2147483647;
	else console.error( 'THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array );

	morph.divideScalar( denominator );

}

function WebGLMorphtargets( gl, capabilities, textures ) {

	const influencesList = {};
	const morphInfluences = new Float32Array( 8 );
	const morphTextures = new WeakMap();
	const morph = new Vector4();

	const workInfluences = [];

	for ( let i = 0; i < 8; i ++ ) {

		workInfluences[ i ] = [ i, 0 ];

	}

	function update( object, geometry, material, program ) {

		const objectInfluences = object.morphTargetInfluences;

		if ( capabilities.isWebGL2 === true ) {

			// instead of using attributes, the WebGL 2 code path encodes morph targets
			// into an array of data textures. Each layer represents a single morph target.

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

			let entry = morphTextures.get( geometry );

			if ( entry === undefined || entry.count !== morphTargetsCount ) {

				if ( entry !== undefined ) entry.texture.dispose();

				const hasMorphPosition = geometry.morphAttributes.position !== undefined;
				const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
				const hasMorphColors = geometry.morphAttributes.color !== undefined;

				const morphTargets = geometry.morphAttributes.position || [];
				const morphNormals = geometry.morphAttributes.normal || [];
				const morphColors = geometry.morphAttributes.color || [];

				let vertexDataCount = 0;

				if ( hasMorphPosition === true ) vertexDataCount = 1;
				if ( hasMorphNormals === true ) vertexDataCount = 2;
				if ( hasMorphColors === true ) vertexDataCount = 3;

				let width = geometry.attributes.position.count * vertexDataCount;
				let height = 1;

				if ( width > capabilities.maxTextureSize ) {

					height = Math.ceil( width / capabilities.maxTextureSize );
					width = capabilities.maxTextureSize;

				}

				const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

				const texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
				texture.type = FloatType;
				texture.needsUpdate = true;

				// fill buffer

				const vertexDataStride = vertexDataCount * 4;

				for ( let i = 0; i < morphTargetsCount; i ++ ) {

					const morphTarget = morphTargets[ i ];
					const morphNormal = morphNormals[ i ];
					const morphColor = morphColors[ i ];

					const offset = width * height * 4 * i;

					for ( let j = 0; j < morphTarget.count; j ++ ) {

						const stride = j * vertexDataStride;

						if ( hasMorphPosition === true ) {

							morph.fromBufferAttribute( morphTarget, j );

							if ( morphTarget.normalized === true ) denormalize( morph, morphTarget );

							buffer[ offset + stride + 0 ] = morph.x;
							buffer[ offset + stride + 1 ] = morph.y;
							buffer[ offset + stride + 2 ] = morph.z;
							buffer[ offset + stride + 3 ] = 0;

						}

						if ( hasMorphNormals === true ) {

							morph.fromBufferAttribute( morphNormal, j );

							if ( morphNormal.normalized === true ) denormalize( morph, morphNormal );

							buffer[ offset + stride + 4 ] = morph.x;
							buffer[ offset + stride + 5 ] = morph.y;
							buffer[ offset + stride + 6 ] = morph.z;
							buffer[ offset + stride + 7 ] = 0;

						}

						if ( hasMorphColors === true ) {

							morph.fromBufferAttribute( morphColor, j );

							if ( morphColor.normalized === true ) denormalize( morph, morphColor );

							buffer[ offset + stride + 8 ] = morph.x;
							buffer[ offset + stride + 9 ] = morph.y;
							buffer[ offset + stride + 10 ] = morph.z;
							buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;

						}

					}

				}

				entry = {
					count: morphTargetsCount,
					texture: texture,
					size: new Vector2( width, height )
				};

				morphTextures.set( geometry, entry );

				function disposeTexture() {

					texture.dispose();

					morphTextures.delete( geometry );

					geometry.removeEventListener( 'dispose', disposeTexture );

				}

				geometry.addEventListener( 'dispose', disposeTexture );

			}

			//

			let morphInfluencesSum = 0;

			for ( let i = 0; i < objectInfluences.length; i ++ ) {

				morphInfluencesSum += objectInfluences[ i ];

			}

			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

			program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
			program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );


		} else {

			// When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			const length = objectInfluences === undefined ? 0 : objectInfluences.length;

			let influences = influencesList[ geometry.id ];

			if ( influences === undefined || influences.length !== length ) {

				// initialise list

				influences = [];

				for ( let i = 0; i < length; i ++ ) {

					influences[ i ] = [ i, 0 ];

				}

				influencesList[ geometry.id ] = influences;

			}

			// Collect influences

			for ( let i = 0; i < length; i ++ ) {

				const influence = influences[ i ];

				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];

			}

			influences.sort( absNumericalSort );

			for ( let i = 0; i < 8; i ++ ) {

				if ( i < length && influences[ i ][ 1 ] ) {

					workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
					workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

				} else {

					workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
					workInfluences[ i ][ 1 ] = 0;

				}

			}

			workInfluences.sort( numericalSort );

			const morphTargets = geometry.morphAttributes.position;
			const morphNormals = geometry.morphAttributes.normal;

			let morphInfluencesSum = 0;

			for ( let i = 0; i < 8; i ++ ) {

				const influence = workInfluences[ i ];
				const index = influence[ 0 ];
				const value = influence[ 1 ];

				if ( index !== Number.MAX_SAFE_INTEGER && value ) {

					if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

						geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

					}

					if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

						geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

					}

					morphInfluences[ i ] = value;
					morphInfluencesSum += value;

				} else {

					if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

						geometry.deleteAttribute( 'morphTarget' + i );

					}

					if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

						geometry.deleteAttribute( 'morphNormal' + i );

					}

					morphInfluences[ i ] = 0;

				}

			}

			// GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

		}

	}

	return {

		update: update

	};

}

function WebGLObjects( gl, geometries, attributes, info ) {

	let updateMap = new WeakMap();

	function update( object ) {

		const frame = info.render.frame;

		const geometry = object.geometry;
		const buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateMap.get( buffergeometry ) !== frame ) {

			geometries.update( buffergeometry );

			updateMap.set( buffergeometry, frame );

		}

		if ( object.isInstancedMesh ) {

			if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

				object.addEventListener( 'dispose', onInstancedMeshDispose );

			}

			attributes.update( object.instanceMatrix, 34962 );

			if ( object.instanceColor !== null ) {

				attributes.update( object.instanceColor, 34962 );

			}

		}

		return buffergeometry;

	}

	function dispose() {

		updateMap = new WeakMap();

	}

	function onInstancedMeshDispose( event ) {

		const instancedMesh = event.target;

		instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

		attributes.remove( instancedMesh.instanceMatrix );

		if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

	}

	return {

		update: update,
		dispose: dispose

	};

}

/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

const emptyTexture = new Texture();
const emptyArrayTexture = new DataArrayTexture();
const empty3dTexture = new Data3DTexture();
const emptyCubeTexture = new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array( 16 );
const mat3array = new Float32Array( 9 );
const mat2array = new Float32Array( 4 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	const firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	const n = nBlocks * blockSize;
	let r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

function arraysEqual( a, b ) {

	if ( a.length !== b.length ) return false;

	for ( let i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) return false;

	}

	return true;

}

function copyArray( a, b ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		a[ i ] = b[ i ];

	}

}

// Texture unit allocation

function allocTexUnits( textures, n ) {

	let r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( let i = 0; i !== n; ++ i ) {

		r[ i ] = textures.allocateTextureUnit();

	}

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1f( this.addr, v );

	cache[ 0 ] = v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2f( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else if ( v.r !== undefined ) {

		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

			cache[ 0 ] = v.r;
			cache[ 1 ] = v.g;
			cache[ 2 ] = v.b;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4fv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single matrix (from flat array or THREE.MatrixN)

function setValueM2( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix2fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat2array.set( elements );

		gl.uniformMatrix2fv( this.addr, false, mat2array );

		copyArray( cache, elements );

	}

}

function setValueM3( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix3fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat3array.set( elements );

		gl.uniformMatrix3fv( this.addr, false, mat3array );

		copyArray( cache, elements );

	}

}

function setValueM4( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix4fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat4array.set( elements );

		gl.uniformMatrix4fv( this.addr, false, mat4array );

		copyArray( cache, elements );

	}

}

// Single integer / boolean

function setValueV1i( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1i( this.addr, v );

	cache[ 0 ] = v;

}

// Single integer / boolean vector (from flat array)

function setValueV2i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform2iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV3i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform3iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV4i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform4iv( this.addr, v );

	copyArray( cache, v );

}

// Single unsigned integer

function setValueV1ui( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1ui( this.addr, v );

	cache[ 0 ] = v;

}

// Single unsigned integer vector (from flat array)

function setValueV2ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform2uiv( this.addr, v );

	copyArray( cache, v );

}

function setValueV3ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform3uiv( this.addr, v );

	copyArray( cache, v );

}

function setValueV4ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform4uiv( this.addr, v );

	copyArray( cache, v );

}


// Single texture (2D / Cube)

function setValueT1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2D( v || emptyTexture, unit );

}

function setValueT3D1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture3D( v || empty3dTexture, unit );

}

function setValueT6( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTextureCube( v || emptyCubeTexture, unit );

}

function setValueT2DArray1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2DArray( v || emptyArrayTexture, unit );

}

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1f; // FLOAT
		case 0x8b50: return setValueV2f; // _VEC2
		case 0x8b51: return setValueV3f; // _VEC3
		case 0x8b52: return setValueV4f; // _VEC4

		case 0x8b5a: return setValueM2; // _MAT2
		case 0x8b5b: return setValueM3; // _MAT3
		case 0x8b5c: return setValueM4; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

		case 0x1405: return setValueV1ui; // UINT
		case 0x8dc6: return setValueV2ui; // _VEC2
		case 0x8dc7: return setValueV3ui; // _VEC3
		case 0x8dc8: return setValueV4ui; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;

	}

}


// Array of scalars

function setValueV1fArray( gl, v ) {

	gl.uniform1fv( this.addr, v );

}

// Array of vectors (from flat array or array of THREE.VectorN)

function setValueV2fArray( gl, v ) {

	const data = flatten( v, this.size, 2 );

	gl.uniform2fv( this.addr, data );

}

function setValueV3fArray( gl, v ) {

	const data = flatten( v, this.size, 3 );

	gl.uniform3fv( this.addr, data );

}

function setValueV4fArray( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniform4fv( this.addr, data );

}

// Array of matrices (from flat array or array of THREE.MatrixN)

function setValueM2Array( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniformMatrix2fv( this.addr, false, data );

}

function setValueM3Array( gl, v ) {

	const data = flatten( v, this.size, 9 );

	gl.uniformMatrix3fv( this.addr, false, data );

}

function setValueM4Array( gl, v ) {

	const data = flatten( v, this.size, 16 );

	gl.uniformMatrix4fv( this.addr, false, data );

}

// Array of integer / boolean

function setValueV1iArray( gl, v ) {

	gl.uniform1iv( this.addr, v );

}

// Array of integer / boolean vectors (from flat array)

function setValueV2iArray( gl, v ) {

	gl.uniform2iv( this.addr, v );

}

function setValueV3iArray( gl, v ) {

	gl.uniform3iv( this.addr, v );

}

function setValueV4iArray( gl, v ) {

	gl.uniform4iv( this.addr, v );

}

// Array of unsigned integer

function setValueV1uiArray( gl, v ) {

	gl.uniform1uiv( this.addr, v );

}

// Array of unsigned integer vectors (from flat array)

function setValueV2uiArray( gl, v ) {

	gl.uniform2uiv( this.addr, v );

}

function setValueV3uiArray( gl, v ) {

	gl.uniform3uiv( this.addr, v );

}

function setValueV4uiArray( gl, v ) {

	gl.uniform4uiv( this.addr, v );

}


// Array of textures (2D / 3D / Cube / 2DArray)

function setValueT1Array( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT3DArray( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );

	}

}

function setValueT6Array( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

function setValueT2DArrayArray( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );

	}

}


// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1fArray; // FLOAT
		case 0x8b50: return setValueV2fArray; // _VEC2
		case 0x8b51: return setValueV3fArray; // _VEC3
		case 0x8b52: return setValueV4fArray; // _VEC4

		case 0x8b5a: return setValueM2Array; // _MAT2
		case 0x8b5b: return setValueM3Array; // _MAT3
		case 0x8b5c: return setValueM4Array; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

		case 0x1405: return setValueV1uiArray; // UINT
		case 0x8dc6: return setValueV2uiArray; // _VEC2
		case 0x8dc7: return setValueV3uiArray; // _VEC3
		case 0x8dc8: return setValueV4uiArray; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1Array;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3DArray;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6Array;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArrayArray;

	}

}

// --- Uniform Classes ---

function SingleUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.setValue = getSingularSetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function PureArrayUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.size = activeInfo.size;
	this.setValue = getPureArraySetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

PureArrayUniform.prototype.updateCache = function ( data ) {

	const cache = this.cache;

	if ( data instanceof Float32Array && cache.length !== data.length ) {

		this.cache = new Float32Array( data.length );

	}

	copyArray( cache, data );

};

function StructuredUniform( id ) {

	this.id = id;

	this.seq = [];
	this.map = {};

}

StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

	const seq = this.seq;

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ];
		u.setValue( gl, value[ u.id ], textures );

	}

};

// --- Top-level ---

// Parser - builds up the property tree from the path strings

const RePathPart = /(\w+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	const path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	while ( true ) {

		const match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex;

		let id = match[ 1 ];
		const idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			const map = container.map;
			let next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

function WebGLUniforms( gl, program ) {

	this.seq = [];
	this.map = {};

	const n = gl.getProgramParameter( program, 35718 );

	for ( let i = 0; i < n; ++ i ) {

		const info = gl.getActiveUniform( program, i ),
			addr = gl.getUniformLocation( program, info.name );

		parseUniform( info, addr, this );

	}

}

WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

	const u = this.map[ name ];

	if ( u !== undefined ) u.setValue( gl, value, textures );

};

WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

	const v = object[ name ];

	if ( v !== undefined ) this.setValue( gl, name, v );

};


// Static interface

WebGLUniforms.upload = function ( gl, seq, values, textures ) {

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ],
			v = values[ u.id ];

		if ( v.needsUpdate !== false ) {

			// note: always updating when .needsUpdate is undefined
			u.setValue( gl, v.value, textures );

		}

	}

};

WebGLUniforms.seqWithValue = function ( seq, values ) {

	const r = [];

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ];
		if ( u.id in values ) r.push( u );

	}

	return r;

};

function WebGLShader( gl, type, string ) {

	const shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	return shader;

}

let programIdCount = 0;

function handleSource( string, errorLine ) {

	const lines = string.split( '\n' );
	const lines2 = [];

	const from = Math.max( errorLine - 6, 0 );
	const to = Math.min( errorLine + 6, lines.length );

	for ( let i = from; i < to; i ++ ) {

		lines2.push( ( i + 1 ) + ': ' + lines[ i ] );

	}

	return lines2.join( '\n' );

}

function getEncodingComponents( encoding ) {

	switch ( encoding ) {

		case LinearEncoding:
			return [ 'Linear', '( value )' ];
		case sRGBEncoding:
			return [ 'sRGB', '( value )' ];
		default:
			console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
			return [ 'Linear', '( value )' ];

	}

}

function getShaderErrors( gl, shader, type ) {

	const status = gl.getShaderParameter( shader, 35713 );
	const errors = gl.getShaderInfoLog( shader ).trim();

	if ( status && errors === '' ) return '';

	const errorLine = parseInt( /ERROR: 0:(\d+)/.exec( errors )[ 1 ] );

	// --enable-privileged-webgl-extension
	// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

	return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );

}

function getTexelEncodingFunction( functionName, encoding ) {

	const components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

}

function getToneMappingFunction( functionName, toneMapping ) {

	let toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;

		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;

		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;

		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;

		case CustomToneMapping:
			toneMappingName = 'Custom';
			break;

		default:
			console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
			toneMappingName = 'Linear';

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

}

function generateExtensions( parameters ) {

	const chunks = [
		( parameters.extensionDerivatives || !! parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
		( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	const chunks = [];

	for ( const name in defines ) {

		const value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program ) {

	const attributes = {};

	const n = gl.getProgramParameter( program, 35721 );

	for ( let i = 0; i < n; i ++ ) {

		const info = gl.getActiveAttrib( program, i );
		const name = info.name;

		let locationSize = 1;
		if ( info.type === 35674 ) locationSize = 2;
		if ( info.type === 35675 ) locationSize = 3;
		if ( info.type === 35676 ) locationSize = 4;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[ name ] = {
			type: info.type,
			location: gl.getAttribLocation( program, name ),
			locationSize: locationSize
		};

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

}

function replaceClippingPlaneNums( string, parameters ) {

	return string
		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

}

// Resolve Includes

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes( string ) {

	return string.replace( includePattern, includeReplacer );

}

function includeReplacer( match, include ) {

	const string = ShaderChunk[ include ];

	if ( string === undefined ) {

		throw new Error( 'Can not resolve #include <' + include + '>' );

	}

	return resolveIncludes( string );

}

// Unroll Loops

const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops( string ) {

	return string
		.replace( unrollLoopPattern, loopReplacer )
		.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

}

function deprecatedLoopReplacer( match, start, end, snippet ) {

	console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
	return loopReplacer( match, start, end, snippet );

}

function loopReplacer( match, start, end, snippet ) {

	let string = '';

	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

		string += snippet
			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
			.replace( /UNROLLED_LOOP_INDEX/g, i );

	}

	return string;

}

//

function generatePrecision( parameters ) {

	let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

	if ( parameters.precision === 'highp' ) {

		precisionstring += '\n#define HIGH_PRECISION';

	} else if ( parameters.precision === 'mediump' ) {

		precisionstring += '\n#define MEDIUM_PRECISION';

	} else if ( parameters.precision === 'lowp' ) {

		precisionstring += '\n#define LOW_PRECISION';

	}

	return precisionstring;

}

function generateShadowMapTypeDefine( parameters ) {

	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	} else if ( parameters.shadowMapType === VSMShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	}

	return shadowMapTypeDefine;

}

function generateEnvMapTypeDefine( parameters ) {

	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

		}

	}

	return envMapTypeDefine;

}

function generateEnvMapModeDefine( parameters ) {

	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeRefractionMapping:

				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

	}

	return envMapModeDefine;

}

function generateEnvMapBlendingDefine( parameters ) {

	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	if ( parameters.envMap ) {

		switch ( parameters.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	return envMapBlendingDefine;

}

function generateCubeUVSize( parameters ) {

	const imageHeight = parameters.envMapCubeUVHeight;

	if ( imageHeight === null ) return null;

	const maxMip = Math.log2( imageHeight / 32 + 1 ) + 3;

	const texelHeight = 1.0 / imageHeight;

	const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

	return { texelWidth, texelHeight, maxMip };

}

function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

	// TODO Send this event to Three.js DevTools
	// console.log( 'WebGLProgram', cacheKey );

	const gl = renderer.getContext();

	const defines = parameters.defines;

	let vertexShader = parameters.vertexShader;
	let fragmentShader = parameters.fragmentShader;

	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
	const envMapModeDefine = generateEnvMapModeDefine( parameters );
	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
	const envMapCubeUVSize = generateCubeUVSize( parameters );

	const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

	const customDefines = generateDefines( defines );

	const program = gl.createProgram();

	let prefixVertex, prefixFragment;
	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

	if ( parameters.isRawShaderMaterial ) {

		prefixVertex = [

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixVertex.length > 0 ) {

			prefixVertex += '\n';

		}

		prefixFragment = [

			customExtensions,
			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixFragment.length > 0 ) {

			prefixFragment += '\n';

		}

	} else {

		prefixVertex = [

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.instancing ? '#define USE_INSTANCING' : '',
			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			'#define MAX_BONES ' + parameters.maxBones,
			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',

			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
			parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',

			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

			parameters.transmission ? '#define USE_TRANSMISSION' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
			parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',
			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			( parameters.morphColors && parameters.isWebGL2 ) ? '#define USE_MORPHCOLORS' : '',
			( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE' : '',
			( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
			( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			'#ifdef USE_INSTANCING',

			'	attribute mat4 instanceMatrix;',

			'#endif',

			'#ifdef USE_INSTANCING_COLOR',

			'	attribute vec3 instanceColor;',

			'#endif',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_TANGENT',

			'	attribute vec4 tangent;',

			'#endif',

			'#if defined( USE_COLOR_ALPHA )',

			'	attribute vec4 color;',

			'#elif defined( USE_COLOR )',

			'	attribute vec3 color;',

			'#endif',

			'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.matcap ? '#define USE_MATCAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
			envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
			envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
			parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.alphaTest ? '#define USE_ALPHATEST' : '',

			parameters.sheen ? '#define USE_SHEEN' : '',
			parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
			parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

			parameters.transmission ? '#define USE_TRANSMISSION' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',
			parameters.opaque ? '#define OPAQUE' : '',

			ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

			parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = resolveIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	fragmentShader = resolveIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	vertexShader = unrollLoops( vertexShader );
	fragmentShader = unrollLoops( fragmentShader );

	if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

		versionString = '#version 300 es\n';

		prefixVertex = [
			'precision mediump sampler2DArray;',
			'#define attribute in',
			'#define varying out',
			'#define texture2D texture'
		].join( '\n' ) + '\n' + prefixVertex;

		prefixFragment = [
			'#define varying in',
			( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
			( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
			'#define gl_FragDepthEXT gl_FragDepth',
			'#define texture2D texture',
			'#define textureCube texture',
			'#define texture2DProj textureProj',
			'#define texture2DLodEXT textureLod',
			'#define texture2DProjLodEXT textureProjLod',
			'#define textureCubeLodEXT textureLod',
			'#define texture2DGradEXT textureGrad',
			'#define texture2DProjGradEXT textureProjGrad',
			'#define textureCubeGradEXT textureGrad'
		].join( '\n' ) + '\n' + prefixFragment;

	}

	const vertexGlsl = versionString + prefixVertex + vertexShader;
	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	const glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
	const glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( parameters.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	// check for link errors
	if ( renderer.debug.checkShaderErrors ) {

		const programLog = gl.getProgramInfoLog( program ).trim();
		const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		let runnable = true;
		let haveDiagnostics = true;

		if ( gl.getProgramParameter( program, 35714 ) === false ) {

			runnable = false;

			const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
			const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

			console.error(
				'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
				'VALIDATE_STATUS ' + gl.getProgramParameter( program, 35715 ) + '\n\n' +
				'Program Info Log: ' + programLog + '\n' +
				vertexErrors + '\n' +
				fragmentErrors
			);

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

	}

	// Clean up

	// Crashes in iOS9 and iOS10. #18402
	// gl.detachShader( program, glVertexShader );
	// gl.detachShader( program, glFragmentShader );

	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );

	// set up caching for uniform locations

	let cachedUniforms;

	this.getUniforms = function () {

		if ( cachedUniforms === undefined ) {

			cachedUniforms = new WebGLUniforms( gl, program );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	let cachedAttributes;

	this.getAttributes = function () {

		if ( cachedAttributes === undefined ) {

			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		return cachedAttributes;

	};

	// free resource

	this.destroy = function () {

		bindingStates.releaseStatesOfProgram( this );

		gl.deleteProgram( program );
		this.program = undefined;

	};

	//

	this.name = parameters.shaderName;
	this.id = programIdCount ++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

let _id = 0;

class WebGLShaderCache {

	constructor() {

		this.shaderCache = new Map();
		this.materialCache = new Map();

	}

	update( material ) {

		const vertexShader = material.vertexShader;
		const fragmentShader = material.fragmentShader;

		const vertexShaderStage = this._getShaderStage( vertexShader );
		const fragmentShaderStage = this._getShaderStage( fragmentShader );

		const materialShaders = this._getShaderCacheForMaterial( material );

		if ( materialShaders.has( vertexShaderStage ) === false ) {

			materialShaders.add( vertexShaderStage );
			vertexShaderStage.usedTimes ++;

		}

		if ( materialShaders.has( fragmentShaderStage ) === false ) {

			materialShaders.add( fragmentShaderStage );
			fragmentShaderStage.usedTimes ++;

		}

		return this;

	}

	remove( material ) {

		const materialShaders = this.materialCache.get( material );

		for ( const shaderStage of materialShaders ) {

			shaderStage.usedTimes --;

			if ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );

		}

		this.materialCache.delete( material );

		return this;

	}

	getVertexShaderID( material ) {

		return this._getShaderStage( material.vertexShader ).id;

	}

	getFragmentShaderID( material ) {

		return this._getShaderStage( material.fragmentShader ).id;

	}

	dispose() {

		this.shaderCache.clear();
		this.materialCache.clear();

	}

	_getShaderCacheForMaterial( material ) {

		const cache = this.materialCache;

		if ( cache.has( material ) === false ) {

			cache.set( material, new Set() );

		}

		return cache.get( material );

	}

	_getShaderStage( code ) {

		const cache = this.shaderCache;

		if ( cache.has( code ) === false ) {

			const stage = new WebGLShaderStage( code );
			cache.set( code, stage );

		}

		return cache.get( code );

	}

}

class WebGLShaderStage {

	constructor( code ) {

		this.id = _id ++;

		this.code = code;
		this.usedTimes = 0;

	}

}

function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

	const _programLayers = new Layers();
	const _customShaders = new WebGLShaderCache();
	const programs = [];

	const isWebGL2 = capabilities.isWebGL2;
	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	const floatVertexTextures = capabilities.floatVertexTextures;
	const maxVertexUniforms = capabilities.maxVertexUniforms;
	const vertexTextures = capabilities.vertexTextures;
	let precision = capabilities.precision;

	const shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	function getMaxBones( object ) {

		const skeleton = object.skeleton;
		const bones = skeleton.bones;

		if ( floatVertexTextures ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			const nVertexUniforms = maxVertexUniforms;
			const nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			const maxBones = Math.min( nVertexMatrices, bones.length );

			if ( maxBones < bones.length ) {

				console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
				return 0;

			}

			return maxBones;

		}

	}

	function getParameters( material, lights, shadows, scene, object ) {

		const fog = scene.fog;
		const geometry = object.geometry;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;

		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
		const envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;

		const shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		const maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		//

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		let morphTextureStride = 0;

		if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
		if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
		if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;

		//

		let vertexShader, fragmentShader;
		let customVertexShaderID, customFragmentShaderID;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];

			vertexShader = shader.vertexShader;
			fragmentShader = shader.fragmentShader;

		} else {

			vertexShader = material.vertexShader;
			fragmentShader = material.fragmentShader;

			_customShaders.update( material );

			customVertexShaderID = _customShaders.getVertexShaderID( material );
			customFragmentShaderID = _customShaders.getFragmentShaderID( material );

		}

		const currentRenderTarget = renderer.getRenderTarget();

		const useAlphaTest = material.alphaTest > 0;
		const useClearcoat = material.clearcoat > 0;

		const parameters = {

			isWebGL2: isWebGL2,

			shaderID: shaderID,
			shaderName: material.type,

			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			defines: material.defines,

			customVertexShaderID: customVertexShaderID,
			customFragmentShaderID: customFragmentShaderID,

			isRawShaderMaterial: material.isRawShaderMaterial === true,
			glslVersion: material.glslVersion,

			precision: precision,

			instancing: object.isInstancedMesh === true,
			instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

			supportsVertexTextures: vertexTextures,
			outputEncoding: ( currentRenderTarget === null ) ? renderer.outputEncoding : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding ),
			map: !! material.map,
			matcap: !! material.matcap,
			envMap: !! envMap,
			envMapMode: envMap && envMap.mapping,
			envMapCubeUVHeight: envMapCubeUVHeight,
			lightMap: !! material.lightMap,
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
			tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,

			decodeVideoTexture: !! material.map && ( material.map.isVideoTexture === true ) && ( material.map.encoding === sRGBEncoding ),

			clearcoat: useClearcoat,
			clearcoatMap: useClearcoat && !! material.clearcoatMap,
			clearcoatRoughnessMap: useClearcoat && !! material.clearcoatRoughnessMap,
			clearcoatNormalMap: useClearcoat && !! material.clearcoatNormalMap,

			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			specularIntensityMap: !! material.specularIntensityMap,
			specularColorMap: !! material.specularColorMap,

			opaque: material.transparent === false && material.blending === NormalBlending,

			alphaMap: !! material.alphaMap,
			alphaTest: useAlphaTest,

			gradientMap: !! material.gradientMap,

			sheen: material.sheen > 0,
			sheenColorMap: !! material.sheenColorMap,
			sheenRoughnessMap: !! material.sheenRoughnessMap,

			transmission: material.transmission > 0,
			transmissionMap: !! material.transmissionMap,
			thicknessMap: !! material.thicknessMap,

			combine: material.combine,

			vertexTangents: ( !! material.normalMap && !! geometry.attributes.tangent ),
			vertexColors: material.vertexColors,
			vertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,
			vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmissionMap || !! material.thicknessMap || !! material.specularIntensityMap || !! material.specularColorMap || !! material.sheenColorMap || !! material.sheenRoughnessMap,
			uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || material.transmission > 0 || !! material.transmissionMap || !! material.thicknessMap || !! material.specularIntensityMap || !! material.specularColorMap || material.sheen > 0 || !! material.sheenColorMap || !! material.sheenRoughnessMap ) && !! material.displacementMap,

			fog: !! fog,
			useFog: material.fog,
			fogExp2: ( fog && fog.isFogExp2 ),

			flatShading: !! material.flatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			skinning: object.isSkinnedMesh === true && maxBones > 0,
			maxBones: maxBones,
			useVertexTexture: floatVertexTextures,

			morphTargets: geometry.morphAttributes.position !== undefined,
			morphNormals: geometry.morphAttributes.normal !== undefined,
			morphColors: geometry.morphAttributes.color !== undefined,
			morphTargetsCount: morphTargetsCount,
			morphTextureStride: morphTextureStride,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,

			numClippingPlanes: clipping.numPlanes,
			numClipIntersection: clipping.numIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

			index0AttributeName: material.index0AttributeName,

			extensionDerivatives: material.extensions && material.extensions.derivatives,
			extensionFragDepth: material.extensions && material.extensions.fragDepth,
			extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
			extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

			rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
			rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
			rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

			customProgramCacheKey: material.customProgramCacheKey()

		};

		return parameters;

	}

	function getProgramCacheKey( parameters ) {

		const array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( parameters.customVertexShaderID );
			array.push( parameters.customFragmentShaderID );

		}

		if ( parameters.defines !== undefined ) {

			for ( const name in parameters.defines ) {

				array.push( name );
				array.push( parameters.defines[ name ] );

			}

		}

		if ( parameters.isRawShaderMaterial === false ) {

			getProgramCacheKeyParameters( array, parameters );
			getProgramCacheKeyBooleans( array, parameters );
			array.push( renderer.outputEncoding );

		}

		array.push( parameters.customProgramCacheKey );

		return array.join();

	}

	function getProgramCacheKeyParameters( array, parameters ) {

		array.push( parameters.precision );
		array.push( parameters.outputEncoding );
		array.push( parameters.envMapMode );
		array.push( parameters.envMapCubeUVHeight );
		array.push( parameters.combine );
		array.push( parameters.vertexUvs );
		array.push( parameters.fogExp2 );
		array.push( parameters.sizeAttenuation );
		array.push( parameters.maxBones );
		array.push( parameters.morphTargetsCount );
		array.push( parameters.morphAttributeCount );
		array.push( parameters.numDirLights );
		array.push( parameters.numPointLights );
		array.push( parameters.numSpotLights );
		array.push( parameters.numHemiLights );
		array.push( parameters.numRectAreaLights );
		array.push( parameters.numDirLightShadows );
		array.push( parameters.numPointLightShadows );
		array.push( parameters.numSpotLightShadows );
		array.push( parameters.shadowMapType );
		array.push( parameters.toneMapping );
		array.push( parameters.numClippingPlanes );
		array.push( parameters.numClipIntersection );

	}

	function getProgramCacheKeyBooleans( array, parameters ) {

		_programLayers.disableAll();

		if ( parameters.isWebGL2 )
			_programLayers.enable( 0 );
		if ( parameters.supportsVertexTextures )
			_programLayers.enable( 1 );
		if ( parameters.instancing )
			_programLayers.enable( 2 );
		if ( parameters.instancingColor )
			_programLayers.enable( 3 );
		if ( parameters.map )
			_programLayers.enable( 4 );
		if ( parameters.matcap )
			_programLayers.enable( 5 );
		if ( parameters.envMap )
			_programLayers.enable( 6 );
		if ( parameters.lightMap )
			_programLayers.enable( 7 );
		if ( parameters.aoMap )
			_programLayers.enable( 8 );
		if ( parameters.emissiveMap )
			_programLayers.enable( 9 );
		if ( parameters.bumpMap )
			_programLayers.enable( 10 );
		if ( parameters.normalMap )
			_programLayers.enable( 11 );
		if ( parameters.objectSpaceNormalMap )
			_programLayers.enable( 12 );
		if ( parameters.tangentSpaceNormalMap )
			_programLayers.enable( 13 );
		if ( parameters.clearcoat )
			_programLayers.enable( 14 );
		if ( parameters.clearcoatMap )
			_programLayers.enable( 15 );
		if ( parameters.clearcoatRoughnessMap )
			_programLayers.enable( 16 );
		if ( parameters.clearcoatNormalMap )
			_programLayers.enable( 17 );
		if ( parameters.displacementMap )
			_programLayers.enable( 18 );
		if ( parameters.specularMap )
			_programLayers.enable( 19 );
		if ( parameters.roughnessMap )
			_programLayers.enable( 20 );
		if ( parameters.metalnessMap )
			_programLayers.enable( 21 );
		if ( parameters.gradientMap )
			_programLayers.enable( 22 );
		if ( parameters.alphaMap )
			_programLayers.enable( 23 );
		if ( parameters.alphaTest )
			_programLayers.enable( 24 );
		if ( parameters.vertexColors )
			_programLayers.enable( 25 );
		if ( parameters.vertexAlphas )
			_programLayers.enable( 26 );
		if ( parameters.vertexUvs )
			_programLayers.enable( 27 );
		if ( parameters.vertexTangents )
			_programLayers.enable( 28 );
		if ( parameters.uvsVertexOnly )
			_programLayers.enable( 29 );
		if ( parameters.fog )
			_programLayers.enable( 30 );

		array.push( _programLayers.mask );
		_programLayers.disableAll();

		if ( parameters.useFog )
			_programLayers.enable( 0 );
		if ( parameters.flatShading )
			_programLayers.enable( 1 );
		if ( parameters.logarithmicDepthBuffer )
			_programLayers.enable( 2 );
		if ( parameters.skinning )
			_programLayers.enable( 3 );
		if ( parameters.useVertexTexture )
			_programLayers.enable( 4 );
		if ( parameters.morphTargets )
			_programLayers.enable( 5 );
		if ( parameters.morphNormals )
			_programLayers.enable( 6 );
		if ( parameters.morphColors )
			_programLayers.enable( 7 );
		if ( parameters.premultipliedAlpha )
			_programLayers.enable( 8 );
		if ( parameters.shadowMapEnabled )
			_programLayers.enable( 9 );
		if ( parameters.physicallyCorrectLights )
			_programLayers.enable( 10 );
		if ( parameters.doubleSided )
			_programLayers.enable( 11 );
		if ( parameters.flipSided )
			_programLayers.enable( 12 );
		if ( parameters.depthPacking )
			_programLayers.enable( 13 );
		if ( parameters.dithering )
			_programLayers.enable( 14 );
		if ( parameters.specularIntensityMap )
			_programLayers.enable( 15 );
		if ( parameters.specularColorMap )
			_programLayers.enable( 16 );
		if ( parameters.transmission )
			_programLayers.enable( 17 );
		if ( parameters.transmissionMap )
			_programLayers.enable( 18 );
		if ( parameters.thicknessMap )
			_programLayers.enable( 19 );
		if ( parameters.sheen )
			_programLayers.enable( 20 );
		if ( parameters.sheenColorMap )
			_programLayers.enable( 21 );
		if ( parameters.sheenRoughnessMap )
			_programLayers.enable( 22 );
		if ( parameters.decodeVideoTexture )
			_programLayers.enable( 23 );
		if ( parameters.opaque )
			_programLayers.enable( 24 );

		array.push( _programLayers.mask );

	}

	function getUniforms( material ) {

		const shaderID = shaderIDs[ material.type ];
		let uniforms;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];
			uniforms = UniformsUtils.clone( shader.uniforms );

		} else {

			uniforms = material.uniforms;

		}

		return uniforms;

	}

	function acquireProgram( parameters, cacheKey ) {

		let program;

		// Check if code has been already compiled
		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

			const preexistingProgram = programs[ p ];

			if ( preexistingProgram.cacheKey === cacheKey ) {

				program = preexistingProgram;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
			programs.push( program );

		}

		return program;

	}

	function releaseProgram( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			const i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	}

	function releaseShaderCache( material ) {

		_customShaders.remove( material );

	}

	function dispose() {

		_customShaders.dispose();

	}

	return {
		getParameters: getParameters,
		getProgramCacheKey: getProgramCacheKey,
		getUniforms: getUniforms,
		acquireProgram: acquireProgram,
		releaseProgram: releaseProgram,
		releaseShaderCache: releaseShaderCache,
		// Exposed for resource monitoring & error feedback via renderer.info:
		programs: programs,
		dispose: dispose
	};

}

function WebGLProperties() {

	let properties = new WeakMap();

	function get( object ) {

		let map = properties.get( object );

		if ( map === undefined ) {

			map = {};
			properties.set( object, map );

		}

		return map;

	}

	function remove( object ) {

		properties.delete( object );

	}

	function update( object, key, value ) {

		properties.get( object )[ key ] = value;

	}

	function dispose() {

		properties = new WeakMap();

	}

	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};

}

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}


function WebGLRenderList() {

	const renderItems = [];
	let renderItemsIndex = 0;

	const opaque = [];
	const transmissive = [];
	const transparent = [];

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transmissive.length = 0;
		transparent.length = 0;

	}

	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		let renderItem = renderItems[ renderItemsIndex ];

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[ renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		}

		renderItemsIndex ++;

		return renderItem;

	}

	function push( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		if ( material.transmission > 0.0 ) {

			transmissive.push( renderItem );

		} else if ( material.transparent === true ) {

			transparent.push( renderItem );

		} else {

			opaque.push( renderItem );

		}

	}

	function unshift( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		if ( material.transmission > 0.0 ) {

			transmissive.unshift( renderItem );

		} else if ( material.transparent === true ) {

			transparent.unshift( renderItem );

		} else {

			opaque.unshift( renderItem );

		}

	}

	function sort( customOpaqueSort, customTransparentSort ) {

		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
		if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	function finish() {

		// Clear references from inactive renderItems in the list

		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			const renderItem = renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.group = null;

		}

	}

	return {

		opaque: opaque,
		transmissive: transmissive,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,
		finish: finish,

		sort: sort
	};

}

function WebGLRenderLists() {

	let lists = new WeakMap();

	function get( scene, renderCallDepth ) {

		let list;

		if ( lists.has( scene ) === false ) {

			list = new WebGLRenderList();
			lists.set( scene, [ list ] );

		} else {

			if ( renderCallDepth >= lists.get( scene ).length ) {

				list = new WebGLRenderList();
				lists.get( scene ).push( list );

			} else {

				list = lists.get( scene )[ renderCallDepth ];

			}

		}

		return list;

	}

	function dispose() {

		lists = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

function UniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

function ShadowUniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}



let nextVersion = 0;

function shadowCastingLightsFirst( lightA, lightB ) {

	return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

}

function WebGLLights( extensions, capabilities ) {

	const cache = new UniformsCache();

	const shadowCache = ShadowUniformsCache();

	const state = {

		version: 0,

		hash: {
			directionalLength: - 1,
			pointLength: - 1,
			spotLength: - 1,
			rectAreaLength: - 1,
			hemiLength: - 1,

			numDirectionalShadows: - 1,
			numPointShadows: - 1,
			numSpotShadows: - 1
		},

		ambient: [ 0, 0, 0 ],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadow: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		rectArea: [],
		rectAreaLTC1: null,
		rectAreaLTC2: null,
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: []

	};

	for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

	const vector3 = new Vector3();
	const matrix4 = new Matrix4();
	const matrix42 = new Matrix4();

	function setup( lights, physicallyCorrectLights ) {

		let r = 0, g = 0, b = 0;

		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		let numDirectionalShadows = 0;
		let numPointShadows = 0;
		let numSpotShadows = 0;

		lights.sort( shadowCastingLightsFirst );

		// artist-friendly light intensity scaling factor
		const scaleFactor = ( physicallyCorrectLights !== true ) ? Math.PI : 1;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			const color = light.color;
			const intensity = light.intensity;
			const distance = light.distance;

			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity * scaleFactor;
				g += color.g * intensity * scaleFactor;
				b += color.b * intensity * scaleFactor;

			} else if ( light.isLightProbe ) {

				for ( let j = 0; j < 9; j ++ ) {

					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				}

			} else if ( light.isDirectionalLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.directionalShadow[ directionalLength ] = shadowUniforms;
					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					numDirectionalShadows ++;

				}

				state.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );

				uniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );
				uniforms.distance = distance;

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.spotShadow[ spotLength ] = shadowUniforms;
					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

					numSpotShadows ++;

				}

				state.spot[ spotLength ] = uniforms;

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = cache.get( light );

				// (a) intensity is the total visible light emitted
				//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

				// (b) intensity is the brightness of the light
				uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				state.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;

					state.pointShadow[ pointLength ] = shadowUniforms;
					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					numPointShadows ++;

				}

				state.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = cache.get( light );

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );

				state.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		if ( rectAreaLength > 0 ) {

			if ( capabilities.isWebGL2 ) {

				// WebGL 2

				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

			} else {

				// WebGL 1

				if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
					state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

				} else {

					console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

				}

			}

		}

		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;

		const hash = state.hash;

		if ( hash.directionalLength !== directionalLength ||
			hash.pointLength !== pointLength ||
			hash.spotLength !== spotLength ||
			hash.rectAreaLength !== rectAreaLength ||
			hash.hemiLength !== hemiLength ||
			hash.numDirectionalShadows !== numDirectionalShadows ||
			hash.numPointShadows !== numPointShadows ||
			hash.numSpotShadows !== numSpotShadows ) {

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotShadowMatrix.length = numSpotShadows;

			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;

			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;

			state.version = nextVersion ++;

		}

	}

	function setupView( lights, camera ) {

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		const viewMatrix = camera.matrixWorldInverse;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			if ( light.isDirectionalLight ) {

				const uniforms = state.directional[ directionalLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = state.spot[ spotLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = state.rectArea[ rectAreaLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = state.point[ pointLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = state.hemi[ hemiLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();

				hemiLength ++;

			}

		}

	}

	return {
		setup: setup,
		setupView: setupView,
		state: state
	};

}

function WebGLRenderState( extensions, capabilities ) {

	const lights = new WebGLLights( extensions, capabilities );

	const lightsArray = [];
	const shadowsArray = [];

	function init() {

		lightsArray.length = 0;
		shadowsArray.length = 0;

	}

	function pushLight( light ) {

		lightsArray.push( light );

	}

	function pushShadow( shadowLight ) {

		shadowsArray.push( shadowLight );

	}

	function setupLights( physicallyCorrectLights ) {

		lights.setup( lightsArray, physicallyCorrectLights );

	}

	function setupLightsView( camera ) {

		lights.setupView( lightsArray, camera );

	}

	const state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		lights: lights
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,
		setupLightsView: setupLightsView,

		pushLight: pushLight,
		pushShadow: pushShadow
	};

}

function WebGLRenderStates( extensions, capabilities ) {

	let renderStates = new WeakMap();

	function get( scene, renderCallDepth = 0 ) {

		let renderState;

		if ( renderStates.has( scene ) === false ) {

			renderState = new WebGLRenderState( extensions, capabilities );
			renderStates.set( scene, [ renderState ] );

		} else {

			if ( renderCallDepth >= renderStates.get( scene ).length ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStates.get( scene ).push( renderState );

			} else {

				renderState = renderStates.get( scene )[ renderCallDepth ];

			}

		}

		return renderState;

	}

	function dispose() {

		renderStates = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

class MeshDepthMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.depthPacking = source.depthPacking;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	}

}

MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

class MeshDistanceMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.fog = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	}

}

MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

function WebGLShadowMap( _renderer, _objects, _capabilities ) {

	let _frustum = new Frustum();

	const _shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),

		_viewport = new Vector4(),

		_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
		_distanceMaterial = new MeshDistanceMaterial(),

		_materialCache = {},

		_maxTextureSize = _capabilities.maxTextureSize;

	const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

	const shadowMaterialVertical = new ShaderMaterial( {
		defines: {
			VSM_SAMPLES: 8
		},
		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new Vector2() },
			radius: { value: 4.0 }
		},

		vertexShader: vertex,
		fragmentShader: fragment

	} );

	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

	const fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute(
		'position',
		new BufferAttribute(
			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
			3
		)
	);

	const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

	const scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;

	this.render = function ( lights, scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( lights.length === 0 ) return;

		const currentRenderTarget = _renderer.getRenderTarget();
		const activeCubeFace = _renderer.getActiveCubeFace();
		const activeMipmapLevel = _renderer.getActiveMipmapLevel();

		const _state = _renderer.state;

		// Set GL state for depth map.
		_state.setBlending( NoBlending );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// render depth map

		for ( let i = 0, il = lights.length; i < il; i ++ ) {

			const light = lights[ i ];
			const shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

			_shadowMapSize.copy( shadow.mapSize );

			const shadowFrameExtents = shadow.getFrameExtents();

			_shadowMapSize.multiply( shadowFrameExtents );

			_viewportSize.copy( shadow.mapSize );

			if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

				if ( _shadowMapSize.x > _maxTextureSize ) {

					_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;

				}

				if ( _shadowMapSize.y > _maxTextureSize ) {

					_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;

				}

			}

			if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );

				shadow.camera.updateProjectionMatrix();

			}

			if ( shadow.map === null ) {

				const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.camera.updateProjectionMatrix();

			}

			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();

			const viewportCount = shadow.getViewportCount();

			for ( let vp = 0; vp < viewportCount; vp ++ ) {

				const viewport = shadow.getViewport( vp );

				_viewport.set(
					_viewportSize.x * viewport.x,
					_viewportSize.y * viewport.y,
					_viewportSize.x * viewport.z,
					_viewportSize.y * viewport.w
				);

				_state.viewport( _viewport );

				shadow.updateMatrices( light, vp );

				_frustum = shadow.getFrustum();

				renderObject( scene, camera, shadow.camera, light, this.type );

			}

			// do blur pass for VSM

			if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				VSMPass( shadow, camera );

			}

			shadow.needsUpdate = false;

		}

		scope.needsUpdate = false;

		_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	};

	function VSMPass( shadow, camera ) {

		const geometry = _objects.update( fullScreenMesh );

		if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

			shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
			shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

			shadowMaterialVertical.needsUpdate = true;
			shadowMaterialHorizontal.needsUpdate = true;

		}

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.mapPass );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		// horizontal pass

		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.map );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

	}

	function getDepthMaterial( object, material, light, shadowCameraNear, shadowCameraFar, type ) {

		let result = null;

		const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

		if ( customMaterial !== undefined ) {

			result = customMaterial;

		} else {

			result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

		}

		if ( ( _renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 ) ||
			( material.displacementMap && material.displacementScale !== 0 ) ||
			( material.alphaMap && material.alphaTest > 0 ) ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			const keyA = result.uuid, keyB = material.uuid;

			let materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			let cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		if ( type === VSMShadowMap ) {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		} else {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		}

		result.alphaMap = material.alphaMap;
		result.alphaTest = material.alphaTest;

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.displacementMap = material.displacementMap;
		result.displacementScale = material.displacementScale;
		result.displacementBias = material.displacementBias;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			result.referencePosition.setFromMatrixPosition( light.matrixWorld );
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, light, type ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				const geometry = _objects.update( object );
				const material = object.material;

				if ( Array.isArray( material ) ) {

					const groups = geometry.groups;

					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

						const group = groups[ k ];
						const groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							const depthMaterial = getDepthMaterial( object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

						}

					}

				} else if ( material.visible ) {

					const depthMaterial = getDepthMaterial( object, material, light, shadowCamera.near, shadowCamera.far, type );

					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, light, type );

		}

	}

}

function WebGLState( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function ColorBuffer() {

		let locked = false;

		const color = new Vector4();
		let currentColorMask = null;
		const currentColorClear = new Vector4( 0, 0, 0, 0 );

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			}

		};

	}

	function DepthBuffer() {

		let locked = false;

		let currentDepthMask = null;
		let currentDepthFunc = null;
		let currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( 2929 );

				} else {

					disable( 2929 );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					if ( depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( 512 );
								break;

							case AlwaysDepth:

								gl.depthFunc( 519 );
								break;

							case LessDepth:

								gl.depthFunc( 513 );
								break;

							case LessEqualDepth:

								gl.depthFunc( 515 );
								break;

							case EqualDepth:

								gl.depthFunc( 514 );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( 518 );
								break;

							case GreaterDepth:

								gl.depthFunc( 516 );
								break;

							case NotEqualDepth:

								gl.depthFunc( 517 );
								break;

							default:

								gl.depthFunc( 515 );

						}

					} else {

						gl.depthFunc( 515 );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		let locked = false;

		let currentStencilMask = null;
		let currentStencilFunc = null;
		let currentStencilRef = null;
		let currentStencilFuncMask = null;
		let currentStencilFail = null;
		let currentStencilZFail = null;
		let currentStencilZPass = null;
		let currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( ! locked ) {

					if ( stencilTest ) {

						enable( 2960 );

					} else {

						disable( 2960 );

					}

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef !== stencilRef ||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail !== stencilFail ||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	const colorBuffer = new ColorBuffer();
	const depthBuffer = new DepthBuffer();
	const stencilBuffer = new StencilBuffer();

	let enabledCapabilities = {};

	let currentBoundFramebuffers = {};
	let currentDrawbuffers = new WeakMap();
	let defaultDrawbuffers = [];

	let currentProgram = null;

	let currentBlendingEnabled = false;
	let currentBlending = null;
	let currentBlendEquation = null;
	let currentBlendSrc = null;
	let currentBlendDst = null;
	let currentBlendEquationAlpha = null;
	let currentBlendSrcAlpha = null;
	let currentBlendDstAlpha = null;
	let currentPremultipledAlpha = false;

	let currentFlipSided = null;
	let currentCullFace = null;

	let currentLineWidth = null;

	let currentPolygonOffsetFactor = null;
	let currentPolygonOffsetUnits = null;

	const maxTextures = gl.getParameter( 35661 );

	let lineWidthAvailable = false;
	let version = 0;
	const glVersion = gl.getParameter( 7938 );

	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 1.0 );

	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 2.0 );

	}

	let currentTextureSlot = null;
	let currentBoundTextures = {};

	const scissorParam = gl.getParameter( 3088 );
	const viewportParam = gl.getParameter( 2978 );

	const currentScissor = new Vector4().fromArray( scissorParam );
	const currentViewport = new Vector4().fromArray( viewportParam );

	function createTexture( type, target, count ) {

		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		const texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, 10241, 9728 );
		gl.texParameteri( type, 10240, 9728 );

		for ( let i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

		}

		return texture;

	}

	const emptyTextures = {};
	emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
	emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

	// init

	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );

	enable( 2929 );
	depthBuffer.setFunc( LessEqualDepth );

	setFlipSided( false );
	setCullFace( CullFaceBack );
	enable( 2884 );

	setBlending( NoBlending );

	//

	function enable( id ) {

		if ( enabledCapabilities[ id ] !== true ) {

			gl.enable( id );
			enabledCapabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( enabledCapabilities[ id ] !== false ) {

			gl.disable( id );
			enabledCapabilities[ id ] = false;

		}

	}

	function bindFramebuffer( target, framebuffer ) {

		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

			gl.bindFramebuffer( target, framebuffer );

			currentBoundFramebuffers[ target ] = framebuffer;

			if ( isWebGL2 ) {

				// 36009 is equivalent to 36160

				if ( target === 36009 ) {

					currentBoundFramebuffers[ 36160 ] = framebuffer;

				}

				if ( target === 36160 ) {

					currentBoundFramebuffers[ 36009 ] = framebuffer;

				}

			}

			return true;

		}

		return false;

	}

	function drawBuffers( renderTarget, framebuffer ) {

		let drawBuffers = defaultDrawbuffers;

		let needsUpdate = false;

		if ( renderTarget ) {

			drawBuffers = currentDrawbuffers.get( framebuffer );

			if ( drawBuffers === undefined ) {

				drawBuffers = [];
				currentDrawbuffers.set( framebuffer, drawBuffers );

			}

			if ( renderTarget.isWebGLMultipleRenderTargets ) {

				const textures = renderTarget.texture;

				if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== 36064 ) {

					for ( let i = 0, il = textures.length; i < il; i ++ ) {

						drawBuffers[ i ] = 36064 + i;

					}

					drawBuffers.length = textures.length;

					needsUpdate = true;

				}

			} else {

				if ( drawBuffers[ 0 ] !== 36064 ) {

					drawBuffers[ 0 ] = 36064;

					needsUpdate = true;

				}

			}

		} else {

			if ( drawBuffers[ 0 ] !== 1029 ) {

				drawBuffers[ 0 ] = 1029;

				needsUpdate = true;

			}

		}

		if ( needsUpdate ) {

			if ( capabilities.isWebGL2 ) {

				gl.drawBuffers( drawBuffers );

			} else {

				extensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( drawBuffers );

			}

		}


	}

	function useProgram( program ) {

		if ( currentProgram !== program ) {

			gl.useProgram( program );

			currentProgram = program;

			return true;

		}

		return false;

	}

	const equationToGL = {
		[ AddEquation ]: 32774,
		[ SubtractEquation ]: 32778,
		[ ReverseSubtractEquation ]: 32779
	};

	if ( isWebGL2 ) {

		equationToGL[ MinEquation ] = 32775;
		equationToGL[ MaxEquation ] = 32776;

	} else {

		const extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			equationToGL[ MinEquation ] = extension.MIN_EXT;
			equationToGL[ MaxEquation ] = extension.MAX_EXT;

		}

	}

	const factorToGL = {
		[ ZeroFactor ]: 0,
		[ OneFactor ]: 1,
		[ SrcColorFactor ]: 768,
		[ SrcAlphaFactor ]: 770,
		[ SrcAlphaSaturateFactor ]: 776,
		[ DstColorFactor ]: 774,
		[ DstAlphaFactor ]: 772,
		[ OneMinusSrcColorFactor ]: 769,
		[ OneMinusSrcAlphaFactor ]: 771,
		[ OneMinusDstColorFactor ]: 775,
		[ OneMinusDstAlphaFactor ]: 773
	};

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending === NoBlending ) {

			if ( currentBlendingEnabled === true ) {

				disable( 3042 );
				currentBlendingEnabled = false;

			}

			return;

		}

		if ( currentBlendingEnabled === false ) {

			enable( 3042 );
			currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( 32774 );

					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 1, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 1, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( 0, 769, 0, 1 );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( 0, 768, 0, 770 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 770, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 770, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( 0, 769, 0, 1 );
							break;

						case MultiplyBlending:
							gl.blendFunc( 0, 768 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;

		}

		currentBlending = blending;
		currentPremultipledAlpha = null;

	}

	function setMaterial( material, frontFaceCW ) {

		material.side === DoubleSide
			? disable( 2884 )
			: enable( 2884 );

		let flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? setBlending( NoBlending )
			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		const stencilWrite = material.stencilWrite;
		stencilBuffer.setTest( stencilWrite );
		if ( stencilWrite ) {

			stencilBuffer.setMask( material.stencilWriteMask );
			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		material.alphaToCoverage === true
			? enable( 32926 )
			: disable( 32926 );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( 2304 );

			} else {

				gl.frontFace( 2305 );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( 2884 );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( 1029 );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( 1028 );

				} else {

					gl.cullFace( 1032 );

				}

			}

		} else {

			disable( 2884 );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( 32823 );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( 32823 );

		}

	}

	function setScissorTest( scissorTest ) {

		if ( scissorTest ) {

			enable( 3089 );

		} else {

			disable( 3089 );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture ) {

		if ( currentTextureSlot === null ) {

			activeTexture();

		}

		let boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function unbindTexture() {

		const boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texSubImage2D() {

		try {

			gl.texSubImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texSubImage3D() {

		try {

			gl.texSubImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function compressedTexSubImage2D() {

		try {

			gl.compressedTexSubImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texStorage2D() {

		try {

			gl.texStorage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texStorage3D() {

		try {

			gl.texStorage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage3D() {

		try {

			gl.texImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	//

	function reset() {

		// reset state

		gl.disable( 3042 );
		gl.disable( 2884 );
		gl.disable( 2929 );
		gl.disable( 32823 );
		gl.disable( 3089 );
		gl.disable( 2960 );
		gl.disable( 32926 );

		gl.blendEquation( 32774 );
		gl.blendFunc( 1, 0 );
		gl.blendFuncSeparate( 1, 0, 1, 0 );

		gl.colorMask( true, true, true, true );
		gl.clearColor( 0, 0, 0, 0 );

		gl.depthMask( true );
		gl.depthFunc( 513 );
		gl.clearDepth( 1 );

		gl.stencilMask( 0xffffffff );
		gl.stencilFunc( 519, 0, 0xffffffff );
		gl.stencilOp( 7680, 7680, 7680 );
		gl.clearStencil( 0 );

		gl.cullFace( 1029 );
		gl.frontFace( 2305 );

		gl.polygonOffset( 0, 0 );

		gl.activeTexture( 33984 );

		gl.bindFramebuffer( 36160, null );

		if ( isWebGL2 === true ) {

			gl.bindFramebuffer( 36009, null );
			gl.bindFramebuffer( 36008, null );

		}

		gl.useProgram( null );

		gl.lineWidth( 1 );

		gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
		gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

		// reset internals

		enabledCapabilities = {};

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentBoundFramebuffers = {};
		currentDrawbuffers = new WeakMap();
		defaultDrawbuffers = [];

		currentProgram = null;

		currentBlendingEnabled = false;
		currentBlending = null;
		currentBlendEquation = null;
		currentBlendSrc = null;
		currentBlendDst = null;
		currentBlendEquationAlpha = null;
		currentBlendSrcAlpha = null;
		currentBlendDstAlpha = null;
		currentPremultipledAlpha = false;

		currentFlipSided = null;
		currentCullFace = null;

		currentLineWidth = null;

		currentPolygonOffsetFactor = null;
		currentPolygonOffsetUnits = null;

		currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
		currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		enable: enable,
		disable: disable,

		bindFramebuffer: bindFramebuffer,
		drawBuffers: drawBuffers,

		useProgram: useProgram,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,

		texStorage2D: texStorage2D,
		texStorage3D: texStorage3D,
		texSubImage2D: texSubImage2D,
		texSubImage3D: texSubImage3D,
		compressedTexSubImage2D: compressedTexSubImage2D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	const isWebGL2 = capabilities.isWebGL2;
	const maxTextures = capabilities.maxTextures;
	const maxCubemapSize = capabilities.maxCubemapSize;
	const maxTextureSize = capabilities.maxTextureSize;
	const maxSamples = capabilities.maxSamples;
	const multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
	const supportsInvalidateFramebuffer = /OculusBrowser/g.test( navigator.userAgent );

	const _videoTextures = new WeakMap();
	let _canvas;

	const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	let useOffscreenCanvas = false;

	try {

		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			// eslint-disable-next-line compat/compat
			&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

	} catch ( err ) {

		// Ignore any errors

	}

	function createCanvas( width, height ) {

		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
			// eslint-disable-next-line compat/compat
			new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

	}

	function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

		let scale = 1;

		// handle case if texture exceeds max size

		if ( image.width > maxSize || image.height > maxSize ) {

			scale = maxSize / Math.max( image.width, image.height );

		}

		// only perform resize if necessary

		if ( scale < 1 || needsPowerOfTwo === true ) {

			// only perform resize for certain image types

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;

				const width = floor( scale * image.width );
				const height = floor( scale * image.height );

				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				// cube textures can't reuse the same canvas

				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				canvas.width = width;
				canvas.height = height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, width, height );

				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

				return canvas;

			} else {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

				}

				return image;

			}

		}

		return image;

	}

	function isPowerOfTwo$1( image ) {

		return isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( isWebGL2 ) return false;

		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

	}

	function textureNeedsGenerateMipmaps( texture, supportsMips ) {

		return texture.generateMipmaps && supportsMips &&
			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

	}

	function generateMipmap( target ) {

		_gl.generateMipmap( target );

	}

	function getInternalFormat( internalFormatName, glFormat, glType, encoding, isVideoTexture = false ) {

		if ( isWebGL2 === false ) return glFormat;

		if ( internalFormatName !== null ) {

			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		let internalFormat = glFormat;

		if ( glFormat === 6403 ) {

			if ( glType === 5126 ) internalFormat = 33326;
			if ( glType === 5131 ) internalFormat = 33325;
			if ( glType === 5121 ) internalFormat = 33321;

		}

		if ( glFormat === 33319 ) {

			if ( glType === 5126 ) internalFormat = 33328;
			if ( glType === 5131 ) internalFormat = 33327;
			if ( glType === 5121 ) internalFormat = 33323;

		}

		if ( glFormat === 6408 ) {

			if ( glType === 5126 ) internalFormat = 34836;
			if ( glType === 5131 ) internalFormat = 34842;
			if ( glType === 5121 ) internalFormat = ( encoding === sRGBEncoding && isVideoTexture === false ) ? 35907 : 32856;
			if ( glType === 32819 ) internalFormat = 32854;
			if ( glType === 32820 ) internalFormat = 32855;

		}

		if ( internalFormat === 33325 || internalFormat === 33326 ||
			internalFormat === 33327 || internalFormat === 33328 ||
			internalFormat === 34842 || internalFormat === 34836 ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	function getMipLevels( texture, image, supportsMips ) {

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {

			return Math.log2( Math.max( image.width, image.height ) ) + 1;

		} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {

			// user-defined mipmaps

			return texture.mipmaps.length;

		} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {

			return image.mipmaps.length;

		} else {

			// texture without mipmaps (only base level)

			return 1;

		}

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback( f ) {

		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

			return 9728;

		}

		return 9729;

	}

	//

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		if ( texture.isVideoTexture ) {

			_videoTextures.delete( texture );

		}

	}

	function onRenderTargetDispose( event ) {

		const renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

	}

	//

	function deallocateTexture( texture ) {

		const textureProperties = properties.get( texture );

		if ( textureProperties.__webglInit === undefined ) return;

		// check if it's necessary to remove the WebGLTexture object

		const source = texture.source;
		const webglTextures = _sources.get( source );

		if ( webglTextures ) {

			const webglTexture = webglTextures[ textureProperties.__cacheKey ];
			webglTexture.usedTimes --;

			// the WebGLTexture object is not used anymore, remove it

			if ( webglTexture.usedTimes === 0 ) {

				deleteTexture( texture );

			}

			// remove the weak map entry if no WebGLTexture uses the source anymore

			if ( Object.keys( webglTextures ).length === 0 ) {

				_sources.delete( source );

			}

		}

		properties.remove( texture );

	}

	function deleteTexture( texture ) {

		const textureProperties = properties.get( texture );
		_gl.deleteTexture( textureProperties.__webglTexture );

		const source = texture.source;
		const webglTextures = _sources.get( source );
		delete webglTextures[ textureProperties.__cacheKey ];

		info.memory.textures --;

	}

	function deallocateRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

			info.memory.textures --;

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLCubeRenderTarget ) {

			for ( let i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
			if ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );
			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		}

		if ( renderTarget.isWebGLMultipleRenderTargets ) {

			for ( let i = 0, il = texture.length; i < il; i ++ ) {

				const attachmentProperties = properties.get( texture[ i ] );

				if ( attachmentProperties.__webglTexture ) {

					_gl.deleteTexture( attachmentProperties.__webglTexture );

					info.memory.textures --;

				}

				properties.remove( texture[ i ] );

			}

		}

		properties.remove( texture );
		properties.remove( renderTarget );

	}

	//

	let textureUnits = 0;

	function resetTextureUnits() {

		textureUnits = 0;

	}

	function allocateTextureUnit() {

		const textureUnit = textureUnits;

		if ( textureUnit >= maxTextures ) {

			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

		}

		textureUnits += 1;

		return textureUnit;

	}

	function getTextureCacheKey( texture ) {

		const array = [];

		array.push( texture.wrapS );
		array.push( texture.wrapT );
		array.push( texture.magFilter );
		array.push( texture.minFilter );
		array.push( texture.anisotropy );
		array.push( texture.internalFormat );
		array.push( texture.format );
		array.push( texture.type );
		array.push( texture.generateMipmaps );
		array.push( texture.premultiplyAlpha );
		array.push( texture.flipY );
		array.push( texture.unpackAlignment );
		array.push( texture.encoding );

		return array.join();

	}

	//

	function setTexture2D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.isVideoTexture ) updateVideoTexture( texture );

		if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

			const image = texture.image;

			if ( image === null ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 3553, textureProperties.__webglTexture );

	}

	function setTexture2DArray( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 35866, textureProperties.__webglTexture );

	}

	function setTexture3D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 32879, textureProperties.__webglTexture );

	}

	function setTextureCube( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadCubeTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 34067, textureProperties.__webglTexture );

	}

	const wrappingToGL = {
		[ RepeatWrapping ]: 10497,
		[ ClampToEdgeWrapping ]: 33071,
		[ MirroredRepeatWrapping ]: 33648
	};

	const filterToGL = {
		[ NearestFilter ]: 9728,
		[ NearestMipmapNearestFilter ]: 9984,
		[ NearestMipmapLinearFilter ]: 9986,

		[ LinearFilter ]: 9729,
		[ LinearMipmapNearestFilter ]: 9985,
		[ LinearMipmapLinearFilter ]: 9987
	};

	function setTextureParameters( textureType, texture, supportsMips ) {

		if ( supportsMips ) {

			_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
			_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

			}

			_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
			_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

		} else {

			_gl.texParameteri( textureType, 10242, 33071 );
			_gl.texParameteri( textureType, 10243, 33071 );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, 33071 );

			}

			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

			}

			_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

			}

		}

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
			if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function initTexture( textureProperties, texture ) {

		let forceUpload = false;

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

		}

		// create Source <-> WebGLTextures mapping if necessary

		const source = texture.source;
		let webglTextures = _sources.get( source );

		if ( webglTextures === undefined ) {

			webglTextures = {};
			_sources.set( source, webglTextures );

		}

		// check if there is already a WebGLTexture object for the given texture parameters

		const textureCacheKey = getTextureCacheKey( texture );

		if ( textureCacheKey !== textureProperties.__cacheKey ) {

			// if not, create a new instance of WebGLTexture

			if ( webglTextures[ textureCacheKey ] === undefined ) {

				// create new entry

				webglTextures[ textureCacheKey ] = {
					texture: _gl.createTexture(),
					usedTimes: 0
				};

				info.memory.textures ++;

				// when a new instance of WebGLTexture was created, a texture upload is required
				// even if the image contents are identical

				forceUpload = true;

			}

			webglTextures[ textureCacheKey ].usedTimes ++;

			// every time the texture cache key changes, it's necessary to check if an instance of
			// WebGLTexture can be deleted in order to avoid a memory leak.

			const webglTexture = webglTextures[ textureProperties.__cacheKey ];

			if ( webglTexture !== undefined ) {

				webglTextures[ textureProperties.__cacheKey ].usedTimes --;

				if ( webglTexture.usedTimes === 0 ) {

					deleteTexture( texture );

				}

			}

			// store references to cache key and WebGLTexture object

			textureProperties.__cacheKey = textureCacheKey;
			textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;

		}

		return forceUpload;

	}

	function uploadTexture( textureProperties, texture, slot ) {

		let textureType = 3553;

		if ( texture.isDataArrayTexture ) textureType = 35866;
		if ( texture.isData3DTexture ) textureType = 32879;

		const forceUpload = initTexture( textureProperties, texture );
		const source = texture.source;

		state.activeTexture( 33984 + slot );
		state.bindTexture( textureType, textureProperties.__webglTexture );

		if ( source.version !== source.__currentVersion || forceUpload === true ) {

			_gl.pixelStorei( 37440, texture.flipY );
			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
			_gl.pixelStorei( 3317, texture.unpackAlignment );
			_gl.pixelStorei( 37443, 0 );

			const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;
			let image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );
			image = verifyColorSpace( texture, image );

			const supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
				glFormat = utils.convert( texture.format, texture.encoding );

			let glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture );

			setTextureParameters( textureType, texture, supportsMips );

			let mipmap;
			const mipmaps = texture.mipmaps;

			const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
			const allocateMemory = ( textureProperties.__version === undefined );
			const levels = getMipLevels( texture, image, supportsMips );

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				glInternalFormat = 6402;

				if ( isWebGL2 ) {

					if ( texture.type === FloatType ) {

						glInternalFormat = 36012;

					} else if ( texture.type === UnsignedIntType ) {

						glInternalFormat = 33190;

					} else if ( texture.type === UnsignedInt248Type ) {

						glInternalFormat = 35056;

					} else {

						glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

					}

				} else {

					if ( texture.type === FloatType ) {

						console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

					}

				}

				// validation checks for WebGL 1

				if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

						texture.type = UnsignedShortType;
						glType = utils.convert( texture.type );

					}

				}

				if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = 34041;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedInt248Type ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );

					}

				}

				//

				if ( useTexStorage && allocateMemory ) {

					state.texStorage2D( 3553, 1, glInternalFormat, image.width, image.height );

				} else {

					state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

				}

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( useTexStorage ) {

							state.texSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

						} else {

							state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

					texture.generateMipmaps = false;

				} else {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

						}

						state.texSubImage2D( 3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );

					} else {

						state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

					}

				}

			} else if ( texture.isCompressedTexture ) {

				if ( useTexStorage && allocateMemory ) {

					state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

				}

				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== RGBAFormat ) {

						if ( glFormat !== null ) {

							if ( useTexStorage ) {

								state.compressedTexSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

							} else {

								state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							}

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						if ( useTexStorage ) {

							state.texSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

						} else {

							state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

				}

			} else if ( texture.isDataArrayTexture ) {

				if ( useTexStorage ) {

					if ( allocateMemory ) {

						state.texStorage3D( 35866, levels, glInternalFormat, image.width, image.height, image.depth );

					}

					state.texSubImage3D( 35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

				} else {

					state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

				}

			} else if ( texture.isData3DTexture ) {

				if ( useTexStorage ) {

					if ( allocateMemory ) {

						state.texStorage3D( 32879, levels, glInternalFormat, image.width, image.height, image.depth );

					}

					state.texSubImage3D( 32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

				} else {

					state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

				}

			} else if ( texture.isFramebufferTexture ) {

				if ( useTexStorage && allocateMemory ) {

					state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

				} else {

					state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

				}

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( useTexStorage ) {

							state.texSubImage2D( 3553, i, 0, 0, glFormat, glType, mipmap );

						} else {

							state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

						}

					}

					texture.generateMipmaps = false;

				} else {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

						}

						state.texSubImage2D( 3553, 0, 0, 0, glFormat, glType, image );

					} else {

						state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );

					}

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( textureType );

			}

			source.__currentVersion = source.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		textureProperties.__version = texture.version;

	}

	function uploadCubeTexture( textureProperties, texture, slot ) {

		if ( texture.image.length !== 6 ) return;

		const forceUpload = initTexture( textureProperties, texture );
		const source = texture.source;

		state.activeTexture( 33984 + slot );
		state.bindTexture( 34067, textureProperties.__webglTexture );

		if ( source.version !== source.__currentVersion || forceUpload === true ) {

			_gl.pixelStorei( 37440, texture.flipY );
			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
			_gl.pixelStorei( 3317, texture.unpackAlignment );
			_gl.pixelStorei( 37443, 0 );

			const isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );
			const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

			const cubeImage = [];

			for ( let i = 0; i < 6; i ++ ) {

				if ( ! isCompressed && ! isDataTexture ) {

					cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

				} else {

					cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

				}

				cubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );

			}

			const image = cubeImage[ 0 ],
				supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
				glFormat = utils.convert( texture.format, texture.encoding ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );

			const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
			const allocateMemory = ( textureProperties.__version === undefined );
			let levels = getMipLevels( texture, image, supportsMips );

			setTextureParameters( 34067, texture, supportsMips );

			let mipmaps;

			if ( isCompressed ) {

				if ( useTexStorage && allocateMemory ) {

					state.texStorage2D( 34067, levels, glInternalFormat, image.width, image.height );

				}

				for ( let i = 0; i < 6; i ++ ) {

					mipmaps = cubeImage[ i ].mipmaps;

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									state.compressedTexSubImage2D( 34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

								} else {

									state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								}

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

							}

						} else {

							if ( useTexStorage ) {

								state.texSubImage2D( 34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

							} else {

								state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

			} else {

				mipmaps = texture.mipmaps;

				if ( useTexStorage && allocateMemory ) {

					// TODO: Uniformly handle mipmap definitions
					// Normal textures and compressed cube textures define base level + mips with their mipmap array
					// Uncompressed cube textures use their mipmap array only for mips (no base level)

					if ( mipmaps.length > 0 ) levels ++;

					state.texStorage2D( 34067, levels, glInternalFormat, cubeImage[ 0 ].width, cubeImage[ 0 ].height );

				}

				for ( let i = 0; i < 6; i ++ ) {

					if ( isDataTexture ) {

						if ( useTexStorage ) {

							state.texSubImage2D( 34069 + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );

						} else {

							state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						}

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];
							const mipmapImage = mipmap.image[ i ].image;

							if ( useTexStorage ) {

								state.texSubImage2D( 34069 + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );

							} else {

								state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

							}

						}

					} else {

						if ( useTexStorage ) {

							state.texSubImage2D( 34069 + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );

						} else {

							state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

						}

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];

							if ( useTexStorage ) {

								state.texSubImage2D( 34069 + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );

							} else {

								state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

							}

						}

					}

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				// We assume images for cube map have the same size.
				generateMipmap( 34067 );

			}

			source.__currentVersion = source.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		textureProperties.__version = texture.version;

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget ) {

		const glFormat = utils.convert( texture.format, texture.encoding );
		const glType = utils.convert( texture.type );
		const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
		const renderTargetProperties = properties.get( renderTarget );

		if ( ! renderTargetProperties.__hasExternalTextures ) {

			if ( textureTarget === 32879 || textureTarget === 35866 ) {

				state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

			} else {

				state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

			}

		}

		state.bindFramebuffer( 36160, framebuffer );

		if ( useMultisampledRTT( renderTarget ) ) {

			multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );

		} else {

			_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );

		}

		state.bindFramebuffer( 36160, null );

	}


	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		_gl.bindRenderbuffer( 36161, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			let glInternalFormat = 33189;

			if ( isMultisample || useMultisampledRTT( renderTarget ) ) {

				const depthTexture = renderTarget.depthTexture;

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === FloatType ) {

						glInternalFormat = 36012;

					} else if ( depthTexture.type === UnsignedIntType ) {

						glInternalFormat = 33190;

					}

				}

				const samples = getRenderTargetSamples( renderTarget );

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

			_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			const samples = getRenderTargetSamples( renderTarget );

			if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

				_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

			} else if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, 35056, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

			}


			_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

		} else {

			// Use the first texture for MRT so far
			const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[ 0 ] : renderTarget.texture;

			const glFormat = utils.convert( texture.format, texture.encoding );
			const glType = utils.convert( texture.type );
			const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
			const samples = getRenderTargetSamples( renderTarget );

			if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

		}

		_gl.bindRenderbuffer( 36161, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		state.bindFramebuffer( 36160, framebuffer );

		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		}

		// upload an empty depth texture with framebuffer size
		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;

		}

		setTexture2D( renderTarget.depthTexture, 0 );

		const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
		const samples = getRenderTargetSamples( renderTarget );

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, 36096, 3553, webglDepthTexture, 0, samples );

			} else {

				_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

			}

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, 33306, 3553, webglDepthTexture, 0, samples );

			} else {

				_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

			}

		} else {

			throw new Error( 'Unknown depthTexture format' );

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );
		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		if ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {

			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

				}

			} else {

				state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

			}

		}

		state.bindFramebuffer( 36160, null );

	}

	// rebind framebuffer with external textures
	function rebindTextures( renderTarget, colorTexture, depthTexture ) {

		const renderTargetProperties = properties.get( renderTarget );

		if ( colorTexture !== undefined ) {

			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553 );

		}

		if ( depthTexture !== undefined ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		if ( renderTarget.isWebGLMultipleRenderTargets !== true ) {

			if ( textureProperties.__webglTexture === undefined ) {

				textureProperties.__webglTexture = _gl.createTexture();

			}

			textureProperties.__version = texture.version;
			info.memory.textures ++;

		}

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );
		const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( let i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			if ( isMultipleRenderTargets ) {

				if ( capabilities.drawBuffers ) {

					const textures = renderTarget.texture;

					for ( let i = 0, il = textures.length; i < il; i ++ ) {

						const attachmentProperties = properties.get( textures[ i ] );

						if ( attachmentProperties.__webglTexture === undefined ) {

							attachmentProperties.__webglTexture = _gl.createTexture();

							info.memory.textures ++;

						}

					}

				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.' );

				}

			} else if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

				renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
				renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

				_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );

				const glFormat = utils.convert( texture.format, texture.encoding );
				const glType = utils.convert( texture.type );
				const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
				const samples = getRenderTargetSamples( renderTarget );
				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
				_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
				_gl.bindRenderbuffer( 36161, null );

				if ( renderTarget.depthBuffer ) {

					renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

				}

				state.bindFramebuffer( 36160, null );

			}

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( 34067, textureProperties.__webglTexture );
			setTextureParameters( 34067, texture, supportsMips );

			for ( let i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, 36064, 34069 + i );

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( 34067 );

			}

			state.unbindTexture();

		} else if ( isMultipleRenderTargets ) {

			const textures = renderTarget.texture;

			for ( let i = 0, il = textures.length; i < il; i ++ ) {

				const attachment = textures[ i ];
				const attachmentProperties = properties.get( attachment );

				state.bindTexture( 3553, attachmentProperties.__webglTexture );
				setTextureParameters( 3553, attachment, supportsMips );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553 );

				if ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {

					generateMipmap( 3553 );

				}

			}

			state.unbindTexture();

		} else {

			let glTextureType = 3553;

			if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

				if ( isWebGL2 ) {

					glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;

				} else {

					console.error( 'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.' );

				}

			}

			state.bindTexture( glTextureType, textureProperties.__webglTexture );
			setTextureParameters( glTextureType, texture, supportsMips );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType );

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( glTextureType );

			}

			state.unbindTexture();

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

		const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

		for ( let i = 0, il = textures.length; i < il; i ++ ) {

			const texture = textures[ i ];

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
				const webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				generateMipmap( target );
				state.unbindTexture();

			}

		}

	}

	function updateMultisampleRenderTarget( renderTarget ) {

		if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

			const width = renderTarget.width;
			const height = renderTarget.height;
			let mask = 16384;
			const invalidationArray = [ 36064 ];
			const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;

			if ( renderTarget.depthBuffer ) {

				invalidationArray.push( depthStyle );

			}

			const renderTargetProperties = properties.get( renderTarget );
			const ignoreDepthValues = ( renderTargetProperties.__ignoreDepthValues !== undefined ) ? renderTargetProperties.__ignoreDepthValues : false;

			if ( ignoreDepthValues === false ) {

				if ( renderTarget.depthBuffer ) mask |= 256;
				if ( renderTarget.stencilBuffer ) mask |= 1024;

			}

			state.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
			state.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

			if ( ignoreDepthValues === true ) {

				_gl.invalidateFramebuffer( 36008, [ depthStyle ] );
				_gl.invalidateFramebuffer( 36009, [ depthStyle ] );

			}

			_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

			if ( supportsInvalidateFramebuffer ) {

				_gl.invalidateFramebuffer( 36008, invalidationArray );

			}

			state.bindFramebuffer( 36008, null );
			state.bindFramebuffer( 36009, renderTargetProperties.__webglMultisampledFramebuffer );

		}

	}

	function getRenderTargetSamples( renderTarget ) {

		return Math.min( maxSamples, renderTarget.samples );

	}

	function useMultisampledRTT( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );

		return isWebGL2 && renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;

	}

	function updateVideoTexture( texture ) {

		const frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if ( _videoTextures.get( texture ) !== frame ) {

			_videoTextures.set( texture, frame );
			texture.update();

		}

	}

	function verifyColorSpace( texture, image ) {

		const encoding = texture.encoding;
		const format = texture.format;
		const type = texture.type;

		if ( texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat ) return image;

		if ( encoding !== LinearEncoding ) {

			// sRGB

			if ( encoding === sRGBEncoding ) {

				if ( isWebGL2 === false ) {

					// in WebGL 1, try to use EXT_sRGB extension and unsized formats

					if ( extensions.has( 'EXT_sRGB' ) === true && format === RGBAFormat ) {

						texture.format = _SRGBAFormat;

						// it's not possible to generate mips in WebGL 1 with this extension

						texture.minFilter = LinearFilter;
						texture.generateMipmaps = false;

					} else {

						// slow fallback (CPU decode)

						image = ImageUtils.sRGBToLinear( image );

					}

				} else {

					// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

					if ( format !== RGBAFormat || type !== UnsignedByteType ) {

						console.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );

					}

				}

			} else {

				console.error( 'THREE.WebGLTextures: Unsupported texture encoding:', encoding );

			}

		}

		return image;

	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;

	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.rebindTextures = rebindTextures;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
	this.setupDepthRenderbuffer = setupDepthRenderbuffer;
	this.setupFrameBufferTexture = setupFrameBufferTexture;
	this.useMultisampledRTT = useMultisampledRTT;

}

function WebGLUtils( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function convert( p, encoding = null ) {

		let extension;

		if ( p === UnsignedByteType ) return 5121;
		if ( p === UnsignedShort4444Type ) return 32819;
		if ( p === UnsignedShort5551Type ) return 32820;

		if ( p === ByteType ) return 5120;
		if ( p === ShortType ) return 5122;
		if ( p === UnsignedShortType ) return 5123;
		if ( p === IntType ) return 5124;
		if ( p === UnsignedIntType ) return 5125;
		if ( p === FloatType ) return 5126;

		if ( p === HalfFloatType ) {

			if ( isWebGL2 ) return 5131;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				return extension.HALF_FLOAT_OES;

			} else {

				return null;

			}

		}

		if ( p === AlphaFormat ) return 6406;
		if ( p === RGBAFormat ) return 6408;
		if ( p === LuminanceFormat ) return 6409;
		if ( p === LuminanceAlphaFormat ) return 6410;
		if ( p === DepthFormat ) return 6402;
		if ( p === DepthStencilFormat ) return 34041;
		if ( p === RedFormat ) return 6403;

		if ( p === RGBFormat ) {

			console.warn( 'THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228' );
			return 6408;

		}

		// WebGL 1 sRGB fallback

		if ( p === _SRGBAFormat ) {

			extension = extensions.get( 'EXT_sRGB' );

			if ( extension !== null ) {

				return extension.SRGB_ALPHA_EXT;

			} else {

				return null;

			}

		}

		// WebGL2 formats.

		if ( p === RedIntegerFormat ) return 36244;
		if ( p === RGFormat ) return 33319;
		if ( p === RGIntegerFormat ) return 33320;
		if ( p === RGBAIntegerFormat ) return 36249;

		// S3TC

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			if ( encoding === sRGBEncoding ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			} else {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			}

		}

		// PVRTC

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		// ETC1

		if ( p === RGB_ETC1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			if ( extension !== null ) {

				return extension.COMPRESSED_RGB_ETC1_WEBGL;

			} else {

				return null;

			}

		}

		// ETC2

		if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC2_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

			} else {

				return null;

			}

		}

		// ASTC

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				if ( p === RGBA_ASTC_4x4_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if ( p === RGBA_ASTC_5x4_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if ( p === RGBA_ASTC_5x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if ( p === RGBA_ASTC_6x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if ( p === RGBA_ASTC_6x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if ( p === RGBA_ASTC_8x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if ( p === RGBA_ASTC_8x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if ( p === RGBA_ASTC_8x8_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if ( p === RGBA_ASTC_10x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if ( p === RGBA_ASTC_10x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if ( p === RGBA_ASTC_10x8_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if ( p === RGBA_ASTC_10x10_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if ( p === RGBA_ASTC_12x10_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if ( p === RGBA_ASTC_12x12_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

			} else {

				return null;

			}

		}

		// BPTC

		if ( p === RGBA_BPTC_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;

			} else {

				return null;

			}

		}

		//

		if ( p === UnsignedInt248Type ) {

			if ( isWebGL2 ) return 34042;

			extension = extensions.get( 'WEBGL_depth_texture' );

			if ( extension !== null ) {

				return extension.UNSIGNED_INT_24_8_WEBGL;

			} else {

				return null;

			}

		}

	}

	return { convert: convert };

}

class ArrayCamera extends PerspectiveCamera {

	constructor( array = [] ) {

		super();

		this.cameras = array;

	}

}

ArrayCamera.prototype.isArrayCamera = true;

class Group extends Object3D {

	constructor() {

		super();

		this.type = 'Group';

	}

}

Group.prototype.isGroup = true;

const _moveEvent = { type: 'move' };

class WebXRController {

	constructor() {

		this._targetRay = null;
		this._grip = null;
		this._hand = null;

	}

	getHandSpace() {

		if ( this._hand === null ) {

			this._hand = new Group();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;

			this._hand.joints = {};
			this._hand.inputState = { pinching: false };

		}

		return this._hand;

	}

	getTargetRaySpace() {

		if ( this._targetRay === null ) {

			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;
			this._targetRay.hasLinearVelocity = false;
			this._targetRay.linearVelocity = new Vector3();
			this._targetRay.hasAngularVelocity = false;
			this._targetRay.angularVelocity = new Vector3();

		}

		return this._targetRay;

	}

	getGripSpace() {

		if ( this._grip === null ) {

			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;
			this._grip.hasLinearVelocity = false;
			this._grip.linearVelocity = new Vector3();
			this._grip.hasAngularVelocity = false;
			this._grip.angularVelocity = new Vector3();

		}

		return this._grip;

	}

	dispatchEvent( event ) {

		if ( this._targetRay !== null ) {

			this._targetRay.dispatchEvent( event );

		}

		if ( this._grip !== null ) {

			this._grip.dispatchEvent( event );

		}

		if ( this._hand !== null ) {

			this._hand.dispatchEvent( event );

		}

		return this;

	}

	disconnect( inputSource ) {

		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		if ( this._targetRay !== null ) {

			this._targetRay.visible = false;

		}

		if ( this._grip !== null ) {

			this._grip.visible = false;

		}

		if ( this._hand !== null ) {

			this._hand.visible = false;

		}

		return this;

	}

	update( inputSource, frame, referenceSpace ) {

		let inputPose = null;
		let gripPose = null;
		let handPose = null;

		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;

		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

			if ( targetRay !== null ) {

				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

				if ( inputPose !== null ) {

					targetRay.matrix.fromArray( inputPose.transform.matrix );
					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

					if ( inputPose.linearVelocity ) {

						targetRay.hasLinearVelocity = true;
						targetRay.linearVelocity.copy( inputPose.linearVelocity );

					} else {

						targetRay.hasLinearVelocity = false;

					}

					if ( inputPose.angularVelocity ) {

						targetRay.hasAngularVelocity = true;
						targetRay.angularVelocity.copy( inputPose.angularVelocity );

					} else {

						targetRay.hasAngularVelocity = false;

					}

					this.dispatchEvent( _moveEvent );

				}

			}

			if ( hand && inputSource.hand ) {

				handPose = true;

				for ( const inputjoint of inputSource.hand.values() ) {

					// Update the joints groups with the XRJoint poses
					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

					if ( hand.joints[ inputjoint.jointName ] === undefined ) {

						// The transform of this joint will be updated with the joint pose on each frame
						const joint = new Group();
						joint.matrixAutoUpdate = false;
						joint.visible = false;
						hand.joints[ inputjoint.jointName ] = joint;
						// ??
						hand.add( joint );

					}

					const joint = hand.joints[ inputjoint.jointName ];

					if ( jointPose !== null ) {

						joint.matrix.fromArray( jointPose.transform.matrix );
						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
						joint.jointRadius = jointPose.radius;

					}

					joint.visible = jointPose !== null;

				}

				// Custom events

				// Check pinchz
				const indexTip = hand.joints[ 'index-finger-tip' ];
				const thumbTip = hand.joints[ 'thumb-tip' ];
				const distance = indexTip.position.distanceTo( thumbTip.position );

				const distanceToPinch = 0.02;
				const threshold = 0.005;

				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

					hand.inputState.pinching = false;
					this.dispatchEvent( {
						type: 'pinchend',
						handedness: inputSource.handedness,
						target: this
					} );

				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

					hand.inputState.pinching = true;
					this.dispatchEvent( {
						type: 'pinchstart',
						handedness: inputSource.handedness,
						target: this
					} );

				}

			} else {

				if ( grip !== null && inputSource.gripSpace ) {

					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					if ( gripPose !== null ) {

						grip.matrix.fromArray( gripPose.transform.matrix );
						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

						if ( gripPose.linearVelocity ) {

							grip.hasLinearVelocity = true;
							grip.linearVelocity.copy( gripPose.linearVelocity );

						} else {

							grip.hasLinearVelocity = false;

						}

						if ( gripPose.angularVelocity ) {

							grip.hasAngularVelocity = true;
							grip.angularVelocity.copy( gripPose.angularVelocity );

						} else {

							grip.hasAngularVelocity = false;

						}

					}

				}

			}

		}

		if ( targetRay !== null ) {

			targetRay.visible = ( inputPose !== null );

		}

		if ( grip !== null ) {

			grip.visible = ( gripPose !== null );

		}

		if ( hand !== null ) {

			hand.visible = ( handPose !== null );

		}

		return this;

	}

}

class DepthTexture extends Texture {

	constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps	= false;

	}


}

DepthTexture.prototype.isDepthTexture = true;

class WebXRManager extends EventDispatcher {

	constructor( renderer, gl ) {

		super();

		const scope = this;

		let session = null;
		let framebufferScaleFactor = 1.0;

		let referenceSpace = null;
		let referenceSpaceType = 'local-floor';

		let pose = null;
		let glBinding = null;
		let glProjLayer = null;
		let glBaseLayer = null;
		let xrFrame = null;
		const attributes = gl.getContextAttributes();
		let initialRenderTarget = null;
		let newRenderTarget = null;

		const controllers = [];
		const inputSourcesMap = new Map();

		//

		const cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();

		const cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();

		const cameras = [ cameraL, cameraR ];

		const cameraVR = new ArrayCamera();
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		let _currentDepthNear = null;
		let _currentDepthFar = null;

		//

		this.cameraAutoUpdate = true;
		this.enabled = false;

		this.isPresenting = false;

		this.getController = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getTargetRaySpace();

		};

		this.getControllerGrip = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getGripSpace();

		};

		this.getHand = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getHandSpace();

		};

		//

		function onSessionEvent( event ) {

			const controller = inputSourcesMap.get( event.inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: event.type, data: event.inputSource } );

			}

		}

		function onSessionEnd() {

			inputSourcesMap.forEach( function ( controller, inputSource ) {

				controller.disconnect( inputSource );

			} );

			inputSourcesMap.clear();

			_currentDepthNear = null;
			_currentDepthFar = null;

			// restore framebuffer/rendering state

			renderer.setRenderTarget( initialRenderTarget );

			glBaseLayer = null;
			glProjLayer = null;
			glBinding = null;
			session = null;
			newRenderTarget = null;

			//

			animation.stop();

			scope.isPresenting = false;

			scope.dispatchEvent( { type: 'sessionend' } );

		}

		this.setFramebufferScaleFactor = function ( value ) {

			framebufferScaleFactor = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

			}

		};

		this.setReferenceSpaceType = function ( value ) {

			referenceSpaceType = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

			}

		};

		this.getReferenceSpace = function () {

			return referenceSpace;

		};

		this.getBaseLayer = function () {

			return glProjLayer !== null ? glProjLayer : glBaseLayer;

		};

		this.getBinding = function () {

			return glBinding;

		};

		this.getFrame = function () {

			return xrFrame;

		};

		this.getSession = function () {

			return session;

		};

		this.setSession = async function ( value ) {

			session = value;

			if ( session !== null ) {

				initialRenderTarget = renderer.getRenderTarget();

				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'squeeze', onSessionEvent );
				session.addEventListener( 'squeezestart', onSessionEvent );
				session.addEventListener( 'squeezeend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );
				session.addEventListener( 'inputsourceschange', onInputSourcesChange );

				if ( attributes.xrCompatible !== true ) {

					await gl.makeXRCompatible();

				}

				if ( ( session.renderState.layers === undefined ) || ( renderer.capabilities.isWebGL2 === false ) ) {

					const layerInit = {
						antialias: ( session.renderState.layers === undefined ) ? attributes.antialias : true,
						alpha: attributes.alpha,
						depth: attributes.depth,
						stencil: attributes.stencil,
						framebufferScaleFactor: framebufferScaleFactor
					};

					glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

					session.updateRenderState( { baseLayer: glBaseLayer } );

					newRenderTarget = new WebGLRenderTarget(
						glBaseLayer.framebufferWidth,
						glBaseLayer.framebufferHeight,
						{
							format: RGBAFormat,
							type: UnsignedByteType,
							encoding: renderer.outputEncoding
						}
					);

				} else {

					let depthFormat = null;
					let depthType = null;
					let glDepthFormat = null;

					if ( attributes.depth ) {

						glDepthFormat = attributes.stencil ? 35056 : 33190;
						depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
						depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;

					}

					const projectionlayerInit = {
						colorFormat: ( renderer.outputEncoding === sRGBEncoding ) ? 35907 : 32856,
						depthFormat: glDepthFormat,
						scaleFactor: framebufferScaleFactor
					};

					glBinding = new XRWebGLBinding( session, gl );

					glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

					session.updateRenderState( { layers: [ glProjLayer ] } );

					newRenderTarget = new WebGLRenderTarget(
						glProjLayer.textureWidth,
						glProjLayer.textureHeight,
						{
							format: RGBAFormat,
							type: UnsignedByteType,
							depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
							stencilBuffer: attributes.stencil,
							encoding: renderer.outputEncoding,
							samples: attributes.antialias ? 4 : 0
						} );

					const renderTargetProperties = renderer.properties.get( newRenderTarget );
					renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;

				}

				newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

				// Set foveation to maximum.
				this.setFoveation( 1.0 );

				referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

				animation.setContext( session );
				animation.start();

				scope.isPresenting = true;

				scope.dispatchEvent( { type: 'sessionstart' } );

			}

		};

		function onInputSourcesChange( event ) {

			const inputSources = session.inputSources;

			// Assign inputSources to available controllers

			for ( let i = 0; i < controllers.length; i ++ ) {

				inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

			}

			// Notify disconnected

			for ( let i = 0; i < event.removed.length; i ++ ) {

				const inputSource = event.removed[ i ];
				const controller = inputSourcesMap.get( inputSource );

				if ( controller ) {

					controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
					inputSourcesMap.delete( inputSource );

				}

			}

			// Notify connected

			for ( let i = 0; i < event.added.length; i ++ ) {

				const inputSource = event.added[ i ];
				const controller = inputSourcesMap.get( inputSource );

				if ( controller ) {

					controller.dispatchEvent( { type: 'connected', data: inputSource } );

				}

			}

		}

		//

		const cameraLPos = new Vector3();
		const cameraRPos = new Vector3();

		/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */
		function setProjectionFromUnion( camera, cameraL, cameraR ) {

			cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
			cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

			const ipd = cameraLPos.distanceTo( cameraRPos );

			const projL = cameraL.projectionMatrix.elements;
			const projR = cameraR.projectionMatrix.elements;

			// VR systems will have identical far and near planes, and
			// most likely identical top and bottom frustum extents.
			// Use the left camera for these values.
			const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
			const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
			const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
			const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

			const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
			const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
			const left = near * leftFov;
			const right = near * rightFov;

			// Calculate the new camera's position offset from the
			// left camera. xOffset should be roughly half `ipd`.
			const zOffset = ipd / ( - leftFov + rightFov );
			const xOffset = zOffset * - leftFov;

			// TODO: Better way to apply this offset?
			cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
			camera.translateX( xOffset );
			camera.translateZ( zOffset );
			camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			// Find the union of the frustum values of the cameras and scale
			// the values so that the near plane's position does not change in world space,
			// although must now be relative to the new union camera.
			const near2 = near + zOffset;
			const far2 = far + zOffset;
			const left2 = left - xOffset;
			const right2 = right + ( ipd - xOffset );
			const top2 = topFov * far / far2 * near2;
			const bottom2 = bottomFov * far / far2 * near2;

			camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

		}

		function updateCamera( camera, parent ) {

			if ( parent === null ) {

				camera.matrixWorld.copy( camera.matrix );

			} else {

				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			}

			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		}

		this.updateCamera = function ( camera ) {

			if ( session === null ) return;

			cameraVR.near = cameraR.near = cameraL.near = camera.near;
			cameraVR.far = cameraR.far = cameraL.far = camera.far;

			if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

				// Note that the new renderState won't apply until the next frame. See #18320

				session.updateRenderState( {
					depthNear: cameraVR.near,
					depthFar: cameraVR.far
				} );

				_currentDepthNear = cameraVR.near;
				_currentDepthFar = cameraVR.far;

			}

			const parent = camera.parent;
			const cameras = cameraVR.cameras;

			updateCamera( cameraVR, parent );

			for ( let i = 0; i < cameras.length; i ++ ) {

				updateCamera( cameras[ i ], parent );

			}

			cameraVR.matrixWorld.decompose( cameraVR.position, cameraVR.quaternion, cameraVR.scale );

			// update user camera and its children

			camera.position.copy( cameraVR.position );
			camera.quaternion.copy( cameraVR.quaternion );
			camera.scale.copy( cameraVR.scale );
			camera.matrix.copy( cameraVR.matrix );
			camera.matrixWorld.copy( cameraVR.matrixWorld );

			const children = camera.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( true );

			}

			// update projection matrix for proper view frustum culling

			if ( cameras.length === 2 ) {

				setProjectionFromUnion( cameraVR, cameraL, cameraR );

			} else {

				// assume single camera setup (AR)

				cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

			}

		};

		this.getCamera = function () {

			return cameraVR;

		};

		this.getFoveation = function () {

			if ( glProjLayer !== null ) {

				return glProjLayer.fixedFoveation;

			}

			if ( glBaseLayer !== null ) {

				return glBaseLayer.fixedFoveation;

			}

			return undefined;

		};

		this.setFoveation = function ( foveation ) {

			// 0 = no foveation = full resolution
			// 1 = maximum foveation = the edges render at lower resolution

			if ( glProjLayer !== null ) {

				glProjLayer.fixedFoveation = foveation;

			}

			if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

				glBaseLayer.fixedFoveation = foveation;

			}

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time, frame ) {

			pose = frame.getViewerPose( referenceSpace );
			xrFrame = frame;

			if ( pose !== null ) {

				const views = pose.views;

				if ( glBaseLayer !== null ) {

					renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
					renderer.setRenderTarget( newRenderTarget );

				}

				let cameraVRNeedsUpdate = false;

				// check if it's necessary to rebuild cameraVR's camera list

				if ( views.length !== cameraVR.cameras.length ) {

					cameraVR.cameras.length = 0;
					cameraVRNeedsUpdate = true;

				}

				for ( let i = 0; i < views.length; i ++ ) {

					const view = views[ i ];

					let viewport = null;

					if ( glBaseLayer !== null ) {

						viewport = glBaseLayer.getViewport( view );

					} else {

						const glSubImage = glBinding.getViewSubImage( glProjLayer, view );
						viewport = glSubImage.viewport;

						// For side-by-side projection, we only produce a single texture for both eyes.
						if ( i === 0 ) {

							renderer.setRenderTargetTextures(
								newRenderTarget,
								glSubImage.colorTexture,
								glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );

							renderer.setRenderTarget( newRenderTarget );

						}

					}

					const camera = cameras[ i ];

					camera.matrix.fromArray( view.transform.matrix );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					if ( i === 0 ) {

						cameraVR.matrix.copy( camera.matrix );

					}

					if ( cameraVRNeedsUpdate === true ) {

						cameraVR.cameras.push( camera );

					}

				}

			}

			//

			const inputSources = session.inputSources;

			for ( let i = 0; i < controllers.length; i ++ ) {

				const controller = controllers[ i ];
				const inputSource = inputSources[ i ];

				controller.update( inputSource, frame, referenceSpace );

			}

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

			xrFrame = null;

		}

		const animation = new WebGLAnimation();

		animation.setAnimationLoop( onAnimationFrame );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;

		};

		this.dispose = function () {};

	}

}

function WebGLMaterials( renderer, properties ) {

	function refreshFogUniforms( uniforms, fog ) {

		uniforms.fogColor.value.copy( fog.color );

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

		if ( material.isMeshBasicMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshLambertMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshToonMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsToon( uniforms, material );

		} else if ( material.isMeshPhongMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsPhong( uniforms, material );

		} else if ( material.isMeshStandardMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsStandard( uniforms, material );

			if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

			}

		} else if ( material.isMeshMatcapMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsMatcap( uniforms, material );

		} else if ( material.isMeshDepthMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshDistanceMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDistance( uniforms, material );

		} else if ( material.isMeshNormalMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isLineBasicMaterial ) {

			refreshUniformsLine( uniforms, material );

			if ( material.isLineDashedMaterial ) {

				refreshUniformsDash( uniforms, material );

			}

		} else if ( material.isPointsMaterial ) {

			refreshUniformsPoints( uniforms, material, pixelRatio, height );

		} else if ( material.isSpriteMaterial ) {

			refreshUniformsSprites( uniforms, material );

		} else if ( material.isShadowMaterial ) {

			uniforms.color.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		} else if ( material.isShaderMaterial ) {

			material.uniformsNeedUpdate = false; // #15581

		}

	}

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( material.color ) {

			uniforms.diffuse.value.copy( material.color );

		}

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.specularMap ) {

			uniforms.specularMap.value = material.specularMap;

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			uniforms.envMap.value = envMap;

			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.ior.value = material.ior;
			uniforms.refractionRatio.value = material.refractionRatio;

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;

			// artist-friendly light intensity scaling factor
			const scaleFactor = ( renderer.physicallyCorrectLights !== true ) ? Math.PI : 1;

			uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. displacementMap map
		// 4. normal map
		// 5. bump map
		// 6. roughnessMap map
		// 7. metalnessMap map
		// 8. alphaMap map
		// 9. emissiveMap map
		// 10. clearcoat map
		// 11. clearcoat normal map
		// 12. clearcoat roughnessMap map
		// 13. specular intensity map
		// 14. specular tint map
		// 15. transmission map
		// 16. thickness map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		} else if ( material.clearcoatMap ) {

			uvScaleMap = material.clearcoatMap;

		} else if ( material.clearcoatNormalMap ) {

			uvScaleMap = material.clearcoatNormalMap;

		} else if ( material.clearcoatRoughnessMap ) {

			uvScaleMap = material.clearcoatRoughnessMap;

		} else if ( material.specularIntensityMap ) {

			uvScaleMap = material.specularIntensityMap;

		} else if ( material.specularColorMap ) {

			uvScaleMap = material.specularColorMap;

		} else if ( material.transmissionMap ) {

			uvScaleMap = material.transmissionMap;

		} else if ( material.thicknessMap ) {

			uvScaleMap = material.thicknessMap;

		} else if ( material.sheenColorMap ) {

			uvScaleMap = material.sheenColorMap;

		} else if ( material.sheenRoughnessMap ) {

			uvScaleMap = material.sheenRoughnessMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap.isWebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

		// uv repeat and offset setting priorities for uv2
		// 1. ao map
		// 2. light map

		let uv2ScaleMap;

		if ( material.aoMap ) {

			uv2ScaleMap = material.aoMap;

		} else if ( material.lightMap ) {

			uv2ScaleMap = material.lightMap;

		}

		if ( uv2ScaleMap !== undefined ) {

			// backwards compatibility
			if ( uv2ScaleMap.isWebGLRenderTarget ) {

				uv2ScaleMap = uv2ScaleMap.texture;

			}

			if ( uv2ScaleMap.matrixAutoUpdate === true ) {

				uv2ScaleMap.updateMatrix();

			}

			uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

		}

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * 0.5;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsSprites( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

	}

	function refreshUniformsToon( uniforms, material ) {

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

		uniforms.ior.value = material.ior; // also part of uniforms common

		if ( material.sheen > 0 ) {

			uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

			uniforms.sheenRoughness.value = material.sheenRoughness;

			if ( material.sheenColorMap ) {

				uniforms.sheenColorMap.value = material.sheenColorMap;

			}

			if ( material.sheenRoughnessMap ) {

				uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

			}

		}

		if ( material.clearcoat > 0 ) {

			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

			if ( material.clearcoatMap ) {

				uniforms.clearcoatMap.value = material.clearcoatMap;

			}

			if ( material.clearcoatRoughnessMap ) {

				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

			}

			if ( material.clearcoatNormalMap ) {

				uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

				if ( material.side === BackSide ) {

					uniforms.clearcoatNormalScale.value.negate();

				}

			}

		}

		if ( material.transmission > 0 ) {

			uniforms.transmission.value = material.transmission;
			uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
			uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

			if ( material.transmissionMap ) {

				uniforms.transmissionMap.value = material.transmissionMap;

			}

			uniforms.thickness.value = material.thickness;

			if ( material.thicknessMap ) {

				uniforms.thicknessMap.value = material.thicknessMap;

			}

			uniforms.attenuationDistance.value = material.attenuationDistance;
			uniforms.attenuationColor.value.copy( material.attenuationColor );

		}

		uniforms.specularIntensity.value = material.specularIntensity;
		uniforms.specularColor.value.copy( material.specularColor );

		if ( material.specularIntensityMap ) {

			uniforms.specularIntensityMap.value = material.specularIntensityMap;

		}

		if ( material.specularColorMap ) {

			uniforms.specularColorMap.value = material.specularColorMap;

		}

	}

	function refreshUniformsMatcap( uniforms, material ) {

		if ( material.matcap ) {

			uniforms.matcap.value = material.matcap;

		}

	}

	function refreshUniformsDistance( uniforms, material ) {

		uniforms.referencePosition.value.copy( material.referencePosition );
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;

	}

	return {
		refreshFogUniforms: refreshFogUniforms,
		refreshMaterialUniforms: refreshMaterialUniforms
	};

}

function createCanvasElement() {

	const canvas = createElementNS( 'canvas' );
	canvas.style.display = 'block';
	return canvas;

}

function WebGLRenderer( parameters = {} ) {

	const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
		_context = parameters.context !== undefined ? parameters.context : null,

		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
		_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

	let _alpha;

	if ( parameters.context !== undefined ) {

		_alpha = _context.getContextAttributes().alpha;

	} else {

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false;

	}

	let currentRenderList = null;
	let currentRenderState = null;

	// render() can be called from within a callback triggered by another render.
	// We track this so that the nested render call gets its list and state isolated from the parent render call.

	const renderListStack = [];
	const renderStateStack = [];

	// public properties

	this.domElement = _canvas;

	// Debug configuration container
	this.debug = {

		/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
		checkShaderErrors: true
	};

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.outputEncoding = LinearEncoding;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = NoToneMapping;
	this.toneMappingExposure = 1.0;

	// internal properties

	const _this = this;

	let _isContextLost = false;

	// internal state cache

	let _currentActiveCubeFace = 0;
	let _currentActiveMipmapLevel = 0;
	let _currentRenderTarget = null;
	let _currentMaterialId = - 1;

	let _currentCamera = null;

	const _currentViewport = new Vector4();
	const _currentScissor = new Vector4();
	let _currentScissorTest = null;

	//

	let _width = _canvas.width;
	let _height = _canvas.height;

	let _pixelRatio = 1;
	let _opaqueSort = null;
	let _transparentSort = null;

	const _viewport = new Vector4( 0, 0, _width, _height );
	const _scissor = new Vector4( 0, 0, _width, _height );
	let _scissorTest = false;

	// frustum

	const _frustum = new Frustum();

	// clipping

	let _clippingEnabled = false;
	let _localClippingEnabled = false;

	// transmission

	let _transmissionRenderTarget = null;

	// camera matrices cache

	const _projScreenMatrix = new Matrix4();

	const _vector2 = new Vector2();
	const _vector3 = new Vector3();

	const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	// initialize

	let _gl = _context;

	function getContext( contextNames, contextAttributes ) {

		for ( let i = 0; i < contextNames.length; i ++ ) {

			const contextName = contextNames[ i ];
			const context = _canvas.getContext( contextName, contextAttributes );
			if ( context !== null ) return context;

		}

		return null;

	}

	try {

		const contextAttributes = {
			alpha: true,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer,
			powerPreference: _powerPreference,
			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
		};

		// OffscreenCanvas does not have setAttribute, see #22811
		if ( 'setAttribute' in _canvas ) _canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );

		// event listeners must be registered before WebGL context is created, see #12753
		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

		if ( _gl === null ) {

			const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

			if ( _this.isWebGL1Renderer === true ) {

				contextNames.shift();

			}

			_gl = getContext( contextNames, contextAttributes );

			if ( _gl === null ) {

				if ( getContext( contextNames ) ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error.message );
		throw error;

	}

	let extensions, capabilities, state, info;
	let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
	let programCache, materials, renderLists, renderStates, clipping, shadowMap;

	let background, morphtargets, bufferRenderer, indexedBufferRenderer;

	let utils, bindingStates;

	function initGLContext() {

		extensions = new WebGLExtensions( _gl );

		capabilities = new WebGLCapabilities( _gl, extensions, parameters );

		extensions.init( capabilities );

		utils = new WebGLUtils( _gl, extensions, capabilities );

		state = new WebGLState( _gl, extensions, capabilities );

		info = new WebGLInfo( _gl );
		properties = new WebGLProperties();
		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
		cubemaps = new WebGLCubeMaps( _this );
		cubeuvmaps = new WebGLCubeUVMaps( _this );
		attributes = new WebGLAttributes( _gl, capabilities );
		bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
		geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
		objects = new WebGLObjects( _gl, geometries, attributes, info );
		morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
		clipping = new WebGLClipping( properties );
		programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
		materials = new WebGLMaterials( _this, properties );
		renderLists = new WebGLRenderLists();
		renderStates = new WebGLRenderStates( extensions, capabilities );
		background = new WebGLBackground( _this, cubemaps, state, objects, _alpha, _premultipliedAlpha );
		shadowMap = new WebGLShadowMap( _this, objects, capabilities );

		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

		info.programs = programCache.programs;

		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.shadowMap = shadowMap;
		_this.state = state;
		_this.info = info;

	}

	initGLContext();

	// xr

	const xr = new WebXRManager( _this, _gl );

	this.xr = xr;

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.loseContext();

	};

	this.forceContextRestore = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.restoreContext();

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _width, _height, false );

	};

	this.getSize = function ( target ) {

		return target.set( _width, _height );

	};

	this.setSize = function ( width, height, updateStyle ) {

		if ( xr.isPresenting ) {

			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			return;

		}

		_width = width;
		_height = height;

		_canvas.width = Math.floor( width * _pixelRatio );
		_canvas.height = Math.floor( height * _pixelRatio );

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.getDrawingBufferSize = function ( target ) {

		return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

	};

	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

		_width = width;
		_height = height;

		_pixelRatio = pixelRatio;

		_canvas.width = Math.floor( width * pixelRatio );
		_canvas.height = Math.floor( height * pixelRatio );

		this.setViewport( 0, 0, width, height );

	};

	this.getCurrentViewport = function ( target ) {

		return target.copy( _currentViewport );

	};

	this.getViewport = function ( target ) {

		return target.copy( _viewport );

	};

	this.setViewport = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_viewport.set( x.x, x.y, x.z, x.w );

		} else {

			_viewport.set( x, y, width, height );

		}

		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissor = function ( target ) {

		return target.copy( _scissor );

	};

	this.setScissor = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_scissor.set( x.x, x.y, x.z, x.w );

		} else {

			_scissor.set( x, y, width, height );

		}

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissorTest = function () {

		return _scissorTest;

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	this.setOpaqueSort = function ( method ) {

		_opaqueSort = method;

	};

	this.setTransparentSort = function ( method ) {

		_transparentSort = method;

	};

	// Clearing

	this.getClearColor = function ( target ) {

		return target.copy( background.getClearColor() );

	};

	this.setClearColor = function () {

		background.setClearColor.apply( background, arguments );

	};

	this.getClearAlpha = function () {

		return background.getClearAlpha();

	};

	this.setClearAlpha = function () {

		background.setClearAlpha.apply( background, arguments );

	};

	this.clear = function ( color = true, depth = true, stencil = true ) {

		let bits = 0;

		if ( color ) bits |= 16384;
		if ( depth ) bits |= 256;
		if ( stencil ) bits |= 1024;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	//

	this.dispose = function () {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

		renderLists.dispose();
		renderStates.dispose();
		properties.dispose();
		cubemaps.dispose();
		cubeuvmaps.dispose();
		objects.dispose();
		bindingStates.dispose();
		programCache.dispose();

		xr.dispose();

		xr.removeEventListener( 'sessionstart', onXRSessionStart );
		xr.removeEventListener( 'sessionend', onXRSessionEnd );

		if ( _transmissionRenderTarget ) {

			_transmissionRenderTarget.dispose();
			_transmissionRenderTarget = null;

		}

		animation.stop();

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		console.log( 'THREE.WebGLRenderer: Context Lost.' );

		_isContextLost = true;

	}

	function onContextRestore( /* event */ ) {

		console.log( 'THREE.WebGLRenderer: Context Restored.' );

		_isContextLost = false;

		const infoAutoReset = info.autoReset;
		const shadowMapEnabled = shadowMap.enabled;
		const shadowMapAutoUpdate = shadowMap.autoUpdate;
		const shadowMapNeedsUpdate = shadowMap.needsUpdate;
		const shadowMapType = shadowMap.type;

		initGLContext();

		info.autoReset = infoAutoReset;
		shadowMap.enabled = shadowMapEnabled;
		shadowMap.autoUpdate = shadowMapAutoUpdate;
		shadowMap.needsUpdate = shadowMapNeedsUpdate;
		shadowMap.type = shadowMapType;

	}

	function onMaterialDispose( event ) {

		const material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReferences( material );

		properties.remove( material );

	}


	function releaseMaterialProgramReferences( material ) {

		const programs = properties.get( material ).programs;

		if ( programs !== undefined ) {

			programs.forEach( function ( program ) {

				programCache.releaseProgram( program );

			} );

			if ( material.isShaderMaterial ) {

				programCache.releaseShaderCache( material );

			}

		}

	}

	// Buffer rendering

	this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

		if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		const program = setProgram( camera, scene, geometry, material, object );

		state.setMaterial( material, frontFaceCW );

		//

		let index = geometry.index;
		const position = geometry.attributes.position;

		//

		if ( index === null ) {

			if ( position === undefined || position.count === 0 ) return;

		} else if ( index.count === 0 ) {

			return;

		}

		//

		let rangeFactor = 1;

		if ( material.wireframe === true ) {

			index = geometries.getWireframeAttribute( geometry );
			rangeFactor = 2;

		}

		bindingStates.setup( object, material, program, geometry, index );

		let attribute;
		let renderer = bufferRenderer;

		if ( index !== null ) {

			attribute = attributes.get( index );

			renderer = indexedBufferRenderer;
			renderer.setIndex( attribute );

		}

		//

		const dataCount = ( index !== null ) ? index.count : position.count;

		const rangeStart = geometry.drawRange.start * rangeFactor;
		const rangeCount = geometry.drawRange.count * rangeFactor;

		const groupStart = group !== null ? group.start * rangeFactor : 0;
		const groupCount = group !== null ? group.count * rangeFactor : Infinity;

		const drawStart = Math.max( rangeStart, groupStart );
		const drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		const drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		if ( drawCount === 0 ) return;

		//

		if ( object.isMesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( 1 );

			} else {

				renderer.setMode( 4 );

			}

		} else if ( object.isLine ) {

			let lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object.isLineSegments ) {

				renderer.setMode( 1 );

			} else if ( object.isLineLoop ) {

				renderer.setMode( 2 );

			} else {

				renderer.setMode( 3 );

			}

		} else if ( object.isPoints ) {

			renderer.setMode( 0 );

		} else if ( object.isSprite ) {

			renderer.setMode( 4 );

		}

		if ( object.isInstancedMesh ) {

			renderer.renderInstances( drawStart, drawCount, object.count );

		} else if ( geometry.isInstancedBufferGeometry ) {

			const instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

			renderer.renderInstances( drawStart, drawCount, instanceCount );

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	// Compile

	this.compile = function ( scene, camera ) {

		currentRenderState = renderStates.get( scene );
		currentRenderState.init();

		renderStateStack.push( currentRenderState );

		scene.traverseVisible( function ( object ) {

			if ( object.isLight && object.layers.test( camera.layers ) ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			}

		} );

		currentRenderState.setupLights( _this.physicallyCorrectLights );

		scene.traverse( function ( object ) {

			const material = object.material;

			if ( material ) {

				if ( Array.isArray( material ) ) {

					for ( let i = 0; i < material.length; i ++ ) {

						const material2 = material[ i ];

						getProgram( material2, scene, object );

					}

				} else {

					getProgram( material, scene, object );

				}

			}

		} );

		renderStateStack.pop();
		currentRenderState = null;

	};

	// Animation Loop

	let onAnimationFrameCallback = null;

	function onAnimationFrame( time ) {

		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

	}

	function onXRSessionStart() {

		animation.stop();

	}

	function onXRSessionEnd() {

		animation.start();

	}

	const animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	if ( typeof self !== 'undefined' ) animation.setContext( self );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;
		xr.setAnimationLoop( callback );

		( callback === null ) ? animation.stop() : animation.start();

	};

	xr.addEventListener( 'sessionstart', onXRSessionStart );
	xr.addEventListener( 'sessionend', onXRSessionEnd );

	// Rendering

	this.render = function ( scene, camera ) {

		if ( camera !== undefined && camera.isCamera !== true ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( _isContextLost === true ) return;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		if ( xr.enabled === true && xr.isPresenting === true ) {

			if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

			camera = xr.getCamera(); // use XR camera for rendering

		}

		//
		if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

		currentRenderState = renderStates.get( scene, renderStateStack.length );
		currentRenderState.init();

		renderStateStack.push( currentRenderState );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromProjectionMatrix( _projScreenMatrix );

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		currentRenderList = renderLists.get( scene, renderListStack.length );
		currentRenderList.init();

		renderListStack.push( currentRenderList );

		projectObject( scene, camera, 0, _this.sortObjects );

		currentRenderList.finish();

		if ( _this.sortObjects === true ) {

			currentRenderList.sort( _opaqueSort, _transparentSort );

		}

		//

		if ( _clippingEnabled === true ) clipping.beginShadows();

		const shadowsArray = currentRenderState.state.shadowsArray;

		shadowMap.render( shadowsArray, scene, camera );

		if ( _clippingEnabled === true ) clipping.endShadows();

		//

		if ( this.info.autoReset === true ) this.info.reset();

		//

		background.render( currentRenderList, scene );

		// render scene

		currentRenderState.setupLights( _this.physicallyCorrectLights );

		if ( camera.isArrayCamera ) {

			const cameras = camera.cameras;

			for ( let i = 0, l = cameras.length; i < l; i ++ ) {

				const camera2 = cameras[ i ];

				renderScene( currentRenderList, scene, camera2, camera2.viewport );

			}

		} else {

			renderScene( currentRenderList, scene, camera );

		}

		//

		if ( _currentRenderTarget !== null ) {

			// resolve multisample renderbuffers to a single-sample texture if necessary

			textures.updateMultisampleRenderTarget( _currentRenderTarget );

			// Generate mipmap if we're using any kind of mipmap filtering

			textures.updateRenderTargetMipmap( _currentRenderTarget );

		}

		//

		if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

		// _gl.finish();

		bindingStates.resetDefaultState();
		_currentMaterialId = - 1;
		_currentCamera = null;

		renderStateStack.pop();

		if ( renderStateStack.length > 0 ) {

			currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

		} else {

			currentRenderState = null;

		}

		renderListStack.pop();

		if ( renderListStack.length > 0 ) {

			currentRenderList = renderListStack[ renderListStack.length - 1 ];

		} else {

			currentRenderList = null;

		}

	};

	function projectObject( object, camera, groupOrder, sortObjects ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isGroup ) {

				groupOrder = object.renderOrder;

			} else if ( object.isLOD ) {

				if ( object.autoUpdate === true ) object.update( camera );

			} else if ( object.isLight ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( object.isSkinnedMesh ) {

					// update skeleton only once in a frame

					if ( object.skeleton.frame !== info.render.frame ) {

						object.skeleton.update();
						object.skeleton.frame = info.render.frame;

					}

				}

				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let i = 0, l = groups.length; i < l; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

							}

						}

					} else if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, groupOrder, sortObjects );

		}

	}

	function renderScene( currentRenderList, scene, camera, viewport ) {

		const opaqueObjects = currentRenderList.opaque;
		const transmissiveObjects = currentRenderList.transmissive;
		const transparentObjects = currentRenderList.transparent;

		currentRenderState.setupLightsView( camera );

		if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, scene, camera );

		if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

		if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
		if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
		if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.buffers.depth.setTest( true );
		state.buffers.depth.setMask( true );
		state.buffers.color.setMask( true );

		state.setPolygonOffset( false );

	}

	function renderTransmissionPass( opaqueObjects, scene, camera ) {

		const isWebGL2 = capabilities.isWebGL2;

		if ( _transmissionRenderTarget === null ) {

			_transmissionRenderTarget = new WebGLRenderTarget( 1, 1, {
				generateMipmaps: true,
				type: utils.convert( HalfFloatType ) !== null ? HalfFloatType : UnsignedByteType,
				minFilter: LinearMipmapLinearFilter,
				samples: ( isWebGL2 && _antialias === true ) ? 4 : 0
			} );

		}

		_this.getDrawingBufferSize( _vector2 );

		if ( isWebGL2 ) {

			_transmissionRenderTarget.setSize( _vector2.x, _vector2.y );

		} else {

			_transmissionRenderTarget.setSize( floorPowerOfTwo( _vector2.x ), floorPowerOfTwo( _vector2.y ) );

		}

		//

		const currentRenderTarget = _this.getRenderTarget();
		_this.setRenderTarget( _transmissionRenderTarget );
		_this.clear();

		// Turn off the features which can affect the frag color for opaque objects pass.
		// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
		const currentToneMapping = _this.toneMapping;
		_this.toneMapping = NoToneMapping;

		renderObjects( opaqueObjects, scene, camera );

		_this.toneMapping = currentToneMapping;

		textures.updateMultisampleRenderTarget( _transmissionRenderTarget );
		textures.updateRenderTargetMipmap( _transmissionRenderTarget );

		_this.setRenderTarget( currentRenderTarget );

	}

	function renderObjects( renderList, scene, camera ) {

		const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

		for ( let i = 0, l = renderList.length; i < l; i ++ ) {

			const renderItem = renderList[ i ];

			const object = renderItem.object;
			const geometry = renderItem.geometry;
			const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
			const group = renderItem.group;

			if ( object.layers.test( camera.layers ) ) {

				renderObject( object, scene, camera, geometry, material, group );

			}

		}

	}

	function renderObject( object, scene, camera, geometry, material, group ) {

		object.onBeforeRender( _this, scene, camera, geometry, material, group );

		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

		material.onBeforeRender( _this, scene, camera, geometry, object, group );

		if ( material.transparent === true && material.side === DoubleSide ) {

			material.side = BackSide;
			material.needsUpdate = true;
			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			material.side = FrontSide;
			material.needsUpdate = true;
			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			material.side = DoubleSide;

		} else {

			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

		}

		object.onAfterRender( _this, scene, camera, geometry, material, group );

	}

	function getProgram( material, scene, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		const materialProperties = properties.get( material );

		const lights = currentRenderState.state.lights;
		const shadowsArray = currentRenderState.state.shadowsArray;

		const lightsStateVersion = lights.state.version;

		const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
		const programCacheKey = programCache.getProgramCacheKey( parameters );

		let programs = materialProperties.programs;

		// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

		materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
		materialProperties.fog = scene.fog;
		materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );

		if ( programs === undefined ) {

			// new material

			material.addEventListener( 'dispose', onMaterialDispose );

			programs = new Map();
			materialProperties.programs = programs;

		}

		let program = programs.get( programCacheKey );

		if ( program !== undefined ) {

			// early out if program and light state is identical

			if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

				updateCommonMaterialProperties( material, parameters );

				return program;

			}

		} else {

			parameters.uniforms = programCache.getUniforms( material );

			material.onBuild( object, parameters, _this );

			material.onBeforeCompile( parameters, _this );

			program = programCache.acquireProgram( parameters, programCacheKey );
			programs.set( programCacheKey, program );

			materialProperties.uniforms = parameters.uniforms;

		}

		const uniforms = materialProperties.uniforms;

		if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

			uniforms.clippingPlanes = clipping.uniform;

		}

		updateCommonMaterialProperties( material, parameters );

		// store the light setup it was created for

		materialProperties.needsLights = materialNeedsLights( material );
		materialProperties.lightsStateVersion = lightsStateVersion;

		if ( materialProperties.needsLights ) {

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.lightProbe.value = lights.state.probe;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.directionalLightShadows.value = lights.state.directionalShadow;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.spotLightShadows.value = lights.state.spotShadow;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.ltc_1.value = lights.state.rectAreaLTC1;
			uniforms.ltc_2.value = lights.state.rectAreaLTC2;
			uniforms.pointLights.value = lights.state.point;
			uniforms.pointLightShadows.value = lights.state.pointShadow;
			uniforms.hemisphereLights.value = lights.state.hemi;

			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms

		}

		const progUniforms = program.getUniforms();
		const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.currentProgram = program;
		materialProperties.uniformsList = uniformsList;

		return program;

	}

	function updateCommonMaterialProperties( material, parameters ) {

		const materialProperties = properties.get( material );

		materialProperties.outputEncoding = parameters.outputEncoding;
		materialProperties.instancing = parameters.instancing;
		materialProperties.skinning = parameters.skinning;
		materialProperties.morphTargets = parameters.morphTargets;
		materialProperties.morphNormals = parameters.morphNormals;
		materialProperties.morphColors = parameters.morphColors;
		materialProperties.morphTargetsCount = parameters.morphTargetsCount;
		materialProperties.numClippingPlanes = parameters.numClippingPlanes;
		materialProperties.numIntersection = parameters.numClipIntersection;
		materialProperties.vertexAlphas = parameters.vertexAlphas;
		materialProperties.vertexTangents = parameters.vertexTangents;
		materialProperties.toneMapping = parameters.toneMapping;

	}

	function setProgram( camera, scene, geometry, material, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		textures.resetTextureUnits();

		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;
		const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding );
		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
		const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
		const vertexTangents = !! material.normalMap && !! geometry.attributes.tangent;
		const morphTargets = !! geometry.morphAttributes.position;
		const morphNormals = !! geometry.morphAttributes.normal;
		const morphColors = !! geometry.morphAttributes.color;
		const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		const materialProperties = properties.get( material );
		const lights = currentRenderState.state.lights;

		if ( _clippingEnabled === true ) {

			if ( _localClippingEnabled === true || camera !== _currentCamera ) {

				const useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				clipping.setState( material, camera, useCache );

			}

		}

		//

		let needsProgramChange = false;

		if ( material.version === materialProperties.__version ) {

			if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

				needsProgramChange = true;

			} else if ( materialProperties.outputEncoding !== encoding ) {

				needsProgramChange = true;

			} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

				needsProgramChange = true;

			} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

				needsProgramChange = true;

			} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

				needsProgramChange = true;

			} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

				needsProgramChange = true;

			} else if ( materialProperties.envMap !== envMap ) {

				needsProgramChange = true;

			} else if ( material.fog && materialProperties.fog !== fog ) {

				needsProgramChange = true;

			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== clipping.numPlanes ||
				materialProperties.numIntersection !== clipping.numIntersection ) ) {

				needsProgramChange = true;

			} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

				needsProgramChange = true;

			} else if ( materialProperties.vertexTangents !== vertexTangents ) {

				needsProgramChange = true;

			} else if ( materialProperties.morphTargets !== morphTargets ) {

				needsProgramChange = true;

			} else if ( materialProperties.morphNormals !== morphNormals ) {

				needsProgramChange = true;

			} else if ( materialProperties.morphColors !== morphColors ) {

				needsProgramChange = true;

			} else if ( materialProperties.toneMapping !== toneMapping ) {

				needsProgramChange = true;

			} else if ( capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount ) {

				needsProgramChange = true;

			}

		} else {

			needsProgramChange = true;
			materialProperties.__version = material.version;

		}

		//

		let program = materialProperties.currentProgram;

		if ( needsProgramChange === true ) {

			program = getProgram( material, scene, object );

		}

		let refreshProgram = false;
		let refreshMaterial = false;
		let refreshLights = false;

		const p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.uniforms;

		if ( state.useProgram( program.program ) ) {

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || _currentCamera !== camera ) {

			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}

			if ( _currentCamera !== camera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {

				const uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ) {

				p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.isShadowMaterial ||
				object.isSkinnedMesh ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

		}

		// skinning and morph target uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone and morph texture must go before other textures
		// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

		if ( object.isSkinnedMesh ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			const skeleton = object.skeleton;

			if ( skeleton ) {

				if ( capabilities.floatVertexTextures ) {

					if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

				} else {

					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				}

			}

		}

		const morphAttributes = geometry.morphAttributes;

		if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined && capabilities.isWebGL2 === true ) ) {

			morphtargets.update( object, geometry, material, program );

		}


		if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

			materialProperties.receiveShadow = object.receiveShadow;
			p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

		}

		if ( refreshMaterial ) {

			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

			if ( materialProperties.needsLights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				materials.refreshFogUniforms( m_uniforms, fog );

			}

			materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

		}

		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
			material.uniformsNeedUpdate = false;

		}

		if ( material.isSpriteMaterial ) {

			p_uniforms.setValue( _gl, 'center', object.center );

		}

		// common matrices

		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		return program;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;
		uniforms.lightProbe.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.directionalLightShadows.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.pointLightShadows.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.spotLightShadows.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	function materialNeedsLights( material ) {

		return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
			material.isMeshStandardMaterial || material.isShadowMaterial ||
			( material.isShaderMaterial && material.lights === true );

	}

	this.getActiveCubeFace = function () {

		return _currentActiveCubeFace;

	};

	this.getActiveMipmapLevel = function () {

		return _currentActiveMipmapLevel;

	};

	this.getRenderTarget = function () {

		return _currentRenderTarget;

	};

	this.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {

		properties.get( renderTarget.texture ).__webglTexture = colorTexture;
		properties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;

		const renderTargetProperties = properties.get( renderTarget );
		renderTargetProperties.__hasExternalTextures = true;

		if ( renderTargetProperties.__hasExternalTextures ) {

			renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;

			if ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {

				// The multisample_render_to_texture extension doesn't work properly if there
				// are midframe flushes and an external depth buffer. Disable use of the extension.
				if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {

					console.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );
					renderTargetProperties.__useRenderToTexture = false;

				}

			}

		}

	};

	this.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {

		const renderTargetProperties = properties.get( renderTarget );
		renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
		renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;

	};

	this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

		_currentRenderTarget = renderTarget;
		_currentActiveCubeFace = activeCubeFace;
		_currentActiveMipmapLevel = activeMipmapLevel;

		let useDefaultFramebuffer = true;

		if ( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );

			if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {

				// We need to make sure to rebind the framebuffer.
				state.bindFramebuffer( 36160, null );
				useDefaultFramebuffer = false;

			} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {

				textures.setupRenderTarget( renderTarget );

			} else if ( renderTargetProperties.__hasExternalTextures ) {

				// Color and depth texture must be rebound in order for the swapchain to update.
				textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );

			}

		}

		let framebuffer = null;
		let isCube = false;
		let isRenderTarget3D = false;

		if ( renderTarget ) {

			const texture = renderTarget.texture;

			if ( texture.isData3DTexture || texture.isDataArrayTexture ) {

				isRenderTarget3D = true;

			}

			const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				framebuffer = __webglFramebuffer[ activeCubeFace ];
				isCube = true;

			} else if ( ( capabilities.isWebGL2 && renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {

				framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

			} else {

				framebuffer = __webglFramebuffer;

			}

			_currentViewport.copy( renderTarget.viewport );
			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

		} else {

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
			_currentScissorTest = _scissorTest;

		}

		const framebufferBound = state.bindFramebuffer( 36160, framebuffer );

		if ( framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer ) {

			state.drawBuffers( renderTarget, framebuffer );

		}

		state.viewport( _currentViewport );
		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		if ( isCube ) {

			const textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

		} else if ( isRenderTarget3D ) {

			const textureProperties = properties.get( renderTarget.texture );
			const layer = activeCubeFace || 0;
			_gl.framebufferTextureLayer( 36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

		}

		_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

			framebuffer = framebuffer[ activeCubeFaceIndex ];

		}

		if ( framebuffer ) {

			state.bindFramebuffer( 36160, framebuffer );

			try {

				const texture = renderTarget.texture;
				const textureFormat = texture.format;
				const textureType = texture.type;

				if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

				if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)
					! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					! halfFloatSupportedByExt ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

				if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

					_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

				}

			} finally {

				// restore framebuffer of current render target if necessary

				const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
				state.bindFramebuffer( 36160, framebuffer );

			}

		}

	};

	this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

		if ( texture.isFramebufferTexture !== true ) {

			console.error( 'THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.' );
			return;

		}

		const levelScale = Math.pow( 2, - level );
		const width = Math.floor( texture.image.width * levelScale );
		const height = Math.floor( texture.image.height * levelScale );

		textures.setTexture2D( texture, 0 );

		_gl.copyTexSubImage2D( 3553, level, 0, 0, position.x, position.y, width, height );

		state.unbindTexture();

	};

	this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

		const width = srcTexture.image.width;
		const height = srcTexture.image.height;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );

		textures.setTexture2D( dstTexture, 0 );

		// As another texture upload may have changed pixelStorei
		// parameters, make sure they are correct for the dstTexture
		_gl.pixelStorei( 37440, dstTexture.flipY );
		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		if ( srcTexture.isDataTexture ) {

			_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

		} else {

			if ( srcTexture.isCompressedTexture ) {

				_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

			} else {

				_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

			}

		}

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );

		state.unbindTexture();

	};

	this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

		if ( _this.isWebGL1Renderer ) {

			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
			return;

		}

		const width = sourceBox.max.x - sourceBox.min.x + 1;
		const height = sourceBox.max.y - sourceBox.min.y + 1;
		const depth = sourceBox.max.z - sourceBox.min.z + 1;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );
		let glTarget;

		if ( dstTexture.isData3DTexture ) {

			textures.setTexture3D( dstTexture, 0 );
			glTarget = 32879;

		} else if ( dstTexture.isDataArrayTexture ) {

			textures.setTexture2DArray( dstTexture, 0 );
			glTarget = 35866;

		} else {

			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
			return;

		}

		_gl.pixelStorei( 37440, dstTexture.flipY );
		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		const unpackRowLen = _gl.getParameter( 3314 );
		const unpackImageHeight = _gl.getParameter( 32878 );
		const unpackSkipPixels = _gl.getParameter( 3316 );
		const unpackSkipRows = _gl.getParameter( 3315 );
		const unpackSkipImages = _gl.getParameter( 32877 );

		const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;

		_gl.pixelStorei( 3314, image.width );
		_gl.pixelStorei( 32878, image.height );
		_gl.pixelStorei( 3316, sourceBox.min.x );
		_gl.pixelStorei( 3315, sourceBox.min.y );
		_gl.pixelStorei( 32877, sourceBox.min.z );

		if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

			_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );

		} else {

			if ( srcTexture.isCompressedTexture ) {

				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );
				_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );

			} else {

				_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );

			}

		}

		_gl.pixelStorei( 3314, unpackRowLen );
		_gl.pixelStorei( 32878, unpackImageHeight );
		_gl.pixelStorei( 3316, unpackSkipPixels );
		_gl.pixelStorei( 3315, unpackSkipRows );
		_gl.pixelStorei( 32877, unpackSkipImages );

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

		state.unbindTexture();

	};

	this.initTexture = function ( texture ) {

		textures.setTexture2D( texture, 0 );

		state.unbindTexture();

	};

	this.resetState = function () {

		_currentActiveCubeFace = 0;
		_currentActiveMipmapLevel = 0;
		_currentRenderTarget = null;

		state.reset();
		bindingStates.reset();

	};

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

	}

}

WebGLRenderer.prototype.isWebGLRenderer = true;

class WebGL1Renderer extends WebGLRenderer {}

WebGL1Renderer.prototype.isWebGL1Renderer = true;

class FogExp2 {

	constructor( color, density = 0.00025 ) {

		this.name = '';

		this.color = new Color( color );
		this.density = density;

	}

	clone() {

		return new FogExp2( this.color, this.density );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};

	}

}

FogExp2.prototype.isFogExp2 = true;

class Fog {

	constructor( color, near = 1, far = 1000 ) {

		this.name = '';

		this.color = new Color( color );

		this.near = near;
		this.far = far;

	}

	clone() {

		return new Fog( this.color, this.near, this.far );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	}

}

Fog.prototype.isFog = true;

class Scene extends Object3D {

	constructor() {

		super();

		this.type = 'Scene';

		this.background = null;
		this.environment = null;
		this.fog = null;

		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		return data;

	}

}

Scene.prototype.isScene = true;

class InterleavedBuffer {

	constructor( array, stride ) {

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

		this.uuid = generateUUID();

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	copy( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( let i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	set( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	}

	clone( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		}

		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		const ib = new this.constructor( array, this.stride );
		ib.setUsage( this.usage );

		return ib;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	toJSON( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		// generate UUID for array buffer if necessary

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );

		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};

	}

}

InterleavedBuffer.prototype.isInterleavedBuffer = true;

const _vector$6 = /*@__PURE__*/ new Vector3();

class InterleavedBufferAttribute {

	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

		this.name = '';

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;

	}

	get count() {

		return this.data.count;

	}

	get array() {

		return this.data.array;

	}

	set needsUpdate( value ) {

		this.data.needsUpdate = value;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.applyMatrix4( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.applyNormalMatrix( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.transformDirection( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	setX( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	}

	setY( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	}

	setZ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	}

	setW( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	}

	getX( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	}

	getY( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	}

	getZ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	}

	getW( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	}

	setXY( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

	clone( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

		} else {

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			}

			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		}

	}

	toJSON( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			// deinterleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};

		} else {

			// save as true interlaved attribtue

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			}

			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};

		}

	}

}

InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;

class SpriteMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'SpriteMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.rotation = 0;

		this.sizeAttenuation = true;

		this.transparent = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		return this;

	}

}

SpriteMaterial.prototype.isSpriteMaterial = true;

let _geometry;

const _intersectPoint = /*@__PURE__*/ new Vector3();
const _worldScale = /*@__PURE__*/ new Vector3();
const _mvPosition = /*@__PURE__*/ new Vector3();

const _alignedPosition = /*@__PURE__*/ new Vector2();
const _rotatedPosition = /*@__PURE__*/ new Vector2();
const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();

const _vA = /*@__PURE__*/ new Vector3();
const _vB = /*@__PURE__*/ new Vector3();
const _vC = /*@__PURE__*/ new Vector3();

const _uvA = /*@__PURE__*/ new Vector2();
const _uvB = /*@__PURE__*/ new Vector2();
const _uvC = /*@__PURE__*/ new Vector2();

class Sprite extends Object3D {

	constructor( material ) {

		super();

		this.type = 'Sprite';

		if ( _geometry === undefined ) {

			_geometry = new BufferGeometry();

			const float32Array = new Float32Array( [
				- 0.5, - 0.5, 0, 0, 0,
				0.5, - 0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				- 0.5, 0.5, 0, 0, 1
			] );

			const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

			_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

		}

		this.geometry = _geometry;
		this.material = ( material !== undefined ) ? material : new SpriteMaterial();

		this.center = new Vector2( 0.5, 0.5 );

	}

	raycast( raycaster, intersects ) {

		if ( raycaster.camera === null ) {

			console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		}

		_worldScale.setFromMatrixScale( this.matrixWorld );

		_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
		this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

		if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			_worldScale.multiplyScalar( - _mvPosition.z );

		}

		const rotation = this.material.rotation;
		let sin, cos;

		if ( rotation !== 0 ) {

			cos = Math.cos( rotation );
			sin = Math.sin( rotation );

		}

		const center = this.center;

		transformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

		_uvA.set( 0, 0 );
		_uvB.set( 1, 0 );
		_uvC.set( 1, 1 );

		// check first triangle
		let intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );

		if ( intersect === null ) {

			// check second triangle
			transformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			_uvB.set( 0, 1 );

			intersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );
			if ( intersect === null ) {

				return;

			}

		}

		const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			point: _intersectPoint.clone(),
			uv: Triangle.getUV( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),
			face: null,
			object: this

		} );

	}

	copy( source ) {

		super.copy( source );

		if ( source.center !== undefined ) this.center.copy( source.center );

		this.material = source.material;

		return this;

	}

}

Sprite.prototype.isSprite = true;

function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

	// compute position in camera space
	_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	// to check if rotation is not zero
	if ( sin !== undefined ) {

		_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
		_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

	} else {

		_rotatedPosition.copy( _alignedPosition );

	}


	vertexPosition.copy( mvPosition );
	vertexPosition.x += _rotatedPosition.x;
	vertexPosition.y += _rotatedPosition.y;

	// transform to world space
	vertexPosition.applyMatrix4( _viewWorldMatrix );

}

const _v1$2 = /*@__PURE__*/ new Vector3();
const _v2$1 = /*@__PURE__*/ new Vector3();

class LOD extends Object3D {

	constructor() {

		super();

		this._currentLevel = 0;

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			},
			isLOD: {
				value: true,
			}
		} );

		this.autoUpdate = true;

	}

	copy( source ) {

		super.copy( source, false );

		const levels = source.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		this.autoUpdate = source.autoUpdate;

		return this;

	}

	addLevel( object, distance = 0 ) {

		distance = Math.abs( distance );

		const levels = this.levels;

		let l;

		for ( l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

		return this;

	}

	getCurrentLevel() {

		return this._currentLevel;

	}

	getObjectForDistance( distance ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance < levels[ i ].distance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		}

		return null;

	}

	raycast( raycaster, intersects ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			_v1$2.setFromMatrixPosition( this.matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( _v1$2 );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		}

	}

	update( camera ) {

		const levels = this.levels;

		if ( levels.length > 1 ) {

			_v1$2.setFromMatrixPosition( camera.matrixWorld );
			_v2$1.setFromMatrixPosition( this.matrixWorld );

			const distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;

			levels[ 0 ].object.visible = true;

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance >= levels[ i ].distance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			this._currentLevel = i - 1;

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.autoUpdate === false ) data.object.autoUpdate = false;

		data.object.levels = [];

		const levels = this.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	}

}

const _basePosition = /*@__PURE__*/ new Vector3();

const _skinIndex = /*@__PURE__*/ new Vector4();
const _skinWeight = /*@__PURE__*/ new Vector4();

const _vector$5 = /*@__PURE__*/ new Vector3();
const _matrix = /*@__PURE__*/ new Matrix4();

class SkinnedMesh extends Mesh {

	constructor( geometry, material ) {

		super( geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

	}

	copy( source ) {

		super.copy( source );

		this.bindMode = source.bindMode;
		this.bindMatrix.copy( source.bindMatrix );
		this.bindMatrixInverse.copy( source.bindMatrixInverse );

		this.skeleton = source.skeleton;

		return this;

	}

	bind( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.copy( bindMatrix ).invert();

	}

	pose() {

		this.skeleton.pose();

	}

	normalizeSkinWeights() {

		const vector = new Vector4();

		const skinWeight = this.geometry.attributes.skinWeight;

		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.fromBufferAttribute( skinWeight, i );

			const scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.bindMode === 'attached' ) {

			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

		} else if ( this.bindMode === 'detached' ) {

			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	}

	boneTransform( index, target ) {

		const skeleton = this.skeleton;
		const geometry = this.geometry;

		_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
		_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

		_basePosition.copy( target ).applyMatrix4( this.bindMatrix );

		target.set( 0, 0, 0 );

		for ( let i = 0; i < 4; i ++ ) {

			const weight = _skinWeight.getComponent( i );

			if ( weight !== 0 ) {

				const boneIndex = _skinIndex.getComponent( i );

				_matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

				target.addScaledVector( _vector$5.copy( _basePosition ).applyMatrix4( _matrix ), weight );

			}

		}

		return target.applyMatrix4( this.bindMatrixInverse );

	}

}

SkinnedMesh.prototype.isSkinnedMesh = true;

class Bone extends Object3D {

	constructor() {

		super();

		this.type = 'Bone';

	}

}

Bone.prototype.isBone = true;

class DataTexture extends Texture {

	constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { data: data, width: width, height: height };

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

DataTexture.prototype.isDataTexture = true;

const _offsetMatrix = /*@__PURE__*/ new Matrix4();
const _identityMatrix = /*@__PURE__*/ new Matrix4();

class Skeleton {

	constructor( bones = [], boneInverses = [] ) {

		this.uuid = generateUUID();

		this.bones = bones.slice( 0 );
		this.boneInverses = boneInverses;
		this.boneMatrices = null;

		this.boneTexture = null;
		this.boneTextureSize = 0;

		this.frame = - 1;

		this.init();

	}

	init() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		this.boneMatrices = new Float32Array( bones.length * 16 );

		// calculate inverse bone matrices if necessary

		if ( boneInverses.length === 0 ) {

			this.calculateInverses();

		} else {

			// handle special case

			if ( bones.length !== boneInverses.length ) {

				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

				this.boneInverses = [];

				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	calculateInverses() {

		this.boneInverses.length = 0;

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.copy( this.bones[ i ].matrixWorld ).invert();

			}

			this.boneInverses.push( inverse );

		}

	}

	pose() {

		// recover the bind-time world matrices

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.copy( bone.parent.matrixWorld ).invert();
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	}

	update() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;
		const boneMatrices = this.boneMatrices;
		const boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( let i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== null ) {

			boneTexture.needsUpdate = true;

		}

	}

	clone() {

		return new Skeleton( this.bones, this.boneInverses );

	}

	computeBoneTexture() {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

		let size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = ceilPowerOfTwo( size );
		size = Math.max( size, 4 );

		const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
		boneMatrices.set( this.boneMatrices ); // copy current values

		const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
		boneTexture.needsUpdate = true;

		this.boneMatrices = boneMatrices;
		this.boneTexture = boneTexture;
		this.boneTextureSize = size;

		return this;

	}

	getBoneByName( name ) {

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	}

	dispose( ) {

		if ( this.boneTexture !== null ) {

			this.boneTexture.dispose();

			this.boneTexture = null;

		}

	}

	fromJSON( json, bones ) {

		this.uuid = json.uuid;

		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

			const uuid = json.bones[ i ];
			let bone = bones[ uuid ];

			if ( bone === undefined ) {

				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
				bone = new Bone();

			}

			this.bones.push( bone );
			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

		}

		this.init();

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};

		data.uuid = this.uuid;

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		for ( let i = 0, l = bones.length; i < l; i ++ ) {

			const bone = bones[ i ];
			data.bones.push( bone.uuid );

			const boneInverse = boneInverses[ i ];
			data.boneInverses.push( boneInverse.toArray() );

		}

		return data;

	}

}

class InstancedBufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

		if ( typeof normalized === 'number' ) {

			meshPerAttribute = normalized;

			normalized = false;

			console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

		}

		super( array, itemSize, normalized );

		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.meshPerAttribute = this.meshPerAttribute;

		data.isInstancedBufferAttribute = true;

		return data;

	}

}

InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();

const _instanceIntersects = [];

const _mesh = /*@__PURE__*/ new Mesh();

class InstancedMesh extends Mesh {

	constructor( geometry, material, count ) {

		super( geometry, material );

		this.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );
		this.instanceColor = null;

		this.count = count;

		this.frustumCulled = false;

	}

	copy( source ) {

		super.copy( source );

		this.instanceMatrix.copy( source.instanceMatrix );

		if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

		this.count = source.count;

		return this;

	}

	getColorAt( index, color ) {

		color.fromArray( this.instanceColor.array, index * 3 );

	}

	getMatrixAt( index, matrix ) {

		matrix.fromArray( this.instanceMatrix.array, index * 16 );

	}

	raycast( raycaster, intersects ) {

		const matrixWorld = this.matrixWorld;
		const raycastTimes = this.count;

		_mesh.geometry = this.geometry;
		_mesh.material = this.material;

		if ( _mesh.material === undefined ) return;

		for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			// calculate the world matrix for each instance

			this.getMatrixAt( instanceId, _instanceLocalMatrix );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// the mesh represents this single instance

			_mesh.matrixWorld = _instanceWorldMatrix;

			_mesh.raycast( raycaster, _instanceIntersects );

			// process the result of raycast

			for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

				const intersect = _instanceIntersects[ i ];
				intersect.instanceId = instanceId;
				intersect.object = this;
				intersects.push( intersect );

			}

			_instanceIntersects.length = 0;

		}

	}

	setColorAt( index, color ) {

		if ( this.instanceColor === null ) {

			this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );

		}

		color.toArray( this.instanceColor.array, index * 3 );

	}

	setMatrixAt( index, matrix ) {

		matrix.toArray( this.instanceMatrix.array, index * 16 );

	}

	updateMorphTargets() {

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

InstancedMesh.prototype.isInstancedMesh = true;

class LineBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		return this;

	}

}

LineBasicMaterial.prototype.isLineBasicMaterial = true;

const _start$1 = /*@__PURE__*/ new Vector3();
const _end$1 = /*@__PURE__*/ new Vector3();
const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
const _ray$1 = /*@__PURE__*/ new Ray();
const _sphere$1 = /*@__PURE__*/ new Sphere();

class Line extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

		super();

		this.type = 'Line';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source ) {

		super.copy( source );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	computeLineDistances() {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [ 0 ];

				for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

					_start$1.fromBufferAttribute( positionAttribute, i - 1 );
					_end$1.fromBufferAttribute( positionAttribute, i );

					lineDistances[ i ] = lineDistances[ i - 1 ];
					lineDistances[ i ] += _start$1.distanceTo( _end$1 );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$1.copy( geometry.boundingSphere );
		_sphere$1.applyMatrix4( matrixWorld );
		_sphere$1.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

		//

		_inverseMatrix$1.copy( matrixWorld ).invert();
		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const vStart = new Vector3();
		const vEnd = new Vector3();
		const interSegment = new Vector3();
		const interRay = new Vector3();
		const step = this.isLineSegments ? 2 : 1;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end - 1; i < l; i += step ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );

					vStart.fromBufferAttribute( positionAttribute, a );
					vEnd.fromBufferAttribute( positionAttribute, b );

					const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end - 1; i < l; i += step ) {

					vStart.fromBufferAttribute( positionAttribute, i );
					vEnd.fromBufferAttribute( positionAttribute, i + 1 );

					const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

}

Line.prototype.isLine = true;

const _start = /*@__PURE__*/ new Vector3();
const _end = /*@__PURE__*/ new Vector3();

class LineSegments extends Line {

	constructor( geometry, material ) {

		super( geometry, material );

		this.type = 'LineSegments';

	}

	computeLineDistances() {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [];

				for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

					_start.fromBufferAttribute( positionAttribute, i );
					_end.fromBufferAttribute( positionAttribute, i + 1 );

					lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
					lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

		return this;

	}

}

LineSegments.prototype.isLineSegments = true;

class LineLoop extends Line {

	constructor( geometry, material ) {

		super( geometry, material );

		this.type = 'LineLoop';

	}

}

LineLoop.prototype.isLineLoop = true;

class PointsMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		return this;

	}

}

PointsMaterial.prototype.isPointsMaterial = true;

const _inverseMatrix = /*@__PURE__*/ new Matrix4();
const _ray = /*@__PURE__*/ new Ray();
const _sphere = /*@__PURE__*/ new Sphere();
const _position$2 = /*@__PURE__*/ new Vector3();

class Points extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

		super();

		this.type = 'Points';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source ) {

		super.copy( source );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );
		_sphere.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i ++ ) {

					const a = index.getX( i );

					_position$2.fromBufferAttribute( positionAttribute, a );

					testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end; i < l; i ++ ) {

					_position$2.fromBufferAttribute( positionAttribute, i );

					testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			}

		} else {

			console.error( 'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

}

Points.prototype.isPoints = true;

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	const rayPointDistanceSq = _ray.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		const intersectPoint = new Vector3();

		_ray.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			object: object

		} );

	}

}

class VideoTexture extends Texture {

	constructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

		this.generateMipmaps = false;

		const scope = this;

		function updateVideo() {

			scope.needsUpdate = true;
			video.requestVideoFrameCallback( updateVideo );

		}

		if ( 'requestVideoFrameCallback' in video ) {

			video.requestVideoFrameCallback( updateVideo );

		}

	}

	clone() {

		return new this.constructor( this.image ).copy( this );

	}

	update() {

		const video = this.image;
		const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

		if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

			this.needsUpdate = true;

		}

	}

}

VideoTexture.prototype.isVideoTexture = true;

class FramebufferTexture extends Texture {

	constructor( width, height, format ) {

		super( { width, height } );

		this.format = format;

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.generateMipmaps = false;

		this.needsUpdate = true;

	}

}

FramebufferTexture.prototype.isFramebufferTexture = true;

class CompressedTexture extends Texture {

	constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

}

CompressedTexture.prototype.isCompressedTexture = true;

class CanvasTexture extends Texture {

	constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	}

}

CanvasTexture.prototype.isCanvasTexture = true;

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

class Curve {

	constructor() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint( /* t, optionalTarget */ ) {

		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		return null;

	}

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getPoint( t, optionalTarget );

	}

	// Get sequence of points using getPoint( t )

	getPoints( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	}

	// Get sequence of points using getPointAt( u )

	getSpacedPoints( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	}

	// Get total curve arc length

	getLength() {

		const lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	}

	// Get list of cumulative segment lengths

	getLengths( divisions = this.arcLengthDivisions ) {

		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {

			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		const cache = [];
		let current, last = this.getPoint( 0 );
		let sum = 0;

		cache.push( 0 );

		for ( let p = 1; p <= divisions; p ++ ) {

			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	}

	updateArcLengths() {

		this.needsUpdate = true;
		this.getLengths();

	}

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping( u, distance ) {

		const arcLengths = this.getLengths();

		let i = 0;
		const il = arcLengths.length;

		let targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		// binary search for the index with largest value smaller than target u distance

		let low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		if ( arcLengths[ i ] === targetArcLength ) {

			return i / ( il - 1 );

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		const lengthBefore = arcLengths[ i ];
		const lengthAfter = arcLengths[ i + 1 ];

		const segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		const t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	}

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent( t, optionalTarget ) {

		const delta = 0.0001;
		let t1 = t - delta;
		let t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		const pt1 = this.getPoint( t1 );
		const pt2 = this.getPoint( t2 );

		const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

		tangent.copy( pt2 ).sub( pt1 ).normalize();

		return tangent;

	}

	getTangentAt( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getTangent( t, optionalTarget );

	}

	computeFrenetFrames( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		const normal = new Vector3();

		const tangents = [];
		const normals = [];
		const binormals = [];

		const vec = new Vector3();
		const mat = new Matrix4();

		// compute the tangent vectors for each segment on the curve

		for ( let i = 0; i <= segments; i ++ ) {

			const u = i / segments;

			tangents[ i ] = this.getTangentAt( u, new Vector3() );

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		let min = Number.MAX_VALUE;
		const tx = Math.abs( tangents[ 0 ].x );
		const ty = Math.abs( tangents[ 0 ].y );
		const tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( let i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( let i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.arcLengthDivisions = source.arcLengthDivisions;

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};

		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;

		return data;

	}

	fromJSON( json ) {

		this.arcLengthDivisions = json.arcLengthDivisions;

		return this;

	}

}

class EllipseCurve extends Curve {

	constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

		super();

		this.type = 'EllipseCurve';

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;

		this.aRotation = aRotation;

	}

	getPoint( t, optionalTarget ) {

		const point = optionalTarget || new Vector2();

		const twoPi = Math.PI * 2;
		let deltaAngle = this.aEndAngle - this.aStartAngle;
		const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		const angle = this.aStartAngle + t * deltaAngle;
		let x = this.aX + this.xRadius * Math.cos( angle );
		let y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			const cos = Math.cos( this.aRotation );
			const sin = Math.sin( this.aRotation );

			const tx = x - this.aX;
			const ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	}

	copy( source ) {

		super.copy( source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	}

}

EllipseCurve.prototype.isEllipseCurve = true;

class ArcCurve extends EllipseCurve {

	constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.type = 'ArcCurve';

	}

}

ArcCurve.prototype.isArcCurve = true;

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {

	let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			const t2 = t * t;
			const t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

const tmp = new Vector3();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

class CatmullRomCurve3 extends Curve {

	constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

		super();

		this.type = 'CatmullRomCurve3';

		this.points = points;
		this.closed = closed;
		this.curveType = curveType;
		this.tension = tension;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const points = this.points;
		const l = points.length;

		const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		let intPoint = Math.floor( p );
		let weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		let p0, p3; // 4 points (p1 & p2 defined below)

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		const p1 = points[ intPoint % l ];
		const p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	}

}

CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

/**
 * Bezier Curves formulas obtained from
 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
 */

function CatmullRom( t, p0, p1, p2, p3 ) {

	const v0 = ( p2 - p0 ) * 0.5;
	const v1 = ( p3 - p1 ) * 0.5;
	const t2 = t * t;
	const t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	const k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}

class CubicBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

		super();

		this.type = 'CubicBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

CubicBezierCurve.prototype.isCubicBezierCurve = true;

class CubicBezierCurve3 extends Curve {

	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

		super();

		this.type = 'CubicBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

class LineCurve extends Curve {

	constructor( v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.type = 'LineCurve';

		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget ) {

		const tangent = optionalTarget || new Vector2();

		tangent.copy( this.v2 ).sub( this.v1 ).normalize();

		return tangent;

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

LineCurve.prototype.isLineCurve = true;

class LineCurve3 extends Curve {

	constructor( v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		this.type = 'LineCurve3';
		this.isLineCurve3 = true;

		this.v1 = v1;
		this.v2 = v2;

	}
	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}
	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}
	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}
	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}
	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class QuadraticBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

class QuadraticBezierCurve3 extends Curve {

	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

class SplineCurve extends Curve {

	constructor( points = [] ) {

		super();

		this.type = 'SplineCurve';

		this.points = points;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const points = this.points;
		const p = ( points.length - 1 ) * t;

		const intPoint = Math.floor( p );
		const weight = p - intPoint;

		const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		const p1 = points[ intPoint ];
		const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	}

}

SplineCurve.prototype.isSplineCurve = true;

var Curves = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArcCurve: ArcCurve,
	CatmullRomCurve3: CatmullRomCurve3,
	CubicBezierCurve: CubicBezierCurve,
	CubicBezierCurve3: CubicBezierCurve3,
	EllipseCurve: EllipseCurve,
	LineCurve: LineCurve,
	LineCurve3: LineCurve3,
	QuadraticBezierCurve: QuadraticBezierCurve,
	QuadraticBezierCurve3: QuadraticBezierCurve3,
	SplineCurve: SplineCurve
});

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

class CurvePath extends Curve {

	constructor() {

		super();

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	add( curve ) {

		this.curves.push( curve );

	}

	closePath() {

		// Add a line curve if start and end of lines are not connected
		const startPoint = this.curves[ 0 ].getPoint( 0 );
		const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new LineCurve( endPoint, startPoint ) );

		}

	}

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint( t, optionalTarget ) {

		const d = t * this.getLength();
		const curveLengths = this.getCurveLengths();
		let i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				const diff = curveLengths[ i ] - d;
				const curve = this.curves[ i ];

				const segmentLength = curve.getLength();
				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u, optionalTarget );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	}

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength() {

		const lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	}

	// cacheLengths must be recalculated.
	updateArcLengths() {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();

	}

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		const lengths = [];
		let sums = 0;

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	}

	getSpacedPoints( divisions = 40 ) {

		const points = [];

		for ( let i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	getPoints( divisions = 12 ) {

		const points = [];
		let last;

		for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

			const curve = curves[ i ];
			const resolution = curve.isEllipseCurve ? divisions * 2
				: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1
					: curve.isSplineCurve ? divisions * curve.points.length
						: divisions;

			const pts = curve.getPoints( resolution );

			for ( let j = 0; j < pts.length; j ++ ) {

				const point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	copy( source ) {

		super.copy( source );

		this.curves = [];

		for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

			const curve = source.curves[ i ];

			this.curves.push( curve.clone() );

		}

		this.autoClose = source.autoClose;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.autoClose = this.autoClose;
		data.curves = [];

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			const curve = this.curves[ i ];
			data.curves.push( curve.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.autoClose = json.autoClose;
		this.curves = [];

		for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

			const curve = json.curves[ i ];
			this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

		}

		return this;

	}

}

class Path extends CurvePath {

	constructor( points ) {

		super();
		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	setFromPoints( points ) {

		this.moveTo( points[ 0 ].x, points[ 0 ].y );

		for ( let i = 1, l = points.length; i < l; i ++ ) {

			this.lineTo( points[ i ].x, points[ i ].y );

		}

		return this;

	}

	moveTo( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		return this;

	}

	lineTo( x, y ) {

		const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		const curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		const curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	splineThru( pts /*Array of Vector*/ ) {

		const npts = [ this.currentPoint.clone() ].concat( pts );

		const curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

		return this;

	}

	arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		return this;

	}

	absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			const firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		const lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

		return this;

	}

	copy( source ) {

		super.copy( source );

		this.currentPoint.copy( source.currentPoint );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.currentPoint = this.currentPoint.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.currentPoint.fromArray( json.currentPoint );

		return this;

	}

}

class LatheGeometry extends BufferGeometry {

	constructor( points = [ new Vector2( 0, 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, - 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {

		super();

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments );

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = clamp( phiLength, 0, Math.PI * 2 );

		// buffers

		const indices = [];
		const vertices = [];
		const uvs = [];
		const initNormals = [];
		const normals = [];

		// helper variables

		const inverseSegments = 1.0 / segments;
		const vertex = new Vector3();
		const uv = new Vector2();
		const normal = new Vector3();
		const curNormal = new Vector3();
		const prevNormal = new Vector3();
		let dx = 0;
		let dy = 0;

		// pre-compute normals for initial "meridian"

		for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

			switch ( j ) {

				case 0:				// special handling for 1st vertex on path

					dx = points[ j + 1 ].x - points[ j ].x;
					dy = points[ j + 1 ].y - points[ j ].y;

					normal.x = dy * 1.0;
					normal.y = - dx;
					normal.z = dy * 0.0;

					prevNormal.copy( normal );

					normal.normalize();

					initNormals.push( normal.x, normal.y, normal.z );

					break;

				case ( points.length - 1 ):	// special handling for last Vertex on path

					initNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );

					break;

				default:			// default handling for all vertices in between

					dx = points[ j + 1 ].x - points[ j ].x;
					dy = points[ j + 1 ].y - points[ j ].y;

					normal.x = dy * 1.0;
					normal.y = - dx;
					normal.z = dy * 0.0;

					curNormal.copy( normal );

					normal.x += prevNormal.x;
					normal.y += prevNormal.y;
					normal.z += prevNormal.z;

					normal.normalize();

					initNormals.push( normal.x, normal.y, normal.z );

					prevNormal.copy( curNormal );

			}

		}

		// generate vertices, uvs and normals

		for ( let i = 0; i <= segments; i ++ ) {

			const phi = phiStart + i * inverseSegments * phiLength;

			const sin = Math.sin( phi );
			const cos = Math.cos( phi );

			for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );

				// normal

				const x = initNormals[ 3 * j + 0 ] * sin;
				const y = initNormals[ 3 * j + 1 ];
				const z = initNormals[ 3 * j + 0 ] * cos;

				normals.push( x, y, z );

			}

		}

		// indices

		for ( let i = 0; i < segments; i ++ ) {

			for ( let j = 0; j < ( points.length - 1 ); j ++ ) {

				const base = j + i * points.length;

				const a = base;
				const b = base + points.length;
				const c = base + points.length + 1;
				const d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( c, d, b );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

	}

	static fromJSON( data ) {

		return new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );

	}

}

class CapsuleGeometry extends LatheGeometry {

	constructor( radius = 1, length = 1, capSegments = 4, radialSegments = 8 ) {

		const path = new Path();
		path.absarc( 0, - length / 2, radius, Math.PI * 1.5, 0 );
		path.absarc( 0, length / 2, radius, 0, Math.PI * 0.5 );

		super( path.getPoints( capSegments ), radialSegments );

		this.type = 'CapsuleGeometry';

		this.parameters = {
			radius: radius,
			height: length,
			capSegments: capSegments,
			radialSegments: radialSegments,
		};

	}

	static fromJSON( data ) {

		return new CapsuleGeometry( data.radius, data.length, data.capSegments, data.radialSegments );

	}

}

class CircleGeometry extends BufferGeometry {

	constructor( radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		segments = Math.max( 3, segments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( let i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	static fromJSON( data ) {

		return new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );

	}

}

class CylinderGeometry extends BufferGeometry {

	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();
		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		const scope = this;

		radialSegments = Math.floor( radialSegments );
		heightSegments = Math.floor( heightSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			const normal = new Vector3();
			const vertex = new Vector3();

			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( let y = 0; y <= heightSegments; y ++ ) {

				const indexRow = [];

				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;

					const theta = u * thetaLength + thetaStart;

					const sinTheta = Math.sin( theta );
					const cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				for ( let y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					const a = indexArray[ y ][ x ];
					const b = indexArray[ y + 1 ][ x ];
					const c = indexArray[ y + 1 ][ x + 1 ];
					const d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			// save the index of the first center vertex
			const centerIndexStart = index;

			const uv = new Vector2();
			const vertex = new Vector3();

			let groupCount = 0;

			const radius = ( top === true ) ? radiusTop : radiusBottom;
			const sign = ( top === true ) ? 1 : - 1;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( let x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex
			const centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( let x = 0; x <= radialSegments; x ++ ) {

				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;

				const cosTheta = Math.cos( theta );
				const sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

	static fromJSON( data ) {

		return new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

class ConeGeometry extends CylinderGeometry {

	constructor( radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	static fromJSON( data ) {

		return new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

class PolyhedronGeometry extends BufferGeometry {

	constructor( vertices = [], indices = [], radius = 1, detail = 0 ) {

		super();

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			// iterate over all faces and apply a subdivison with the given detail value

			for ( let i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for ( let i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				const aj = a.clone().lerp( c, i / cols );
				const bj = b.clone().lerp( c, i / cols );

				const rows = cols - i;

				for ( let j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( let i = 0; i < cols; i ++ ) {

				for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					const k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function applyRadius( radius ) {

			const vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			const vertex = new Vector3();

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				const v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( let i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				const x0 = uvBuffer[ i + 0 ];
				const x1 = uvBuffer[ i + 2 ];
				const x2 = uvBuffer[ i + 4 ];

				const max = Math.max( x0, x1, x2 );
				const min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			const stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			const centroid = new Vector3();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				const azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	static fromJSON( data ) {

		return new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );

	}

}

class DodecahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;
		const r = 1 / t;

		const vertices = [

			// (±1, ±1, ±1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, ±1/φ, ±φ)
			0, - r, - t, 0, - r, t,
			0, r, - t, 0, r, t,

			// (±1/φ, ±φ, 0)
			- r, - t, 0, - r, t, 0,
			r, - t, 0, r, t, 0,

			// (±φ, 0, ±1/φ)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		const indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		super( vertices, indices, radius, detail );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new DodecahedronGeometry( data.radius, data.detail );

	}

}

const _v0 = new Vector3();
const _v1$1 = new Vector3();
const _normal = new Vector3();
const _triangle = new Triangle();

class EdgesGeometry extends BufferGeometry {

	constructor( geometry = null, thresholdAngle = 1 ) {

		super();
		this.type = 'EdgesGeometry';

		this.parameters = {
			geometry: geometry,
			thresholdAngle: thresholdAngle
		};

		if ( geometry !== null ) {

			const precisionPoints = 4;
			const precision = Math.pow( 10, precisionPoints );
			const thresholdDot = Math.cos( DEG2RAD * thresholdAngle );

			const indexAttr = geometry.getIndex();
			const positionAttr = geometry.getAttribute( 'position' );
			const indexCount = indexAttr ? indexAttr.count : positionAttr.count;

			const indexArr = [ 0, 0, 0 ];
			const vertKeys = [ 'a', 'b', 'c' ];
			const hashes = new Array( 3 );

			const edgeData = {};
			const vertices = [];
			for ( let i = 0; i < indexCount; i += 3 ) {

				if ( indexAttr ) {

					indexArr[ 0 ] = indexAttr.getX( i );
					indexArr[ 1 ] = indexAttr.getX( i + 1 );
					indexArr[ 2 ] = indexAttr.getX( i + 2 );

				} else {

					indexArr[ 0 ] = i;
					indexArr[ 1 ] = i + 1;
					indexArr[ 2 ] = i + 2;

				}

				const { a, b, c } = _triangle;
				a.fromBufferAttribute( positionAttr, indexArr[ 0 ] );
				b.fromBufferAttribute( positionAttr, indexArr[ 1 ] );
				c.fromBufferAttribute( positionAttr, indexArr[ 2 ] );
				_triangle.getNormal( _normal );

				// create hashes for the edge from the vertices
				hashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
				hashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
				hashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;

				// skip degenerate triangles
				if ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {

					continue;

				}

				// iterate over every edge
				for ( let j = 0; j < 3; j ++ ) {

					// get the first and next vertex making up the edge
					const jNext = ( j + 1 ) % 3;
					const vecHash0 = hashes[ j ];
					const vecHash1 = hashes[ jNext ];
					const v0 = _triangle[ vertKeys[ j ] ];
					const v1 = _triangle[ vertKeys[ jNext ] ];

					const hash = `${ vecHash0 }_${ vecHash1 }`;
					const reverseHash = `${ vecHash1 }_${ vecHash0 }`;

					if ( reverseHash in edgeData && edgeData[ reverseHash ] ) {

						// if we found a sibling edge add it into the vertex array if
						// it meets the angle threshold and delete the edge from the map.
						if ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {

							vertices.push( v0.x, v0.y, v0.z );
							vertices.push( v1.x, v1.y, v1.z );

						}

						edgeData[ reverseHash ] = null;

					} else if ( ! ( hash in edgeData ) ) {

						// if we've already got an edge here then skip adding a new one
						edgeData[ hash ] = {

							index0: indexArr[ j ],
							index1: indexArr[ jNext ],
							normal: _normal.clone(),

						};

					}

				}

			}

			// iterate over all remaining, unmatched edges and add them to the vertex array
			for ( const key in edgeData ) {

				if ( edgeData[ key ] ) {

					const { index0, index1 } = edgeData[ key ];
					_v0.fromBufferAttribute( positionAttr, index0 );
					_v1$1.fromBufferAttribute( positionAttr, index1 );

					vertices.push( _v0.x, _v0.y, _v0.z );
					vertices.push( _v1$1.x, _v1$1.y, _v1$1.z );

				}

			}

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

}

class Shape extends Path {

	constructor( points ) {

		super( points );

		this.uuid = generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	getPointsHoles( divisions ) {

		const holesPts = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	}

	// get points of shape and holes (keypoints based on segments parameter)

	extractPoints( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	}

	copy( source ) {

		super.copy( source );

		this.holes = [];

		for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

			const hole = source.holes[ i ];

			this.holes.push( hole.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.uuid = this.uuid;
		data.holes = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			const hole = this.holes[ i ];
			data.holes.push( hole.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.uuid = json.uuid;
		this.holes = [];

		for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

			const hole = json.holes[ i ];
			this.holes.push( new Path().fromJSON( hole ) );

		}

		return this;

	}

}

/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */

const Earcut = {

	triangulate: function ( data, holeIndices, dim = 2 ) {

		const hasHoles = holeIndices && holeIndices.length;
		const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
		let outerNode = linkedList( data, 0, outerLen, dim, true );
		const triangles = [];

		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

		let minX, minY, maxX, maxY, x, y, invSize;

		if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		if ( data.length > 80 * dim ) {

			minX = maxX = data[ 0 ];
			minY = maxY = data[ 1 ];

			for ( let i = dim; i < outerLen; i += dim ) {

				x = data[ i ];
				y = data[ i + 1 ];
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;

			}

			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
			invSize = Math.max( maxX - minX, maxY - minY );
			invSize = invSize !== 0 ? 1 / invSize : 0;

		}

		earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

		return triangles;

	}

};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList( data, start, end, dim, clockwise ) {

	let i, last;

	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

		for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	} else {

		for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	}

	if ( last && equals( last, last.next ) ) {

		removeNode( last );
		last = last.next;

	}

	return last;

}

// eliminate colinear or duplicate points
function filterPoints( start, end ) {

	if ( ! start ) return start;
	if ( ! end ) end = start;

	let p = start,
		again;
	do {

		again = false;

		if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

			removeNode( p );
			p = end = p.prev;
			if ( p === p.next ) break;
			again = true;

		} else {

			p = p.next;

		}

	} while ( again || p !== end );

	return end;

}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

	if ( ! ear ) return;

	// interlink polygon nodes in z-order
	if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

	let stop = ear,
		prev, next;

	// iterate through ears, slicing them one by one
	while ( ear.prev !== ear.next ) {

		prev = ear.prev;
		next = ear.next;

		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

			// cut off the triangle
			triangles.push( prev.i / dim );
			triangles.push( ear.i / dim );
			triangles.push( next.i / dim );

			removeNode( ear );

			// skipping the next vertex leads to less sliver triangles
			ear = next.next;
			stop = next.next;

			continue;

		}

		ear = next;

		// if we looped through the whole remaining polygon and can't find any more ears
		if ( ear === stop ) {

			// try filtering points and slicing again
			if ( ! pass ) {

				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

				// if this didn't work, try curing all small self-intersections locally

			} else if ( pass === 1 ) {

				ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

			} else if ( pass === 2 ) {

				splitEarcut( ear, triangles, dim, minX, minY, invSize );

			}

			break;

		}

	}

}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar( ear ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// now make sure we don't have other points inside the potential ear
	let p = ear.next.next;

	while ( p !== ear.prev ) {

		if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.next;

	}

	return true;

}

function isEarHashed( ear, minX, minY, invSize ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// triangle bbox; min & max are calculated like this for speed
	const minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
		minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
		maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
		maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

	// z-order range for the current triangle bbox;
	const minZ = zOrder( minTX, minTY, minX, minY, invSize ),
		maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

	let p = ear.prevZ,
		n = ear.nextZ;

	// look for points inside the triangle in both directions
	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	// look for remaining points in decreasing z-order
	while ( p && p.z >= minZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

	}

	// look for remaining points in increasing z-order
	while ( n && n.z <= maxZ ) {

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	return true;

}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections( start, triangles, dim ) {

	let p = start;
	do {

		const a = p.prev,
			b = p.next.next;

		if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

			triangles.push( a.i / dim );
			triangles.push( p.i / dim );
			triangles.push( b.i / dim );

			// remove two nodes involved
			removeNode( p );
			removeNode( p.next );

			p = start = b;

		}

		p = p.next;

	} while ( p !== start );

	return filterPoints( p );

}

// try splitting polygon into two and triangulate them independently
function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

	// look for a valid diagonal that divides the polygon into two
	let a = start;
	do {

		let b = a.next.next;
		while ( b !== a.prev ) {

			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

				// split the polygon in two by the diagonal
				let c = splitPolygon( a, b );

				// filter colinear points around the cuts
				a = filterPoints( a, a.next );
				c = filterPoints( c, c.next );

				// run earcut on each half
				earcutLinked( a, triangles, dim, minX, minY, invSize );
				earcutLinked( c, triangles, dim, minX, minY, invSize );
				return;

			}

			b = b.next;

		}

		a = a.next;

	} while ( a !== start );

}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles( data, holeIndices, outerNode, dim ) {

	const queue = [];
	let i, len, start, end, list;

	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

		start = holeIndices[ i ] * dim;
		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
		list = linkedList( data, start, end, dim, false );
		if ( list === list.next ) list.steiner = true;
		queue.push( getLeftmost( list ) );

	}

	queue.sort( compareX );

	// process holes from left to right
	for ( i = 0; i < queue.length; i ++ ) {

		eliminateHole( queue[ i ], outerNode );
		outerNode = filterPoints( outerNode, outerNode.next );

	}

	return outerNode;

}

function compareX( a, b ) {

	return a.x - b.x;

}

// find a bridge between vertices that connects hole with an outer ring and link it
function eliminateHole( hole, outerNode ) {

	outerNode = findHoleBridge( hole, outerNode );
	if ( outerNode ) {

		const b = splitPolygon( outerNode, hole );

		// filter collinear points around the cuts
		filterPoints( outerNode, outerNode.next );
		filterPoints( b, b.next );

	}

}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge( hole, outerNode ) {

	let p = outerNode;
	const hx = hole.x;
	const hy = hole.y;
	let qx = - Infinity, m;

	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	do {

		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

			const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
			if ( x <= hx && x > qx ) {

				qx = x;
				if ( x === hx ) {

					if ( hy === p.y ) return p;
					if ( hy === p.next.y ) return p.next;

				}

				m = p.x < p.next.x ? p : p.next;

			}

		}

		p = p.next;

	} while ( p !== outerNode );

	if ( ! m ) return null;

	if ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint

	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point

	const stop = m,
		mx = m.x,
		my = m.y;
	let tanMin = Infinity, tan;

	p = m;

	do {

		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
				pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

			if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

				m = p;
				tanMin = tan;

			}

		}

		p = p.next;

	} while ( p !== stop );

	return m;

}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector( m, p ) {

	return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

}

// interlink polygon nodes in z-order
function indexCurve( start, minX, minY, invSize ) {

	let p = start;
	do {

		if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;

	} while ( p !== start );

	p.prevZ.nextZ = null;
	p.prevZ = null;

	sortLinked( p );

}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked( list ) {

	let i, p, q, e, tail, numMerges, pSize, qSize,
		inSize = 1;

	do {

		p = list;
		list = null;
		tail = null;
		numMerges = 0;

		while ( p ) {

			numMerges ++;
			q = p;
			pSize = 0;
			for ( i = 0; i < inSize; i ++ ) {

				pSize ++;
				q = q.nextZ;
				if ( ! q ) break;

			}

			qSize = inSize;

			while ( pSize > 0 || ( qSize > 0 && q ) ) {

				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

					e = p;
					p = p.nextZ;
					pSize --;

				} else {

					e = q;
					q = q.nextZ;
					qSize --;

				}

				if ( tail ) tail.nextZ = e;
				else list = e;

				e.prevZ = tail;
				tail = e;

			}

			p = q;

		}

		tail.nextZ = null;
		inSize *= 2;

	} while ( numMerges > 1 );

	return list;

}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder( x, y, minX, minY, invSize ) {

	// coords are transformed into non-negative 15-bit integer range
	x = 32767 * ( x - minX ) * invSize;
	y = 32767 * ( y - minY ) * invSize;

	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
	x = ( x | ( x << 2 ) ) & 0x33333333;
	x = ( x | ( x << 1 ) ) & 0x55555555;

	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
	y = ( y | ( y << 2 ) ) & 0x33333333;
	y = ( y | ( y << 1 ) ) & 0x55555555;

	return x | ( y << 1 );

}

// find the leftmost node of a polygon ring
function getLeftmost( start ) {

	let p = start,
		leftmost = start;
	do {

		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
		p = p.next;

	} while ( p !== start );

	return leftmost;

}

// check if a point lies within a convex triangle
function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

	return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
			( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
			( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal( a, b ) {

	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // doesn't intersect other edges
		( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
		( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
		equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

}

// signed area of a triangle
function area( p, q, r ) {

	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

}

// check if two points are equal
function equals( p1, p2 ) {

	return p1.x === p2.x && p1.y === p2.y;

}

// check if two segments intersect
function intersects( p1, q1, p2, q2 ) {

	const o1 = sign( area( p1, q1, p2 ) );
	const o2 = sign( area( p1, q1, q2 ) );
	const o3 = sign( area( p2, q2, p1 ) );
	const o4 = sign( area( p2, q2, q1 ) );

	if ( o1 !== o2 && o3 !== o4 ) return true; // general case

	if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	return false;

}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment( p, q, r ) {

	return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

}

function sign( num ) {

	return num > 0 ? 1 : num < 0 ? - 1 : 0;

}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon( a, b ) {

	let p = a;
	do {

		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
				intersects( p, p.next, a, b ) ) return true;
		p = p.next;

	} while ( p !== a );

	return false;

}

// check if a polygon diagonal is locally inside the polygon
function locallyInside( a, b ) {

	return area( a.prev, a, a.next ) < 0 ?
		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside( a, b ) {

	let p = a,
		inside = false;
	const px = ( a.x + b.x ) / 2,
		py = ( a.y + b.y ) / 2;
	do {

		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
				( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
			inside = ! inside;
		p = p.next;

	} while ( p !== a );

	return inside;

}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon( a, b ) {

	const a2 = new Node( a.i, a.x, a.y ),
		b2 = new Node( b.i, b.x, b.y ),
		an = a.next,
		bp = b.prev;

	a.next = b;
	b.prev = a;

	a2.next = an;
	an.prev = a2;

	b2.next = a2;
	a2.prev = b2;

	bp.next = b2;
	b2.prev = bp;

	return b2;

}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode( i, x, y, last ) {

	const p = new Node( i, x, y );

	if ( ! last ) {

		p.prev = p;
		p.next = p;

	} else {

		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;

	}

	return p;

}

function removeNode( p ) {

	p.next.prev = p.prev;
	p.prev.next = p.next;

	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

}

function Node( i, x, y ) {

	// vertex index in coordinates array
	this.i = i;

	// vertex coordinates
	this.x = x;
	this.y = y;

	// previous and next vertex nodes in a polygon ring
	this.prev = null;
	this.next = null;

	// z-order curve value
	this.z = null;

	// previous and next nodes in z-order
	this.prevZ = null;
	this.nextZ = null;

	// indicates whether this is a steiner point
	this.steiner = false;

}

function signedArea( data, start, end, dim ) {

	let sum = 0;
	for ( let i = start, j = end - dim; i < end; i += dim ) {

		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
		j = i;

	}

	return sum;

}

class ShapeUtils {

	// calculate area of the contour polygon

	static area( contour ) {

		const n = contour.length;
		let a = 0.0;

		for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	}

	static isClockWise( pts ) {

		return ShapeUtils.area( pts ) < 0;

	}

	static triangulateShape( contour, holes ) {

		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		const holeIndices = []; // array of hole indices
		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts( contour );
		addContour( vertices, contour );

		//

		let holeIndex = contour.length;

		holes.forEach( removeDupEndPts );

		for ( let i = 0; i < holes.length; i ++ ) {

			holeIndices.push( holeIndex );
			holeIndex += holes[ i ].length;
			addContour( vertices, holes[ i ] );

		}

		//

		const triangles = Earcut.triangulate( vertices, holeIndices );

		//

		for ( let i = 0; i < triangles.length; i += 3 ) {

			faces.push( triangles.slice( i, i + 3 ) );

		}

		return faces;

	}

}

function removeDupEndPts( points ) {

	const l = points.length;

	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		points.pop();

	}

}

function addContour( vertices, contour ) {

	for ( let i = 0; i < contour.length; i ++ ) {

		vertices.push( contour[ i ].x );
		vertices.push( contour[ i ].y );

	}

}

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */

class ExtrudeGeometry extends BufferGeometry {

	constructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {

		super();

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		const scope = this;

		const verticesArray = [];
		const uvArray = [];

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];
			addShape( shape );

		}

		// build geometry

		this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		this.computeVertexNormals();

		// functions

		function addShape( shape ) {

			const placeholder = [];

			// options

			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			const steps = options.steps !== undefined ? options.steps : 1;
			let depth = options.depth !== undefined ? options.depth : 1;

			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
			let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			const extrudePath = options.extrudePath;

			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			// deprecated options

			if ( options.amount !== undefined ) {

				console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
				depth = options.amount;

			}

			//

			let extrudePts, extrudeByPath = false;
			let splineTube, binormal, normal, position2;

			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
				bevelOffset = 0;

			}

			// Variables initialization

			const shapePoints = shape.extractPoints( curveSegments );

			let vertices = shapePoints.shape;
			const holes = shapePoints.holes;

			const reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

			}


			const faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			const contour = vertices; // vertices has all points but contour has only points of circumference

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

				return vec.clone().multiplyScalar( size ).add( pt );

			}

			const vlen = vertices.length, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				const v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				const v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;

				const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					const v_prev_len = Math.sqrt( v_prev_lensq );
					const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					let direction_eq = false; // assumes: opposite

					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			const contourMovements = [];

			for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			const holesMovements = [];
			let oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				oneHoleMovements = [];

				for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( let b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

				}

			}

			const bs = bevelSize + bevelOffset;

			// Back facing vertices

			for ( let i = 0; i < vlen; i ++ ) {

				const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			for ( let s = 1; s <= steps; s ++ ) {

				for ( let i = 0; i < vlen; i ++ ) {

					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( let b = bevelSegments - 1; b >= 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				const start = verticesArray.length / 3;

				if ( bevelEnabled ) {

					let layer = 0; // steps + 1
					let offset = vlen * layer;

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				const start = verticesArray.length / 3;
				let layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}


				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			}

			function sidewalls( contour, layeroffset ) {

				let i = contour.length;

				while ( -- i >= 0 ) {

					const j = i;
					let k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

						const slen1 = vlen * s;
						const slen2 = vlen * ( s + 1 );

						const a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d );

					}

				}

			}

			function v( x, y, z ) {

				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );

			}


			function f3( a, b, c ) {

				addVertex( a );
				addVertex( b );
				addVertex( c );

				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );

			}

			function f4( a, b, c, d ) {

				addVertex( a );
				addVertex( b );
				addVertex( d );

				addVertex( b );
				addVertex( c );
				addVertex( d );


				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );

				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );

			}

			function addVertex( index ) {

				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );

			}


			function addUV( vector2 ) {

				uvArray.push( vector2.x );
				uvArray.push( vector2.y );

			}

		}

	}

	toJSON() {

		const data = super.toJSON();

		const shapes = this.parameters.shapes;
		const options = this.parameters.options;

		return toJSON$1( shapes, options, data );

	}

	static fromJSON( data, shapes ) {

		const geometryShapes = [];

		for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			const shape = shapes[ data.shapes[ j ] ];

			geometryShapes.push( shape );

		}

		const extrudePath = data.options.extrudePath;

		if ( extrudePath !== undefined ) {

			data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

		}

		return new ExtrudeGeometry( geometryShapes, data.options );

	}

}

const WorldUVGenerator = {

	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];

		return [
			new Vector2( a_x, a_y ),
			new Vector2( b_x, b_y ),
			new Vector2( c_x, c_y )
		];

	},

	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const a_z = vertices[ indexA * 3 + 2 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const b_z = vertices[ indexB * 3 + 2 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];
		const c_z = vertices[ indexC * 3 + 2 ];
		const d_x = vertices[ indexD * 3 ];
		const d_y = vertices[ indexD * 3 + 1 ];
		const d_z = vertices[ indexD * 3 + 2 ];

		if ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {

			return [
				new Vector2( a_x, 1 - a_z ),
				new Vector2( b_x, 1 - b_z ),
				new Vector2( c_x, 1 - c_z ),
				new Vector2( d_x, 1 - d_z )
			];

		} else {

			return [
				new Vector2( a_y, 1 - a_z ),
				new Vector2( b_y, 1 - b_z ),
				new Vector2( c_y, 1 - c_z ),
				new Vector2( d_y, 1 - d_z )
			];

		}

	}

};

function toJSON$1( shapes, options, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	return data;

}

class IcosahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;

		const vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		const indices = [
			0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new IcosahedronGeometry( data.radius, data.detail );

	}

}

class OctahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		const indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		super( vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new OctahedronGeometry( data.radius, data.detail );

	}

}

class RingGeometry extends BufferGeometry {

	constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		thetaSegments = Math.max( 3, thetaSegments );
		phiSegments = Math.max( 1, phiSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// some helper variables

		let radius = innerRadius;
		const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		const vertex = new Vector3();
		const uv = new Vector2();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= phiSegments; j ++ ) {

			for ( let i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				const segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( let j = 0; j < phiSegments; j ++ ) {

			const thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( let i = 0; i < thetaSegments; i ++ ) {

				const segment = i + thetaSegmentLevel;

				const a = segment;
				const b = segment + thetaSegments + 1;
				const c = segment + thetaSegments + 2;
				const d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	static fromJSON( data ) {

		return new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );

	}

}

class ShapeGeometry extends BufferGeometry {

	constructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {

		super();
		this.type = 'ShapeGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let groupStart = 0;
		let groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( let i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			const indexOffset = vertices.length / 3;
			const points = shape.extractPoints( curveSegments );

			let shapeVertices = points.shape;
			const shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

			}

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

			const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

				const vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// incides

			for ( let i = 0, l = faces.length; i < l; i ++ ) {

				const face = faces[ i ];

				const a = face[ 0 ] + indexOffset;
				const b = face[ 1 ] + indexOffset;
				const c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	toJSON() {

		const data = super.toJSON();

		const shapes = this.parameters.shapes;

		return toJSON( shapes, data );

	}

	static fromJSON( data, shapes ) {

		const geometryShapes = [];

		for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			const shape = shapes[ data.shapes[ j ] ];

			geometryShapes.push( shape );

		}

		return new ShapeGeometry( geometryShapes, data.curveSegments );

	}

}

function toJSON( shapes, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	return data;

}

class SphereGeometry extends BufferGeometry {

	constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

		super();
		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		let index = 0;
		const grid = [];

		const vertex = new Vector3();
		const normal = new Vector3();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

			const verticesRow = [];

			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;

			if ( iy == 0 && thetaStart == 0 ) {

				uOffset = 0.5 / widthSegments;

			} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

				uOffset = - 0.5 / widthSegments;

			}

			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

				const u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( let iy = 0; iy < heightSegments; iy ++ ) {

			for ( let ix = 0; ix < widthSegments; ix ++ ) {

				const a = grid[ iy ][ ix + 1 ];
				const b = grid[ iy ][ ix ];
				const c = grid[ iy + 1 ][ ix ];
				const d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	static fromJSON( data ) {

		return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

	}

}

class TetrahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		const indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new TetrahedronGeometry( data.radius, data.detail );

	}

}

class TorusGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2 ) {

		super();
		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radialSegments = Math.floor( radialSegments );
		tubularSegments = Math.floor( tubularSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3();
		const vertex = new Vector3();
		const normal = new Vector3();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= radialSegments; j ++ ) {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= radialSegments; j ++ ) {

			for ( let i = 1; i <= tubularSegments; i ++ ) {

				// indices

				const a = ( tubularSegments + 1 ) * j + i - 1;
				const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				const d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	static fromJSON( data ) {

		return new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );

	}

}

class TorusKnotGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

		super();
		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		tubularSegments = Math.floor( tubularSegments );
		radialSegments = Math.floor( radialSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();

		const P1 = new Vector3();
		const P2 = new Vector3();

		const B = new Vector3();
		const T = new Vector3();
		const N = new Vector3();

		// generate vertices, normals and uvs

		for ( let i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segment

			const u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( let j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				const v = j / radialSegments * Math.PI * 2;
				const cx = - tube * Math.cos( v );
				const cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= tubularSegments; j ++ ) {

			for ( let i = 1; i <= radialSegments; i ++ ) {

				// indices

				const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				const b = ( radialSegments + 1 ) * j + ( i - 1 );
				const c = ( radialSegments + 1 ) * j + i;
				const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			const cu = Math.cos( u );
			const su = Math.sin( u );
			const quOverP = q / p * u;
			const cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

	static fromJSON( data ) {

		return new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );

	}

}

class TubeGeometry extends BufferGeometry {

	constructor( path = new QuadraticBezierCurve3( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

		super();
		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		const frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();
		const uv = new Vector2();
		let P = new Vector3();

		// buffer

		const vertices = [];
		const normals = [];
		const uvs = [];
		const indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( let i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			const N = frames.normals[ i ];
			const B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( let j = 0; j <= radialSegments; j ++ ) {

				const v = j / radialSegments * Math.PI * 2;

				const sin = Math.sin( v );
				const cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( let j = 1; j <= tubularSegments; j ++ ) {

				for ( let i = 1; i <= radialSegments; i ++ ) {

					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					const b = ( radialSegments + 1 ) * j + ( i - 1 );
					const c = ( radialSegments + 1 ) * j + i;
					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				for ( let j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}

	toJSON() {

		const data = super.toJSON();

		data.path = this.parameters.path.toJSON();

		return data;

	}

	static fromJSON( data ) {

		// This only works for built-in curves (e.g. CatmullRomCurve3).
		// User defined curves or instances of CurvePath will not be deserialized.
		return new TubeGeometry(
			new Curves[ data.path.type ]().fromJSON( data.path ),
			data.tubularSegments,
			data.radius,
			data.radialSegments,
			data.closed
		);

	}

}

class WireframeGeometry extends BufferGeometry {

	constructor( geometry = null ) {

		super();
		this.type = 'WireframeGeometry';

		this.parameters = {
			geometry: geometry
		};

		if ( geometry !== null ) {

			// buffer

			const vertices = [];
			const edges = new Set();

			// helper variables

			const start = new Vector3();
			const end = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all edges without duplicates

				for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

					const group = groups[ o ];

					const groupStart = group.start;
					const groupCount = group.count;

					for ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {

						for ( let j = 0; j < 3; j ++ ) {

							const index1 = indices.getX( i + j );
							const index2 = indices.getX( i + ( j + 1 ) % 3 );

							start.fromBufferAttribute( position, index1 );
							end.fromBufferAttribute( position, index2 );

							if ( isUniqueEdge( start, end, edges ) === true ) {

								vertices.push( start.x, start.y, start.z );
								vertices.push( end.x, end.y, end.z );

							}

						}

					}

				}

			} else {

				// non-indexed BufferGeometry

				const position = geometry.attributes.position;

				for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( let j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						const index1 = 3 * i + j;
						const index2 = 3 * i + ( ( j + 1 ) % 3 );

						start.fromBufferAttribute( position, index1 );
						end.fromBufferAttribute( position, index2 );

						if ( isUniqueEdge( start, end, edges ) === true ) {

							vertices.push( start.x, start.y, start.z );
							vertices.push( end.x, end.y, end.z );

						}

					}

				}

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

}

function isUniqueEdge( start, end, edges ) {

	const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
	const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

	if ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {

		return false;

	} else {

		edges.add( hash1 );
		edges.add( hash2 );
		return true;

	}

}

var Geometries = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BoxGeometry: BoxGeometry,
	BoxBufferGeometry: BoxGeometry,
	CapsuleGeometry: CapsuleGeometry,
	CapsuleBufferGeometry: CapsuleGeometry,
	CircleGeometry: CircleGeometry,
	CircleBufferGeometry: CircleGeometry,
	ConeGeometry: ConeGeometry,
	ConeBufferGeometry: ConeGeometry,
	CylinderGeometry: CylinderGeometry,
	CylinderBufferGeometry: CylinderGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	DodecahedronBufferGeometry: DodecahedronGeometry,
	EdgesGeometry: EdgesGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	ExtrudeBufferGeometry: ExtrudeGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	IcosahedronBufferGeometry: IcosahedronGeometry,
	LatheGeometry: LatheGeometry,
	LatheBufferGeometry: LatheGeometry,
	OctahedronGeometry: OctahedronGeometry,
	OctahedronBufferGeometry: OctahedronGeometry,
	PlaneGeometry: PlaneGeometry,
	PlaneBufferGeometry: PlaneGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	PolyhedronBufferGeometry: PolyhedronGeometry,
	RingGeometry: RingGeometry,
	RingBufferGeometry: RingGeometry,
	ShapeGeometry: ShapeGeometry,
	ShapeBufferGeometry: ShapeGeometry,
	SphereGeometry: SphereGeometry,
	SphereBufferGeometry: SphereGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TetrahedronBufferGeometry: TetrahedronGeometry,
	TorusGeometry: TorusGeometry,
	TorusBufferGeometry: TorusGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TorusKnotBufferGeometry: TorusKnotGeometry,
	TubeGeometry: TubeGeometry,
	TubeBufferGeometry: TubeGeometry,
	WireframeGeometry: WireframeGeometry
});

class ShadowMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'ShadowMaterial';

		this.color = new Color( 0x000000 );
		this.transparent = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		return this;

	}

}

ShadowMaterial.prototype.isShadowMaterial = true;

class RawShaderMaterial extends ShaderMaterial {

	constructor( parameters ) {

		super( parameters );

		this.type = 'RawShaderMaterial';

	}

}

RawShaderMaterial.prototype.isRawShaderMaterial = true;

class MeshStandardMaterial extends Material {

	constructor( parameters ) {

		super();

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 1.0;
		this.metalness = 0.0;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

class MeshPhysicalMaterial extends MeshStandardMaterial {

	constructor( parameters ) {

		super();

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.type = 'MeshPhysicalMaterial';

		this.clearcoatMap = null;
		this.clearcoatRoughness = 0.0;
		this.clearcoatRoughnessMap = null;
		this.clearcoatNormalScale = new Vector2( 1, 1 );
		this.clearcoatNormalMap = null;

		this.ior = 1.5;

		Object.defineProperty( this, 'reflectivity', {
			get: function () {

				return ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

			},
			set: function ( reflectivity ) {

				this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

			}
		} );

		this.sheenColor = new Color( 0x000000 );
		this.sheenColorMap = null;
		this.sheenRoughness = 1.0;
		this.sheenRoughnessMap = null;

		this.transmissionMap = null;

		this.thickness = 0;
		this.thicknessMap = null;
		this.attenuationDistance = 0.0;
		this.attenuationColor = new Color( 1, 1, 1 );

		this.specularIntensity = 1.0;
		this.specularIntensityMap = null;
		this.specularColor = new Color( 1, 1, 1 );
		this.specularColorMap = null;

		this._sheen = 0.0;
		this._clearcoat = 0;
		this._transmission = 0;

		this.setValues( parameters );

	}

	get sheen() {

		return this._sheen;

	}

	set sheen( value ) {

		if ( this._sheen > 0 !== value > 0 ) {

			this.version ++;

		}

		this._sheen = value;

	}

	get clearcoat() {

		return this._clearcoat;

	}

	set clearcoat( value ) {

		if ( this._clearcoat > 0 !== value > 0 ) {

			this.version ++;

		}

		this._clearcoat = value;

	}

	get transmission() {

		return this._transmission;

	}

	set transmission( value ) {

		if ( this._transmission > 0 !== value > 0 ) {

			this.version ++;

		}

		this._transmission = value;

	}

	copy( source ) {

		super.copy( source );

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

		this.ior = source.ior;

		this.sheen = source.sheen;
		this.sheenColor.copy( source.sheenColor );
		this.sheenColorMap = source.sheenColorMap;
		this.sheenRoughness = source.sheenRoughness;
		this.sheenRoughnessMap = source.sheenRoughnessMap;

		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;

		this.thickness = source.thickness;
		this.thicknessMap = source.thicknessMap;
		this.attenuationDistance = source.attenuationDistance;
		this.attenuationColor.copy( source.attenuationColor );

		this.specularIntensity = source.specularIntensity;
		this.specularIntensityMap = source.specularIntensityMap;
		this.specularColor.copy( source.specularColor );
		this.specularColorMap = source.specularColorMap;

		return this;

	}

}

MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

class MeshPhongMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshPhongMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

class MeshToonMaterial extends Material {

	constructor( parameters ) {

		super();

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;
		this.gradientMap = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;
		this.gradientMap = source.gradientMap;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		return this;

	}

}

MeshToonMaterial.prototype.isMeshToonMaterial = true;

class MeshNormalMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

class MeshLambertMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		return this;

	}

}

MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

class MeshMatcapMaterial extends Material {

	constructor( parameters ) {

		super();

		this.defines = { 'MATCAP': '' };

		this.type = 'MeshMatcapMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.matcap = null;

		this.map = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.flatShading = false;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.defines = { 'MATCAP': '' };

		this.color.copy( source.color );

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

class LineDashedMaterial extends LineBasicMaterial {

	constructor( parameters ) {

		super();

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	}

}

LineDashedMaterial.prototype.isLineDashedMaterial = true;

const materialLib = {
	ShadowMaterial,
	SpriteMaterial,
	RawShaderMaterial,
	ShaderMaterial,
	PointsMaterial,
	MeshPhysicalMaterial,
	MeshStandardMaterial,
	MeshPhongMaterial,
	MeshToonMaterial,
	MeshNormalMaterial,
	MeshLambertMaterial,
	MeshDepthMaterial,
	MeshDistanceMaterial,
	MeshBasicMaterial,
	MeshMatcapMaterial,
	LineDashedMaterial,
	LineBasicMaterial,
	Material
};

Material.fromType = function ( type ) {

	return new materialLib[ type ]();

};

const AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function ( array, from, to ) {

		if ( AnimationUtils.isTypedArray( array ) ) {

			// in ios9 array.subarray(from, undefined) will return empty array
			// but array.subarray(from) or array.subarray(from, len) is correct
			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function ( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
			! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function ( object ) {

		return ArrayBuffer.isView( object ) &&
			! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function ( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		const n = times.length;
		const result = new Array( n );
		for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function ( values, stride, order ) {

		const nValues = values.length;
		const result = new values.constructor( nValues );

		for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			const srcOffset = order[ i ] * stride;

			for ( let j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

		let i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		let value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {

			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {

			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	},

	subclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {

		const clip = sourceClip.clone();

		clip.name = name;

		const tracks = [];

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			const track = clip.tracks[ i ];
			const valueSize = track.getValueSize();

			const times = [];
			const values = [];

			for ( let j = 0; j < track.times.length; ++ j ) {

				const frame = track.times[ j ] * fps;

				if ( frame < startFrame || frame >= endFrame ) continue;

				times.push( track.times[ j ] );

				for ( let k = 0; k < valueSize; ++ k ) {

					values.push( track.values[ j * valueSize + k ] );

				}

			}

			if ( times.length === 0 ) continue;

			track.times = AnimationUtils.convertArray( times, track.times.constructor );
			track.values = AnimationUtils.convertArray( values, track.values.constructor );

			tracks.push( track );

		}

		clip.tracks = tracks;

		// find minimum .times value across all tracks in the trimmed clip

		let minStartTime = Infinity;

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

				minStartTime = clip.tracks[ i ].times[ 0 ];

			}

		}

		// shift all tracks such that clip begins at t=0

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			clip.tracks[ i ].shift( - 1 * minStartTime );

		}

		clip.resetDuration();

		return clip;

	},

	makeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

		if ( fps <= 0 ) fps = 30;

		const numTracks = referenceClip.tracks.length;
		const referenceTime = referenceFrame / fps;

		// Make each track's values relative to the values at the reference frame
		for ( let i = 0; i < numTracks; ++ i ) {

			const referenceTrack = referenceClip.tracks[ i ];
			const referenceTrackType = referenceTrack.ValueTypeName;

			// Skip this track if it's non-numeric
			if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

			// Find the track in the target clip whose name and type matches the reference track
			const targetTrack = targetClip.tracks.find( function ( track ) {

				return track.name === referenceTrack.name
					&& track.ValueTypeName === referenceTrackType;

			} );

			if ( targetTrack === undefined ) continue;

			let referenceOffset = 0;
			const referenceValueSize = referenceTrack.getValueSize();

			if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				referenceOffset = referenceValueSize / 3;

			}

			let targetOffset = 0;
			const targetValueSize = targetTrack.getValueSize();

			if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				targetOffset = targetValueSize / 3;

			}

			const lastIndex = referenceTrack.times.length - 1;
			let referenceValue;

			// Find the value to subtract out of the track
			if ( referenceTime <= referenceTrack.times[ 0 ] ) {

				// Reference frame is earlier than the first keyframe, so just use the first keyframe
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

				// Reference frame is after the last keyframe, so just use the last keyframe
				const startIndex = lastIndex * referenceValueSize + referenceOffset;
				const endIndex = startIndex + referenceValueSize - referenceOffset;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			} else {

				// Interpolate to the reference value
				const interpolant = referenceTrack.createInterpolant();
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				interpolant.evaluate( referenceTime );
				referenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );

			}

			// Conjugate the quaternion
			if ( referenceTrackType === 'quaternion' ) {

				const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
				referenceQuat.toArray( referenceValue );

			}

			// Subtract the reference value from all of the track values

			const numTimes = targetTrack.times.length;
			for ( let j = 0; j < numTimes; ++ j ) {

				const valueStart = j * targetValueSize + targetOffset;

				if ( referenceTrackType === 'quaternion' ) {

					// Multiply the conjugate for quaternion track types
					Quaternion.multiplyQuaternionsFlat(
						targetTrack.values,
						valueStart,
						referenceValue,
						0,
						targetTrack.values,
						valueStart
					);

				} else {

					const valueEnd = targetValueSize - targetOffset * 2;

					// Subtract each value for all other numeric track types
					for ( let k = 0; k < valueEnd; ++ k ) {

						targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

					}

				}

			}

		}

		targetClip.blendMode = AdditiveAnimationBlendMode;

		return targetClip;

	}

};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

class Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

		this.settings = null;
		this.DefaultSettings_ = {};

	}

	evaluate( t ) {

		const pp = this.parameterPositions;
		let i1 = this._cachedIndex,
			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				let right;

				linear_scan: {

					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( let giveUpAt = i1 + 2; ; ) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.afterEnd_( i1 - 1, t, t0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						const t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( let giveUpAt = i1 - 2; ; ) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.beforeStart_( 0, t, t1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					const mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.beforeStart_( 0, t, t1 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.afterEnd_( i1 - 1, t0, t );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	}

	getSettings_() {

		return this.settings || this.DefaultSettings_;

	}

	copySampleValue_( index ) {

		// copies a sample value to the result buffer

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

	// Template methods for derived classes:

	interpolate_( /* i1, t0, t, t1 */ ) {

		throw new Error( 'call to abstract method' );
		// implementations shall return this.resultBuffer

	}

	intervalChanged_( /* i1, t0, t1 */ ) {

		// empty

	}

}

// ALIAS DEFINITIONS

Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

class CubicInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

		this.DefaultSettings_ = {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		};

	}

	intervalChanged_( i1, t0, t1 ) {

		const pp = this.parameterPositions;
		let iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		const halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		const sP = - wP * ppp + 2 * wP * pp - wP * p;
		const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		const sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

}

class LinearInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

}

/**
 *
 * Interpolant that evaluates to the sample value at the position preceding
 * the parameter.
 */

class DiscreteInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

}

class KeyframeTrack {

	constructor( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	}

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	static toJSON( track ) {

		const trackType = track.constructor;

		let json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== this.toJSON ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': AnimationUtils.convertArray( track.times, Array ),
				'values': AnimationUtils.convertArray( track.values, Array )

			};

			const interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

	InterpolantFactoryMethodDiscrete( result ) {

		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodLinear( result ) {

		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodSmooth( result ) {

		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	setInterpolation( interpolation ) {

		let factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			const message = 'unsupported interpolation for ' +
				this.ValueTypeName + ' keyframe track named ' + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	}

	getInterpolation() {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	}

	getValueSize() {

		return this.values.length / this.times.length;

	}

	// move all keyframes either forwards or backwards in time
	shift( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	}

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale( timeScale ) {

		if ( timeScale !== 1.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	}

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim( startTime, endTime ) {

		const times = this.times,
			nKeys = times.length;

		let from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			const stride = this.getValueSize();
			this.times = AnimationUtils.arraySlice( times, from, to );
			this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	}

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate() {

		let valid = true;

		const valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		const times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		let prevTime = null;

		for ( let i = 0; i !== nKeys; i ++ ) {

			const currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( AnimationUtils.isTypedArray( values ) ) {

				for ( let i = 0, n = values.length; i !== n; ++ i ) {

					const value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	}

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize() {

		// times or values may be shared with other tracks, so overwriting is unsafe
		const times = AnimationUtils.arraySlice( this.times ),
			values = AnimationUtils.arraySlice( this.values ),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			lastIndex = times.length - 1;

		let writeIndex = 1;

		for ( let i = 1; i < lastIndex; ++ i ) {

			let keep = false;

			const time = times[ i ];
			const timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					const offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( let j = 0; j !== stride; ++ j ) {

						const value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					const readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( let j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	}

	clone() {

		const times = AnimationUtils.arraySlice( this.times, 0 );
		const values = AnimationUtils.arraySlice( this.values, 0 );

		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

}

KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

/**
 * A Track of Boolean keyframe values.
 */
class BooleanKeyframeTrack extends KeyframeTrack {}

BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of keyframe values that represent color.
 */
class ColorKeyframeTrack extends KeyframeTrack {}

ColorKeyframeTrack.prototype.ValueTypeName = 'color';

/**
 * A Track of numeric keyframe values.
 */
class NumberKeyframeTrack extends KeyframeTrack {}

NumberKeyframeTrack.prototype.ValueTypeName = 'number';

/**
 * Spherical linear unit quaternion interpolant.
 */

class QuaternionLinearInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			alpha = ( t - t0 ) / ( t1 - t0 );

		let offset = i1 * stride;

		for ( let end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

}

/**
 * A Track of quaternion keyframe values.
 */
class QuaternionKeyframeTrack extends KeyframeTrack {

	InterpolantFactoryMethodLinear( result ) {

		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

}

QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track that interpolates Strings
 */
class StringKeyframeTrack extends KeyframeTrack {}

StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of vectored keyframe values.
 */
class VectorKeyframeTrack extends KeyframeTrack {}

VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

class AnimationClip {

	constructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = duration;
		this.blendMode = blendMode;

		this.uuid = generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	}


	static parse( json ) {

		const tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		const clip = new this( json.name, json.duration, tracks, json.blendMode );
		clip.uuid = json.uuid;

		return clip;

	}

	static toJSON( clip ) {

		const tracks = [],
			clipTracks = clip.tracks;

		const json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	}

	static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

		const numMorphTargets = morphTargetSequence.length;
		const tracks = [];

		for ( let i = 0; i < numMorphTargets; i ++ ) {

			let times = [];
			let values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			const order = AnimationUtils.getKeyframeOrder( times );
			times = AnimationUtils.sortedArray( times, 1, order );
			values = AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new this( name, - 1, tracks );

	}

	static findByName( objectOrClipArray, name ) {

		let clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			const o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( let i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	}

	static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

		const animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		const pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				const name = parts[ 1 ];

				let animationMorphTargets = animationToMorphTargets[ name ];

				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		const clips = [];

		for ( const name in animationToMorphTargets ) {

			clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	}

	// parse the animation.hierarchy format
	static parseAnimation( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				const times = [];
				const values = [];

				AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		const tracks = [];

		const clipName = animation.name || 'default';
		const fps = animation.fps || 30;
		const blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		let duration = animation.length || - 1;

		const hierarchyTracks = animation.hierarchy || [];

		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			const animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				const morphTargetNames = {};

				let k;

				for ( k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( const morphTargetName in morphTargetNames ) {

					const times = [];
					const values = [];

					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						const animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * fps;

			} else {

				// ...assume skeletal animation

				const boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		const clip = new this( clipName, duration, tracks, blendMode );

		return clip;

	}

	resetDuration() {

		const tracks = this.tracks;
		let duration = 0;

		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			const track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	}

	trim() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	}

	validate() {

		let valid = true;

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	}

	optimize() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

	clone() {

		const tracks = [];

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new this.constructor( this.name, this.duration, tracks, this.blendMode );

	}

	toJSON() {

		return this.constructor.toJSON( this );

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return VectorKeyframeTrack;

		case 'color':

			return ColorKeyframeTrack;

		case 'quaternion':

			return QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return BooleanKeyframeTrack;

		case 'string':

			return StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	const trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		const times = [], values = [];

		AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}

const Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

class LoadingManager {

	constructor( onLoad, onProgress, onError ) {

		const scope = this;

		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier = undefined;
		const handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;

			return this;

		};

		this.addHandler = function ( regex, loader ) {

			handlers.push( regex, loader );

			return this;

		};

		this.removeHandler = function ( regex ) {

			const index = handlers.indexOf( regex );

			if ( index !== - 1 ) {

				handlers.splice( index, 2 );

			}

			return this;

		};

		this.getHandler = function ( file ) {

			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

				const regex = handlers[ i ];
				const loader = handlers[ i + 1 ];

				if ( regex.global ) regex.lastIndex = 0; // see #17920

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		};

	}

}

const DefaultLoadingManager = new LoadingManager();

class Loader {

	constructor( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.crossOrigin = 'anonymous';
		this.withCredentials = false;
		this.path = '';
		this.resourcePath = '';
		this.requestHeader = {};

	}

	load( /* url, onLoad, onProgress, onError */ ) {}

	loadAsync( url, onProgress ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.load( url, resolve, onProgress, reject );

		} );

	}

	parse( /* data */ ) {}

	setCrossOrigin( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	}

	setWithCredentials( value ) {

		this.withCredentials = value;
		return this;

	}

	setPath( path ) {

		this.path = path;
		return this;

	}

	setResourcePath( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	}

	setRequestHeader( requestHeader ) {

		this.requestHeader = requestHeader;
		return this;

	}

}

const loading = {};

class FileLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			this.manager.itemStart( url );

			setTimeout( () => {

				if ( onLoad ) onLoad( cached );

				this.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Initialise array for duplicate requests
		loading[ url ] = [];

		loading[ url ].push( {
			onLoad: onLoad,
			onProgress: onProgress,
			onError: onError,
		} );

		// create request
		const req = new Request( url, {
			headers: new Headers( this.requestHeader ),
			credentials: this.withCredentials ? 'include' : 'same-origin',
			// An abort controller could be added within a future PR
		} );

		// record states ( avoid data race )
		const mimeType = this.mimeType;
		const responseType = this.responseType;

		// start the fetch
		fetch( req )
			.then( response => {

				if ( response.status === 200 || response.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( response.status === 0 ) {

						console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					}

					// Workaround: Checking if response.body === undefined for Alipay browser #23548

					if ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {

						return response;

					}

					const callbacks = loading[ url ];
					const reader = response.body.getReader();
					const contentLength = response.headers.get( 'Content-Length' );
					const total = contentLength ? parseInt( contentLength ) : 0;
					const lengthComputable = total !== 0;
					let loaded = 0;

					// periodically read data into the new stream tracking while download progress
					const stream = new ReadableStream( {
						start( controller ) {

							readData();

							function readData() {

								reader.read().then( ( { done, value } ) => {

									if ( done ) {

										controller.close();

									} else {

										loaded += value.byteLength;

										const event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );
										for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

											const callback = callbacks[ i ];
											if ( callback.onProgress ) callback.onProgress( event );

										}

										controller.enqueue( value );
										readData();

									}

								} );

							}

						}

					} );

					return new Response( stream );

				} else {

					throw Error( `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}` );

				}

			} )
			.then( response => {

				switch ( responseType ) {

					case 'arraybuffer':

						return response.arrayBuffer();

					case 'blob':

						return response.blob();

					case 'document':

						return response.text()
							.then( text => {

								const parser = new DOMParser();
								return parser.parseFromString( text, mimeType );

							} );

					case 'json':

						return response.json();

					default:

						if ( mimeType === undefined ) {

							return response.text();

						} else {

							// sniff encoding
							const re = /charset="?([^;"\s]*)"?/i;
							const exec = re.exec( mimeType );
							const label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;
							const decoder = new TextDecoder( label );
							return response.arrayBuffer().then( ab => decoder.decode( ab ) );

						}

				}

			} )
			.then( data => {

				// Add to cache only on HTTP success, so that we do not cache
				// error response bodies as proper responses to requests.
				Cache.add( url, data );

				const callbacks = loading[ url ];
				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onLoad ) callback.onLoad( data );

				}

			} )
			.catch( err => {

				// Abort errors and other errors are handled the same

				const callbacks = loading[ url ];

				if ( callbacks === undefined ) {

					// When onLoad was called and url was deleted in `loading`
					this.manager.itemError( url );
					throw err;

				}

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( err );

				}

				this.manager.itemError( url );

			} )
			.finally( () => {

				this.manager.itemEnd( url );

			} );

		this.manager.itemStart( url );

	}

	setResponseType( value ) {

		this.responseType = value;
		return this;

	}

	setMimeType( value ) {

		this.mimeType = value;
		return this;

	}

}

class AnimationLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const animations = [];

		for ( let i = 0; i < json.length; i ++ ) {

			const clip = AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	}

}

/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

class CompressedTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const images = [];

		const texture = new CompressedTexture();

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( scope.withCredentials );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;

					texture.image = images;
					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			for ( let i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				if ( texDatas.isCubemap ) {

					const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( let f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps: [] };

						for ( let i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

					texture.image = images;

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	}

}

class ImageLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const image = createElementNS( 'img' );

		function onImageLoad() {

			removeEventListeners();

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			removeEventListeners();

			if ( onError ) onError( event );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		function removeEventListeners() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.slice( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

}

class CubeTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( urls, onLoad, onProgress, onError ) {

		const texture = new CubeTexture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( let i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	}

}

/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

class DataTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const texture = new DataTexture();

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setPath( this.path );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( buffer ) {

			const texData = scope.parse( buffer );

			if ( ! texData ) return;

			if ( texData.image !== undefined ) {

				texture.image = texData.image;

			} else if ( texData.data !== undefined ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

			if ( texData.encoding !== undefined ) {

				texture.encoding = texData.encoding;

			}

			if ( texData.flipY !== undefined ) {

				texture.flipY = texData.flipY;

			}

			if ( texData.format !== undefined ) {

				texture.format = texData.format;

			}

			if ( texData.type !== undefined ) {

				texture.type = texData.type;

			}

			if ( texData.mipmaps !== undefined ) {

				texture.mipmaps = texData.mipmaps;
				texture.minFilter = LinearMipmapLinearFilter; // presumably...

			}

			if ( texData.mipmapCount === 1 ) {

				texture.minFilter = LinearFilter;

			}

			if ( texData.generateMipmaps !== undefined ) {

				texture.generateMipmaps = texData.generateMipmaps;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

}

class TextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const texture = new Texture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

}

class Light extends Object3D {

	constructor( color, intensity = 1 ) {

		super();

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity;

	}

	dispose() {

		// Empty here in base class; some subclasses override.

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

}

Light.prototype.isLight = true;

class HemisphereLight extends Light {

	constructor( skyColor, groundColor, intensity ) {

		super( skyColor, intensity );

		this.type = 'HemisphereLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.groundColor = new Color( groundColor );

	}

	copy( source ) {

		Light.prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );

		return this;

	}

}

HemisphereLight.prototype.isHemisphereLight = true;

const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
const _lookTarget$1 = /*@__PURE__*/ new Vector3();

class LightShadow {

	constructor( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;
		this.blurSamples = 8;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();

		this.autoUpdate = true;
		this.needsUpdate = false;

		this._frustum = new Frustum();
		this._frameExtents = new Vector2( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new Vector4( 0, 0, 1, 1 )

		];

	}

	getViewportCount() {

		return this._viewportCount;

	}

	getFrustum() {

		return this._frustum;

	}

	updateMatrices( light ) {

		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;

		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( _lightPositionWorld$1 );

		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( _lookTarget$1 );
		shadowCamera.updateMatrixWorld();

		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( shadowCamera.projectionMatrix );
		shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

	}

	getViewport( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	}

	getFrameExtents() {

		return this._frameExtents;

	}

	dispose() {

		if ( this.map ) {

			this.map.dispose();

		}

		if ( this.mapPass ) {

			this.mapPass.dispose();

		}

	}

	copy( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	toJSON() {

		const object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

}

class SpotLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		this.focus = 1;

	}

	updateMatrices( light ) {

		const camera = this.camera;

		const fov = RAD2DEG * 2 * light.angle * this.focus;
		const aspect = this.mapSize.width / this.mapSize.height;
		const far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		super.updateMatrices( light );

	}

	copy( source ) {

		super.copy( source );

		this.focus = source.focus;

		return this;

	}

}

SpotLightShadow.prototype.isSpotLightShadow = true;

class SpotLight extends Light {

	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1 ) {

		super( color, intensity );

		this.type = 'SpotLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.distance = distance;
		this.angle = angle;
		this.penumbra = penumbra;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new SpotLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
		return this.intensity * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / Math.PI;

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source ) {

		super.copy( source );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

}

SpotLight.prototype.isSpotLight = true;

const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld = /*@__PURE__*/ new Vector3();
const _lookTarget = /*@__PURE__*/ new Vector3();

class PointLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		this._frameExtents = new Vector2( 4, 2 );

		this._viewportCount = 6;

		this._viewports = [
			// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//  xzXZ
			//   y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction

			// positive X
			new Vector4( 2, 1, 1, 1 ),
			// negative X
			new Vector4( 0, 1, 1, 1 ),
			// positive Z
			new Vector4( 3, 1, 1, 1 ),
			// negative Z
			new Vector4( 1, 1, 1, 1 ),
			// positive Y
			new Vector4( 3, 0, 1, 1 ),
			// negative Y
			new Vector4( 1, 0, 1, 1 )
		];

		this._cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];

		this._cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];

	}

	updateMatrices( light, viewportIndex = 0 ) {

		const camera = this.camera;
		const shadowMatrix = this.matrix;

		const far = light.distance || camera.far;

		if ( far !== camera.far ) {

			camera.far = far;
			camera.updateProjectionMatrix();

		}

		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( _lightPositionWorld );

		_lookTarget.copy( camera.position );
		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( _lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix );

	}

}

PointLightShadow.prototype.isPointLightShadow = true;

class PointLight extends Light {

	constructor( color, intensity, distance = 0, decay = 1 ) {

		super( color, intensity );

		this.type = 'PointLight';

		this.distance = distance;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new PointLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
		return this.intensity * 4 * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / ( 4 * Math.PI );

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source ) {

		super.copy( source );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

}

PointLight.prototype.isPointLight = true;

class DirectionalLightShadow extends LightShadow {

	constructor() {

		super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

	}

}

DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

class DirectionalLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source ) {

		super.copy( source );

		this.target = source.target.clone();
		this.shadow = source.shadow.clone();

		return this;

	}

}

DirectionalLight.prototype.isDirectionalLight = true;

class AmbientLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.type = 'AmbientLight';

	}

}

AmbientLight.prototype.isAmbientLight = true;

class RectAreaLight extends Light {

	constructor( color, intensity, width = 10, height = 10 ) {

		super( color, intensity );

		this.type = 'RectAreaLight';

		this.width = width;
		this.height = height;

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in nits)
		return this.intensity * this.width * this.height * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in nits) from the desired luminous power (in lumens)
		this.intensity = power / ( this.width * this.height * Math.PI );

	}

	copy( source ) {

		super.copy( source );

		this.width = source.width;
		this.height = source.height;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.width = this.width;
		data.object.height = this.height;

		return data;

	}

}

RectAreaLight.prototype.isRectAreaLight = true;

/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

class SphericalHarmonics3 {

	constructor() {

		this.coefficients = [];

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients.push( new Vector3() );

		}

	}

	set( coefficients ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].copy( coefficients[ i ] );

		}

		return this;

	}

	zero() {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].set( 0, 0, 0 );

		}

		return this;

	}

	// get the radiance in the direction of the normal
	// target is a Vector3
	getAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		// band 1
		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		return target;

	}

	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	// target is a Vector3
	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
	getIrradianceAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

		// band 1
		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

		return target;

	}

	add( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].add( sh.coefficients[ i ] );

		}

		return this;

	}

	addScaledSH( sh, s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		}

		return this;

	}

	scale( s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].multiplyScalar( s );

		}

		return this;

	}

	lerp( sh, alpha ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		}

		return this;

	}

	equals( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				return false;

			}

		}

		return true;

	}

	copy( sh ) {

		return this.set( sh.coefficients );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	fromArray( array, offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		}

		return array;

	}

	// evaluate the basis functions
	// shBasis is an Array[ 9 ]
	static getBasisAt( normal, shBasis ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		// band 0
		shBasis[ 0 ] = 0.282095;

		// band 1
		shBasis[ 1 ] = 0.488603 * y;
		shBasis[ 2 ] = 0.488603 * z;
		shBasis[ 3 ] = 0.488603 * x;

		// band 2
		shBasis[ 4 ] = 1.092548 * x * y;
		shBasis[ 5 ] = 1.092548 * y * z;
		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		shBasis[ 7 ] = 1.092548 * x * z;
		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	}

}

SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

class LightProbe extends Light {

	constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

		super( undefined, intensity );

		this.sh = sh;

	}

	copy( source ) {

		super.copy( source );

		this.sh.copy( source.sh );

		return this;

	}

	fromJSON( json ) {

		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		this.sh.fromArray( json.sh );

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.sh = this.sh.toArray();

		return data;

	}

}

LightProbe.prototype.isLightProbe = true;

class MaterialLoader extends Loader {

	constructor( manager ) {

		super( manager );
		this.textures = {};

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		const material = Material.fromType( json.type );

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.sheen !== undefined ) material.sheen = json.sheen;
		if ( json.sheenColor !== undefined ) material.sheenColor = new Color().setHex( json.sheenColor );
		if ( json.sheenRoughness !== undefined ) material.sheenRoughness = json.sheenRoughness;
		if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.specularIntensity !== undefined ) material.specularIntensity = json.specularIntensity;
		if ( json.specularColor !== undefined && material.specularColor !== undefined ) material.specularColor.setHex( json.specularColor );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
		if ( json.transmission !== undefined ) material.transmission = json.transmission;
		if ( json.thickness !== undefined ) material.thickness = json.thickness;
		if ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;
		if ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.combine !== undefined ) material.combine = json.combine;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;

		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;

		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

		if ( json.rotation !== undefined ) material.rotation = json.rotation;

		if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		if ( json.scale !== undefined ) material.scale = json.scale;

		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

		if ( json.dithering !== undefined ) material.dithering = json.dithering;

		if ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;
		if ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;

		if ( json.visible !== undefined ) material.visible = json.visible;

		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

		if ( json.userData !== undefined ) material.userData = json.userData;

		if ( json.vertexColors !== undefined ) {

			if ( typeof json.vertexColors === 'number' ) {

				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

			} else {

				material.vertexColors = json.vertexColors;

			}

		}

		// Shader Material

		if ( json.uniforms !== undefined ) {

			for ( const name in json.uniforms ) {

				const uniform = json.uniforms[ name ];

				material.uniforms[ name ] = {};

				switch ( uniform.type ) {

					case 't':
						material.uniforms[ name ].value = getTexture( uniform.value );
						break;

					case 'c':
						material.uniforms[ name ].value = new Color().setHex( uniform.value );
						break;

					case 'v2':
						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
						break;

					case 'v3':
						material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
						break;

					case 'v4':
						material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
						break;

					case 'm3':
						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
						break;

					case 'm4':
						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
						break;

					default:
						material.uniforms[ name ].value = uniform.value;

				}

			}

		}

		if ( json.defines !== undefined ) material.defines = json.defines;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

		if ( json.extensions !== undefined ) {

			for ( const key in json.extensions ) {

				material.extensions[ key ] = json.extensions[ key ];

			}

		}

		// Deprecated

		if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
		if ( json.normalScale !== undefined ) {

			let normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
		if ( json.specularIntensityMap !== undefined ) material.specularIntensityMap = getTexture( json.specularIntensityMap );
		if ( json.specularColorMap !== undefined ) material.specularColorMap = getTexture( json.specularColorMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

		if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );
		if ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );

		if ( json.sheenColorMap !== undefined ) material.sheenColorMap = getTexture( json.sheenColorMap );
		if ( json.sheenRoughnessMap !== undefined ) material.sheenRoughnessMap = getTexture( json.sheenRoughnessMap );

		return material;

	}

	setTextures( value ) {

		this.textures = value;
		return this;

	}

}

class LoaderUtils {

	static decodeText( array ) {

		if ( typeof TextDecoder !== 'undefined' ) {

			return new TextDecoder().decode( array );

		}

		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
		// throws a "maximum call stack size exceeded" error for large arrays.

		let s = '';

		for ( let i = 0, il = array.length; i < il; i ++ ) {

			// Implicitly assumes little-endian.
			s += String.fromCharCode( array[ i ] );

		}

		try {

			// merges multi-byte utf-8 characters.

			return decodeURIComponent( escape( s ) );

		} catch ( e ) { // see #16358

			return s;

		}

	}

	static extractUrlBase( url ) {

		const index = url.lastIndexOf( '/' );

		if ( index === - 1 ) return './';

		return url.slice( 0, index + 1 );

	}

	static resolveURL( url, path ) {

		// Invalid URL
		if ( typeof url !== 'string' || url === '' ) return '';

		// Host Relative URL
		if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

			path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

		}

		// Absolute URL http://,https://,//
		if ( /^(https?:)?\/\//i.test( url ) ) return url;

		// Data URI
		if ( /^data:.*,.*$/i.test( url ) ) return url;

		// Blob URL
		if ( /^blob:.*$/i.test( url ) ) return url;

		// Relative URL
		return path + url;

	}

}

class InstancedBufferGeometry extends BufferGeometry {

	constructor() {

		super();

		this.type = 'InstancedBufferGeometry';
		this.instanceCount = Infinity;

	}

	copy( source ) {

		super.copy( source );

		this.instanceCount = source.instanceCount;

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	toJSON() {

		const data = super.toJSON( this );

		data.instanceCount = this.instanceCount;

		data.isInstancedBufferGeometry = true;

		return data;

	}

}

InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

class BufferGeometryLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const interleavedBufferMap = {};
		const arrayBufferMap = {};

		function getInterleavedBuffer( json, uuid ) {

			if ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];

			const interleavedBuffers = json.interleavedBuffers;
			const interleavedBuffer = interleavedBuffers[ uuid ];

			const buffer = getArrayBuffer( json, interleavedBuffer.buffer );

			const array = getTypedArray( interleavedBuffer.type, buffer );
			const ib = new InterleavedBuffer( array, interleavedBuffer.stride );
			ib.uuid = interleavedBuffer.uuid;

			interleavedBufferMap[ uuid ] = ib;

			return ib;

		}

		function getArrayBuffer( json, uuid ) {

			if ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];

			const arrayBuffers = json.arrayBuffers;
			const arrayBuffer = arrayBuffers[ uuid ];

			const ab = new Uint32Array( arrayBuffer ).buffer;

			arrayBufferMap[ uuid ] = ab;

			return ab;

		}

		const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

		const index = json.data.index;

		if ( index !== undefined ) {

			const typedArray = getTypedArray( index.type, index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

		}

		const attributes = json.data.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];
			let bufferAttribute;

			if ( attribute.isInterleavedBufferAttribute ) {

				const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
				bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

			} else {

				const typedArray = getTypedArray( attribute.type, attribute.array );
				const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
				bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );

			}

			if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
			if ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );

			if ( attribute.updateRange !== undefined ) {

				bufferAttribute.updateRange.offset = attribute.updateRange.offset;
				bufferAttribute.updateRange.count = attribute.updateRange.count;

			}

			geometry.setAttribute( key, bufferAttribute );

		}

		const morphAttributes = json.data.morphAttributes;

		if ( morphAttributes ) {

			for ( const key in morphAttributes ) {

				const attributeArray = morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];
					let bufferAttribute;

					if ( attribute.isInterleavedBufferAttribute ) {

						const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
						bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

					} else {

						const typedArray = getTypedArray( attribute.type, attribute.array );
						bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );

					}

					if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
					array.push( bufferAttribute );

				}

				geometry.morphAttributes[ key ] = array;

			}

		}

		const morphTargetsRelative = json.data.morphTargetsRelative;

		if ( morphTargetsRelative ) {

			geometry.morphTargetsRelative = true;

		}

		const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( let i = 0, n = groups.length; i !== n; ++ i ) {

				const group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		const boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			const center = new Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

		}

		if ( json.name ) geometry.name = json.name;
		if ( json.userData ) geometry.userData = json.userData;

		return geometry;

	}

}

class ObjectLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			let json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				if ( onError !== undefined ) onError( error );

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

				return;

			}

			const metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	}

	async loadAsync( url, onProgress ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		const text = await loader.loadAsync( url, onProgress );

		const json = JSON.parse( text );

		const metadata = json.metadata;

		if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

			throw new Error( 'THREE.ObjectLoader: Can\'t load ' + url );

		}

		return await scope.parseAsync( json );

	}

	parse( json, onLoad ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, textures, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		//

		if ( onLoad !== undefined ) {

			let hasImages = false;

			for ( const uuid in images ) {

				if ( images[ uuid ] instanceof HTMLImageElement ) {

					hasImages = true;
					break;

				}

			}

			if ( hasImages === false ) onLoad( object );

		}

		return object;

	}

	async parseAsync( json ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = await this.parseImagesAsync( json.images );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, textures, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		return object;

	}

	parseShapes( json ) {

		const shapes = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const shape = new Shape().fromJSON( json[ i ] );

				shapes[ shape.uuid ] = shape;

			}

		}

		return shapes;

	}

	parseSkeletons( json, object ) {

		const skeletons = {};
		const bones = {};

		// generate bone lookup table

		object.traverse( function ( child ) {

			if ( child.isBone ) bones[ child.uuid ] = child;

		} );

		// create skeletons

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const skeleton = new Skeleton().fromJSON( json[ i ], bones );

				skeletons[ skeleton.uuid ] = skeleton;

			}

		}

		return skeletons;

	}

	parseGeometries( json, shapes ) {

		const geometries = {};

		if ( json !== undefined ) {

			const bufferGeometryLoader = new BufferGeometryLoader();

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				let geometry;
				const data = json[ i ];

				switch ( data.type ) {

					case 'BufferGeometry':
					case 'InstancedBufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						console.error( 'THREE.ObjectLoader: The legacy Geometry type is no longer supported.' );

						break;

					default:

						if ( data.type in Geometries ) {

							geometry = Geometries[ data.type ].fromJSON( data, shapes );

						} else {

							console.warn( `THREE.ObjectLoader: Unsupported geometry type "${ data.type }"` );

						}

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;
				if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	}

	parseMaterials( json, textures ) {

		const cache = {}; // MultiMaterial
		const materials = {};

		if ( json !== undefined ) {

			const loader = new MaterialLoader();
			loader.setTextures( textures );

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.type === 'MultiMaterial' ) {

					// Deprecated

					const array = [];

					for ( let j = 0; j < data.materials.length; j ++ ) {

						const material = data.materials[ j ];

						if ( cache[ material.uuid ] === undefined ) {

							cache[ material.uuid ] = loader.parse( material );

						}

						array.push( cache[ material.uuid ] );

					}

					materials[ data.uuid ] = array;

				} else {

					if ( cache[ data.uuid ] === undefined ) {

						cache[ data.uuid ] = loader.parse( data );

					}

					materials[ data.uuid ] = cache[ data.uuid ];

				}

			}

		}

		return materials;

	}

	parseAnimations( json ) {

		const animations = {};

		if ( json !== undefined ) {

			for ( let i = 0; i < json.length; i ++ ) {

				const data = json[ i ];

				const clip = AnimationClip.parse( data );

				animations[ clip.uuid ] = clip;

			}

		}

		return animations;

	}

	parseImages( json, onLoad ) {

		const scope = this;
		const images = {};

		let loader;

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

		}

		function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return loadImage( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			const manager = new LoadingManager( onLoad );

			loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					const imageArray = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								imageArray.push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								imageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

					images[ image.uuid ] = new Source( imageArray );

				} else {

					// load single image

					const deserializedImage = deserializeImage( image.url );
					images[ image.uuid ] = new Source( deserializedImage );


				}

			}

		}

		return images;

	}

	async parseImagesAsync( json ) {

		const scope = this;
		const images = {};

		let loader;

		async function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return await loader.loadAsync( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					const imageArray = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = await deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								imageArray.push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								imageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

					images[ image.uuid ] = new Source( imageArray );

				} else {

					// load single image

					const deserializedImage = await deserializeImage( image.url );
					images[ image.uuid ] = new Source( deserializedImage );

				}

			}

		}

		return images;

	}

	parseTextures( json, images ) {

		function parseConstant( value, type ) {

			if ( typeof value === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		const textures = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				const source = images[ data.image ];
				const image = source.data;

				let texture;

				if ( Array.isArray( image ) ) {

					texture = new CubeTexture();

					if ( image.length === 6 ) texture.needsUpdate = true;

				} else {

					if ( image && image.data ) {

						texture = new DataTexture();

					} else {

						texture = new Texture();

					}

					if ( image ) texture.needsUpdate = true; // textures can have undefined image data

				}

				texture.source = source;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

				}

				if ( data.format !== undefined ) texture.format = data.format;
				if ( data.type !== undefined ) texture.type = data.type;
				if ( data.encoding !== undefined ) texture.encoding = data.encoding;

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

				if ( data.userData !== undefined ) texture.userData = data.userData;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	}

	parseObject( data, geometries, materials, textures, animations ) {

		let object;

		function getGeometry( name ) {

			if ( geometries[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

			}

			return geometries[ name ];

		}

		function getMaterial( name ) {

			if ( name === undefined ) return undefined;

			if ( Array.isArray( name ) ) {

				const array = [];

				for ( let i = 0, l = name.length; i < l; i ++ ) {

					const uuid = name[ i ];

					if ( materials[ uuid ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

					}

					array.push( materials[ uuid ] );

				}

				return array;

			}

			if ( materials[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined material', name );

			}

			return materials[ name ];

		}

		function getTexture( uuid ) {

			if ( textures[ uuid ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined texture', uuid );

			}

			return textures[ uuid ];

		}

		let geometry, material;

		switch ( data.type ) {

			case 'Scene':

				object = new Scene();

				if ( data.background !== undefined ) {

					if ( Number.isInteger( data.background ) ) {

						object.background = new Color( data.background );

					} else {

						object.background = getTexture( data.background );

					}

				}

				if ( data.environment !== undefined ) {

					object.environment = getTexture( data.environment );

				}

				if ( data.fog !== undefined ) {

					if ( data.fog.type === 'Fog' ) {

						object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

					} else if ( data.fog.type === 'FogExp2' ) {

						object.fog = new FogExp2( data.fog.color, data.fog.density );

					}

				}

				break;

			case 'PerspectiveCamera':

				object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

				if ( data.focus !== undefined ) object.focus = data.focus;
				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
				if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'OrthographicCamera':

				object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'AmbientLight':

				object = new AmbientLight( data.color, data.intensity );

				break;

			case 'DirectionalLight':

				object = new DirectionalLight( data.color, data.intensity );

				break;

			case 'PointLight':

				object = new PointLight( data.color, data.intensity, data.distance, data.decay );

				break;

			case 'RectAreaLight':

				object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

				break;

			case 'SpotLight':

				object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

				break;

			case 'HemisphereLight':

				object = new HemisphereLight( data.color, data.groundColor, data.intensity );

				break;

			case 'LightProbe':

				object = new LightProbe().fromJSON( data );

				break;

			case 'SkinnedMesh':

				geometry = getGeometry( data.geometry );
			 	material = getMaterial( data.material );

				object = new SkinnedMesh( geometry, material );

				if ( data.bindMode !== undefined ) object.bindMode = data.bindMode;
				if ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );
				if ( data.skeleton !== undefined ) object.skeleton = data.skeleton;

				break;

			case 'Mesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );

				object = new Mesh( geometry, material );

				break;

			case 'InstancedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );
				const count = data.count;
				const instanceMatrix = data.instanceMatrix;
				const instanceColor = data.instanceColor;

				object = new InstancedMesh( geometry, material, count );
				object.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );
				if ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );

				break;

			case 'LOD':

				object = new LOD();

				break;

			case 'Line':

				object = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineLoop':

				object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineSegments':

				object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'PointCloud':
			case 'Points':

				object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'Sprite':

				object = new Sprite( getMaterial( data.material ) );

				break;

			case 'Group':

				object = new Group();

				break;

			case 'Bone':

				object = new Bone();

				break;

			default:

				object = new Object3D();

		}

		object.uuid = data.uuid;

		if ( data.name !== undefined ) object.name = data.name;

		if ( data.matrix !== undefined ) {

			object.matrix.fromArray( data.matrix );

			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

		} else {

			if ( data.position !== undefined ) object.position.fromArray( data.position );
			if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
			if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
			if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

		}

		if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
		if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

		if ( data.shadow ) {

			if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
			if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
			if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
			if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
			if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

		}

		if ( data.visible !== undefined ) object.visible = data.visible;
		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
		if ( data.userData !== undefined ) object.userData = data.userData;
		if ( data.layers !== undefined ) object.layers.mask = data.layers;

		if ( data.children !== undefined ) {

			const children = data.children;

			for ( let i = 0; i < children.length; i ++ ) {

				object.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );

			}

		}

		if ( data.animations !== undefined ) {

			const objectAnimations = data.animations;

			for ( let i = 0; i < objectAnimations.length; i ++ ) {

				const uuid = objectAnimations[ i ];

				object.animations.push( animations[ uuid ] );

			}

		}

		if ( data.type === 'LOD' ) {

			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

			const levels = data.levels;

			for ( let l = 0; l < levels.length; l ++ ) {

				const level = levels[ l ];
				const child = object.getObjectByProperty( 'uuid', level.object );

				if ( child !== undefined ) {

					object.addLevel( child, level.distance );

				}

			}

		}

		return object;

	}

	bindSkeletons( object, skeletons ) {

		if ( Object.keys( skeletons ).length === 0 ) return;

		object.traverse( function ( child ) {

			if ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {

				const skeleton = skeletons[ child.skeleton ];

				if ( skeleton === undefined ) {

					console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );

				} else {

					child.bind( skeleton, child.bindMatrix );

				}

			}

		} );

	}

	/* DEPRECATED */

	setTexturePath( value ) {

		console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
		return this.setResourcePath( value );

	}

}

const TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping
};

const TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};

const TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

class ImageBitmapLoader extends Loader {

	constructor( manager ) {

		super( manager );

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		this.options = { premultiplyAlpha: 'none' };

	}

	setOptions( options ) {

		this.options = options;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const fetchOptions = {};
		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
		fetchOptions.headers = this.requestHeader;

		fetch( url, fetchOptions ).then( function ( res ) {

			return res.blob();

		} ).then( function ( blob ) {

			return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

		} ).then( function ( imageBitmap ) {

			Cache.add( url, imageBitmap );

			if ( onLoad ) onLoad( imageBitmap );

			scope.manager.itemEnd( url );

		} ).catch( function ( e ) {

			if ( onError ) onError( e );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		} );

		scope.manager.itemStart( url );

	}

}

ImageBitmapLoader.prototype.isImageBitmapLoader = true;

let _context;

const AudioContext = {

	getContext: function () {

		if ( _context === undefined ) {

			_context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return _context;

	},

	setContext: function ( value ) {

		_context = value;

	}

};

class AudioLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( buffer ) {

			try {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				const bufferCopy = buffer.slice( 0 );

				const context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

}

class HemisphereLightProbe extends LightProbe {

	constructor( skyColor, groundColor, intensity = 1 ) {

		super( undefined, intensity );

		const color1 = new Color().set( skyColor );
		const color2 = new Color().set( groundColor );

		const sky = new Vector3( color1.r, color1.g, color1.b );
		const ground = new Vector3( color2.r, color2.g, color2.b );

		// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
		const c0 = Math.sqrt( Math.PI );
		const c1 = c0 * Math.sqrt( 0.75 );

		this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
		this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

	}

}

HemisphereLightProbe.prototype.isHemisphereLightProbe = true;

class AmbientLightProbe extends LightProbe {

	constructor( color, intensity = 1 ) {

		super( undefined, intensity );

		const color1 = new Color().set( color );

		// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
		this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

	}

}

AmbientLightProbe.prototype.isAmbientLightProbe = true;

const _eyeRight = /*@__PURE__*/ new Matrix4();
const _eyeLeft = /*@__PURE__*/ new Matrix4();
const _projectionMatrix = /*@__PURE__*/ new Matrix4();

class StereoCamera {

	constructor() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

		this._cache = {
			focus: null,
			fov: null,
			aspect: null,
			near: null,
			far: null,
			zoom: null,
			eyeSep: null
		};

	}

	update( camera ) {

		const cache = this._cache;

		const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
			cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
			cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

		if ( needsUpdate ) {

			cache.focus = camera.focus;
			cache.fov = camera.fov;
			cache.aspect = camera.aspect * this.aspect;
			cache.near = camera.near;
			cache.far = camera.far;
			cache.zoom = camera.zoom;
			cache.eyeSep = this.eyeSep;

			// Off-axis stereoscopic effect based on
			// http://paulbourke.net/stereographics/stereorender/

			_projectionMatrix.copy( camera.projectionMatrix );
			const eyeSepHalf = cache.eyeSep / 2;
			const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
			const ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
			let xmin, xmax;

			// translate xOffset

			_eyeLeft.elements[ 12 ] = - eyeSepHalf;
			_eyeRight.elements[ 12 ] = eyeSepHalf;

			// for left eye

			xmin = - ymax * cache.aspect + eyeSepOnProjection;
			xmax = ymax * cache.aspect + eyeSepOnProjection;

			_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraL.projectionMatrix.copy( _projectionMatrix );

			// for right eye

			xmin = - ymax * cache.aspect - eyeSepOnProjection;
			xmax = ymax * cache.aspect - eyeSepOnProjection;

			_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraR.projectionMatrix.copy( _projectionMatrix );

		}

		this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
		this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

	}

}

class Clock {

	constructor( autoStart = true ) {

		this.autoStart = autoStart;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	start() {

		this.startTime = now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	}

	stop() {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	}

	getElapsedTime() {

		this.getDelta();
		return this.elapsedTime;

	}

	getDelta() {

		let diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			const newTime = now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

}

function now() {

	return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

}

const _position$1 = /*@__PURE__*/ new Vector3();
const _quaternion$1 = /*@__PURE__*/ new Quaternion();
const _scale$1 = /*@__PURE__*/ new Vector3();
const _orientation$1 = /*@__PURE__*/ new Vector3();

class AudioListener extends Object3D {

	constructor() {

		super();

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

		this.timeDelta = 0;

		// private

		this._clock = new Clock();

	}

	getInput() {

		return this.gain;

	}

	removeFilter() {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

		return this;

	}

	getFilter() {

		return this.filter;

	}

	setFilter( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

		return this;

	}

	getMasterVolume() {

		return this.gain.gain.value;

	}

	setMasterVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		const listener = this.context.listener;
		const up = this.up;

		this.timeDelta = this._clock.getDelta();

		this.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );

		_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );

		if ( listener.positionX ) {

			// code path for Chrome (see #14393)

			const endTime = this.context.currentTime + this.timeDelta;

			listener.positionX.linearRampToValueAtTime( _position$1.x, endTime );
			listener.positionY.linearRampToValueAtTime( _position$1.y, endTime );
			listener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );
			listener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );
			listener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );
			listener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );
			listener.upX.linearRampToValueAtTime( up.x, endTime );
			listener.upY.linearRampToValueAtTime( up.y, endTime );
			listener.upZ.linearRampToValueAtTime( up.z, endTime );

		} else {

			listener.setPosition( _position$1.x, _position$1.y, _position$1.z );
			listener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );

		}

	}

}

class Audio extends Object3D {

	constructor( listener ) {

		super();

		this.type = 'Audio';

		this.listener = listener;
		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.loopStart = 0;
		this.loopEnd = 0;
		this.offset = 0;
		this.duration = undefined;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.source = null;
		this.sourceType = 'empty';

		this._startedAt = 0;
		this._progress = 0;
		this._connected = false;

		this.filters = [];

	}

	getOutput() {

		return this.gain;

	}

	setNodeSource( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	}

	setMediaElementSource( mediaElement ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaNode';
		this.source = this.context.createMediaElementSource( mediaElement );
		this.connect();

		return this;

	}

	setMediaStreamSource( mediaStream ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaStreamNode';
		this.source = this.context.createMediaStreamSource( mediaStream );
		this.connect();

		return this;

	}

	setBuffer( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	}

	play( delay = 0 ) {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._startedAt = this.context.currentTime + delay;

		const source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.loop = this.loop;
		source.loopStart = this.loopStart;
		source.loopEnd = this.loopEnd;
		source.onended = this.onEnded.bind( this );
		source.start( this._startedAt, this._progress + this.offset, this.duration );

		this.isPlaying = true;

		this.source = source;

		this.setDetune( this.detune );
		this.setPlaybackRate( this.playbackRate );

		return this.connect();

	}

	pause() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		if ( this.isPlaying === true ) {

			// update current progress

			this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

			if ( this.loop === true ) {

				// ensure _progress does not exceed duration with looped audios

				this._progress = this._progress % ( this.duration || this.buffer.duration );

			}

			this.source.stop();
			this.source.onended = null;

			this.isPlaying = false;

		}

		return this;

	}

	stop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._progress = 0;

		this.source.stop();
		this.source.onended = null;
		this.isPlaying = false;

		return this;

	}

	connect() {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		this._connected = true;

		return this;

	}

	disconnect() {

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		this._connected = false;

		return this;

	}

	getFilters() {

		return this.filters;

	}

	setFilters( value ) {

		if ( ! value ) value = [];

		if ( this._connected === true ) {

			this.disconnect();
			this.filters = value.slice();
			this.connect();

		} else {

			this.filters = value.slice();

		}

		return this;

	}

	setDetune( value ) {

		this.detune = value;

		if ( this.source.detune === undefined ) return; // only set detune when available

		if ( this.isPlaying === true ) {

			this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getDetune() {

		return this.detune;

	}

	getFilter() {

		return this.getFilters()[ 0 ];

	}

	setFilter( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	}

	setPlaybackRate( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getPlaybackRate() {

		return this.playbackRate;

	}

	onEnded() {

		this.isPlaying = false;

	}

	getLoop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	}

	setLoop( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	}

	setLoopStart( value ) {

		this.loopStart = value;

		return this;

	}

	setLoopEnd( value ) {

		this.loopEnd = value;

		return this;

	}

	getVolume() {

		return this.gain.gain.value;

	}

	setVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

}

const _position = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new Quaternion();
const _scale = /*@__PURE__*/ new Vector3();
const _orientation = /*@__PURE__*/ new Vector3();

class PositionalAudio extends Audio {

	constructor( listener ) {

		super( listener );

		this.panner = this.context.createPanner();
		this.panner.panningModel = 'HRTF';
		this.panner.connect( this.gain );

	}

	disconnect() {

		super.disconnect();

		this.panner.disconnect( this.gain );

	}

	getOutput() {

		return this.panner;

	}

	getRefDistance() {

		return this.panner.refDistance;

	}

	setRefDistance( value ) {

		this.panner.refDistance = value;

		return this;

	}

	getRolloffFactor() {

		return this.panner.rolloffFactor;

	}

	setRolloffFactor( value ) {

		this.panner.rolloffFactor = value;

		return this;

	}

	getDistanceModel() {

		return this.panner.distanceModel;

	}

	setDistanceModel( value ) {

		this.panner.distanceModel = value;

		return this;

	}

	getMaxDistance() {

		return this.panner.maxDistance;

	}

	setMaxDistance( value ) {

		this.panner.maxDistance = value;

		return this;

	}

	setDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

		this.panner.coneInnerAngle = coneInnerAngle;
		this.panner.coneOuterAngle = coneOuterAngle;
		this.panner.coneOuterGain = coneOuterGain;

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

		this.matrixWorld.decompose( _position, _quaternion, _scale );

		_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );

		const panner = this.panner;

		if ( panner.positionX ) {

			// code path for Chrome and Firefox (see #14393)

			const endTime = this.context.currentTime + this.listener.timeDelta;

			panner.positionX.linearRampToValueAtTime( _position.x, endTime );
			panner.positionY.linearRampToValueAtTime( _position.y, endTime );
			panner.positionZ.linearRampToValueAtTime( _position.z, endTime );
			panner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );
			panner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );
			panner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );

		} else {

			panner.setPosition( _position.x, _position.y, _position.z );
			panner.setOrientation( _orientation.x, _orientation.y, _orientation.z );

		}

	}

}

class AudioAnalyser {

	constructor( audio, fftSize = 2048 ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}


	getFrequencyData() {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	}

	getAverageFrequency() {

		let value = 0;
		const data = this.getFrequencyData();

		for ( let i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

}

class PropertyMixer {

	constructor( binding, typeName, valueSize ) {

		this.binding = binding;
		this.valueSize = valueSize;

		let mixFunction,
			mixFunctionAdditive,
			setIdentity;

		// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
		//
		// 'add' is used for additive cumulative results
		//
		// 'work' is optional and is only present for quaternion types. It is used
		// to store intermediate quaternion multiplication results

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				mixFunctionAdditive = this._slerpAdditive;
				setIdentity = this._setAdditiveIdentityQuaternion;

				this.buffer = new Float64Array( valueSize * 6 );
				this._workIndex = 5;
				break;

			case 'string':
			case 'bool':
				mixFunction = this._select;

				// Use the regular mix function and for additive on these types,
				// additive is not relevant for non-numeric types
				mixFunctionAdditive = this._select;

				setIdentity = this._setAdditiveIdentityOther;

				this.buffer = new Array( valueSize * 5 );
				break;

			default:
				mixFunction = this._lerp;
				mixFunctionAdditive = this._lerpAdditive;
				setIdentity = this._setAdditiveIdentityNumeric;

				this.buffer = new Float64Array( valueSize * 5 );

		}

		this._mixBufferRegion = mixFunction;
		this._mixBufferRegionAdditive = mixFunctionAdditive;
		this._setIdentity = setIdentity;
		this._origIndex = 3;
		this._addIndex = 4;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	}

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride;

		let currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			const mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	}

	// accumulate data in the 'incoming' region into 'add'
	accumulateAdditive( weight ) {

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = stride * this._addIndex;

		if ( this.cumulativeWeightAdditive === 0 ) {

			// add = identity

			this._setIdentity();

		}

		// add := add + incoming * weight

		this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
		this.cumulativeWeightAdditive += weight;

	}

	// apply the state of 'accu<i>' to the binding when accus differ
	apply( accuIndex ) {

		const stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,
			weightAdditive = this.cumulativeWeightAdditive,

			binding = this.binding;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			const originalValueOffset = stride * this._origIndex;

			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		if ( weightAdditive > 0 ) {

			// accuN := accuN + additive accuN

			this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

		}

		for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	}

	// remember the state of the bound property and copy it to both accus
	saveOriginalState() {

		const binding = this.binding;

		const buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * this._origIndex;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		// Add to identity for additive
		this._setIdentity();

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

	}

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState() {

		const originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	}

	_setAdditiveIdentityNumeric() {

		const startIndex = this._addIndex * this.valueSize;
		const endIndex = startIndex + this.valueSize;

		for ( let i = startIndex; i < endIndex; i ++ ) {

			this.buffer[ i ] = 0;

		}

	}

	_setAdditiveIdentityQuaternion() {

		this._setAdditiveIdentityNumeric();
		this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

	}

	_setAdditiveIdentityOther() {

		const startIndex = this._origIndex * this.valueSize;
		const targetIndex = this._addIndex * this.valueSize;

		for ( let i = 0; i < this.valueSize; i ++ ) {

			this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

		}

	}


	// mix functions

	_select( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	}

	_slerp( buffer, dstOffset, srcOffset, t ) {

		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	}

	_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		const workOffset = this._workIndex * stride;

		// Store result in intermediate buffer offset
		Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

		// Slerp to the intermediate result
		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

	}

	_lerp( buffer, dstOffset, srcOffset, t, stride ) {

		const s = 1 - t;

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

	_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

		}

	}

}

// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

const _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

const _supportedObjectNames = [ 'material', 'materials', 'bones' ];

class Composite {

	constructor( targetGroup, path, optionalParsedPath ) {

		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	getValue( array, offset ) {

		this.bind(); // bind all binding

		const firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	}

	setValue( array, offset ) {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	}

	bind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	}

	unbind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

}

// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class PropertyBinding {

	constructor( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		this.rootNode = rootNode;

		// initial state of these methods that calls 'bind'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}


	static create( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	}

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	static sanitizeNodeName( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	}

	static parseTrackName( trackName ) {

		const matches = _trackRe.exec( trackName );

		if ( matches === null ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		const results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== - 1 ) {

			const objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against an allowlist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	}

	static findNode( root, nodeName ) {

		if ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			const bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			const searchNodeSubtree = function ( children ) {

				for ( let i = 0; i < children.length; i ++ ) {

					const childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					const result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			const subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

	// these are used to "bind" a nonexistent property
	_getValue_unavailable() {}
	_setValue_unavailable() {}

	// Getters

	_getValue_direct( buffer, offset ) {

		buffer[ offset ] = this.targetObject[ this.propertyName ];

	}

	_getValue_array( buffer, offset ) {

		const source = this.resolvedProperty;

		for ( let i = 0, n = source.length; i !== n; ++ i ) {

			buffer[ offset ++ ] = source[ i ];

		}

	}

	_getValue_arrayElement( buffer, offset ) {

		buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

	}

	_getValue_toArray( buffer, offset ) {

		this.resolvedProperty.toArray( buffer, offset );

	}

	// Direct

	_setValue_direct( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];

	}

	_setValue_direct_setNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// EntireArray

	_setValue_array( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

	}

	_setValue_array_setNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.needsUpdate = true;

	}

	_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// ArrayElement

	_setValue_arrayElement( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

	}

	_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// HasToFromArray

	_setValue_fromArray( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );

	}

	_setValue_fromArray_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.needsUpdate = true;

	}

	_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	_getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

	}

	_setValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	}

	// create getter / setter pair for a property in the scene graph
	bind() {

		let targetObject = this.node;
		const parsedPath = this.parsedPath;

		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			return;

		}

		if ( objectName ) {

			let objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( let i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		const nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			const nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		let versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		let bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === 'morphTargetInfluences' ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( targetObject.geometry.isBufferGeometry ) {

					if ( ! targetObject.geometry.morphAttributes ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
						return;

					}

					if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

						propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

					}


				} else {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );
					return;

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	}

	unbind() {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

}

PropertyBinding.Composite = Composite;

PropertyBinding.prototype.BindingType = {
	Direct: 0,
	EntireArray: 1,
	ArrayElement: 2,
	HasFromToArray: 3
};

PropertyBinding.prototype.Versioning = {
	None: 0,
	NeedsUpdate: 1,
	MatrixWorldNeedsUpdate: 2
};

PropertyBinding.prototype.GetterByBindingType = [

	PropertyBinding.prototype._getValue_direct,
	PropertyBinding.prototype._getValue_array,
	PropertyBinding.prototype._getValue_arrayElement,
	PropertyBinding.prototype._getValue_toArray,

];

PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

	[
		// Direct
		PropertyBinding.prototype._setValue_direct,
		PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
		PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

	], [

		// EntireArray

		PropertyBinding.prototype._setValue_array,
		PropertyBinding.prototype._setValue_array_setNeedsUpdate,
		PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

	], [

		// ArrayElement
		PropertyBinding.prototype._setValue_arrayElement,
		PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
		PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

	], [

		// HasToFromArray
		PropertyBinding.prototype._setValue_fromArray,
		PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
		PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

	]

];

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */

class AnimationObjectGroup {

	constructor() {

		this.uuid = generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite

		const indices = {};
		this._indicesByUUID = indices; // for bookkeeping

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = []; // inside: string
		this._parsedPaths = []; // inside: { we don't care, here }
		this._bindings = []; // inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

		const scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	add() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		let knownObject = undefined,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid;
			let index = indicesByUUID[ uuid ];

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				const firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ];

					let binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject ) {

				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
					'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	remove() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				const lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// remove & forget
	uncache() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_,
			nObjects = objects.length;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					const firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					const lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					if ( lastIndex > 0 ) {

						indicesByUUID[ lastObject.uuid ] = index;

					}

					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_( path, parsedPath ) {

		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		const indicesByPath = this._bindingsIndicesByPath;
		let index = indicesByPath[ path ];
		const bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		const paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

			const object = objects[ i ];
			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	}

	unsubscribe_( path ) {

		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		const indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

}

AnimationObjectGroup.prototype.isAnimationObjectGroup = true;

class AnimationAction {

	constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot;
		this.blendMode = blendMode;

		const tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		const interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( let i = 0; i !== nTracks; ++ i ) {

			const interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants; // bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; // no. of repetitions when looping

		this.paused = false; // true -> zero effective time scale
		this.enabled = true; // false -> zero effective weight

		this.clampWhenFinished = false;// keep feeding the last frame?

		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd = true;// clips for start, loop and end

	}

	// State & Scheduling

	play() {

		this._mixer._activateAction( this );

		return this;

	}

	stop() {

		this._mixer._deactivateAction( this );

		return this.reset();

	}

	reset() {

		this.paused = false;
		this.enabled = true;

		this.time = 0; // restart clip
		this._loopCount = - 1;// forget previous loops
		this._startTime = null;// forget scheduling

		return this.stopFading().stopWarping();

	}

	isRunning() {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
			this._startTime === null && this._mixer._isActiveAction( this );

	}

	// return true when play has been called
	isScheduled() {

		return this._mixer._isActiveAction( this );

	}

	startAt( time ) {

		this._startTime = time;

		return this;

	}

	setLoop( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	}

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	}

	// return the weight considering fading and .enabled
	getEffectiveWeight() {

		return this._effectiveWeight;

	}

	fadeIn( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	}

	fadeOut( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	}

	crossFadeFrom( fadeOutAction, duration, warp ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if ( warp ) {

			const fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	}

	crossFadeTo( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	}

	stopFading() {

		const weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	}

	// Time Scale Control

	// set the time scale stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 : timeScale;

		return this.stopWarping();

	}

	// return the time scale considering warping and .paused
	getEffectiveTimeScale() {

		return this._effectiveTimeScale;

	}

	setDuration( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	}

	syncWith( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	}

	halt( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	}

	warp( startTimeScale, endTimeScale, duration ) {

		const mixer = this._mixer,
			now = mixer.time,
			timeScale = this.timeScale;

		let interpolant = this._timeScaleInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	}

	stopWarping() {

		const timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	}

	// Object Accessors

	getMixer() {

		return this._mixer;

	}

	getClip() {

		return this._clip;

	}

	getRoot() {

		return this._localRoot || this._mixer._root;

	}

	// Interna

	_update( time, deltaTime, timeDirection, accuIndex ) {

		// called by the mixer

		if ( ! this.enabled ) {

			// call ._updateWeight() to update ._effectiveWeight

			this._updateWeight( time );
			return;

		}

		const startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			const timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				return; // yet to come / don't decide when delta = 0

			}

			// start

			this._startTime = null; // unschedule
			deltaTime = timeDirection * timeRunning;

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		const clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		const weight = this._updateWeight( time );

		if ( weight > 0 ) {

			const interpolants = this._interpolants;
			const propertyMixers = this._propertyBindings;

			switch ( this.blendMode ) {

				case AdditiveAnimationBlendMode:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulateAdditive( weight );

					}

					break;

				case NormalAnimationBlendMode:
				default:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

			}

		}

	}

	_updateWeight( time ) {

		let weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			const interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	}

	_updateTimeScale( time ) {

		let timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			const interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	}

	_updateTime( deltaTime ) {

		const duration = this._clip.duration;
		const loop = this.loop;

		let time = this.time + deltaTime;
		let loopCount = this._loopCount;

		const pingPong = ( loop === LoopPingPong );

		if ( deltaTime === 0 ) {

			if ( loopCount === - 1 ) return time;

			return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

		}

		if ( loop === LoopOnce ) {

			if ( loopCount === - 1 ) {

				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else {

					this.time = time;

					break handle_stop;

				}

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this.time = time;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? - 1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			if ( loopCount === - 1 ) {

				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings( true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings( this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {

				// wrap around

				const loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				const pending = this.repetitions - loopCount;

				if ( pending <= 0 ) {

					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : - 1
					} );

				} else {

					// keep running

					if ( pending === 1 ) {

						// entering the last round

						const atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			} else {

				this.time = time;

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {

				// invert time for the "pong round"

				return duration - time;

			}

		}

		return time;

	}

	_setEndings( atStart, atEnd, pingPong ) {

		const settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart = ZeroSlopeEnding;
			settings.endingEnd = ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingStart = WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = WrapAroundEnding;

			}

		}

	}

	_scheduleFading( duration, weightNow, weightThen ) {

		const mixer = this._mixer, now = mixer.time;
		let interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;
		values[ 1 ] = weightThen;

		return this;

	}

}

class AnimationMixer extends EventDispatcher {

	constructor( root ) {

		super();

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;
		this.time = 0;
		this.timeScale = 1.0;

	}

	_bindAction( action, prototypeAction ) {

		const root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName;

		let bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( let i = 0; i !== nTracks; ++ i ) {

			const track = tracks[ i ],
				trackName = track.name;

			let binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				++ binding.referenceCount;
				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				const path = prototypeAction && prototypeAction.
					_propertyBindings[ i ].binding.parsedPath;

				binding = new PropertyMixer(
					PropertyBinding.create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	}

	_activateAction( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				const rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			const bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	}

	_deactivateAction( action ) {

		if ( this._isActiveAction( action ) ) {

			const bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	}

	// Memory manager

	_initMemoryManager() {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 	knownActions: Array< AnimationAction > - used as prototypes
		// 	actionByRoot: AnimationAction - lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		const scope = this;

		this.stats = {

			actions: {
				get total() {

					return scope._actions.length;

				},
				get inUse() {

					return scope._nActiveActions;

				}
			},
			bindings: {
				get total() {

					return scope._bindings.length;

				},
				get inUse() {

					return scope._nActiveBindings;

				}
			},
			controlInterpolants: {
				get total() {

					return scope._controlInterpolants.length;

				},
				get inUse() {

					return scope._nActiveControlInterpolants;

				}
			}

		};

	}

	// Memory management for AnimationAction objects

	_isActiveAction( action ) {

		const index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	}

	_addInactiveAction( action, clipUuid, rootUuid ) {

		const actions = this._actions,
			actionsByClip = this._actionsByClip;

		let actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			const knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	}

	_removeInactiveAction( action ) {

		const actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		const clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		const actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	}

	_removeInactiveBindingsForAction( action ) {

		const bindings = action._propertyBindings;

		for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

			const binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	}

	_lendAction( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	}

	_takeBackAction( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	}

	// Memory management for PropertyMixer objects

	_addInactiveBinding( binding, rootUuid, trackName ) {

		const bindingsByRoot = this._bindingsByRootAndName,
			bindings = this._bindings;

		let bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	}

	_removeInactiveBinding( binding ) {

		const bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		if ( Object.keys( bindingByName ).length === 0 ) {

			delete bindingsByRoot[ rootUuid ];

		}

	}

	_lendBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	}

	_takeBackBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	}


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant() {

		const interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++;

		let interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new LinearInterpolant(
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, this._controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	}

	_takeBackControlInterpolant( interpolant ) {

		const interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	}

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction( clip, optionalRoot, blendMode ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid;

		let clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;

		const clipUuid = clipObject !== null ? clipObject.uuid : clip;

		const actionsForClip = this._actionsByClip[ clipUuid ];
		let prototypeAction = null;

		if ( blendMode === undefined ) {

			if ( clipObject !== null ) {

				blendMode = clipObject.blendMode;

			} else {

				blendMode = NormalAnimationBlendMode;

			}

		}

		if ( actionsForClip !== undefined ) {

			const existingAction = actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		const newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	}

	// get an existing action
	existingAction( clip, optionalRoot ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	}

	// deactivates all previously scheduled actions
	stopAllAction() {

		const actions = this._actions,
			nActions = this._nActiveActions;

		for ( let i = nActions - 1; i >= 0; -- i ) {

			actions[ i ].stop();

		}

		return this;

	}

	// advance the time and update apply the animation
	update( deltaTime ) {

		deltaTime *= this.timeScale;

		const actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( let i = 0; i !== nActions; ++ i ) {

			const action = actions[ i ];

			action._update( time, deltaTime, timeDirection, accuIndex );

		}

		// update scene graph

		const bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( let i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	}

	// Allows you to seek to a specific time in an animation.
	setTime( timeInSeconds ) {

		this.time = 0; // Zero out time attribute for AnimationMixer object;
		for ( let i = 0; i < this._actions.length; i ++ ) {

			this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		}

		return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

	}

	// return this mixer's root target object
	getRoot() {

		return this._root;

	}

	// free all resources specific to a particular clip
	uncacheClip( clip ) {

		const actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			const actionsToRemove = actionsForClip.knownActions;

			for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				const action = actionsToRemove[ i ];

				this._deactivateAction( action );

				const cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	}

	// free all resources specific to a particular root target object
	uncacheRoot( root ) {

		const rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( const clipUuid in actionsByClip ) {

			const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		const bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( const trackName in bindingByName ) {

				const binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	}

	// remove a targeted clip from the cache
	uncacheAction( clip, optionalRoot ) {

		const action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

}

AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array( 1 );

class Uniform {

	constructor( value ) {

		if ( typeof value === 'string' ) {

			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];

		}

		this.value = value;

	}

	clone() {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	}

}

class InstancedInterleavedBuffer extends InterleavedBuffer {

	constructor( array, stride, meshPerAttribute = 1 ) {

		super( array, stride );

		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	clone( data ) {

		const ib = super.clone( data );

		ib.meshPerAttribute = this.meshPerAttribute;

		return ib;

	}

	toJSON( data ) {

		const json = super.toJSON( data );

		json.isInstancedInterleavedBuffer = true;
		json.meshPerAttribute = this.meshPerAttribute;

		return json;

	}

}

InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

class GLBufferAttribute {

	constructor( buffer, type, itemSize, elementSize, count ) {

		this.buffer = buffer;
		this.type = type;
		this.itemSize = itemSize;
		this.elementSize = elementSize;
		this.count = count;

		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setBuffer( buffer ) {

		this.buffer = buffer;

		return this;

	}

	setType( type, elementSize ) {

		this.type = type;
		this.elementSize = elementSize;

		return this;

	}

	setItemSize( itemSize ) {

		this.itemSize = itemSize;

		return this;

	}

	setCount( count ) {

		this.count = count;

		return this;

	}

}

GLBufferAttribute.prototype.isGLBufferAttribute = true;

class Raycaster {

	constructor( origin, direction, near = 0, far = Infinity ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near;
		this.far = far;
		this.camera = null;
		this.layers = new Layers();

		this.params = {
			Mesh: {},
			Line: { threshold: 1 },
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

	}

	set( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	}

	setFromCamera( coords, camera ) {

		if ( camera.isPerspectiveCamera ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( camera.isOrthographicCamera ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

		}

	}

	intersectObject( object, recursive = true, intersects = [] ) {

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	}

	intersectObjects( objects, recursive = true, intersects = [] ) {

		for ( let i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.layers.test( raycaster.layers ) ) {

		object.raycast( raycaster, intersects );

	}

	if ( recursive === true ) {

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */

class Spherical {

	constructor( radius = 1, phi = 0, theta = 0 ) {

		this.radius = radius;
		this.phi = phi; // polar angle
		this.theta = theta; // azimuthal angle

		return this;

	}

	set( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	}

	// restrict phi to be between EPS and PI-EPS
	makeSafe() {

		const EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );

		}

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */

class Cylindrical {

	constructor( radius = 1, theta = 0, y = 0 ) {

		this.radius = radius; // distance from the origin to a point in the x-z plane
		this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = y; // height above the x-z plane

		return this;

	}

	set( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + z * z );
		this.theta = Math.atan2( x, z );
		this.y = y;

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$4 = /*@__PURE__*/ new Vector2();

class Box2 {

	constructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );
		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	}

	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	}

	intersectsBox( box ) {

		// using 4 splitting planes to rule out intersections

		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

	}

	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector$4.copy( point ).clamp( this.min, this.max );
		return clampedPoint.sub( point ).length();

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

Box2.prototype.isBox2 = true;

const _startP = /*@__PURE__*/ new Vector3();
const _startEnd = /*@__PURE__*/ new Vector3();

class Line3 {

	constructor( start = new Vector3(), end = new Vector3() ) {

		this.start = start;
		this.end = end;

	}

	set( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	}

	copy( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	}

	getCenter( target ) {

		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	}

	delta( target ) {

		return target.subVectors( this.end, this.start );

	}

	distanceSq() {

		return this.start.distanceToSquared( this.end );

	}

	distance() {

		return this.start.distanceTo( this.end );

	}

	at( t, target ) {

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	closestPointToPointParameter( point, clampToLine ) {

		_startP.subVectors( point, this.start );
		_startEnd.subVectors( this.end, this.start );

		const startEnd2 = _startEnd.dot( _startEnd );
		const startEnd_startP = _startEnd.dot( _startP );

		let t = startEnd_startP / startEnd2;

		if ( clampToLine ) {

			t = clamp( t, 0, 1 );

		}

		return t;

	}

	closestPointToPoint( point, clampToLine, target ) {

		const t = this.closestPointToPointParameter( point, clampToLine );

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	applyMatrix4( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	}

	equals( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$3 = /*@__PURE__*/ new Vector3();

class SpotLightHelper extends Object3D {

	constructor( light, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		const geometry = new BufferGeometry();

		const positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			const p1 = ( i / l ) * Math.PI * 2;
			const p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	dispose() {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	}

	update() {

		this.light.updateMatrixWorld();

		const coneLength = this.light.distance ? this.light.distance : 1000;
		const coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( _vector$3 );

		if ( this.color !== undefined ) {

			this.cone.material.color.set( this.color );

		} else {

			this.cone.material.color.copy( this.light.color );

		}

	}

}

const _vector$2 = /*@__PURE__*/ new Vector3();
const _boneMatrix = /*@__PURE__*/ new Matrix4();
const _matrixWorldInv = /*@__PURE__*/ new Matrix4();


class SkeletonHelper extends LineSegments {

	constructor( object ) {

		const bones = getBoneList( object );

		const geometry = new BufferGeometry();

		const vertices = [];
		const colors = [];

		const color1 = new Color( 0, 0, 1 );
		const color2 = new Color( 0, 1, 0 );

		for ( let i = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

		super( geometry, material );

		this.type = 'SkeletonHelper';
		this.isSkeletonHelper = true;

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	updateMatrixWorld( force ) {

		const bones = this.bones;

		const geometry = this.geometry;
		const position = geometry.getAttribute( 'position' );

		_matrixWorldInv.copy( this.root.matrixWorld ).invert();

		for ( let i = 0, j = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
				_vector$2.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
				_vector$2.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );

				j += 2;

			}

		}

		geometry.getAttribute( 'position' ).needsUpdate = true;

		super.updateMatrixWorld( force );

	}

}


function getBoneList( object ) {

	const boneList = [];

	if ( object.isBone === true ) {

		boneList.push( object );

	}

	for ( let i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

	}

	return boneList;

}

class PointLightHelper extends Mesh {

	constructor( light, sphereSize, color ) {

		const geometry = new SphereGeometry( sphereSize, 4, 2 );
		const material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

		super( geometry, material );

		this.light = light;
		this.light.updateMatrixWorld();

		this.color = color;

		this.type = 'PointLightHelper';

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

	update() {

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	}

}

const _vector$1 = /*@__PURE__*/ new Vector3();
const _color1 = /*@__PURE__*/ new Color();
const _color2 = /*@__PURE__*/ new Color();

class HemisphereLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		const geometry = new OctahedronGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
		if ( this.color === undefined ) this.material.vertexColors = true;

		const position = geometry.getAttribute( 'position' );
		const colors = new Float32Array( position.count * 3 );

		geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	dispose() {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

	update() {

		const mesh = this.children[ 0 ];

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			const colors = mesh.geometry.getAttribute( 'color' );

			_color1.copy( this.light.color );
			_color2.copy( this.light.groundColor );

			for ( let i = 0, l = colors.count; i < l; i ++ ) {

				const color = ( i < ( l / 2 ) ) ? _color1 : _color2;

				colors.setXYZ( i, color.r, color.g, color.b );

			}

			colors.needsUpdate = true;

		}

		mesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );

	}

}

class GridHelper extends LineSegments {

	constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const center = divisions / 2;
		const step = size / divisions;
		const halfSize = size / 2;

		const vertices = [], colors = [];

		for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			const color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'GridHelper';

	}

}

class PolarGridHelper extends LineSegments {

	constructor( radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const vertices = [];
		const colors = [];

		// create the radials

		for ( let i = 0; i <= radials; i ++ ) {

			const v = ( i / radials ) * ( Math.PI * 2 );

			const x = Math.sin( v ) * radius;
			const z = Math.cos( v ) * radius;

			vertices.push( 0, 0, 0 );
			vertices.push( x, 0, z );

			const color = ( i & 1 ) ? color1 : color2;

			colors.push( color.r, color.g, color.b );
			colors.push( color.r, color.g, color.b );

		}

		// create the circles

		for ( let i = 0; i <= circles; i ++ ) {

			const color = ( i & 1 ) ? color1 : color2;

			const r = radius - ( radius / circles * i );

			for ( let j = 0; j < divisions; j ++ ) {

				// first vertex

				let v = ( j / divisions ) * ( Math.PI * 2 );

				let x = Math.sin( v ) * r;
				let z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'PolarGridHelper';

	}

}

const _v1 = /*@__PURE__*/ new Vector3();
const _v2 = /*@__PURE__*/ new Vector3();
const _v3 = /*@__PURE__*/ new Vector3();

class DirectionalLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		if ( size === undefined ) size = 1;

		let geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	dispose() {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	}

	update() {

		_v1.setFromMatrixPosition( this.light.matrixWorld );
		_v2.setFromMatrixPosition( this.light.target.matrixWorld );
		_v3.subVectors( _v2, _v1 );

		this.lightPlane.lookAt( _v2 );

		if ( this.color !== undefined ) {

			this.lightPlane.material.color.set( this.color );
			this.targetLine.material.color.set( this.color );

		} else {

			this.lightPlane.material.color.copy( this.light.color );
			this.targetLine.material.color.copy( this.light.color );

		}

		this.targetLine.lookAt( _v2 );
		this.targetLine.scale.z = _v3.length();

	}

}

const _vector = /*@__PURE__*/ new Vector3();
const _camera = /*@__PURE__*/ new Camera();

/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html
 */

class CameraHelper extends LineSegments {

	constructor( camera ) {

		const geometry = new BufferGeometry();
		const material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );

		const vertices = [];
		const colors = [];

		const pointMap = {};

		// colors

		const colorFrustum = new Color( 0xffaa00 );
		const colorCone = new Color( 0xff0000 );
		const colorUp = new Color( 0x00aaff );
		const colorTarget = new Color( 0xffffff );
		const colorCross = new Color( 0x333333 );

		// near

		addLine( 'n1', 'n2', colorFrustum );
		addLine( 'n2', 'n4', colorFrustum );
		addLine( 'n4', 'n3', colorFrustum );
		addLine( 'n3', 'n1', colorFrustum );

		// far

		addLine( 'f1', 'f2', colorFrustum );
		addLine( 'f2', 'f4', colorFrustum );
		addLine( 'f4', 'f3', colorFrustum );
		addLine( 'f3', 'f1', colorFrustum );

		// sides

		addLine( 'n1', 'f1', colorFrustum );
		addLine( 'n2', 'f2', colorFrustum );
		addLine( 'n3', 'f3', colorFrustum );
		addLine( 'n4', 'f4', colorFrustum );

		// cone

		addLine( 'p', 'n1', colorCone );
		addLine( 'p', 'n2', colorCone );
		addLine( 'p', 'n3', colorCone );
		addLine( 'p', 'n4', colorCone );

		// up

		addLine( 'u1', 'u2', colorUp );
		addLine( 'u2', 'u3', colorUp );
		addLine( 'u3', 'u1', colorUp );

		// target

		addLine( 'c', 't', colorTarget );
		addLine( 'p', 'c', colorCross );

		// cross

		addLine( 'cn1', 'cn2', colorCross );
		addLine( 'cn3', 'cn4', colorCross );

		addLine( 'cf1', 'cf2', colorCross );
		addLine( 'cf3', 'cf4', colorCross );

		function addLine( a, b, color ) {

			addPoint( a, color );
			addPoint( b, color );

		}

		function addPoint( id, color ) {

			vertices.push( 0, 0, 0 );
			colors.push( color.r, color.g, color.b );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		super( geometry, material );

		this.type = 'CameraHelper';

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	}

	update() {

		const geometry = this.geometry;
		const pointMap = this.pointMap;

		const w = 1, h = 1;

		// we need just camera projection matrix inverse
		// world matrix must be identity

		_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

		// center / target

		setPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );
		setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );

		// near

		setPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );
		setPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );
		setPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );
		setPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );

		// far

		setPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );
		setPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );
		setPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );
		setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );

		// up

		setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );
		setPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );
		setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );

		// cross

		setPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );
		setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
		setPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );
		setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );

		setPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );
		setPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );
		setPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );
		setPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );

		geometry.getAttribute( 'position' ).needsUpdate = true;

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}


function setPoint( point, pointMap, geometry, camera, x, y, z ) {

	_vector.set( x, y, z ).unproject( camera );

	const points = pointMap[ point ];

	if ( points !== undefined ) {

		const position = geometry.getAttribute( 'position' );

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			position.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );

		}

	}

}

const _box = /*@__PURE__*/ new Box3();

class BoxHelper extends LineSegments {

	constructor( object, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		const positions = new Float32Array( 8 * 3 );

		const geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.object = object;
		this.type = 'BoxHelper';

		this.matrixAutoUpdate = false;

		this.update();

	}

	update( object ) {

		if ( object !== undefined ) {

			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

		}

		if ( this.object !== undefined ) {

			_box.setFromObject( this.object );

		}

		if ( _box.isEmpty() ) return;

		const min = _box.min;
		const max = _box.max;

		/*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		const position = this.geometry.attributes.position;
		const array = position.array;

		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();


	}

	setFromObject( object ) {

		this.object = object;
		this.update();

		return this;

	}

	copy( source ) {

		LineSegments.prototype.copy.call( this, source );

		this.object = source.object;

		return this;

	}

}

class Box3Helper extends LineSegments {

	constructor( box, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		const positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		const geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.box = box;

		this.type = 'Box3Helper';

		this.geometry.computeBoundingSphere();

	}

	updateMatrixWorld( force ) {

		const box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		super.updateMatrixWorld( force );

	}

}

class PlaneHelper extends Line {

	constructor( plane, size = 1, hex = 0xffff00 ) {

		const color = hex;

		const positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = size;

		const positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

		const geometry2 = new BufferGeometry();
		geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

	}

	updateMatrixWorld( force ) {

		let scale = - this.plane.constant;

		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

		this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

		this.lookAt( this.plane.normal );

		super.updateMatrixWorld( force );

	}

}

const _axis = /*@__PURE__*/ new Vector3();
let _lineGeometry, _coneGeometry;

class ArrowHelper extends Object3D {

	// dir is assumed to be normalized

	constructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		super();

		this.type = 'ArrowHelper';

		if ( _lineGeometry === undefined ) {

			_lineGeometry = new BufferGeometry();
			_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );
			_coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			_axis.set( dir.z, 0, - dir.x ).normalize();

			const radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( _axis, radians );

		}

	}

	setLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	}

	setColor( color ) {

		this.line.material.color.set( color );
		this.cone.material.color.set( color );

	}

	copy( source ) {

		super.copy( source, false );

		this.line.copy( source.line );
		this.cone.copy( source.cone );

		return this;

	}

}

class AxesHelper extends LineSegments {

	constructor( size = 1 ) {

		const vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		const colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'AxesHelper';

	}

	setColors( xAxisColor, yAxisColor, zAxisColor ) {

		const color = new Color();
		const array = this.geometry.attributes.color.array;

		color.set( xAxisColor );
		color.toArray( array, 0 );
		color.toArray( array, 3 );

		color.set( yAxisColor );
		color.toArray( array, 6 );
		color.toArray( array, 9 );

		color.set( zAxisColor );
		color.toArray( array, 12 );
		color.toArray( array, 15 );

		this.geometry.attributes.color.needsUpdate = true;

		return this;

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class ShapePath {

	constructor() {

		this.type = 'ShapePath';

		this.color = new Color();

		this.subPaths = [];
		this.currentPath = null;

	}

	moveTo( x, y ) {

		this.currentPath = new Path();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );

		return this;

	}

	lineTo( x, y ) {

		this.currentPath.lineTo( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		return this;

	}

	splineThru( pts ) {

		this.currentPath.splineThru( pts );

		return this;

	}

	toShapes( isCCW, noHoles ) {

		function toShapesNoHoles( inSubpaths ) {

			const shapes = [];

			for ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {

				const tmpPath = inSubpaths[ i ];

				const tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			const polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			let inside = false;
			for ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				let edgeLowPt = inPolygon[ p ];
				let edgeHighPt = inPolygon[ q ];

				let edgeDx = edgeHighPt.x - edgeLowPt.x;
				let edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}

					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						const perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		const isClockWise = ShapeUtils.isClockWise;

		const subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		let solid, tmpPath, tmpShape;
		const shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		let holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		const betterShapeHoles = [];
		const newShapes = [];
		let newShapeHoles = [];
		let mainIdx = 0;
		let tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( let i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			let ambiguous = false;
			let toChange = 0;

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				const sho = newShapeHoles[ sIdx ];

				for ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					const ho = sho[ hIdx ];
					let hole_unassigned = true;

					for ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange ++;

							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}

					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}

			if ( toChange > 0 && ambiguous === false ) {

				newShapeHoles = betterShapeHoles;

			}

		}

		let tmpHoles;

		for ( let i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

}

// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf

class DataUtils {

	// float32 to float16

	static toHalfFloat( val ) {

		if ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );

		val = clamp( val, - 65504, 65504 );

		_floatView[ 0 ] = val;
		const f = _uint32View[ 0 ];
		const e = ( f >> 23 ) & 0x1ff;
		return _baseTable[ e ] + ( ( f & 0x007fffff ) >> _shiftTable[ e ] );

	}

	// float16 to float32

	static fromHalfFloat( val ) {

		const m = val >> 10;
		_uint32View[ 0 ] = _mantissaTable[ _offsetTable[ m ] + ( val & 0x3ff ) ] + _exponentTable[ m ];
		return _floatView[ 0 ];

	}

}

// float32 to float16 helpers

const _buffer = new ArrayBuffer( 4 );
const _floatView = new Float32Array( _buffer );
const _uint32View = new Uint32Array( _buffer );

const _baseTable = new Uint32Array( 512 );
const _shiftTable = new Uint32Array( 512 );

for ( let i = 0; i < 256; ++ i ) {

	const e = i - 127;

	// very small number (0, -0)

	if ( e < - 27 ) {

		_baseTable[ i ] = 0x0000;
		_baseTable[ i | 0x100 ] = 0x8000;
		_shiftTable[ i ] = 24;
		_shiftTable[ i | 0x100 ] = 24;

		// small number (denorm)

	} else if ( e < - 14 ) {

		_baseTable[ i ] = 0x0400 >> ( - e - 14 );
		_baseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;
		_shiftTable[ i ] = - e - 1;
		_shiftTable[ i | 0x100 ] = - e - 1;

		// normal number

	} else if ( e <= 15 ) {

		_baseTable[ i ] = ( e + 15 ) << 10;
		_baseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;
		_shiftTable[ i ] = 13;
		_shiftTable[ i | 0x100 ] = 13;

		// large number (Infinity, -Infinity)

	} else if ( e < 128 ) {

		_baseTable[ i ] = 0x7c00;
		_baseTable[ i | 0x100 ] = 0xfc00;
		_shiftTable[ i ] = 24;
		_shiftTable[ i | 0x100 ] = 24;

		// stay (NaN, Infinity, -Infinity)

	} else {

		_baseTable[ i ] = 0x7c00;
		_baseTable[ i | 0x100 ] = 0xfc00;
		_shiftTable[ i ] = 13;
		_shiftTable[ i | 0x100 ] = 13;

	}

}

// float16 to float32 helpers

const _mantissaTable = new Uint32Array( 2048 );
const _exponentTable = new Uint32Array( 64 );
const _offsetTable = new Uint32Array( 64 );

for ( let i = 1; i < 1024; ++ i ) {

	let m = i << 13; // zero pad mantissa bits
	let e = 0; // zero exponent

	// normalized
	while ( ( m & 0x00800000 ) === 0 ) {

		m <<= 1;
		e -= 0x00800000; // decrement exponent

	}

	m &= ~ 0x00800000; // clear leading 1 bit
	e += 0x38800000; // adjust bias

	_mantissaTable[ i ] = m | e;

}

for ( let i = 1024; i < 2048; ++ i ) {

	_mantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );

}

for ( let i = 1; i < 31; ++ i ) {

	_exponentTable[ i ] = i << 23;

}

_exponentTable[ 31 ] = 0x47800000;
_exponentTable[ 32 ] = 0x80000000;
for ( let i = 33; i < 63; ++ i ) {

	_exponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );

}

_exponentTable[ 63 ] = 0xc7800000;

for ( let i = 1; i < 64; ++ i ) {

	if ( i !== 32 ) {

		_offsetTable[ i ] = 1024;

	}

}

const LineStrip = 0;
const LinePieces = 1;
const NoColors = 0;
const FaceColors = 1;
const VertexColors = 2;

function MeshFaceMaterial( materials ) {

	console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
	return materials;

}

function MultiMaterial( materials = [] ) {

	console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
	materials.isMultiMaterial = true;
	materials.materials = materials;
	materials.clone = function () {

		return materials.slice();

	};

	return materials;

}

class PointCloud extends Points {

	constructor( geometry, material ) {

		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
		super( geometry, material );

	}

}

class Particle extends Sprite {

	constructor( material ) {

		console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
		super( material );

	}

}

class ParticleSystem extends Points {

	constructor( geometry, material ) {

		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
		super( geometry, material );

	}

}

class PointCloudMaterial extends PointsMaterial {

	constructor( parameters ) {

		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
		super( parameters );

	}

}

class ParticleBasicMaterial extends PointsMaterial {

	constructor( parameters ) {

		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
		super( parameters );

	}

}

class ParticleSystemMaterial extends PointsMaterial {

	constructor( parameters ) {

		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
		super( parameters );

	}

}

class Vertex extends Vector3 {

	constructor( x, y, z ) {

		console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
		super( x, y, z );

	}

}

//

class DynamicBufferAttribute extends BufferAttribute {

	constructor( array, itemSize ) {

		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );
		super( array, itemSize );
		this.setUsage( DynamicDrawUsage );

	}

}

class Int8Attribute extends Int8BufferAttribute {

	constructor( array, itemSize ) {

		console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
		super( array, itemSize );

	}

}

class Uint8Attribute extends Uint8BufferAttribute {

	constructor( array, itemSize ) {

		console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
		super( array, itemSize );

	}

}

class Uint8ClampedAttribute extends Uint8ClampedBufferAttribute {

	constructor( array, itemSize ) {

		console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
		super( array, itemSize );

	}

}

class Int16Attribute extends Int16BufferAttribute {

	constructor( array, itemSize ) {

		console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
		super( array, itemSize );

	}

}

class Uint16Attribute extends Uint16BufferAttribute {

	constructor( array, itemSize ) {

		console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
		super( array, itemSize );

	}

}

class Int32Attribute extends Int32BufferAttribute {

	constructor( array, itemSize ) {

		console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
		super( array, itemSize );

	}

}

class Uint32Attribute extends Uint32BufferAttribute {

	constructor( array, itemSize ) {

		console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
		super( array, itemSize );

	}

}

class Float32Attribute extends Float32BufferAttribute {

	constructor( array, itemSize ) {

		console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
		super( array, itemSize );

	}

}

class Float64Attribute extends Float64BufferAttribute {

	constructor( array, itemSize ) {

		console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
		super( array, itemSize );

	}

}

//

Curve.create = function ( construct, getPoint ) {

	console.log( 'THREE.Curve.create() has been deprecated' );

	construct.prototype = Object.create( Curve.prototype );
	construct.prototype.constructor = construct;
	construct.prototype.getPoint = getPoint;

	return construct;

};

//

Path.prototype.fromPoints = function ( points ) {

	console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
	return this.setFromPoints( points );

};

//

class AxisHelper extends AxesHelper {

	constructor( size ) {

		console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
		super( size );

	}

}

class BoundingBoxHelper extends BoxHelper {

	constructor( object, color ) {

		console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
		super( object, color );

	}

}

class EdgesHelper extends LineSegments {

	constructor( object, hex ) {

		console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
		super( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

	}

}

GridHelper.prototype.setColors = function () {

	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

};

SkeletonHelper.prototype.update = function () {

	console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

};

class WireframeHelper extends LineSegments {

	constructor( object, hex ) {

		console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
		super( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

	}

}

//

Loader.prototype.extractUrlBase = function ( url ) {

	console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
	return LoaderUtils.extractUrlBase( url );

};

Loader.Handlers = {

	add: function ( /* regex, loader */ ) {

		console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

	},

	get: function ( /* file */ ) {

		console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

	}

};

class XHRLoader extends FileLoader {

	constructor( manager ) {

		console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
		super( manager );

	}

}

class BinaryTextureLoader extends DataTextureLoader {

	constructor( manager ) {

		console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
		super( manager );

	}

}

//

Box2.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

Box2.prototype.empty = function () {

	console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

Box2.prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

Box2.prototype.size = function ( optionalTarget ) {

	console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
	return this.getSize( optionalTarget );

};

//

Box3.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

Box3.prototype.empty = function () {

	console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

Box3.prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

Box3.prototype.isIntersectionSphere = function ( sphere ) {

	console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
	return this.intersectsSphere( sphere );

};

Box3.prototype.size = function ( optionalTarget ) {

	console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
	return this.getSize( optionalTarget );

};

//

Euler.prototype.toVector3 = function () {

	console.error( 'THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead' );

};


//

Sphere.prototype.empty = function () {

	console.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

//

Frustum.prototype.setFromMatrix = function ( m ) {

	console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
	return this.setFromProjectionMatrix( m );

};

//

Line3.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

//

Matrix3.prototype.flattenToArrayOffset = function ( array, offset ) {

	console.warn( 'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
	return this.toArray( array, offset );

};

Matrix3.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
	return vector.applyMatrix3( this );

};

Matrix3.prototype.multiplyVector3Array = function ( /* a */ ) {

	console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

};

Matrix3.prototype.applyToBufferAttribute = function ( attribute ) {

	console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
	return attribute.applyMatrix3( this );

};

Matrix3.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

	console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

};

Matrix3.prototype.getInverse = function ( matrix ) {

	console.warn( 'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
	return this.copy( matrix ).invert();

};

//

Matrix4.prototype.extractPosition = function ( m ) {

	console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
	return this.copyPosition( m );

};

Matrix4.prototype.flattenToArrayOffset = function ( array, offset ) {

	console.warn( 'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
	return this.toArray( array, offset );

};

Matrix4.prototype.getPosition = function () {

	console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
	return new Vector3().setFromMatrixColumn( this, 3 );

};

Matrix4.prototype.setRotationFromQuaternion = function ( q ) {

	console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
	return this.makeRotationFromQuaternion( q );

};

Matrix4.prototype.multiplyToArray = function () {

	console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

};

Matrix4.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

Matrix4.prototype.multiplyVector4 = function ( vector ) {

	console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

Matrix4.prototype.multiplyVector3Array = function ( /* a */ ) {

	console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

};

Matrix4.prototype.rotateAxis = function ( v ) {

	console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
	v.transformDirection( this );

};

Matrix4.prototype.crossVector = function ( vector ) {

	console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

Matrix4.prototype.translate = function () {

	console.error( 'THREE.Matrix4: .translate() has been removed.' );

};

Matrix4.prototype.rotateX = function () {

	console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

};

Matrix4.prototype.rotateY = function () {

	console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

};

Matrix4.prototype.rotateZ = function () {

	console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

};

Matrix4.prototype.rotateByAxis = function () {

	console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

};

Matrix4.prototype.applyToBufferAttribute = function ( attribute ) {

	console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
	return attribute.applyMatrix4( this );

};

Matrix4.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

	console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

};

Matrix4.prototype.makeFrustum = function ( left, right, bottom, top, near, far ) {

	console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
	return this.makePerspective( left, right, top, bottom, near, far );

};

Matrix4.prototype.getInverse = function ( matrix ) {

	console.warn( 'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
	return this.copy( matrix ).invert();

};

//

Plane.prototype.isIntersectionLine = function ( line ) {

	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
	return this.intersectsLine( line );

};

//

Quaternion.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
	return vector.applyQuaternion( this );

};

Quaternion.prototype.inverse = function ( ) {

	console.warn( 'THREE.Quaternion: .inverse() has been renamed to invert().' );
	return this.invert();

};

//

Ray.prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

Ray.prototype.isIntersectionPlane = function ( plane ) {

	console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
	return this.intersectsPlane( plane );

};

Ray.prototype.isIntersectionSphere = function ( sphere ) {

	console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
	return this.intersectsSphere( sphere );

};

//

Triangle.prototype.area = function () {

	console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
	return this.getArea();

};

Triangle.prototype.barycoordFromPoint = function ( point, target ) {

	console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
	return this.getBarycoord( point, target );

};

Triangle.prototype.midpoint = function ( target ) {

	console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
	return this.getMidpoint( target );

};

Triangle.prototypenormal = function ( target ) {

	console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
	return this.getNormal( target );

};

Triangle.prototype.plane = function ( target ) {

	console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
	return this.getPlane( target );

};

Triangle.barycoordFromPoint = function ( point, a, b, c, target ) {

	console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
	return Triangle.getBarycoord( point, a, b, c, target );

};

Triangle.normal = function ( a, b, c, target ) {

	console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
	return Triangle.getNormal( a, b, c, target );

};

//

Shape.prototype.extractAllPoints = function ( divisions ) {

	console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
	return this.extractPoints( divisions );

};

Shape.prototype.extrude = function ( options ) {

	console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
	return new ExtrudeGeometry( this, options );

};

Shape.prototype.makeGeometry = function ( options ) {

	console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
	return new ShapeGeometry( this, options );

};

//

Vector2.prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

Vector2.prototype.distanceToManhattan = function ( v ) {

	console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
	return this.manhattanDistanceTo( v );

};

Vector2.prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

Vector3.prototype.setEulerFromRotationMatrix = function () {

	console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

};

Vector3.prototype.setEulerFromQuaternion = function () {

	console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

};

Vector3.prototype.getPositionFromMatrix = function ( m ) {

	console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
	return this.setFromMatrixPosition( m );

};

Vector3.prototype.getScaleFromMatrix = function ( m ) {

	console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
	return this.setFromMatrixScale( m );

};

Vector3.prototype.getColumnFromMatrix = function ( index, matrix ) {

	console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
	return this.setFromMatrixColumn( matrix, index );

};

Vector3.prototype.applyProjection = function ( m ) {

	console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
	return this.applyMatrix4( m );

};

Vector3.prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

Vector3.prototype.distanceToManhattan = function ( v ) {

	console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
	return this.manhattanDistanceTo( v );

};

Vector3.prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

Vector4.prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

Vector4.prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

Object3D.prototype.getChildByName = function ( name ) {

	console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
	return this.getObjectByName( name );

};

Object3D.prototype.renderDepth = function () {

	console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

};

Object3D.prototype.translate = function ( distance, axis ) {

	console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
	return this.translateOnAxis( axis, distance );

};

Object3D.prototype.getWorldRotation = function () {

	console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

};

Object3D.prototype.applyMatrix = function ( matrix ) {

	console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
	return this.applyMatrix4( matrix );

};

Object.defineProperties( Object3D.prototype, {

	eulerOrder: {
		get: function () {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			return this.rotation.order;

		},
		set: function ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			this.rotation.order = value;

		}
	},
	useQuaternion: {
		get: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},
		set: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		}
	}

} );

Mesh.prototype.setDrawMode = function () {

	console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

};

Object.defineProperties( Mesh.prototype, {

	drawMode: {
		get: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
			return TrianglesDrawMode;

		},
		set: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

		}
	}

} );

SkinnedMesh.prototype.initBones = function () {

	console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

};

//

PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

	console.warn( 'THREE.PerspectiveCamera.setLens is deprecated. ' +
			'Use .setFocalLength and .filmGauge for a photographic setup.' );

	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	this.setFocalLength( focalLength );

};

//

Object.defineProperties( Light.prototype, {
	onlyShadow: {
		set: function () {

			console.warn( 'THREE.Light: .onlyShadow has been removed.' );

		}
	},
	shadowCameraFov: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			this.shadow.camera.fov = value;

		}
	},
	shadowCameraLeft: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			this.shadow.camera.left = value;

		}
	},
	shadowCameraRight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			this.shadow.camera.right = value;

		}
	},
	shadowCameraTop: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			this.shadow.camera.top = value;

		}
	},
	shadowCameraBottom: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			this.shadow.camera.bottom = value;

		}
	},
	shadowCameraNear: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			this.shadow.camera.near = value;

		}
	},
	shadowCameraFar: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			this.shadow.camera.far = value;

		}
	},
	shadowCameraVisible: {
		set: function () {

			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

		}
	},
	shadowBias: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			this.shadow.bias = value;

		}
	},
	shadowDarkness: {
		set: function () {

			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

		}
	},
	shadowMapWidth: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			this.shadow.mapSize.width = value;

		}
	},
	shadowMapHeight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			this.shadow.mapSize.height = value;

		}
	}
} );

//

Object.defineProperties( BufferAttribute.prototype, {

	length: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
			return this.array.length;

		}
	},
	dynamic: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			return this.usage === DynamicDrawUsage;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			this.setUsage( DynamicDrawUsage );

		}
	}

} );

BufferAttribute.prototype.setDynamic = function ( value ) {

	console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
	this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
	return this;

};

BufferAttribute.prototype.copyIndicesArray = function ( /* indices */ ) {

	console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

},

BufferAttribute.prototype.setArray = function ( /* array */ ) {

	console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

};

//

BufferGeometry.prototype.addIndex = function ( index ) {

	console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
	this.setIndex( index );

};

BufferGeometry.prototype.addAttribute = function ( name, attribute ) {

	console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

	if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

		console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

		return this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

	}

	if ( name === 'index' ) {

		console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
		this.setIndex( attribute );

		return this;

	}

	return this.setAttribute( name, attribute );

};

BufferGeometry.prototype.addDrawCall = function ( start, count, indexOffset ) {

	if ( indexOffset !== undefined ) {

		console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

	}

	console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
	this.addGroup( start, count );

};

BufferGeometry.prototype.clearDrawCalls = function () {

	console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
	this.clearGroups();

};

BufferGeometry.prototype.computeOffsets = function () {

	console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

};

BufferGeometry.prototype.removeAttribute = function ( name ) {

	console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

	return this.deleteAttribute( name );

};

BufferGeometry.prototype.applyMatrix = function ( matrix ) {

	console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
	return this.applyMatrix4( matrix );

};

Object.defineProperties( BufferGeometry.prototype, {

	drawcalls: {
		get: function () {

			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;

		}
	},
	offsets: {
		get: function () {

			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;

		}
	}

} );

InterleavedBuffer.prototype.setDynamic = function ( value ) {

	console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
	this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
	return this;

};

InterleavedBuffer.prototype.setArray = function ( /* array */ ) {

	console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

};

//

ExtrudeGeometry.prototype.getArrays = function () {

	console.error( 'THREE.ExtrudeGeometry: .getArrays() has been removed.' );

};

ExtrudeGeometry.prototype.addShapeList = function () {

	console.error( 'THREE.ExtrudeGeometry: .addShapeList() has been removed.' );

};

ExtrudeGeometry.prototype.addShape = function () {

	console.error( 'THREE.ExtrudeGeometry: .addShape() has been removed.' );

};

//

Scene.prototype.dispose = function () {

	console.error( 'THREE.Scene: .dispose() has been removed.' );

};

//

Uniform.prototype.onUpdate = function () {

	console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
	return this;

};

//

Object.defineProperties( Material.prototype, {

	wrapAround: {
		get: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		}
	},

	overdraw: {
		get: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		}
	},

	wrapRGB: {
		get: function () {

			console.warn( 'THREE.Material: .wrapRGB has been removed.' );
			return new Color();

		}
	},

	shading: {
		get: function () {

			console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
			this.flatShading = ( value === FlatShading );

		}
	},

	stencilMask: {
		get: function () {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			return this.stencilFuncMask;

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			this.stencilFuncMask = value;

		}
	},

	vertexTangents: {
		get: function () {

			console.warn( 'THREE.' + this.type + ': .vertexTangents has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.' + this.type + ': .vertexTangents has been removed.' );

		}
	},

} );

Object.defineProperties( ShaderMaterial.prototype, {

	derivatives: {
		get: function () {

			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			return this.extensions.derivatives;

		},
		set: function ( value ) {

			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			this.extensions.derivatives = value;

		}
	}

} );

//

WebGLRenderer.prototype.clearTarget = function ( renderTarget, color, depth, stencil ) {

	console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
	this.setRenderTarget( renderTarget );
	this.clear( color, depth, stencil );

};

WebGLRenderer.prototype.animate = function ( callback ) {

	console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
	this.setAnimationLoop( callback );

};

WebGLRenderer.prototype.getCurrentRenderTarget = function () {

	console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
	return this.getRenderTarget();

};

WebGLRenderer.prototype.getMaxAnisotropy = function () {

	console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
	return this.capabilities.getMaxAnisotropy();

};

WebGLRenderer.prototype.getPrecision = function () {

	console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
	return this.capabilities.precision;

};

WebGLRenderer.prototype.resetGLState = function () {

	console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
	return this.state.reset();

};

WebGLRenderer.prototype.supportsFloatTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
	return this.extensions.get( 'OES_texture_float' );

};

WebGLRenderer.prototype.supportsHalfFloatTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
	return this.extensions.get( 'OES_texture_half_float' );

};

WebGLRenderer.prototype.supportsStandardDerivatives = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
	return this.extensions.get( 'OES_standard_derivatives' );

};

WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
	return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

};

WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
	return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

};

WebGLRenderer.prototype.supportsBlendMinMax = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
	return this.extensions.get( 'EXT_blend_minmax' );

};

WebGLRenderer.prototype.supportsVertexTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
	return this.capabilities.vertexTextures;

};

WebGLRenderer.prototype.supportsInstancedArrays = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
	return this.extensions.get( 'ANGLE_instanced_arrays' );

};

WebGLRenderer.prototype.enableScissorTest = function ( boolean ) {

	console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
	this.setScissorTest( boolean );

};

WebGLRenderer.prototype.initMaterial = function () {

	console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

};

WebGLRenderer.prototype.addPrePlugin = function () {

	console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

};

WebGLRenderer.prototype.addPostPlugin = function () {

	console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

};

WebGLRenderer.prototype.updateShadowMap = function () {

	console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

};

WebGLRenderer.prototype.setFaceCulling = function () {

	console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

};

WebGLRenderer.prototype.allocTextureUnit = function () {

	console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

};

WebGLRenderer.prototype.setTexture = function () {

	console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

};

WebGLRenderer.prototype.setTexture2D = function () {

	console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

};

WebGLRenderer.prototype.setTextureCube = function () {

	console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

};

WebGLRenderer.prototype.getActiveMipMapLevel = function () {

	console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
	return this.getActiveMipmapLevel();

};

Object.defineProperties( WebGLRenderer.prototype, {

	shadowMapEnabled: {
		get: function () {

			return this.shadowMap.enabled;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			this.shadowMap.enabled = value;

		}
	},
	shadowMapType: {
		get: function () {

			return this.shadowMap.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			this.shadowMap.type = value;

		}
	},
	shadowMapCullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	context: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
			return this.getContext();

		}
	},
	vr: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
			return this.xr;

		}
	},
	gammaInput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

		}
	},
	gammaOutput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			return false;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			this.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;

		}
	},
	toneMappingWhitePoint: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );
			return 1.0;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );

		}
	},
	gammaFactor: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaFactor has been removed.' );
			return 2;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaFactor has been removed.' );

		}
	}
} );

Object.defineProperties( WebGLShadowMap.prototype, {

	cullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* cullFace */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderReverseSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderSingleSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

		}
	}

} );

class WebGLRenderTargetCube extends WebGLCubeRenderTarget {

	constructor( width, height, options ) {

		console.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );
		super( width, options );

	}

}

//

Object.defineProperties( WebGLRenderTarget.prototype, {

	wrapS: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			return this.texture.wrapS;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			this.texture.wrapS = value;

		}
	},
	wrapT: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			return this.texture.wrapT;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			this.texture.wrapT = value;

		}
	},
	magFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			return this.texture.magFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			this.texture.magFilter = value;

		}
	},
	minFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			return this.texture.minFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			this.texture.minFilter = value;

		}
	},
	anisotropy: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			return this.texture.anisotropy;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			this.texture.anisotropy = value;

		}
	},
	offset: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			return this.texture.offset;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			this.texture.offset = value;

		}
	},
	repeat: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			return this.texture.repeat;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			this.texture.repeat = value;

		}
	},
	format: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			return this.texture.format;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			this.texture.format = value;

		}
	},
	type: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			return this.texture.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			this.texture.type = value;

		}
	},
	generateMipmaps: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			return this.texture.generateMipmaps;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			this.texture.generateMipmaps = value;

		}
	}

} );

//

Audio.prototype.load = function ( file ) {

	console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
	const scope = this;
	const audioLoader = new AudioLoader();
	audioLoader.load( file, function ( buffer ) {

		scope.setBuffer( buffer );

	} );
	return this;

};


AudioAnalyser.prototype.getData = function () {

	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
	return this.getFrequencyData();

};

//

CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

	console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
	return this.update( renderer, scene );

};

CubeCamera.prototype.clear = function ( renderer, color, depth, stencil ) {

	console.warn( 'THREE.CubeCamera: .clear() is now .renderTarget.clear().' );
	return this.renderTarget.clear( renderer, color, depth, stencil );

};

ImageUtils.crossOrigin = undefined;

ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

	const loader = new TextureLoader();
	loader.setCrossOrigin( this.crossOrigin );

	const texture = loader.load( url, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

	const loader = new CubeTextureLoader();
	loader.setCrossOrigin( this.crossOrigin );

	const texture = loader.load( urls, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

ImageUtils.loadCompressedTexture = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

};

ImageUtils.loadCompressedTextureCube = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

};

//

function CanvasRenderer() {

	console.error( 'THREE.CanvasRenderer has been removed' );

}

//

function JSONLoader() {

	console.error( 'THREE.JSONLoader has been removed.' );

}

//

const SceneUtils = {

	createMultiMaterialObject: function ( /* geometry, materials */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	detach: function ( /* child, parent, scene */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	attach: function ( /* child, scene, parent */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	}

};

//

function LensFlare() {

	console.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );

}

//

class ParametricGeometry extends BufferGeometry {

	constructor() {

		console.error( 'THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js' );
		super();

	}

}

class TextGeometry extends BufferGeometry {

	constructor() {

		console.error( 'THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js' );
		super();

	}

}

function FontLoader() {

	console.error( 'THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js' );

}

function Font() {

	console.error( 'THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js' );

}

function ImmediateRenderObject() {

	console.error( 'THREE.ImmediateRenderObject has been removed.' );

}

class WebGLMultisampleRenderTarget extends WebGLRenderTarget {

	constructor( width, height, options ) {

		console.error( 'THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.' );
		super( width, height, options );
		this.samples = 4;

	}

}

class DataTexture2DArray extends DataArrayTexture {

	constructor( data, width, height, depth ) {

		console.warn( 'THREE.DataTexture2DArray has been renamed to DataArrayTexture.' );
		super( data, width, height, depth );

	}

}

class DataTexture3D extends Data3DTexture {

	constructor( data, width, height, depth ) {

		console.warn( 'THREE.DataTexture3D has been renamed to Data3DTexture.' );
		super( data, width, height, depth );

	}

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );

}

if ( typeof window !== 'undefined' ) {

	if ( window.__THREE__ ) {

		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	} else {

		window.__THREE__ = REVISION;

	}

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/GLTFLoader.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/GLTFLoader.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GLTFLoader": () => (/* binding */ GLTFLoader)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


class GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {

	constructor( manager ) {

		super( manager );

		this.dracoLoader = null;
		this.ktx2Loader = null;
		this.meshoptDecoder = null;

		this.pluginCallbacks = [];

		this.register( function ( parser ) {

			return new GLTFMaterialsClearcoatExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureBasisUExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureWebPExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSheenExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsTransmissionExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsVolumeExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIorExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSpecularExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFLightsExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshoptCompression( parser );

		} );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		let resourcePath;

		if ( this.resourcePath !== '' ) {

			resourcePath = this.resourcePath;

		} else if ( this.path !== '' ) {

			resourcePath = this.path;

		} else {

			resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase( url );

		}

		// Tells the LoadingManager to track an extra item, which resolves after
		// the model is fully loaded. This means the count of items loaded will
		// be incorrect, but ensures manager.onLoad() does not fire early.
		this.manager.itemStart( url );

		const _onError = function ( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		};

		const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, function ( data ) {

			try {

				scope.parse( data, resourcePath, function ( gltf ) {

					onLoad( gltf );

					scope.manager.itemEnd( url );

				}, _onError );

			} catch ( e ) {

				_onError( e );

			}

		}, onProgress, _onError );

	}

	setDRACOLoader( dracoLoader ) {

		this.dracoLoader = dracoLoader;
		return this;

	}

	setDDSLoader() {

		throw new Error(

			'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

		);

	}

	setKTX2Loader( ktx2Loader ) {

		this.ktx2Loader = ktx2Loader;
		return this;

	}

	setMeshoptDecoder( meshoptDecoder ) {

		this.meshoptDecoder = meshoptDecoder;
		return this;

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	parse( data, path, onLoad, onError ) {

		let content;
		const extensions = {};
		const plugins = {};

		if ( typeof data === 'string' ) {

			content = data;

		} else {

			const magic = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

				try {

					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

				} catch ( error ) {

					if ( onError ) onError( error );
					return;

				}

				content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

			} else {

				content = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( new Uint8Array( data ) );

			}

		}

		const json = JSON.parse( content );

		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
			return;

		}

		const parser = new GLTFParser( json, {

			path: path || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder

		} );

		parser.fileLoader.setRequestHeader( this.requestHeader );

		for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

			const plugin = this.pluginCallbacks[ i ]( parser );
			plugins[ plugin.name ] = plugin;

			// Workaround to avoid determining as unknown extension
			// in addUnknownExtensionsToUserData().
			// Remove this workaround if we move all the existing
			// extension handlers to plugin system
			extensions[ plugin.name ] = true;

		}

		if ( json.extensionsUsed ) {

			for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

				const extensionName = json.extensionsUsed[ i ];
				const extensionsRequired = json.extensionsRequired || [];

				switch ( extensionName ) {

					case EXTENSIONS.KHR_MATERIALS_UNLIT:
						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
						break;

					case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
						extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
						break;

					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
						break;

					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
						extensions[ extensionName ] = new GLTFTextureTransformExtension();
						break;

					case EXTENSIONS.KHR_MESH_QUANTIZATION:
						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
						break;

					default:

						if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

						}

				}

			}

		}

		parser.setExtensions( extensions );
		parser.setPlugins( plugins );
		parser.parse( onLoad, onError );

	}

	parseAsync( data, path ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.parse( data, path, resolve, reject );

		} );

	}

}

/* GLTFREGISTRY */

function GLTFRegistry() {

	let objects = {};

	return	{

		get: function ( key ) {

			return objects[ key ];

		},

		add: function ( key, object ) {

			objects[ key ] = object;

		},

		remove: function ( key ) {

			delete objects[ key ];

		},

		removeAll: function () {

			objects = {};

		}

	};

}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

const EXTENSIONS = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
	KHR_MATERIALS_IOR: 'KHR_materials_ior',
	KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
};

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightsExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

		// Object3D instance caches
		this.cache = { refs: {}, uses: {} };

	}

	_markDefs() {

		const parser = this.parser;
		const nodeDefs = this.parser.json.nodes || [];

		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.extensions
					&& nodeDef.extensions[ this.name ]
					&& nodeDef.extensions[ this.name ].light !== undefined ) {

				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

			}

		}

	}

	_loadLight( lightIndex ) {

		const parser = this.parser;
		const cacheKey = 'light:' + lightIndex;
		let dependency = parser.cache.get( cacheKey );

		if ( dependency ) return dependency;

		const json = parser.json;
		const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
		const lightDefs = extensions.lights || [];
		const lightDef = lightDefs[ lightIndex ];
		let lightNode;

		const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 0xffffff );

		if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );

		const range = lightDef.range !== undefined ? lightDef.range : 0;

		switch ( lightDef.type ) {

			case 'directional':
				lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight( color );
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			case 'point':
				lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight( color );
				lightNode.distance = range;
				break;

			case 'spot':
				lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight( color );
				lightNode.distance = range;
				// Handle spotlight properties.
				lightDef.spot = lightDef.spot || {};
				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
				lightNode.angle = lightDef.spot.outerConeAngle;
				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			default:
				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

		}

		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
		// here, because node-level parsing will only override position if explicitly specified.
		lightNode.position.set( 0, 0, 0 );

		lightNode.decay = 2;

		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

		dependency = Promise.resolve( lightNode );

		parser.cache.add( cacheKey, dependency );

		return dependency;

	}

	createNodeAttachment( nodeIndex ) {

		const self = this;
		const parser = this.parser;
		const json = parser.json;
		const nodeDef = json.nodes[ nodeIndex ];
		const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
		const lightIndex = lightDef.light;

		if ( lightIndex === undefined ) return null;

		return this._loadLight( lightIndex ).then( function ( light ) {

			return parser._getNodeRef( self.cache, lightIndex, light );

		} );

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

	}

	getMaterialType() {

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pending = [];

		materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const metallicRoughness = materialDef.pbrMetallicRoughness;

		if ( metallicRoughness ) {

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding ) );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.clearcoatFactor !== undefined ) {

			materialParams.clearcoat = extension.clearcoatFactor;

		}

		if ( extension.clearcoatTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

		}

		if ( extension.clearcoatRoughnessFactor !== undefined ) {

			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

		}

		if ( extension.clearcoatRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

		}

		if ( extension.clearcoatNormalTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

				const scale = extension.clearcoatNormalTexture.scale;

				materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( scale, scale );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */
class GLTFMaterialsSheenExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 0, 0, 0 );
		materialParams.sheenRoughness = 0;
		materialParams.sheen = 1;

		const extension = materialDef.extensions[ this.name ];

		if ( extension.sheenColorFactor !== undefined ) {

			materialParams.sheenColor.fromArray( extension.sheenColorFactor );

		}

		if ( extension.sheenRoughnessFactor !== undefined ) {

			materialParams.sheenRoughness = extension.sheenRoughnessFactor;

		}

		if ( extension.sheenColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding ) );

		}

		if ( extension.sheenRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */
class GLTFMaterialsTransmissionExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.transmissionFactor !== undefined ) {

			materialParams.transmission = extension.transmissionFactor;

		}

		if ( extension.transmissionTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFMaterialsVolumeExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

		if ( extension.thicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

		}

		materialParams.attenuationDistance = extension.attenuationDistance || 0;

		const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
		materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		return Promise.all( pending );

	}

}

/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */
class GLTFMaterialsIorExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IOR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const extension = materialDef.extensions[ this.name ];

		materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

		return Promise.resolve();

	}

}

/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */
class GLTFMaterialsSpecularExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

		if ( extension.specularTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

		}

		const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
		materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		if ( extension.specularColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding ) );

		}

		return Promise.all( pending );

	}

}

/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */
class GLTFTextureBasisUExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

	}

	loadTexture( textureIndex ) {

		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ this.name ];
		const loader = parser.options.ktx2Loader;

		if ( ! loader ) {

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

			} else {

				// Assumes that the extension is optional and that a fallback texture is present
				return null;

			}

		}

		return parser.loadTextureImage( textureIndex, extension.source, loader );

	}

}

/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */
class GLTFTextureWebPExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image. Support for lossy images doesn't guarantee support for all
				// WebP images, unfortunately.
				image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */
class GLTFMeshoptCompression {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
		this.parser = parser;

	}

	loadBufferView( index ) {

		const json = this.parser.json;
		const bufferView = json.bufferViews[ index ];

		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

			const extensionDef = bufferView.extensions[ this.name ];

			const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
			const decoder = this.parser.options.meshoptDecoder;

			if ( ! decoder || ! decoder.supported ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

				} else {

					// Assumes that the extension is optional and that fallback buffer data is present
					return null;

				}

			}

			return Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {

				const byteOffset = extensionDef.byteOffset || 0;
				const byteLength = extensionDef.byteLength || 0;

				const count = extensionDef.count;
				const stride = extensionDef.byteStride;

				const result = new ArrayBuffer( count * stride );
				const source = new Uint8Array( res[ 0 ], byteOffset, byteLength );

				decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
				return result;

			} );

		} else {

			return null;

		}

	}

}

/* BINARY EXTENSION */
const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

class GLTFBinaryExtension {

	constructor( data ) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

		this.header = {
			magic: three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
			version: headerView.getUint32( 4, true ),
			length: headerView.getUint32( 8, true )
		};

		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

		} else if ( this.header.version < 2.0 ) {

			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

		}

		const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
		const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
		let chunkIndex = 0;

		while ( chunkIndex < chunkContentsLength ) {

			const chunkLength = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			const chunkType = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

				const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
				this.content = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( contentArray );

			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

				const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice( byteOffset, byteOffset + chunkLength );

			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;

		}

		if ( this.content === null ) {

			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

		}

	}

}

/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */
class GLTFDracoMeshCompressionExtension {

	constructor( json, dracoLoader ) {

		if ( ! dracoLoader ) {

			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

		}

		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
		this.json = json;
		this.dracoLoader = dracoLoader;
		this.dracoLoader.preload();

	}

	decodePrimitive( primitive, parser ) {

		const json = this.json;
		const dracoLoader = this.dracoLoader;
		const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
		const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
		const threeAttributeMap = {};
		const attributeNormalizedMap = {};
		const attributeTypeMap = {};

		for ( const attributeName in gltfAttributeMap ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

		}

		for ( const attributeName in primitive.attributes ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

				const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
				const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

				attributeTypeMap[ threeAttributeName ] = componentType;
				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

			}

		}

		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

			return new Promise( function ( resolve ) {

				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

					for ( const attributeName in geometry.attributes ) {

						const attribute = geometry.attributes[ attributeName ];
						const normalized = attributeNormalizedMap[ attributeName ];

						if ( normalized !== undefined ) attribute.normalized = normalized;

					}

					resolve( geometry );

				}, threeAttributeMap, attributeTypeMap );

			} );

		} );

	}

}

/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */
class GLTFTextureTransformExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

	}

	extendTexture( texture, transform ) {

		if ( transform.texCoord !== undefined ) {

			console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

		}

		if ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {

			// See https://github.com/mrdoob/three.js/issues/21819.
			return texture;

		}

		texture = texture.clone();

		if ( transform.offset !== undefined ) {

			texture.offset.fromArray( transform.offset );

		}

		if ( transform.rotation !== undefined ) {

			texture.rotation = transform.rotation;

		}

		if ( transform.scale !== undefined ) {

			texture.repeat.fromArray( transform.scale );

		}

		texture.needsUpdate = true;

		return texture;

	}

}

/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness
 */

/**
 * A sub class of StandardMaterial with some of the functionality
 * changed via the `onBeforeCompile` callback
 * @pailhead
 */
class GLTFMeshStandardSGMaterial extends three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial {

	constructor( params ) {

		super();

		this.isGLTFSpecularGlossinessMaterial = true;

		//various chunks that need replacing
		const specularMapParsFragmentChunk = [
			'#ifdef USE_SPECULARMAP',
			'	uniform sampler2D specularMap;',
			'#endif'
		].join( '\n' );

		const glossinessMapParsFragmentChunk = [
			'#ifdef USE_GLOSSINESSMAP',
			'	uniform sampler2D glossinessMap;',
			'#endif'
		].join( '\n' );

		const specularMapFragmentChunk = [
			'vec3 specularFactor = specular;',
			'#ifdef USE_SPECULARMAP',
			'	vec4 texelSpecular = texture2D( specularMap, vUv );',
			'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	specularFactor *= texelSpecular.rgb;',
			'#endif'
		].join( '\n' );

		const glossinessMapFragmentChunk = [
			'float glossinessFactor = glossiness;',
			'#ifdef USE_GLOSSINESSMAP',
			'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
			'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	glossinessFactor *= texelGlossiness.a;',
			'#endif'
		].join( '\n' );

		const lightPhysicalFragmentChunk = [
			'PhysicalMaterial material;',
			'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
			'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
			'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
			'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
			'material.roughness += geometryRoughness;',
			'material.roughness = min( material.roughness, 1.0 );',
			'material.specularColor = specularFactor;',
		].join( '\n' );

		const uniforms = {
			specular: { value: new three__WEBPACK_IMPORTED_MODULE_0__.Color().setHex( 0xffffff ) },
			glossiness: { value: 1 },
			specularMap: { value: null },
			glossinessMap: { value: null }
		};

		this._extraUniforms = uniforms;

		this.onBeforeCompile = function ( shader ) {

			for ( const uniformName in uniforms ) {

				shader.uniforms[ uniformName ] = uniforms[ uniformName ];

			}

			shader.fragmentShader = shader.fragmentShader
				.replace( 'uniform float roughness;', 'uniform vec3 specular;' )
				.replace( 'uniform float metalness;', 'uniform float glossiness;' )
				.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )
				.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )
				.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )
				.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )
				.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

		};

		Object.defineProperties( this, {

			specular: {
				get: function () {

					return uniforms.specular.value;

				},
				set: function ( v ) {

					uniforms.specular.value = v;

				}
			},

			specularMap: {
				get: function () {

					return uniforms.specularMap.value;

				},
				set: function ( v ) {

					uniforms.specularMap.value = v;

					if ( v ) {

						this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps

					} else {

						delete this.defines.USE_SPECULARMAP;

					}

				}
			},

			glossiness: {
				get: function () {

					return uniforms.glossiness.value;

				},
				set: function ( v ) {

					uniforms.glossiness.value = v;

				}
			},

			glossinessMap: {
				get: function () {

					return uniforms.glossinessMap.value;

				},
				set: function ( v ) {

					uniforms.glossinessMap.value = v;

					if ( v ) {

						this.defines.USE_GLOSSINESSMAP = '';
						this.defines.USE_UV = '';

					} else {

						delete this.defines.USE_GLOSSINESSMAP;
						delete this.defines.USE_UV;

					}

				}
			}

		} );

		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;

		this.setValues( params );

	}

	copy( source ) {

		super.copy( source );

		this.specularMap = source.specularMap;
		this.specular.copy( source.specular );
		this.glossinessMap = source.glossinessMap;
		this.glossiness = source.glossiness;
		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;
		return this;

	}

}


class GLTFMaterialsPbrSpecularGlossinessExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;

		this.specularGlossinessParams = [
			'color',
			'map',
			'lightMap',
			'lightMapIntensity',
			'aoMap',
			'aoMapIntensity',
			'emissive',
			'emissiveIntensity',
			'emissiveMap',
			'bumpMap',
			'bumpScale',
			'normalMap',
			'normalMapType',
			'displacementMap',
			'displacementScale',
			'displacementBias',
			'specularMap',
			'specular',
			'glossinessMap',
			'glossiness',
			'alphaMap',
			'envMap',
			'envMapIntensity'
		];

	}

	getMaterialType() {

		return GLTFMeshStandardSGMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pbrSpecularGlossiness = materialDef.extensions[ this.name ];

		materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const pending = [];

		if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

			const array = pbrSpecularGlossiness.diffuseFactor;

			materialParams.color.fromArray( array );
			materialParams.opacity = array[ 3 ];

		}

		if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture, three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding ) );

		}

		materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 0.0, 0.0, 0.0 );
		materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
		materialParams.specular = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1.0, 1.0, 1.0 );

		if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

			materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

		}

		if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

			const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
			pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
			pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef, three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding ) );

		}

		return Promise.all( pending );

	}

	createMaterial( materialParams ) {

		const material = new GLTFMeshStandardSGMaterial( materialParams );
		material.fog = true;

		material.color = materialParams.color;

		material.map = materialParams.map === undefined ? null : materialParams.map;

		material.lightMap = null;
		material.lightMapIntensity = 1.0;

		material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
		material.aoMapIntensity = 1.0;

		material.emissive = materialParams.emissive;
		material.emissiveIntensity = 1.0;
		material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

		material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
		material.bumpScale = 1;

		material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
		material.normalMapType = three__WEBPACK_IMPORTED_MODULE_0__.TangentSpaceNormalMap;

		if ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;

		material.displacementMap = null;
		material.displacementScale = 1;
		material.displacementBias = 0;

		material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
		material.specular = materialParams.specular;

		material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
		material.glossiness = materialParams.glossiness;

		material.alphaMap = null;

		material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
		material.envMapIntensity = 1.0;

		return material;

	}

}

/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */
class GLTFMeshQuantizationExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

	}

}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	copySampleValue_( index ) {

		// Copies a sample value to the result buffer. See description of glTF
		// CUBICSPLINE values layout in interpolate_() function below.

		const result = this.resultBuffer,
			values = this.sampleValues,
			valueSize = this.valueSize,
			offset = index * valueSize * 3 + valueSize;

		for ( let i = 0; i !== valueSize; i ++ ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

}

GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

	const result = this.resultBuffer;
	const values = this.sampleValues;
	const stride = this.valueSize;

	const stride2 = stride * 2;
	const stride3 = stride * 3;

	const td = t1 - t0;

	const p = ( t - t0 ) / td;
	const pp = p * p;
	const ppp = pp * p;

	const offset1 = i1 * stride3;
	const offset0 = offset1 - stride3;

	const s2 = - 2 * ppp + 3 * pp;
	const s3 = ppp - pp;
	const s0 = 1 - s2;
	const s1 = s3 - pp + p;

	// Layout of keyframe output values for CUBICSPLINE animations:
	//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
	for ( let i = 0; i !== stride; i ++ ) {

		const p0 = values[ offset0 + i + stride ]; // splineVertex_k
		const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
		const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
		const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

		result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

	}

	return result;

};

const _q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();

class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

	interpolate_( i1, t0, t, t1 ) {

		const result = super.interpolate_( i1, t0, t, t1 );

		_q.fromArray( result ).normalize().toArray( result );

		return result;

	}

}


/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

const WEBGL_CONSTANTS = {
	FLOAT: 5126,
	//FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	LINEAR: 9729,
	REPEAT: 10497,
	SAMPLER_2D: 35678,
	POINTS: 0,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	TRIANGLES: 4,
	TRIANGLE_STRIP: 5,
	TRIANGLE_FAN: 6,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_SHORT: 5123
};

const WEBGL_COMPONENT_TYPES = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

const WEBGL_FILTERS = {
	9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,
	9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,
	9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,
	9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,
	9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,
	9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter
};

const WEBGL_WRAPPINGS = {
	33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,
	33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,
	10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping
};

const WEBGL_TYPE_SIZES = {
	'SCALAR': 1,
	'VEC2': 2,
	'VEC3': 3,
	'VEC4': 4,
	'MAT2': 4,
	'MAT3': 9,
	'MAT4': 16
};

const ATTRIBUTES = {
	POSITION: 'position',
	NORMAL: 'normal',
	TANGENT: 'tangent',
	TEXCOORD_0: 'uv',
	TEXCOORD_1: 'uv2',
	COLOR_0: 'color',
	WEIGHTS_0: 'skinWeight',
	JOINTS_0: 'skinIndex',
};

const PATH_PROPERTIES = {
	scale: 'scale',
	translation: 'position',
	rotation: 'quaternion',
	weights: 'morphTargetInfluences'
};

const INTERPOLATION = {
	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		                        // keyframe track will be initialized with a default interpolation type, then modified.
	LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,
	STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete
};

const ALPHA_MODES = {
	OPAQUE: 'OPAQUE',
	MASK: 'MASK',
	BLEND: 'BLEND'
};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */
function createDefaultMaterial( cache ) {

	if ( cache[ 'DefaultMaterial' ] === undefined ) {

		cache[ 'DefaultMaterial' ] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial( {
			color: 0xFFFFFF,
			emissive: 0x000000,
			metalness: 1,
			roughness: 1,
			transparent: false,
			depthTest: true,
			side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide
		} );

	}

	return cache[ 'DefaultMaterial' ];

}

function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

	// Add unknown glTF extensions to an object's userData.

	for ( const name in objectDef.extensions ) {

		if ( knownExtensions[ name ] === undefined ) {

			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

		}

	}

}

/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */
function assignExtrasToUserData( object, gltfDef ) {

	if ( gltfDef.extras !== undefined ) {

		if ( typeof gltfDef.extras === 'object' ) {

			Object.assign( object.userData, gltfDef.extras );

		} else {

			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

		}

	}

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addMorphTargets( geometry, targets, parser ) {

	let hasMorphPosition = false;
	let hasMorphNormal = false;
	let hasMorphColor = false;

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( target.POSITION !== undefined ) hasMorphPosition = true;
		if ( target.NORMAL !== undefined ) hasMorphNormal = true;
		if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

		if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

	}

	if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

	const pendingPositionAccessors = [];
	const pendingNormalAccessors = [];
	const pendingColorAccessors = [];

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( hasMorphPosition ) {

			const pendingAccessor = target.POSITION !== undefined
				? parser.getDependency( 'accessor', target.POSITION )
				: geometry.attributes.position;

			pendingPositionAccessors.push( pendingAccessor );

		}

		if ( hasMorphNormal ) {

			const pendingAccessor = target.NORMAL !== undefined
				? parser.getDependency( 'accessor', target.NORMAL )
				: geometry.attributes.normal;

			pendingNormalAccessors.push( pendingAccessor );

		}

		if ( hasMorphColor ) {

			const pendingAccessor = target.COLOR_0 !== undefined
				? parser.getDependency( 'accessor', target.COLOR_0 )
				: geometry.attributes.color;

			pendingColorAccessors.push( pendingAccessor );

		}

	}

	return Promise.all( [
		Promise.all( pendingPositionAccessors ),
		Promise.all( pendingNormalAccessors ),
		Promise.all( pendingColorAccessors )
	] ).then( function ( accessors ) {

		const morphPositions = accessors[ 0 ];
		const morphNormals = accessors[ 1 ];
		const morphColors = accessors[ 2 ];

		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
		if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
		geometry.morphTargetsRelative = true;

		return geometry;

	} );

}

/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */
function updateMorphTargets( mesh, meshDef ) {

	mesh.updateMorphTargets();

	if ( meshDef.weights !== undefined ) {

		for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

		}

	}

	// .extras has user-defined data, so check that .extras.targetNames is an array.
	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

		const targetNames = meshDef.extras.targetNames;

		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

			mesh.morphTargetDictionary = {};

			for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

		}

	}

}

function createPrimitiveKey( primitiveDef ) {

	const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
	let geometryKey;

	if ( dracoExtension ) {

		geometryKey = 'draco:' + dracoExtension.bufferView
				+ ':' + dracoExtension.indices
				+ ':' + createAttributesKey( dracoExtension.attributes );

	} else {

		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

	}

	return geometryKey;

}

function createAttributesKey( attributes ) {

	let attributesKey = '';

	const keys = Object.keys( attributes ).sort();

	for ( let i = 0, il = keys.length; i < il; i ++ ) {

		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

	}

	return attributesKey;

}

function getNormalizedComponentScale( constructor ) {

	// Reference:
	// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

	switch ( constructor ) {

		case Int8Array:
			return 1 / 127;

		case Uint8Array:
			return 1 / 255;

		case Int16Array:
			return 1 / 32767;

		case Uint16Array:
			return 1 / 65535;

		default:
			throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

	}

}

function getImageURIMimeType( uri ) {

	if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
	if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';

	return 'image/png';

}

/* GLTF PARSER */

class GLTFParser {

	constructor( json = {}, options = {} ) {

		this.json = json;
		this.extensions = {};
		this.plugins = {};
		this.options = options;

		// loader object cache
		this.cache = new GLTFRegistry();

		// associations between Three.js objects and glTF elements
		this.associations = new Map();

		// BufferGeometry caching
		this.primitiveCache = {};

		// Object3D instance caches
		this.meshCache = { refs: {}, uses: {} };
		this.cameraCache = { refs: {}, uses: {} };
		this.lightCache = { refs: {}, uses: {} };

		this.sourceCache = {};
		this.textureCache = {};

		// Track node names, to ensure no duplicates
		this.nodeNamesUsed = {};

		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
		// expensive work of uploading a texture to the GPU off the main thread.
		if ( typeof createImageBitmap !== 'undefined' && /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === false ) {

			this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader( this.options.manager );

		} else {

			this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader( this.options.manager );

		}

		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
		this.textureLoader.setRequestHeader( this.options.requestHeader );

		this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.options.manager );
		this.fileLoader.setResponseType( 'arraybuffer' );

		if ( this.options.crossOrigin === 'use-credentials' ) {

			this.fileLoader.setWithCredentials( true );

		}

	}

	setExtensions( extensions ) {

		this.extensions = extensions;

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	parse( onLoad, onError ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		// Clear the loader cache
		this.cache.removeAll();

		// Mark the special nodes/meshes in json for efficient parse
		this._invokeAll( function ( ext ) {

			return ext._markDefs && ext._markDefs();

		} );

		Promise.all( this._invokeAll( function ( ext ) {

			return ext.beforeRoot && ext.beforeRoot();

		} ) ).then( function () {

			return Promise.all( [

				parser.getDependencies( 'scene' ),
				parser.getDependencies( 'animation' ),
				parser.getDependencies( 'camera' ),

			] );

		} ).then( function ( dependencies ) {

			const result = {
				scene: dependencies[ 0 ][ json.scene || 0 ],
				scenes: dependencies[ 0 ],
				animations: dependencies[ 1 ],
				cameras: dependencies[ 2 ],
				asset: json.asset,
				parser: parser,
				userData: {}
			};

			addUnknownExtensionsToUserData( extensions, result, json );

			assignExtrasToUserData( result, json );

			Promise.all( parser._invokeAll( function ( ext ) {

				return ext.afterRoot && ext.afterRoot( result );

			} ) ).then( function () {

				onLoad( result );

			} );

		} ).catch( onError );

	}

	/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */
	_markDefs() {

		const nodeDefs = this.json.nodes || [];
		const skinDefs = this.json.skins || [];
		const meshDefs = this.json.meshes || [];

		// Nothing in the node definition indicates whether it is a Bone or an
		// Object3D. Use the skins' joint references to mark bones.
		for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

			const joints = skinDefs[ skinIndex ].joints;

			for ( let i = 0, il = joints.length; i < il; i ++ ) {

				nodeDefs[ joints[ i ] ].isBone = true;

			}

		}

		// Iterate over all nodes, marking references to shared resources,
		// as well as skeleton joints.
		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.mesh !== undefined ) {

				this._addNodeRef( this.meshCache, nodeDef.mesh );

				// Nothing in the mesh definition indicates whether it is
				// a SkinnedMesh or Mesh. Use the node's mesh reference
				// to mark SkinnedMesh if node has skin.
				if ( nodeDef.skin !== undefined ) {

					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

				}

			}

			if ( nodeDef.camera !== undefined ) {

				this._addNodeRef( this.cameraCache, nodeDef.camera );

			}

		}

	}

	/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 */
	_addNodeRef( cache, index ) {

		if ( index === undefined ) return;

		if ( cache.refs[ index ] === undefined ) {

			cache.refs[ index ] = cache.uses[ index ] = 0;

		}

		cache.refs[ index ] ++;

	}

	/** Returns a reference to a shared resource, cloning it if necessary. */
	_getNodeRef( cache, index, object ) {

		if ( cache.refs[ index ] <= 1 ) return object;

		const ref = object.clone();

		// Propagates mappings to the cloned object, prevents mappings on the
		// original object from being lost.
		const updateMappings = ( original, clone ) => {

			const mappings = this.associations.get( original );
			if ( mappings != null ) {

				this.associations.set( clone, mappings );

			}

			for ( const [ i, child ] of original.children.entries() ) {

				updateMappings( child, clone.children[ i ] );

			}

		};

		updateMappings( object, ref );

		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

		return ref;

	}

	_invokeOne( func ) {

		const extensions = Object.values( this.plugins );
		extensions.push( this );

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) return result;

		}

		return null;

	}

	_invokeAll( func ) {

		const extensions = Object.values( this.plugins );
		extensions.unshift( this );

		const pending = [];

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) pending.push( result );

		}

		return pending;

	}

	/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */
	getDependency( type, index ) {

		const cacheKey = type + ':' + index;
		let dependency = this.cache.get( cacheKey );

		if ( ! dependency ) {

			switch ( type ) {

				case 'scene':
					dependency = this.loadScene( index );
					break;

				case 'node':
					dependency = this.loadNode( index );
					break;

				case 'mesh':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMesh && ext.loadMesh( index );

					} );
					break;

				case 'accessor':
					dependency = this.loadAccessor( index );
					break;

				case 'bufferView':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadBufferView && ext.loadBufferView( index );

					} );
					break;

				case 'buffer':
					dependency = this.loadBuffer( index );
					break;

				case 'material':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMaterial && ext.loadMaterial( index );

					} );
					break;

				case 'texture':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadTexture && ext.loadTexture( index );

					} );
					break;

				case 'skin':
					dependency = this.loadSkin( index );
					break;

				case 'animation':
					dependency = this.loadAnimation( index );
					break;

				case 'camera':
					dependency = this.loadCamera( index );
					break;

				default:
					throw new Error( 'Unknown type: ' + type );

			}

			this.cache.add( cacheKey, dependency );

		}

		return dependency;

	}

	/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */
	getDependencies( type ) {

		let dependencies = this.cache.get( type );

		if ( ! dependencies ) {

			const parser = this;
			const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

			dependencies = Promise.all( defs.map( function ( def, index ) {

				return parser.getDependency( type, index );

			} ) );

			this.cache.add( type, dependencies );

		}

		return dependencies;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBuffer( bufferIndex ) {

		const bufferDef = this.json.buffers[ bufferIndex ];
		const loader = this.fileLoader;

		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

		}

		// If present, GLB container is required to be the first buffer.
		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

		}

		const options = this.options;

		return new Promise( function ( resolve, reject ) {

			loader.load( three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

			} );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBufferView( bufferViewIndex ) {

		const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

			const byteLength = bufferViewDef.byteLength || 0;
			const byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice( byteOffset, byteOffset + byteLength );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */
	loadAccessor( accessorIndex ) {

		const parser = this;
		const json = this.json;

		const accessorDef = this.json.accessors[ accessorIndex ];

		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

			// Ignore empty accessors, which may be used to declare runtime
			// information about attributes coming from another source (e.g. Draco
			// compression extension).
			return Promise.resolve( null );

		}

		const pendingBufferViews = [];

		if ( accessorDef.bufferView !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

		} else {

			pendingBufferViews.push( null );

		}

		if ( accessorDef.sparse !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

		}

		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

			const bufferView = bufferViews[ 0 ];

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
			const elementBytes = TypedArray.BYTES_PER_ELEMENT;
			const itemBytes = elementBytes * itemSize;
			const byteOffset = accessorDef.byteOffset || 0;
			const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
			const normalized = accessorDef.normalized === true;
			let array, bufferAttribute;

			// The buffer is not interleaved if the stride is the item size in bytes.
			if ( byteStride && byteStride !== itemBytes ) {

				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
				// This makes sure that IBA.count reflects accessor.count properly
				const ibSlice = Math.floor( byteOffset / byteStride );
				const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
				let ib = parser.cache.get( ibCacheKey );

				if ( ! ib ) {

					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

					// Integer parameters to IB/IBA are in array elements, not bytes.
					ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer( array, byteStride / elementBytes );

					parser.cache.add( ibCacheKey, ib );

				}

				bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

			} else {

				if ( bufferView === null ) {

					array = new TypedArray( accessorDef.count * itemSize );

				} else {

					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

				}

				bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( array, itemSize, normalized );

			}

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
			if ( accessorDef.sparse !== undefined ) {

				const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
				const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

				const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
				const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

				const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
				const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

				if ( bufferView !== null ) {

					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
					bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

				}

				for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

					const index = sparseIndices[ i ];

					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

				}

			}

			return bufferAttribute;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture>}
	 */
	loadTexture( textureIndex ) {

		const json = this.json;
		const options = this.options;
		const textureDef = json.textures[ textureIndex ];
		const sourceIndex = textureDef.source;
		const sourceDef = json.images[ sourceIndex ];

		let loader = this.textureLoader;

		if ( sourceDef.uri ) {

			const handler = options.manager.getHandler( sourceDef.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.loadTextureImage( textureIndex, sourceIndex, loader );

	}

	loadTextureImage( textureIndex, sourceIndex, loader ) {

		const parser = this;
		const json = this.json;

		const textureDef = json.textures[ textureIndex ];
		const sourceDef = json.images[ sourceIndex ];

		const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

		if ( this.textureCache[ cacheKey ] ) {

			// See https://github.com/mrdoob/three.js/issues/21559.
			return this.textureCache[ cacheKey ];

		}

		const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

			texture.flipY = false;

			if ( textureDef.name ) texture.name = textureDef.name;

			const samplers = json.samplers || {};
			const sampler = samplers[ textureDef.sampler ] || {};

			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;
			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;
			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;
			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;

			parser.associations.set( texture, { textures: textureIndex } );

			return texture;

		} ).catch( function () {

			return null;

		} );

		this.textureCache[ cacheKey ] = promise;

		return promise;

	}

	loadImageSource( sourceIndex, loader ) {

		const parser = this;
		const json = this.json;
		const options = this.options;

		if ( this.sourceCache[ sourceIndex ] !== undefined ) {

			return this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );

		}

		const sourceDef = json.images[ sourceIndex ];

		const URL = self.URL || self.webkitURL;

		let sourceURI = sourceDef.uri || '';
		let isObjectURL = false;

		if ( sourceDef.bufferView !== undefined ) {

			// Load binary image data from bufferView, if provided.

			sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

				isObjectURL = true;
				const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
				sourceURI = URL.createObjectURL( blob );
				return sourceURI;

			} );

		} else if ( sourceDef.uri === undefined ) {

			throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

		}

		const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

			return new Promise( function ( resolve, reject ) {

				let onLoad = resolve;

				if ( loader.isImageBitmapLoader === true ) {

					onLoad = function ( imageBitmap ) {

						const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture( imageBitmap );
						texture.needsUpdate = true;

						resolve( texture );

					};

				}

				loader.load( three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

			} );

		} ).then( function ( texture ) {

			// Clean up resources and configure Texture.

			if ( isObjectURL === true ) {

				URL.revokeObjectURL( sourceURI );

			}

			texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

			return texture;

		} ).catch( function ( error ) {

			console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
			throw error;

		} );

		this.sourceCache[ sourceIndex ] = promise;
		return promise;

	}

	/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise<Texture>}
	 */
	assignTexture( materialParams, mapName, mapDef, encoding ) {

		const parser = this;

		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

			// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
			// However, we will copy UV set 0 to UV set 1 on demand for aoMap
			if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

				console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

			}

			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

				const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

				if ( transform ) {

					const gltfReference = parser.associations.get( texture );
					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
					parser.associations.set( texture, gltfReference );

				}

			}

			if ( encoding !== undefined ) {

				texture.encoding = encoding;

			}

			materialParams[ mapName ] = texture;

			return texture;

		} );

	}

	/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */
	assignFinalMaterial( mesh ) {

		const geometry = mesh.geometry;
		let material = mesh.material;

		const useDerivativeTangents = geometry.attributes.tangent === undefined;
		const useVertexColors = geometry.attributes.color !== undefined;
		const useFlatShading = geometry.attributes.normal === undefined;

		if ( mesh.isPoints ) {

			const cacheKey = 'PointsMaterial:' + material.uuid;

			let pointsMaterial = this.cache.get( cacheKey );

			if ( ! pointsMaterial ) {

				pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();
				three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call( pointsMaterial, material );
				pointsMaterial.color.copy( material.color );
				pointsMaterial.map = material.map;
				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

				this.cache.add( cacheKey, pointsMaterial );

			}

			material = pointsMaterial;

		} else if ( mesh.isLine ) {

			const cacheKey = 'LineBasicMaterial:' + material.uuid;

			let lineMaterial = this.cache.get( cacheKey );

			if ( ! lineMaterial ) {

				lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();
				three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call( lineMaterial, material );
				lineMaterial.color.copy( material.color );

				this.cache.add( cacheKey, lineMaterial );

			}

			material = lineMaterial;

		}

		// Clone the material if it will be modified
		if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

			let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

			if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';
			if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
			if ( useVertexColors ) cacheKey += 'vertex-colors:';
			if ( useFlatShading ) cacheKey += 'flat-shading:';

			let cachedMaterial = this.cache.get( cacheKey );

			if ( ! cachedMaterial ) {

				cachedMaterial = material.clone();

				if ( useVertexColors ) cachedMaterial.vertexColors = true;
				if ( useFlatShading ) cachedMaterial.flatShading = true;

				if ( useDerivativeTangents ) {

					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

				}

				this.cache.add( cacheKey, cachedMaterial );

				this.associations.set( cachedMaterial, this.associations.get( material ) );

			}

			material = cachedMaterial;

		}

		// workarounds for mesh and geometry

		if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

			geometry.setAttribute( 'uv2', geometry.attributes.uv );

		}

		mesh.material = material;

	}

	getMaterialType( /* materialIndex */ ) {

		return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */
	loadMaterial( materialIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;
		const materialDef = json.materials[ materialIndex ];

		let materialType;
		const materialParams = {};
		const materialExtensions = materialDef.extensions || {};

		const pending = [];

		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

			const sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
			materialType = sgExtension.getMaterialType();
			pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

		} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

			const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
			materialType = kmuExtension.getMaterialType();
			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

		} else {

			// Specification:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

			const metallicRoughness = materialDef.pbrMetallicRoughness || {};

			materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding ) );

			}

			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

			}

			materialType = this._invokeOne( function ( ext ) {

				return ext.getMaterialType && ext.getMaterialType( materialIndex );

			} );

			pending.push( Promise.all( this._invokeAll( function ( ext ) {

				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

			} ) ) );

		}

		if ( materialDef.doubleSided === true ) {

			materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;

		}

		const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

		if ( alphaMode === ALPHA_MODES.BLEND ) {

			materialParams.transparent = true;

			// See: https://github.com/mrdoob/three.js/issues/17706
			materialParams.depthWrite = false;

		} else {

			materialParams.transparent = false;

			if ( alphaMode === ALPHA_MODES.MASK ) {

				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

			}

		}

		if ( materialDef.normalTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

			materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( 1, 1 );

			if ( materialDef.normalTexture.scale !== undefined ) {

				const scale = materialDef.normalTexture.scale;

				materialParams.normalScale.set( scale, scale );

			}

		}

		if ( materialDef.occlusionTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

			if ( materialDef.occlusionTexture.strength !== undefined ) {

				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

			}

		}

		if ( materialDef.emissiveFactor !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {

			materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray( materialDef.emissiveFactor );

		}

		if ( materialDef.emissiveTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding ) );

		}

		return Promise.all( pending ).then( function () {

			let material;

			if ( materialType === GLTFMeshStandardSGMaterial ) {

				material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

			} else {

				material = new materialType( materialParams );

			}

			if ( materialDef.name ) material.name = materialDef.name;

			assignExtrasToUserData( material, materialDef );

			parser.associations.set( material, { materials: materialIndex } );

			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

			return material;

		} );

	}

	/** When Object3D instances are targeted by animation, they need unique names. */
	createUniqueName( originalName ) {

		const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName( originalName || '' );

		let name = sanitizedName;

		for ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {

			name = sanitizedName + '_' + i;

		}

		this.nodeNamesUsed[ name ] = true;

		return name;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */
	loadGeometries( primitives ) {

		const parser = this;
		const extensions = this.extensions;
		const cache = this.primitiveCache;

		function createDracoPrimitive( primitive ) {

			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
				.decodePrimitive( primitive, parser )
				.then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

		}

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const primitive = primitives[ i ];
			const cacheKey = createPrimitiveKey( primitive );

			// See if we've already created this geometry
			const cached = cache[ cacheKey ];

			if ( cached ) {

				// Use the cached geometry if it exists
				pending.push( cached.promise );

			} else {

				let geometryPromise;

				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

					// Use DRACO geometry if available
					geometryPromise = createDracoPrimitive( primitive );

				} else {

					// Otherwise create a new geometry
					geometryPromise = addPrimitiveAttributes( new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser );

				}

				// Cache this geometry
				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

				pending.push( geometryPromise );

			}

		}

		return Promise.all( pending );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */
	loadMesh( meshIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		const meshDef = json.meshes[ meshIndex ];
		const primitives = meshDef.primitives;

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const material = primitives[ i ].material === undefined
				? createDefaultMaterial( this.cache )
				: this.getDependency( 'material', primitives[ i ].material );

			pending.push( material );

		}

		pending.push( parser.loadGeometries( primitives ) );

		return Promise.all( pending ).then( function ( results ) {

			const materials = results.slice( 0, results.length - 1 );
			const geometries = results[ results.length - 1 ];

			const meshes = [];

			for ( let i = 0, il = geometries.length; i < il; i ++ ) {

				const geometry = geometries[ i ];
				const primitive = primitives[ i ];

				// 1. create Mesh

				let mesh;

				const material = materials[ i ];

				if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
						primitive.mode === undefined ) {

					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
					mesh = meshDef.isSkinnedMesh === true
						? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh( geometry, material )
						: new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( geometry, material );

					if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

						// we normalize floating point skin weight array to fix malformed assets (see #15319)
						// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
						mesh.normalizeSkinWeights();

					}

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode );

					} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode );

					}

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

					mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

					mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

					mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

					mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points( geometry, material );

				} else {

					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

				}

				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

					updateMorphTargets( mesh, meshDef );

				}

				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

				assignExtrasToUserData( mesh, meshDef );

				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

				parser.assignFinalMaterial( mesh );

				meshes.push( mesh );

			}

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				parser.associations.set( meshes[ i ], {
					meshes: meshIndex,
					primitives: i
				} );

			}

			if ( meshes.length === 1 ) {

				return meshes[ 0 ];

			}

			const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();

			parser.associations.set( group, { meshes: meshIndex } );

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				group.add( meshes[ i ] );

			}

			return group;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */
	loadCamera( cameraIndex ) {

		let camera;
		const cameraDef = this.json.cameras[ cameraIndex ];
		const params = cameraDef[ cameraDef.type ];

		if ( ! params ) {

			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
			return;

		}

		if ( cameraDef.type === 'perspective' ) {

			camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

		} else if ( cameraDef.type === 'orthographic' ) {

			camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

		}

		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

		assignExtrasToUserData( camera, cameraDef );

		return Promise.resolve( camera );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Object>}
	 */
	loadSkin( skinIndex ) {

		const skinDef = this.json.skins[ skinIndex ];

		const skinEntry = { joints: skinDef.joints };

		if ( skinDef.inverseBindMatrices === undefined ) {

			return Promise.resolve( skinEntry );

		}

		return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

			skinEntry.inverseBindMatrices = accessor;

			return skinEntry;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */
	loadAnimation( animationIndex ) {

		const json = this.json;

		const animationDef = json.animations[ animationIndex ];

		const pendingNodes = [];
		const pendingInputAccessors = [];
		const pendingOutputAccessors = [];
		const pendingSamplers = [];
		const pendingTargets = [];

		for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

			const channel = animationDef.channels[ i ];
			const sampler = animationDef.samplers[ channel.sampler ];
			const target = channel.target;
			const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
			const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
			const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

			pendingNodes.push( this.getDependency( 'node', name ) );
			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
			pendingSamplers.push( sampler );
			pendingTargets.push( target );

		}

		return Promise.all( [

			Promise.all( pendingNodes ),
			Promise.all( pendingInputAccessors ),
			Promise.all( pendingOutputAccessors ),
			Promise.all( pendingSamplers ),
			Promise.all( pendingTargets )

		] ).then( function ( dependencies ) {

			const nodes = dependencies[ 0 ];
			const inputAccessors = dependencies[ 1 ];
			const outputAccessors = dependencies[ 2 ];
			const samplers = dependencies[ 3 ];
			const targets = dependencies[ 4 ];

			const tracks = [];

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				const node = nodes[ i ];
				const inputAccessor = inputAccessors[ i ];
				const outputAccessor = outputAccessors[ i ];
				const sampler = samplers[ i ];
				const target = targets[ i ];

				if ( node === undefined ) continue;

				node.updateMatrix();
				node.matrixAutoUpdate = true;

				let TypedKeyframeTrack;

				switch ( PATH_PROPERTIES[ target.path ] ) {

					case PATH_PROPERTIES.weights:

						TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;
						break;

					case PATH_PROPERTIES.rotation:

						TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;
						break;

					case PATH_PROPERTIES.position:
					case PATH_PROPERTIES.scale:
					default:

						TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;
						break;

				}

				const targetName = node.name ? node.name : node.uuid;

				const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;

				const targetNames = [];

				if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

					node.traverse( function ( object ) {

						if ( object.morphTargetInfluences ) {

							targetNames.push( object.name ? object.name : object.uuid );

						}

					} );

				} else {

					targetNames.push( targetName );

				}

				let outputArray = outputAccessor.array;

				if ( outputAccessor.normalized ) {

					const scale = getNormalizedComponentScale( outputArray.constructor );
					const scaled = new Float32Array( outputArray.length );

					for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

						scaled[ j ] = outputArray[ j ] * scale;

					}

					outputArray = scaled;

				}

				for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

					const track = new TypedKeyframeTrack(
						targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
						inputAccessor.array,
						outputArray,
						interpolation
					);

					// Override interpolation with custom factory method.
					if ( sampler.interpolation === 'CUBICSPLINE' ) {

						track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

							// A CUBICSPLINE keyframe in glTF has three output values for each input value,
							// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
							// must be divided by three to get the interpolant's sampleSize argument.

							const interpolantType = ( this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

							return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

						};

						// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
						track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

					}

					tracks.push( track );

				}

			}

			const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

			return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip( name, undefined, tracks );

		} );

	}

	createNodeMesh( nodeIndex ) {

		const json = this.json;
		const parser = this;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( nodeDef.mesh === undefined ) return null;

		return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

			const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

			// if weights are provided on the node, override weights on the mesh.
			if ( nodeDef.weights !== undefined ) {

				node.traverse( function ( o ) {

					if ( ! o.isMesh ) return;

					for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

						o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

					}

				} );

			}

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */
	loadNode( nodeIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const parser = this;

		const nodeDef = json.nodes[ nodeIndex ];

		// reserve node's name before its dependencies, so the root has the intended name.
		const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

		return ( function () {

			const pending = [];

			const meshPromise = parser._invokeOne( function ( ext ) {

				return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

			} );

			if ( meshPromise ) {

				pending.push( meshPromise );

			}

			if ( nodeDef.camera !== undefined ) {

				pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

					return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

				} ) );

			}

			parser._invokeAll( function ( ext ) {

				return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

			} ).forEach( function ( promise ) {

				pending.push( promise );

			} );

			return Promise.all( pending );

		}() ).then( function ( objects ) {

			let node;

			// .isBone isn't in glTF spec. See ._markDefs
			if ( nodeDef.isBone === true ) {

				node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();

			} else if ( objects.length > 1 ) {

				node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();

			} else if ( objects.length === 1 ) {

				node = objects[ 0 ];

			} else {

				node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();

			}

			if ( node !== objects[ 0 ] ) {

				for ( let i = 0, il = objects.length; i < il; i ++ ) {

					node.add( objects[ i ] );

				}

			}

			if ( nodeDef.name ) {

				node.userData.name = nodeDef.name;
				node.name = nodeName;

			}

			assignExtrasToUserData( node, nodeDef );

			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

			if ( nodeDef.matrix !== undefined ) {

				const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
				matrix.fromArray( nodeDef.matrix );
				node.applyMatrix4( matrix );

			} else {

				if ( nodeDef.translation !== undefined ) {

					node.position.fromArray( nodeDef.translation );

				}

				if ( nodeDef.rotation !== undefined ) {

					node.quaternion.fromArray( nodeDef.rotation );

				}

				if ( nodeDef.scale !== undefined ) {

					node.scale.fromArray( nodeDef.scale );

				}

			}

			if ( ! parser.associations.has( node ) ) {

				parser.associations.set( node, {} );

			}

			parser.associations.get( node ).nodes = nodeIndex;

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */
	loadScene( sceneIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const sceneDef = this.json.scenes[ sceneIndex ];
		const parser = this;

		// Loader returns Group, not Scene.
		// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
		const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();
		if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

		assignExtrasToUserData( scene, sceneDef );

		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

		const nodeIds = sceneDef.nodes || [];

		const pending = [];

		for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

			pending.push( buildNodeHierarchy( nodeIds[ i ], scene, json, parser ) );

		}

		return Promise.all( pending ).then( function () {

			// Removes dangling associations, associations that reference a node that
			// didn't make it into the scene.
			const reduceAssociations = ( node ) => {

				const reducedAssociations = new Map();

				for ( const [ key, value ] of parser.associations ) {

					if ( key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture ) {

						reducedAssociations.set( key, value );

					}

				}

				node.traverse( ( node ) => {

					const mappings = parser.associations.get( node );

					if ( mappings != null ) {

						reducedAssociations.set( node, mappings );

					}

				} );

				return reducedAssociations;

			};

			parser.associations = reduceAssociations( scene );

			return scene;

		} );

	}

}

function buildNodeHierarchy( nodeId, parentObject, json, parser ) {

	const nodeDef = json.nodes[ nodeId ];

	return parser.getDependency( 'node', nodeId ).then( function ( node ) {

		if ( nodeDef.skin === undefined ) return node;

		// build skeleton here as well

		let skinEntry;

		return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

			skinEntry = skin;

			const pendingJoints = [];

			for ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

				pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

			}

			return Promise.all( pendingJoints );

		} ).then( function ( jointNodes ) {

			node.traverse( function ( mesh ) {

				if ( ! mesh.isMesh ) return;

				const bones = [];
				const boneInverses = [];

				for ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {

					const jointNode = jointNodes[ j ];

					if ( jointNode ) {

						bones.push( jointNode );

						const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();

						if ( skinEntry.inverseBindMatrices !== undefined ) {

							mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

						}

						boneInverses.push( mat );

					} else {

						console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

					}

				}

				mesh.bind( new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton( bones, boneInverses ), mesh.matrixWorld );

			} );

			return node;

		} );

	} ).then( function ( node ) {

		// build node hierachy

		parentObject.add( node );

		const pending = [];

		if ( nodeDef.children ) {

			const children = nodeDef.children;

			for ( let i = 0, il = children.length; i < il; i ++ ) {

				const child = children[ i ];
				pending.push( buildNodeHierarchy( child, node, json, parser ) );

			}

		}

		return Promise.all( pending );

	} );

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */
function computeBounds( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();

	if ( attributes.POSITION !== undefined ) {

		const accessor = parser.json.accessors[ attributes.POSITION ];

		const min = accessor.min;
		const max = accessor.max;

		// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

		if ( min !== undefined && max !== undefined ) {

			box.set(
				new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
				new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
			);

			if ( accessor.normalized ) {

				const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
				box.min.multiplyScalar( boxScale );
				box.max.multiplyScalar( boxScale );

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

			return;

		}

	} else {

		return;

	}

	const targets = primitiveDef.targets;

	if ( targets !== undefined ) {

		const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( target.POSITION !== undefined ) {

				const accessor = parser.json.accessors[ target.POSITION ];
				const min = accessor.min;
				const max = accessor.max;

				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

				if ( min !== undefined && max !== undefined ) {

					// we need to get max of absolute components because target weight is [-1,1]
					vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
					vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
					vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


					if ( accessor.normalized ) {

						const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
						vector.multiplyScalar( boxScale );

					}

					// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
					// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
					// are used to implement key-frame animations and as such only two are active at a time - this results in very large
					// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
					maxDisplacement.max( vector );

				} else {

					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

				}

			}

		}

		// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
		box.expandByVector( maxDisplacement );

	}

	geometry.boundingBox = box;

	const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();

	box.getCenter( sphere.center );
	sphere.radius = box.min.distanceTo( box.max ) / 2;

	geometry.boundingSphere = sphere;

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const pending = [];

	function assignAttributeAccessor( accessorIndex, attributeName ) {

		return parser.getDependency( 'accessor', accessorIndex )
			.then( function ( accessor ) {

				geometry.setAttribute( attributeName, accessor );

			} );

	}

	for ( const gltfAttributeName in attributes ) {

		const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

		// Skip attributes already provided by e.g. Draco extension.
		if ( threeAttributeName in geometry.attributes ) continue;

		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

	}

	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

		const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

			geometry.setIndex( accessor );

		} );

		pending.push( accessor );

	}

	assignExtrasToUserData( geometry, primitiveDef );

	computeBounds( geometry, primitiveDef, parser );

	return Promise.all( pending ).then( function () {

		return primitiveDef.targets !== undefined
			? addMorphTargets( geometry, primitiveDef.targets, parser )
			: geometry;

	} );

}

/**
 * @param {BufferGeometry} geometry
 * @param {Number} drawMode
 * @return {BufferGeometry}
 */
function toTrianglesDrawMode( geometry, drawMode ) {

	let index = geometry.getIndex();

	// generate index if not present

	if ( index === null ) {

		const indices = [];

		const position = geometry.getAttribute( 'position' );

		if ( position !== undefined ) {

			for ( let i = 0; i < position.count; i ++ ) {

				indices.push( i );

			}

			geometry.setIndex( indices );
			index = geometry.getIndex();

		} else {

			console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
			return geometry;

		}

	}

	//

	const numberOfTriangles = index.count - 2;
	const newIndices = [];

	if ( drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode ) {

		// gl.TRIANGLE_FAN

		for ( let i = 1; i <= numberOfTriangles; i ++ ) {

			newIndices.push( index.getX( 0 ) );
			newIndices.push( index.getX( i ) );
			newIndices.push( index.getX( i + 1 ) );

		}

	} else {

		// gl.TRIANGLE_STRIP

		for ( let i = 0; i < numberOfTriangles; i ++ ) {

			if ( i % 2 === 0 ) {

				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );
				newIndices.push( index.getX( i + 2 ) );


			} else {

				newIndices.push( index.getX( i + 2 ) );
				newIndices.push( index.getX( i + 1 ) );
				newIndices.push( index.getX( i ) );

			}

		}

	}

	if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

		console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

	}

	// build final geometry

	const newGeometry = geometry.clone();
	newGeometry.setIndex( newIndices );

	return newGeometry;

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/RGBELoader.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/RGBELoader.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RGBELoader": () => (/* binding */ RGBELoader)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


// https://github.com/mrdoob/three.js/issues/5552
// http://en.wikipedia.org/wiki/RGBE_image_format

class RGBELoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {

	constructor( manager ) {

		super( manager );

		this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;

	}

	// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html

	parse( buffer ) {

		const
			/* return codes for rgbe routines */
			//RGBE_RETURN_SUCCESS = 0,
			RGBE_RETURN_FAILURE = - 1,

			/* default error routine.  change this to change error handling */
			rgbe_read_error = 1,
			rgbe_write_error = 2,
			rgbe_format_error = 3,
			rgbe_memory_error = 4,
			rgbe_error = function ( rgbe_error_code, msg ) {

				switch ( rgbe_error_code ) {

					case rgbe_read_error: console.error( 'THREE.RGBELoader Read Error: ' + ( msg || '' ) );
						break;
					case rgbe_write_error: console.error( 'THREE.RGBELoader Write Error: ' + ( msg || '' ) );
						break;
					case rgbe_format_error: console.error( 'THREE.RGBELoader Bad File Format: ' + ( msg || '' ) );
						break;
					default:
					case rgbe_memory_error: console.error( 'THREE.RGBELoader: Error: ' + ( msg || '' ) );

				}

				return RGBE_RETURN_FAILURE;

			},

			/* offsets to red, green, and blue components in a data (float) pixel */
			//RGBE_DATA_RED = 0,
			//RGBE_DATA_GREEN = 1,
			//RGBE_DATA_BLUE = 2,

			/* number of floats per pixel, use 4 since stored in rgba image format */
			//RGBE_DATA_SIZE = 4,

			/* flags indicating which fields in an rgbe_header_info are valid */
			RGBE_VALID_PROGRAMTYPE = 1,
			RGBE_VALID_FORMAT = 2,
			RGBE_VALID_DIMENSIONS = 4,

			NEWLINE = '\n',

			fgets = function ( buffer, lineLimit, consume ) {

				const chunkSize = 128;

				lineLimit = ! lineLimit ? 1024 : lineLimit;
				let p = buffer.pos,
					i = - 1, len = 0, s = '',
					chunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				while ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {

					s += chunk; len += chunk.length;
					p += chunkSize;
					chunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				}

				if ( - 1 < i ) {

					/*for (i=l-1; i>=0; i--) {
						byteCode = m.charCodeAt(i);
						if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
						else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
						if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
					}*/
					if ( false !== consume ) buffer.pos += len + i + 1;
					return s + chunk.slice( 0, i );

				}

				return false;

			},

			/* minimal header reading.  modify if you want to parse more information */
			RGBE_ReadHeader = function ( buffer ) {


				// regexes to parse header info fields
				const magic_token_re = /^#\?(\S+)/,
					gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
					exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
					format_re = /^\s*FORMAT=(\S+)\s*$/,
					dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,

					// RGBE format header struct
					header = {

						valid: 0, /* indicate which fields are valid */

						string: '', /* the actual header string */

						comments: '', /* comments found in header */

						programtype: 'RGBE', /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */

						format: '', /* RGBE format, default 32-bit_rle_rgbe */

						gamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */

						exposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */

						width: 0, height: 0 /* image dimensions, width/height */

					};

				let line, match;

				if ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {

					return rgbe_error( rgbe_read_error, 'no header found' );

				}

				/* if you want to require the magic token then uncomment the next line */
				if ( ! ( match = line.match( magic_token_re ) ) ) {

					return rgbe_error( rgbe_format_error, 'bad initial token' );

				}

				header.valid |= RGBE_VALID_PROGRAMTYPE;
				header.programtype = match[ 1 ];
				header.string += line + '\n';

				while ( true ) {

					line = fgets( buffer );
					if ( false === line ) break;
					header.string += line + '\n';

					if ( '#' === line.charAt( 0 ) ) {

						header.comments += line + '\n';
						continue; // comment line

					}

					if ( match = line.match( gamma_re ) ) {

						header.gamma = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( exposure_re ) ) {

						header.exposure = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( format_re ) ) {

						header.valid |= RGBE_VALID_FORMAT;
						header.format = match[ 1 ];//'32-bit_rle_rgbe';

					}

					if ( match = line.match( dimensions_re ) ) {

						header.valid |= RGBE_VALID_DIMENSIONS;
						header.height = parseInt( match[ 1 ], 10 );
						header.width = parseInt( match[ 2 ], 10 );

					}

					if ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;

				}

				if ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {

					return rgbe_error( rgbe_format_error, 'missing format specifier' );

				}

				if ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {

					return rgbe_error( rgbe_format_error, 'missing image size specifier' );

				}

				return header;

			},

			RGBE_ReadPixels_RLE = function ( buffer, w, h ) {

				const scanline_width = w;

				if (
					// run length encoding is not allowed so read flat
					( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||
					// this file is not run length encoded
					( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )
				) {

					// return the flat buffer
					return new Uint8Array( buffer );

				}

				if ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {

					return rgbe_error( rgbe_format_error, 'wrong scanline width' );

				}

				const data_rgba = new Uint8Array( 4 * w * h );

				if ( ! data_rgba.length ) {

					return rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );

				}

				let offset = 0, pos = 0;

				const ptr_end = 4 * scanline_width;
				const rgbeStart = new Uint8Array( 4 );
				const scanline_buffer = new Uint8Array( ptr_end );
				let num_scanlines = h;

				// read in each successive scanline
				while ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {

					if ( pos + 4 > buffer.byteLength ) {

						return rgbe_error( rgbe_read_error );

					}

					rgbeStart[ 0 ] = buffer[ pos ++ ];
					rgbeStart[ 1 ] = buffer[ pos ++ ];
					rgbeStart[ 2 ] = buffer[ pos ++ ];
					rgbeStart[ 3 ] = buffer[ pos ++ ];

					if ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {

						return rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );

					}

					// read each of the four channels for the scanline into the buffer
					// first red, then green, then blue, then exponent
					let ptr = 0, count;

					while ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {

						count = buffer[ pos ++ ];
						const isEncodedRun = count > 128;
						if ( isEncodedRun ) count -= 128;

						if ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {

							return rgbe_error( rgbe_format_error, 'bad scanline data' );

						}

						if ( isEncodedRun ) {

							// a (encoded) run of the same value
							const byteValue = buffer[ pos ++ ];
							for ( let i = 0; i < count; i ++ ) {

								scanline_buffer[ ptr ++ ] = byteValue;

							}
							//ptr += count;

						} else {

							// a literal-run
							scanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );
							ptr += count; pos += count;

						}

					}


					// now convert data from buffer into rgba
					// first red, then green, then blue, then exponent (alpha)
					const l = scanline_width; //scanline_buffer.byteLength;
					for ( let i = 0; i < l; i ++ ) {

						let off = 0;
						data_rgba[ offset ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 1 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 2 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 3 ] = scanline_buffer[ i + off ];
						offset += 4;

					}

					num_scanlines --;

				}

				return data_rgba;

			};

		const RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			destArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;
			destArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;
			destArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;
			destArray[ destOffset + 3 ] = 1;

		};

		const RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			// clamping to 65504, the maximum representable value in float16
			destArray[ destOffset + 0 ] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );
			destArray[ destOffset + 1 ] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );
			destArray[ destOffset + 2 ] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );
			destArray[ destOffset + 3 ] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat( 1 );

		};

		const byteArray = new Uint8Array( buffer );
		byteArray.pos = 0;
		const rgbe_header_info = RGBE_ReadHeader( byteArray );

		if ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {

			const w = rgbe_header_info.width,
				h = rgbe_header_info.height,
				image_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );

			if ( RGBE_RETURN_FAILURE !== image_rgba_data ) {

				let data, format, type;
				let numElements;

				switch ( this.type ) {

					case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:

						numElements = image_rgba_data.length / 4;
						const floatArray = new Float32Array( numElements * 4 );

						for ( let j = 0; j < numElements; j ++ ) {

							RGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );

						}

						data = floatArray;
						type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;
						break;

					case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:

						numElements = image_rgba_data.length / 4;
						const halfArray = new Uint16Array( numElements * 4 );

						for ( let j = 0; j < numElements; j ++ ) {

							RGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );

						}

						data = halfArray;
						type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;
						break;

					default:

						console.error( 'THREE.RGBELoader: unsupported type: ', this.type );
						break;

				}

				return {
					width: w, height: h,
					data: data,
					header: rgbe_header_info.string,
					gamma: rgbe_header_info.gamma,
					exposure: rgbe_header_info.exposure,
					format: format,
					type: type
				};

			}

		}

		return null;

	}

	setDataType( value ) {

		this.type = value;
		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		function onLoadCallback( texture, texData ) {

			switch ( texture.type ) {

				case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:

					texture.encoding = three__WEBPACK_IMPORTED_MODULE_0__.LinearEncoding;
					texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;
					texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;
					texture.generateMipmaps = false;
					texture.flipY = true;
					break;

				case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:

					texture.encoding = three__WEBPACK_IMPORTED_MODULE_0__.LinearEncoding;
					texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;
					texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;
					texture.generateMipmaps = false;
					texture.flipY = true;
					break;

			}

			if ( onLoad ) onLoad( texture, texData );

		}

		return super.load( url, onLoadCallback, onProgress, onError );

	}

}




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"bundle": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _style_main_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style/main.scss */ "./src/style/main.scss");
/* harmony import */ var three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ "./node_modules/three/examples/jsm/loaders/GLTFLoader.js");
/* harmony import */ var three_examples_jsm_loaders_RGBELoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/loaders/RGBELoader */ "./node_modules/three/examples/jsm/loaders/RGBELoader.js");
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gsap */ "./node_modules/gsap/index.js");
/* harmony import */ var _particles_twirl_03_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./particles/twirl_03.png */ "./src/particles/twirl_03.png");
/* harmony import */ var _hdri_gamrig_1k_hdr__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hdri/gamrig_1k.hdr */ "./src/hdri/gamrig_1k.hdr");




 // ----------------- Canvas -----------------

var canvas_1 = document.querySelector('canvas.canvas-1'); // ----------------- Scene -----------------

var scene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene(); // ----------------- Particles -----------------


var textureLoader = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader();
var particleTexture = textureLoader.load(_particles_twirl_03_png__WEBPACK_IMPORTED_MODULE_4__["default"]); // Geometry

var particlesGeometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();
var count = 20000;
var positions = new Float32Array(count * 3);

for (var i = 0; i < count * 3; i++) {
  positions[i] = (Math.random() - 0.5) * 100;
}

particlesGeometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_3__.BufferAttribute(positions, 3)); // Material

var particlesMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.PointsMaterial();
particlesMaterial.size = 0.25;
particlesMaterial.sizeAttenuation = true;
particlesMaterial.color = new three__WEBPACK_IMPORTED_MODULE_3__.Color('#7161F5');
particlesMaterial.transparent = true;
particlesMaterial.alphaMap = particleTexture; // Points

var particles = new three__WEBPACK_IMPORTED_MODULE_3__.Points(particlesGeometry, particlesMaterial);
scene.add(particles);
gsap__WEBPACK_IMPORTED_MODULE_5__.gsap.to(particles.rotation, {
  duration: 1000,
  delay: 0,
  y: -5,
  repeat: -1
}); // ----------------- Sizes -----------------

var sizes = {
  width: window.innerWidth,
  height: window.innerHeight
}; // ----------------- Camera -----------------

var camera = new three__WEBPACK_IMPORTED_MODULE_3__.PerspectiveCamera(30, sizes.width / sizes.height, 0.1, 1000);
camera.position.x = -1;
camera.position.y = 0;
camera.position.z = 6; // ----------------- Lights -----------------

var hemiLight = new three__WEBPACK_IMPORTED_MODULE_3__.HemisphereLight(0xffeeb1, 0x080820, 4);
scene.add(hemiLight);
var spotLight = new three__WEBPACK_IMPORTED_MODULE_3__.SpotLight(0xffffff, 4);
spotLight.position.set(-50, 50, 50);
spotLight.castShadow = true;
spotLight.shadow.bias = -0.0001;
spotLight.shadow.mapSize.width = 1024 * 4;
spotLight.shadow.mapSize.height = 1024 * 4;
scene.add(spotLight); // ----------------- HDRI -----------------


new three_examples_jsm_loaders_RGBELoader__WEBPACK_IMPORTED_MODULE_2__.RGBELoader().load(_hdri_gamrig_1k_hdr__WEBPACK_IMPORTED_MODULE_6__["default"], function (texture) {
  texture.mapping = three__WEBPACK_IMPORTED_MODULE_3__.EquirectangularReflectionMapping;
  scene.environment = texture;
}); // ----------------- 3d models -----------------
// import sphere from './models/sphere2.gltf'
// let modelsDistance = 5
// // Model 1
// let model_1 = new GLTFLoader()
// model_1.load("../src/models/sphere2.gltf", function (gltf) {
//     model_1 = gltf.scene
//     gltf.scene.scale.set(1, 1, 1)
//     gltf.scene.position.set(0, 0, 0)
//     gltf.scene.position.y = -modelsDistance * 0
//     const newMaterial = new THREE.MeshPhysicalMaterial({
//         color: 0x7161F5,
//         metalness: 1,
//         roughness: 0,
//         transmission: 1,
//         thickness: 0,
//     })
//     model_1.traverse((o) => {
//         if (o.isMesh) o.material = newMaterial
//     })
//     model_1.traverse(n => {
//         if (n.isMesh) {
//             n.castShadow = true
//             n.receiveShadow = true
//             if (n.material.map) n.material.map.anisotropy = 16
//         }
//     })
//     // Animation
//     gsap.to(model_1.rotation, {
//         duration: 500,
//         delay: 0,
//         y: -15,
//         repeat: -1
//     })
//     scene.add(model_1)
// })
// // Model 2
// let model_2 = new GLTFLoader()
// model_2.load("../src/models/sphere2.gltf", function (gltf) {
//     model_2 = gltf.scene
//     gltf.scene.scale.set(1, 1, 1)
//     gltf.scene.position.set(-0.5, 0, -3)
//     gltf.scene.position.y = -modelsDistance * 1
//     const newMaterial = new THREE.MeshPhysicalMaterial({
//         color: 0xF57061,
//         metalness: 1,
//         roughness: 0,
//         transmission: 1,
//         thickness: 0,
//     })
//     model_2.traverse((o) => {
//         if (o.isMesh) o.material = newMaterial
//     })
//     model_2.traverse(n => {
//         if (n.isMesh) {
//             n.castShadow = true
//             n.receiveShadow = true
//             if (n.material.map) n.material.map.anisotropy = 16
//         }
//     })
//     // Animation
//     gsap.to(model_2.rotation, {
//         duration: 500,
//         delay: 0,
//         y: -15,
//         repeat: -1
//     })
//     scene.add(model_2)
// })
// // Model 3
// let model_3 = new GLTFLoader()
// model_3.load("../src/models/sphere2.gltf", function (gltf) {
//     model_3 = gltf.scene
//     gltf.scene.scale.set(1, 1, 1)
//     gltf.scene.position.set(-2, 0, -1)
//     gltf.scene.position.y = -modelsDistance * 2
//     const newMaterial = new THREE.MeshPhysicalMaterial({
//         color: 0x61F570,
//         metalness: 1,
//         roughness: 0,
//         transmission: 1,
//         thickness: 0,
//     })
//     model_3.traverse((o) => {
//         if (o.isMesh) o.material = newMaterial
//     })
//     model_3.traverse(n => {
//         if (n.isMesh) {
//             n.castShadow = true
//             n.receiveShadow = true
//             if (n.material.map) n.material.map.anisotropy = 16
//         }
//     })
//     // Animation
//     gsap.to(model_3.rotation, {
//         duration: 500,
//         delay: 0,
//         y: -15,
//         repeat: -1
//     })
//     scene.add(model_3)
// })
// // Model 4
// let model_4 = new GLTFLoader()
// model_4.load("../src/models/sphere2.gltf", function (gltf) {
//     model_4 = gltf.scene
//     gltf.scene.scale.set(1, 1, 1)
//     gltf.scene.position.set(0.5, 0, -4)
//     gltf.scene.position.y = -modelsDistance * 2.75
//     // Material
//     const newMaterial = new THREE.MeshPhysicalMaterial({
//         color: 0x7161F5,
//         metalness: 0.9,
//         roughness: 0.1,
//         transmission: 0.9,
//         thickness: 0.1,
//     })
//     model_4.traverse((o) => {
//         if (o.isMesh) o.material = newMaterial
//     })
//     model_4.traverse(n => {
//         if (n.isMesh) {
//             n.castShadow = true
//             n.receiveShadow = true
//             if (n.material.map) n.material.map.anisotropy = 16
//         }
//     })
//     // Animation
//     gsap.to(model_4.rotation, {
//         duration: 500,
//         delay: 0,
//         y: -15,
//         repeat: -1
//     })
//     scene.add(model_4)
// })
// // Model 5
// let model_5 = new GLTFLoader()
// model_5.load("../src/models/sphere2.gltf", function (gltf) {
//     model_5 = gltf.scene
//     gltf.scene.scale.set(1, 1, 1)
//     gltf.scene.position.set(-2.5, 0, -1)
//     gltf.scene.position.y = -modelsDistance * 3.6
//     // Material
//     const newMaterial = new THREE.MeshPhysicalMaterial({
//         color: 0x040117,
//         metalness: 0.9,
//         roughness: 0.1,
//         transmission: 0.9,
//         thickness: 0.1,
//     })
//     model_5.traverse((o) => {
//         if (o.isMesh) o.material = newMaterial
//     })
//     model_5.traverse(n => {
//         if (n.isMesh) {
//             n.castShadow = true
//             n.receiveShadow = true
//             if (n.material.map) n.material.map.anisotropy = 16
//         }
//     })
//     // Animation
//     gsap.to(model_5.rotation, {
//         duration: 500,
//         delay: 0,
//         y: -15,
//         repeat: -1
//     })
//     scene.add(model_5)
// })
// // Model 6
// let model_6 = new GLTFLoader()
// model_6.load("../src/models/sphere2.gltf", function (gltf) {
//     model_6 = gltf.scene
//     gltf.scene.scale.set(1, 1, 1)
//     gltf.scene.position.set(-1, 0, -1)
//     gltf.scene.position.y = -modelsDistance * 4.65
//     // Material
//     const newMaterial = new THREE.MeshPhysicalMaterial({
//         color: 0x61F570,
//         metalness: 0.9,
//         roughness: 0.1,
//         transmission: 0.9,
//         thickness: 0.1,
//     })
//     model_6.traverse((o) => {
//         if (o.isMesh) o.material = newMaterial
//     })
//     model_6.traverse(n => {
//         if (n.isMesh) {
//             n.castShadow = true
//             n.receiveShadow = true
//             if (n.material.map) n.material.map.anisotropy = 16
//         }
//     })
//     // Animation
//     gsap.to(model_6.rotation, {
//         duration: 500,
//         delay: 0,
//         y: -15,
//         repeat: -1
//     })
//     scene.add(model_6)
// })
// // Model 7
// let model_7 = new GLTFLoader()
// model_7.load("../src/models/sphere2.gltf", function (gltf) {
//     model_7 = gltf.scene
//     gltf.scene.scale.set(1, 1, 1)
//     gltf.scene.position.set(-2.5, 0, -1.5)
//     gltf.scene.position.y = -modelsDistance * 5.65
//     // Material
//     const newMaterial = new THREE.MeshPhysicalMaterial({
//         color: 0x040117,
//         metalness: 0.9,
//         roughness: 0.1,
//         transmission: 0.9,
//         thickness: 0.1,
//     })
//     model_7.traverse((o) => {
//         if (o.isMesh) o.material = newMaterial
//     })
//     model_7.traverse(n => {
//         if (n.isMesh) {
//             n.castShadow = true
//             n.receiveShadow = true
//             if (n.material.map) n.material.map.anisotropy = 16
//         }
//     })
//     // Animation
//     gsap.to(model_7.rotation, {
//         duration: 500,
//         delay: 0,
//         y: -15,
//         repeat: -1
//     })
//     scene.add(model_7)
// })
// ----------------- Render -----------------
// Render 1

var renderer = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderer({
  canvas: canvas_1,
  antialias: true,
  alpha: true
});
renderer.toneMapping = three__WEBPACK_IMPORTED_MODULE_3__.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1;
renderer.outputEncoding = three__WEBPACK_IMPORTED_MODULE_3__.sRGBEncoding;
renderer.setSize(sizes.width, sizes.height);
document.body.appendChild(renderer.domElement); // ----------------- Section paralax -----------------

var scrollY = window.scrollY;
window.addEventListener('scroll', function () {
  scrollY = window.scrollY;
}); // ----------------- Orbit controls -----------------
// const controls = new OrbitControls(camera, renderer.domElement)
// controls.autoRotate = true
// controls.autoRotateSpeed = -0.25
// controls.enableDamping = true
// controls.enableZoom = false
// ----------------- Helpers -----------------
// const gridHelper = new THREE.GridHelper(10, 10)
// scene.add(gridHelper)
// const axesHelper = new THREE.AxesHelper(5)
// scene.add(axesHelper)
// ----------------- GUI -----------------/
// const gui = new GUI()
// gui.add(directionalLight, 'intensity').min(0).max(1).step(0.001).name('directionalLight intensity')
// gui.addColor(directionalLight, 'color').name('directionalLight color')
// gui.add(directionalLight.position, 'x').min(- 3).max(3).step(0.01).name('directionalLight X')
// gui.add(directionalLight.position, 'y').min(- 3).max(3).step(0.01).name('directionalLight Y')
// gui.add(directionalLight.position, 'z').min(- 3).max(3).step(0.01).name('directionalLight Z')
// ----------------- Clock -----------------/

var clock = new three__WEBPACK_IMPORTED_MODULE_3__.Clock();

var tick = function tick() {
  var elapsedTime = clock.getElapsedTime(); // Animate camera
  // camera.position.y = -scrollY / sizes.height * modelsDistance
  // Render

  renderer.render(scene, camera); // Call tick again on the next frame

  window.requestAnimationFrame(tick);
};

tick(); // ----------------- Animation -----------------

function animate() {
  requestAnimationFrame(animate); // spotLight.position.set(
  //     camera.position.x + 10,
  //     camera.position.y + 10,
  //     camera.position.z + 10
  // )
  // controls.update()

  renderer.render(scene, camera);
}

animate(); // ----------------- Resize -----------------

function onWindowResize() {
  // Update sizes
  sizes.width = window.innerWidth;
  sizes.height = window.innerHeight; // Update camera

  camera.aspect = sizes.width / sizes.height;
  camera.updateProjectionMatrix(); // Update renderer

  renderer.setSize(sizes.width, sizes.height); // Casting shadows

  renderer.shadowMap.enabled = true;
}

window.addEventListener('resize', onWindowResize, false);
})();

/******/ })()
;
//# sourceMappingURL=bundle.js.map